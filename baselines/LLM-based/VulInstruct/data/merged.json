[
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "AutoconfTextHover.java",
        "method_name": "build/org.eclipse.cdt.autotools.ui/src/org/eclipse/cdt/internal/autotools/ui/text/hover/AutoconfTextHover.java#getAMDoc",
        "raw_code": "protected static Document getAMDoc(String amDocVer) {\n\t\tDocument amDocument = null;\n\t\tif (amHoverDocs == null) {\n\t\t\tamHoverDocs = new HashMap<>();\n\t\t}\n\t\tamDocument = amHoverDocs.get(amDocVer);\n\t\tif (amDocument == null) {\n\t\t\tDocument doc = null;\n\t\t\ttry {\n\t\t\t\t// see comment in initialize()\n\t\t\t\ttry {\n\t\t\t\t\tInputStream docStream = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tURI uri = new URI(getLocalAutomakeMacrosDocName(amDocVer));\n\t\t\t\t\t\tIPath p = URIUtil.toPath(uri);\n\t\t\t\t\t\t// Try to open the file as local to this plug-in.\n\t\t\t\t\t\tdocStream = FileLocator.openStream(AutotoolsUIPlugin.getDefault().getBundle(), p, false);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Local open failed.  Try normal external location.\n\t\t\t\t\t\tURI acDoc = new URI(getAutomakeMacrosDocName(amDocVer));\n\t\t\t\t\t\tIPath p = URIUtil.toPath(acDoc);\n\t\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\t\tURL url = acDoc.toURL();\n\t\t\t\t\t\t\tdocStream = url.openStream();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocStream = new FileInputStream(p.toFile());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\t\t\tfactory.setValidating(false);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\t\t\t\tdoc = builder.parse(docStream);\n\t\t\t\t\t} catch (SAXException | ParserConfigurationException | IOException ex) {\n\t\t\t\t\t\tdoc = null;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (docStream != null)\n\t\t\t\t\t\t\tdocStream.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (FileNotFoundException | MalformedURLException | URISyntaxException e) {\n\t\t\t\t\tAutotoolsPlugin.log(e);\n\t\t\t\t}\n\t\t\t\tamDocument = doc;\n\t\t\t} catch (IOException ioe) {\n\t\t\t}\n\t\t}\n\t\tamHoverDocs.put(amDocVer, amDocument);\n\t\treturn amDocument;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AutoconfTextHover.java",
        "method_name": "build/org.eclipse.cdt.autotools.ui/src/org/eclipse/cdt/internal/autotools/ui/text/hover/AutoconfTextHover.java#getAMDoc",
        "raw_code": "protected static Document getAMDoc(String amDocVer) {\n\t\tDocument amDocument = null;\n\t\tif (amHoverDocs == null) {\n\t\t\tamHoverDocs = new HashMap<>();\n\t\t}\n\t\tamDocument = amHoverDocs.get(amDocVer);\n\t\tif (amDocument == null) {\n\t\t\tDocument doc = null;\n\t\t\ttry {\n\t\t\t\t// see comment in initialize()\n\t\t\t\ttry {\n\t\t\t\t\tInputStream docStream = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tURI uri = new URI(getLocalAutomakeMacrosDocName(amDocVer));\n\t\t\t\t\t\tIPath p = URIUtil.toPath(uri);\n\t\t\t\t\t\t// Try to open the file as local to this plug-in.\n\t\t\t\t\t\tdocStream = FileLocator.openStream(AutotoolsUIPlugin.getDefault().getBundle(), p, false);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Local open failed.  Try normal external location.\n\t\t\t\t\t\tURI acDoc = new URI(getAutomakeMacrosDocName(amDocVer));\n\t\t\t\t\t\tIPath p = URIUtil.toPath(acDoc);\n\t\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\t\tURL url = acDoc.toURL();\n\t\t\t\t\t\t\tdocStream = url.openStream();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocStream = new FileInputStream(p.toFile());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDocumentBuilderFactory factory = XmlProcessorFactoryCdt\n\t\t\t\t\t\t\t.createDocumentBuilderFactoryIgnoringDOCTYPE();\n\t\t\t\t\tfactory.setValidating(false);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\t\t\t\tdoc = builder.parse(docStream);\n\t\t\t\t\t} catch (SAXException | ParserConfigurationException | IOException ex) {\n\t\t\t\t\t\tdoc = null;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (docStream != null)\n\t\t\t\t\t\t\tdocStream.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (FileNotFoundException | MalformedURLException | URISyntaxException e) {\n\t\t\t\t\tAutotoolsPlugin.log(e);\n\t\t\t\t}\n\t\t\t\tamDocument = doc;\n\t\t\t} catch (IOException ioe) {\n\t\t\t}\n\t\t}\n\t\tamHoverDocs.put(amDocVer, amDocument);\n\t\treturn amDocument;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "RoughlyEnoughItems",
    "cve_id": "CVE-2024-42698",
    "cwe_list": [
      "CWE-129"
    ],
    "commit_hash": "e80ca84f1affb91d2388ddb298bfc6b141828cad",
    "short_hash": "e80ca84f",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "InputCleanHandler.java",
        "method_name": "api/src/main/java/me/shedaniel/rei/api/common/transfer/info/clean/InputCleanHandler.java#returnSlotsToPlayerInventory",
        "raw_code": "static <T extends AbstractContainerMenu> void returnSlotsToPlayerInventory(MenuInfoContext<T, ?, ?> context, DumpHandler<T, ?> dumpHandler, SlotAccessor slotAccessor) {\n        ItemStack stackToReturn = slotAccessor.getItemStack();\n        if (!stackToReturn.isEmpty()) {\n            if (!slotAccessor.allowModification(context.getPlayerEntity())) {\n                error(\"rei.rei.no.slot.in.inv\");\n            }\n            \n            for (; !(stackToReturn = slotAccessor.getItemStack()).isEmpty(); slotAccessor.takeStack(1)) {\n                ItemStack stackToInsert = stackToReturn.copy();\n                stackToInsert.setCount(1);\n                if (!dumpGenericsFtw(context, dumpHandler, stackToInsert)) {\n                    error(\"rei.rei.no.slot.in.inv\");\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2024-31981",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "a4ad14d9c1605a5ab957237e505ebbb29f5b9d73",
    "short_hash": "a4ad14d9",
    "vulnerableMethods_before": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#getPDFTemplateProperty",
        "raw_code": "private String getPDFTemplateProperty(String propertyName, XWikiContext context)\n    {\n        String pdftemplate = context.getRequest().getParameter(\"pdftemplate\");\n\n        DocumentReference templateReference;\n        DocumentReference classReference;\n        if (StringUtils.isNotEmpty(pdftemplate)) {\n            templateReference = referenceResolver.resolve(pdftemplate);\n            classReference = new DocumentReference(templateReference.getWikiReference().getName(), \"XWiki\", \"PDFClass\");\n        } else {\n            templateReference = dab.getCurrentDocumentReference();\n            String currentWiki = dab.getCurrentDocumentReference().getRoot().getName();\n            classReference = new DocumentReference(currentWiki, \"XWiki\", \"PDFClass\");\n        }\n\n        String result = (String) dab.getProperty(templateReference, classReference, propertyName);\n        if (StringUtils.isBlank(result)) {\n            return \"\";\n        }\n        String templateName = referenceSerializer.serialize(templateReference);\n        try {\n            StringWriter writer = new StringWriter();\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n            velocityManager.getVelocityEngine().evaluate(vcontext, writer, templateName, result);\n            result = writer.toString();\n        } catch (XWikiVelocityException e) {\n            LOGGER.warn(\"Error applying Velocity to the [{}] property of the [{}] document. Using the property's value \"\n                + \"without applying Velocity.\", propertyName, templateName, ExceptionUtils.getRootCauseMessage(e));\n        }\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#getPDFTemplateProperty",
        "raw_code": "private String getPDFTemplateProperty(String propertyName, XWikiContext context)\n    {\n        String pdftemplate = context.getRequest().getParameter(\"pdftemplate\");\n\n        DocumentReference templateReference;\n        DocumentReference classReference;\n        if (StringUtils.isNotEmpty(pdftemplate)) {\n            templateReference = this.referenceResolver.resolve(pdftemplate);\n            classReference = new DocumentReference(templateReference.getWikiReference().getName(), \"XWiki\", \"PDFClass\");\n        } else {\n            templateReference = this.dab.getCurrentDocumentReference();\n            String currentWiki = this.dab.getCurrentDocumentReference().getRoot().getName();\n            classReference = new DocumentReference(currentWiki, \"XWiki\", \"PDFClass\");\n        }\n\n        String templateContent = (String) this.dab.getProperty(templateReference, classReference, propertyName);\n        if (StringUtils.isBlank(templateContent)) {\n            return \"\";\n        }\n\n        String templateName = this.referenceSerializer.serialize(templateReference);\n        DocumentReference templateAuthorReference;\n        String result = templateContent;\n        try {\n             templateAuthorReference = this.userReferenceSerializer.serialize(\n                 this.dab.getDocumentInstance(templateReference).getAuthors().getEffectiveMetadataAuthor());\n        } catch (Exception e) {\n            LOGGER.warn(\"Error fetching the author of template [{}] during PDF conversion. Using the [{}] property of \"\n                + \"the document's value without applying Velocity.\", templateName, propertyName);\n            return result;\n        }\n\n        if (this.authorizationManager.hasAccess(Right.SCRIPT, templateAuthorReference, templateReference)) {\n            try {\n                result = this.authorExecutor.call(() -> {\n                    StringWriter writer = new StringWriter();\n                    VelocityContext vcontext = this.velocityManager.getVelocityContext();\n                    this.velocityManager.getVelocityEngine().evaluate(vcontext, writer, templateName,\n                        templateContent);\n                    return writer.toString();\n                }, templateAuthorReference, templateReference);\n            } catch (Exception e) {\n                LOGGER.warn(\"Failed to run Velocity engine in author executor. Using the [{}] property of the [{}] \"\n                    + \"document's value without applying Velocity. Reason: [{}]\",\n                    propertyName, templateName, ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "UpdateManagedProject12.java",
        "method_name": "build/org.eclipse.cdt.managedbuilder.core/src/org/eclipse/cdt/managedbuilder/projectconverter/UpdateManagedProject12.java#doProjectUpdate",
        "raw_code": "public static void doProjectUpdate(IProgressMonitor monitor, final IProject project) throws CoreException {\n\t\tString[] projectName = new String[] { project.getName() };\n\t\tIFile file = project.getFile(ManagedBuildManager.SETTINGS_FILE_NAME);\n\t\tFile settingsFile = file.getLocation().toFile();\n\n\t\tif (!settingsFile.exists()) {\n\t\t\tmonitor.done();\n\t\t\treturn;\n\t\t}\n\n\t\t// Backup the file\n\t\tmonitor.beginTask(ConverterMessages.getFormattedString(\"UpdateManagedProject12.0\", projectName), 1); //$NON-NLS-1$\n\t\tIManagedBuildInfo info = ManagedBuildManager.getBuildInfo(project);\n\t\tUpdateManagedProjectManager.backupFile(file, \"_12backup\", monitor, project); //$NON-NLS-1$\n\n\t\tIManagedProject newProject = null;\n\n\t\t//Now convert each target to the new format\n\t\ttry {\n\t\t\t// Load the old build file\n\t\t\tInputStream stream = new FileInputStream(settingsFile);\n\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tDocument document = parser.parse(stream);\n\n\t\t\t// Clone the target based on the proper target definition\n\t\t\tNodeList targetNodes = document.getElementsByTagName(ITarget.TARGET_ELEMENT_NAME);\n\t\t\t// This is a guess, but typically the project has 1 target, 2 configs, and 6 tool defs\n\t\t\tint listSize = targetNodes.getLength();\n\t\t\tmonitor.beginTask(ConverterMessages.getFormattedString(\"UpdateManagedProject12.1\", projectName), //$NON-NLS-1$\n\t\t\t\t\tlistSize * 9);\n\t\t\tfor (int targIndex = 0; targIndex < listSize; ++targIndex) {\n\t\t\t\tElement oldTarget = (Element) targetNodes.item(targIndex);\n\t\t\t\tString oldTargetId = oldTarget.getAttribute(ITarget.ID);\n\t\t\t\tnewProject = convertTarget(project, oldTarget, monitor);\n\t\t\t\t// Remove the old target\n\t\t\t\tif (newProject != null) {\n\t\t\t\t\tinfo.removeTarget(oldTargetId);\n\t\t\t\t\tmonitor.worked(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the default configuration\n\t\t\tNodeList defaultConfiguration = document.getElementsByTagName(IManagedBuildInfo.DEFAULT_CONFIGURATION);\n\t\t\ttry {\n\t\t\t\tElement defaultConfig = (Element) defaultConfiguration.item(0);\n\t\t\t\tString oldDefaultConfigId = defaultConfig.getAttribute(IBuildObject.ID);\n\t\t\t\tIConfiguration newDefaultConfig = getConfigIdMap().get(oldDefaultConfigId);\n\t\t\t\tif (newDefaultConfig != null) {\n\t\t\t\t\tinfo.setDefaultConfiguration(newDefaultConfig);\n\t\t\t\t\tinfo.setSelectedConfiguration(newDefaultConfig);\n\t\t\t\t} else {\n\t\t\t\t\t// The only safe thing to do if there wasn't a default configuration for a built-in\n\t\t\t\t\t// target is to set the first defined configuration as the default\n\t\t\t\t\tIConfiguration[] newConfigs = newProject.getConfigurations();\n\t\t\t\t\tif (newConfigs.length > 0) {\n\t\t\t\t\t\tinfo.setDefaultConfiguration(newConfigs[0]);\n\t\t\t\t\t\tinfo.setSelectedConfiguration(newConfigs[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ManagedBuilderCorePlugin.getUniqueIdentifier(), -1,\n\t\t\t\t\t\tConverterMessages.getFormattedString(\"UpdateManagedProject12.7\", newProject.getName()), null)); //$NON-NLS-1$\n\t\t\t}\n\n\t\t\t// Upgrade the version\n\t\t\t((ManagedBuildInfo) info).setVersion(\"2.1.0\"); //$NON-NLS-1$\n\t\t\tinfo.setValid(true);\n\t\t} catch (CoreException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tthrow new CoreException(\n\t\t\t\t\tnew Status(IStatus.ERROR, ManagedBuilderCorePlugin.getUniqueIdentifier(), -1, e.getMessage(), e));\n\t\t} finally {\n\t\t\t// If the tree is locked spawn a job to this.\n\t\t\tIWorkspace workspace = project.getWorkspace();\n\t\t\t//\t\t\tboolean treeLock = workspace.isTreeLocked();\n\t\t\tISchedulingRule rule = workspace.getRuleFactory().createRule(project);\n\t\t\t//since the java synchronized mechanism is now used for the build info loadding,\n\t\t\t//initiate the job in all cases\n\t\t\t//\t\t\tif (treeLock) {\n\t\t\tWorkspaceJob job = new WorkspaceJob(ConverterMessages.getResourceString(\"UpdateManagedProject.notice\")) { //$NON-NLS-1$\n\t\t\t\t@Override\n\t\t\t\tpublic IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n\t\t\t\t\tManagedBuildManager.saveBuildInfoLegacy(project, false);\n\t\t\t\t\treturn Status.OK_STATUS;\n\t\t\t\t}\n\t\t\t};\n\t\t\tjob.setRule(rule);\n\t\t\tjob.schedule();\n\t\t\t//\t\t\t} else {\n\t\t\t//\t\t\t\tManagedBuildManager.saveBuildInfo(project, false);\n\t\t\t//\t\t\t}\n\t\t\tmonitor.done();\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UpdateManagedProject12.java",
        "method_name": "build/org.eclipse.cdt.managedbuilder.core/src/org/eclipse/cdt/managedbuilder/projectconverter/UpdateManagedProject12.java#doProjectUpdate",
        "raw_code": "public static void doProjectUpdate(IProgressMonitor monitor, final IProject project) throws CoreException {\n\t\tString[] projectName = new String[] { project.getName() };\n\t\tIFile file = project.getFile(ManagedBuildManager.SETTINGS_FILE_NAME);\n\t\tFile settingsFile = file.getLocation().toFile();\n\n\t\tif (!settingsFile.exists()) {\n\t\t\tmonitor.done();\n\t\t\treturn;\n\t\t}\n\n\t\t// Backup the file\n\t\tmonitor.beginTask(ConverterMessages.getFormattedString(\"UpdateManagedProject12.0\", projectName), 1); //$NON-NLS-1$\n\t\tIManagedBuildInfo info = ManagedBuildManager.getBuildInfo(project);\n\t\tUpdateManagedProjectManager.backupFile(file, \"_12backup\", monitor, project); //$NON-NLS-1$\n\n\t\tIManagedProject newProject = null;\n\n\t\t//Now convert each target to the new format\n\t\ttry {\n\t\t\t// Load the old build file\n\t\t\tInputStream stream = new FileInputStream(settingsFile);\n\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument document = parser.parse(stream);\n\n\t\t\t// Clone the target based on the proper target definition\n\t\t\tNodeList targetNodes = document.getElementsByTagName(ITarget.TARGET_ELEMENT_NAME);\n\t\t\t// This is a guess, but typically the project has 1 target, 2 configs, and 6 tool defs\n\t\t\tint listSize = targetNodes.getLength();\n\t\t\tmonitor.beginTask(ConverterMessages.getFormattedString(\"UpdateManagedProject12.1\", projectName), //$NON-NLS-1$\n\t\t\t\t\tlistSize * 9);\n\t\t\tfor (int targIndex = 0; targIndex < listSize; ++targIndex) {\n\t\t\t\tElement oldTarget = (Element) targetNodes.item(targIndex);\n\t\t\t\tString oldTargetId = oldTarget.getAttribute(ITarget.ID);\n\t\t\t\tnewProject = convertTarget(project, oldTarget, monitor);\n\t\t\t\t// Remove the old target\n\t\t\t\tif (newProject != null) {\n\t\t\t\t\tinfo.removeTarget(oldTargetId);\n\t\t\t\t\tmonitor.worked(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the default configuration\n\t\t\tNodeList defaultConfiguration = document.getElementsByTagName(IManagedBuildInfo.DEFAULT_CONFIGURATION);\n\t\t\ttry {\n\t\t\t\tElement defaultConfig = (Element) defaultConfiguration.item(0);\n\t\t\t\tString oldDefaultConfigId = defaultConfig.getAttribute(IBuildObject.ID);\n\t\t\t\tIConfiguration newDefaultConfig = getConfigIdMap().get(oldDefaultConfigId);\n\t\t\t\tif (newDefaultConfig != null) {\n\t\t\t\t\tinfo.setDefaultConfiguration(newDefaultConfig);\n\t\t\t\t\tinfo.setSelectedConfiguration(newDefaultConfig);\n\t\t\t\t} else {\n\t\t\t\t\t// The only safe thing to do if there wasn't a default configuration for a built-in\n\t\t\t\t\t// target is to set the first defined configuration as the default\n\t\t\t\t\tIConfiguration[] newConfigs = newProject.getConfigurations();\n\t\t\t\t\tif (newConfigs.length > 0) {\n\t\t\t\t\t\tinfo.setDefaultConfiguration(newConfigs[0]);\n\t\t\t\t\t\tinfo.setSelectedConfiguration(newConfigs[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ManagedBuilderCorePlugin.getUniqueIdentifier(), -1,\n\t\t\t\t\t\tConverterMessages.getFormattedString(\"UpdateManagedProject12.7\", newProject.getName()), null)); //$NON-NLS-1$\n\t\t\t}\n\n\t\t\t// Upgrade the version\n\t\t\t((ManagedBuildInfo) info).setVersion(\"2.1.0\"); //$NON-NLS-1$\n\t\t\tinfo.setValid(true);\n\t\t} catch (CoreException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tthrow new CoreException(\n\t\t\t\t\tnew Status(IStatus.ERROR, ManagedBuilderCorePlugin.getUniqueIdentifier(), -1, e.getMessage(), e));\n\t\t} finally {\n\t\t\t// If the tree is locked spawn a job to this.\n\t\t\tIWorkspace workspace = project.getWorkspace();\n\t\t\t//\t\t\tboolean treeLock = workspace.isTreeLocked();\n\t\t\tISchedulingRule rule = workspace.getRuleFactory().createRule(project);\n\t\t\t//since the java synchronized mechanism is now used for the build info loadding,\n\t\t\t//initiate the job in all cases\n\t\t\t//\t\t\tif (treeLock) {\n\t\t\tWorkspaceJob job = new WorkspaceJob(ConverterMessages.getResourceString(\"UpdateManagedProject.notice\")) { //$NON-NLS-1$\n\t\t\t\t@Override\n\t\t\t\tpublic IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n\t\t\t\t\tManagedBuildManager.saveBuildInfoLegacy(project, false);\n\t\t\t\t\treturn Status.OK_STATUS;\n\t\t\t\t}\n\t\t\t};\n\t\t\tjob.setRule(rule);\n\t\t\tjob.schedule();\n\t\t\t//\t\t\t} else {\n\t\t\t//\t\t\t\tManagedBuildManager.saveBuildInfo(project, false);\n\t\t\t//\t\t\t}\n\t\t\tmonitor.done();\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "web-feature-service",
    "cve_id": "CVE-2022-4607",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "246f4e2a97ad81491c00a7ed72ce5e7c7f75050a",
    "short_hash": "246f4e2a",
    "vulnerableMethods_before": [
      {
        "filename": "CityGMLWriterBuilder.java",
        "method_name": "src/main/java/vcs/citydb/wfs/operation/getfeature/citygml/CityGMLWriterBuilder.java#initializeContext",
        "raw_code": "@Override\n\tpublic void initializeContext(\n\t\t\tGetFeatureType wfsRequest,\n\t\t\tList<QueryExpression> queryExpressions,\n\t\t\tMap<String, String> formatOptions,\n\t\t\tGeometryStripper geometryStripper,\n\t\t\tIdCacheManager idCacheManager,\n\t\t\tObject eventChannel,\n\t\t\tInternalConfig internalConfig,\n\t\t\tWFSConfig wfsConfig,\n\t\t\tConfig config) throws FeatureWriteException {\n\t\tthis.geometryStripper = geometryStripper;\n\t\tthis.idCacheManager = idCacheManager;\n\t\tthis.eventChannel = eventChannel;\n\t\tthis.internalConfig = internalConfig;\n\t\tthis.config = config;\n\n\t\tversion = queryExpressions.get(0).getTargetVersion();\n\n\t\tsaxWriter = new SAXWriter();\n\t\tsaxWriter.setWriteEncoding(true);\n\n\t\tif (\"true\".equals(formatOptions.get(PRETTY_PRINT)))\n\t\t\tsaxWriter.setIndentString(\" \");\n\n\t\t// set WFS prefix and schema location in case we do not have to return the bare feature\n\t\tif (queryExpressions.size() > 1 || !queryExpressions.get(0).isGetFeatureById()) {\n\t\t\tsaxWriter.setPrefix(Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\t\t\tsaxWriter.setSchemaLocation(Constants.WFS_NAMESPACE_URI, Constants.WFS_SCHEMA_LOCATION);\n\t\t}\n\n\t\t// set CityGML prefixes and schema locations if we have to return feature instances\n\t\tif (wfsRequest.getResultType() == ResultTypeType.RESULTS) {\n\t\t\t// add default prefixes and schema locations\n\t\t\tModuleContext moduleContext = new ModuleContext(version);\n\n\t\t\tModule core = moduleContext.getModule(CityGMLModuleType.CORE);\n\t\t\tModule generics = moduleContext.getModule(CityGMLModuleType.GENERICS);\n\t\t\tsaxWriter.setPrefix(core.getNamespacePrefix(), core.getNamespaceURI());\n\t\t\tsaxWriter.setPrefix(generics.getNamespacePrefix(), generics.getNamespaceURI());\n\t\t\tsaxWriter.setSchemaLocation(generics.getNamespaceURI(), generics.getSchemaLocation());\n\t\t\tif (wfsConfig.getConstraints().isExportAppearance()) {\n\t\t\t\tModule appearance = moduleContext.getModule(CityGMLModuleType.APPEARANCE);\n\t\t\t\tsaxWriter.setPrefix(appearance.getNamespacePrefix(), appearance.getNamespaceURI());\n\t\t\t\tsaxWriter.setSchemaLocation(appearance.getNamespaceURI(), appearance.getSchemaLocation());\n\t\t\t}\n\n\t\t\t// add XML prefixes and schema locations for non-CityGML modules\n\t\t\tfor (Module module : moduleContext.getModules()) {\n\t\t\t\tif (!(module instanceof CityGMLModule)) {\n\t\t\t\t\t// skip 3DCityDB ADE prefix and namespace if metadata shall not be exported\n\t\t\t\t\tif ((module == CityDBADE200Module.v3_0 || module == CityDBADE100Module.v3_0)\n\t\t\t\t\t\t\t&& !wfsConfig.getConstraints().isExportCityDBMetadata())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tif (module instanceof ADEModule)\n\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set XML prefixes and schema locations for selected feature types\n\t\t\tfor (QueryExpression queryExpression : queryExpressions) {\n\t\t\t\tfor (FeatureType featureType : queryExpression.getFeatureTypeFilter().getFeatureTypes()) {\n\t\t\t\t\tif (featureType.isAvailableForCityGML(version)) {\n\t\t\t\t\t\tCityGMLModule module = Modules.getCityGMLModule(featureType.getSchema().getNamespace(version).getURI());\n\t\t\t\t\t\tif (module != null) {\n\t\t\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build XSLT transformer chain\n\t\t\tif (wfsConfig.getPostProcessing().getXSLTransformation().isEnabled()\n\t\t\t\t\t&& wfsConfig.getPostProcessing().getXSLTransformation().isSetStylesheets()) {\n\t\t\t\ttry {\n\t\t\t\t\tList<String> stylesheets = wfsConfig.getPostProcessing().getXSLTransformation().getStylesheets();\n\t\t\t\t\tSAXTransformerFactory factory = (SAXTransformerFactory) TransformerFactory.newInstance();\n\t\t\t\t\tTemplates[] templates = new Templates[stylesheets.size()];\n\n\t\t\t\t\tfor (int i = 0; i < stylesheets.size(); i++) {\n\t\t\t\t\t\tTemplates template = factory.newTemplates(new StreamSource(new File(stylesheets.get(i))));\n\t\t\t\t\t\ttemplates[i] = template;\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformerChainFactory = new TransformerChainFactory(templates);\n\t\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\t\tlog.error(\"Failed to compile XSLT stylesheets.\");\n\t\t\t\t\tlog.error(\"Cause: \" + e.getMessage());\n\t\t\t\t\tthrow new FeatureWriteException(\"Failed to configure the XSL transformation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CityGMLWriterBuilder.java",
        "method_name": "src/main/java/vcs/citydb/wfs/operation/getfeature/citygml/CityGMLWriterBuilder.java#initializeContext",
        "raw_code": "@Override\n\tpublic void initializeContext(\n\t\t\tGetFeatureType wfsRequest,\n\t\t\tList<QueryExpression> queryExpressions,\n\t\t\tMap<String, String> formatOptions,\n\t\t\tGeometryStripper geometryStripper,\n\t\t\tIdCacheManager idCacheManager,\n\t\t\tObject eventChannel,\n\t\t\tInternalConfig internalConfig,\n\t\t\tWFSConfig wfsConfig,\n\t\t\tConfig config) throws FeatureWriteException {\n\t\tthis.geometryStripper = geometryStripper;\n\t\tthis.idCacheManager = idCacheManager;\n\t\tthis.eventChannel = eventChannel;\n\t\tthis.internalConfig = internalConfig;\n\t\tthis.config = config;\n\n\t\tversion = queryExpressions.get(0).getTargetVersion();\n\n\t\tsaxWriter = new SAXWriter();\n\t\tsaxWriter.setWriteEncoding(true);\n\n\t\tif (\"true\".equals(formatOptions.get(PRETTY_PRINT)))\n\t\t\tsaxWriter.setIndentString(\" \");\n\n\t\t// set WFS prefix and schema location in case we do not have to return the bare feature\n\t\tif (queryExpressions.size() > 1 || !queryExpressions.get(0).isGetFeatureById()) {\n\t\t\tsaxWriter.setPrefix(Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\t\t\tsaxWriter.setSchemaLocation(Constants.WFS_NAMESPACE_URI, Constants.WFS_SCHEMA_LOCATION);\n\t\t}\n\n\t\t// set CityGML prefixes and schema locations if we have to return feature instances\n\t\tif (wfsRequest.getResultType() == ResultTypeType.RESULTS) {\n\t\t\t// add default prefixes and schema locations\n\t\t\tModuleContext moduleContext = new ModuleContext(version);\n\n\t\t\tModule core = moduleContext.getModule(CityGMLModuleType.CORE);\n\t\t\tModule generics = moduleContext.getModule(CityGMLModuleType.GENERICS);\n\t\t\tsaxWriter.setPrefix(core.getNamespacePrefix(), core.getNamespaceURI());\n\t\t\tsaxWriter.setPrefix(generics.getNamespacePrefix(), generics.getNamespaceURI());\n\t\t\tsaxWriter.setSchemaLocation(generics.getNamespaceURI(), generics.getSchemaLocation());\n\t\t\tif (wfsConfig.getConstraints().isExportAppearance()) {\n\t\t\t\tModule appearance = moduleContext.getModule(CityGMLModuleType.APPEARANCE);\n\t\t\t\tsaxWriter.setPrefix(appearance.getNamespacePrefix(), appearance.getNamespaceURI());\n\t\t\t\tsaxWriter.setSchemaLocation(appearance.getNamespaceURI(), appearance.getSchemaLocation());\n\t\t\t}\n\n\t\t\t// add XML prefixes and schema locations for non-CityGML modules\n\t\t\tfor (Module module : moduleContext.getModules()) {\n\t\t\t\tif (!(module instanceof CityGMLModule)) {\n\t\t\t\t\t// skip 3DCityDB ADE prefix and namespace if metadata shall not be exported\n\t\t\t\t\tif ((module == CityDBADE200Module.v3_0 || module == CityDBADE100Module.v3_0)\n\t\t\t\t\t\t\t&& !wfsConfig.getConstraints().isExportCityDBMetadata())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tif (module instanceof ADEModule)\n\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set XML prefixes and schema locations for selected feature types\n\t\t\tfor (QueryExpression queryExpression : queryExpressions) {\n\t\t\t\tfor (FeatureType featureType : queryExpression.getFeatureTypeFilter().getFeatureTypes()) {\n\t\t\t\t\tif (featureType.isAvailableForCityGML(version)) {\n\t\t\t\t\t\tCityGMLModule module = Modules.getCityGMLModule(featureType.getSchema().getNamespace(version).getURI());\n\t\t\t\t\t\tif (module != null) {\n\t\t\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build XSLT transformer chain\n\t\t\tif (wfsConfig.getPostProcessing().getXSLTransformation().isEnabled()\n\t\t\t\t\t&& wfsConfig.getPostProcessing().getXSLTransformation().isSetStylesheets()) {\n\t\t\t\ttry {\n\t\t\t\t\tList<String> stylesheets = wfsConfig.getPostProcessing().getXSLTransformation().getStylesheets();\n\t\t\t\t\tSAXTransformerFactory factory = (SAXTransformerFactory) SecureXMLProcessors.newTransformerFactory();\n\t\t\t\t\tTemplates[] templates = new Templates[stylesheets.size()];\n\n\t\t\t\t\tfor (int i = 0; i < stylesheets.size(); i++) {\n\t\t\t\t\t\tTemplates template = factory.newTemplates(new StreamSource(new File(stylesheets.get(i))));\n\t\t\t\t\t\ttemplates[i] = template;\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformerChainFactory = new TransformerChainFactory(templates);\n\t\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\t\tlog.error(\"Failed to compile XSLT stylesheets.\");\n\t\t\t\t\tlog.error(\"Cause: \" + e.getMessage());\n\t\t\t\t\tthrow new FeatureWriteException(\"Failed to configure the XSL transformation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2021-21290",
    "cwe_list": [
      "CWE-379"
    ],
    "commit_hash": "c735357bf29d07856ad171c6611a2e1a0e0000ec",
    "short_hash": "c735357b",
    "vulnerableMethods_before": [
      {
        "filename": "SelfSignedCertificate.java",
        "method_name": "handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java#newSelfSignedCertificate",
        "raw_code": "static String[] newSelfSignedCertificate(\n            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {\n        // Encode the private key into a file.\n        ByteBuf wrappedBuf = Unpooled.wrappedBuffer(key.getEncoded());\n        ByteBuf encodedBuf;\n        final String keyText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                keyText = \"-----BEGIN PRIVATE KEY-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END PRIVATE KEY-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File keyFile = File.createTempFile(\"keyutil_\" + fqdn + '_', \".key\");\n        keyFile.deleteOnExit();\n\n        OutputStream keyOut = new FileOutputStream(keyFile);\n        try {\n            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));\n            keyOut.close();\n            keyOut = null;\n        } finally {\n            if (keyOut != null) {\n                safeClose(keyFile, keyOut);\n                safeDelete(keyFile);\n            }\n        }\n\n        wrappedBuf = Unpooled.wrappedBuffer(cert.getEncoded());\n        final String certText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                // Encode the certificate into a CRT file.\n                certText = \"-----BEGIN CERTIFICATE-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END CERTIFICATE-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File certFile = File.createTempFile(\"keyutil_\" + fqdn + '_', \".crt\");\n        certFile.deleteOnExit();\n\n        OutputStream certOut = new FileOutputStream(certFile);\n        try {\n            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));\n            certOut.close();\n            certOut = null;\n        } finally {\n            if (certOut != null) {\n                safeClose(certFile, certOut);\n                safeDelete(certFile);\n                safeDelete(keyFile);\n            }\n        }\n\n        return new String[] { certFile.getPath(), keyFile.getPath() };\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SelfSignedCertificate.java",
        "method_name": "handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java#newSelfSignedCertificate",
        "raw_code": "static String[] newSelfSignedCertificate(\n            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {\n        // Encode the private key into a file.\n        ByteBuf wrappedBuf = Unpooled.wrappedBuffer(key.getEncoded());\n        ByteBuf encodedBuf;\n        final String keyText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                keyText = \"-----BEGIN PRIVATE KEY-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END PRIVATE KEY-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File keyFile = PlatformDependent.createTempFile(\"keyutil_\" + fqdn + '_', \".key\", null);\n        keyFile.deleteOnExit();\n\n        OutputStream keyOut = new FileOutputStream(keyFile);\n        try {\n            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));\n            keyOut.close();\n            keyOut = null;\n        } finally {\n            if (keyOut != null) {\n                safeClose(keyFile, keyOut);\n                safeDelete(keyFile);\n            }\n        }\n\n        wrappedBuf = Unpooled.wrappedBuffer(cert.getEncoded());\n        final String certText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                // Encode the certificate into a CRT file.\n                certText = \"-----BEGIN CERTIFICATE-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END CERTIFICATE-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File certFile = PlatformDependent.createTempFile(\"keyutil_\" + fqdn + '_', \".crt\", null);\n        certFile.deleteOnExit();\n\n        OutputStream certOut = new FileOutputStream(certFile);\n        try {\n            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));\n            certOut.close();\n            certOut = null;\n        } finally {\n            if (certOut != null) {\n                safeClose(certFile, certOut);\n                safeDelete(certFile);\n                safeDelete(keyFile);\n            }\n        }\n\n        return new String[] { certFile.getPath(), keyFile.getPath() };\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geoserver",
    "cve_id": "CVE-2025-21621",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "dc9ff1c726dd73c884437a123b4ad72b19383c7d",
    "short_hash": "dc9ff1c7",
    "vulnerableMethods_before": [
      {
        "filename": "FreeMarkerTemplateManager.java",
        "method_name": "getTemplate",
        "raw_code": "private Template getTemplate(ResourceInfo ri, String templateFileName, Charset charset)\n            throws IOException {\n\n        synchronized (templateConfig) {\n            // setup template subsystem\n            if (templateLoader == null) {\n                templateLoader = new GeoServerTemplateLoader(getClass(), resourceLoader);\n            }\n            templateLoader.setResource(ri);\n            templateConfig.setTemplateLoader(templateLoader);\n            templateConfig.unsetOutputFormat();\n            if (format.equals(OutputFormat.HTML) && wms.isAutoEscapeTemplateValues()) {\n                templateConfig.setOutputFormat(HTMLOutputFormat.INSTANCE);\n            }\n            Template t = null;\n            try {\n                t = templateConfig.getTemplate(templateFileName);\n            } catch (FileNotFoundException ex) {\n                // throws exception just for text/html that completely rely on templates\n                if (format.equals(OutputFormat.HTML)) throw ex;\n            }\n\n            return t;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FreeMarkerTemplateManager.java",
        "method_name": "getTemplate",
        "raw_code": "private Template getTemplate(ResourceInfo ri, String templateFileName, Charset charset)\n            throws IOException {\n\n        synchronized (templateConfig) {\n            // setup template subsystem\n            if (templateLoader == null) {\n                templateLoader = new GeoServerTemplateLoader(getClass(), resourceLoader);\n            }\n            templateLoader.setResource(ri);\n            templateConfig.setTemplateLoader(templateLoader);\n            templateConfig.unsetOutputFormat();\n            if (format.equals(OutputFormat.HTML)) {\n                String prop = GeoServerExtensions.getProperty(FORCE_FREEMARKER_ESCAPING);\n                if (!\"false\".equalsIgnoreCase(prop) || wms.isAutoEscapeTemplateValues()) {\n                    templateConfig.setOutputFormat(HTMLOutputFormat.INSTANCE);\n                }\n            }\n            Template t = null;\n            try {\n                t = templateConfig.getTemplate(templateFileName);\n            } catch (FileNotFoundException ex) {\n                // throws exception just for text/html that completely rely on templates\n                if (format.equals(OutputFormat.HTML)) throw ex;\n            }\n\n            return t;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snyk-eclipse-plugin",
    "cve_id": "CVE-2022-24441",
    "cwe_list": [
      "CWE-78"
    ],
    "commit_hash": "b5a8bce25a359ced75f83a729fc6b2393fc9a495",
    "short_hash": "b5a8bce2",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "SnykWizard.java",
        "method_name": "plugin/src/main/java/io/snyk/eclipse/plugin/wizards/SnykWizard.java#performFinish",
        "raw_code": "public boolean performFinish() {\n    new LsConfigurationUpdater().configurationChanged();\n    SnykExtendedLanguageClient.getInstance().triggerAuthentication();\n    SnykExtendedLanguageClient.getInstance().trustWorkspaceFolders();\n    return true;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jai-ext",
    "cve_id": "CVE-2022-24816",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "cb1d6565d38954676b0a366da4f965fef38da1cb",
    "short_hash": "cb1d6565",
    "vulnerableMethods_before": [
      {
        "filename": "Jiffle.java",
        "method_name": "jt-jiffle/jt-jiffle-language/src/main/java/it/geosolutions/jaiext/jiffle/Jiffle.java#getRuntimeInstance",
        "raw_code": "public <T extends JiffleRuntime> T getRuntimeInstance(Class<T> baseClass) throws\n            it.geosolutions.jaiext.jiffle.JiffleException {\n        RuntimeModel model = RuntimeModel.get(baseClass);\n        if (model == null) {\n            throw new it.geosolutions.jaiext.jiffle.JiffleException(baseClass.getName() +\n                    \" does not implement a required Jiffle runtime interface\");\n        }\n\n        return (T) createRuntimeInstance(model, baseClass, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Jiffle.java",
        "method_name": "jt-jiffle/jt-jiffle-language/src/main/java/it/geosolutions/jaiext/jiffle/Jiffle.java#getRuntimeInstance",
        "raw_code": "public <T extends JiffleRuntime> T getRuntimeInstance(Class<T> baseClass) throws\n            it.geosolutions.jaiext.jiffle.JiffleException {\n        RuntimeModel model = RuntimeModel.get(baseClass);\n        if (model == null) {\n            throw new it.geosolutions.jaiext.jiffle.JiffleException(baseClass.getName() +\n                    \" does not implement a required Jiffle runtime interface\");\n        }\n\n        return (T) createRuntimeInstance(model, baseClass, includeScript);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2024-31981",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "480186f9d2fca880513da8bc5a609674d106cbd3",
    "short_hash": "480186f9",
    "vulnerableMethods_before": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#getPDFTemplateProperty",
        "raw_code": "private String getPDFTemplateProperty(String propertyName, XWikiContext context)\n    {\n        String pdftemplate = context.getRequest().getParameter(\"pdftemplate\");\n\n        DocumentReference templateReference;\n        DocumentReference classReference;\n        if (StringUtils.isNotEmpty(pdftemplate)) {\n            templateReference = referenceResolver.resolve(pdftemplate);\n            classReference = new DocumentReference(templateReference.getWikiReference().getName(), \"XWiki\", \"PDFClass\");\n        } else {\n            templateReference = dab.getCurrentDocumentReference();\n            String currentWiki = dab.getCurrentDocumentReference().getRoot().getName();\n            classReference = new DocumentReference(currentWiki, \"XWiki\", \"PDFClass\");\n        }\n\n        String result = (String) dab.getProperty(templateReference, classReference, propertyName);\n        if (StringUtils.isBlank(result)) {\n            return \"\";\n        }\n        String templateName = referenceSerializer.serialize(templateReference);\n        try {\n            StringWriter writer = new StringWriter();\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n            velocityManager.getVelocityEngine().evaluate(vcontext, writer, templateName, result);\n            result = writer.toString();\n        } catch (XWikiVelocityException e) {\n            LOGGER.warn(\"Error applying Velocity to the [{}] property of the [{}] document. Using the property's value \"\n                + \"without applying Velocity.\", propertyName, templateName, ExceptionUtils.getRootCauseMessage(e));\n        }\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#getPDFTemplateProperty",
        "raw_code": "private String getPDFTemplateProperty(String propertyName, XWikiContext context)\n    {\n        String pdftemplate = context.getRequest().getParameter(\"pdftemplate\");\n\n        DocumentReference templateReference;\n        DocumentReference classReference;\n        if (StringUtils.isNotEmpty(pdftemplate)) {\n            templateReference = this.referenceResolver.resolve(pdftemplate);\n            classReference = new DocumentReference(templateReference.getWikiReference().getName(), \"XWiki\", \"PDFClass\");\n        } else {\n            templateReference = this.dab.getCurrentDocumentReference();\n            String currentWiki = this.dab.getCurrentDocumentReference().getRoot().getName();\n            classReference = new DocumentReference(currentWiki, \"XWiki\", \"PDFClass\");\n        }\n\n        String templateContent = (String) this.dab.getProperty(templateReference, classReference, propertyName);\n        if (StringUtils.isBlank(templateContent)) {\n            return \"\";\n        }\n\n        String templateName = this.referenceSerializer.serialize(templateReference);\n        DocumentReference templateAuthorReference;\n        String result = templateContent;\n        try {\n             templateAuthorReference = this.userReferenceSerializer.serialize(\n                 this.dab.getDocumentInstance(templateReference).getAuthors().getEffectiveMetadataAuthor());\n        } catch (Exception e) {\n            LOGGER.warn(\"Error fetching the author of template [{}] during PDF conversion. Using the [{}] property of \"\n                + \"the document's value without applying Velocity.\", templateName, propertyName);\n            return result;\n        }\n\n        if (this.authorizationManager.hasAccess(Right.SCRIPT, templateAuthorReference, templateReference)) {\n            try {\n                result = this.authorExecutor.call(() -> {\n                    StringWriter writer = new StringWriter();\n                    VelocityContext vcontext = this.velocityManager.getVelocityContext();\n                    this.velocityManager.getVelocityEngine().evaluate(vcontext, writer, templateName,\n                        templateContent);\n                    return writer.toString();\n                }, templateAuthorReference, templateReference);\n            } catch (Exception e) {\n                LOGGER.warn(\"Failed to run Velocity engine in author executor. Using the [{}] property of the [{}] \"\n                    + \"document's value without applying Velocity. Reason: [{}]\",\n                    propertyName, templateName, ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geotools",
    "cve_id": "CVE-2023-25158",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b",
    "short_hash": "64fb4c47",
    "vulnerableMethods_before": [
      {
        "filename": "LikeFilterImpl.java",
        "method_name": "modules/library/main/src/main/java/org/geotools/filter/LikeFilterImpl.java#getSQL92LikePattern",
        "raw_code": "public String getSQL92LikePattern() throws IllegalArgumentException {\n        if (escape.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> escape char should be of length exactly 1\");\n        }\n        if (wildcardSingle.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> wildcardSingle char should be of length exactly 1\");\n        }\n        if (wildcardMulti.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> wildcardMulti char should be of length exactly 1\");\n        }\n        return LikeFilterImpl.convertToSQL92(\n                escape.charAt(0),\n                wildcardMulti.charAt(0),\n                wildcardSingle.charAt(0),\n                matchingCase,\n                pattern);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LikeFilterImpl.java",
        "method_name": "modules/library/main/src/main/java/org/geotools/filter/LikeFilterImpl.java#getSQL92LikePattern",
        "raw_code": "@Deprecated\n    public String getSQL92LikePattern() throws IllegalArgumentException {\n        if (escape.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> escape char should be of length exactly 1\");\n        }\n        if (wildcardSingle.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> wildcardSingle char should be of length exactly 1\");\n        }\n        if (wildcardMulti.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> wildcardMulti char should be of length exactly 1\");\n        }\n        return LikeFilterImpl.convertToSQL92(\n                escape.charAt(0),\n                wildcardMulti.charAt(0),\n                wildcardSingle.charAt(0),\n                matchingCase,\n                pattern,\n                true);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-29523",
    "cwe_list": [
      "CWE-74"
    ],
    "commit_hash": "0d547181389f7941e53291af940966413823f61c",
    "short_hash": "0d547181",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiDocument.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDocument.java#display",
        "raw_code": "public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument )context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String prefix = pref + LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference())\n                + \"_\" + obj.getNumber() + \"_\";\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId) && HTMLUtils.containsElementText(result)) {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                result.append(\"{{/html}}\");\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiDocument.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDocument.java#display",
        "raw_code": "public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument )context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String prefix = pref + LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference())\n                + \"_\" + obj.getNumber() + \"_\";\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html or { which could be part of an XWiki\n            // macro syntax since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId)\n                && (HTMLUtils.containsElementText(result) || result.indexOf(\"{\") != -1))\n            {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                // Escape closing HTML macro syntax.\n                int startIndex = 0;\n                // Start searching at the last match to avoid scanning the whole string again.\n                while ((startIndex = result.indexOf(CLOSE_HTML_MACRO, startIndex)) != -1) {\n                    result.replace(startIndex, startIndex + 2, \"&#123;&#123;\");\n                }\n                result.append(CLOSE_HTML_MACRO);\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "05f795bb7cf18856004f40e5042709e550ed0d6e",
    "short_hash": "05f795bb",
    "vulnerableMethods_before": [
      {
        "filename": "ParameterExecutableValidationContext.java",
        "method_name": "createConstraintValidatorContextFor",
        "raw_code": "@Override\n\tpublic ConstraintValidatorContextImpl createConstraintValidatorContextFor(ConstraintDescriptorImpl<?> constraintDescriptor, PathImpl path) {\n\t\tif ( ConstraintType.CROSS_PARAMETER.equals( constraintDescriptor.getConstraintType() ) ) {\n\t\t\treturn new CrossParameterConstraintValidatorContextImpl(\n\t\t\t\t\tgetParameterNames(),\n\t\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\t\tpath,\n\t\t\t\t\tconstraintDescriptor,\n\t\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload()\n\t\t\t);\n\t\t}\n\n\t\treturn new ConstraintValidatorContextImpl(\n\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\tpath,\n\t\t\t\tconstraintDescriptor,\n\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload()\n\t\t);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ParameterExecutableValidationContext.java",
        "method_name": "createConstraintValidatorContextFor",
        "raw_code": "@Override\n\tpublic ConstraintValidatorContextImpl createConstraintValidatorContextFor(ConstraintDescriptorImpl<?> constraintDescriptor, PathImpl path) {\n\t\tif ( ConstraintType.CROSS_PARAMETER.equals( constraintDescriptor.getConstraintType() ) ) {\n\t\t\treturn new CrossParameterConstraintValidatorContextImpl(\n\t\t\t\t\tgetParameterNames(),\n\t\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\t\tpath,\n\t\t\t\t\tconstraintDescriptor,\n\t\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload(),\n\t\t\t\t\tvalidatorScopedContext.getConstraintExpressionLanguageFeatureLevel(),\n\t\t\t\t\tvalidatorScopedContext.getCustomViolationExpressionLanguageFeatureLevel()\n\t\t\t);\n\t\t}\n\n\t\treturn new ConstraintValidatorContextImpl(\n\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\tpath,\n\t\t\t\tconstraintDescriptor,\n\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload(),\n\t\t\t\tvalidatorScopedContext.getConstraintExpressionLanguageFeatureLevel(),\n\t\t\t\tvalidatorScopedContext.getCustomViolationExpressionLanguageFeatureLevel()\n\t\t);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "bc-java",
    "cve_id": "CVE-2016-1000339",
    "cwe_list": [
      "CWE-310"
    ],
    "commit_hash": "8a73f08931450c17c749af067b6a8185abdfd2c0#diff-494fb066bed02aeb76b6c005632943f2",
    "short_hash": "8a73f089",
    "vulnerableMethods_before": [
      {
        "filename": "DRBG.java",
        "method_name": "generateDefaultPersonalizationString",
        "raw_code": "private static byte[] generateDefaultPersonalizationString()\n    {\n        return Arrays.concatenate(Strings.toByteArray(\"Default\"), Strings.toUTF8ByteArray(getVIMID()),\n            Pack.longToBigEndian(Thread.currentThread().getId()), Pack.longToBigEndian(System.currentTimeMillis()));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DRBG.java",
        "method_name": "generateDefaultPersonalizationString",
        "raw_code": "private static byte[] generateDefaultPersonalizationString(SecureRandom random)\n    {\n        return Arrays.concatenate(Strings.toByteArray(\"Default\"), random.generateSeed(16),\n            Pack.longToBigEndian(Thread.currentThread().getId()), Pack.longToBigEndian(System.currentTimeMillis()));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "dataease",
    "cve_id": "CVE-2024-47074",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "86eafc4d77f0bbc0eaa7fc58e5076a085257f259",
    "short_hash": "86eafc4d",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PgConfiguration.java",
        "method_name": "core/backend/src/main/java/io/dataease/dto/datasource/PgConfiguration.java#getJdbc",
        "raw_code": "public String getJdbc() {\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            if (StringUtils.isEmpty(getSchema())) {\n                return \"jdbc:postgresql://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getHost().trim())\n                        .replace(\"PORT\", getPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                return \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?currentSchema=SCHEMA\"\n                        .replace(\"HOSTNAME\", getHost().trim())\n                        .replace(\"PORT\", getPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\", getSchema().trim());\n            }\n        } else {\n            for (String illegalParameter : illegalParameters) {\n                if (getExtraParams().toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(getExtraParams()).contains(illegalParameter.toLowerCase())) {\n                    throw new RuntimeException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getHost().trim())\n                    .replace(\"PORT\", getPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "shopizer",
    "cve_id": "CVE-2022-23061",
    "cwe_list": [
      "CWE-639"
    ],
    "commit_hash": "6b9f1ecd303b3b724d96bd08095c1a751dcc287e",
    "short_hash": "6b9f1ecd",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PersistableProductOptionValueMapper.java",
        "method_name": "sm-shop/src/main/java/com/salesmanager/shop/mapper/catalog/PersistableProductOptionValueMapper.java#description",
        "raw_code": "ProductOptionValueDescription description(\n\t\t\tcom.salesmanager.shop.model.catalog.product.attribute.ProductOptionValueDescription description)\n\t\t\tthrows Exception {\n\t\tValidate.notNull(description.getLanguage(), \"description.language should not be null\");\n\t\tProductOptionValueDescription desc = new ProductOptionValueDescription();\n\t\tdesc.setId(null);\n\t\tdesc.setDescription(description.getDescription());\n\t\tdesc.setName(description.getName());\n\t\tif(StringUtils.isBlank(desc.getName())) {\n\t\t\tdesc.setName(description.getDescription());\n\t\t}\n\t\tif (description.getId() != null && description.getId().longValue() > 0) {\n\t\t\tdesc.setId(description.getId());\n\t\t}\n\t\tLanguage lang = languageService.getByCode(description.getLanguage());\n\t\tdesc.setLanguage(lang);\n\t\treturn desc;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geotools",
    "cve_id": "CVE-2022-24818",
    "cwe_list": [
      "CWE-917"
    ],
    "commit_hash": "4f70fa3234391dd0cda883a20ab0ec75688cba49",
    "short_hash": "4f70fa32",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractEpsgMediator.java",
        "method_name": "modules/library/referencing/src/main/java/org/geotools/referencing/factory/AbstractEpsgMediator.java#lookupDataSource",
        "raw_code": "static DataSource lookupDataSource(Hints hints) throws FactoryException {\n        Object hint = hints.get(Hints.EPSG_DATA_SOURCE);\n        if (hint instanceof DataSource) {\n            return (DataSource) hint;\n        } else if (hint instanceof String) {\n            String name = (String) hint;\n            InitialContext context;\n            try {\n                context = GeoTools.getInitialContext();\n                // name = GeoTools.fixName( context, name );\n                return (DataSource) context.lookup(name);\n            } catch (Exception e) {\n                throw new FactoryException(\"EPSG_DATA_SOURCE '\" + name + \"' not found:\" + e, e);\n            }\n        }\n        throw new FactoryException(\"EPSG_DATA_SOURCE must be provided\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractEpsgMediator.java",
        "method_name": "modules/library/referencing/src/main/java/org/geotools/referencing/factory/AbstractEpsgMediator.java#lookupDataSource",
        "raw_code": "static DataSource lookupDataSource(Hints hints) throws FactoryException {\n        Object hint = hints.get(Hints.EPSG_DATA_SOURCE);\n        if (hint instanceof DataSource) {\n            return (DataSource) hint;\n        } else if (hint instanceof String) {\n            String name = (String) hint;\n            try {\n                return (DataSource) GeoTools.jndiLookup(name);\n            } catch (Exception e) {\n                throw new FactoryException(\"EPSG_DATA_SOURCE '\" + name + \"' not found:\" + e, e);\n            }\n        }\n        throw new FactoryException(\"EPSG_DATA_SOURCE must be provided\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geotools",
    "cve_id": "CVE-2022-24818",
    "cwe_list": [
      "CWE-917"
    ],
    "commit_hash": "4f70fa3234391dd0cda883a20ab0ec75688cba49",
    "short_hash": "4f70fa32",
    "vulnerableMethods_before": [
      {
        "filename": "GeoTools.java",
        "method_name": "modules/library/metadata/src/main/java/org/geotools/util/factory/GeoTools.java#init",
        "raw_code": "public static void init(final Hints hints) {\n        init();\n        if (hints != null) {\n            // This will trigger fireConfigurationChanged()\n            Hints.putSystemDefault(hints);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GeoTools.java",
        "method_name": "modules/library/metadata/src/main/java/org/geotools/util/factory/GeoTools.java#init",
        "raw_code": "public static void init(final InitialContext initialContext) {\n        synchronized (GeoTools.class) {\n            context = initialContext;\n        }\n        fireConfigurationChanged();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "05f795bb7cf18856004f40e5042709e550ed0d6e",
    "short_hash": "05f795bb",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractMessageInterpolator.java",
        "method_name": "interpolate",
        "raw_code": "public abstract String interpolate(Context context, Locale locale, String term);",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractMessageInterpolator.java",
        "method_name": "interpolate",
        "raw_code": "protected abstract String interpolate(Context context, Locale locale, String term);",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "d2db40b9e7d22c7a0b44d7665242dfc7b4d14d78",
    "short_hash": "d2db40b9",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractValidationContext.java",
        "method_name": "createConstraintValidatorContextFor",
        "raw_code": "@Override\n\tpublic ConstraintValidatorContextImpl createConstraintValidatorContextFor(ConstraintDescriptorImpl<?> constraintDescriptor, PathImpl path) {\n\t\treturn new ConstraintValidatorContextImpl(\n\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\tpath,\n\t\t\t\tconstraintDescriptor,\n\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload()\n\t\t);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractValidationContext.java",
        "method_name": "createConstraintValidatorContextFor",
        "raw_code": "@Override\n\tpublic ConstraintValidatorContextImpl createConstraintValidatorContextFor(ConstraintDescriptorImpl<?> constraintDescriptor, PathImpl path) {\n\t\treturn new ConstraintValidatorContextImpl(\n\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\tpath,\n\t\t\t\tconstraintDescriptor,\n\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload(),\n\t\t\t\tvalidatorScopedContext.getConstraintExpressionLanguageFeatureLevel(),\n\t\t\t\tvalidatorScopedContext.getCustomViolationExpressionLanguageFeatureLevel()\n\t\t);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "plantuml",
    "cve_id": "CVE-2022-1231",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "c9137be051ce98b3e3e27f65f54ec7d9f8886903",
    "short_hash": "c9137be0",
    "vulnerableMethods_before": [
      {
        "filename": "UImageSvg.java",
        "method_name": "src/net/sourceforge/plantuml/ugraphic/UImageSvg.java#clean",
        "raw_code": "private String clean(String svg) {\n\t\tsvg = svg.toLowerCase().replaceAll(\"\\\\s\", \"\");\n\t\tif (svg.contains(\"<script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"</script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"<foreignobject\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"</foreignobject>\"))\n\t\t\treturn EMPTY_SVG;\n\t\treturn svg;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UImageSvg.java",
        "method_name": "src/net/sourceforge/plantuml/ugraphic/UImageSvg.java#clean",
        "raw_code": "private String clean(final String svg) {\n\t\tfinal String svg2 = svg.toLowerCase().replaceAll(\"\\\\s\", \"\");\n\t\tif (svg2.contains(\"<script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg2.contains(\"</script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg2.contains(\"<foreignobject\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg2.contains(\"</foreignobject>\"))\n\t\t\treturn EMPTY_SVG;\n\t\treturn svg;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "onedev",
    "cve_id": "CVE-2021-21242",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "f864053176c08f59ef2d97fea192ceca46a4d9be",
    "short_hash": "f8640531",
    "vulnerableMethods_before": [
      {
        "filename": "MarkdownEditor.java",
        "method_name": "server-core/src/main/java/io/onedev/server/web/component/markdown/MarkdownEditor.java#onInitialize",
        "raw_code": "@Override\n\tprotected void onInitialize() {\n\t\tsuper.onInitialize();\n\n\t\tcontainer = new WebMarkupContainer(\"container\");\n\t\tcontainer.setOutputMarkupId(true);\n\t\t\n\t\tadd(container);\n\t\t\n\t\tWebMarkupContainer editLink = new WebMarkupContainer(\"editLink\");\n\t\tWebMarkupContainer splitLink = new WebMarkupContainer(\"splitLink\");\n\t\tWebMarkupContainer preview = new WebMarkupContainer(\"preview\");\n\t\tWebMarkupContainer edit = new WebMarkupContainer(\"edit\");\n\t\tcontainer.add(editLink);\n\t\tcontainer.add(splitLink);\n\t\tcontainer.add(preview);\n\t\tcontainer.add(edit);\n\t\t\n\t\tcontainer.add(AttributeAppender.append(\"class\", compactMode?\"compact-mode\":\"normal-mode\"));\n\t\t\n\t\tcontainer.add(new DropdownLink(\"doReference\") {\n\n\n\t\t\t@Override\n\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\treturn new Fragment(id, \"referenceMenuFrag\", MarkdownEditor.this) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\t\tString script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", \n\t\t\t\t\t\t\t\tcontainer.getMarkupId(), getMarkupId());\n\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}.setOutputMarkupId(true);\n\t\t\t}\n\t\t\t\n\t\t}.setVisible(getReferenceSupport() != null));\n\t\t\n\t\tcontainer.add(new DropdownLink(\"actionMenuTrigger\") {\n\n\n\t\t\t@Override\n\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\treturn new Fragment(id, \"actionMenuFrag\", MarkdownEditor.this) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onInitialize() {\n\t\t\t\t\t\tsuper.onInitialize();\n\t\t\t\t\t\tadd(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (getReferenceSupport() != null) \n\t\t\t\t\t\t\tadd(new Fragment(\"doReference\", \"referenceMenuFrag\", MarkdownEditor.this));\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tadd(new WebMarkupContainer(\"doReference\").setVisible(false));\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\t\tString script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", \n\t\t\t\t\t\t\t\tcontainer.getMarkupId(), getMarkupId());\n\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}.setOutputMarkupId(true);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontainer.add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));\n\t\t\t\n\t\tedit.add(input = new TextArea<String>(\"input\", Model.of(getModelObject())));\n\t\tfor (AttributeModifier modifier: getInputModifiers()) \n\t\t\tinput.add(modifier);\n\n\t\tif (initialSplit) {\n\t\t\tcontainer.add(AttributeAppender.append(\"class\", \"split-mode\"));\n\t\t\tpreview.add(new Label(\"rendered\", new LoadableDetachableModel<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected String load() {\n\t\t\t\t\treturn renderInput(input.getConvertedInput());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\tString script = String.format(\n\t\t\t\t\t\t\t\"onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));\", \n\t\t\t\t\t\t\tcontainer.getMarkupId());\n\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}.setEscapeModelStrings(false));\n\t\t\tsplitLink.add(AttributeAppender.append(\"class\", \"active\"));\n\t\t} else {\n\t\t\tcontainer.add(AttributeAppender.append(\"class\", \"edit-mode\"));\n\t\t\tpreview.add(new WebMarkupContainer(\"rendered\"));\n\t\t\teditLink.add(AttributeAppender.append(\"class\", \"active\"));\n\t\t}\n\t\t\n\t\tcontainer.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));\n\t\t\n\t\tcontainer.add(ajaxBehavior = new AbstractPostAjaxBehavior() {\n\n\t\t\t@Override\n\t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\n\t\t\t\tsuper.updateAjaxAttributes(attributes);\n\t\t\t\tattributes.setChannel(new AjaxChannel(\"markdown-preview\", AjaxChannel.Type.DROP));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void respond(AjaxRequestTarget target) {\n\t\t\t\tIRequestParameters params = RequestCycle.get().getRequest().getPostParameters();\n\t\t\t\tString action = params.getParameterValue(\"action\").toString(\"\");\n\t\t\t\tswitch (action) {\n\t\t\t\tcase \"render\":\n\t\t\t\t\tString markdown = params.getParameterValue(\"param1\").toString();\n\t\t\t\t\tString rendered = renderInput(markdown);\n\t\t\t\t\tString script = String.format(\"onedev.server.markdown.onRendered('%s', '%s');\", \n\t\t\t\t\t\t\tcontainer.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"emojiQuery\":\n\t\t\t\t\tList<String> emojiNames = new ArrayList<>();\n\t\t\t\t\tString emojiQuery = params.getParameterValue(\"param1\").toOptionalString();\n\t\t\t\t\tif (StringUtils.isNotBlank(emojiQuery)) {\n\t\t\t\t\t\temojiQuery = emojiQuery.toLowerCase();\n\t\t\t\t\t\tfor (String emojiName: EmojiOnes.getInstance().all().keySet()) {\n\t\t\t\t\t\t\tif (emojiName.toLowerCase().contains(emojiQuery))\n\t\t\t\t\t\t\t\temojiNames.add(emojiName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\temojiNames.sort((name1, name2) -> name1.length() - name2.length());\n\t\t\t\t\t} else {\n\t\t\t\t\t\temojiNames.add(\"smile\");\n\t\t\t\t\t\temojiNames.add(\"worried\");\n\t\t\t\t\t\temojiNames.add(\"blush\");\n\t\t\t\t\t\temojiNames.add(\"+1\");\n\t\t\t\t\t\temojiNames.add(\"-1\");\n\t\t\t\t\t}\n\n\t\t\t\t\tList<Map<String, String>> emojis = new ArrayList<>();\n\t\t\t\t\tfor (String emojiName: emojiNames) {\n\t\t\t\t\t\tif (emojis.size() < ATWHO_LIMIT) {\n\t\t\t\t\t\t\tString emojiCode = EmojiOnes.getInstance().all().get(emojiName);\n\t\t\t\t\t\t\tCharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(\n\t\t\t\t\t\t\t\t\tEmojiOnes.class, \"icon/\" + emojiCode + \".png\"), new PageParameters());\n\t\t\t\t\t\t\tMap<String, String> emoji = new HashMap<>();\n\t\t\t\t\t\t\temoji.put(\"name\", emojiName);\n\t\t\t\t\t\t\temoji.put(\"url\", url.toString());\n\t\t\t\t\t\t\temojis.add(emoji);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString json;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoEmojiRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"loadEmojis\":\n\t\t\t\t\temojis = new ArrayList<>();\n\t\t\t\t\tString urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,\n\t\t\t\t\t        \"icon/FILENAME.png\"), new PageParameters()).toString();\n\t\t\t\t\t\n\t\t\t\t\tfor (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {\n\t\t\t\t\t\tMap<String, String> emoji = new HashMap<>();\n\t\t\t\t\t\temoji.put(\"name\", entry.getKey());\n\t\t\t\t\t\temoji.put(\"url\", urlPattern.replace(\"FILENAME\", entry.getValue()));\n\t\t\t\t\t\temojis.add(emoji);\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscript = String.format(\"onedev.server.markdown.onEmojisLoaded('%s', %s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"userQuery\":\n\t\t\t\t\tString userQuery = params.getParameterValue(\"param1\").toOptionalString();\n\n\t\t\t\t\tAvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);\n\t\t\t\t\tList<Map<String, String>> userList = new ArrayList<>();\n\t\t\t\t\tfor (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\tMap<String, String> userMap = new HashMap<>();\n\t\t\t\t\t\tuserMap.put(\"name\", user.getName());\n\t\t\t\t\t\tif (user.getFullName() != null)\n\t\t\t\t\t\t\tuserMap.put(\"fullName\", user.getFullName());\n\t\t\t\t\t\tString noSpaceName = StringUtils.deleteWhitespace(user.getName());\n\t\t\t\t\t\tif (user.getFullName() != null) {\n\t\t\t\t\t\t\tString noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());\n\t\t\t\t\t\t\tuserMap.put(\"searchKey\", noSpaceName + \" \" + noSpaceFullName);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuserMap.put(\"searchKey\", noSpaceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString avatarUrl = avatarManager.getAvatarUrl(user);\n\t\t\t\t\t\tuserMap.put(\"avatarUrl\", avatarUrl);\n\t\t\t\t\t\tuserList.add(userMap);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoUserRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"referenceQuery\":\n\t\t\t\t\tString referenceQuery = params.getParameterValue(\"param1\").toOptionalString();\n\t\t\t\t\tString referenceQueryType = params.getParameterValue(\"param2\").toOptionalString();\n\t\t\t\t\tString referenceProjectName = params.getParameterValue(\"param3\").toOptionalString();\n\t\t\t\t\tList<Map<String, String>> referenceList = new ArrayList<>();\n\t\t\t\t\tProject referenceProject;\n\t\t\t\t\tif (StringUtils.isNotBlank(referenceProjectName)) \n\t\t\t\t\t\treferenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);\n\t\t\t\t\telse\n\t\t\t\t\t\treferenceProject = null;\n\t\t\t\t\tif (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {\n\t\t\t\t\t\tif (\"issue\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"issue\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(issue.getNumber()));\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", issue.getTitle());\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", issue.getNumber() + \" \" + StringUtils.deleteWhitespace(issue.getTitle()));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"pullrequest\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"pull request\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(request.getNumber()));\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", request.getTitle());\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", request.getNumber() + \" \" + StringUtils.deleteWhitespace(request.getTitle()));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"build\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"build\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(build.getNumber()));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tString title;\n\t\t\t\t\t\t\t\tif (build.getVersion() != null) \n\t\t\t\t\t\t\t\t\ttitle = \"(\" + build.getVersion() + \") \" + build.getJobName();\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\ttitle = build.getJobName();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", title);\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", build.getNumber() + \" \" + StringUtils.deleteWhitespace(title));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoReferenceRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"selectImage\":\n\t\t\t\tcase \"selectLink\":\n\t\t\t\t\tnew ModalPanel(target) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Component newContent(String id) {\n\t\t\t\t\t\t\treturn new InsertUrlPanel(id, MarkdownEditor.this, action.equals(\"selectImage\")) {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tprotected void onClose(AjaxRequestTarget target) {\n\t\t\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClosed() {\n\t\t\t\t\t\t\tsuper.onClosed();\n\t\t\t\t\t\t\tAjaxRequestTarget target = \n\t\t\t\t\t\t\t\t\tPreconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));\n\t\t\t\t\t\t\ttarget.appendJavaScript(String.format(\"$('#%s textarea').focus();\", container.getMarkupId()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"insertUrl\":\n\t\t\t\t\tString name;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tname = URLDecoder.decode(params.getParameterValue(\"param1\").toString(), StandardCharsets.UTF_8.name());\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tString replaceMessage = params.getParameterValue(\"param2\").toString();\n\t\t\t\t\tString url = getAttachmentSupport().getAttachmentUrl(name);\n\t\t\t\t\tinsertUrl(target, isWebSafeImage(name), url, name, replaceMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException(\"Unknown action: \" + action);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "MarkdownEditor.java",
        "method_name": "server-core/src/main/java/io/onedev/server/web/component/markdown/MarkdownEditor.java#onInitialize",
        "raw_code": "@Override\n\tprotected void onInitialize() {\n\t\tsuper.onInitialize();\n\n\t\tcontainer = new WebMarkupContainer(\"container\");\n\t\tcontainer.setOutputMarkupId(true);\n\t\t\n\t\tadd(container);\n\t\t\n\t\tWebMarkupContainer editLink = new WebMarkupContainer(\"editLink\");\n\t\tWebMarkupContainer splitLink = new WebMarkupContainer(\"splitLink\");\n\t\tWebMarkupContainer preview = new WebMarkupContainer(\"preview\");\n\t\tWebMarkupContainer edit = new WebMarkupContainer(\"edit\");\n\t\tcontainer.add(editLink);\n\t\tcontainer.add(splitLink);\n\t\tcontainer.add(preview);\n\t\tcontainer.add(edit);\n\t\t\n\t\tcontainer.add(AttributeAppender.append(\"class\", compactMode?\"compact-mode\":\"normal-mode\"));\n\t\t\n\t\tcontainer.add(new DropdownLink(\"doReference\") {\n\n\n\t\t\t@Override\n\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\treturn new Fragment(id, \"referenceMenuFrag\", MarkdownEditor.this) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\t\tString script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", \n\t\t\t\t\t\t\t\tcontainer.getMarkupId(), getMarkupId());\n\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}.setOutputMarkupId(true);\n\t\t\t}\n\t\t\t\n\t\t}.setVisible(getReferenceSupport() != null));\n\t\t\n\t\tcontainer.add(new DropdownLink(\"actionMenuTrigger\") {\n\n\n\t\t\t@Override\n\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\treturn new Fragment(id, \"actionMenuFrag\", MarkdownEditor.this) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onInitialize() {\n\t\t\t\t\t\tsuper.onInitialize();\n\t\t\t\t\t\tadd(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (getReferenceSupport() != null) \n\t\t\t\t\t\t\tadd(new Fragment(\"doReference\", \"referenceMenuFrag\", MarkdownEditor.this));\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tadd(new WebMarkupContainer(\"doReference\").setVisible(false));\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\t\tString script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", \n\t\t\t\t\t\t\t\tcontainer.getMarkupId(), getMarkupId());\n\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}.setOutputMarkupId(true);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontainer.add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));\n\t\t\t\n\t\tedit.add(input = new TextArea<String>(\"input\", Model.of(getModelObject())));\n\t\tfor (AttributeModifier modifier: getInputModifiers()) \n\t\t\tinput.add(modifier);\n\n\t\tif (initialSplit) {\n\t\t\tcontainer.add(AttributeAppender.append(\"class\", \"split-mode\"));\n\t\t\tpreview.add(new Label(\"rendered\", new LoadableDetachableModel<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected String load() {\n\t\t\t\t\treturn renderInput(input.getConvertedInput());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\tString script = String.format(\n\t\t\t\t\t\t\t\"onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));\", \n\t\t\t\t\t\t\tcontainer.getMarkupId());\n\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}.setEscapeModelStrings(false));\n\t\t\tsplitLink.add(AttributeAppender.append(\"class\", \"active\"));\n\t\t} else {\n\t\t\tcontainer.add(AttributeAppender.append(\"class\", \"edit-mode\"));\n\t\t\tpreview.add(new WebMarkupContainer(\"rendered\"));\n\t\t\teditLink.add(AttributeAppender.append(\"class\", \"active\"));\n\t\t}\n\t\t\n\t\tcontainer.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));\n\t\t\n\t\tcontainer.add(actionBehavior = new AbstractPostAjaxBehavior() {\n\n\t\t\t@Override\n\t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\n\t\t\t\tsuper.updateAjaxAttributes(attributes);\n\t\t\t\tattributes.setChannel(new AjaxChannel(\"markdown-preview\", AjaxChannel.Type.DROP));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void respond(AjaxRequestTarget target) {\n\t\t\t\tIRequestParameters params = RequestCycle.get().getRequest().getPostParameters();\n\t\t\t\tString action = params.getParameterValue(\"action\").toString(\"\");\n\t\t\t\tswitch (action) {\n\t\t\t\tcase \"render\":\n\t\t\t\t\tString markdown = params.getParameterValue(\"param1\").toString();\n\t\t\t\t\tString rendered = renderInput(markdown);\n\t\t\t\t\tString script = String.format(\"onedev.server.markdown.onRendered('%s', '%s');\", \n\t\t\t\t\t\t\tcontainer.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"emojiQuery\":\n\t\t\t\t\tList<String> emojiNames = new ArrayList<>();\n\t\t\t\t\tString emojiQuery = params.getParameterValue(\"param1\").toOptionalString();\n\t\t\t\t\tif (StringUtils.isNotBlank(emojiQuery)) {\n\t\t\t\t\t\temojiQuery = emojiQuery.toLowerCase();\n\t\t\t\t\t\tfor (String emojiName: EmojiOnes.getInstance().all().keySet()) {\n\t\t\t\t\t\t\tif (emojiName.toLowerCase().contains(emojiQuery))\n\t\t\t\t\t\t\t\temojiNames.add(emojiName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\temojiNames.sort((name1, name2) -> name1.length() - name2.length());\n\t\t\t\t\t} else {\n\t\t\t\t\t\temojiNames.add(\"smile\");\n\t\t\t\t\t\temojiNames.add(\"worried\");\n\t\t\t\t\t\temojiNames.add(\"blush\");\n\t\t\t\t\t\temojiNames.add(\"+1\");\n\t\t\t\t\t\temojiNames.add(\"-1\");\n\t\t\t\t\t}\n\n\t\t\t\t\tList<Map<String, String>> emojis = new ArrayList<>();\n\t\t\t\t\tfor (String emojiName: emojiNames) {\n\t\t\t\t\t\tif (emojis.size() < ATWHO_LIMIT) {\n\t\t\t\t\t\t\tString emojiCode = EmojiOnes.getInstance().all().get(emojiName);\n\t\t\t\t\t\t\tCharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(\n\t\t\t\t\t\t\t\t\tEmojiOnes.class, \"icon/\" + emojiCode + \".png\"), new PageParameters());\n\t\t\t\t\t\t\tMap<String, String> emoji = new HashMap<>();\n\t\t\t\t\t\t\temoji.put(\"name\", emojiName);\n\t\t\t\t\t\t\temoji.put(\"url\", url.toString());\n\t\t\t\t\t\t\temojis.add(emoji);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString json;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoEmojiRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"loadEmojis\":\n\t\t\t\t\temojis = new ArrayList<>();\n\t\t\t\t\tString urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,\n\t\t\t\t\t        \"icon/FILENAME.png\"), new PageParameters()).toString();\n\t\t\t\t\t\n\t\t\t\t\tfor (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {\n\t\t\t\t\t\tMap<String, String> emoji = new HashMap<>();\n\t\t\t\t\t\temoji.put(\"name\", entry.getKey());\n\t\t\t\t\t\temoji.put(\"url\", urlPattern.replace(\"FILENAME\", entry.getValue()));\n\t\t\t\t\t\temojis.add(emoji);\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscript = String.format(\"onedev.server.markdown.onEmojisLoaded('%s', %s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"userQuery\":\n\t\t\t\t\tString userQuery = params.getParameterValue(\"param1\").toOptionalString();\n\n\t\t\t\t\tAvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);\n\t\t\t\t\tList<Map<String, String>> userList = new ArrayList<>();\n\t\t\t\t\tfor (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\tMap<String, String> userMap = new HashMap<>();\n\t\t\t\t\t\tuserMap.put(\"name\", user.getName());\n\t\t\t\t\t\tif (user.getFullName() != null)\n\t\t\t\t\t\t\tuserMap.put(\"fullName\", user.getFullName());\n\t\t\t\t\t\tString noSpaceName = StringUtils.deleteWhitespace(user.getName());\n\t\t\t\t\t\tif (user.getFullName() != null) {\n\t\t\t\t\t\t\tString noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());\n\t\t\t\t\t\t\tuserMap.put(\"searchKey\", noSpaceName + \" \" + noSpaceFullName);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuserMap.put(\"searchKey\", noSpaceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString avatarUrl = avatarManager.getAvatarUrl(user);\n\t\t\t\t\t\tuserMap.put(\"avatarUrl\", avatarUrl);\n\t\t\t\t\t\tuserList.add(userMap);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoUserRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"referenceQuery\":\n\t\t\t\t\tString referenceQuery = params.getParameterValue(\"param1\").toOptionalString();\n\t\t\t\t\tString referenceQueryType = params.getParameterValue(\"param2\").toOptionalString();\n\t\t\t\t\tString referenceProjectName = params.getParameterValue(\"param3\").toOptionalString();\n\t\t\t\t\tList<Map<String, String>> referenceList = new ArrayList<>();\n\t\t\t\t\tProject referenceProject;\n\t\t\t\t\tif (StringUtils.isNotBlank(referenceProjectName)) \n\t\t\t\t\t\treferenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);\n\t\t\t\t\telse\n\t\t\t\t\t\treferenceProject = null;\n\t\t\t\t\tif (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {\n\t\t\t\t\t\tif (\"issue\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"issue\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(issue.getNumber()));\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", issue.getTitle());\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", issue.getNumber() + \" \" + StringUtils.deleteWhitespace(issue.getTitle()));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"pullrequest\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"pull request\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(request.getNumber()));\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", request.getTitle());\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", request.getNumber() + \" \" + StringUtils.deleteWhitespace(request.getTitle()));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"build\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"build\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(build.getNumber()));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tString title;\n\t\t\t\t\t\t\t\tif (build.getVersion() != null) \n\t\t\t\t\t\t\t\t\ttitle = \"(\" + build.getVersion() + \") \" + build.getJobName();\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\ttitle = build.getJobName();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", title);\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", build.getNumber() + \" \" + StringUtils.deleteWhitespace(title));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoReferenceRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"selectImage\":\n\t\t\t\tcase \"selectLink\":\n\t\t\t\t\tnew ModalPanel(target) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Component newContent(String id) {\n\t\t\t\t\t\t\treturn new InsertUrlPanel(id, MarkdownEditor.this, action.equals(\"selectImage\")) {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tprotected void onClose(AjaxRequestTarget target) {\n\t\t\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClosed() {\n\t\t\t\t\t\t\tsuper.onClosed();\n\t\t\t\t\t\t\tAjaxRequestTarget target = \n\t\t\t\t\t\t\t\t\tPreconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));\n\t\t\t\t\t\t\ttarget.appendJavaScript(String.format(\"$('#%s textarea').focus();\", container.getMarkupId()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"insertUrl\":\n\t\t\t\t\tString name;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tname = URLDecoder.decode(params.getParameterValue(\"param1\").toString(), StandardCharsets.UTF_8.name());\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tString replaceMessage = params.getParameterValue(\"param2\").toString();\n\t\t\t\t\tString url = getAttachmentSupport().getAttachmentUrl(name);\n\t\t\t\t\tinsertUrl(target, isWebSafeImage(name), url, name, replaceMessage);\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException(\"Unknown action: \" + action);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontainer.add(attachmentUploadBehavior = new AbstractPostAjaxBehavior() {\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void respond(AjaxRequestTarget target) {\n\t\t\t\tPreconditions.checkNotNull(getAttachmentSupport(), \"Unexpected attachment upload request\");\n\t\t\t\tHttpServletRequest request = (HttpServletRequest) RequestCycle.get().getRequest().getContainerRequest();\n\t\t\t\tHttpServletResponse response = (HttpServletResponse) RequestCycle.get().getResponse().getContainerResponse();\n\t\t\t\ttry {\n\t\t\t\t\tString fileName = URLDecoder.decode(request.getHeader(\"File-Name\"), StandardCharsets.UTF_8.name());\n\t\t\t\t\tString attachmentName = getAttachmentSupport().saveAttachment(fileName, request.getInputStream());\n\t\t\t\t\tresponse.getWriter().print(URLEncoder.encode(attachmentName, StandardCharsets.UTF_8.name()));\n\t\t\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlogger.error(\"Error uploading attachment.\", e);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (e.getMessage() != null)\n\t\t\t\t\t\t\tresponse.getWriter().print(e.getMessage());\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresponse.getWriter().print(\"Internal server error\");\n\t\t\t\t\t} catch (IOException e2) {\n\t\t\t\t\t\tthrow new RuntimeException(e2);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "shopizer",
    "cve_id": "CVE-2022-23061",
    "cwe_list": [
      "CWE-639"
    ],
    "commit_hash": "6b9f1ecd303b3b724d96bd08095c1a751dcc287e",
    "short_hash": "6b9f1ecd",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PersistableProductOptionValueMapper.java",
        "method_name": "sm-shop/src/main/java/com/salesmanager/shop/mapper/catalog/PersistableProductOptionValueMapper.java#merge",
        "raw_code": "@Override\n\tpublic ProductOptionValue merge(PersistableProductOptionValue source, ProductOptionValue destination,\n\t\t\t\t\t\t\t\t\tMerchantStore store, Language language) {\n\t\tif (destination == null) {\n\t\t\tdestination = new ProductOptionValue();\n\t\t}\n\n\t\ttry {\n\t\t\t\n\t\t\tif(StringUtils.isBlank(source.getCode())) {\n\t\t\t\tif(!StringUtils.isBlank(destination.getCode())) {\n\t\t\t\t\tsource.setCode(destination.getCode());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!CollectionUtils.isEmpty(source.getDescriptions())) {\n\t\t\t\tfor (com.salesmanager.shop.model.catalog.product.attribute.ProductOptionValueDescription desc : source\n\t\t\t\t\t\t.getDescriptions()) {\n\t\t\t\t\tProductOptionValueDescription description = null;\n\t\t\t\t\tif (!CollectionUtils.isEmpty(destination.getDescriptions())) {\n\t\t\t\t\t\tfor (ProductOptionValueDescription d : destination.getDescriptions()) {\n\t\t\t\t\t\t\tif (!StringUtils.isBlank(desc.getLanguage())\n\t\t\t\t\t\t\t\t\t&& desc.getLanguage().equals(d.getLanguage().getCode())) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t            \t  d.setDescription(desc.getDescription());\n\t\t\t\t            \t  d.setName(desc.getName());\n\t\t\t\t            \t  d.setTitle(desc.getTitle());\n\t\t\t\t            \t  if(StringUtils.isBlank(d.getName())) {\n\t\t\t\t            \t\t  d.setName(d.getDescription());\n\t\t\t\t            \t  }\n\t\t\t\t            \t  description = d;\n\t\t\t\t            \t  break;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} //else {\n\t\t\t          if(description == null) {\n\t\t\t\t          description = description(desc);\n\t\t\t\t          description.setProductOptionValue(destination);\n\t\t\t\t          destination.getDescriptions().add(description);\n\t\t\t          }\n\t\t\t\t\t\t//description = description(desc);\n\t\t\t\t\t\t//description.setProductOptionValue(destination);\n\t\t\t\t\t//}\n\t\t\t\t\t//destination.getDescriptions().add(description);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestination.setCode(source.getCode());\n\t\t\tdestination.setMerchantStore(store);\n\t\t\tdestination.setProductOptionValueSortOrder(source.getSortOrder());\n\n\n\t\t\treturn destination;\n\t\t} catch (Exception e) {\n\t\t\tthrow new ServiceRuntimeException(\"Error while converting product option\", e);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "CodenameOne",
    "cve_id": "CVE-2022-4903",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "dad49c9ef26a598619fc48d2697151a02987d478",
    "short_hash": "dad49c9e",
    "vulnerableMethods_before": [
      {
        "filename": "AndroidLocationPlayServiceManager.java",
        "method_name": "Ports/Android/src/com/codename1/location/AndroidLocationPlayServiceManager.java#createBackgroundPendingIntent",
        "raw_code": "private PendingIntent createBackgroundPendingIntent(boolean forceService) {\n        Context context = AndroidNativeUtil.getContext().getApplicationContext();\n        final Class bgListenerClass = getBackgroundLocationListener();\n        if (bgListenerClass == null) {\n            return null;\n        }\n        if (!forceService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            Intent intent = new Intent(context, BackgroundLocationBroadcastReceiver.class);\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\n            intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_UPDATES);\n            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n            return pendingIntent;\n        } else {\n\n\n            Intent intent = new Intent(context, BackgroundLocationHandler.class);\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\n            PendingIntent pendingIntent = PendingIntent.getService(context, 0,\n                    intent,\n                    PendingIntent.FLAG_UPDATE_CURRENT);\n            return pendingIntent;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AndroidLocationPlayServiceManager.java",
        "method_name": "Ports/Android/src/com/codename1/location/AndroidLocationPlayServiceManager.java#createBackgroundPendingIntent",
        "raw_code": "private PendingIntent createBackgroundPendingIntent(boolean forceService) {\n        Context context = AndroidNativeUtil.getContext().getApplicationContext();\n        final Class bgListenerClass = getBackgroundLocationListener();\n        if (bgListenerClass == null) {\n            return null;\n        }\n        if (!forceService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            Intent intent = new Intent(context, BackgroundLocationBroadcastReceiver.class);\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\n            intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_UPDATES);\n            PendingIntent pendingIntent = AndroidImplementation.getBroadcastPendingIntent(context, 0, intent);\n            return pendingIntent;\n        } else {\n\n\n            Intent intent = new Intent(context, BackgroundLocationHandler.class);\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\n            PendingIntent pendingIntent = AndroidImplementation.getPendingIntent(context, 0,\n                    intent);\n            return pendingIntent;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "onedev",
    "cve_id": "CVE-2021-21245",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "0c060153fb97c0288a1917efdb17cc426934dacb",
    "short_hash": "0c060153",
    "vulnerableMethods_before": [
      {
        "filename": "InsertUrlPanel.java",
        "method_name": "server-core/src/main/java/io/onedev/server/web/component/markdown/InsertUrlPanel.java#newUploadPanel",
        "raw_code": "private Component newUploadPanel() {\n\t\tFragment fragment;\n\n\t\tIModel<Collection<FileUpload>> model = new PropertyModel<Collection<FileUpload>>(this, \"uploads\");\n\t\tString acceptedFiles;\n\t\tif (isImage)\n\t\t\tacceptedFiles = \"image/*\";\n\t\telse\n\t\t\tacceptedFiles = null;\n\t\t\n\t\tAttachmentSupport attachmentSupport = markdownEditor.getAttachmentSupport();\n\t\tif (attachmentSupport != null) {\n\t\t\tfragment = new Fragment(CONTENT_ID, \"uploadAttachmentFrag\", this);\n\t\t\t\n\t\t\tForm<?> form = new Form<Void>(\"form\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSubmit() {\n\t\t\t\t\tsuper.onSubmit();\n\t\t\t\t\t\n\t\t\t\t\tAjaxRequestTarget target = RequestCycle.get().find(AjaxRequestTarget.class);\n\t\t\t\t\tString attachmentName;\n\t\t\t\t\tFileUpload upload = uploads.iterator().next();\n\t\t\t\t\ttry (InputStream is = upload.getInputStream()) {\n\t\t\t\t\t\tattachmentName = attachmentSupport.saveAttachment(upload.getClientFileName(), is);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tmarkdownEditor.insertUrl(target, isImage, \n\t\t\t\t\t\t\tattachmentSupport.getAttachmentUrl(attachmentName), UrlUtils.describe(attachmentName), null);\n\t\t\t\t\tonClose(target);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onFileUploadException(FileUploadException e, Map<String, Object> model) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.setMaxSize(Bytes.bytes(attachmentSupport.getAttachmentMaxSize()));\n\t\t\tform.setMultiPart(true);\n\t\t\tform.add(new FencedFeedbackPanel(\"feedback\", form));\n\t\t\t\n\t\t\tint maxFilesize = (int) (attachmentSupport.getAttachmentMaxSize()/1024/1024);\n\t\t\tif (maxFilesize <= 0)\n\t\t\t\tmaxFilesize = 1;\n\t\t\tform.add(new DropzoneField(\"file\", model, acceptedFiles, 1, maxFilesize)\n\t\t\t\t\t.setRequired(true).setLabel(Model.of(\"Attachment\")));\n\t\t\t\n\t\t\tform.add(new AjaxButton(\"insert\"){});\n\t\t\t\n\t\t\tfragment.add(form);\n\t\t} else {\n\t\t\tfragment = new Fragment(CONTENT_ID, \"uploadBlobFrag\", this);\n\t\t\tForm<?> form = new Form<Void>(\"form\");\n\t\t\tform.setMultiPart(true);\n\t\t\tform.setFileMaxSize(Bytes.megabytes(Project.MAX_UPLOAD_SIZE));\n\t\t\tadd(form);\n\t\t\t\n\t\t\tFencedFeedbackPanel feedback = new FencedFeedbackPanel(\"feedback\", form);\n\t\t\tfeedback.setOutputMarkupPlaceholderTag(true);\n\t\t\tform.add(feedback);\n\t\t\t\n\t\t\tform.add(new DropzoneField(\"file\", model, acceptedFiles, 1, Project.MAX_UPLOAD_SIZE)\n\t\t\t\t\t.setRequired(true).setLabel(Model.of(\"Attachment\")));\n\n\t\t\tform.add(new TextField<String>(\"directory\", new IModel<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void detach() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getObject() {\n\t\t\t\t\treturn WebSession.get().getMetaData(UPLOAD_DIRECTORY);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setObject(String object) {\n\t\t\t\t\tWebSession.get().setMetaData(UPLOAD_DIRECTORY, object);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t})); \n\n\t\t\tBlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());\n\t\t\tObjectId commitId = resolveCommitId(context);\n\t\t\tSet<BlobIdent> folderPickerState = getPickerState(commitId, context.getBlobIdent(), \n\t\t\t\t\tWebSession.get().getMetaData(FOLDER_PICKER_STATE));\n\t\t\t\n\t\t\tform.add(new DropdownLink(\"select\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\t\treturn new BlobFolderPicker(id, commitId) {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect(AjaxRequestTarget target, BlobIdent blobIdent) {\n\t\t\t\t\t\t\tdropdown.close();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tString relativePath = PathUtils.relativize(context.getDirectory(), blobIdent.path);\n\t\t\t\t\t\t\tString script = String.format(\"$('form.upload-blob .directory input').val('%s');\", \n\t\t\t\t\t\t\t\t\tJavaScriptEscape.escapeJavaScript(relativePath));\n\t\t\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Project getProject() {\n\t\t\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onStateChange() {\n\t\t\t\t\t\t\tHashSet<String> expandedPaths = new HashSet<>();\n\t\t\t\t\t\t\tfor (BlobIdent blobIdent: folderPickerState)\n\t\t\t\t\t\t\t\texpandedPaths.add(blobIdent.path);\n\t\t\t\t\t\t\tWebSession.get().setMetaData(FOLDER_PICKER_STATE, expandedPaths);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Set<BlobIdent> getState() {\n\t\t\t\t\t\t\treturn folderPickerState;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tReferenceInputBehavior behavior = new ReferenceInputBehavior(true) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tprotected Project getProject() {\n\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.add(new TextField<String>(\"summaryCommitMessage\", \n\t\t\t\t\tnew PropertyModel<String>(this, \"summaryCommitMessage\")).add(behavior));\n\t\t\t\n\t\t\tbehavior = new ReferenceInputBehavior(true) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tprotected Project getProject() {\n\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.add(new TextArea<String>(\"detailCommitMessage\", \n\t\t\t\t\tnew PropertyModel<String>(this, \"detailCommitMessage\")).add(behavior));\n\t\t\t\n\t\t\tform.add(new AjaxButton(\"insert\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\tsuper.onSubmit(target, form);\n\n\t\t\t\t\tBlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());\n\t\t\t\t\tString commitMessage = summaryCommitMessage;\n\t\t\t\t\tif (StringUtils.isBlank(commitMessage))\n\t\t\t\t\t\tcommitMessage = \"Add files via upload\";\n\t\t\t\t\t\n\t\t\t\t\tif (StringUtils.isNotBlank(detailCommitMessage))\n\t\t\t\t\t\tcommitMessage += \"\\n\\n\" + detailCommitMessage;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString directory = WebSession.get().getMetaData(UPLOAD_DIRECTORY);\n\t\t\t\t\t\tcontext.onCommitted(null, context.uploadFiles(uploads, directory, commitMessage), null);\n\t\t\t\t\t\t\n\t\t\t\t\t\tString fileName = uploads.iterator().next().getClientFileName();\n\t\t\t\t\t\tString url;\n\t\t\t\t\t\tif (directory != null) \n\t\t\t\t\t\t\turl = directory + \"/\" + UrlUtils.encodePath(fileName);\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\turl = UrlUtils.encodePath(fileName);\n\t\t\t\t\t\tmarkdownEditor.insertUrl(target, isImage, url, UrlUtils.describe(fileName), null);\n\t\t\t\t\t\tonClose(target);\n\t\t\t\t\t} catch (GitException e) {\n\t\t\t\t\t\tform.error(e.getMessage());\n\t\t\t\t\t\ttarget.add(feedback);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onError(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\tsuper.onError(target, form);\n\t\t\t\t\ttarget.add(feedback);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tfragment.add(form);\n\t\t}\n\t\t\n\t\tfragment.setOutputMarkupId(true);\n\t\treturn fragment;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "InsertUrlPanel.java",
        "method_name": "server-core/src/main/java/io/onedev/server/web/component/markdown/InsertUrlPanel.java#newUploadPanel",
        "raw_code": "private Component newUploadPanel() {\n\t\tFragment fragment;\n\n\t\tIModel<Collection<FileUpload>> model = new PropertyModel<Collection<FileUpload>>(this, \"uploads\");\n\t\tString acceptedFiles;\n\t\tif (isImage)\n\t\t\tacceptedFiles = \"image/*\";\n\t\telse\n\t\t\tacceptedFiles = null;\n\t\t\n\t\tAttachmentSupport attachmentSupport = markdownEditor.getAttachmentSupport();\n\t\tif (attachmentSupport != null) {\n\t\t\tfragment = new Fragment(CONTENT_ID, \"uploadAttachmentFrag\", this);\n\t\t\t\n\t\t\tForm<?> form = new Form<Void>(\"form\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSubmit() {\n\t\t\t\t\tsuper.onSubmit();\n\t\t\t\t\t\n\t\t\t\t\tAjaxRequestTarget target = RequestCycle.get().find(AjaxRequestTarget.class);\n\t\t\t\t\tString attachmentName;\n\t\t\t\t\tFileUpload upload = uploads.iterator().next();\n\t\t\t\t\ttry (InputStream is = upload.getInputStream()) {\n\t\t\t\t\t\tattachmentName = attachmentSupport.saveAttachment(\n\t\t\t\t\t\t\t\tFilenameUtils.sanitizeFilename(upload.getClientFileName()), is);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tmarkdownEditor.insertUrl(target, isImage, \n\t\t\t\t\t\t\tattachmentSupport.getAttachmentUrl(attachmentName), UrlUtils.describe(attachmentName), null);\n\t\t\t\t\tonClose(target);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onFileUploadException(FileUploadException e, Map<String, Object> model) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.setMaxSize(Bytes.bytes(attachmentSupport.getAttachmentMaxSize()));\n\t\t\tform.setMultiPart(true);\n\t\t\tform.add(new FencedFeedbackPanel(\"feedback\", form));\n\t\t\t\n\t\t\tint maxFilesize = (int) (attachmentSupport.getAttachmentMaxSize()/1024/1024);\n\t\t\tif (maxFilesize <= 0)\n\t\t\t\tmaxFilesize = 1;\n\t\t\tform.add(new DropzoneField(\"file\", model, acceptedFiles, 1, maxFilesize)\n\t\t\t\t\t.setRequired(true).setLabel(Model.of(\"Attachment\")));\n\t\t\t\n\t\t\tform.add(new AjaxButton(\"insert\"){});\n\t\t\t\n\t\t\tfragment.add(form);\n\t\t} else {\n\t\t\tfragment = new Fragment(CONTENT_ID, \"uploadBlobFrag\", this);\n\t\t\tForm<?> form = new Form<Void>(\"form\");\n\t\t\tform.setMultiPart(true);\n\t\t\tform.setFileMaxSize(Bytes.megabytes(Project.MAX_UPLOAD_SIZE));\n\t\t\tadd(form);\n\t\t\t\n\t\t\tFencedFeedbackPanel feedback = new FencedFeedbackPanel(\"feedback\", form);\n\t\t\tfeedback.setOutputMarkupPlaceholderTag(true);\n\t\t\tform.add(feedback);\n\t\t\t\n\t\t\tform.add(new DropzoneField(\"file\", model, acceptedFiles, 1, Project.MAX_UPLOAD_SIZE)\n\t\t\t\t\t.setRequired(true).setLabel(Model.of(\"Attachment\")));\n\n\t\t\tform.add(new TextField<String>(\"directory\", new IModel<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void detach() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getObject() {\n\t\t\t\t\treturn WebSession.get().getMetaData(UPLOAD_DIRECTORY);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setObject(String object) {\n\t\t\t\t\tWebSession.get().setMetaData(UPLOAD_DIRECTORY, object);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t})); \n\n\t\t\tBlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());\n\t\t\tObjectId commitId = resolveCommitId(context);\n\t\t\tSet<BlobIdent> folderPickerState = getPickerState(commitId, context.getBlobIdent(), \n\t\t\t\t\tWebSession.get().getMetaData(FOLDER_PICKER_STATE));\n\t\t\t\n\t\t\tform.add(new DropdownLink(\"select\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\t\treturn new BlobFolderPicker(id, commitId) {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect(AjaxRequestTarget target, BlobIdent blobIdent) {\n\t\t\t\t\t\t\tdropdown.close();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tString relativePath = PathUtils.relativize(context.getDirectory(), blobIdent.path);\n\t\t\t\t\t\t\tString script = String.format(\"$('form.upload-blob .directory input').val('%s');\", \n\t\t\t\t\t\t\t\t\tJavaScriptEscape.escapeJavaScript(relativePath));\n\t\t\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Project getProject() {\n\t\t\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onStateChange() {\n\t\t\t\t\t\t\tHashSet<String> expandedPaths = new HashSet<>();\n\t\t\t\t\t\t\tfor (BlobIdent blobIdent: folderPickerState)\n\t\t\t\t\t\t\t\texpandedPaths.add(blobIdent.path);\n\t\t\t\t\t\t\tWebSession.get().setMetaData(FOLDER_PICKER_STATE, expandedPaths);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Set<BlobIdent> getState() {\n\t\t\t\t\t\t\treturn folderPickerState;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tReferenceInputBehavior behavior = new ReferenceInputBehavior(true) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tprotected Project getProject() {\n\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.add(new TextField<String>(\"summaryCommitMessage\", \n\t\t\t\t\tnew PropertyModel<String>(this, \"summaryCommitMessage\")).add(behavior));\n\t\t\t\n\t\t\tbehavior = new ReferenceInputBehavior(true) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tprotected Project getProject() {\n\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.add(new TextArea<String>(\"detailCommitMessage\", \n\t\t\t\t\tnew PropertyModel<String>(this, \"detailCommitMessage\")).add(behavior));\n\t\t\t\n\t\t\tform.add(new AjaxButton(\"insert\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\tsuper.onSubmit(target, form);\n\n\t\t\t\t\tBlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());\n\t\t\t\t\tString commitMessage = summaryCommitMessage;\n\t\t\t\t\tif (StringUtils.isBlank(commitMessage))\n\t\t\t\t\t\tcommitMessage = \"Add files via upload\";\n\t\t\t\t\t\n\t\t\t\t\tif (StringUtils.isNotBlank(detailCommitMessage))\n\t\t\t\t\t\tcommitMessage += \"\\n\\n\" + detailCommitMessage;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString directory = WebSession.get().getMetaData(UPLOAD_DIRECTORY);\n\t\t\t\t\t\tcontext.onCommitted(null, context.uploadFiles(uploads, directory, commitMessage), null);\n\t\t\t\t\t\t\n\t\t\t\t\t\tString fileName = uploads.iterator().next().getClientFileName();\n\t\t\t\t\t\tString url;\n\t\t\t\t\t\tif (directory != null) \n\t\t\t\t\t\t\turl = directory + \"/\" + UrlUtils.encodePath(fileName);\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\turl = UrlUtils.encodePath(fileName);\n\t\t\t\t\t\tmarkdownEditor.insertUrl(target, isImage, url, UrlUtils.describe(fileName), null);\n\t\t\t\t\t\tonClose(target);\n\t\t\t\t\t} catch (GitException e) {\n\t\t\t\t\t\tform.error(e.getMessage());\n\t\t\t\t\t\ttarget.add(feedback);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onError(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\tsuper.onError(target, form);\n\t\t\t\t\ttarget.add(feedback);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tfragment.add(form);\n\t\t}\n\t\t\n\t\tfragment.setOutputMarkupId(true);\n\t\treturn fragment;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jclouds",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "b0819e0ef5e08c792a4d1724b938714ce9503aa3",
    "short_hash": "b0819e0e",
    "vulnerableMethods_before": [
      {
        "filename": "FilesystemStorageStrategyImpl.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n   public Blob getBlob(final String container, final String key) {\n      BlobBuilder builder = blobBuilders.get();\n      builder.name(key);\n      File file = getFileForBlobKey(container, key);\n      ByteSource byteSource;\n      boolean isDirectory = false;\n\n      if (getDirectoryBlobSuffix(key) != null) {\n         if (!file.isDirectory()) {\n            // filesystem blobstore does not allow the existence of \"file\" and\n            // \"file/\" and getDirectoryBlobSuffix normalizes \"file/\" to \"file\".\n            // Therefore we need to return null when the normalized file is not\n            // a directory.\n            return null;\n         }\n         logger.debug(\"%s - %s is a directory\", container, key);\n         byteSource = ByteSource.empty();\n         isDirectory = true;\n      } else {\n         byteSource = Files.asByteSource(file);\n      }\n      try {\n         String cacheControl = null;\n         String contentDisposition = null;\n         String contentEncoding = null;\n         String contentLanguage = null;\n         String contentType = isDirectory ? \"application/x-directory\" : null;\n         HashCode hashCode = null;\n         String eTag = null;\n         Date expires = null;\n         Tier tier = Tier.STANDARD;\n         ImmutableMap.Builder<String, String> userMetadata = ImmutableMap.builder();\n\n         UserDefinedFileAttributeView view = getUserDefinedFileAttributeView(file.toPath());\n         if (view != null) {\n            try {\n               Set<String> attributes = ImmutableSet.copyOf(view.list());\n\n               cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n               contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n               contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n               contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n               if (!isDirectory) {\n                  contentType = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n                  if (contentType == null && autoDetectContentType) {\n                     contentType = probeContentType(file.toPath());\n                  }\n               }\n               if (attributes.contains(XATTR_CONTENT_MD5)) {\n                  ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                  view.read(XATTR_CONTENT_MD5, buf);\n                  byte [] etagBytes = buf.array();\n                  if (etagBytes.length == 16) {\n                     // regular object\n                     hashCode = HashCode.fromBytes(buf.array());\n                     eTag = \"\\\"\" + hashCode + \"\\\"\";\n                  } else {\n                     // multi-part object\n                     eTag = new String(etagBytes, US_ASCII);\n                  }\n               }\n               if (attributes.contains(XATTR_EXPIRES)) {\n                  ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                  view.read(XATTR_EXPIRES, buf);\n                  buf.flip();\n                  expires = new Date(buf.asLongBuffer().get());\n               }\n               String tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n               if (tierString != null) {\n                  tier = Tier.valueOf(tierString);\n               }\n               for (String attribute : attributes) {\n                  if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                     continue;\n                  }\n                  String value = readStringAttributeIfPresent(view, attributes, attribute);\n                  userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n               }\n            } catch (IOException e) {\n               logger.debug(\"xattrs not supported on %s\", file.toPath());\n            }\n\n            builder.payload(byteSource)\n               .cacheControl(cacheControl)\n               .contentDisposition(contentDisposition)\n               .contentEncoding(contentEncoding)\n               .contentLanguage(contentLanguage)\n               .contentLength(byteSource.size())\n               .contentMD5(hashCode)\n               .eTag(eTag)\n               .contentType(contentType)\n               .expires(expires)\n               .tier(tier)\n               .userMetadata(userMetadata.build());\n         } else {\n            builder.payload(byteSource)\n               .contentLength(byteSource.size())\n               .contentMD5(byteSource.hash(Hashing.md5()).asBytes());\n         }\n      } catch (FileNotFoundException fnfe) {\n         return null;\n      } catch (IOException e) {\n         throw Throwables.propagate(e);\n      }\n      Blob blob = builder.type(isDirectory ? StorageType.FOLDER : StorageType.BLOB).build();\n      blob.getMetadata().setContainer(container);\n      blob.getMetadata().setLastModified(new Date(file.lastModified()));\n      blob.getMetadata().setSize(file.length());\n      if (blob.getPayload().getContentMetadata().getContentMD5() != null)\n         blob.getMetadata().setETag(base16().lowerCase().encode(blob.getPayload().getContentMetadata().getContentMD5()));\n      return blob;\n   }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FilesystemStorageStrategyImpl.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n   public Blob getBlob(final String container, final String key) {\n      filesystemContainerNameValidator.validate(container);\n      filesystemBlobKeyValidator.validate(key);\n      BlobBuilder builder = blobBuilders.get();\n      builder.name(key);\n      File file = getFileForBlobKey(container, key);\n      ByteSource byteSource;\n      boolean isDirectory = false;\n\n      if (getDirectoryBlobSuffix(key) != null) {\n         if (!file.isDirectory()) {\n            // filesystem blobstore does not allow the existence of \"file\" and\n            // \"file/\" and getDirectoryBlobSuffix normalizes \"file/\" to \"file\".\n            // Therefore we need to return null when the normalized file is not\n            // a directory.\n            return null;\n         }\n         logger.debug(\"%s - %s is a directory\", container, key);\n         byteSource = ByteSource.empty();\n         isDirectory = true;\n      } else {\n         byteSource = Files.asByteSource(file);\n      }\n      try {\n         String cacheControl = null;\n         String contentDisposition = null;\n         String contentEncoding = null;\n         String contentLanguage = null;\n         String contentType = isDirectory ? \"application/x-directory\" : null;\n         HashCode hashCode = null;\n         String eTag = null;\n         Date expires = null;\n         Tier tier = Tier.STANDARD;\n         ImmutableMap.Builder<String, String> userMetadata = ImmutableMap.builder();\n\n         UserDefinedFileAttributeView view = getUserDefinedFileAttributeView(file.toPath());\n         if (view != null) {\n            try {\n               Set<String> attributes = ImmutableSet.copyOf(view.list());\n\n               cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n               contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n               contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n               contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n               if (!isDirectory) {\n                  contentType = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n                  if (contentType == null && autoDetectContentType) {\n                     contentType = probeContentType(file.toPath());\n                  }\n               }\n               if (attributes.contains(XATTR_CONTENT_MD5)) {\n                  ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                  view.read(XATTR_CONTENT_MD5, buf);\n                  byte [] etagBytes = buf.array();\n                  if (etagBytes.length == 16) {\n                     // regular object\n                     hashCode = HashCode.fromBytes(buf.array());\n                     eTag = \"\\\"\" + hashCode + \"\\\"\";\n                  } else {\n                     // multi-part object\n                     eTag = new String(etagBytes, US_ASCII);\n                  }\n               }\n               if (attributes.contains(XATTR_EXPIRES)) {\n                  ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                  view.read(XATTR_EXPIRES, buf);\n                  buf.flip();\n                  expires = new Date(buf.asLongBuffer().get());\n               }\n               String tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n               if (tierString != null) {\n                  tier = Tier.valueOf(tierString);\n               }\n               for (String attribute : attributes) {\n                  if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                     continue;\n                  }\n                  String value = readStringAttributeIfPresent(view, attributes, attribute);\n                  userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n               }\n            } catch (IOException e) {\n               logger.debug(\"xattrs not supported on %s\", file.toPath());\n            }\n\n            builder.payload(byteSource)\n               .cacheControl(cacheControl)\n               .contentDisposition(contentDisposition)\n               .contentEncoding(contentEncoding)\n               .contentLanguage(contentLanguage)\n               .contentLength(byteSource.size())\n               .contentMD5(hashCode)\n               .eTag(eTag)\n               .contentType(contentType)\n               .expires(expires)\n               .tier(tier)\n               .userMetadata(userMetadata.build());\n         } else {\n            builder.payload(byteSource)\n               .contentLength(byteSource.size())\n               .contentMD5(byteSource.hash(Hashing.md5()).asBytes());\n         }\n      } catch (FileNotFoundException fnfe) {\n         return null;\n      } catch (IOException e) {\n         throw Throwables.propagate(e);\n      }\n      Blob blob = builder.type(isDirectory ? StorageType.FOLDER : StorageType.BLOB).build();\n      blob.getMetadata().setContainer(container);\n      blob.getMetadata().setLastModified(new Date(file.lastModified()));\n      blob.getMetadata().setSize(file.length());\n      if (blob.getPayload().getContentMetadata().getContentMD5() != null)\n         blob.getMetadata().setETag(base16().lowerCase().encode(blob.getPayload().getContentMetadata().getContentMD5()));\n      return blob;\n   }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.jdt.ui",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "13675b1f8a74f47de4da89ed0ded6af7c21dfbec",
    "short_hash": "13675b1f",
    "vulnerableMethods_before": [
      {
        "filename": "JavadocWriter.java",
        "method_name": "org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/javadocexport/JavadocWriter.java#writeDocument",
        "raw_code": "public static void writeDocument(Element javadocElement, String encoding, OutputStream outputStream) throws TransformerException {\n\n\t\t// Write the document to the stream\n\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\",\"4\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tDOMSource source = new DOMSource(javadocElement.getOwnerDocument());\n\t\tStreamResult result = new StreamResult(new BufferedOutputStream(outputStream));\n\t\ttransformer.transform(source, result);\n\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "JavadocWriter.java",
        "method_name": "org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/javadocexport/JavadocWriter.java#writeDocument",
        "raw_code": "public static void writeDocument(Element javadocElement, String encoding, OutputStream outputStream) throws TransformerException {\n\n\t\t// Write the document to the stream\n\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\",\"4\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tDOMSource source = new DOMSource(javadocElement.getOwnerDocument());\n\t\tStreamResult result = new StreamResult(new BufferedOutputStream(outputStream));\n\t\ttransformer.transform(source, result);\n\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "Connector",
    "cve_id": "CVE-2024-8642",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "04899e91dcdb4a407db4eb7af3e7b6ff9a9e9ad6",
    "short_hash": "04899e91",
    "vulnerableMethods_before": [
      {
        "filename": "JsonObjectToContractAgreementVerificationMessageTransformer.java",
        "method_name": "data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/to/JsonObjectToContractAgreementVerificationMessageTransformer.java#transform",
        "raw_code": "@Override\n    public @Nullable ContractAgreementVerificationMessage transform(@NotNull JsonObject object, @NotNull TransformerContext context) {\n        var builder = ContractAgreementVerificationMessage.Builder.newInstance();\n        var processId = object.get(DSPACE_PROPERTY_PROCESS_ID);\n        if (!transformMandatoryString(object.get(DSPACE_PROPERTY_CONSUMER_PID), builder::consumerPid, context)) {\n            if (processId == null) {\n                context.problem()\n                        .missingProperty()\n                        .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                        .property(DSPACE_PROPERTY_CONSUMER_PID)\n                        .report();\n                return null;\n            } else {\n                builder.consumerPid(transformString(processId, context));\n            }\n        }\n        if (!transformMandatoryString(object.get(DSPACE_PROPERTY_PROVIDER_PID), builder::providerPid, context)) {\n            if (processId == null) {\n                context.problem()\n                        .missingProperty()\n                        .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                        .property(DSPACE_PROPERTY_PROVIDER_PID)\n                        .report();\n                return null;\n            } else {\n                builder.providerPid(transformString(processId, context));\n            }\n        }\n\n        return builder.build();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "JsonObjectToContractAgreementVerificationMessageTransformer.java",
        "method_name": "data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/to/JsonObjectToContractAgreementVerificationMessageTransformer.java#transform",
        "raw_code": "@Override\n    public @Nullable ContractAgreementVerificationMessage transform(@NotNull JsonObject object, @NotNull TransformerContext context) {\n        var builder = ContractAgreementVerificationMessage.Builder.newInstance();\n        if (!transformMandatoryString(object.get(DSPACE_PROPERTY_CONSUMER_PID), builder::consumerPid, context)) {\n            context.problem()\n                    .missingProperty()\n                    .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                    .property(DSPACE_PROPERTY_CONSUMER_PID)\n                    .report();\n            return null;\n        }\n        if (!transformMandatoryString(object.get(DSPACE_PROPERTY_PROVIDER_PID), builder::providerPid, context)) {\n            context.problem()\n                    .missingProperty()\n                    .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                    .property(DSPACE_PROPERTY_PROVIDER_PID)\n                    .report();\n            return null;\n        }\n\n        return builder.build();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "californium",
    "cve_id": "CVE-2022-39368",
    "cwe_list": [
      "CWE-459"
    ],
    "commit_hash": "5648a0c27c2c2667c98419254557a14bac2b1f3f",
    "short_hash": "5648a0c2",
    "vulnerableMethods_before": [
      {
        "filename": "DTLSConnector.java",
        "method_name": "scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java#processNewClientHello",
        "raw_code": "private void processNewClientHello(final Record record) {\n\t\tInetSocketAddress peerAddress = record.getPeerAddress();\n\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\tStringBuilder msg = new StringBuilder(\"Processing new CLIENT_HELLO from peer [\")\n\t\t\t\t\t.append(peerAddress).append(\"]\").append(\":\").append(StringUtil.lineSeparator()).append(record);\n\t\t\tLOGGER.trace(msg.toString());\n\t\t}\n\t\ttry {\n\t\t\t// CLIENT_HELLO with epoch 0 is not encrypted, so use DTLSConnectionState.NULL \n\t\t\trecord.applySession(null);\n\t\t\tDTLSMessage message = record.getFragment();\n\t\t\tif (message instanceof FragmentedHandshakeMessage) {\n\t\t\t\tLOGGER.debug(\"Received unsupported fragmented CLIENT_HELLO from peer [{}].\", peerAddress);\n\t\t\t\tdiscardRecord(record, new DtlsException(\"Fragmented CLIENT_HELLO is not supported!\", peerAddress));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal ClientHello clientHello = (ClientHello) message;\n\n\t\t\t// before starting a new handshake or resuming an established\n\t\t\t// session we need to make sure that the peer is in possession of\n\t\t\t// the IP address indicated in the client hello message\n\t\t\tfinal AvailableConnections connections = new AvailableConnections();\n\t\t\tif (isClientInControlOfSourceIpAddress(clientHello, record, connections)) {\n\t\t\t\tboolean verify = false;\n\t\t\t\tExecutorService executorService = getExecutorService();\n\t\t\t\tConnection connection;\n\t\t\t\tsynchronized (connectionStore) {\n\t\t\t\t\tconnection = connectionStore.get(peerAddress);\n\t\t\t\t\tif (connection != null && !connection.isStartedByClientHello(clientHello)) {\n\t\t\t\t\t\tConnection sessionConnection = connections.getConnectionBySessionId();\n\t\t\t\t\t\tif (sessionConnection != null && sessionConnection != connection) {\n\t\t\t\t\t\t\t// don't overwrite\n\t\t\t\t\t\t\tverify = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sessionConnection != null && sessionConnection == connection) {\n\t\t\t\t\t\t\t\tconnections.setRemoveConnectionBySessionId(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal Handshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\t\t\t\t\t\tif (establishedSession == null || handshaker.getSession() != establishedSession) {\n\t\t\t\t\t\t\t\t\tfinal DtlsException cause = new DtlsException(\n\t\t\t\t\t\t\t\t\t\t\t\"Received new CLIENT_HELLO from \" + StringUtil.toDisplayString(peerAddress),\n\t\t\t\t\t\t\t\t\t\t\tpeerAddress);\n\t\t\t\t\t\t\t\t\thandshaker.setFailureCause(cause);\n\t\t\t\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\t\t\t\thandshaker.handshakeFailed(cause);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (connection == null) {\n\t\t\t\t\t\tconnection = new Connection(peerAddress, new SerialExecutor(executorService));\n\t\t\t\t\t\tconnection.setExecutionListener(connectionExecutionListener);\n\t\t\t\t\t\tconnection.startByClientHello(clientHello);\n\t\t\t\t\t\tif (!connectionStore.put(connection)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (verify) {\n\t\t\t\t\tsendHelloVerify(clientHello, record, null);\n\t\t\t\t} else {\n\t\t\t\t\tconnections.setConnectionByAddress(connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\tprocessClientHello(clientHello, record, connections);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\t\t\tLOGGER.debug(\"Execution rejected while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t\tterminateConnection(connections.getConnectionByAddress(), e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\tLOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (RuntimeException e) {\n\t\t\tLOGGER.warn(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DTLSConnector.java",
        "method_name": "scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java#processNewClientHello",
        "raw_code": "private void processNewClientHello(final Record record) {\n\t\tInetSocketAddress peerAddress = record.getPeerAddress();\n\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\tStringBuilder msg = new StringBuilder(\"Processing new CLIENT_HELLO from peer [\")\n\t\t\t\t\t.append(peerAddress).append(\"]\").append(\":\").append(StringUtil.lineSeparator()).append(record);\n\t\t\tLOGGER.trace(msg.toString());\n\t\t}\n\t\ttry {\n\t\t\t// CLIENT_HELLO with epoch 0 is not encrypted, so use DTLSConnectionState.NULL \n\t\t\trecord.applySession(null);\n\t\t\tDTLSMessage message = record.getFragment();\n\t\t\tif (message instanceof FragmentedHandshakeMessage) {\n\t\t\t\tLOGGER.debug(\"Received unsupported fragmented CLIENT_HELLO from peer [{}].\", peerAddress);\n\t\t\t\tdiscardRecord(record, new DtlsException(\"Fragmented CLIENT_HELLO is not supported!\", peerAddress));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal ClientHello clientHello = (ClientHello) message;\n\n\t\t\t// before starting a new handshake or resuming an established\n\t\t\t// session we need to make sure that the peer is in possession of\n\t\t\t// the IP address indicated in the client hello message\n\t\t\tfinal AvailableConnections connections = new AvailableConnections();\n\t\t\tif (isClientInControlOfSourceIpAddress(clientHello, record, connections)) {\n\t\t\t\tboolean verify = false;\n\t\t\t\tExecutorService executorService = getExecutorService();\n\t\t\t\tConnection connection;\n\t\t\t\tsynchronized (connectionStore) {\n\t\t\t\t\tconnection = connectionStore.get(peerAddress);\n\t\t\t\t\tif (connection != null && !connection.isStartedByClientHello(clientHello)) {\n\t\t\t\t\t\tConnection sessionConnection = connections.getConnectionBySessionId();\n\t\t\t\t\t\tif (sessionConnection != null && sessionConnection != connection) {\n\t\t\t\t\t\t\t// don't overwrite\n\t\t\t\t\t\t\tverify = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sessionConnection != null && sessionConnection == connection) {\n\t\t\t\t\t\t\t\tconnections.setRemoveConnectionBySessionId(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal Handshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\t\t\t\t\t\tif (establishedSession == null || handshaker.getSession() != establishedSession) {\n\t\t\t\t\t\t\t\t\tfinal DtlsException cause = new DtlsException(\n\t\t\t\t\t\t\t\t\t\t\t\"Received new CLIENT_HELLO from \" + StringUtil.toDisplayString(peerAddress),\n\t\t\t\t\t\t\t\t\t\t\tpeerAddress);\n\t\t\t\t\t\t\t\t\thandshaker.setFailureCause(cause);\n\t\t\t\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\t\t\t\thandshaker.handshakeFailed(cause);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (connection == null) {\n\t\t\t\t\t\tconnection = new Connection(peerAddress, new SerialExecutor(executorService));\n\t\t\t\t\t\tconnection.setExecutionListener(connectionExecutionListener);\n\t\t\t\t\t\tconnection.startByClientHello(clientHello);\n\t\t\t\t\t\tif (!connectionStore.put(connection)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (verify) {\n\t\t\t\t\tsendHelloVerify(clientHello, record, null);\n\t\t\t\t} else {\n\t\t\t\t\tconnections.setConnectionByAddress(connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tif (running.get() && connections.getConnectionByAddress().isExecuting()) {\n\t\t\t\t\t\t\t\t\tprocessClientHello(clientHello, record, connections);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\t\t\tLOGGER.debug(\"Execution rejected while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t\tterminateConnection(connections.getConnectionByAddress(), e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\tLOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (RuntimeException e) {\n\t\t\tLOGGER.warn(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "opencrx",
    "cve_id": "CVE-2023-46502",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "ce7a71db0bb34ecbcb0e822d40598e410a48b399",
    "short_hash": "ce7a71db",
    "vulnerableMethods_before": [
      {
        "filename": "WebDavMethod.java",
        "method_name": "core/src/main/java/org/opencrx/application/uses/net/sf/webdav/methods/WebDavMethod.java#getDocumentBuilder",
        "raw_code": "protected DocumentBuilder getDocumentBuilder(\n    ) throws ServiceException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        return documentBuilder;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "WebDavMethod.java",
        "method_name": "core/src/main/java/org/opencrx/application/uses/net/sf/webdav/methods/WebDavMethod.java#getDocumentBuilder",
        "raw_code": "protected DocumentBuilder getDocumentBuilder(\n    ) throws ServiceException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        documentBuilderFactory.setNamespaceAware(true);\n        // Flags required to prevent XML eXternal Entity injection (XXE)\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        return documentBuilder;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xp",
    "cve_id": "CVE-2024-23679",
    "cwe_list": [
      "CWE-384"
    ],
    "commit_hash": "1f44674eb9ab3fbab7103e8d08067846e88bace4",
    "short_hash": "1f44674e",
    "vulnerableMethods_before": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#getSortedIdProviders",
        "raw_code": "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from( idProviders.stream().\n            sorted( Comparator.comparing( u -> u.getKey().toString() ) ).\n            collect( Collectors.toList() ) );\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#getSortedIdProviders",
        "raw_code": "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from(\n            idProviders.stream().sorted( Comparator.comparing( u -> u.getKey().toString() ) ).collect( Collectors.toList() ) );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jw-community",
    "cve_id": "CVE-2022-4560",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "ecf8be8f6f0cb725c18536ddc726d42a11bdaa1b",
    "short_hash": "ecf8be8f",
    "vulnerableMethods_before": [
      {
        "filename": "UniversalTheme.java",
        "method_name": "wflow-core/src/main/java/org/joget/plugin/enterprise/UniversalTheme.java#getInternalJsCssLib",
        "raw_code": "protected String getInternalJsCssLib(Map<String, Object> data) {\n        String jsCssLink = \"\";\n               \n        // PWA: register service worker\n        if (!\"true\".equals(getPropertyString(\"disablePwa\"))) {\n            WorkflowUserManager workflowUserManager = (WorkflowUserManager)AppUtil.getApplicationContext().getBean(\"workflowUserManager\");\n            boolean pushEnabled = !\"true\".equals(getPropertyString(\"disablePush\")) && !workflowUserManager.isCurrentUserAnonymous();\n            String appId = userview.getParamString(\"appId\");\n            if (appId != null && !appId.isEmpty()) {\n                String userviewId = userview.getPropertyString(\"id\");\n                String key = userview.getParamString(\"key\");\n                if (key.isEmpty()) {\n                    key = Userview.USERVIEW_KEY_EMPTY_VALUE;\n                }\n                \n                boolean isEmbedded = false;\n                if(data.get(\"embed\") != null){\n                    isEmbedded = (Boolean) data.get(\"embed\");\n                };\n                \n                String pwaOnlineNotificationMessage = ResourceBundleUtil.getMessage(\"pwa.onlineNow\");\n                String pwaOfflineNotificationMessage = ResourceBundleUtil.getMessage(\"pwa.offlineNow\");\n                String pwaLoginPromptMessage = ResourceBundleUtil.getMessage(\"pwa.loginPrompt\");\n                String pwaSyncingMessage = ResourceBundleUtil.getMessage(\"pwa.syncing\");\n                String pwaSyncFailedMessage = ResourceBundleUtil.getMessage(\"pwa.syncFailed\");\n                String pwaSyncSuccessMessage = ResourceBundleUtil.getMessage(\"pwa.syncSuccess\");\n                String buildNumber = ResourceBundleUtil.getMessage(\"build.number\");\n                \n                String serviceWorkerUrl = data.get(\"context_path\") + \"/web/userview/\" + appId + \"/\" + userviewId + \"/\"+key+\"/serviceworker\";\n                jsCssLink += \"<script>$(function() {\"\n                        + \"var initPwaUtil = function(){\"\n                        + \"PwaUtil.contextPath = '\" + data.get(\"context_path\") + \"';\"\n                        + \"PwaUtil.userviewKey = '\" + key + \"';\"\n                        + \"PwaUtil.homePageLink = '\" + data.get(\"home_page_link\") + \"';\"\n                        + \"PwaUtil.serviceWorkerPath = '\" + serviceWorkerUrl + \"';\"\n                        + \"PwaUtil.subscriptionApiPath = '\" + data.get(\"context_path\") + \"/web/console/profile/subscription';\"\n                        + \"PwaUtil.pushEnabled = \" + pushEnabled + \";\"\n                        + \"PwaUtil.currentUsername = '\" + workflowUserManager.getCurrentUsername() + \"';\"\n                        + \"PwaUtil.onlineNotificationMessage = '\" + pwaOnlineNotificationMessage + \"';\"\n                        + \"PwaUtil.offlineNotificationMessage = '\" + pwaOfflineNotificationMessage + \"';\"\n                        + \"PwaUtil.loginPromptMessage = '\" + pwaLoginPromptMessage + \"';\"\n                        + \"PwaUtil.syncingMessage = '\" + pwaSyncingMessage + \"';\"\n                        + \"PwaUtil.syncFailedMessage = '\" + pwaSyncFailedMessage + \"';\"\n                        + \"PwaUtil.syncSuccessMessage = '\" + pwaSyncSuccessMessage + \"';\"\n                        + \"PwaUtil.isEmbedded = \" + isEmbedded + \";\"\n                        + \"PwaUtil.register();\"\n                        + \"PwaUtil.init();\"\n                        + \"};\"\n                        + \"if (typeof PwaUtil !== \\\"undefined\\\") {initPwaUtil();} else { $(document).on(\\\"PwaUtil.ready\\\", function(){ initPwaUtil(); });}\"\n                        + \"});</script>\";\n            }\n        }\n        return jsCssLink;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UniversalTheme.java",
        "method_name": "wflow-core/src/main/java/org/joget/plugin/enterprise/UniversalTheme.java#getInternalJsCssLib",
        "raw_code": "protected String getInternalJsCssLib(Map<String, Object> data) {\n        String jsCssLink = \"\";\n               \n        // PWA: register service worker\n        if (!\"true\".equals(getPropertyString(\"disablePwa\"))) {\n            WorkflowUserManager workflowUserManager = (WorkflowUserManager)AppUtil.getApplicationContext().getBean(\"workflowUserManager\");\n            boolean pushEnabled = !\"true\".equals(getPropertyString(\"disablePush\")) && !workflowUserManager.isCurrentUserAnonymous();\n            String appId = userview.getParamString(\"appId\");\n            if (appId != null && !appId.isEmpty()) {\n                String userviewId = userview.getPropertyString(\"id\");\n                String key = userview.getParamString(\"key\");\n                if (key.isEmpty()) {\n                    key = Userview.USERVIEW_KEY_EMPTY_VALUE;\n                }\n                \n                boolean isEmbedded = false;\n                if(data.get(\"embed\") != null){\n                    isEmbedded = (Boolean) data.get(\"embed\");\n                };\n                \n                String pwaOnlineNotificationMessage = ResourceBundleUtil.getMessage(\"pwa.onlineNow\");\n                String pwaOfflineNotificationMessage = ResourceBundleUtil.getMessage(\"pwa.offlineNow\");\n                String pwaLoginPromptMessage = ResourceBundleUtil.getMessage(\"pwa.loginPrompt\");\n                String pwaSyncingMessage = ResourceBundleUtil.getMessage(\"pwa.syncing\");\n                String pwaSyncFailedMessage = ResourceBundleUtil.getMessage(\"pwa.syncFailed\");\n                String pwaSyncSuccessMessage = ResourceBundleUtil.getMessage(\"pwa.syncSuccess\");\n                String buildNumber = ResourceBundleUtil.getMessage(\"build.number\");\n                \n                String serviceWorkerUrl = data.get(\"context_path\") + \"/web/userview/\" + appId + \"/\" + userviewId + \"/\"+key+\"/serviceworker\";\n                jsCssLink += \"<script>$(function() {\"\n                        + \"var initPwaUtil = function(){\"\n                        + \"PwaUtil.contextPath = '\" + StringUtil.escapeString(data.get(\"context_path\").toString(), StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.userviewKey = '\" + StringUtil.escapeString(key, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.homePageLink = '\" + StringUtil.escapeString(data.get(\"home_page_link\").toString(), StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.serviceWorkerPath = '\" + StringUtil.escapeString(serviceWorkerUrl, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.subscriptionApiPath = '\" + StringUtil.escapeString(data.get(\"context_path\").toString(), StringUtil.TYPE_JAVASCIPT, null) + \"/web/console/profile/subscription';\"\n                        + \"PwaUtil.pushEnabled = \" + pushEnabled + \";\"\n                        + \"PwaUtil.currentUsername = '\" + StringUtil.escapeString(workflowUserManager.getCurrentUsername(), StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.onlineNotificationMessage = '\" + StringUtil.escapeString(pwaOnlineNotificationMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.offlineNotificationMessage = '\" + StringUtil.escapeString(pwaOfflineNotificationMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.loginPromptMessage = '\" + StringUtil.escapeString(pwaLoginPromptMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.syncingMessage = '\" + StringUtil.escapeString(pwaSyncingMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.syncFailedMessage = '\" + StringUtil.escapeString(pwaSyncFailedMessage, StringUtil.TYPE_JAVA, null) + \"';\"\n                        + \"PwaUtil.syncSuccessMessage = '\" + StringUtil.escapeString(pwaSyncSuccessMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.isEmbedded = \" + isEmbedded + \";\"\n                        + \"PwaUtil.register();\"\n                        + \"PwaUtil.init();\"\n                        + \"};\"\n                        + \"if (typeof PwaUtil !== \\\"undefined\\\") {initPwaUtil();} else { $(document).on(\\\"PwaUtil.ready\\\", function(){ initPwaUtil(); });}\"\n                        + \"});</script>\";\n            }\n        }\n        return jsCssLink;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "overrideCacheFile",
        "raw_code": "void overrideCacheFile(File newCacheFile) {\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n    FileUtil.logFileUsage(cacheFile, \"Override cache file\", true);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "overrideCacheFile",
        "raw_code": "void overrideCacheFile(File newCacheFile) {\n    if (!newCacheFile.exists()) {\n      logger.debug(\"Cache file doesn't exists. File: {}\", newCacheFile);\n    }\n    if (onlyOwnerPermissions) {\n      FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(\n          newCacheFile, \"Override cache file\");\n    } else {\n      FileUtil.logFileUsage(cacheFile, \"Override cache file\", false);\n    }\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "fastjson",
    "cve_id": "CVE-2022-25845",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "8f3410f81cbd437f7c459f8868445d50ad301f15",
    "short_hash": "8f3410f8",
    "vulnerableMethods_before": [
      {
        "filename": "ParserConfig.java",
        "method_name": "src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#checkAutoType",
        "raw_code": "public Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {\n        if (typeName == null) {\n            return null;\n        }\n\n        if (autoTypeCheckHandlers != null) {\n            for (AutoTypeCheckHandler h : autoTypeCheckHandlers) {\n                Class<?> type = h.handler(typeName, expectClass, features);\n                if (type != null) {\n                    return type;\n                }\n            }\n        }\n\n        final int safeModeMask = Feature.SafeMode.mask;\n        boolean safeMode = this.safeMode\n                || (features & safeModeMask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0;\n        if (safeMode) {\n            throw new JSONException(\"safeMode not support autoType : \" + typeName);\n        }\n\n        if (typeName.length() >= 192 || typeName.length() < 3) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final boolean expectClassFlag;\n        if (expectClass == null) {\n            expectClassFlag = false;\n        } else {\n            long expectHash = TypeUtils.fnv1a_64(expectClass.getName());\n            if (expectHash == 0x90a25f5baa21529eL\n                    || expectHash == 0x2d10a5801b9d6136L\n                    || expectHash == 0xaf586a571e302c6bL\n                    || expectHash == 0xed007300a7b227c6L\n                    || expectHash == 0x295c4605fd1eaa95L\n                    || expectHash == 0x47ef269aadc650b4L\n                    || expectHash == 0x6439c4dff712ae8bL\n                    || expectHash == 0xe3dd9875a2dc5283L\n                    || expectHash == 0xe2a8ddba03e69e0dL\n                    || expectHash == 0xd734ceb4c3e9d1daL\n            ) {\n                expectClassFlag = false;\n            } else {\n                expectClassFlag = true;\n            }\n        }\n\n        String className = typeName.replace('$', '.');\n        Class<?> clazz;\n\n        final long h1 = (fnv1a_64_magic_hashcode ^ className.charAt(0)) * fnv1a_64_magic_prime;\n        if (h1 == 0xaf64164c86024f1aL) { // [\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if ((h1 ^ className.charAt(className.length() - 1)) * fnv1a_64_magic_prime == 0x9198507b5af98f0L) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final long h3 = (((((fnv1a_64_magic_hashcode ^ className.charAt(0))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(1))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(2))\n                * fnv1a_64_magic_prime;\n\n        long fullHash = TypeUtils.fnv1a_64(className);\n        boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  fullHash) >= 0;\n\n        if (internalDenyHashCodes != null) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(internalDenyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n                    if (clazz != null) {\n                        return clazz;\n                    }\n                }\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {\n                    if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) {\n                        continue;\n                    }\n\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        clazz = TypeUtils.getClassFromMapping(typeName);\n\n        if (clazz == null) {\n            clazz = deserializers.findClass(typeName);\n        }\n\n        if (expectClass == null && clazz != null && Throwable.class.isAssignableFrom(clazz) && !autoTypeSupport) {\n            clazz = null;\n        }\n\n        if (clazz == null) {\n            clazz = typeMapping.get(typeName);\n        }\n\n        if (internalWhite) {\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n        }\n\n        if (clazz != null) {\n            if (expectClass != null\n                    && clazz != java.util.HashMap.class\n                    && clazz != java.util.LinkedHashMap.class\n                    && !expectClass.isAssignableFrom(clazz)) {\n                throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n            }\n\n            return clazz;\n        }\n\n        if (!autoTypeSupport) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                char c = className.charAt(i);\n                hash ^= c;\n                hash *= fnv1a_64_magic_prime;\n\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n\n                // white list\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n\n                    if (clazz == null) {\n                        return expectClass;\n                    }\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n\n                    return clazz;\n                }\n            }\n        }\n\n        boolean jsonType = false;\n        InputStream is = null;\n        try {\n            String resource = typeName.replace('.', '/') + \".class\";\n            if (defaultClassLoader != null) {\n                is = defaultClassLoader.getResourceAsStream(resource);\n            } else {\n                is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);\n            }\n            if (is != null) {\n                ClassReader classReader = new ClassReader(is, true);\n                TypeCollector visitor = new TypeCollector(\"<clinit>\", new Class[0]);\n                classReader.accept(visitor);\n                jsonType = visitor.hasJsonType();\n            }\n        } catch (Exception e) {\n            // skip\n        } finally {\n            IOUtils.close(is);\n        }\n\n        final int mask = Feature.SupportAutoType.mask;\n        boolean autoTypeSupport = this.autoTypeSupport\n                || (features & mask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0;\n\n        if (autoTypeSupport || jsonType || expectClassFlag) {\n            boolean cacheClass = autoTypeSupport || jsonType;\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);\n        }\n\n        if (clazz != null) {\n            if (jsonType) {\n                TypeUtils.addMapping(typeName, clazz);\n                return clazz;\n            }\n\n            if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger\n                    || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver\n                    || javax.sql.RowSet.class.isAssignableFrom(clazz) //\n                    ) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n\n            if (expectClass != null) {\n                if (expectClass.isAssignableFrom(clazz)) {\n                    TypeUtils.addMapping(typeName, clazz);\n                    return clazz;\n                } else {\n                    throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                }\n            }\n\n            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);\n            if (beanInfo.creatorConstructor != null && autoTypeSupport) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n        }\n\n        if (!autoTypeSupport) {\n            if (typeName.endsWith(\"Exception\")) {\n                return null;\n            }\n\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if (clazz != null) {\n            TypeUtils.addMapping(typeName, clazz);\n        }\n\n        return clazz;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ParserConfig.java",
        "method_name": "src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#checkAutoType",
        "raw_code": "public Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {\n        if (typeName == null) {\n            return null;\n        }\n\n        if (autoTypeCheckHandlers != null) {\n            for (AutoTypeCheckHandler h : autoTypeCheckHandlers) {\n                Class<?> type = h.handler(typeName, expectClass, features);\n                if (type != null) {\n                    return type;\n                }\n            }\n        }\n\n        final int safeModeMask = Feature.SafeMode.mask;\n        boolean safeMode = this.safeMode\n                || (features & safeModeMask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0;\n        if (safeMode) {\n            throw new JSONException(\"safeMode not support autoType : \" + typeName);\n        }\n\n        final int mask = Feature.SupportAutoType.mask;\n        boolean autoTypeSupport = this.autoTypeSupport\n                || (features & mask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0;\n\n        if (typeName.length() >= 192 || typeName.length() < 3) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final boolean expectClassFlag;\n        if (expectClass == null) {\n            expectClassFlag = false;\n        } else {\n            long expectHash = TypeUtils.fnv1a_64(expectClass.getName());\n            if (expectHash == 0x90a25f5baa21529eL\n                    || expectHash == 0x2d10a5801b9d6136L\n                    || expectHash == 0xaf586a571e302c6bL\n                    || expectHash == 0xed007300a7b227c6L\n                    || expectHash == 0x295c4605fd1eaa95L\n                    || expectHash == 0x47ef269aadc650b4L\n                    || expectHash == 0x6439c4dff712ae8bL\n                    || expectHash == 0xe3dd9875a2dc5283L\n                    || expectHash == 0xe2a8ddba03e69e0dL\n                    || expectHash == 0xd734ceb4c3e9d1daL\n            ) {\n                expectClassFlag = false;\n            } else {\n                expectClassFlag = true;\n            }\n        }\n\n        String className = typeName.replace('$', '.');\n        Class<?> clazz;\n\n        final long h1 = (fnv1a_64_magic_hashcode ^ className.charAt(0)) * fnv1a_64_magic_prime;\n        if (h1 == 0xaf64164c86024f1aL) { // [\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if ((h1 ^ className.charAt(className.length() - 1)) * fnv1a_64_magic_prime == 0x9198507b5af98f0L) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final long h3 = (((((fnv1a_64_magic_hashcode ^ className.charAt(0))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(1))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(2))\n                * fnv1a_64_magic_prime;\n\n        long fullHash = TypeUtils.fnv1a_64(className);\n        boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  fullHash) >= 0;\n\n        if (internalDenyHashCodes != null) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(internalDenyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n                    if (clazz != null) {\n                        return clazz;\n                    }\n                }\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {\n                    if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) {\n                        continue;\n                    }\n\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        clazz = TypeUtils.getClassFromMapping(typeName);\n\n        if (clazz == null) {\n            clazz = deserializers.findClass(typeName);\n        }\n\n        if (expectClass == null && clazz != null && Throwable.class.isAssignableFrom(clazz) && !autoTypeSupport) {\n            clazz = null;\n        }\n\n        if (clazz == null) {\n            clazz = typeMapping.get(typeName);\n        }\n\n        if (internalWhite) {\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n        }\n\n        if (clazz != null) {\n            if (expectClass != null\n                    && clazz != java.util.HashMap.class\n                    && clazz != java.util.LinkedHashMap.class\n                    && !expectClass.isAssignableFrom(clazz)) {\n                throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n            }\n\n            return clazz;\n        }\n\n        if (!autoTypeSupport) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                char c = className.charAt(i);\n                hash ^= c;\n                hash *= fnv1a_64_magic_prime;\n\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0) {\n                    if (typeName.endsWith(\"Exception\") || typeName.endsWith(\"Error\")) {\n                        return null;\n                    }\n\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n\n                // white list\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n\n                    if (clazz == null) {\n                        return expectClass;\n                    }\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n\n                    return clazz;\n                }\n            }\n        }\n\n        boolean jsonType = false;\n        InputStream is = null;\n        try {\n            String resource = typeName.replace('.', '/') + \".class\";\n            if (defaultClassLoader != null) {\n                is = defaultClassLoader.getResourceAsStream(resource);\n            } else {\n                is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);\n            }\n            if (is != null) {\n                ClassReader classReader = new ClassReader(is, true);\n                TypeCollector visitor = new TypeCollector(\"<clinit>\", new Class[0]);\n                classReader.accept(visitor);\n                jsonType = visitor.hasJsonType();\n            }\n        } catch (Exception e) {\n            // skip\n        } finally {\n            IOUtils.close(is);\n        }\n\n        if (autoTypeSupport || jsonType || expectClassFlag) {\n            boolean cacheClass = autoTypeSupport || jsonType;\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);\n        }\n\n        if (clazz != null) {\n            if (jsonType) {\n                if (autoTypeSupport) {\n                    TypeUtils.addMapping(typeName, clazz);\n                }\n                return clazz;\n            }\n\n            if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger\n                    || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver\n                    || javax.sql.RowSet.class.isAssignableFrom(clazz) //\n                    ) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n\n            if (expectClass != null) {\n                if (expectClass.isAssignableFrom(clazz)) {\n                    if (autoTypeSupport) {\n                        TypeUtils.addMapping(typeName, clazz);\n                    }\n                    return clazz;\n                } else {\n                    throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                }\n            }\n\n            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);\n            if (beanInfo.creatorConstructor != null && autoTypeSupport) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n        }\n\n        if (!autoTypeSupport) {\n            if (typeName.endsWith(\"Exception\") || typeName.endsWith(\"Error\")) {\n                return null;\n            }\n\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if (clazz != null) {\n            if (autoTypeSupport) {\n                TypeUtils.addMapping(typeName, clazz);\n            }\n        }\n\n        return clazz;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "syntax-markdown",
    "cve_id": "CVE-2025-46558",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "d136472d6e8a47981a0ede420a9096f88ffa5035",
    "short_hash": "d136472d",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractMarkdownConfiguration.java",
        "method_name": "getDefaultOptions",
        "raw_code": "protected MutableDataHolder getDefaultOptions(ParserEmulationProfile parserEmulationProfile,\n        List<Class<?>> additionalExtensionClasses)\n    {\n        // Configure Parser Family\n        MutableDataHolder options = new MutableDataSet();\n        options.setFrom(parserEmulationProfile);\n\n        // Configure extensions\n        List<Extension> extensions = new ArrayList<>();\n        List<Class<?>> resolvedExensionClasses = new ArrayList<>();\n        resolvedExensionClasses.addAll(DEFAULT_EXTENSIONS);\n        resolvedExensionClasses.addAll(additionalExtensionClasses);\n        for (Class<?> extensionClass : resolvedExensionClasses) {\n            try {\n                Method method = extensionClass.getMethod(\"create\");\n                Extension extension = (Extension) method.invoke(null);\n                extensions.add(extension);\n            } catch (Exception e) {\n                // Invalid extension, skip it\n                getLogger().warn(\"Invalid extension: [{}]. Root cause: [{}]\", extensionClass.getName(),\n                    ExceptionUtils.getRootCauseMessage(e));\n            }\n            options.set(Parser.EXTENSIONS, extensions);\n        }\n\n        return options;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractMarkdownConfiguration.java",
        "method_name": "getDefaultOptions",
        "raw_code": "protected MutableDataHolder getDefaultOptions(ParserEmulationProfile parserEmulationProfile,\n        List<Class<?>> additionalExtensionClasses)\n    {\n        // Configure Parser Family\n        MutableDataHolder options = new MutableDataSet();\n        options.setFrom(parserEmulationProfile);\n\n        // Configure extensions\n        List<Extension> extensions = new ArrayList<>();\n        List<Class<?>> resolvedExensionClasses = new ArrayList<>();\n        resolvedExensionClasses.addAll(DEFAULT_EXTENSIONS);\n        resolvedExensionClasses.addAll(additionalExtensionClasses);\n        for (Class<?> extensionClass : resolvedExensionClasses) {\n            try {\n                Method method = extensionClass.getMethod(\"create\");\n                Extension extension = (Extension) method.invoke(null);\n                extensions.add(extension);\n            } catch (Exception e) {\n                // Invalid extension, skip it\n                getLogger().warn(\"Invalid extension: [{}]. Root cause: [{}]\", extensionClass.getName(),\n                    ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n        options.set(Parser.EXTENSIONS, extensions);\n\n        return options;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "rabbitmq-java-client",
    "cve_id": "CVE-2023-46120",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "714aae602dcae6cb4b53cadf009323ebac313cc8",
    "short_hash": "714aae60",
    "vulnerableMethods_before": [
      {
        "filename": "CommandAssembler.java",
        "method_name": "src/main/java/com/rabbitmq/client/impl/CommandAssembler.java#consumeHeaderFrame",
        "raw_code": "private void consumeHeaderFrame(Frame f) throws IOException {\n        if (f.type == AMQP.FRAME_HEADER) {\n            this.contentHeader = AMQImpl.readContentHeaderFrom(f.getInputStream());\n            this.remainingBodyBytes = this.contentHeader.getBodySize();\n            updateContentBodyState();\n        } else {\n            throw new UnexpectedFrameError(f, AMQP.FRAME_HEADER);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CommandAssembler.java",
        "method_name": "src/main/java/com/rabbitmq/client/impl/CommandAssembler.java#consumeHeaderFrame",
        "raw_code": "private void consumeHeaderFrame(Frame f) throws IOException {\n        if (f.type == AMQP.FRAME_HEADER) {\n            this.contentHeader = AMQImpl.readContentHeaderFrom(f.getInputStream());\n            long bodySize = this.contentHeader.getBodySize();\n            if (bodySize >= this.maxBodyLength) {\n                throw new IllegalStateException(format(\n                    \"Message body is too large (%d), maximum size is %d\",\n                    bodySize, this.maxBodyLength\n                ));\n            }\n            this.remainingBodyBytes = bodySize;\n            updateContentBodyState();\n        } else {\n            throw new UnexpectedFrameError(f, AMQP.FRAME_HEADER);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-37913",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "45d182a4141ff22f3ff289cf71e4669bdc714544",
    "short_hash": "45d182a4",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultXHTMLOfficeDocumentBuilder.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/builder/DefaultXHTMLOfficeDocumentBuilder.java#handleArtifacts",
        "raw_code": "private Set<File> handleArtifacts(Document xhtmlDoc, OfficeConverterResult officeConverterResult)\n        throws OfficeImporterException\n    {\n        Set<File> artifacts = new HashSet<>(officeConverterResult.getAllFiles());\n        artifacts.remove(officeConverterResult.getOutputFile());\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) xhtmlDoc.getUserData(\"embeddedImages\");\n        if (embeddedImages != null) {\n            File outputDirectory = officeConverterResult.getOutputDirectory();\n            for (Map.Entry<String, byte[]> embeddedImage : embeddedImages.entrySet()) {\n                File outputFile = new File(outputDirectory, embeddedImage.getKey());\n                try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n                    IOUtils.write(embeddedImage.getValue(), fos);\n                } catch (IOException e) {\n                    throw new OfficeImporterException(\n                        String.format(\"Error when writing embedded image file [%s]\", outputFile.getAbsolutePath()), e);\n                }\n                artifacts.add(outputFile);\n            }\n        }\n        return artifacts;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultXHTMLOfficeDocumentBuilder.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/builder/DefaultXHTMLOfficeDocumentBuilder.java#handleArtifacts",
        "raw_code": "private Map<String, OfficeDocumentArtifact> handleArtifacts(Document xhtmlDoc,\n        OfficeConverterResult officeConverterResult, String replacePrefix, String replacementPrefix)\n    {\n        Map<String, OfficeDocumentArtifact> artifacts = new HashMap<>();\n        for (File file : officeConverterResult.getAllFiles()) {\n            // Rename the file if it starts with the static prefix similar to the image filter.\n            String filename = file.getName();\n            if (StringUtils.startsWith(filename, replacePrefix)) {\n                filename = replacementPrefix + StringUtils.removeStart(filename, replacePrefix);\n            }\n            artifacts.put(filename, new FileOfficeDocumentArtifact(file.getName(), file));\n        }\n        // Remove the output file from the artifacts\n        artifacts.remove(officeConverterResult.getOutputFile().getName());\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) xhtmlDoc.getUserData(\"embeddedImages\");\n        if (embeddedImages != null) {\n            for (Map.Entry<String, byte[]> embeddedImage : embeddedImages.entrySet()) {\n                String fileName = embeddedImage.getKey();\n                artifacts.put(fileName, new ByteArrayOfficeDocumentArtifact(fileName, embeddedImage.getValue()));\n            }\n        }\n        return artifacts;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "drawio",
    "cve_id": "CVE-2022-1767",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "c63f3a04450f30798df47f9badbc74eb8a69fbdf",
    "short_hash": "c63f3a04",
    "vulnerableMethods_before": [
      {
        "filename": "ProxyServlet.java",
        "method_name": "src/main/java/com/mxgraph/online/ExportProxyServlet.java#doGet",
        "raw_code": "protected void doGet(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws ServletException, IOException\n\t{\n\t\tString urlParam = request.getParameter(\"url\");\n\n\t\tif (Utils.sanitizeUrl(urlParam))\n\t\t{\n\t\t\t// build the UML source from the compressed request parameter\n\t\t\tString ref = request.getHeader(\"referer\");\n\t\t\tString ua = request.getHeader(\"User-Agent\");\n\t\t\tString auth = request.getHeader(\"Authorization\");\n\t\t\tString dom = getCorsDomain(ref, ua);\n\n\t\t\ttry(OutputStream out = response.getOutputStream())\n\t\t\t{\n\t\t\t\trequest.setCharacterEncoding(\"UTF-8\");\n\t\t\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\n\t\t\t\tURL url = new URL(urlParam);\n\t\t\t\tURLConnection connection = url.openConnection();\n\t\t\t\tconnection.setConnectTimeout(TIMEOUT);\n\t\t\t\tconnection.setReadTimeout(TIMEOUT);\n\t\t\t\t\n\t\t\t\tresponse.setHeader(\"Cache-Control\", \"private, max-age=86400\");\n\n\t\t\t\t// Workaround for 451 response from Iconfinder CDN\n\t\t\t\tconnection.setRequestProperty(\"User-Agent\", \"draw.io\");\n\t\t\t\t\n\t\t\t\t//Forward auth header\n\t\t\t\tif (auth  !=  null)\n\t\t\t\t{\n\t\t\t\t\tconnection.setRequestProperty(\"Authorization\", auth);\n\t\t\t\t}\n\n\t\t\t\tif (dom != null && dom.length() > 0)\n\t\t\t\t{\n\t\t\t\t\tresponse.addHeader(\"Access-Control-Allow-Origin\", dom);\n\t\t\t\t}\n\n\t\t\t\t// Status code pass-through and follow redirects\n\t\t\t\tif (connection instanceof HttpURLConnection)\n\t\t\t\t{\n\t\t\t\t\t((HttpURLConnection) connection)\n\t\t\t\t\t\t\t.setInstanceFollowRedirects(true);\n\t\t\t\t\tint status = ((HttpURLConnection) connection)\n\t\t\t\t\t\t\t.getResponseCode();\n\t\t\t\t\tint counter = 0;\n\n\t\t\t\t\t// Follows a maximum of 6 redirects \n\t\t\t\t\twhile (counter++ <= 6\n\t\t\t\t\t\t\t&& (status == HttpURLConnection.HTTP_MOVED_PERM\n\t\t\t\t\t\t\t\t\t|| status == HttpURLConnection.HTTP_MOVED_TEMP))\n\t\t\t\t\t{\n\t\t\t\t\t\tString redirectUrl = connection.getHeaderField(\"Location\");\n\n\t\t\t\t\t\tif (!Utils.sanitizeUrl(redirectUrl))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\turl = new URL(redirectUrl);\n\t\t\t\t\t\tconnection = url.openConnection();\n\t\t\t\t\t\t((HttpURLConnection) connection)\n\t\t\t\t\t\t\t\t.setInstanceFollowRedirects(true);\n\t\t\t\t\t\tconnection.setConnectTimeout(TIMEOUT);\n\t\t\t\t\t\tconnection.setReadTimeout(TIMEOUT);\n\n\t\t\t\t\t\t// Workaround for 451 response from Iconfinder CDN\n\t\t\t\t\t\tconnection.setRequestProperty(\"User-Agent\", \"draw.io\");\n\t\t\t\t\t\tstatus = ((HttpURLConnection) connection)\n\t\t\t\t\t\t\t\t.getResponseCode();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (status >= 200 && status <= 299)\n\t\t\t\t\t{\n\t\t\t\t\t\tresponse.setStatus(status);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Copies input stream to output stream\n\t\t\t\t\t\tInputStream is = connection.getInputStream();\n\t\t\t\t\t\tbyte[] head = (contentAlwaysAllowed(urlParam)) ? emptyBytes\n\t\t\t\t\t\t\t\t: Utils.checkStreamContent(is);\n\t\t\t\t\t\tresponse.setContentType(\"application/octet-stream\");\n\t\t\t\t\t\tString base64 = request.getParameter(\"base64\");\n\t\t\t\t\t\tcopyResponse(is, out, head,\n\t\t\t\t\t\t\t\tbase64 != null && base64.equals(\"1\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresponse.setStatus(HttpURLConnection.HTTP_PRECON_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresponse.setStatus(HttpURLConnection.HTTP_UNSUPPORTED_TYPE);\n\t\t\t\t}\n\n\t\t\t\tout.flush();\n\n\t\t\t\tlog.log(Level.FINEST, \"processed proxy request: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t}\n\t\t\tcatch (DeadlineExceededException e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_REQUEST_TIMEOUT);\n\t\t\t}\n\t\t\tcatch (UnknownHostException | FileNotFoundException e)\n\t\t\t{\n\t\t\t\t// do not log 404 and DNS errors\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t\tcatch (UnsupportedContentException e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n\t\t\t\tlog.log(Level.SEVERE, \"proxy request with invalid content: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(\n\t\t\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\tlog.log(Level.FINE, \"proxy request failed: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\tlog.log(Level.SEVERE,\n\t\t\t\t\t\"proxy request with invalid URL parameter: url=\"\n\t\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\"));\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ProxyServlet.java",
        "method_name": "src/main/java/com/mxgraph/online/ExportProxyServlet.java#doGet",
        "raw_code": "protected void doGet(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws ServletException, IOException\n\t{\n\t\tString urlParam = request.getParameter(\"url\");\n\n\t\tif (Utils.sanitizeUrl(urlParam))\n\t\t{\n\t\t\t// build the UML source from the compressed request parameter\n\t\t\tString ref = request.getHeader(\"referer\");\n\t\t\tString ua = request.getHeader(\"User-Agent\");\n\t\t\tString auth = request.getHeader(\"Authorization\");\n\t\t\tString dom = getCorsDomain(ref, ua);\n\n\t\t\ttry(OutputStream out = response.getOutputStream())\n\t\t\t{\n\t\t\t\trequest.setCharacterEncoding(\"UTF-8\");\n\t\t\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\n\t\t\t\tURL url = new URL(urlParam);\n\t\t\t\tURLConnection connection = url.openConnection();\n\t\t\t\tconnection.setConnectTimeout(TIMEOUT);\n\t\t\t\tconnection.setReadTimeout(TIMEOUT);\n\t\t\t\t\n\t\t\t\tresponse.setHeader(\"Cache-Control\", \"private, max-age=86400\");\n\n\t\t\t\t// Workaround for 451 response from Iconfinder CDN\n\t\t\t\tconnection.setRequestProperty(\"User-Agent\", \"draw.io\");\n\t\t\t\t\n\t\t\t\t//Forward auth header\n\t\t\t\tif (auth  !=  null)\n\t\t\t\t{\n\t\t\t\t\tconnection.setRequestProperty(\"Authorization\", auth);\n\t\t\t\t}\n\n\t\t\t\tif (dom != null && dom.length() > 0)\n\t\t\t\t{\n\t\t\t\t\tresponse.addHeader(\"Access-Control-Allow-Origin\", dom);\n\t\t\t\t}\n\n\t\t\t\t// Status code pass-through and follow redirects\n\t\t\t\tif (connection instanceof HttpURLConnection)\n\t\t\t\t{\n\t\t\t\t\t((HttpURLConnection) connection)\n\t\t\t\t\t\t\t.setInstanceFollowRedirects(false);\n\t\t\t\t\tint status = ((HttpURLConnection) connection)\n\t\t\t\t\t\t\t.getResponseCode();\n\t\t\t\t\tint counter = 0;\n\n\t\t\t\t\t// Follows a maximum of 6 redirects \n\t\t\t\t\twhile (counter++ <= 6 && (int)(status / 10) == 30) //Any redirect status 30x\n\t\t\t\t\t{\n\t\t\t\t\t\tString redirectUrl = connection.getHeaderField(\"Location\");\n\n\t\t\t\t\t\tif (!Utils.sanitizeUrl(redirectUrl))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\turl = new URL(redirectUrl);\n\t\t\t\t\t\tconnection = url.openConnection();\n\t\t\t\t\t\t((HttpURLConnection) connection)\n\t\t\t\t\t\t\t\t.setInstanceFollowRedirects(false);\n\t\t\t\t\t\tconnection.setConnectTimeout(TIMEOUT);\n\t\t\t\t\t\tconnection.setReadTimeout(TIMEOUT);\n\n\t\t\t\t\t\t// Workaround for 451 response from Iconfinder CDN\n\t\t\t\t\t\tconnection.setRequestProperty(\"User-Agent\", \"draw.io\");\n\t\t\t\t\t\tstatus = ((HttpURLConnection) connection)\n\t\t\t\t\t\t\t\t.getResponseCode();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (status >= 200 && status <= 299)\n\t\t\t\t\t{\n\t\t\t\t\t\tresponse.setStatus(status);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Copies input stream to output stream\n\t\t\t\t\t\tInputStream is = connection.getInputStream();\n\t\t\t\t\t\tbyte[] head = (contentAlwaysAllowed(urlParam)) ? emptyBytes\n\t\t\t\t\t\t\t\t: Utils.checkStreamContent(is);\n\t\t\t\t\t\tresponse.setContentType(\"application/octet-stream\");\n\t\t\t\t\t\tString base64 = request.getParameter(\"base64\");\n\t\t\t\t\t\tcopyResponse(is, out, head,\n\t\t\t\t\t\t\t\tbase64 != null && base64.equals(\"1\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresponse.setStatus(HttpURLConnection.HTTP_PRECON_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresponse.setStatus(HttpURLConnection.HTTP_UNSUPPORTED_TYPE);\n\t\t\t\t}\n\n\t\t\t\tout.flush();\n\n\t\t\t\tlog.log(Level.FINEST, \"processed proxy request: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t}\n\t\t\tcatch (DeadlineExceededException e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_REQUEST_TIMEOUT);\n\t\t\t}\n\t\t\tcatch (UnknownHostException | FileNotFoundException e)\n\t\t\t{\n\t\t\t\t// do not log 404 and DNS errors\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t\tcatch (UnsupportedContentException e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n\t\t\t\tlog.log(Level.SEVERE, \"proxy request with invalid content: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(\n\t\t\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\tlog.log(Level.FINE, \"proxy request failed: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\tlog.log(Level.SEVERE,\n\t\t\t\t\t\"proxy request with invalid URL parameter: url=\"\n\t\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\"));\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jmix",
    "cve_id": "CVE-2025-32950",
    "cwe_list": [
      "CWE-35"
    ],
    "commit_hash": "cc97e6ff974b9e7af8160fab39cc5866169daa37",
    "short_hash": "cc97e6ff",
    "vulnerableMethods_before": [
      {
        "filename": "FileDownloadController.java",
        "method_name": "downloadFile",
        "raw_code": "@GetMapping\n    public void downloadFile(@RequestParam String fileRef,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkFileDownloadPermission();\n        try {\n            FileRef fileReference;\n            fileReference = FileRef.fromString(fileRef);\n            fileTransferService.downloadAndWriteResponse(fileReference, fileReference.getStorageName(), attachment, response);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid file reference\",\n                    String.format(\"Cannot convert '%s' into valid file reference\", fileRef),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileDownloadController.java",
        "method_name": "downloadFile",
        "raw_code": "@GetMapping\n    public void downloadFile(@RequestParam String fileRef,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkFileDownloadPermission();\n        try {\n            FileRef fileReference;\n            fileReference = FileRef.fromString(fileRef);\n            attachment = resolveAttachmentValue(attachment, fileReference);\n            fileTransferService.downloadAndWriteResponse(fileReference, fileReference.getStorageName(), attachment, response);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid file reference\",\n                    String.format(\"Cannot convert '%s' into valid file reference\", fileRef),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "dhis2-core",
    "cve_id": "CVE-2022-24848",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "ef04483a9b177d62e48dcf4e498b302a11f95e7d",
    "short_hash": "ef04483a",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultProgramService.java",
        "method_name": "dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/program/DefaultProgramService.java#getProgramOrganisationUnitsAssociationsForCurrentUser",
        "raw_code": "@Override\n    public SetValuedMap<String, String> getProgramOrganisationUnitsAssociationsForCurrentUser( Set<String> programUids )\n    {\n        idObjectManager.getAndValidateByUid( Program.class, programUids );\n\n        return jdbcOrgUnitAssociationsStore.getOrganisationUnitsAssociationsForCurrentUser( programUids );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-29208",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "d9e947559077e947315bf700c5703dfc7dd8a8d7",
    "short_hash": "d9e94755",
    "vulnerableMethods_before": [
      {
        "filename": "DeletedDocument.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/api/DeletedDocument.java#canUndelete",
        "raw_code": "public boolean canUndelete()\n    {\n        try {\n            return hasAccessLevel(ADMIN_RIGHT, getFullName()) || hasAccessLevel(\"undelete\", getFullName())\n                || (Objects.equals(this.context.getUserReference(), getDeleterReference())\n                    && hasAccess(Right.EDIT, getDocumentReference()));\n        } catch (XWikiException ex) {\n            // Public APIs should not throw exceptions\n            LOGGER.warn(\"Exception while checking if entry [{}] can be restored from the recycle bin\", getId(), ex);\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DeletedDocument.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/api/DeletedDocument.java#canUndelete",
        "raw_code": "public boolean canUndelete()\n    {\n        return hasAccess(Right.EDIT);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "bc-java",
    "cve_id": "CVE-2016-1000339",
    "cwe_list": [
      "CWE-310"
    ],
    "commit_hash": "413b42f4d770456508585c830cfcde95f9b0e93b#diff-54656f860db94b867ba7542430cd2ef0",
    "short_hash": "413b42f4",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "KeyFactorySpi.java",
        "method_name": "engineGeneratePublic",
        "raw_code": "protected PublicKey engineGeneratePublic(\n        KeySpec keySpec)\n        throws InvalidKeySpecException\n    {\n        if (keySpec instanceof DHPublicKeySpec)\n        {\n            try\n            {\n                return new BCDHPublicKey((DHPublicKeySpec)keySpec);\n            }\n            catch (IllegalArgumentException e)\n            {\n                throw new InvalidKeySpecException(e.getMessage(), e);\n            }\n        }\n\n        return super.engineGeneratePublic(keySpec);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cxf",
    "cve_id": "CVE-2018-8039",
    "cwe_list": [
      "CWE-755"
    ],
    "commit_hash": "fae6fabf9bd7647f5e9cb68897a7d72b545b741b",
    "short_hash": "fae6fabf",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultHostnameVerifier.java",
        "method_name": "rt/transports/http/src/main/java/org/apache/cxf/transport/https/httpclient/DefaultHostnameVerifier.java#verify",
        "raw_code": "@Override\n    public boolean verify(final String host, final SSLSession session) {\n        try {\n            final Certificate[] certs = session.getPeerCertificates();\n            final X509Certificate x509 = (X509Certificate) certs[0];\n            verify(host, x509);\n            return true;\n        } catch (final SSLException ex) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n            }\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultHostnameVerifier.java",
        "method_name": "rt/transports/http/src/main/java/org/apache/cxf/transport/https/httpclient/DefaultHostnameVerifier.java#verify",
        "raw_code": "public boolean verify(final String host, final String certHostname) {\n        try {\n            matchCN(host, certHostname, this.publicSuffixMatcher);\n            return true;\n        } catch (SSLException ex) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n            }\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "05f795bb7cf18856004f40e5042709e550ed0d6e",
    "short_hash": "05f795bb",
    "vulnerableMethods_before": [
      {
        "filename": "HibernateConstraintViolationBuilder.java",
        "method_name": "enableExpressionLanguage",
        "raw_code": "@Incubating\n\tHibernateConstraintViolationBuilder enableExpressionLanguage();",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HibernateConstraintViolationBuilder.java",
        "method_name": "enableExpressionLanguage",
        "raw_code": "@Incubating\n\tHibernateConstraintViolationBuilder enableExpressionLanguage(ExpressionLanguageFeatureLevel level);",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "shopizer",
    "cve_id": "CVE-2022-23061",
    "cwe_list": [
      "CWE-639"
    ],
    "commit_hash": "6b9f1ecd303b3b724d96bd08095c1a751dcc287e",
    "short_hash": "6b9f1ecd",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "ProductPriceUtils.java",
        "method_name": "sm-core/src/main/java/com/salesmanager/core/business/utils/ProductPriceUtils.java#getFinalPrice",
        "raw_code": "public FinalPrice getFinalPrice(Product product) {\n\n\n\n\t\tFinalPrice finalPrice = calculateFinalPrice(product);\n\t\t\n\t\t//attributes\n\t\tBigDecimal attributePrice = null;\n\t\tif(product.getAttributes()!=null && product.getAttributes().size()>0) {\n\t\t\tfor(ProductAttribute attribute : product.getAttributes()) {\n\t\t\t\t\tif(attribute.getAttributeDefault()) {\n\t\t\t\t\t\tif(attribute.getProductAttributePrice()!=null && attribute.getProductAttributePrice().doubleValue()>0) {\n\t\t\t\t\t\t\tif(attributePrice==null) {\n\t\t\t\t\t\t\t\tattributePrice = new BigDecimal(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tattributePrice = attributePrice.add(attribute.getProductAttributePrice());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(attributePrice!=null && attributePrice.doubleValue()>0) {\n\t\t\t\tBigDecimal fp = finalPrice.getFinalPrice();\n\t\t\t\tfp = fp.add(attributePrice);\n\t\t\t\tfinalPrice.setFinalPrice(fp);\n\t\t\t\t\n\t\t\t\tBigDecimal op = finalPrice.getOriginalPrice();\n\t\t\t\top = op.add(attributePrice);\n\t\t\t\tfinalPrice.setOriginalPrice(op);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinalPrice.setStringPrice(this.getStringAmount(finalPrice.getFinalPrice()));\n\n\t\treturn finalPrice;\n\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        try {\n            XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n            XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n            if (avatarAttachment != null) {\n                icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                    \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n            }\n        } catch (XWikiException e) {\n            this.logger.warn(\n                \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n        }\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n                XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n                if (avatarAttachment != null) {\n                    icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                        \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                    icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n                }\n            } catch (XWikiException e) {\n                this.logger.warn(\n                    \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                    groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "d2db40b9e7d22c7a0b44d7665242dfc7b4d14d78",
    "short_hash": "d2db40b9",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractMessageInterpolator.java",
        "method_name": "interpolateMessage",
        "raw_code": "private String interpolateMessage(String message, Context context, Locale locale) throws MessageDescriptorFormatException {\n\t\t// if the message does not contain any message parameter, we can ignore the next steps and just return\n\t\t// the unescaped message. It avoids storing the message in the cache and a cache lookup.\n\t\tif ( message.indexOf( '{' ) < 0 ) {\n\t\t\treturn replaceEscapedLiterals( message );\n\t\t}\n\n\t\tString resolvedMessage = null;\n\n\t\t// either retrieve message from cache, or if message is not yet there or caching is disabled,\n\t\t// perform message resolution algorithm (step 1)\n\t\tif ( cachingEnabled ) {\n\t\t\tresolvedMessage = resolvedMessages.computeIfAbsent( new LocalizedMessage( message, locale ), lm -> resolveMessage( message, locale ) );\n\t\t}\n\t\telse {\n\t\t\tresolvedMessage = resolveMessage( message, locale );\n\t\t}\n\n\t\t// there's no need for steps 2-3 unless there's `{param}`/`${expr}` in the message\n\t\tif ( resolvedMessage.indexOf( '{' ) > -1 ) {\n\t\t\t// resolve parameter expressions (step 2)\n\t\t\tresolvedMessage = interpolateExpression(\n\t\t\t\t\tnew TokenIterator( getParameterTokens( resolvedMessage, tokenizedParameterMessages, InterpolationTermType.PARAMETER ) ),\n\t\t\t\t\tcontext,\n\t\t\t\t\tlocale\n\t\t\t);\n\n\t\t\t// resolve EL expressions (step 3)\n\t\t\t// in the standard Hibernate Validator execution flow, the context is always an instance of\n\t\t\t// HibernateMessageInterpolatorContext\n\t\t\t// but it can be a spec Context in the Jakarta Bean Validation TCK.\n\t\t\tif ( !( context instanceof HibernateMessageInterpolatorContext )\n\t\t\t\t\t|| ( (HibernateMessageInterpolatorContext) context ).isExpressionLanguageEnabled() ) {\n\t\t\t\tresolvedMessage = interpolateExpression(\n\t\t\t\t\t\tnew TokenIterator( getParameterTokens( resolvedMessage, tokenizedELMessages, InterpolationTermType.EL ) ),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tlocale );\n\t\t\t}\n\t\t}\n\n\t\t// last but not least we have to take care of escaped literals\n\t\tresolvedMessage = replaceEscapedLiterals( resolvedMessage );\n\n\t\treturn resolvedMessage;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractMessageInterpolator.java",
        "method_name": "interpolateMessage",
        "raw_code": "private String interpolateMessage(String message, Context context, Locale locale) throws MessageDescriptorFormatException {\n\t\t// if the message does not contain any message parameter, we can ignore the next steps and just return\n\t\t// the unescaped message. It avoids storing the message in the cache and a cache lookup.\n\t\tif ( message.indexOf( '{' ) < 0 ) {\n\t\t\treturn replaceEscapedLiterals( message );\n\t\t}\n\n\t\tString resolvedMessage = null;\n\n\t\t// either retrieve message from cache, or if message is not yet there or caching is disabled,\n\t\t// perform message resolution algorithm (step 1)\n\t\tif ( cachingEnabled ) {\n\t\t\tresolvedMessage = resolvedMessages.computeIfAbsent( new LocalizedMessage( message, locale ), lm -> resolveMessage( message, locale ) );\n\t\t}\n\t\telse {\n\t\t\tresolvedMessage = resolveMessage( message, locale );\n\t\t}\n\n\t\t// there's no need for steps 2-3 unless there's `{param}`/`${expr}` in the message\n\t\tif ( resolvedMessage.indexOf( '{' ) > -1 ) {\n\t\t\t// resolve parameter expressions (step 2)\n\t\t\tresolvedMessage = interpolateExpression(\n\t\t\t\t\tnew TokenIterator( getParameterTokens( resolvedMessage, tokenizedParameterMessages, InterpolationTermType.PARAMETER ) ),\n\t\t\t\t\tcontext,\n\t\t\t\t\tlocale\n\t\t\t);\n\n\t\t\t// resolve EL expressions (step 3)\n\t\t\t// in the standard Hibernate Validator execution flow, the context is always an instance of\n\t\t\t// HibernateMessageInterpolatorContext\n\t\t\t// but it can be a spec Context in the Jakarta Bean Validation TCK.\n\t\t\tif ( !( context instanceof HibernateMessageInterpolatorContext )\n\t\t\t\t\t|| ( (HibernateMessageInterpolatorContext) context ).getExpressionLanguageFeatureLevel() != ExpressionLanguageFeatureLevel.NONE ) {\n\t\t\t\tresolvedMessage = interpolateExpression(\n\t\t\t\t\t\tnew TokenIterator( getParameterTokens( resolvedMessage, tokenizedELMessages, InterpolationTermType.EL ) ),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tlocale );\n\t\t\t}\n\t\t}\n\n\t\t// last but not least we have to take care of escaped literals\n\t\tresolvedMessage = replaceEscapedLiterals( resolvedMessage );\n\n\t\treturn resolvedMessage;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hertzbeat",
    "cve_id": "CVE-2023-51388",
    "cwe_list": [
      "CWE-74"
    ],
    "commit_hash": "8dcf050e27ca95d15460a7ba98a3df8a9cd1d3d2",
    "short_hash": "8dcf050e",
    "vulnerableMethods_before": [
      {
        "filename": "AviatorConfiguration.java",
        "method_name": "configAviatorEvaluator",
        "raw_code": "@Bean\n    public void configAviatorEvaluator() {\n        // AviatorEvaluatorLRU\n        AviatorEvaluator.getInstance()\n                .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                .addFunction(new StrEqualFunction());\n\n        // aviator\n        AviatorEvaluator.getInstance().addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                      final AviatorObject arg2) {\n                try {\n                    Object value1 = arg1.getValue(env);\n                    Object value2 = arg2.getValue(env);\n                    Object currentValue = value1 == null ? value2 : value1;\n                    if (arg1.getAviatorType() == AviatorType.String) {\n                        return new AviatorString(String.valueOf(currentValue));\n                    } else {\n                        return AviatorDouble.valueOf(currentValue);\n                    }\n                } catch (Exception e) {\n                    log.error(e.getMessage());\n                }\n                return arg1.bitOr(arg2, env);\n            }\n            @Override\n            public String getName() {\n                return OperatorType.BIT_OR.getToken();\n            }\n        });\n\n        AviatorEvaluator.getInstance().addFunction(new StrContainsFunction());\n        AviatorEvaluator.getInstance().addFunction(new ObjectExistsFunction());\n        AviatorEvaluator.getInstance().addFunction(new StrMatchesFunction());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AviatorConfiguration.java",
        "method_name": "configAviatorEvaluator",
        "raw_code": "@Bean\n    public void configAviatorEvaluator() {\n        AviatorEvaluatorInstance instance = AviatorEvaluator.getInstance();\n\n        // AviatorEvaluatorLRU\n        instance\n                .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                .addFunction(new StrEqualFunction());\n\n        // Aviator\n        instance.setOption(Options.FEATURE_SET,\n                Feature.asSet(Feature.If,\n                        Feature.Assignment,\n                        Feature.Let,\n                        Feature.StringInterpolation));\n\n        // aviator\n        instance.addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                      final AviatorObject arg2) {\n                try {\n                    Object value1 = arg1.getValue(env);\n                    Object value2 = arg2.getValue(env);\n                    Object currentValue = value1 == null ? value2 : value1;\n                    if (arg1.getAviatorType() == AviatorType.String) {\n                        return new AviatorString(String.valueOf(currentValue));\n                    } else {\n                        return AviatorDouble.valueOf(currentValue);\n                    }\n                } catch (Exception e) {\n                    log.error(e.getMessage());\n                }\n                return arg1.bitOr(arg2, env);\n            }\n            @Override\n            public String getName() {\n                return OperatorType.BIT_OR.getToken();\n            }\n        });\n\n        instance.addFunction(new StrContainsFunction());\n        instance.addFunction(new ObjectExistsFunction());\n        instance.addFunction(new StrMatchesFunction());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jenkins",
    "cve_id": "CVE-2017-2600",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "0f92cd08a19207de2cceb6a2f4e3e9f92fdc0899",
    "short_hash": "0f92cd08",
    "vulnerableMethods_before": [
      {
        "filename": "Computer.java",
        "method_name": "core/src/main/java/hudson/model/Computer.java#getMonitorData",
        "raw_code": "@Exported(inline=true)\n    public Map<String/*monitor name*/,Object> getMonitorData() {\n        Map<String,Object> r = new HashMap<String, Object>();\n        for (NodeMonitor monitor : NodeMonitor.getAll())\n            r.put(monitor.getClass().getName(),monitor.data(this));\n        return r;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Computer.java",
        "method_name": "core/src/main/java/hudson/model/Computer.java#getMonitorData",
        "raw_code": "@Exported(inline=true)\n    public Map<String/*monitor name*/,Object> getMonitorData() {\n        Map<String,Object> r = new HashMap<String, Object>();\n        if (hasPermission(CONNECT)) {\n            for (NodeMonitor monitor : NodeMonitor.getAll())\n                r.put(monitor.getClass().getName(), monitor.data(this));\n        }\n        return r;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "californium",
    "cve_id": "CVE-2022-39368",
    "cwe_list": [
      "CWE-459"
    ],
    "commit_hash": "726bac57659410da463dcf404b3e79a7312ac0b9",
    "short_hash": "726bac57",
    "vulnerableMethods_before": [
      {
        "filename": "DTLSConnector.java",
        "method_name": "scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java#stop",
        "raw_code": "@Override\n\tpublic void stop() {\n\t\tExecutorService shutdownTimer = null;\n\t\tExecutorService shutdown = null;\n\t\tList<Runnable> pending = new ArrayList<>();\n\t\tboolean stop;\n\t\tsynchronized (this) {\n\t\t\tstop = running.compareAndSet(true, false);\n\t\t\tif (stop) {\n\t\t\t\tLOGGER.debug(\"DTLS connector on [{}] stopping ...\", lastBindAddress);\n\t\t\t\tif (statusLogger != null) {\n\t\t\t\t\tstatusLogger.cancel(false);\n\t\t\t\t\tstatusLogger = null;\n\t\t\t\t}\n\t\t\t\tif (recentHandshakeCleaner != null) {\n\t\t\t\t\trecentHandshakeCleaner.cancel(false);\n\t\t\t\t\trecentHandshakeCleaner = null;\n\t\t\t\t}\n\t\t\t\t// recent handshakes will be restored from connection store,\n\t\t\t\tclearRecentHandshakes();\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t}\n\t\t\t\tif (socket != null) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t\tsocket = null;\n\t\t\t\t}\n\t\t\t\tmaximumTransmissionUnit = null;\n\t\t\t\tipv4Mtu = DEFAULT_IPV4_MTU;\n\t\t\t\tipv6Mtu = DEFAULT_IPV6_MTU;\n\t\t\t\tconnectionStore.stop(pending);\n\t\t\t\tif (executorService != timer) {\n\t\t\t\t\tpending.addAll(timer.shutdownNow());\n\t\t\t\t\tshutdownTimer = timer;\n\t\t\t\t\ttimer = null;\n\t\t\t\t}\n\t\t\t\tif (hasInternalExecutor) {\n\t\t\t\t\tpending.addAll(executorService.shutdownNow());\n\t\t\t\t\tshutdown = executorService;\n\t\t\t\t\texecutorService = null;\n\t\t\t\t\thasInternalExecutor = false;\n\t\t\t\t\tif (connectionStore instanceof ReadWriteLockConnectionStore) {\n\t\t\t\t\t\t((ReadWriteLockConnectionStore)connectionStore).setExecutor(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.join(500);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treceiverThreads.clear();\n\t\t\t}\n\t\t}\n\t\tif (shutdownTimer != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdownTimer.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] timer not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tif (shutdown != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdown.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] executor not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tfor (Runnable job : pending) {\n\t\t\ttry {\n\t\t\t\tjob.run();\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector:\", e);\n\t\t\t}\n\t\t}\n\t\tif (stop) {\n\t\t\tLOGGER.debug(\"DTLS connector on [{}] stopped.\", lastBindAddress);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DTLSConnector.java",
        "method_name": "scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java#stop",
        "raw_code": "@Override\n\tpublic void stop() {\n\t\tExecutorService shutdownTimer = null;\n\t\tExecutorService shutdown = null;\n\t\tList<Runnable> pending = new ArrayList<>();\n\t\tboolean stop;\n\t\tsynchronized (this) {\n\t\t\tstop = running.compareAndSet(true, false);\n\t\t\tif (stop) {\n\t\t\t\tLOGGER.debug(\"DTLS connector on [{}] stopping ...\", lastBindAddress);\n\t\t\t\tif (statusLogger != null) {\n\t\t\t\t\tstatusLogger.cancel(false);\n\t\t\t\t\tstatusLogger = null;\n\t\t\t\t}\n\t\t\t\tif (recentHandshakeCleaner != null) {\n\t\t\t\t\trecentHandshakeCleaner.cancel(false);\n\t\t\t\t\trecentHandshakeCleaner = null;\n\t\t\t\t}\n\t\t\t\t// recent handshakes will be restored from connection store,\n\t\t\t\tclearRecentHandshakes();\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t}\n\t\t\t\tif (socket != null) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t\tsocket = null;\n\t\t\t\t}\n\t\t\t\tmaximumTransmissionUnit = null;\n\t\t\t\tipv4Mtu = DEFAULT_IPV4_MTU;\n\t\t\t\tipv6Mtu = DEFAULT_IPV6_MTU;\n\t\t\t\tconnectionStore.stop(pending);\n\t\t\t\tif (executorService != timer) {\n\t\t\t\t\tpending.addAll(timer.shutdownNow());\n\t\t\t\t\tshutdownTimer = timer;\n\t\t\t\t\ttimer = null;\n\t\t\t\t}\n\t\t\t\tif (hasInternalExecutor) {\n\t\t\t\t\tpending.addAll(executorService.shutdownNow());\n\t\t\t\t\tshutdown = executorService;\n\t\t\t\t\texecutorService = null;\n\t\t\t\t\thasInternalExecutor = false;\n\t\t\t\t\tif (connectionStore instanceof ReadWriteLockConnectionStore) {\n\t\t\t\t\t\t((ReadWriteLockConnectionStore)connectionStore).setExecutor(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.join(500);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treceiverThreads.clear();\n\t\t\t}\n\t\t}\n\t\tif (shutdownTimer != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdownTimer.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] timer not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tif (shutdown != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdown.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] executor not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tExecutorsUtil.runAll(pending);\n\t\tif (stop) {\n\t\t\tLOGGER.debug(\"DTLS connector on [{}] stopped.\", lastBindAddress);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "plantuml",
    "cve_id": "CVE-2022-1379",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "93e5964e5f35914f3f7b89de620c596795550083",
    "short_hash": "93e5964e",
    "vulnerableMethods_before": [
      {
        "filename": "CommandBinary.java",
        "method_name": "src/net/sourceforge/plantuml/timingdiagram/command/CommandBinary.java#executeArg",
        "raw_code": "@Override\n\tfinal protected CommandExecutionResult executeArg(TimingDiagram diagram, LineLocation location, RegexResult arg) {\n\t\tfinal String compact = arg.get(\"COMPACT\", 0);\n\t\tfinal String code = arg.get(\"CODE\", 0);\n\t\tfinal String full = arg.get(\"FULL\", 0);\n\t\treturn diagram.createBinary(code, full, compact != null);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CommandBinary.java",
        "method_name": "src/net/sourceforge/plantuml/timingdiagram/command/CommandBinary.java#executeArg",
        "raw_code": "@Override\n\tfinal protected CommandExecutionResult executeArg(TimingDiagram diagram, LineLocation location, RegexResult arg) {\n\t\tfinal String compact = arg.get(\"COMPACT\", 0);\n\t\tfinal String code = arg.get(\"CODE\", 0);\n\t\tfinal String full = arg.get(\"FULL\", 0);\n\n\t\tStereotype stereotype = null;\n\t\tif (arg.get(\"STEREOTYPE\", 0) != null)\n\t\t\tstereotype = Stereotype.build(arg.get(\"STEREOTYPE\", 0));\n\t\telse if (arg.get(\"STEREOTYPE2\", 0) != null)\n\t\t\tstereotype = Stereotype.build(arg.get(\"STEREOTYPE2\", 0));\n\n\t\treturn diagram.createBinary(code, full, compact != null, stereotype);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-37913",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "45d182a4141ff22f3ff289cf71e4669bdc714544",
    "short_hash": "45d182a4",
    "vulnerableMethods_before": [
      {
        "filename": "ImageFilter.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/filter/ImageFilter.java#filter",
        "raw_code": "@Override\n    public void filter(Document htmlDocument, Map<String, String> cleaningParams)\n    {\n        String targetDocumentName = cleaningParams.get(\"targetDocument\");\n        DocumentReference targetDocumentReference =\n            targetDocumentName == null ? null : this.stringDocumentReferenceResolver.resolve(targetDocumentName);\n\n        boolean attachEmbeddedImages = Boolean.valueOf(cleaningParams.get(\"attachEmbeddedImages\"));\n        if (attachEmbeddedImages) {\n            htmlDocument.setUserData(EMBEDDED_IMAGES, new HashMap<String, byte[]>(), null);\n        }\n\n        List<Element> images = filterDescendants(htmlDocument.getDocumentElement(), new String[] {TAG_IMG});\n        for (Element image : images) {\n            Attr source = image.getAttributeNode(ATTRIBUTE_SRC);\n            if (source != null && targetDocumentReference != null) {\n                filterImageSource(source, targetDocumentReference);\n            }\n\n            // The 'align' attribute of images creates a lot of problems. First,the office server has a problem with\n            // center aligning images (it aligns them to left). Next, the office server uses <br clear\"xxx\"> for\n            // avoiding content wrapping around images which is not valid XHTML. There for, to be consistent and simple\n            // we will remove the 'align' attribute of all the images so that they are all left aligned.\n            image.removeAttribute(ATTRIBUTE_ALIGN);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImageFilter.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/filter/ImageFilter.java#filter",
        "raw_code": "@Override\n    public void filter(Document htmlDocument, Map<String, String> cleaningParams)\n    {\n        String targetDocumentName = cleaningParams.get(\"targetDocument\");\n        DocumentReference targetDocumentReference =\n            targetDocumentName == null ? null : this.stringDocumentReferenceResolver.resolve(targetDocumentName);\n\n        boolean attachEmbeddedImages = Boolean.valueOf(cleaningParams.get(\"attachEmbeddedImages\"));\n        if (attachEmbeddedImages) {\n            htmlDocument.setUserData(EMBEDDED_IMAGES, new HashMap<String, byte[]>(), null);\n        }\n\n        String replaceAttachmentPrefix = cleaningParams.get(\"replaceImagePrefix\");\n        String replacementAttachmentPrefix = cleaningParams.get(\"replacementImagePrefix\");\n\n        List<Element> images = filterDescendants(htmlDocument.getDocumentElement(), new String[] {TAG_IMG});\n        for (Element image : images) {\n            Attr source = image.getAttributeNode(ATTRIBUTE_SRC);\n            if (source != null && targetDocumentReference != null) {\n                filterImageSource(source, targetDocumentReference, replaceAttachmentPrefix,\n                    replacementAttachmentPrefix);\n            }\n\n            // The 'align' attribute of images creates a lot of problems. First,the office server has a problem with\n            // center aligning images (it aligns them to left). Next, the office server uses <br clear\"xxx\"> for\n            // avoiding content wrapping around images which is not valid XHTML. There for, to be consistent and simple\n            // we will remove the 'align' attribute of all the images so that they are all left aligned.\n            image.removeAttribute(ATTRIBUTE_ALIGN);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jenkins",
    "cve_id": "CVE-2013-7330",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "36342d71e29e0620f803a7470ce96c61761648d8",
    "short_hash": "36342d71",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "BuildTrigger.java",
        "method_name": "core/src/main/java/hudson/tasks/BuildTrigger.java#doCheck",
        "raw_code": "public FormValidation doCheck(@AncestorInPath Item project, @QueryParameter String value, @QueryParameter boolean upstream) {\n            // Require CONFIGURE permission on this project\n            if(!project.hasPermission(Item.CONFIGURE))      return FormValidation.ok();\n\n            StringTokenizer tokens = new StringTokenizer(Util.fixNull(value),\",\");\n            boolean hasProjects = false;\n            while(tokens.hasMoreTokens()) {\n                String projectName = tokens.nextToken().trim();\n                if (StringUtils.isNotBlank(projectName)) {\n                    Item item = Jenkins.getInstance().getItem(projectName,project,Item.class);\n                    if(item==null)\n                        return FormValidation.error(Messages.BuildTrigger_NoSuchProject(projectName,\n                                AbstractProject.findNearest(projectName,project.getParent()).getRelativeNameFrom(project)));\n                    if(!(item instanceof AbstractProject))\n                        return FormValidation.error(Messages.BuildTrigger_NotBuildable(projectName));\n                    if (!upstream && !item.hasPermission(Item.BUILD)) {\n                        return FormValidation.error(Messages.BuildTrigger_you_have_no_permission_to_build_(projectName));\n                    }\n                    hasProjects = true;\n                }\n            }\n            if (!hasProjects) {\n                return FormValidation.error(Messages.BuildTrigger_NoProjectSpecified());\n            }\n\n            return FormValidation.ok();\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2022-36092",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "71a6d0bb6f8ab718fcfaae0e9b8c16c2d69cd4bb",
    "short_hash": "71a6d0bb",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/XWiki.java#prepareDocuments",
        "raw_code": "public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        context.put(\"doc\", doc);\n        context.put(\"cdoc\", doc);\n        vcontext.put(\"doc\", doc.newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        XWikiDocument tdoc;\n\n        // If the parameter language exists and is empty, it means we want to force loading the regular document\n        // not a translation. This should be handled later by doing a better separation between locale used in the UI\n        // and for loading the documents.\n        if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(context);\n        }\n\n        try {\n            String rev = (String) context.get(\"rev\");\n            if (StringUtils.isNotEmpty(rev)) {\n                tdoc = getDocument(tdoc, rev, context);\n            }\n        } catch (Exception ex) {\n            // Invalid version, just use the most recent one\n        }\n        context.put(\"tdoc\", tdoc);\n        vcontext.put(\"tdoc\", tdoc.newDocument(context));\n\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/XWiki.java#prepareDocuments",
        "raw_code": "public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        if (!\"skin\".equals(context.getAction()) && !this.getRightService().hasAccessLevel(\"view\",\n            user.getFullName(), doc.getFullName(), context)) {\n            // If for some reason (e.g., login action) the user has rights for the action but no view right on the\n            // document, do not load the document into the context.\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n            context.put(\"tdoc\", doc);\n            context.put(\"cdoc\", doc);\n        } else {\n            context.put(\"doc\", doc);\n            context.put(\"cdoc\", doc);\n            vcontext.put(\"doc\", doc.newDocument(context));\n            vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n            XWikiDocument tdoc;\n\n            // If the parameter language exists and is empty, it means we want to force loading the regular document\n            // not a translation. This should be handled later by doing a better separation between locale used in the UI\n            // and for loading the documents.\n            if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n                tdoc = doc;\n            } else {\n                tdoc = doc.getTranslatedDocument(context);\n            }\n\n            try {\n                String rev = (String) context.get(\"rev\");\n                if (StringUtils.isNotEmpty(rev)) {\n                    tdoc = getDocument(tdoc, rev, context);\n                }\n            } catch (Exception ex) {\n                // Invalid version, just use the most recent one\n            }\n            context.put(\"tdoc\", tdoc);\n            vcontext.put(\"tdoc\", tdoc.newDocument(context));\n        }\n\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "bc-java",
    "cve_id": "CVE-2016-1000339",
    "cwe_list": [
      "CWE-310"
    ],
    "commit_hash": "413b42f4d770456508585c830cfcde95f9b0e93b#diff-54656f860db94b867ba7542430cd2ef0",
    "short_hash": "413b42f4",
    "vulnerableMethods_before": [
      {
        "filename": "DHPublicKeyParameters.java",
        "method_name": "validate",
        "raw_code": "private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (y == null)\n        {\n            throw new NullPointerException(\"y value cannot be null\");\n        }\n\n        if (dhParams.getQ() != null)\n        {\n            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            // TLS check\n            if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)\n            {\n                throw new IllegalArgumentException(\"invalid DH public key\");\n            }\n\n            return y;         // we can't validate without Q.\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DHPublicKeyParameters.java",
        "method_name": "validate",
        "raw_code": "private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (y == null)\n        {\n            throw new NullPointerException(\"y value cannot be null\");\n        }\n\n        // TLS check\n        if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)\n        {\n            throw new IllegalArgumentException(\"invalid DH public key\");\n        }\n\n        if (dhParams.getQ() != null)\n        {\n            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            return y;         // we can't validate without Q.\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "RuoYi",
    "cve_id": "CVE-2022-32065",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "d8b2a9a905fb750fa60e2400238cf4750a77c5e6",
    "short_hash": "d8b2a9a9",
    "vulnerableMethods_before": [
      {
        "filename": "SysProfileController.java",
        "method_name": "ruoyi-admin/src/main/java/com/ruoyi/web/controller/system/SysProfileController.java#updateAvatar",
        "raw_code": "@Log(title = \"\", businessType = BusinessType.UPDATE)\n    @PostMapping(\"/updateAvatar\")\n    @ResponseBody\n    public AjaxResult updateAvatar(@RequestParam(\"avatarfile\") MultipartFile file)\n    {\n        SysUser currentUser = getSysUser();\n        try\n        {\n            if (!file.isEmpty())\n            {\n                String avatar = FileUploadUtils.upload(RuoYiConfig.getAvatarPath(), file);\n                currentUser.setAvatar(avatar);\n                if (userService.updateUserInfo(currentUser) > 0)\n                {\n                    setSysUser(userService.selectUserById(currentUser.getUserId()));\n                    return success();\n                }\n            }\n            return error();\n        }\n        catch (Exception e)\n        {\n            log.error(\"\", e);\n            return error(e.getMessage());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysProfileController.java",
        "method_name": "ruoyi-admin/src/main/java/com/ruoyi/web/controller/system/SysProfileController.java#updateAvatar",
        "raw_code": "@Log(title = \"\", businessType = BusinessType.UPDATE)\n    @PostMapping(\"/updateAvatar\")\n    @ResponseBody\n    public AjaxResult updateAvatar(@RequestParam(\"avatarfile\") MultipartFile file)\n    {\n        SysUser currentUser = getSysUser();\n        try\n        {\n            if (!file.isEmpty())\n            {\n                String avatar = FileUploadUtils.upload(RuoYiConfig.getAvatarPath(), file, MimeTypeUtils.IMAGE_EXTENSION);\n                currentUser.setAvatar(avatar);\n                if (userService.updateUserInfo(currentUser) > 0)\n                {\n                    setSysUser(userService.selectUserById(currentUser.getUserId()));\n                    return success();\n                }\n            }\n            return error();\n        }\n        catch (Exception e)\n        {\n            log.error(\"\", e);\n            return error(e.getMessage());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geowebcache",
    "cve_id": "CVE-2024-23643",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "9d010e09c784690ada8af43f594461a2553a62f0",
    "short_hash": "9d010e09",
    "vulnerableMethods_before": [
      {
        "filename": "FormService.java",
        "method_name": "geowebcache/rest/src/main/java/org/geowebcache/rest/service/FormService.java#makeModifiableParameters",
        "raw_code": "private void makeModifiableParameters(StringBuilder doc, TileLayer tl) {\n        List<ParameterFilter> parameterFilters = tl.getParameterFilters();\n        if (parameterFilters == null || parameterFilters.isEmpty()) {\n            return;\n        }\n        doc.append(\"<tr><td>Modifiable Parameters:</td><td>\\n\");\n        doc.append(\"<table>\");\n        for (ParameterFilter pf : parameterFilters) {\n            Assert.notNull(pf, \"Parameter filter must be non null\");\n            String key = pf.getKey();\n            String defaultValue = pf.getDefaultValue();\n            List<String> legalValues = pf.getLegalValues();\n            doc.append(\"<tr><td>\").append(key.toUpperCase()).append(\": \").append(\"</td><td>\");\n            String parameterId = \"parameter_\" + key;\n            if (pf instanceof StringParameterFilter) {\n                Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                makePullDown(doc, parameterId, keysValues, defaultValue);\n            } else if (pf instanceof RegexParameterFilter) {\n                makeTextInput(doc, parameterId, 25);\n            } else if (pf instanceof FloatParameterFilter) {\n                FloatParameterFilter floatFilter = (FloatParameterFilter) pf;\n                if (floatFilter.getValues().isEmpty()) {\n                    // accepts any value\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            } else if (\"org.geowebcache.filter.parameters.NaiveWMSDimensionFilter\"\n                    .equals(pf.getClass().getName())) {\n                makeTextInput(doc, parameterId, 25);\n            } else {\n                // Unknown filter type\n                if (legalValues == null) {\n                    // Doesn't have a defined set of values, just provide a text field\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    // Does have a defined set of values, so provide a drop down\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            }\n            doc.append(\"</td></tr>\");\n        }\n        doc.append(\"</table>\");\n        doc.append(\"</td></tr>\\n\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FormService.java",
        "method_name": "geowebcache/rest/src/main/java/org/geowebcache/rest/service/FormService.java#makeModifiableParameters",
        "raw_code": "private void makeModifiableParameters(StringBuilder doc, TileLayer tl) {\n        List<ParameterFilter> parameterFilters = tl.getParameterFilters();\n        if (parameterFilters == null || parameterFilters.isEmpty()) {\n            return;\n        }\n        doc.append(\"<tr><td>Modifiable Parameters:</td><td>\\n\");\n        doc.append(\"<table>\");\n        for (ParameterFilter pf : parameterFilters) {\n            Assert.notNull(pf, \"Parameter filter must be non null\");\n            String key = pf.getKey();\n            String defaultValue = pf.getDefaultValue();\n            List<String> legalValues = pf.getLegalValues();\n            doc.append(\"<tr><td>\")\n                    .append(escapeHtml4(key.toUpperCase()))\n                    .append(\": \")\n                    .append(\"</td><td>\");\n            String parameterId = \"parameter_\" + key;\n            if (pf instanceof StringParameterFilter) {\n                Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                makePullDown(doc, parameterId, keysValues, defaultValue);\n            } else if (pf instanceof RegexParameterFilter) {\n                makeTextInput(doc, parameterId, 25);\n            } else if (pf instanceof FloatParameterFilter) {\n                FloatParameterFilter floatFilter = (FloatParameterFilter) pf;\n                if (floatFilter.getValues().isEmpty()) {\n                    // accepts any value\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            } else if (\"org.geowebcache.filter.parameters.NaiveWMSDimensionFilter\"\n                    .equals(pf.getClass().getName())) {\n                makeTextInput(doc, parameterId, 25);\n            } else {\n                // Unknown filter type\n                if (legalValues == null) {\n                    // Doesn't have a defined set of values, just provide a text field\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    // Does have a defined set of values, so provide a drop down\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            }\n            doc.append(\"</td></tr>\");\n        }\n        doc.append(\"</table>\");\n        doc.append(\"</td></tr>\\n\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2024-31464",
    "cwe_list": [
      "CWE-916"
    ],
    "commit_hash": "955fb097e02a2a7153f527522ee9eef42447e5d7",
    "short_hash": "955fb097",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "BaseObject.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/objects/BaseObject.java#getDiff",
        "raw_code": "@Override\n    public List<ObjectDiff> getDiff(Object oldEntity, XWikiContext context)\n    {\n        ArrayList<ObjectDiff> difflist = new ArrayList<ObjectDiff>();\n        BaseObject oldObject = (BaseObject) oldEntity;\n        // Iterate over the new properties first, to handle changed and added objects\n        for (String propertyName : this.getPropertyList()) {\n            BaseProperty newProperty = (BaseProperty) this.getField(propertyName);\n            BaseProperty oldProperty = (BaseProperty) oldObject.getField(propertyName);\n            BaseClass bclass = getXClass(context);\n            PropertyClass pclass = (PropertyClass) ((bclass == null) ? null : bclass.getField(propertyName));\n            String propertyType = (pclass == null) ? \"\" : pclass.getClassType();\n\n            if (oldProperty == null) {\n                // The property exist in the new object, but not in the old one\n                if ((newProperty != null) && (!newProperty.toText().equals(\"\"))) {\n                    String newPropertyValue = (newProperty.getValue() instanceof String || pclass == null)\n                        ? newProperty.toText() : pclass.displayView(propertyName, this, context);\n                    difflist.add(new ObjectDiff(getXClassReference(), getNumber(), getGuid(),\n                        ObjectDiff.ACTION_PROPERTYADDED, propertyName, propertyType, \"\", newPropertyValue));\n                }\n            } else if (!oldProperty.toText().equals(((newProperty == null) ? \"\" : newProperty.toText()))) {\n                // The property exists in both objects and is different\n                if (pclass != null) {\n                    // Put the values as they would be displayed in the interface\n                    String newPropertyValue = (newProperty.getValue() instanceof String) ? newProperty.toText()\n                        : pclass.displayView(propertyName, this, context);\n                    String oldPropertyValue = (oldProperty.getValue() instanceof String) ? oldProperty.toText()\n                        : pclass.displayView(propertyName, oldObject, context);\n                    difflist.add(\n                        new ObjectDiff(getXClassReference(), getNumber(), getGuid(), ObjectDiff.ACTION_PROPERTYCHANGED,\n                            propertyName, propertyType, oldPropertyValue, newPropertyValue));\n                } else {\n                    // Cannot get property definition, so use the plain value\n                    difflist.add(\n                        new ObjectDiff(getXClassReference(), getNumber(), getGuid(), ObjectDiff.ACTION_PROPERTYCHANGED,\n                            propertyName, propertyType, oldProperty.toText(), newProperty.toText()));\n                }\n            }\n        }\n\n        // Iterate over the old properties, in case there are some removed properties\n        for (String propertyName : oldObject.getPropertyList()) {\n            BaseProperty newProperty = (BaseProperty) this.getField(propertyName);\n            BaseProperty oldProperty = (BaseProperty) oldObject.getField(propertyName);\n            BaseClass bclass = getXClass(context);\n            // Bulletproofing: in theory the BaseObject is defined with a xclass reference allowing to resolve it\n            // however, it's possible that the reference is not set, in which case we might still find the info\n            // in the old object.\n            if (bclass == null) {\n                bclass = oldObject.getXClass(context);\n            }\n            PropertyClass pclass = (PropertyClass) ((bclass == null) ? null : bclass.getField(propertyName));\n            String propertyType = (pclass == null) ? \"\" : pclass.getClassType();\n\n            if (newProperty == null) {\n                // The property exists in the old object, but not in the new one\n                if ((oldProperty != null) && (!oldProperty.toText().equals(\"\"))) {\n                    if (pclass != null) {\n                        // Put the values as they would be displayed in the interface\n                        String oldPropertyValue = (oldProperty.getValue() instanceof String) ? oldProperty.toText()\n                            : pclass.displayView(propertyName, oldObject, context);\n                        difflist.add(\n                            new ObjectDiff(oldObject.getXClassReference(), oldObject.getNumber(), oldObject.getGuid(),\n                                ObjectDiff.ACTION_PROPERTYREMOVED, propertyName, propertyType, oldPropertyValue, \"\"));\n                    } else {\n                        // Cannot get property definition, so use the plain value\n                        difflist.add(new ObjectDiff(oldObject.getXClassReference(), oldObject.getNumber(),\n                            oldObject.getGuid(), ObjectDiff.ACTION_PROPERTYREMOVED, propertyName, propertyType,\n                            oldProperty.toText(), \"\"));\n                    }\n                }\n            }\n        }\n\n        return difflist;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2024-24824",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "7f8ef7fa8edf493106d5ef6f777d4da02c5194d9",
    "short_hash": "7f8ef7fa",
    "vulnerableMethods_before": [
      {
        "filename": "ClusterConfigServiceImpl.java",
        "method_name": "graylog2-server/src/main/java/org/graylog2/cluster/ClusterConfigServiceImpl.java#list",
        "raw_code": "@Override\n    public Set<Class<?>> list() {\n        final ImmutableSet.Builder<Class<?>> classes = ImmutableSet.builder();\n\n        try (DBCursor<ClusterConfig> clusterConfigs = dbCollection.find()) {\n            for (ClusterConfig clusterConfig : clusterConfigs) {\n                final String type = clusterConfig.type();\n                try {\n                    final Class<?> cls = chainingClassLoader.loadClass(type);\n                    classes.add(cls);\n                } catch (ClassNotFoundException e) {\n                    LOG.debug(\"Couldn't find configuration class \\\"{}\\\"\", type, e);\n                }\n            }\n        }\n\n        return classes.build();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ClusterConfigServiceImpl.java",
        "method_name": "graylog2-server/src/main/java/org/graylog2/cluster/ClusterConfigServiceImpl.java#list",
        "raw_code": "@Override\n    public Set<Class<?>> list() {\n        final ImmutableSet.Builder<Class<?>> classes = ImmutableSet.builder();\n\n        try (DBCursor<ClusterConfig> clusterConfigs = dbCollection.find()) {\n            for (ClusterConfig clusterConfig : clusterConfigs) {\n                final String type = clusterConfig.type();\n                try {\n                    final Class<?> cls = chainingClassLoader.loadClassSafely(type);\n                    classes.add(cls);\n                } catch (ClassNotFoundException e) {\n                    LOG.debug(\"Couldn't find configuration class \\\"{}\\\"\", type, e);\n                } catch (UnsafeClassLoadingAttemptException e) {\n                    LOG.warn(\"Couldn't load class <{}>.\", type, e);\n                }\n            }\n        }\n\n        return classes.build();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "SharedDefaults.java",
        "method_name": "core/org.eclipse.cdt.core/templateengine/org/eclipse/cdt/core/templateengine/SharedDefaults.java#deleteBackEndStorage",
        "raw_code": "public void deleteBackEndStorage(String[] deleteName) {\n\t\ttry {\n\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n\t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n\t\t} catch (Exception exp) {\n\t\t\tTemplateEngineUtil.log(exp);\n\t\t}\n\n\t\tList<Element> sharedElementList = TemplateEngine.getChildrenOfElement(document.getDocumentElement());\n\t\tint elementListSize = sharedElementList.size();\n\t\tfor (int i = 0; i < elementListSize; i++) {\n\n\t\t\tElement xmlElement = sharedElementList.get(i);\n\t\t\tString name = xmlElement.getAttribute(TemplateEngineHelper.ID);\n\n\t\t\tfor (int k = 0; k < deleteName.length; k++) {\n\t\t\t\tif (deleteName[k].equals(name)) {\n\t\t\t\t\txmlElement.removeAttribute(name);\n\t\t\t\t\tsharedDefaultsMap.remove(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdateShareDefaultsMap(sharedDefaultsMap);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SharedDefaults.java",
        "method_name": "core/org.eclipse.cdt.core/templateengine/org/eclipse/cdt/core/templateengine/SharedDefaults.java#deleteBackEndStorage",
        "raw_code": "public void deleteBackEndStorage(String[] deleteName) {\n\t\ttry {\n\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n\t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n\t\t} catch (Exception exp) {\n\t\t\tTemplateEngineUtil.log(exp);\n\t\t}\n\n\t\tList<Element> sharedElementList = TemplateEngine.getChildrenOfElement(document.getDocumentElement());\n\t\tint elementListSize = sharedElementList.size();\n\t\tfor (int i = 0; i < elementListSize; i++) {\n\n\t\t\tElement xmlElement = sharedElementList.get(i);\n\t\t\tString name = xmlElement.getAttribute(TemplateEngineHelper.ID);\n\n\t\t\tfor (int k = 0; k < deleteName.length; k++) {\n\t\t\t\tif (deleteName[k].equals(name)) {\n\t\t\t\t\txmlElement.removeAttribute(name);\n\t\t\t\t\tsharedDefaultsMap.remove(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdateShareDefaultsMap(sharedDefaultsMap);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "elasticsearch",
    "cve_id": "CVE-2015-5377",
    "cwe_list": [
      "CWE-74"
    ],
    "commit_hash": "bf3052d14c874aead7da8855c5fcadf5428a43f2",
    "short_hash": "bf3052d1",
    "vulnerableMethods_before": [
      {
        "filename": "ThrowableObjectInputStream.java",
        "method_name": "src/main/java/org/elasticsearch/common/io/ThrowableObjectInputStream.java#readClassDescriptor",
        "raw_code": "@Override\n    protected ObjectStreamClass readClassDescriptor()\n            throws IOException, ClassNotFoundException {\n        int type = read();\n        if (type < 0) {\n            throw new EOFException();\n        }\n        switch (type) {\n            case ThrowableObjectOutputStream.TYPE_EXCEPTION:\n                return ObjectStreamClass.lookup(Exception.class);\n            case ThrowableObjectOutputStream.TYPE_STACKTRACEELEMENT:\n                return ObjectStreamClass.lookup(StackTraceElement.class);\n            case ThrowableObjectOutputStream.TYPE_FAT_DESCRIPTOR:\n                return super.readClassDescriptor();\n            case ThrowableObjectOutputStream.TYPE_THIN_DESCRIPTOR:\n                String className = readUTF();\n                Class<?> clazz = loadClass(className);\n                return ObjectStreamClass.lookup(clazz);\n            default:\n                throw new StreamCorruptedException(\n                        \"Unexpected class descriptor type: \" + type);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ThrowableObjectInputStream.java",
        "method_name": "src/main/java/org/elasticsearch/common/io/ThrowableObjectInputStream.java#readClassDescriptor",
        "raw_code": "@Override\n    protected ObjectStreamClass readClassDescriptor()\n            throws IOException, ClassNotFoundException {\n        int type = read();\n        if (type < 0) {\n            throw new EOFException();\n        }\n        switch (type) {\n            case ThrowableObjectOutputStream.TYPE_EXCEPTION:\n                return ObjectStreamClass.lookup(Exception.class);\n            case ThrowableObjectOutputStream.TYPE_STACKTRACEELEMENT:\n                return ObjectStreamClass.lookup(StackTraceElement.class);\n            case ThrowableObjectOutputStream.TYPE_FAT_DESCRIPTOR:\n                return verify(super.readClassDescriptor());\n            case ThrowableObjectOutputStream.TYPE_THIN_DESCRIPTOR:\n                String className = readUTF();\n                Class<?> clazz = loadClass(className);\n                return verify(ObjectStreamClass.lookup(clazz));\n            default:\n                throw new StreamCorruptedException(\n                        \"Unexpected class descriptor type: \" + type);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jai-ext",
    "cve_id": "CVE-2022-24816",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "cb1d6565d38954676b0a366da4f965fef38da1cb",
    "short_hash": "cb1d6565",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "Jiffle.java",
        "method_name": "jt-jiffle/jt-jiffle-language/src/main/java/it/geosolutions/jaiext/jiffle/Jiffle.java#createRuntimeInstance",
        "raw_code": "private JiffleRuntime createRuntimeInstance(RuntimeModel model, Class<? extends JiffleRuntime> runtimeClass, boolean scriptInDocs) throws\n            \n            it.geosolutions.jaiext.jiffle.JiffleException {\n        if (!isCompiled()) {\n            throw new it.geosolutions.jaiext.jiffle.JiffleException(\"The script has not been compiled\");\n        }\n\n        String runtimeSource = createRuntimeSource(model, runtimeClass.getName(), scriptInDocs);\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"Jiffle script compiled to:\\n\\n\" + runtimeSource);    \n        }\n        try {\n            SimpleCompiler compiler = new SimpleCompiler();\n            compiler.cook(runtimeSource);\n\n            StringBuilder sb = new StringBuilder();\n            sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(\n                    it.geosolutions.jaiext.jiffle.JiffleProperties.RUNTIME_PACKAGE_KEY)).append(\".\");\n\n            switch (model) {\n                case DIRECT:\n                    sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(\n                            it.geosolutions.jaiext.jiffle.JiffleProperties.DIRECT_CLASS_KEY));\n                    break;\n\n                case INDIRECT:\n                    sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(\n                            it.geosolutions.jaiext.jiffle.JiffleProperties.INDIRECT_CLASS_KEY));\n                    break;\n\n                default:\n                    throw new IllegalArgumentException(\"Internal compiler error\");\n            }\n\n            Class<?> clazz = compiler.getClassLoader().loadClass(sb.toString());\n            JiffleRuntime runtime = (JiffleRuntime) clazz.newInstance();\n            runtime.setImageParams(imageParams);\n            if (runtime instanceof JiffleIndirectRuntime) {\n                ((JiffleIndirectRuntime) runtime).setDestinationBands(destinationBands);\n            }\n            return runtime;\n\n        } catch (Exception ex) {\n            // do not display the source code in indirect runtime exception messages\n            if (model == RuntimeModel.INDIRECT) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.fine(\"Runtime source error for source: \" + runtimeSource);\n                }\n                throw new JiffleException(\"Runtime source error\", ex);\n            }\n            throw new JiffleException(\"Runtime source error for source: \" + runtimeSource, ex);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "liferay-portal",
    "cve_id": "CVE-2010-5327",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "90c4e85a8f8135f069f3f05e4d54a77704769f91",
    "short_hash": "90c4e85a",
    "vulnerableMethods_before": [
      {
        "filename": "FreeMarkerManager.java",
        "method_name": "portal-impl/src/com/liferay/portal/freemarker/FreeMarkerManager.java#destroy",
        "raw_code": "public void destroy() {\n\t\tif (_configuration == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t_configuration.clearEncodingMap();\n\t\t_configuration.clearSharedVariables();\n\t\t_configuration.clearTemplateCache();\n\n\t\t_configuration = null;\n\n\t\t_restrictedHelperUtilities.clear();\n\n\t\t_restrictedHelperUtilities = null;\n\n\t\t_standardHelperUtilities.clear();\n\n\t\t_standardHelperUtilities = null;\n\n\t\t_stringTemplateLoader.removeTemplates();\n\n\t\t_stringTemplateLoader = null;\n\n\t\t_templateContextHelper = null;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FreeMarkerManager.java",
        "method_name": "portal-impl/src/com/liferay/portal/freemarker/FreeMarkerManager.java#destroy",
        "raw_code": "public void destroy(ClassLoader classLoader) {\n\t\t_classLoaderHelperUtilities.remove(classLoader);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xp",
    "cve_id": "CVE-2024-23679",
    "cwe_list": [
      "CWE-384"
    ],
    "commit_hash": "0189975691e9e6407a9fee87006f730e84f734ff",
    "short_hash": "01899756",
    "vulnerableMethods_before": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#createSession",
        "raw_code": "private void createSession( final AuthenticationInfo authInfo )\n    {\n        final Session session = this.context.get().getLocalScope().getSession();\n        if ( session != null )\n        {\n            session.setAttribute( authInfo );\n        }\n\n        if ( this.sessionTimeout != null )\n        {\n            setSessionTimeout();\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#createSession",
        "raw_code": "private void createSession( final AuthenticationInfo authInfo )\n    {\n        final LocalScope localScope = this.context.get().getLocalScope();\n        final Session session = localScope.getSession();\n\n        if ( session != null )\n        {\n            final var attributes = session.getAttributes();\n            session.invalidate();\n\n            final Session newSession = localScope.getSession();\n\n            if ( newSession != null )\n            {\n                attributes.forEach( newSession::setAttribute );\n                session.setAttribute( authInfo );\n\n                if ( this.sessionTimeout != null )\n                {\n                    setSessionTimeout();\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.platform.ui",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "f243cf0a28785b89b7c50bf4e1cce48a917d89bd",
    "short_hash": "f243cf0a",
    "vulnerableMethods_before": [
      {
        "filename": "TemplateReaderWriter.java",
        "method_name": "bundles/org.eclipse.jface.text/src/org/eclipse/jface/text/templates/persistence/TemplateReaderWriter.java#read",
        "raw_code": "private TemplatePersistenceData[] read(InputSource source, ResourceBundle bundle, String singleId) throws IOException {\n\t\ttry {\n\t\t\tCollection<TemplatePersistenceData> templates= new ArrayList<>();\n\t\t\tSet<String> ids= new HashSet<>();\n\n\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder parser= factory.newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\tDocument document= parser.parse(source);\n\n\t\t\tNodeList elements= document.getElementsByTagName(TEMPLATE_ELEMENT);\n\n\t\t\tint count= elements.getLength();\n\t\t\tfor (int i= 0; i != count; i++) {\n\t\t\t\tNode node= elements.item(i);\n\t\t\t\tNamedNodeMap attributes= node.getAttributes();\n\n\t\t\t\tif (attributes == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tString id= getStringValue(attributes, ID_ATTRIBUTE, null);\n\t\t\t\tif (id != null && ids.contains(id)) {\n\t\t\t\t\tString PLUGIN_ID= \"org.eclipse.jface.text\"; //$NON-NLS-1$\n\t\t\t\t\tILog log= ILog.of(Platform.getBundle(PLUGIN_ID));\n\t\t\t\t\tString message= NLS.bind(TextTemplateMessages.getString(\"TemplateReaderWriter.duplicate.id\"), id); //$NON-NLS-1$\n\t\t\t\t\tlog.log(new Status(IStatus.WARNING, PLUGIN_ID, IStatus.OK, message, null));\n\t\t\t\t} else {\n\t\t\t\t\tids.add(id);\n\t\t\t\t}\n\n\t\t\t\tif (singleId != null && !singleId.equals(id))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tboolean deleted = getBooleanValue(attributes, DELETED_ATTRIBUTE, false);\n\n\t\t\t\tString name= getStringValue(attributes, NAME_ATTRIBUTE);\n\t\t\t\tname= translateString(name, bundle);\n\n\t\t\t\tString description= getStringValue(attributes, DESCRIPTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\t\tdescription= translateString(description, bundle);\n\n\t\t\t\tString context= getStringValue(attributes, CONTEXT_ATTRIBUTE);\n\n\t\t\t\tif (name == null || context == null)\n\t\t\t\t\tthrow new IOException(TextTemplateMessages.getString(\"TemplateReaderWriter.error.missing_attribute\")); //$NON-NLS-1$\n\n\t\t\t\tboolean enabled = getBooleanValue(attributes, ENABLED_ATTRIBUTE, true);\n\t\t\t\tboolean autoInsertable= getBooleanValue(attributes, AUTO_INSERTABLE_ATTRIBUTE, true);\n\n\t\t\t\tStringBuilder buffer= new StringBuilder();\n\t\t\t\tNodeList children= node.getChildNodes();\n\t\t\t\tfor (int j= 0; j != children.getLength(); j++) {\n\t\t\t\t\tString value= children.item(j).getNodeValue();\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tbuffer.append(value);\n\t\t\t\t}\n\t\t\t\tString pattern= buffer.toString();\n\t\t\t\tpattern= translateString(pattern, bundle);\n\n\t\t\t\tTemplate template= new Template(name, description, context, pattern, autoInsertable);\n\t\t\t\tTemplatePersistenceData data= new TemplatePersistenceData(template, enabled, id);\n\t\t\t\tdata.setDeleted(deleted);\n\n\t\t\t\ttemplates.add(data);\n\n\t\t\t\tif (singleId != null && singleId.equals(id))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn templates.toArray(new TemplatePersistenceData[templates.size()]);\n\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tAssert.isTrue(false);\n\t\t} catch (SAXException e) {\n\t\t\tthrow (IOException)new IOException(\"Could not read template file\").initCause(e); //$NON-NLS-1$\n\t\t}\n\n\t\treturn null; // dummy\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "TemplateReaderWriter.java",
        "method_name": "bundles/org.eclipse.jface.text/src/org/eclipse/jface/text/templates/persistence/TemplateReaderWriter.java#read",
        "raw_code": "private TemplatePersistenceData[] read(InputSource source, ResourceBundle bundle, String singleId) throws IOException {\n\t\ttry {\n\t\t\tCollection<TemplatePersistenceData> templates= new ArrayList<>();\n\t\t\tSet<String> ids= new HashSet<>();\n\n\t\t\t@SuppressWarnings(\"restriction\")\n\t\t\tDocumentBuilder parser= org.eclipse.core.internal.runtime.XmlProcessorFactory.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\tDocument document= parser.parse(source);\n\n\t\t\tNodeList elements= document.getElementsByTagName(TEMPLATE_ELEMENT);\n\n\t\t\tint count= elements.getLength();\n\t\t\tfor (int i= 0; i != count; i++) {\n\t\t\t\tNode node= elements.item(i);\n\t\t\t\tNamedNodeMap attributes= node.getAttributes();\n\n\t\t\t\tif (attributes == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tString id= getStringValue(attributes, ID_ATTRIBUTE, null);\n\t\t\t\tif (id != null && ids.contains(id)) {\n\t\t\t\t\tString PLUGIN_ID= \"org.eclipse.jface.text\"; //$NON-NLS-1$\n\t\t\t\t\tILog log= ILog.of(Platform.getBundle(PLUGIN_ID));\n\t\t\t\t\tString message= NLS.bind(TextTemplateMessages.getString(\"TemplateReaderWriter.duplicate.id\"), id); //$NON-NLS-1$\n\t\t\t\t\tlog.log(new Status(IStatus.WARNING, PLUGIN_ID, IStatus.OK, message, null));\n\t\t\t\t} else {\n\t\t\t\t\tids.add(id);\n\t\t\t\t}\n\n\t\t\t\tif (singleId != null && !singleId.equals(id))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tboolean deleted = getBooleanValue(attributes, DELETED_ATTRIBUTE, false);\n\n\t\t\t\tString name= getStringValue(attributes, NAME_ATTRIBUTE);\n\t\t\t\tname= translateString(name, bundle);\n\n\t\t\t\tString description= getStringValue(attributes, DESCRIPTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\t\tdescription= translateString(description, bundle);\n\n\t\t\t\tString context= getStringValue(attributes, CONTEXT_ATTRIBUTE);\n\n\t\t\t\tif (name == null || context == null)\n\t\t\t\t\tthrow new IOException(TextTemplateMessages.getString(\"TemplateReaderWriter.error.missing_attribute\")); //$NON-NLS-1$\n\n\t\t\t\tboolean enabled = getBooleanValue(attributes, ENABLED_ATTRIBUTE, true);\n\t\t\t\tboolean autoInsertable= getBooleanValue(attributes, AUTO_INSERTABLE_ATTRIBUTE, true);\n\n\t\t\t\tStringBuilder buffer= new StringBuilder();\n\t\t\t\tNodeList children= node.getChildNodes();\n\t\t\t\tfor (int j= 0; j != children.getLength(); j++) {\n\t\t\t\t\tString value= children.item(j).getNodeValue();\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tbuffer.append(value);\n\t\t\t\t}\n\t\t\t\tString pattern= buffer.toString();\n\t\t\t\tpattern= translateString(pattern, bundle);\n\n\t\t\t\tTemplate template= new Template(name, description, context, pattern, autoInsertable);\n\t\t\t\tTemplatePersistenceData data= new TemplatePersistenceData(template, enabled, id);\n\t\t\t\tdata.setDeleted(deleted);\n\n\t\t\t\ttemplates.add(data);\n\n\t\t\t\tif (singleId != null && singleId.equals(id))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn templates.toArray(new TemplatePersistenceData[templates.size()]);\n\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tAssert.isTrue(false);\n\t\t} catch (SAXException e) {\n\t\t\tthrow (IOException)new IOException(\"Could not read template file\").initCause(e); //$NON-NLS-1$\n\t\t}\n\n\t\treturn null; // dummy\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "shopizer",
    "cve_id": "CVE-2022-23061",
    "cwe_list": [
      "CWE-639"
    ],
    "commit_hash": "6b9f1ecd303b3b724d96bd08095c1a751dcc287e",
    "short_hash": "6b9f1ecd",
    "vulnerableMethods_before": [
      {
        "filename": "CustomerFacadeImpl.java",
        "method_name": "sm-shop/src/main/java/com/salesmanager/shop/store/controller/customer/facade/CustomerFacadeImpl.java#setCustomerModelDefaultProperties",
        "raw_code": "@Override\n  public void setCustomerModelDefaultProperties(Customer customer, MerchantStore store)\n      throws Exception {\n    Validate.notNull(customer, \"Customer object cannot be null\");\n    if (customer.getId() == null || customer.getId() == 0) {\n      if (StringUtils.isBlank(customer.getNick())) {\n        String userName = UserReset.generateRandomString(USERNAME_LENGTH);\n        customer.setNick(userName);\n      }\n      if (StringUtils.isBlank(customer.getPassword())) {\n        String password = UserReset.generateRandomString();\n        String encodedPassword = passwordEncoder.encode(password);\n        customer.setPassword(encodedPassword);\n      }\n    }\n\n    if (CollectionUtils.isEmpty(customer.getGroups())) {\n      List<Group> groups = getListOfGroups(GroupType.CUSTOMER);\n      for (Group group : groups) {\n        if (group.getGroupName().equals(Constants.GROUP_CUSTOMER)) {\n          customer.getGroups().add(group);\n        }\n      }\n\n    }\n\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CustomerFacadeImpl.java",
        "method_name": "sm-shop/src/main/java/com/salesmanager/shop/store/controller/customer/facade/CustomerFacadeImpl.java#setCustomerModelDefaultProperties",
        "raw_code": "@Override\n  public void setCustomerModelDefaultProperties(Customer customer, MerchantStore store)\n      throws Exception {\n    Validate.notNull(customer, \"Customer object cannot be null\");\n    if (customer.getId() == null || customer.getId() == 0) {\n      if (StringUtils.isBlank(customer.getNick())) {\n        String userName = \"test@shopizer.com\";\n        customer.setNick(userName);\n      }\n      if (StringUtils.isBlank(customer.getPassword())) {\n        String password = new String(UUID.generateRandomBytes());\n        String encodedPassword = passwordEncoder.encode(password);\n        customer.setPassword(encodedPassword);\n      }\n    }\n\n    if (CollectionUtils.isEmpty(customer.getGroups())) {\n      List<Group> groups = getListOfGroups(GroupType.CUSTOMER);\n      for (Group group : groups) {\n        if (group.getGroupName().equals(Constants.GROUP_CUSTOMER)) {\n          customer.getGroups().add(group);\n        }\n      }\n\n    }\n\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.jdt.core",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "38dd2a878f45cdb3d8d52090f1d6d1b532fd4c4d",
    "short_hash": "38dd2a87",
    "vulnerableMethods_before": [
      {
        "filename": "JavaProject.java",
        "method_name": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaProject.java#decodeClasspathEntry",
        "raw_code": "@Override\n\tpublic IClasspathEntry decodeClasspathEntry(String encodedEntry) {\n\n\t\ttry {\n\t\t\tif (encodedEntry == null) return null;\n\t\t\tStringReader reader = new StringReader(encodedEntry);\n\t\t\tElement node;\n\n\t\t\ttry {\n\t\t\t\tDocumentBuilder parser =\n\t\t\t\t\tDocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\t\tnode = parser.parse(new InputSource(reader)).getDocumentElement();\n\t\t\t} catch (SAXException | ParserConfigurationException e) {\n\t\t\t\treturn null;\n\t\t\t} finally {\n\t\t\t\treader.close();\n\t\t\t}\n\n\t\t\tif (!node.getNodeName().equalsIgnoreCase(ClasspathEntry.TAG_CLASSPATHENTRY)\n\t\t\t\t\t|| node.getNodeType() != Node.ELEMENT_NODE) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn ClasspathEntry.elementDecode(node, this, null/*not interested in unknown elements*/);\n\t\t} catch (IOException e) {\n\t\t\t// bad format\n\t\t\treturn null;\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "JavaProject.java",
        "method_name": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaProject.java#decodeClasspathEntry",
        "raw_code": "@Override\n\tpublic IClasspathEntry decodeClasspathEntry(String encodedEntry) {\n\n\t\ttry {\n\t\t\tif (encodedEntry == null) return null;\n\t\t\tStringReader reader = new StringReader(encodedEntry);\n\t\t\tElement node;\n\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"restriction\")\n\t\t\t\tDocumentBuilder parser =\n\t\t\t\t\t\torg.eclipse.core.internal.runtime.XmlProcessorFactory.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\t\tnode = parser.parse(new InputSource(reader)).getDocumentElement();\n\t\t\t} catch (SAXException | ParserConfigurationException e) {\n\t\t\t\treturn null;\n\t\t\t} finally {\n\t\t\t\treader.close();\n\t\t\t}\n\n\t\t\tif (!node.getNodeName().equalsIgnoreCase(ClasspathEntry.TAG_CLASSPATHENTRY)\n\t\t\t\t\t|| node.getNodeType() != Node.ELEMENT_NODE) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn ClasspathEntry.elementDecode(node, this, null/*not interested in unknown elements*/);\n\t\t} catch (IOException e) {\n\t\t\t// bad format\n\t\t\treturn null;\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "pf4j",
    "cve_id": "CVE-2023-40828",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "8e0aa198c4e652cfc1eb9e05ca9b64397f67cc72",
    "short_hash": "8e0aa198",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "Unzip.java",
        "method_name": "pf4j/src/main/java/org/pf4j/util/Unzip.java#extract",
        "raw_code": "public void extract() throws IOException {\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        String destinationCanonicalPath = destination.getCanonicalPath();\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                String fileCanonicalPath = file.getCanonicalPath();\n                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n                }\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snappy-java",
    "cve_id": "CVE-2023-34455",
    "cwe_list": [
      "CWE-770"
    ],
    "commit_hash": "3bf67857fcf70d9eea56eed4af7c925671e8eaea",
    "short_hash": "3bf67857",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "SnappyInputStream.java",
        "method_name": "src/main/java/org/xerial/snappy/SnappyInputStream.java#hasNextChunk",
        "raw_code": "protected boolean hasNextChunk()\n            throws IOException\n    {\n        if (finishedReading) {\n            return false;\n        }\n\n        uncompressedCursor = 0;\n        uncompressedLimit = 0;\n\n        int readBytes = readNext(header, 0, 4);\n        if (readBytes < 4) {\n            return false;\n        }\n\n        int chunkSize = SnappyOutputStream.readInt(header, 0);\n        if (chunkSize == SnappyCodec.MAGIC_HEADER_HEAD) {\n            // Concatenated data\n            int remainingHeaderSize = SnappyCodec.headerSize() - 4;\n            readBytes = readNext(header, 4, remainingHeaderSize);\n            if(readBytes < remainingHeaderSize) {\n                throw new SnappyIOException(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format(\"Insufficient header size in a concatenated block\"));\n            }\n\n            if (isValidHeader(header)) {\n                return hasNextChunk();\n            }\n            else {\n                return false;\n            }\n        }\n\n        // chunkSize is negative\n        if (chunkSize < 0) {\n            throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, \"chunkSize is too big or negative : \" + chunkSize);\n        }\n\n        // extend the compressed data buffer size\n        if (compressed == null || chunkSize > compressed.length) {\n            // chunkSize exceeds limit\n            try {\n                compressed = new byte[chunkSize];\n            }\n            catch (java.lang.OutOfMemoryError e) {\n                throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, e.getMessage());\n            }\n        }\n        readBytes = 0;\n        while (readBytes < chunkSize) {\n            int ret = in.read(compressed, readBytes, chunkSize - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n        if (readBytes < chunkSize) {\n            throw new IOException(\"failed to read chunk\");\n        }\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, chunkSize);\n        if (uncompressed == null || uncompressedLength > uncompressed.length) {\n            uncompressed = new byte[uncompressedLength];\n        }\n        int actualUncompressedLength = Snappy.uncompress(compressed, 0, chunkSize, uncompressed, 0);\n        if (uncompressedLength != actualUncompressedLength) {\n            throw new SnappyIOException(SnappyErrorCode.INVALID_CHUNK_SIZE, String.format(\"expected %,d bytes, but decompressed chunk has %,d bytes\", uncompressedLength, actualUncompressedLength));\n        }\n        uncompressedLimit = actualUncompressedLength;\n\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junrar",
    "cve_id": "CVE-2022-23596",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "7b16b3d90b91445fd6af0adfed22c07413d4fab7",
    "short_hash": "7b16b3d9",
    "vulnerableMethods_before": [
      {
        "filename": "Archive.java",
        "method_name": "src/main/java/com/github/junrar/Archive.java#readHeaders",
        "raw_code": "private void readHeaders(final long fileLength) throws IOException, RarException {\n        this.markHead = null;\n        this.newMhd = null;\n        this.headers.clear();\n        this.currentHeaderIndex = 0;\n        int toRead = 0;\n\n        //keep track of positions already processed for\n        //more robustness against corrupt files\n        final Set<Long> processedPositions = new HashSet<>();\n        while (true) {\n            int size = 0;\n            long newpos = 0;\n            RawDataIo rawData = new RawDataIo(channel);\n            final byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);\n\n            // if header is encrypted,there is a 8-byte salt before each header\n            if (newMhd != null && newMhd.isEncrypted()) {\n                byte[] salt = new byte[8];\n                rawData.readFully(salt, 8);\n                try {\n                    Cipher cipher = Rijndael.buildDecipherer(password, salt);\n                    rawData.setCipher(cipher);\n                } catch (Exception e) {\n                    throw new InitDeciphererFailedException(e);\n                }\n            }\n\n            final long position = this.channel.getPosition();\n\n            // Weird, but is trying to read beyond the end of the file\n            if (position >= fileLength) {\n                break;\n            }\n\n            // logger.info(\"\\n--------reading header--------\");\n            size = rawData.readFully(baseBlockBuffer, baseBlockBuffer.length);\n\n            if (size == 0) {\n                break;\n            }\n            final BaseBlock block = new BaseBlock(baseBlockBuffer);\n\n            block.setPositionInFile(position);\n\n            UnrarHeadertype headerType = block.getHeaderType();\n            if (headerType == null) {\n                logger.warn(\"unknown block header!\");\n                throw new CorruptHeaderException();\n            }\n            switch (headerType) {\n\n                case MarkHeader:\n                    this.markHead = new MarkHeader(block);\n                    if (!this.markHead.isSignature()) {\n                        if (markHead.getVersion() == RARVersion.V5) {\n                            logger.warn(\"Support for rar version 5 is not yet implemented!\");\n                            throw new UnsupportedRarV5Exception();\n                        } else {\n                            throw new BadRarArchiveException();\n                        }\n                    }\n                    this.headers.add(this.markHead);\n                    // markHead.print();\n                    break;\n\n                case MainHeader:\n                    toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\n                        : MainHeader.mainHeaderSize;\n                    final byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(mainbuff, mainbuff.length);\n                    final MainHeader mainhead = new MainHeader(block, mainbuff);\n                    this.headers.add(mainhead);\n                    this.newMhd = mainhead;\n                    break;\n\n                case SignHeader:\n                    toRead = SignHeader.signHeaderSize;\n                    final byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(signBuff, signBuff.length);\n                    final SignHeader signHead = new SignHeader(block, signBuff);\n                    this.headers.add(signHead);\n                    break;\n\n                case AvHeader:\n                    toRead = AVHeader.avHeaderSize;\n                    final byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(avBuff, avBuff.length);\n                    final AVHeader avHead = new AVHeader(block, avBuff);\n                    this.headers.add(avHead);\n                    break;\n\n                case CommHeader:\n                    toRead = CommentHeader.commentHeaderSize;\n                    final byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(commBuff, commBuff.length);\n                    final CommentHeader commHead = new CommentHeader(block, commBuff);\n                    this.headers.add(commHead);\n\n                    newpos = commHead.getPositionInFile() + commHead.getHeaderSize(isEncrypted());\n                    this.channel.setPosition(newpos);\n\n                    if (processedPositions.contains(newpos)) {\n                        throw new BadRarArchiveException();\n                    }\n                    processedPositions.add(newpos);\n\n                    break;\n                case EndArcHeader:\n\n                    toRead = 0;\n                    if (block.hasArchiveDataCRC()) {\n                        toRead += EndArcHeader.endArcArchiveDataCrcSize;\n                    }\n                    if (block.hasVolumeNumber()) {\n                        toRead += EndArcHeader.endArcVolumeNumberSize;\n                    }\n                    EndArcHeader endArcHead;\n                    if (toRead > 0) {\n                        final byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                        rawData.readFully(endArchBuff, endArchBuff.length);\n                        endArcHead = new EndArcHeader(block, endArchBuff);\n                    } else {\n                        endArcHead = new EndArcHeader(block, null);\n                    }\n                    this.headers.add(endArcHead);\n                    return;\n\n                default:\n                    final byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);\n                    rawData.readFully(blockHeaderBuffer, blockHeaderBuffer.length);\n                    final BlockHeader blockHead = new BlockHeader(block,\n                        blockHeaderBuffer);\n\n                    switch (blockHead.getHeaderType()) {\n                        case NewSubHeader:\n                        case FileHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(fileHeaderBuffer, fileHeaderBuffer.length);\n\n                            final FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\n                            this.headers.add(fh);\n                            newpos = fh.getPositionInFile() + fh.getHeaderSize(isEncrypted()) + fh.getFullPackSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case ProtectHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(protectHeaderBuffer, protectHeaderBuffer.length);\n                            final ProtectHeader ph = new ProtectHeader(blockHead, protectHeaderBuffer);\n                            newpos = ph.getPositionInFile() + ph.getHeaderSize(isEncrypted()) + ph.getDataSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case SubHeader: {\n                            final byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);\n                            rawData.readFully(subHeadbuffer, subHeadbuffer.length);\n                            final SubBlockHeader subHead = new SubBlockHeader(blockHead,\n                                subHeadbuffer);\n                            subHead.print();\n                            switch (subHead.getSubType()) {\n                                case MAC_HEAD: {\n                                    final byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(macHeaderbuffer, macHeaderbuffer.length);\n                                    final MacInfoHeader macHeader = new MacInfoHeader(subHead,\n                                        macHeaderbuffer);\n                                    macHeader.print();\n                                    this.headers.add(macHeader);\n\n                                    break;\n                                }\n                                // TODO implement other subheaders\n                                case BEEA_HEAD:\n                                    break;\n                                case EA_HEAD: {\n                                    final byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(eaHeaderBuffer, eaHeaderBuffer.length);\n                                    final EAHeader eaHeader = new EAHeader(subHead,\n                                        eaHeaderBuffer);\n                                    eaHeader.print();\n                                    this.headers.add(eaHeader);\n\n                                    break;\n                                }\n                                case NTACL_HEAD:\n                                    break;\n                                case STREAM_HEAD:\n                                    break;\n                                case UO_HEAD:\n                                    toRead = subHead.getHeaderSize(false);\n                                    toRead -= BaseBlock.BaseBlockSize;\n                                    toRead -= BlockHeader.blockHeaderSize;\n                                    toRead -= SubBlockHeader.SubBlockHeaderSize;\n                                    final byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                                    rawData.readFully(uoHeaderBuffer, uoHeaderBuffer.length);\n                                    final UnixOwnersHeader uoHeader = new UnixOwnersHeader(\n                                        subHead, uoHeaderBuffer);\n                                    uoHeader.print();\n                                    this.headers.add(uoHeader);\n                                    break;\n                                default:\n                                    break;\n                            }\n\n                            break;\n                        }\n                        default:\n                            logger.warn(\"Unknown Header\");\n                            throw new NotRarArchiveException();\n\n                    }\n            }\n            // logger.info(\"\\n--------end header--------\");\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Archive.java",
        "method_name": "src/main/java/com/github/junrar/Archive.java#readHeaders",
        "raw_code": "private void readHeaders(final long fileLength) throws IOException, RarException {\n        this.markHead = null;\n        this.newMhd = null;\n        this.headers.clear();\n        this.currentHeaderIndex = 0;\n        int toRead = 0;\n\n        //keep track of positions already processed for\n        //more robustness against corrupt files\n        final Set<Long> processedPositions = new HashSet<>();\n        while (true) {\n            int size = 0;\n            long newpos = 0;\n            RawDataIo rawData = new RawDataIo(channel);\n            final byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);\n\n            // if header is encrypted,there is a 8-byte salt before each header\n            if (newMhd != null && newMhd.isEncrypted()) {\n                byte[] salt = new byte[8];\n                rawData.readFully(salt, 8);\n                try {\n                    Cipher cipher = Rijndael.buildDecipherer(password, salt);\n                    rawData.setCipher(cipher);\n                } catch (Exception e) {\n                    throw new InitDeciphererFailedException(e);\n                }\n            }\n\n            final long position = this.channel.getPosition();\n\n            // Weird, but is trying to read beyond the end of the file\n            if (position >= fileLength) {\n                break;\n            }\n\n            // logger.info(\"\\n--------reading header--------\");\n            size = rawData.readFully(baseBlockBuffer, baseBlockBuffer.length);\n\n            if (size == 0) {\n                break;\n            }\n            final BaseBlock block = new BaseBlock(baseBlockBuffer);\n\n            block.setPositionInFile(position);\n\n            UnrarHeadertype headerType = block.getHeaderType();\n            if (headerType == null) {\n                logger.warn(\"unknown block header!\");\n                throw new CorruptHeaderException();\n            }\n            switch (headerType) {\n\n                case MarkHeader:\n                    this.markHead = new MarkHeader(block);\n                    if (!this.markHead.isSignature()) {\n                        if (markHead.getVersion() == RARVersion.V5) {\n                            logger.warn(\"Support for rar version 5 is not yet implemented!\");\n                            throw new UnsupportedRarV5Exception();\n                        } else {\n                            throw new BadRarArchiveException();\n                        }\n                    }\n                    this.headers.add(this.markHead);\n                    // markHead.print();\n                    break;\n\n                case MainHeader:\n                    toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\n                        : MainHeader.mainHeaderSize;\n                    final byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(mainbuff, mainbuff.length);\n                    final MainHeader mainhead = new MainHeader(block, mainbuff);\n                    this.headers.add(mainhead);\n                    this.newMhd = mainhead;\n                    break;\n\n                case SignHeader:\n                    toRead = SignHeader.signHeaderSize;\n                    final byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(signBuff, signBuff.length);\n                    final SignHeader signHead = new SignHeader(block, signBuff);\n                    this.headers.add(signHead);\n                    break;\n\n                case AvHeader:\n                    toRead = AVHeader.avHeaderSize;\n                    final byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(avBuff, avBuff.length);\n                    final AVHeader avHead = new AVHeader(block, avBuff);\n                    this.headers.add(avHead);\n                    break;\n\n                case CommHeader:\n                    toRead = CommentHeader.commentHeaderSize;\n                    final byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(commBuff, commBuff.length);\n                    final CommentHeader commHead = new CommentHeader(block, commBuff);\n                    this.headers.add(commHead);\n\n                    newpos = commHead.getPositionInFile() + commHead.getHeaderSize(isEncrypted());\n                    this.channel.setPosition(newpos);\n\n                    if (processedPositions.contains(newpos)) {\n                        throw new BadRarArchiveException();\n                    }\n                    processedPositions.add(newpos);\n\n                    break;\n                case EndArcHeader:\n\n                    toRead = 0;\n                    if (block.hasArchiveDataCRC()) {\n                        toRead += EndArcHeader.endArcArchiveDataCrcSize;\n                    }\n                    if (block.hasVolumeNumber()) {\n                        toRead += EndArcHeader.endArcVolumeNumberSize;\n                    }\n                    EndArcHeader endArcHead;\n                    if (toRead > 0) {\n                        final byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                        rawData.readFully(endArchBuff, endArchBuff.length);\n                        endArcHead = new EndArcHeader(block, endArchBuff);\n                    } else {\n                        endArcHead = new EndArcHeader(block, null);\n                    }\n                    this.headers.add(endArcHead);\n                    return;\n\n                default:\n                    final byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);\n                    rawData.readFully(blockHeaderBuffer, blockHeaderBuffer.length);\n                    final BlockHeader blockHead = new BlockHeader(block,\n                        blockHeaderBuffer);\n\n                    switch (blockHead.getHeaderType()) {\n                        case NewSubHeader:\n                        case FileHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(fileHeaderBuffer, fileHeaderBuffer.length);\n\n                            final FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\n                            this.headers.add(fh);\n                            newpos = fh.getPositionInFile() + fh.getHeaderSize(isEncrypted()) + fh.getFullPackSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case ProtectHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(protectHeaderBuffer, protectHeaderBuffer.length);\n                            final ProtectHeader ph = new ProtectHeader(blockHead, protectHeaderBuffer);\n                            newpos = ph.getPositionInFile() + ph.getHeaderSize(isEncrypted()) + ph.getDataSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case SubHeader: {\n                            final byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);\n                            rawData.readFully(subHeadbuffer, subHeadbuffer.length);\n                            final SubBlockHeader subHead = new SubBlockHeader(blockHead,\n                                subHeadbuffer);\n                            subHead.print();\n                            SubBlockHeaderType subType = subHead.getSubType();\n                            if (subType == null) break;\n                            switch (subType) {\n                                case MAC_HEAD: {\n                                    final byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(macHeaderbuffer, macHeaderbuffer.length);\n                                    final MacInfoHeader macHeader = new MacInfoHeader(subHead,\n                                        macHeaderbuffer);\n                                    macHeader.print();\n                                    this.headers.add(macHeader);\n\n                                    break;\n                                }\n                                // TODO implement other subheaders\n                                case BEEA_HEAD:\n                                    break;\n                                case EA_HEAD: {\n                                    final byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(eaHeaderBuffer, eaHeaderBuffer.length);\n                                    final EAHeader eaHeader = new EAHeader(subHead,\n                                        eaHeaderBuffer);\n                                    eaHeader.print();\n                                    this.headers.add(eaHeader);\n\n                                    break;\n                                }\n                                case NTACL_HEAD:\n                                    break;\n                                case STREAM_HEAD:\n                                    break;\n                                case UO_HEAD:\n                                    toRead = subHead.getHeaderSize(false);\n                                    toRead -= BaseBlock.BaseBlockSize;\n                                    toRead -= BlockHeader.blockHeaderSize;\n                                    toRead -= SubBlockHeader.SubBlockHeaderSize;\n                                    final byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                                    rawData.readFully(uoHeaderBuffer, uoHeaderBuffer.length);\n                                    final UnixOwnersHeader uoHeader = new UnixOwnersHeader(\n                                        subHead, uoHeaderBuffer);\n                                    uoHeader.print();\n                                    this.headers.add(uoHeader);\n                                    break;\n                                default:\n                                    break;\n                            }\n\n                            break;\n                        }\n                        default:\n                            logger.warn(\"Unknown Header\");\n                            throw new NotRarArchiveException();\n\n                    }\n            }\n            // logger.info(\"\\n--------end header--------\");\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "orientdb",
    "cve_id": "CVE-2015-2913",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "668ece96be210e742a4e2820a3085b215cf55104",
    "short_hash": "668ece96",
    "vulnerableMethods_before": [
      {
        "filename": "OHttpSessionManager.java",
        "method_name": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpSessionManager.java#removeSession",
        "raw_code": "public OHttpSession removeSession(final String iSessionId) {\n     acquireExclusiveLock();\n     try {\n       return sessions.remove(iSessionId);\n\n     } finally {\n       releaseExclusiveLock();\n     }\n   }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OHttpSessionManager.java",
        "method_name": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpSessionManager.java#removeSession",
        "raw_code": "public OHttpSession removeSession(final String iSessionId) {\n    acquireExclusiveLock();\n    try {\n      return sessions.remove(iSessionId);\n\n    } finally {\n      releaseExclusiveLock();\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jw-community",
    "cve_id": "CVE-2022-4859",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "9a77f508a2bf8cf661d588f37a4cc29ecaea4fc8",
    "short_hash": "9a77f508",
    "vulnerableMethods_before": [
      {
        "filename": "UserProfileMenu.java",
        "method_name": "wflow-core/src/main/java/org/joget/plugin/enterprise/UserProfileMenu.java#submitForm",
        "raw_code": "private void submitForm() {\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\"))) {\n            currentUser.setFirstName(getRequestParameterString(\"firstName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(getRequestParameterString(\"lastName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UserProfileMenu.java",
        "method_name": "wflow-core/src/main/java/org/joget/plugin/enterprise/UserProfileMenu.java#submitForm",
        "raw_code": "private void submitForm() {\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\")) && !StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")).isEmpty()) {\n            currentUser.setFirstName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"lastName\")));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.jdt.ui",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "13675b1f8a74f47de4da89ed0ded6af7c21dfbec",
    "short_hash": "13675b1f",
    "vulnerableMethods_before": [
      {
        "filename": "ProfileStore.java",
        "method_name": "org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/preferences/formatter/ProfileStore.java#writeProfilesToStream",
        "raw_code": "public static void writeProfilesToStream(Collection<Profile> profiles, OutputStream stream, String encoding, IProfileVersioner profileVersioner) throws CoreException {\n\n\t\ttry {\n\t\t\tfinal DocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n\t\t\tfinal DocumentBuilder builder= factory.newDocumentBuilder();\n\t\t\tfinal Document document= builder.newDocument();\n\n\t\t\tfinal Element rootElement = document.createElement(XML_NODE_ROOT);\n\t\t\trootElement.setAttribute(XML_ATTRIBUTE_VERSION, Integer.toString(profileVersioner.getCurrentVersion()));\n\n\t\t\tdocument.appendChild(rootElement);\n\n\t\t\tfor (Profile profile : profiles) {\n\t\t\t\tif (profile.isProfileToSave()) {\n\t\t\t\t\tfinal Element profileElement= createProfileElement(profile, document, profileVersioner);\n\t\t\t\t\trootElement.appendChild(profileElement);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\ttransformer.transform(new DOMSource(document), new StreamResult(stream));\n\t\t} catch (TransformerException | ParserConfigurationException e) {\n\t\t\tthrow createException(e, FormatterMessages.CodingStyleConfigurationBlock_error_serializing_xml_message);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ProfileStore.java",
        "method_name": "org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/preferences/formatter/ProfileStore.java#writeProfilesToStream",
        "raw_code": "public static void writeProfilesToStream(Collection<Profile> profiles, OutputStream stream, String encoding, IProfileVersioner profileVersioner) throws CoreException {\n\n\t\ttry {\n\t\t\tfinal DocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n\t\t\tfinal DocumentBuilder builder= factory.newDocumentBuilder();\n\t\t\tfinal Document document= builder.newDocument();\n\n\t\t\tfinal Element rootElement = document.createElement(XML_NODE_ROOT);\n\t\t\trootElement.setAttribute(XML_ATTRIBUTE_VERSION, Integer.toString(profileVersioner.getCurrentVersion()));\n\n\t\t\tdocument.appendChild(rootElement);\n\n\t\t\tfor (Profile profile : profiles) {\n\t\t\t\tif (profile.isProfileToSave()) {\n\t\t\t\t\tfinal Element profileElement= createProfileElement(profile, document, profileVersioner);\n\t\t\t\t\trootElement.appendChild(profileElement);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\ttransformer.transform(new DOMSource(document), new StreamResult(stream));\n\t\t} catch (TransformerException | ParserConfigurationException e) {\n\t\t\tthrow createException(e, FormatterMessages.CodingStyleConfigurationBlock_error_serializing_xml_message);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-46554",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "37ecea84fdd053c33733c2ae9a0778bf98eae608",
    "short_hash": "37ecea84",
    "vulnerableMethods_before": [
      {
        "filename": "ComponentAnnotationLoader.java",
        "method_name": "initialize",
        "raw_code": "public void initialize(ComponentManager manager, ClassLoader classLoader)\n    {\n        try {\n            // 1) Find all components by retrieving the list defined in COMPONENT_LIST. Also find all component\n            // overrides (i.e. the list of components that should take precedence when several are registered\n            // with the same role/hint.\n            List<String> componentClassNames = getDeclaredComponents(classLoader, COMPONENT_LIST);\n            List<String> componentOverrideClassNames = getDeclaredComponents(classLoader, COMPONENT_OVERRIDE_LIST);\n\n            // 2) For each component class name found, load its class and use introspection to find the necessary\n            // annotations required to create a Component Descriptor.\n            Map<RoleHint, ComponentDescriptor> descriptorMap = new HashMap<RoleHint, ComponentDescriptor>();\n            for (String componentClassName : componentClassNames) {\n                Class< ? > componentClass = classLoader.loadClass(componentClassName);\n\n                // Look for ComponentRole annotations and register one component per ComponentRole found\n                for (Class< ? > componentRoleClass : findComponentRoleClasses(componentClass)) {\n                    for (ComponentDescriptor descriptor : factory.createComponentDescriptors(componentClass,\n                        componentRoleClass)) {\n                        // If there's already a existing role/hint in the list of descriptors then decide which one\n                        // to keep by looking at the override list. Use those in the override list in priority.\n                        // Otherwise use the last registered component.\n                        RoleHint roleHint = new RoleHint(componentRoleClass, descriptor.getRoleHint());\n                        if (descriptorMap.containsKey(roleHint)) {\n                            // Is the component in the override list?\n                            ComponentDescriptor existingDescriptor = descriptorMap.get(roleHint);\n                            if (!componentOverrideClassNames.contains(existingDescriptor.getImplementation())) {\n                                descriptorMap.put(new RoleHint(componentRoleClass, descriptor.getRoleHint()),\n                                    descriptor);\n\n                                if (!componentOverrideClassNames.contains(descriptor.getImplementation())) {\n                                    getLogger().warn(\n                                        \"Component [\" + existingDescriptor.getImplementation().getName()\n                                            + \"] is being overwritten by component [\"\n                                            + descriptor.getImplementation().getName()\n                                            + \"]. It will not be possible to look it up.\");\n                                }\n                            }\n                        } else {\n                            descriptorMap.put(new RoleHint(componentRoleClass, descriptor.getRoleHint()), descriptor);\n                        }\n                    }\n                }\n            }\n\n            // 3) Activate all component descriptors\n            for (ComponentDescriptor descriptor : descriptorMap.values()) {\n                manager.registerComponent(descriptor);\n            }\n\n        } catch (Exception e) {\n            // Make sure we make the calling code fail in order to fail fast and prevent the application to start\n            // if something is amiss.\n            throw new RuntimeException(\"Failed to dynamically load components with annotations\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ComponentAnnotationLoader.java",
        "method_name": "initialize",
        "raw_code": "public void initialize(ComponentManager manager, ClassLoader classLoader)\n    {\n        try {\n            // 1) Find all components by retrieving the list defined in COMPONENT_LIST. Also find all component\n            // overrides (i.e. the list of components that should take precedence when several are registered\n            // with the same role/hint.\n            List<String> componentClassNames = getDeclaredComponents(classLoader, COMPONENT_LIST);\n            List<String> componentOverrideClassNames = getDeclaredComponents(classLoader, COMPONENT_OVERRIDE_LIST);\n\n            // 2) For each component class name found, load its class and use introspection to find the necessary\n            // annotations required to create a Component Descriptor.\n            Map<RoleHint, ComponentDescriptor> descriptorMap = new HashMap<RoleHint, ComponentDescriptor>();\n            for (String componentClassName : componentClassNames) {\n                Class< ? > componentClass = classLoader.loadClass(componentClassName);\n\n                // Look for ComponentRole annotations and register one component per ComponentRole found\n                for (Class< ? > componentRoleClass : findComponentRoleClasses(componentClass)) {\n                    for (ComponentDescriptor descriptor : factory.createComponentDescriptors(componentClass,\n                        componentRoleClass)) {\n                        // If there's already a existing role/hint in the list of descriptors then decide which one\n                        // to keep by looking at the override list. Use those in the override list in priority.\n                        // Otherwise use the last registered component.\n                        RoleHint roleHint = new RoleHint(componentRoleClass, descriptor.getRoleHint());\n                        if (descriptorMap.containsKey(roleHint)) {\n                            // Is the component in the override list?\n                            ComponentDescriptor existingDescriptor = descriptorMap.get(roleHint);\n                            if (!componentOverrideClassNames.contains(existingDescriptor.getImplementation().getName())) {\n                                descriptorMap.put(new RoleHint(componentRoleClass, descriptor.getRoleHint()),\n                                    descriptor);\n\n                                if (!componentOverrideClassNames.contains(descriptor.getImplementation().getName())) {\n                                    getLogger().warn(\n                                        \"Component [\" + existingDescriptor.getImplementation().getName()\n                                            + \"] is being overwritten by component [\"\n                                            + descriptor.getImplementation().getName()\n                                            + \"]. It will not be possible to look it up.\");\n                                }\n                            }\n                        } else {\n                            descriptorMap.put(new RoleHint(componentRoleClass, descriptor.getRoleHint()), descriptor);\n                        }\n                    }\n                }\n            }\n\n            // 3) Activate all component descriptors\n            for (ComponentDescriptor descriptor : descriptorMap.values()) {\n                manager.registerComponent(descriptor);\n            }\n\n        } catch (Exception e) {\n            // Make sure we make the calling code fail in order to fail fast and prevent the application to start\n            // if something is amiss.\n            throw new RuntimeException(\"Failed to dynamically load components with annotations\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "SourceUtils.java",
        "method_name": "debug/org.eclipse.cdt.debug.core/src/org/eclipse/cdt/debug/internal/core/sourcelookup/SourceUtils.java#getCommonSourceLocationsMemento",
        "raw_code": "public static String getCommonSourceLocationsMemento(ICSourceLocation[] locations) {\n\t\tDocument document = null;\n\t\tThrowable ex = null;\n\t\ttry {\n\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t\tElement element = document.createElement(NAME_COMMON_SOURCE_LOCATIONS);\n\t\t\tdocument.appendChild(element);\n\t\t\tsaveSourceLocations(document, element, locations);\n\t\t\treturn CDebugUtils.serializeDocument(document);\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tex = e;\n\t\t} catch (IOException e) {\n\t\t\tex = e;\n\t\t} catch (TransformerException e) {\n\t\t\tex = e;\n\t\t}\n\t\tCDebugCorePlugin.log(new Status(IStatus.ERROR, CDebugCorePlugin.getUniqueIdentifier(), 0,\n\t\t\t\t\"Error saving common source settings.\", ex)); //$NON-NLS-1$\n\t\treturn null;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SourceUtils.java",
        "method_name": "debug/org.eclipse.cdt.debug.core/src/org/eclipse/cdt/debug/internal/core/sourcelookup/SourceUtils.java#getCommonSourceLocationsMemento",
        "raw_code": "public static String getCommonSourceLocationsMemento(ICSourceLocation[] locations) {\n\t\tDocument document = null;\n\t\tThrowable ex = null;\n\t\ttry {\n\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t\tElement element = document.createElement(NAME_COMMON_SOURCE_LOCATIONS);\n\t\t\tdocument.appendChild(element);\n\t\t\tsaveSourceLocations(document, element, locations);\n\t\t\treturn CDebugUtils.serializeDocument(document);\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tex = e;\n\t\t} catch (IOException e) {\n\t\t\tex = e;\n\t\t} catch (TransformerException e) {\n\t\t\tex = e;\n\t\t}\n\t\tCDebugCorePlugin.log(new Status(IStatus.ERROR, CDebugCorePlugin.getUniqueIdentifier(), 0,\n\t\t\t\t\"Error saving common source settings.\", ex)); //$NON-NLS-1$\n\t\treturn null;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "nokogiri",
    "cve_id": "CVE-2022-29181",
    "cwe_list": [
      "CWE-843"
    ],
    "commit_hash": "db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
    "short_hash": "db05ba9a",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "ParserContext.java",
        "method_name": "ext/java/nokogiri/Html4SaxParserContext.java#setIOInputSource",
        "raw_code": "public void\n  setIOInputSource(ThreadContext context, IRubyObject data, IRubyObject url)\n  {\n    source = new InputSource();\n    ParserContext.setUrl(context, source, url);\n\n    Ruby ruby = context.getRuntime();\n\n    if (!(data.respondsTo(\"read\"))) {\n      throw ruby.newTypeError(\"must respond to :read\");\n    }\n\n    source.setByteStream(new IOInputStream(data));\n    if (java_encoding != null) {\n      source.setEncoding(java_encoding);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "databasir",
    "cve_id": "CVE-2022-24861",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "ca22a8fef7a31c0235b0b2951260a7819b89993b",
    "short_hash": "ca22a8fe",
    "vulnerableMethods_before": [
      {
        "filename": "CustomDatabaseConnectionFactory.java",
        "method_name": "core/src/main/java/com/databasir/core/infrastructure/connection/CustomDatabaseConnectionFactory.java#getConnection",
        "raw_code": "@Override\n    public Connection getConnection(Context context) throws SQLException {\n        DatabaseTypePojo type = databaseTypeDao.selectByDatabaseType(context.getDatabaseType());\n        File driverFile = driverResources.loadOrDownload(context.getDatabaseType(), type.getJdbcDriverFileUrl());\n        URLClassLoader loader = null;\n        try {\n            loader = new URLClassLoader(\n                    new URL[]{\n                            driverFile.toURI().toURL()\n                    },\n                    this.getClass().getClassLoader()\n            );\n        } catch (MalformedURLException e) {\n            log.error(\"load driver error \" + context, e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(e.getMessage());\n        }\n        // retrieve the driver class\n\n        Class<?> clazz = null;\n        Driver driver = null;\n        try {\n            clazz = Class.forName(type.getJdbcDriverClassName(), true, loader);\n            driver = (Driver) clazz.getConstructor().newInstance();\n        } catch (ClassNotFoundException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(\",  Driver name\" + e.getMessage());\n        } catch (InvocationTargetException\n                 | InstantiationException\n                 | IllegalAccessException\n                 | NoSuchMethodException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(\"\" + e.getMessage());\n        }\n\n        String urlPattern = type.getUrlPattern();\n        String jdbcUrl = urlPattern.replace(\"{{jdbc.protocol}}\", type.getJdbcProtocol())\n                .replace(\"{{db.url}}\", context.getUrl())\n                .replace(\"{{db.name}}\", context.getDatabaseName())\n                .replace(\"{{db.schema}}\", context.getSchemaName());\n        Properties info = new Properties();\n        info.put(\"user\", context.getUsername());\n        info.put(\"password\", context.getPassword());\n        return driver.connect(jdbcUrl, info);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CustomDatabaseConnectionFactory.java",
        "method_name": "core/src/main/java/com/databasir/core/infrastructure/connection/CustomDatabaseConnectionFactory.java#getConnection",
        "raw_code": "@Override\n    public Connection getConnection(Context context) throws SQLException {\n        String databaseType = context.getDatabaseType();\n        DatabaseTypePojo type = databaseTypeDao.selectByDatabaseType(databaseType);\n        File driverFile = driverResources.loadOrDownloadByDatabaseType(databaseType, type.getJdbcDriverFileUrl());\n\n        URLClassLoader loader = null;\n        try {\n            loader = new URLClassLoader(\n                    new URL[]{\n                            driverFile.toURI().toURL()\n                    },\n                    this.getClass().getClassLoader()\n            );\n        } catch (MalformedURLException e) {\n            log.error(\"load driver error \" + context, e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(e.getMessage());\n        }\n        // retrieve the driver class\n\n        Class<?> clazz = null;\n        Driver driver = null;\n        try {\n            clazz = Class.forName(type.getJdbcDriverClassName(), false, loader);\n            driver = (Driver) clazz.getConstructor().newInstance();\n        } catch (ClassNotFoundException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(\", \" + e.getMessage());\n        } catch (InvocationTargetException\n                 | InstantiationException\n                 | IllegalAccessException\n                 | NoSuchMethodException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(\"\" + e.getMessage());\n        }\n\n        String urlPattern = type.getUrlPattern();\n        String jdbcUrl = urlPattern.replace(\"{{jdbc.protocol}}\", type.getJdbcProtocol())\n                .replace(\"{{db.url}}\", context.getUrl())\n                .replace(\"{{db.name}}\", context.getDatabaseName())\n                .replace(\"{{db.schema}}\", context.getSchemaName());\n        Properties info = new Properties();\n        info.put(\"user\", context.getUsername());\n        info.put(\"password\", context.getPassword());\n        return driver.connect(jdbcUrl, info);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-36470",
    "cwe_list": [
      "CWE-74"
    ],
    "commit_hash": "b0cdfd893912baaa053d106a92e39fa1858843c7",
    "short_hash": "b0cdfd89",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultIconSetLoader.java",
        "method_name": "xwiki-platform-core/xwiki-platform-icon/xwiki-platform-icon-default/src/main/java/org/xwiki/icon/internal/DefaultIconSetLoader.java#loadIconSet",
        "raw_code": "@Override\n    public IconSet loadIconSet(DocumentReference iconSetReference) throws IconException\n    {\n        try {\n            // Get the document\n            DocumentModelBridge doc = documentAccessBridge.getDocumentInstance(iconSetReference);\n            String content = doc.getContent();\n            // The name of the icon set is stored in the IconThemesCode.IconThemeClass XObject of the document\n            DocumentReference iconClassRef = new DocumentReference(wikiDescriptorManager.getCurrentWikiId(),\n                \"IconThemesCode\", \"IconThemeClass\");\n            String name = (String) documentAccessBridge.getProperty(iconSetReference, iconClassRef, \"name\");\n            // Load the icon set\n            return loadIconSet(new StringReader(content), name);\n        } catch (Exception e) {\n            throw new IconException(String.format(ERROR_MSG, iconSetReference), e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultIconSetLoader.java",
        "method_name": "xwiki-platform-core/xwiki-platform-icon/xwiki-platform-icon-default/src/main/java/org/xwiki/icon/internal/DefaultIconSetLoader.java#loadIconSet",
        "raw_code": "@Override\n    public IconSet loadIconSet(DocumentReference iconSetReference) throws IconException\n    {\n        try {\n            // Get the document\n            DocumentModelBridge doc = this.documentAccessBridge.getDocumentInstance(iconSetReference);\n\n            // Check that both the content (actual icon theme content) and the metadata author (icon theme object)\n            // have script right.\n            DocumentReference contentAuthor =\n                this.documentUserSerializer.serialize(doc.getAuthors().getContentAuthor());\n            this.authorizationManager.checkAccess(Right.SCRIPT, contentAuthor, iconSetReference);\n            DocumentReference metadataAuthor =\n                this.documentUserSerializer.serialize(doc.getAuthors().getEffectiveMetadataAuthor());\n            this.authorizationManager.checkAccess(Right.SCRIPT, metadataAuthor, iconSetReference);\n\n            String content = doc.getContent();\n            // The name of the icon set is stored in the IconThemesCode.IconThemeClass XObject of the document\n            DocumentReference iconClassRef = new DocumentReference(this.wikiDescriptorManager.getCurrentWikiId(),\n                \"IconThemesCode\", \"IconThemeClass\");\n            String name = (String) this.documentAccessBridge.getProperty(iconSetReference, iconClassRef, \"name\");\n            // Load the icon set\n            IconSet result = loadIconSet(new StringReader(content), name);\n            result.setSourceDocumentReference(iconSetReference);\n            return result;\n        } catch (Exception e) {\n            throw new IconException(String.format(ERROR_MSG, iconSetReference), e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "projectforge-webapp",
    "cve_id": "CVE-2013-7251",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "422de35e3c3141e418a73bfb39b430d5fd74077e",
    "short_hash": "422de35e",
    "vulnerableMethods_before": [
      {
        "filename": "RechnungCostEditTablePanel.java",
        "method_name": "src/main/java/org/projectforge/web/fibu/RechnungCostEditTablePanel.java#onSubmit",
        "raw_code": "@Override\n      protected void onSubmit(final AjaxRequestTarget target, final Form< ? > form)\n      {\n        final KostZuweisungDO zuweisung = addZuweisung(position);\n        final WebMarkupContainer newRow = createRow(rows.newChildId(), position, zuweisung);\n        newRow.setOutputMarkupId(true);\n        final StringBuffer prependJavascriptBuf = new StringBuffer();\n        prependJavascriptBuf.append(WicketAjaxUtils.appendChild(\"costAssignmentBody\", \"tr\", newRow.getMarkupId()));\n        rows.add(newRow);\n        target.add(newRow);\n        ajaxComponents.addTargetComponents(target);\n        target.prependJavaScript(prependJavascriptBuf.toString());\n      }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RechnungCostEditTablePanel.java",
        "method_name": "src/main/java/org/projectforge/web/fibu/RechnungCostEditTablePanel.java#onSubmit",
        "raw_code": "@Override\n      protected void onSubmit()\n      {\n        super.onSubmit();\n        csrfTokenHandler.onSubmit();\n      }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key);\n        checkValidPath(containerPath, path);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2024-31981",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "a4ad14d9c1605a5ab957237e505ebbb29f5b9d73",
    "short_hash": "a4ad14d9",
    "vulnerableMethods_before": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#renderXSLFO",
        "raw_code": "private void renderXSLFO(String xmlfo, OutputStream out, ExportType type, final XWikiContext context)\n        throws XWikiException\n    {\n        try {\n            this.xslFORenderer.render(new ByteArrayInputStream(xmlfo.getBytes(\"UTF-8\")), out, type.getMimeType());\n        } catch (IllegalStateException e) {\n            throw createException(e, type, XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION);\n        } catch (Exception e) {\n            throw createException(e, type, XWikiException.ERROR_XWIKI_EXPORT_PDF_FOP_FAILED);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#renderXSLFO",
        "raw_code": "private void renderXSLFO(String xmlfo, OutputStream out, ExportType type, final XWikiContext context)\n        throws XWikiException\n    {\n        try {\n            this.xslFORenderer.render(new ByteArrayInputStream(xmlfo.getBytes(StandardCharsets.UTF_8)), out, type.getMimeType());\n        } catch (IllegalStateException e) {\n            throw createException(e, type, XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION);\n        } catch (Exception e) {\n            throw createException(e, type, XWikiException.ERROR_XWIKI_EXPORT_PDF_FOP_FAILED);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2022-23617",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "30c52b01559b8ef5ed1035dac7c34aaf805764d5",
    "short_hash": "30c52b01",
    "vulnerableMethods_before": [
      {
        "filename": "AdminAction.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/AdminAction.java#render",
        "raw_code": "@Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        String content = request.getParameter(\"content\");\n        XWikiDocument doc = context.getDoc();\n        XWikiForm form = context.getForm();\n\n        synchronized (doc) {\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            EditForm peform = (EditForm) form;\n            String parent = peform.getParent();\n            if (parent != null) {\n                doc.setParent(parent);\n            }\n            String creator = peform.getCreator();\n            if (creator != null) {\n                doc.setCreator(creator);\n            }\n            String defaultTemplate = peform.getDefaultTemplate();\n            if (defaultTemplate != null) {\n                doc.setDefaultTemplate(defaultTemplate);\n            }\n            String defaultLanguage = peform.getDefaultLanguage();\n            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {\n                doc.setDefaultLanguage(defaultLanguage);\n            }\n            if (doc.getDefaultLanguage().equals(\"\")) {\n                doc.setDefaultLanguage(context.getWiki().getLanguagePreference(context));\n            }\n\n            String language = context.getWiki().getLanguagePreference(context);\n            String languagefromrequest = context.getRequest().getParameter(\"language\");\n            String languagetoedit =\n                ((languagefromrequest == null) || (languagefromrequest.equals(\"\"))) ? language : languagefromrequest;\n\n            if ((languagetoedit == null) || (languagetoedit.equals(\"default\"))) {\n                languagetoedit = \"\";\n            }\n            if (doc.isNew() || (doc.getDefaultLanguage().equals(languagetoedit))) {\n                languagetoedit = \"\";\n            }\n\n            if (languagetoedit.equals(\"\")) {\n                // In this case the created document is going to be the default document\n                tdoc = doc;\n                context.put(\"tdoc\", doc);\n                if (doc.isNew()) {\n                    doc.setDefaultLanguage(language);\n                    doc.setLanguage(\"\");\n                }\n            } else {\n                // If the translated doc object is the same as the doc object\n                // this means the translated doc did not exists so we need to create it\n                if ((tdoc == doc)) {\n                    tdoc = new XWikiDocument(doc.getDocumentReference());\n                    tdoc.setLanguage(languagetoedit);\n                    tdoc.setContent(doc.getContent());\n                    tdoc.setSyntax(doc.getSyntax());\n                    tdoc.setAuthor(context.getUser());\n                    tdoc.setStore(doc.getStore());\n                    context.put(\"tdoc\", tdoc);\n                }\n            }\n\n            XWikiDocument tdoc2 = tdoc.clone();\n            if (content != null && !content.isEmpty()) {\n                tdoc2.setContent(content);\n            }\n            context.put(\"tdoc\", tdoc2);\n            try {\n                tdoc2.readFromTemplate(peform, context);\n            } catch (XWikiException e) {\n                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                    context.put(\"exception\", e);\n                    return \"docalreadyexists\";\n                }\n            }\n\n            /* Setup a lock */\n            try {\n                XWikiLock lock = tdoc.getLock(context);\n                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {\n                    tdoc.setLock(context.getUser(), context);\n                }\n            } catch (Exception e) {\n                // Lock should never make XWiki fail\n                // But we should log any related information\n                LOGGER.error(\"Exception while setting up lock\", e);\n            }\n        }\n\n        return \"admin\";\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AdminAction.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/AdminAction.java#render",
        "raw_code": "@Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        String content = request.getParameter(\"content\");\n        XWikiDocument doc = context.getDoc();\n        XWikiForm form = context.getForm();\n\n        synchronized (doc) {\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            EditForm peform = (EditForm) form;\n            String parent = peform.getParent();\n            if (parent != null) {\n                doc.setParent(parent);\n            }\n            String creator = peform.getCreator();\n            if (creator != null) {\n                doc.setCreator(creator);\n            }\n            String defaultTemplate = peform.getDefaultTemplate();\n            if (defaultTemplate != null) {\n                doc.setDefaultTemplate(defaultTemplate);\n            }\n            String defaultLanguage = peform.getDefaultLanguage();\n            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {\n                doc.setDefaultLanguage(defaultLanguage);\n            }\n            if (doc.getDefaultLanguage().equals(\"\")) {\n                doc.setDefaultLanguage(context.getWiki().getLanguagePreference(context));\n            }\n\n            String language = context.getWiki().getLanguagePreference(context);\n            String languagefromrequest = context.getRequest().getParameter(\"language\");\n            String languagetoedit =\n                ((languagefromrequest == null) || (languagefromrequest.equals(\"\"))) ? language : languagefromrequest;\n\n            if ((languagetoedit == null) || (languagetoedit.equals(\"default\"))) {\n                languagetoedit = \"\";\n            }\n            if (doc.isNew() || (doc.getDefaultLanguage().equals(languagetoedit))) {\n                languagetoedit = \"\";\n            }\n\n            if (languagetoedit.equals(\"\")) {\n                // In this case the created document is going to be the default document\n                tdoc = doc;\n                context.put(\"tdoc\", doc);\n                if (doc.isNew()) {\n                    doc.setDefaultLanguage(language);\n                    doc.setLanguage(\"\");\n                }\n            } else {\n                // If the translated doc object is the same as the doc object\n                // this means the translated doc did not exists so we need to create it\n                if ((tdoc == doc)) {\n                    tdoc = new XWikiDocument(doc.getDocumentReference());\n                    tdoc.setLanguage(languagetoedit);\n                    tdoc.setContent(doc.getContent());\n                    tdoc.setSyntax(doc.getSyntax());\n                    tdoc.setAuthor(context.getUser());\n                    tdoc.setStore(doc.getStore());\n                    context.put(\"tdoc\", tdoc);\n                }\n            }\n\n            XWikiDocument tdoc2 = tdoc.clone();\n            if (content != null && !content.isEmpty()) {\n                tdoc2.setContent(content);\n            }\n            context.put(\"tdoc\", tdoc2);\n            try {\n                readFromTemplate(tdoc2, peform.getTemplate(), context);\n            } catch (XWikiException e) {\n                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                    context.put(\"exception\", e);\n                    return \"docalreadyexists\";\n                }\n            }\n\n            /* Setup a lock */\n            try {\n                XWikiLock lock = tdoc.getLock(context);\n                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {\n                    tdoc.setLock(context.getUser(), context);\n                }\n            } catch (Exception e) {\n                // Lock should never make XWiki fail\n                // But we should log any related information\n                LOGGER.error(\"Exception while setting up lock\", e);\n            }\n        }\n\n        return \"admin\";\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        try {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                xcontext);\n        } catch (XWikiException e) {\n            this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            return super.getLabel(groupReference, currentLabel);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiContext xcontext = this.xcontextProvider.get();\n                return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                    xcontext);\n            } catch (XWikiException e) {\n                this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                    this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return super.getLabel(groupReference, currentLabel);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.platform.ui",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "f243cf0a28785b89b7c50bf4e1cce48a917d89bd",
    "short_hash": "f243cf0a",
    "vulnerableMethods_before": [
      {
        "filename": "ListTab.java",
        "method_name": "tools/bundles/org.eclipse.e4.tools.emf.ui/src/org/eclipse/e4/tools/emf/ui/internal/common/component/tabs/ListTab.java#docToString",
        "raw_code": "static private String docToString(Document doc) throws TransformerException {\n\t\tfinal TransformerFactory tf = TransformerFactory.newInstance();\n\t\tfinal Transformer transformer = tf.newTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\"); //$NON-NLS-1$\n\t\tfinal StringWriter writer = new StringWriter();\n\t\ttransformer.transform(new DOMSource(doc), new StreamResult(writer));\n\t\tfinal String output = writer.getBuffer().toString().replaceAll(\"\\n|\\r\", \"\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\treturn output;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ListTab.java",
        "method_name": "tools/bundles/org.eclipse.e4.tools.emf.ui/src/org/eclipse/e4/tools/emf/ui/internal/common/component/tabs/ListTab.java#docToString",
        "raw_code": "static private String docToString(Document doc) throws TransformerException {\n\t\t@SuppressWarnings(\"restriction\")\n\t\tfinal TransformerFactory tf = org.eclipse.core.internal.runtime.XmlProcessorFactory\n\t\t\t\t.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\tfinal Transformer transformer = tf.newTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\"); //$NON-NLS-1$\n\t\tfinal StringWriter writer = new StringWriter();\n\t\ttransformer.transform(new DOMSource(doc), new StreamResult(writer));\n\t\tfinal String output = writer.getBuffer().toString().replaceAll(\"\\n|\\r\", \"\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\treturn output;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jmix",
    "cve_id": "CVE-2025-32950",
    "cwe_list": [
      "CWE-35"
    ],
    "commit_hash": "cc97e6ff974b9e7af8160fab39cc5866169daa37",
    "short_hash": "cc97e6ff",
    "vulnerableMethods_before": [
      {
        "filename": "LocalFileStorage.java",
        "method_name": "saveStream",
        "raw_code": "public long saveStream(FileRef fileRef, InputStream inputStream) {\n        Path relativePath = getRelativePath(fileRef.getPath());\n\n        Path[] roots = getStorageRoots();\n\n        // Store to primary storage\n        checkStorageDefined(roots, fileRef.getFileName());\n        checkPrimaryStorageAccessible(roots, fileRef.getFileName());\n\n        Path path = roots[0].resolve(relativePath);\n        Path parentPath = path.getParent();\n        if (parentPath == null) {\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                    \"Invalid storage root: \" + path);\n        }\n        if (!parentPath.toFile().exists() && !parentPath.toFile().mkdirs()) {\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                    \"Cannot create directory: \" + parentPath.toAbsolutePath());\n        }\n\n        checkFileExists(path);\n\n        long size;\n        try (OutputStream outputStream = Files.newOutputStream(path, CREATE_NEW)) {\n            size = IOUtils.copyLarge(inputStream, outputStream);\n            outputStream.flush();\n//            writeLog(path, false);\n        } catch (IOException e) {\n            FileUtils.deleteQuietly(path.toFile());\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, path.toAbsolutePath().toString(), e);\n        }\n\n        // Copy file to secondary storages asynchronously\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].toFile().exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileRef.getFileName(), roots[i]);\n                continue;\n            }\n\n            Path pathCopy = roots[i].resolve(relativePath);\n\n            writeExecutor.submit(() -> {\n                try {\n                    FileUtils.copyFile(path.toFile(), pathCopy.toFile(), true);\n                } catch (Exception e) {\n                    log.error(\"Error saving {} into {} : {}\", fileRef.getFileName(), pathCopy, e.getMessage());\n                }\n            });\n        }\n\n        return size;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LocalFileStorage.java",
        "method_name": "saveStream",
        "raw_code": "public long saveStream(FileRef fileRef, InputStream inputStream) {\n        Path relativePath = getRelativePath(fileRef.getPath());\n\n        Path[] roots = getStorageRoots();\n\n        // Store to primary storage\n        checkStorageDefined(roots, fileRef.getFileName());\n        checkPrimaryStorageAccessible(roots, fileRef.getFileName());\n\n        Path path = roots[0].resolve(relativePath);\n        Path parentPath = path.getParent();\n        if (parentPath == null) {\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                    \"Invalid storage root: \" + path);\n        }\n        if (!parentPath.toFile().exists() && !parentPath.toFile().mkdirs()) {\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                    \"Cannot create directory: \" + parentPath.toAbsolutePath());\n        }\n\n        checkFileExists(path);\n\n        long size;\n        long maxAllowedSize = properties.getMaxFileSize().toBytes();\n        try (OutputStream outputStream = Files.newOutputStream(path, CREATE_NEW)) {\n            size = IOUtils.copyLarge(inputStream, outputStream, 0, maxAllowedSize);\n\n            if (size >= maxAllowedSize) {\n                if (inputStream.read() != IOUtils.EOF) {\n                    outputStream.close();\n                    if (path.toFile().exists()) path.toFile().delete();\n\n                    throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                            String.format(\"File is too large: '%s'. Max file size = %s MB is exceeded but there are unread bytes left.\",\n                                    path.toAbsolutePath(),\n                                    properties.getMaxFileSize().toMegabytes()));\n                }\n            }\n            outputStream.flush();\n//            writeLog(path, false);\n        } catch (IOException e) {\n            FileUtils.deleteQuietly(path.toFile());\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, path.toAbsolutePath().toString(), e);\n        }\n\n        // Copy file to secondary storages asynchronously\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].toFile().exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileRef.getFileName(), roots[i]);\n                continue;\n            }\n\n            Path pathCopy = roots[i].resolve(relativePath);\n\n            writeExecutor.submit(() -> {\n                try {\n                    FileUtils.copyFile(path.toFile(), pathCopy.toFile(), true);\n                } catch (Exception e) {\n                    log.error(\"Error saving {} into {} : {}\", fileRef.getFileName(), pathCopy, e.getMessage());\n                }\n            });\n        }\n\n        return size;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "milo",
    "cve_id": "CVE-2022-25897",
    "cwe_list": [
      "CWE-770"
    ],
    "commit_hash": "4534381760d7d9f0bf00cbf6a8449bb0d13c6ce5",
    "short_hash": "45343817",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "SubscriptionManager.java",
        "method_name": "opc-ua-sdk/sdk-server/src/main/java/org/eclipse/milo/opcua/sdk/server/subscriptions/SubscriptionManager.java#deleteMonitoredItems",
        "raw_code": "public void deleteMonitoredItems(ServiceRequest service) throws UaException {\n        DeleteMonitoredItemsRequest request = (DeleteMonitoredItemsRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n        List<UInteger> itemsToDelete = l(request.getMonitoredItemIds());\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n        if (itemsToDelete.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        StatusCode[] deleteResults = new StatusCode[itemsToDelete.size()];\n        List<BaseMonitoredItem<?>> deletedItems = newArrayListWithCapacity(itemsToDelete.size());\n\n        synchronized (subscription) {\n            for (int i = 0; i < itemsToDelete.size(); i++) {\n                UInteger itemId = itemsToDelete.get(i);\n                BaseMonitoredItem<?> item = subscription.getMonitoredItems().get(itemId);\n\n                if (item == null) {\n                    deleteResults[i] = new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                } else {\n                    deletedItems.add(item);\n\n                    deleteResults[i] = StatusCode.GOOD;\n\n                    monitoredItemCount.decrementAndGet();\n                    server.getMonitoredItemCount().decrementAndGet();\n                }\n            }\n\n            subscription.removeMonitoredItems(deletedItems);\n        }\n\n        /*\n         * Notify AddressSpaces of the items that have been deleted.\n         */\n\n        byMonitoredItemType(\n            deletedItems,\n            dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n            eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n        );\n\n        /*\n         * Build and return results.\n         */\n        ResponseHeader header = service.createResponseHeader();\n\n        DeleteMonitoredItemsResponse response = new DeleteMonitoredItemsResponse(\n            header,\n            deleteResults,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "SharedDefaults.java",
        "method_name": "core/org.eclipse.cdt.core/templateengine/org/eclipse/cdt/core/templateengine/SharedDefaults.java#generateSharedXML",
        "raw_code": "private void generateSharedXML(File xmlFile) {\n\t\tDocument d;\n\t\ttry {\n\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\n\t\tfor (String key : sharedDefaultsMap.keySet()) {\n\t\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\t\telement.setAttribute(TemplateEngineHelper.ID, key);\n\t\t\telement.setAttribute(TemplateEngineHelper.VALUE, sharedDefaultsMap.get(key));\n\t\t}\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n\t\tResult fileResult = new StreamResult(xmlFile);\n\t\ttry {\n\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t} catch (Throwable t) {\n\t\t\tTemplateEngineUtil.log(t);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SharedDefaults.java",
        "method_name": "core/org.eclipse.cdt.core/templateengine/org/eclipse/cdt/core/templateengine/SharedDefaults.java#generateSharedXML",
        "raw_code": "private void generateSharedXML(File xmlFile) {\n\t\tDocument d;\n\t\ttry {\n\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\n\t\tfor (String key : sharedDefaultsMap.keySet()) {\n\t\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\t\telement.setAttribute(TemplateEngineHelper.ID, key);\n\t\t\telement.setAttribute(TemplateEngineHelper.VALUE, sharedDefaultsMap.get(key));\n\t\t}\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\tResult fileResult = new StreamResult(xmlFile);\n\t\ttry {\n\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t} catch (Throwable t) {\n\t\t\tTemplateEngineUtil.log(t);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "rebuild",
    "cve_id": "CVE-2023-1495",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "c9474f84e5f376dd2ade2078e3039961a9425da7",
    "short_hash": "c9474f84",
    "vulnerableMethods_before": [
      {
        "filename": "ReferenceSearchController.java",
        "method_name": "buildResultSearch",
        "raw_code": "private JSON buildResultSearch(Entity searchEntity, String quickFields, String q, String appendWhere, int maxResults) {\n        String searchWhere = \"(1=1)\";\n\n        if (StringUtils.isNotBlank(q)) {\n            // \n            Set<String> searchFields = ParseHelper.buildQuickFields(searchEntity, quickFields);\n            if (searchFields.isEmpty()) {\n                return JSONUtils.EMPTY_ARRAY;\n            }\n\n            String like = \" like '%\" + StringEscapeUtils.escapeSql(q) + \"%'\";\n            searchWhere = StringUtils.join(searchFields.iterator(), like + \" or \") + like;\n        }\n\n        if (appendWhere != null) {\n            searchWhere = String.format(\"(%s) and (%s)\", appendWhere, searchWhere);\n        } else {\n            searchWhere = String.format(\"(%s)\", searchWhere);\n        }\n\n        List<Object> result = resultSearch(searchWhere, searchEntity, maxResults);\n        return (JSON) JSON.toJSON(result);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ReferenceSearchController.java",
        "method_name": "buildResultSearch",
        "raw_code": "private JSON buildResultSearch(Entity searchEntity, String quickFields, String q, String appendWhere, int maxResults) {\n        String searchWhere = \"(1=1)\";\n\n        if (StringUtils.isNotBlank(q)) {\n            // \n            Set<String> searchFields = ParseHelper.buildQuickFields(searchEntity, quickFields);\n            if (searchFields.isEmpty()) {\n                return JSONUtils.EMPTY_ARRAY;\n            }\n\n            String like = \" like '%\" + CommonsUtils.escapeSql(q) + \"%'\";\n            searchWhere = StringUtils.join(searchFields.iterator(), like + \" or \") + like;\n        }\n\n        if (appendWhere != null) {\n            searchWhere = String.format(\"(%s) and (%s)\", appendWhere, searchWhere);\n        } else {\n            searchWhere = String.format(\"(%s)\", searchWhere);\n        }\n\n        List<Object> result = resultSearch(searchWhere, searchEntity, maxResults);\n        return (JSON) JSON.toJSON(result);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "UnsafeAccessor",
    "cve_id": "CVE-2022-31139",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "4ef83000184e8f13239a1ea2847ee401d81585fd",
    "short_hash": "4ef83000",
    "vulnerableMethods_before": [
      {
        "filename": "UnsafeAccess.java",
        "method_name": "api/src/main/java/io/github/karlatemp/unsafeaccessor/UnsafeAccess.java#getInstance",
        "raw_code": "public static UnsafeAccess getInstance() {\n        SecurityCheck.getInstance();\n        return INSTANCE;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UnsafeAccess.java",
        "method_name": "api/src/main/java/io/github/karlatemp/unsafeaccessor/UnsafeAccess.java#getInstance",
        "raw_code": "public static UnsafeAccess getInstance() {\n        SecurityCheck.AccessLimiter accessLimiter = SecurityCheck.getInstance().getLimiter();\n        if (accessLimiter != null) accessLimiter.preGetUnsafeAccess();\n        return INSTANCE;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "CHelpProvider.java",
        "method_name": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/help/CHelpProvider.java#loadFile",
        "raw_code": "private void loadFile(IConfigurationElement el, ArrayList<ICHelpBook> chbl, String pluginId) {\n\t\tString fname = el.getAttribute(ATTRIB_FILE);\n\t\tif (fname == null || fname.trim().length() == 0)\n\t\t\treturn;\n\t\tURL x = FileLocator.find(Platform.getBundle(pluginId), new Path(fname), null);\n\t\tif (x == null)\n\t\t\treturn;\n\t\ttry {\n\t\t\tx = FileLocator.toFileURL(x);\n\t\t} catch (IOException e) {\n\t\t\treturn;\n\t\t}\n\t\tfname = x.getPath();\n\t\tif (fname == null || fname.trim().length() == 0)\n\t\t\treturn;\n\n\t\t// format is not supported for now\n\t\t// String format = el.getAttribute(ATTRIB_FORMAT);\n\n\t\tDocument doc = null;\n\t\ttry {\n\t\t\tInputStream stream = new FileInputStream(fname);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tInputSource src = new InputSource(reader);\n\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tdoc = builder.parse(src);\n\t\t\tElement e = doc.getDocumentElement();\n\t\t\tif (NODE_HEAD.equals(e.getNodeName())) {\n\t\t\t\tNodeList list = e.getChildNodes();\n\t\t\t\tfor (int j = 0; j < list.getLength(); j++) {\n\t\t\t\t\tNode node = list.item(j);\n\t\t\t\t\tif (node.getNodeType() != Node.ELEMENT_NODE)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (NODE_BOOK.equals(node.getNodeName())) {\n\t\t\t\t\t\tchbl.add(new CHelpBook((Element) node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ParserConfigurationException e) {\n\t\t} catch (SAXException e) {\n\t\t} catch (IOException e) {\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CHelpProvider.java",
        "method_name": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/help/CHelpProvider.java#loadFile",
        "raw_code": "private void loadFile(IConfigurationElement el, ArrayList<ICHelpBook> chbl, String pluginId) {\n\t\tString fname = el.getAttribute(ATTRIB_FILE);\n\t\tif (fname == null || fname.trim().length() == 0)\n\t\t\treturn;\n\t\tURL x = FileLocator.find(Platform.getBundle(pluginId), new Path(fname), null);\n\t\tif (x == null)\n\t\t\treturn;\n\t\ttry {\n\t\t\tx = FileLocator.toFileURL(x);\n\t\t} catch (IOException e) {\n\t\t\treturn;\n\t\t}\n\t\tfname = x.getPath();\n\t\tif (fname == null || fname.trim().length() == 0)\n\t\t\treturn;\n\n\t\t// format is not supported for now\n\t\t// String format = el.getAttribute(ATTRIB_FORMAT);\n\n\t\tDocument doc = null;\n\t\ttry {\n\t\t\tInputStream stream = new FileInputStream(fname);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tInputSource src = new InputSource(reader);\n\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tdoc = builder.parse(src);\n\t\t\tElement e = doc.getDocumentElement();\n\t\t\tif (NODE_HEAD.equals(e.getNodeName())) {\n\t\t\t\tNodeList list = e.getChildNodes();\n\t\t\t\tfor (int j = 0; j < list.getLength(); j++) {\n\t\t\t\t\tNode node = list.item(j);\n\t\t\t\t\tif (node.getNodeType() != Node.ELEMENT_NODE)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (NODE_BOOK.equals(node.getNodeName())) {\n\t\t\t\t\t\tchbl.add(new CHelpBook((Element) node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tCUIPlugin.log(\"Failed to load helpbook in \" + pluginId, e); //$NON-NLS-1$\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "removeFileAndSoftDel",
        "raw_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            File file = new File(adiFile.getPath());\n            if (!file.delete()) {\n                log.warn(\"Delete file error,uuid:{}\", uuid);\n            }\n        }\n        this.softDel(uuid);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "removeFileAndSoftDel",
        "raw_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            try {\n                if (!Files.deleteIfExists(Paths.get(adiFile.getPath()))) {\n                    log.warn(\"Delete file fail,uuid:{}\", uuid);\n                }\n            } catch (IOException e) {\n                throw new BaseException(B_DELETE_FILE_ERROR);\n            }\n        }\n        this.softDel(uuid);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "dataease",
    "cve_id": "CVE-2023-40183",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "826513053146721a2b3e09a9c9d3ea41f8f10569",
    "short_hash": "82651305",
    "vulnerableMethods_before": [
      {
        "filename": "StaticResourceService.java",
        "method_name": "core/backend/src/main/java/io/dataease/service/staticResource/StaticResourceService.java#isImage",
        "raw_code": "private boolean isImage(MultipartFile file) {\n        BufferedImage image = null;\n        try (InputStream input = file.getInputStream()) {\n            image = ImageIO.read(input);\n        } catch (IOException e) {\n            LogUtil.error(e.getMessage(), e);\n            return false;\n        }\n        if (image == null || image.getWidth() <= 0 || image.getHeight() <= 0) {\n            return false;\n        }\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StaticResourceService.java",
        "method_name": "core/backend/src/main/java/io/dataease/service/staticResource/StaticResourceService.java#isImage",
        "raw_code": "private boolean isImage(MultipartFile file) {\n        BufferedImage image = null;\n        try (InputStream input = file.getInputStream()) {\n            image = ImageIO.read(input);\n        } catch (IOException e) {\n            LogUtil.error(e.getMessage(), e);\n            return false;\n        }\n        Pattern pattern = Pattern.compile(\"\\\\.(png|jpg|jpeg|gif)$\");\n        Matcher matcher = pattern.matcher(file.getOriginalFilename().toLowerCase());\n        if (image == null || image.getWidth() <= 0 || image.getHeight() <= 0 || !matcher.find()) {\n            return false;\n        }\n\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xp",
    "cve_id": "CVE-2024-23679",
    "cwe_list": [
      "CWE-384"
    ],
    "commit_hash": "2abac31cec8679074debc4f1fb69c25930e40842",
    "short_hash": "2abac31c",
    "vulnerableMethods_before": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#getSortedIdProviders",
        "raw_code": "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from( idProviders.stream().\n            sorted( Comparator.comparing( u -> u.getKey().toString() ) ).\n            collect( Collectors.toList() ) );\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#getSortedIdProviders",
        "raw_code": "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from(\n            idProviders.stream().sorted( Comparator.comparing( u -> u.getKey().toString() ) ).collect( Collectors.toList() ) );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenSearch",
    "cve_id": "CVE-2022-41917",
    "cwe_list": [
      "CWE-755"
    ],
    "commit_hash": "6d20423f5920745463b1abc5f1daf6a786c41aa0",
    "short_hash": "6d20423f",
    "vulnerableMethods_before": [
      {
        "filename": "Analysis.java",
        "method_name": "server/src/main/java/org/opensearch/index/analysis/Analysis.java#getWordSet",
        "raw_code": "public static CharArraySet getWordSet(Environment env, Settings settings, String settingsPrefix) {\n        List<String> wordList = getWordList(env, settings, settingsPrefix);\n        if (wordList == null) {\n            return null;\n        }\n        boolean ignoreCase = settings.getAsBoolean(settingsPrefix + \"_case\", false);\n        return new CharArraySet(wordList, ignoreCase);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Analysis.java",
        "method_name": "server/src/main/java/org/opensearch/index/analysis/Analysis.java#getWordSet",
        "raw_code": "public static CharArraySet getWordSet(Environment env, Settings settings, String settingsPrefix) {\n        List<String> wordList = parseWordList(env, settings, settingsPrefix, s -> s);\n        if (wordList == null) {\n            return null;\n        }\n        boolean ignoreCase = settings.getAsBoolean(settingsPrefix + \"_case\", false);\n        return new CharArraySet(wordList, ignoreCase);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-37913",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "45d182a4141ff22f3ff289cf71e4669bdc714544",
    "short_hash": "45d182a4",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultPresentationBuilder.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/builder/DefaultPresentationBuilder.java#build",
        "raw_code": "@Override\n    public XDOMOfficeDocument build(InputStream officeFileStream, String officeFileName,\n        DocumentReference documentReference) throws OfficeImporterException\n    {\n        // Accents seems to cause issues in some conditions\n        // See https://jira.xwiki.org/browse/XWIKI-14692\n        String cleanedOfficeFileName = StringUtils.stripAccents(officeFileName);\n\n        // Invoke the office document converter.\n        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, cleanedOfficeFileName);\n\n        Pair<String, Set<File>> htmlPresentationResult = null;\n        // Create presentation HTML.\n        try {\n            htmlPresentationResult = buildPresentationHTML(officeConverterResult,\n                StringUtils.substringBeforeLast(cleanedOfficeFileName, \".\"));\n        } catch (IOException e) {\n            throw new OfficeImporterException(\"Error while preparing the presentation artifacts.\", e);\n        }\n\n        // Clear and adjust presentation HTML (slide image URLs are updated to point to the corresponding attachments).\n        String html = cleanPresentationHTML(htmlPresentationResult.getLeft(), documentReference);\n\n        // Create the XDOM.\n        XDOM xdom = buildPresentationXDOM(html, documentReference);\n\n        return new XDOMOfficeDocument(xdom, htmlPresentationResult.getRight(),\n            this.contextComponentManagerProvider.get(), officeConverterResult);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultPresentationBuilder.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/builder/DefaultPresentationBuilder.java#build",
        "raw_code": "@Override\n    public XDOMOfficeDocument build(InputStream officeFileStream, String officeFileName,\n        DocumentReference documentReference) throws OfficeImporterException\n    {\n        // Invoke the office document converter.\n        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, officeFileName);\n\n        Pair<String, Map<String, OfficeDocumentArtifact>> htmlPresentationResult;\n        // Create presentation HTML.\n        try {\n            htmlPresentationResult = buildPresentationHTML(officeConverterResult,\n                StringUtils.substringBeforeLast(officeFileName, \".\"));\n        } catch (IOException e) {\n            throw new OfficeImporterException(\"Error while preparing the presentation artifacts.\", e);\n        }\n\n        // Clear and adjust presentation HTML (slide image URLs are updated to point to the corresponding attachments).\n        String html = cleanPresentationHTML(htmlPresentationResult.getLeft(), documentReference);\n\n        // Create the XDOM.\n        XDOM xdom = buildPresentationXDOM(html, documentReference);\n\n        return new XDOMOfficeDocument(xdom, htmlPresentationResult.getRight(),\n            this.contextComponentManagerProvider.get(), officeConverterResult);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "Java-springboot-codebase",
    "cve_id": "CVE-2024-52302",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "204402bb8b68030c14911379ddc82cfff00b8538",
    "short_hash": "204402bb",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "FileSystemStorageService.java",
        "method_name": "spring boot/common-user-management/src/main/java/common/management/common/service/impl/FileSystemStorageService.java#store",
        "raw_code": "@Override\n    public int store(MultipartFile file, String nameAndExt) {\n        Path location = Paths.get(rootLocation+\"/\");\n\n        try {\n            Files.createDirectories(location);\n            if (file.isEmpty()) {\n                return OP_STATUS_FILE_EMPTY;\n            }\n            if (nameAndExt.contains(\"..\")) {\n                // This is a security check\n               return OP_STATUS_INVALID_FILE_NAME;\n            }\n\n            if(!isAllowedFileType(file)) return OP_STATUS_FILE_TYPE_NOT_ALLOWED;\n\n            try (InputStream inputStream = file.getInputStream()) {\n\n                Files.copy(inputStream, location.resolve(nameAndExt),\n                        StandardCopyOption.REPLACE_EXISTING);\n\n                if(isImage(FilenameUtils.getExtension(file.getOriginalFilename()))){\n                    createThumbnail(file,thumbWidth,nameAndExt);\n                }\n            }\n            return OP_STATUS_SUCCESS;\n        }\n        catch (IOException e) {\n            log.error(\"[EXCEPTION] store : {},{}\",e.getMessage(),e.getCause());\n            return OP_STATUS_FAILED;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tigervnc",
    "cve_id": "CVE-2020-26117",
    "cwe_list": [
      "CWE-295"
    ],
    "commit_hash": "f029745f63ac7d22fb91639b2cb5b3ab56134d6e",
    "short_hash": "f029745f",
    "vulnerableMethods_before": [
      {
        "filename": "CSecurityTLS.java",
        "method_name": "java/com/tigervnc/rfb/CSecurityTLS.java#checkServerTrusted",
        "raw_code": "public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      Collection<? extends Certificate> certs = null;\n      X509Certificate cert = chain[0];\n      try {\n        cert.checkValidity();\n      } catch(CertificateNotYetValidException e) {\n        throw new AuthFailureException(\"server certificate has not been activated\");\n      } catch(CertificateExpiredException e) {\n        if (!msg.showMsgBox(YES_NO_OPTION, \"certificate has expired\",\n\t\t\t      \"The certificate of the server has expired, \"+\n\t\t\t      \"do you want to continue?\"))\n          throw new AuthFailureException(\"server certificate has expired\");\n      }\n      String thumbprint = getThumbprint(cert);\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      File certFile = new File(vncDir, \"x509_savedcerts.pem\");\n      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n      if (vncDir.exists() && certFile.exists() && certFile.canRead()) {\n        InputStream certStream = new MyFileInputStream(certFile);\n        certs = cf.generateCertificates(certStream);\n        for (Certificate c : certs)\n          if (thumbprint.equals(getThumbprint((X509Certificate)c)))\n            return;\n      }\n      try {\n        verifyHostname(cert);\n        tm.checkServerTrusted(chain, authType);\n      } catch (java.lang.Exception e) {\n        if (e.getCause() instanceof CertPathBuilderException) {\n          String certinfo =\n            \"This certificate has been signed by an unknown authority\\n\"+\n            \"\\n\"+\n            \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n            \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n            \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n            \"  Version: \"+cert.getVersion()+\"\\n\"+\n            \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n            \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n            \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n            \"  SHA1 Fingerprint: \"+getThumbprint(cert)+\"\\n\"+\n            \"\\n\"+\n            \"Do you want to save it and continue?\";\n          if (!msg.showMsgBox(YES_NO_OPTION, \"certificate issuer unknown\",\n                certinfo)) {\n            throw new AuthFailureException(\"certificate issuer unknown\");\n          }\n          if (certs == null || !certs.contains(cert)) {\n            byte[] der = cert.getEncoded();\n            String pem = Base64.getEncoder().encodeToString(der);\n            pem = pem.replaceAll(\"(.{64})\", \"$1\\n\");\n            FileWriter fw = null;\n            try {\n              if (!vncDir.exists())\n                vncDir.mkdir();\n              if (!certFile.exists() && !certFile.createNewFile()) {\n                vlog.error(\"Certificate save failed.\");\n              } else {\n                fw = new FileWriter(certFile.getAbsolutePath(), true);\n                fw.write(\"-----BEGIN CERTIFICATE-----\\n\");\n                fw.write(pem+\"\\n\");\n                fw.write(\"-----END CERTIFICATE-----\\n\");\n              }\n            } catch (IOException ioe) {\n              msg.showMsgBox(OK_OPTION, \"certificate save failed\",\n                             \"Could not save the certificate\");\n            } finally {\n              try {\n                if (fw != null)\n                  fw.close();\n              } catch(IOException ioe2) {\n                throw new Exception(ioe2.getMessage());\n              }\n            }\n          }\n        } else {\n          throw new SystemException(e.getMessage());\n        }\n      }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CSecurityTLS.java",
        "method_name": "java/com/tigervnc/rfb/CSecurityTLS.java#checkServerTrusted",
        "raw_code": "public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      Collection<? extends Certificate> certs = null;\n      X509Certificate cert = chain[0];\n      String pk =\n        Base64.getEncoder().encodeToString(cert.getPublicKey().getEncoded());\n      try {\n        cert.checkValidity();\n        verifyHostname(cert);\n      } catch(CertificateParsingException e) {\n        throw new SystemException(e.getMessage());\n      } catch(CertificateNotYetValidException e) {\n        throw new AuthFailureException(\"server certificate has not been activated\");\n      } catch(CertificateExpiredException e) {\n        if (!msg.showMsgBox(YES_NO_OPTION, \"certificate has expired\",\n\t\t\t      \"The certificate of the server has expired, \"+\n\t\t\t      \"do you want to continue?\"))\n          throw new AuthFailureException(\"server certificate has expired\");\n      }\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      if (!vncDir.exists())\n        throw new AuthFailureException(\"Could not obtain VNC home directory \"+\n                                       \"path for known hosts storage\");\n      File dbPath = new File(vncDir, \"x509_known_hosts\");\n      String info =\n        \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n        \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n        \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n        \"  Version: \"+cert.getVersion()+\"\\n\"+\n        \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n        \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n        \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n        \"  SHA-1 Fingerprint: \"+getThumbprint(cert)+\"\\n\";\n      try {\n        if (dbPath.exists()) {\n          FileReader db = new FileReader(dbPath);\n          BufferedReader dbBuf = new BufferedReader(db);\n          String line;\n          String server = client.getServerName().toLowerCase();\n          while ((line = dbBuf.readLine())!=null) {\n            String fields[] = line.split(\"\\\\|\");\n            if (fields.length==6) {\n              if (server.equals(fields[2]) && pk.equals(fields[5])) {\n                vlog.debug(\"Server certificate found in known hosts file\");\n                dbBuf.close();\n                return;\n              } else if (server.equals(fields[2]) && !pk.equals(fields[5]) ||\n                         !server.equals(fields[2]) && pk.equals(fields[5])) {\n                throw new CertStoreException();\n              }\n            }\n          }\n          dbBuf.close();\n        }\n        tm.checkServerTrusted(chain, authType);\n      } catch (IOException e) {\n        throw new AuthFailureException(\"Could not load known hosts database\");\n      } catch (CertStoreException e) {\n        vlog.debug(\"Server host key mismatch\");\n        vlog.debug(info);\n        String text =\n          \"This host is previously known with a different \"+\n          \"certificate, and the new certificate has been \"+\n          \"signed by an unknown authority\\n\"+\n          \"\\n\"+info+\"\\n\"+\n          \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n          \"\\n\"+\n          \"Do you want to make an exception for this server?\";\n        if (!msg.showMsgBox(YES_NO_OPTION, \"Unexpected certificate issuer\", text))\n          throw new AuthFailureException(\"Unexpected certificate issuer\");\n        store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n      } catch (java.lang.Exception e) {\n        if (e.getCause() instanceof CertPathBuilderException) {\n          vlog.debug(\"Server host not previously known\");\n          vlog.debug(info);\n          String text =\n            \"This certificate has been signed by an unknown authority\\n\"+\n            \"\\n\"+info+\"\\n\"+\n            \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n            \"\\n\"+\n            \"Do you want to make an exception for this server?\";\n          if (!msg.showMsgBox(YES_NO_OPTION, \"Unknown certificate issuer\", text))\n            throw new AuthFailureException(\"Unknown certificate issuer\");\n          store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n        } else {\n          throw new SystemException(e.getMessage());\n        }\n      }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "socket.io-client-java",
    "cve_id": "CVE-2022-25867",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "e8ffe9d1383736f6a21090ab959a2f4fa5a41284",
    "short_hash": "e8ffe9d1",
    "vulnerableMethods_before": [
      {
        "filename": "Manager.java",
        "method_name": "src/main/java/io/socket/client/Manager.java#onopen",
        "raw_code": "private void onopen() {\n        logger.fine(\"open\");\n\n        this.cleanup();\n\n        this.readyState = ReadyState.OPEN;\n        this.emit(EVENT_OPEN);\n\n        final io.socket.engineio.client.Socket socket = this.engine;\n        this.subs.add(On.on(socket, Engine.EVENT_DATA, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Object data = objects[0];\n                if (data instanceof String) {\n                    Manager.this.ondata((String)data);\n                } else if (data instanceof byte[]) {\n                    Manager.this.ondata((byte[])data);\n                }\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_ERROR, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onerror((Exception)objects[0]);\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_CLOSE, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onclose((String)objects[0]);\n            }\n        }));\n        this.decoder.onDecoded(new Parser.Decoder.Callback() {\n            @Override\n            public void call (Packet packet) {\n                Manager.this.ondecoded(packet);\n            }\n        });\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Manager.java",
        "method_name": "src/main/java/io/socket/client/Manager.java#onopen",
        "raw_code": "private void onopen() {\n        logger.fine(\"open\");\n\n        this.cleanup();\n\n        this.readyState = ReadyState.OPEN;\n        this.emit(EVENT_OPEN);\n\n        final io.socket.engineio.client.Socket socket = this.engine;\n        this.subs.add(On.on(socket, Engine.EVENT_DATA, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Object data = objects[0];\n                try {\n                    if (data instanceof String) {\n                        Manager.this.decoder.add((String) data);\n                    } else if (data instanceof byte[]) {\n                        Manager.this.decoder.add((byte[]) data);\n                    }\n                } catch (DecodingException e) {\n                    logger.fine(\"error while decoding the packet: \" + e.getMessage());\n                }\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_ERROR, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onerror((Exception)objects[0]);\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_CLOSE, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onclose((String)objects[0]);\n            }\n        }));\n        this.decoder.onDecoded(new Parser.Decoder.Callback() {\n            @Override\n            public void call (Packet packet) {\n                Manager.this.ondecoded(packet);\n            }\n        });\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "d2db40b9e7d22c7a0b44d7665242dfc7b4d14d78",
    "short_hash": "d2db40b9",
    "vulnerableMethods_before": [
      {
        "filename": "ConstraintViolationCreationContext.java",
        "method_name": "toString",
        "raw_code": "@Override\n\tpublic String toString() {\n\t\tfinal StringBuilder sb = new StringBuilder( \"ConstraintViolationCreationContext{\" );\n\t\tsb.append( \"message='\" ).append( message ).append( '\\'' );\n\t\tsb.append( \", expressionLanguageEnabled=\" ).append( expressionLanguageEnabled );\n\t\tsb.append( \", propertyPath=\" ).append( propertyPath );\n\t\tsb.append( \", messageParameters=\" ).append( messageParameters );\n\t\tsb.append( \", expressionVariables=\" ).append( expressionVariables );\n\t\tsb.append( \", dynamicPayload=\" ).append( dynamicPayload );\n\t\tsb.append( '}' );\n\t\treturn sb.toString();\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConstraintViolationCreationContext.java",
        "method_name": "toString",
        "raw_code": "@Override\n\tpublic String toString() {\n\t\tfinal StringBuilder sb = new StringBuilder( \"ConstraintViolationCreationContext{\" );\n\t\tsb.append( \"message='\" ).append( message ).append( '\\'' );\n\t\tsb.append( \", expressionLanguageFeatureLevel=\" ).append( expressionLanguageFeatureLevel );\n\t\tsb.append( \", customViolation=\" ).append( customViolation );\n\t\tsb.append( \", propertyPath=\" ).append( propertyPath );\n\t\tsb.append( \", messageParameters=\" ).append( messageParameters );\n\t\tsb.append( \", expressionVariables=\" ).append( expressionVariables );\n\t\tsb.append( \", dynamicPayload=\" ).append( dynamicPayload );\n\t\tsb.append( '}' );\n\t\treturn sb.toString();\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "core",
    "cve_id": "CVE-2014-8122",
    "cwe_list": [
      "CWE-362"
    ],
    "commit_hash": "6808b11cd6d97c71a2eed754ed4f955acd789086",
    "short_hash": "6808b11c",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "RequestScopedCache.java",
        "method_name": "impl/src/main/java/org/jboss/weld/context/cache/RequestScopedCache.java#beginRequest",
        "raw_code": "public static void beginRequest() {\n        // if the previous request was not ended properly for some reason, make sure it is ended now\n        endRequest();\n        CACHE.set(new LinkedList<RequestScopedItem>());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupService.java",
        "method_name": "performBackup",
        "raw_code": "private ServerBackup performBackup(ServerBackup backup, List<BackupUpdateListener> backupUpdateListeners, BackupInitiator initiatedBy) {\n        GoMailSender mailSender = goConfigService.getMailSender();\n        File destDir = new File(backup.getPath());\n        synchronized (BACKUP_MUTEX) {\n            try {\n                runningBackup = backup;\n                notifyUpdateToListeners(backupUpdateListeners, BackupProgressStatus.CREATING_DIR);\n                if (!destDir.mkdirs()) {\n                    notifyErrorToListeners(backupUpdateListeners, \"Failed to perform backup. Reason: Could not create the backup directory.\");\n                    return backup;\n                }\n                backupVersion(destDir, backupUpdateListeners);\n                backupConfig(destDir, backupUpdateListeners);\n                boolean backedUpWrapperConfig = backupWrapperConfig(destDir, backupUpdateListeners);\n                backupConfigRepo(backupUpdateListeners, destDir);\n                backupDb(destDir, backupUpdateListeners);\n                boolean passed = executePostBackupScript(backup.getUsername(), initiatedBy, backup, backupUpdateListeners);\n                if (passed) {\n                    sendBackupSuccessEmail(backup.getUsername(), mailSender, destDir);\n                    notifyCompletionToListeners(backupUpdateListeners, backedUpWrapperConfig);\n                    LOGGER.debug(\"Backup Completed Successfully\");\n                }\n            } catch (Exception e) {\n                FileUtils.deleteQuietly(destDir);\n                sendBackupFailedEmail(mailSender, e);\n                notifyErrorToListeners(backupUpdateListeners, String.format(\"Failed to perform backup. Reason: %s\", e.getMessage()));\n                LOGGER.error(\"[Backup] Failed to backup Go.\", e);\n            } finally {\n                runningBackup = null;\n            }\n        }\n        return backup;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupService.java",
        "method_name": "performBackup",
        "raw_code": "private ServerBackup performBackup(ServerBackup backup, List<BackupUpdateListener> backupUpdateListeners, BackupInitiator initiatedBy) {\n        GoMailSender mailSender = goConfigService.getMailSender();\n        File destDir = new File(backup.getPath());\n        synchronized (BACKUP_MUTEX) {\n            try {\n                runningBackup = backup;\n                validator.validatePostBackupScript(postBackupScriptFile());\n                notifyUpdateToListeners(backupUpdateListeners, BackupProgressStatus.CREATING_DIR);\n                if (!destDir.mkdirs()) {\n                    notifyErrorToListeners(backupUpdateListeners, \"Failed to perform backup. Reason: Could not create the backup directory.\");\n                    return backup;\n                }\n                backupVersion(destDir, backupUpdateListeners);\n                backupConfig(destDir, backupUpdateListeners);\n                boolean backedUpWrapperConfig = backupWrapperConfig(destDir, backupUpdateListeners);\n                backupConfigRepo(backupUpdateListeners, destDir);\n                backupDb(destDir, backupUpdateListeners);\n                boolean passed = executePostBackupScript(backup.getUsername(), initiatedBy, backup, backupUpdateListeners);\n                if (passed) {\n                    sendBackupSuccessEmail(backup.getUsername(), mailSender, destDir);\n                    notifyCompletionToListeners(backupUpdateListeners, backedUpWrapperConfig);\n                    LOGGER.debug(\"Backup Completed Successfully\");\n                }\n            } catch (Exception e) {\n                FileUtils.deleteQuietly(destDir);\n                sendBackupFailedEmail(mailSender, e);\n                notifyErrorToListeners(backupUpdateListeners, String.format(\"Failed to perform backup. Reason: %s\", e.getMessage()));\n                LOGGER.error(\"[Backup] Failed to backup Go.\", e);\n            } finally {\n                runningBackup = null;\n            }\n        }\n        return backup;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldSendEmailToAdminWhenTheBackupFails",
        "raw_code": "@Test\n    public void shouldSendEmailToAdminWhenTheBackupFails() throws Exception {\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig().setEmailOnFailure(true));\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n\n        DateTime now = new DateTime();\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        Database databaseStrategyMock = mock(Database.class);\n        doThrow(new RuntimeException(\"Oh no!\")).when(databaseStrategyMock).backup(any(File.class));\n        BackupService service = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategyMock, null);\n        ServerBackup backup = service.startBackup(admin);\n\n        String ipAddress = SystemUtil.getFirstLocalNonLoopbackIpAddress();\n        String body = String.format(\"Backup of the Go server at '%s' has failed. The reason is: %s\", ipAddress, \"Oh no!\");\n\n        assertThat(backup.isSuccessful()).isFalse();\n        assertThat(backup.getMessage()).isEqualTo(\"Failed to perform backup. Reason: Oh no!\");\n        verify(goMailSender).send(new SendEmailMessage(\"Server Backup Failed\", body, \"mail@admin.com\"));\n        verifyNoMoreInteractions(goMailSender);\n\n        assertThat(FileUtils.listFiles(backupsDirectory, TrueFileFilter.TRUE, TrueFileFilter.TRUE).isEmpty()).isTrue();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldSendEmailToAdminWhenTheBackupFails",
        "raw_code": "@Test\n    public void shouldSendEmailToAdminWhenTheBackupFails() {\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig().setEmailOnFailure(true));\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n\n        DateTime now = new DateTime();\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        Database databaseStrategyMock = mock(Database.class);\n        doThrow(new RuntimeException(\"Oh no!\")).when(databaseStrategyMock).backup(any(File.class));\n        BackupService service = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategyMock, null);\n        ServerBackup backup = service.startBackup(admin);\n\n        String ipAddress = SystemUtil.getFirstLocalNonLoopbackIpAddress();\n        String body = String.format(\"Backup of the Go server at '%s' has failed. The reason is: %s\", ipAddress, \"Oh no!\");\n\n        assertThat(backup.isSuccessful()).isFalse();\n        assertThat(backup.getMessage()).isEqualTo(\"Failed to perform backup. Reason: Oh no!\");\n        verify(goMailSender).send(new SendEmailMessage(\"Server Backup Failed\", body, \"mail@admin.com\"));\n        verifyNoMoreInteractions(goMailSender);\n\n        assertThat(FileUtils.listFiles(backupsDirectory, TrueFileFilter.TRUE, TrueFileFilter.TRUE)).isEmpty();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldNotSendEmailToAdminWhenTheBackupFailsAndEmailConfigIsNotSet",
        "raw_code": "@Test\n    public void shouldNotSendEmailToAdminWhenTheBackupFailsAndEmailConfigIsNotSet() throws Exception {\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig());\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n\n        DateTime now = new DateTime();\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        Database databaseStrategyMock = mock(Database.class);\n        doThrow(new RuntimeException(\"Oh no!\")).when(databaseStrategyMock).backup(any(File.class));\n        BackupService service = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategyMock, null);\n        ServerBackup backup = service.startBackup(admin);\n\n        assertThat(backup.isSuccessful()).isFalse();\n        assertThat(backup.getMessage()).isEqualTo(\"Failed to perform backup. Reason: Oh no!\");\n        verifyNoMoreInteractions(goMailSender);\n\n        assertThat(FileUtils.listFiles(backupsDirectory, TrueFileFilter.TRUE, TrueFileFilter.TRUE).isEmpty()).isTrue();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldNotSendEmailToAdminWhenTheBackupFailsAndEmailConfigIsNotSet",
        "raw_code": "@Test\n    public void shouldNotSendEmailToAdminWhenTheBackupFailsAndEmailConfigIsNotSet() {\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig());\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n\n        DateTime now = new DateTime();\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        Database databaseStrategyMock = mock(Database.class);\n        doThrow(new RuntimeException(\"Oh no!\")).when(databaseStrategyMock).backup(any(File.class));\n        BackupService service = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategyMock, null);\n        ServerBackup backup = service.startBackup(admin);\n\n        assertThat(backup.isSuccessful()).isFalse();\n        assertThat(backup.getMessage()).isEqualTo(\"Failed to perform backup. Reason: Oh no!\");\n        verifyNoMoreInteractions(goMailSender);\n\n        assertThat(FileUtils.listFiles(backupsDirectory, TrueFileFilter.TRUE, TrueFileFilter.TRUE)).isEmpty();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldExecutePostBackupScriptAndReturnResultOnSuccess",
        "raw_code": "@Test\n    public void shouldExecutePostBackupScriptAndReturnResultOnSuccess() throws InterruptedException {\n        final Semaphore waitForBackupToComplete = new Semaphore(1);\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig().setSchedule(null).setPostBackupScript(\"jcmd\"));\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        DateTime now = new DateTime();\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        final MessageCollectingBackupUpdateListener backupUpdateListener = new MessageCollectingBackupUpdateListener(waitForBackupToComplete);\n\n        waitForBackupToComplete.acquire();\n        backupService = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategy, backupQueue);\n        Thread backupThd = new Thread(() -> backupService.startBackup(admin, backupUpdateListener));\n\n        backupThd.start();\n        waitForBackupToComplete.acquire();\n        assertThat(backupUpdateListener.getMessages().contains(BackupProgressStatus.POST_BACKUP_SCRIPT_COMPLETE.getMessage())).isTrue();\n        backupThd.join();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldExecutePostBackupScriptAndReturnResultOnSuccess",
        "raw_code": "@Test\n    public void shouldExecutePostBackupScriptAndReturnResultOnSuccess() throws InterruptedException {\n        final Semaphore waitForBackupToComplete = new Semaphore(1);\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig().setSchedule(null).setPostBackupScript(\"jcmd\"));\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        DateTime now = new DateTime();\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        final MessageCollectingBackupUpdateListener backupUpdateListener = new MessageCollectingBackupUpdateListener(waitForBackupToComplete);\n\n        waitForBackupToComplete.acquire();\n        backupService = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategy, backupQueue);\n        Thread backupThd = new Thread(() -> backupService.startBackup(admin, backupUpdateListener));\n\n        backupThd.start();\n        waitForBackupToComplete.acquire();\n        assertThat(backupUpdateListener.messages).contains(BackupProgressStatus.POST_BACKUP_SCRIPT_COMPLETE.getMessage());\n        backupThd.join();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "cleanupBackups",
        "raw_code": "private void cleanupBackups() throws IOException {\n        FileUtils.deleteQuietly(artifactsDirHolder.getArtifactsDir());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "cleanupBackups",
        "raw_code": "private void cleanupBackups() {\n        FileUtils.deleteQuietly(artifactsDirHolder.getArtifactsDir());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "error",
        "raw_code": "@Override\n            public void error(String message) {\n            }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "error",
        "raw_code": "@Override\n        public void error(String message) {\n            errors.add(message);\n            backupComplete.release();\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49585",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "385bde985cdb61ebf315d30c0b144b6d2e2c2d45",
    "short_hash": "385bde98",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiDocumentRequiredRightAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@Test\n    void analyze() throws Exception\n    {\n        when(this.documentContextExecutor.call(any(), any())).thenAnswer(invocation -> {\n            Callable<List<RequiredRightAnalysisResult>> callable = invocation.getArgument(0);\n            return callable.call();\n        });\n\n        XWikiDocument document = mock();\n        when(document.getTitle()).thenReturn(\"title\");\n        DocumentReference mockDocumentReference = mock();\n        when(document.getDocumentReferenceWithLocale()).thenReturn(mockDocumentReference);\n        BaseObject object = mock();\n        when(document.getXObjects()).thenReturn(Map.of(mock(), List.of(object)));\n\n        XDOM xdom = mock();\n        when(document.getXDOM()).thenReturn(xdom);\n        RequiredRightAnalysisResult xdomResult = mock();\n        when(this.xdomRequiredRightAnalyzer.analyze(xdom)).thenReturn(List.of(xdomResult));\n\n        RequiredRightAnalysisResult objectResult = mock();\n        when(this.objectRequiredRightAnalyzer.analyze(object)).thenReturn(List.of(objectResult));\n\n        assertEquals(List.of(xdomResult, objectResult), this.analyzer.analyze(document));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiDocumentRequiredRightAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@Test\n    void analyze() throws Exception\n    {\n        when(this.documentContextExecutor.call(any(), any())).thenAnswer(invocation -> {\n            Callable<List<RequiredRightAnalysisResult>> callable = invocation.getArgument(0);\n            return callable.call();\n        });\n\n        XWikiDocument document = mock();\n        when(document.getTitle()).thenReturn(\"title\");\n        DocumentReference mockDocumentReference = mock();\n        when(document.getDocumentReferenceWithLocale()).thenReturn(mockDocumentReference);\n        BaseObject object = mock();\n        when(document.getXObjects()).thenReturn(Map.of(mock(), List.of(object)));\n\n        BaseClass baseClass = mock();\n        when(document.getXClass()).thenReturn(baseClass);\n\n        XDOM xdom = mock();\n        when(document.getXDOM()).thenReturn(xdom);\n        RequiredRightAnalysisResult xdomResult = mock();\n        when(this.xdomRequiredRightAnalyzer.analyze(xdom)).thenReturn(List.of(xdomResult));\n\n        RequiredRightAnalysisResult objectResult = mock();\n        when(this.objectRequiredRightAnalyzer.analyze(object)).thenReturn(List.of(objectResult));\n\n        RequiredRightAnalysisResult baseClassResult = mock();\n        when(this.baseClassRequiredRightAnalyzer.analyze(baseClass)).thenReturn(List.of(baseClassResult));\n\n        assertEquals(List.of(xdomResult, baseClassResult, objectResult), this.analyzer.analyze(document));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49585",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "385bde985cdb61ebf315d30c0b144b6d2e2c2d45",
    "short_hash": "385bde98",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiDocumentRequiredRightAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public List<RequiredRightAnalysisResult> analyze(XWikiDocument document) throws RequiredRightsException\n    {\n        // Analyze the content\n        try {\n            // Push the document into the context such that we, e.g., get the correct context wiki with the correct\n            // wiki macros etc.\n            return this.documentContextExecutor.call(() ->\n            {\n                List<RequiredRightAnalysisResult> result = new ArrayList<>();\n\n                // Analyze the title\n                if (this.velocityDetector.containsVelocityScript(document.getTitle())) {\n                    result.add(new RequiredRightAnalysisResult(\n                        document.getDocumentReferenceWithLocale(),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title\"),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title.description\",\n                            document.getTitle()),\n                        List.of(RequiredRight.MAYBE_SCRIPT, RequiredRight.MAYBE_PROGRAM)\n                    ));\n                }\n\n                // Analyze the content\n                result.addAll(this.xdomRequiredRightAnalyzer.analyze(document.getXDOM()));\n\n                // Analyze XObjects on the Root locale version of the document\n                XWikiDocument rootLocaleDocument = document;\n                if (document.getLocale() != null && !document.getLocale().equals(Locale.ROOT)) {\n                    XWikiContext context = this.contextProvider.get();\n                    rootLocaleDocument = context.getWiki().getDocument(document.getDocumentReference(), context);\n                }\n\n                for (List<BaseObject> baseObjects : rootLocaleDocument.getXObjects().values()) {\n                    for (BaseObject object : baseObjects) {\n                        result.addAll(this.objectRequiredRightAnalyzer.analyze(object));\n                    }\n                }\n\n                return result;\n            }, document);\n        } catch (Exception e) {\n            throw new RequiredRightsException(\"Error...\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiDocumentRequiredRightAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public List<RequiredRightAnalysisResult> analyze(XWikiDocument document) throws RequiredRightsException\n    {\n        // Analyze the content\n        try {\n            // Push the document into the context such that we, e.g., get the correct context wiki with the correct\n            // wiki macros etc.\n            return this.documentContextExecutor.call(() ->\n            {\n                List<RequiredRightAnalysisResult> result = new ArrayList<>();\n\n                // Analyze the title\n                if (this.velocityDetector.containsVelocityScript(document.getTitle())) {\n                    result.add(new RequiredRightAnalysisResult(\n                        document.getDocumentReferenceWithLocale(),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title\"),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title.description\",\n                            document.getTitle()),\n                        List.of(RequiredRight.MAYBE_SCRIPT, RequiredRight.MAYBE_PROGRAM)\n                    ));\n                }\n\n                // Analyze the content\n                result.addAll(this.xdomRequiredRightAnalyzer.analyze(document.getXDOM()));\n\n                // Analyze XObjects and XClass on the Root locale version of the document\n                XWikiDocument rootLocaleDocument = document;\n                if (document.getLocale() != null && !document.getLocale().equals(Locale.ROOT)) {\n                    XWikiContext context = this.contextProvider.get();\n                    rootLocaleDocument = context.getWiki().getDocument(document.getDocumentReference(), context);\n                }\n\n                result.addAll(this.classRequiredRightAnalyzer.analyze(rootLocaleDocument.getXClass()));\n\n                for (List<BaseObject> baseObjects : rootLocaleDocument.getXObjects().values()) {\n                    for (BaseObject object : baseObjects) {\n                        result.addAll(this.objectRequiredRightAnalyzer.analyze(object));\n                    }\n                }\n\n                return result;\n            }, document);\n        } catch (Exception e) {\n            throw new RequiredRightsException(\"Error...\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "restapi",
    "cve_id": "CVE-2025-32960",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "b3d599f6657d7e212fdb134a61ab5e0888669eb1",
    "short_hash": "b3d599f6",
    "vulnerableMethods_before": [
      {
        "filename": "FileDownloadController.java",
        "method_name": "downloadFile",
        "raw_code": "@GetMapping(\"/{fileDescriptorId}\")\n    public void downloadFile(@PathVariable String fileDescriptorId,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkCanReadFileDescriptor();\n\n        UUID uuid;\n        try {\n            uuid = UUID.fromString(fileDescriptorId);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid entity ID\",\n                    String.format(\"Cannot convert %s into valid entity ID\", fileDescriptorId),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n        LoadContext<FileDescriptor> ctx = LoadContext.create(FileDescriptor.class).setId(uuid);\n        FileDescriptor fd = dataService.load(ctx);\n        if (fd == null) {\n            throw new RestAPIException(\"File not found\", \"File not found. Id: \" + fileDescriptorId, HttpStatus.NOT_FOUND);\n        }\n\n        try {\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Content-Disposition\", (BooleanUtils.isTrue(attachment) ? \"attachment\" : \"inline\")\n                    + \"; filename=\\\"\" + URLEncodeUtils.encodeUtf8(fd.getName()) + \"\\\"\");\n\n            downloadFromMiddlewareAndWriteResponse(fd, response);\n        } catch (Exception e) {\n            log.error(\"Error on downloading the file {}\", fileDescriptorId, e);\n            throw new RestAPIException(\"Error on downloading the file\", \"\", HttpStatus.INTERNAL_SERVER_ERROR, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileDownloadController.java",
        "method_name": "downloadFile",
        "raw_code": "@GetMapping(\"/{fileDescriptorId}\")\n    public void downloadFile(@PathVariable String fileDescriptorId,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkCanReadFileDescriptor();\n\n        UUID uuid;\n        try {\n            uuid = UUID.fromString(fileDescriptorId);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid entity ID\",\n                    String.format(\"Cannot convert %s into valid entity ID\", fileDescriptorId),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n        LoadContext<FileDescriptor> ctx = LoadContext.create(FileDescriptor.class).setId(uuid);\n        FileDescriptor fd = dataService.load(ctx);\n        if (fd == null) {\n            throw new RestAPIException(\"File not found\", \"File not found. Id: \" + fileDescriptorId, HttpStatus.NOT_FOUND);\n        }\n\n        attachment = resolveAttachmentValue(attachment, fd);\n\n        try {\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Content-Disposition\", (BooleanUtils.isTrue(attachment) ? \"attachment\" : \"inline\")\n                    + \"; filename=\\\"\" + URLEncodeUtils.encodeUtf8(fd.getName()) + \"\\\"\");\n\n            downloadFromMiddlewareAndWriteResponse(fd, response);\n        } catch (Exception e) {\n            log.error(\"Error on downloading the file {}\", fileDescriptorId, e);\n            throw new RestAPIException(\"Error on downloading the file\", \"\", HttpStatus.INTERNAL_SERVER_ERROR, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "ConversationService.java",
        "method_name": "add",
        "raw_code": "public ConvDto add(String title, String systemMessage) {\n        Conversation conversation = this.lambdaQuery()\n                .eq(Conversation::getUserId, ThreadContext.getCurrentUserId())\n                .eq(Conversation::getTitle, title)\n                .eq(Conversation::getIsDeleted, false)\n                .one();\n        if (null != conversation) {\n            throw new BaseException(A_CONVERSATION_TITLE_EXIST);\n        }\n        String uuid = UuidUtil.createShort();\n        Conversation one = new Conversation();\n        one.setUuid(uuid);\n        one.setTitle(title);\n        one.setAiSystemMessage(systemMessage);\n        one.setUserId(ThreadContext.getCurrentUserId());\n        baseMapper.insert(one);\n\n        Conversation conv = this.lambdaQuery().eq(Conversation::getUuid, uuid).one();\n        return MPPageUtil.convertTo(conv, ConvDto.class);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversationService.java",
        "method_name": "add",
        "raw_code": "public ConvDto add(String title, String remark, String systemMessage) {\n        Conversation conversation = this.lambdaQuery()\n                .eq(Conversation::getUserId, ThreadContext.getCurrentUserId())\n                .eq(Conversation::getTitle, title)\n                .eq(Conversation::getIsDeleted, false)\n                .one();\n        if (null != conversation) {\n            throw new BaseException(A_CONVERSATION_TITLE_EXIST);\n        }\n        String uuid = UuidUtil.createShort();\n        Conversation one = new Conversation();\n        one.setUuid(uuid);\n        one.setTitle(title);\n        one.setAiSystemMessage(systemMessage);\n        one.setUserId(ThreadContext.getCurrentUserId());\n        one.setRemark(remark);\n        baseMapper.insert(one);\n\n        Conversation conv = this.lambdaQuery().eq(Conversation::getUuid, uuid).one();\n        return MPPageUtil.convertTo(conv, ConvDto.class);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "ConversationService.java",
        "method_name": "addByPresetConv",
        "raw_code": "public ConvDto addByPresetConv(String presetConvUuid) {\n        ConversationPreset presetConv = this.conversationPresetService.lambdaQuery()\n                .eq(ConversationPreset::getUuid, presetConvUuid)\n                .eq(ConversationPreset::getIsDeleted, false)\n                .oneOpt()\n                .orElseThrow(() -> new BaseException(A_PRESET_CONVERSATION_NOT_EXIST));\n        ConversationPresetRel presetRel = this.conversationPresetRelService.lambdaQuery()\n                .eq(ConversationPresetRel::getUserId, ThreadContext.getCurrentUserId())\n                .eq(ConversationPresetRel::getUserConvId, presetConv.getId())\n                .eq(ConversationPresetRel::getIsDeleted, false)\n                .oneOpt()\n                .orElse(null);\n        if (null != presetRel) {\n            Conversation conv = this.getById(presetRel.getUserConvId());\n            return MPPageUtil.convertTo(conv, ConvDto.class);\n        }\n        ConvDto convDto = self.add(presetConv.getTitle(), presetConv.getAiSystemMessage());\n        conversationPresetRelService.save(\n                ConversationPresetRel.builder()\n                        .presetConvId(presetConv.getId())\n                        .userConvId(convDto.getId())\n                        .userId(ThreadContext.getCurrentUserId())\n                        .build()\n        );\n        return convDto;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversationService.java",
        "method_name": "addByPresetConv",
        "raw_code": "public ConvDto addByPresetConv(String presetConvUuid) {\n        ConversationPreset presetConv = this.conversationPresetService.lambdaQuery()\n                .eq(ConversationPreset::getUuid, presetConvUuid)\n                .eq(ConversationPreset::getIsDeleted, false)\n                .oneOpt()\n                .orElseThrow(() -> new BaseException(A_PRESET_CONVERSATION_NOT_EXIST));\n        ConversationPresetRel presetRel = this.conversationPresetRelService.lambdaQuery()\n                .eq(ConversationPresetRel::getUserId, ThreadContext.getCurrentUserId())\n                .eq(ConversationPresetRel::getUserConvId, presetConv.getId())\n                .eq(ConversationPresetRel::getIsDeleted, false)\n                .oneOpt()\n                .orElse(null);\n        if (null != presetRel) {\n            Conversation conv = this.getById(presetRel.getUserConvId());\n            return MPPageUtil.convertTo(conv, ConvDto.class);\n        }\n        ConvDto convDto = self.add(presetConv.getTitle(), presetConv.getRemark(), presetConv.getAiSystemMessage());\n        conversationPresetRelService.save(\n                ConversationPresetRel.builder()\n                        .presetConvId(presetConv.getId())\n                        .userConvId(convDto.getId())\n                        .userId(ThreadContext.getCurrentUserId())\n                        .build()\n        );\n        return convDto;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "writeToLocal",
        "raw_code": "public AdiFile writeToLocal(MultipartFile file, boolean image) {\n        String md5 = MD5Utils.md5ByMultipartFile(file);\n        Optional<AdiFile> existFile = this.lambdaQuery()\n                .eq(AdiFile::getMd5, md5)\n                .eq(AdiFile::getIsDeleted, false)\n                .oneOpt();\n        if (existFile.isPresent()) {\n            AdiFile adiFile = existFile.get();\n            boolean exist = FileUtil.checkIfExist(adiFile.getPath());\n            if (exist) {\n                return adiFile;\n            } else {\n                log.warn(\",,fileId:{},uuid:{},md5:{}\", adiFile.getId(), adiFile.getUuid(), adiFile.getMd5());\n                this.lambdaUpdate().eq(AdiFile::getId, adiFile.getId()).set(AdiFile::getIsDeleted, true).update();\n            }\n        }\n        String uuid = UuidUtil.createShort();\n        Pair<String, String> originalFile = FileUtil.saveToLocal(file, image ? imagePath : filePath, uuid);\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(file.getOriginalFilename());\n        adiFile.setUuid(uuid);\n        adiFile.setMd5(md5);\n        adiFile.setPath(originalFile.getLeft());\n        adiFile.setExt(originalFile.getRight());\n        adiFile.setUserId(ThreadContext.getCurrentUserId());\n        this.getBaseMapper().insert(adiFile);\n        return adiFile;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "writeToLocal",
        "raw_code": "public AdiFile writeToLocal(MultipartFile file, boolean image) {\n        String sha256 = HashUtil.sha256(file);\n        Optional<AdiFile> existFile = this.lambdaQuery()\n                .eq(AdiFile::getSha256, md5)\n                .eq(AdiFile::getIsDeleted, false)\n                .oneOpt();\n        if (existFile.isPresent()) {\n            AdiFile adiFile = existFile.get();\n            boolean exist = FileUtil.checkIfExist(adiFile.getPath());\n            if (exist) {\n                return adiFile;\n            } else {\n                log.warn(\",,fileId:{},uuid:{},sha256:{}\", adiFile.getId(), adiFile.getUuid(), adiFile.getSha256());\n                this.lambdaUpdate().eq(AdiFile::getId, adiFile.getId()).set(AdiFile::getIsDeleted, true).update();\n            }\n        }\n        String uuid = UuidUtil.createShort();\n        Pair<String, String> originalFile = FileUtil.saveToLocal(file, image ? imagePath : filePath, uuid);\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(file.getOriginalFilename());\n        adiFile.setUuid(uuid);\n        adiFile.setSha256(sha256);\n        adiFile.setPath(originalFile.getLeft());\n        adiFile.setExt(originalFile.getRight());\n        adiFile.setUserId(ThreadContext.getCurrentUserId());\n        this.getBaseMapper().insert(adiFile);\n        return adiFile;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "saveImageToLocal",
        "raw_code": "public String saveImageToLocal(User user, String sourceImageUrl) {\n        String uuid = UuidUtil.createShort();\n        String localPath = imagePath + uuid + \".png\";\n        File target = new File(localPath);\n        try {\n            FileUtils.createParentDirectories(target);\n            FileUtils.copyURLToFile(new URL(sourceImageUrl), target);\n        } catch (IOException e) {\n            log.error(\"saveToLocal\", e);\n            throw new BaseException(B_SAVE_IMAGE_ERROR);\n        }\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(target.getName());\n        adiFile.setUuid(uuid);\n        adiFile.setMd5(MD5Utils.calculateMD5(localPath));\n        adiFile.setPath(localPath);\n        adiFile.setUserId(user.getId());\n        adiFile.setExt(\"png\");\n        this.getBaseMapper().insert(adiFile);\n        return uuid;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "saveImageToLocal",
        "raw_code": "public String saveImageToLocal(User user, String sourceImageUrl) {\n        String uuid = UuidUtil.createShort();\n        String localPath = imagePath + uuid + \".png\";\n        File target = new File(localPath);\n        try {\n            FileUtils.createParentDirectories(target);\n            FileUtils.copyURLToFile(new URL(sourceImageUrl), target);\n        } catch (IOException e) {\n            log.error(\"saveToLocal\", e);\n            throw new BaseException(B_SAVE_IMAGE_ERROR);\n        }\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(target.getName());\n        adiFile.setUuid(uuid);\n        adiFile.setSha256(HashUtil.sha256(localPath));\n        adiFile.setPath(localPath);\n        adiFile.setUserId(user.getId());\n        adiFile.setExt(\"png\");\n        this.getBaseMapper().insert(adiFile);\n        return uuid;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "removeFileAndSoftDel",
        "raw_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            File file = new File(adiFile.getPath());\n            if (!file.delete()) {\n                log.warn(\"Delete file error,uuid:{}\", uuid);\n            }\n        }\n        this.softDel(uuid);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "removeFileAndSoftDel",
        "raw_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            try {\n                if (!Files.deleteIfExists(Paths.get(adiFile.getPath()))) {\n                    log.warn(\"Delete file fail,uuid:{}\", uuid);\n                }\n            } catch (IOException e) {\n                throw new BaseException(B_DELETE_FILE_ERROR);\n            }\n        }\n        this.softDel(uuid);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "readImage",
        "raw_code": "private BufferedImage readImage(AdiFile adiFile, boolean thumbnail) {\n        try {\n            String currentFilePath = adiFile.getPath();\n            if (thumbnail) {\n                currentFilePath = thumbnailsPath + adiFile.getUuid() + \".\" + adiFile.getExt();\n                //\n                if (new File(adiFile.getPath()).exists() && !new File(currentFilePath).exists()) {\n                    ImgUtil.scale(\n                            cn.hutool.core.io.FileUtil.file(adiFile.getPath()),\n                            cn.hutool.core.io.FileUtil.file(currentFilePath),\n                            0.2f\n                    );\n                }\n            }\n            return ImageIO.read(new FileInputStream(currentFilePath));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "readImage",
        "raw_code": "private BufferedImage readImage(AdiFile adiFile, boolean thumbnail) {\n        try {\n            String currentFilePath = adiFile.getPath();\n            if (thumbnail) {\n                currentFilePath = thumbnailsPath + adiFile.getUuid() + \".\" + adiFile.getExt();\n                //\n                if (new File(adiFile.getPath()).exists() && !new File(currentFilePath).exists()) {\n                    ImgUtil.scale(\n                            cn.hutool.core.io.FileUtil.file(adiFile.getPath()),\n                            cn.hutool.core.io.FileUtil.file(currentFilePath),\n                            0.2f\n                    );\n                }\n            }\n            return ImageIO.read(new FileInputStream(currentFilePath));\n        } catch (IOException e) {\n            throw new BaseException(B_IO_EXCEPTION);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "ConversationController.java",
        "method_name": "add",
        "raw_code": "@PostMapping(\"/add\")\n    public ConvDto add(@RequestBody @Validated ConvAddReq convAddReq) {\n        return conversationService.add(convAddReq.getTitle(), convAddReq.getAiSystemMessage());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversationController.java",
        "method_name": "add",
        "raw_code": "@PostMapping(\"/add\")\n    public ConvDto add(@RequestBody @Validated ConvAddReq convAddReq) {\n        return conversationService.add(convAddReq.getTitle(), convAddReq.getRemark(), convAddReq.getAiSystemMessage());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "simofa",
    "cve_id": "CVE-2024-56799",
    "cwe_list": [
      "CWE-306"
    ],
    "commit_hash": "1b04ba413a9c1d12a33dd50a32f67345c2fa6f2a",
    "short_hash": "1b04ba41",
    "vulnerableMethods_before": [
      {
        "filename": "RouteLoader.java",
        "method_name": "load",
        "raw_code": "public void load(Javalin server) throws Exception {\n        // Ignore RouteLoaderException which gets\n        // thrown if a request fails verification\n        server.exception(RouteLoaderException.class, (exception, context) -> {});\n\n        for (Class<? extends Route> route : getRoutes(ROUTES_LOCATION)) {\n            if (!route.isAnnotationPresent(RouteClass.class)) continue;\n            RouteClass routeClass = route.getAnnotation(RouteClass.class);\n            Route routeInstance = route.getDeclaredConstructor().newInstance();\n            boolean registeredBefore = false;\n\n            for (Method method : route.getMethods()) {\n                if (!method.isAnnotationPresent(RouteInfo.class)) continue;\n                if (method.getParameterCount() != 1) {\n                    throw new Exception(\"Failed to load route [\" + method.getName() + \"] \" + route.getSimpleName() + \". Method has too many parameters.\");\n                }\n\n                try {\n                    Class<?> firstParam = method.getParameterTypes()[0];\n                    firstParam.asSubclass(Context.class);\n\n                    RouteInfo routeInfo = method.getAnnotation(RouteInfo.class);\n\n                    if (!registeredBefore) {\n                        if (routeClass.verifyLogin()) {\n                            server.before(routeInfo.url(), ctx -> {\n                                if (routeClass.verifyLogin()) {\n                                    if (!Route.verifyLogin(ctx)) {\n                                        throw new RouteLoaderException();\n                                    }\n                                }\n                            });\n                        }\n\n                        registeredBefore = true;\n                    }\n\n                    server.addHandler(routeInfo.method(), routeInfo.url(), ctx -> {\n                        try {\n                            method.invoke(routeInstance, ctx);\n                        } catch (InvocationTargetException e) {\n                            if (e.getTargetException() instanceof HttpResponseException) {\n                                throw (HttpResponseException) e.getTargetException();\n                            }\n\n                            throw e;\n                        }\n                    });\n\n                    Simofa.getLogger().info(\n                            String.format(\"Registered route %s %s\", routeInfo.method(), routeInfo.url())\n                    );\n                } catch (Exception e) {\n                    throw new Exception(\"Failed to load route \" + route.getSimpleName(), e);\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RouteLoader.java",
        "method_name": "load",
        "raw_code": "public void load(Javalin server) throws Exception {\n        // Ignore RouteLoaderException which gets\n        // thrown if a request fails verification\n        server.exception(RouteLoaderException.class, (exception, context) -> {});\n\n        for (Class<? extends Route> route : getRoutes(ROUTES_LOCATION)) {\n            if (!route.isAnnotationPresent(RouteClass.class)) continue;\n            RouteClass routeClass = route.getAnnotation(RouteClass.class);\n            Route routeInstance = route.getDeclaredConstructor().newInstance();\n            Set<String> registeredBefore = new HashSet<>();\n\n            for (Method method : route.getMethods()) {\n                if (!method.isAnnotationPresent(RouteInfo.class)) continue;\n                if (method.getParameterCount() != 1) {\n                    throw new Exception(\"Failed to load route [\" + method.getName() + \"] \" + route.getSimpleName() + \". Method has too many parameters.\");\n                }\n\n                try {\n                    Class<?> firstParam = method.getParameterTypes()[0];\n                    firstParam.asSubclass(Context.class);\n\n                    RouteInfo routeInfo = method.getAnnotation(RouteInfo.class);\n\n                    if (!registeredBefore.contains(routeInfo.url()) && routeClass.verifyLogin()) {\n                        server.before(routeInfo.url(), ctx -> {\n                            if (!Route.verifyLogin(ctx)) {\n                                throw new RouteLoaderException();\n                            }\n                        });\n\n                        registeredBefore.add(routeInfo.url());\n                    }\n\n                    server.addHandler(routeInfo.method(), routeInfo.url(), ctx -> {\n                        try {\n                            method.invoke(routeInstance, ctx);\n                        } catch (InvocationTargetException e) {\n                            if (e.getTargetException() instanceof HttpResponseException) {\n                                throw (HttpResponseException) e.getTargetException();\n                            }\n\n                            throw e;\n                        }\n                    });\n\n                    Simofa.getLogger().info(\n                            String.format(\"Registered route %s %s\", routeInfo.method(), routeInfo.url())\n                    );\n                } catch (Exception e) {\n                    throw new Exception(\"Failed to load route \" + route.getSimpleName(), e);\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tapir",
    "cve_id": "CVE-2024-56802",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
    "short_hash": "c36360b6",
    "vulnerableMethods_before": [
      {
        "filename": "ElasticSearchDeployKeyRepositoryTest.java",
        "method_name": "tearDown",
        "raw_code": "@AfterEach\n  void tearDown() throws IOException {\n    restClient.performRequest(new Request(HttpMethod.DELETE, \"/deploykeys\"));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ElasticSearchDeployKeyRepositoryTest.java",
        "method_name": "tearDown",
        "raw_code": "@AfterEach\n    void tearDown() throws IOException {\n        restClient.performRequest(new Request(HttpMethod.DELETE, \"/deploykeys\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tapir",
    "cve_id": "CVE-2024-56802",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
    "short_hash": "c36360b6",
    "vulnerableMethods_before": [
      {
        "filename": "CosmosDbRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n          Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n          if (deployKeys == null || deployKeys.size() != 1) {\n            throw new DeployKeyNotFoundException(\"Could not find matching key\");\n          }\n          return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CosmosDbRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n          Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n          if (deployKeys == null || deployKeys.isEmpty() {\n            throw new DeployKeyNotFoundException(\"Could not find matching key\");\n          }\n\n          return deployKeys\n            .stream()\n            .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure exact match\n            .findFirst()\n            .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tapir",
    "cve_id": "CVE-2024-56802",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
    "short_hash": "c36360b6",
    "vulnerableMethods_before": [
      {
        "filename": "DynamodbRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n    if (deployKeys == null || deployKeys.size() != 1) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n    return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DynamodbRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n    if (deployKeys == null || deployKeys.isEmpty()) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n    return deployKeys\n      .stream()\n      .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure exact match\n      .findFirst()\n      .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tapir",
    "cve_id": "CVE-2024-56802",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
    "short_hash": "c36360b6",
    "vulnerableMethods_before": [
      {
        "filename": "ElasticSearchRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n        Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n        if (deployKeys == null || deployKeys.size() != 1) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n        }\n        return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n        throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ElasticSearchRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    try {\n      Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n      if (deployKeys == null || deployKeys.isEmpty()) {\n        throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n      // Ensure we match the key exactly\n      return deployKeys.stream()\n          .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure it's an exact match\n          .findFirst()\n          .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n    } catch (Exception e) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClass.java",
        "method_name": "displayCustom",
        "raw_code": "public void displayCustom(StringBuffer buffer, String fieldName, String prefix, String type, BaseObject object,\n        final XWikiContext context) throws XWikiException\n    {\n        String content = \"\";\n        try {\n            ScriptContext scontext = Utils.getComponent(ScriptContextManager.class).getCurrentScriptContext();\n            scontext.setAttribute(\"name\", fieldName, ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"prefix\", prefix, ScriptContext.ENGINE_SCOPE);\n            // The PropertyClass instance can be used to access meta properties in the custom displayer (e.g.\n            // dateFormat, multiSelect). It can be obtained from the XClass of the given object but only if the property\n            // has been added to the XClass. We need to have it in the Velocity context for the use case when an XClass\n            // property needs to be previewed before being added to the XClass.\n            scontext.setAttribute(\"field\", new com.xpn.xwiki.api.PropertyClass(this, context),\n                ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"object\", new com.xpn.xwiki.api.Object(object, context), ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"type\", type, ScriptContext.ENGINE_SCOPE);\n\n            BaseProperty prop = (BaseProperty) object.safeget(fieldName);\n            if (prop != null) {\n                scontext.setAttribute(\"value\", prop.getValue(), ScriptContext.ENGINE_SCOPE);\n            } else {\n                // The $value property can exist in the velocity context, we overwrite it to make sure we don't get a\n                // wrong value in the displayer when the property does not exist yet.\n                scontext.setAttribute(\"value\", null, ScriptContext.ENGINE_SCOPE);\n            }\n\n            String customDisplayer = getCachedDefaultCustomDisplayer(context);\n            if (StringUtils.isNotEmpty(customDisplayer)) {\n                if (customDisplayer.equals(CLASS_DISPLAYER_IDENTIFIER)) {\n                    final String rawContent = getCustomDisplay();\n                    XWikiDocument classDocument =\n                        context.getWiki().getDocument(getObject().getDocumentReference(), context);\n                    final String classSyntax = classDocument.getSyntax().toIdString();\n                    // Using author reference since the document content is not relevant in this case.\n                    DocumentReference authorReference = classDocument.getAuthorReference();\n                    if (authorReference == null && classDocument.isNew()) {\n                        // If the class document has not been saved yet (e.g. we could be previewing a class property in\n                        // the class editor) then use the context user as author (e.g. the user that is in the process\n                        // of creating the class).\n                        authorReference = context.getUserReference();\n                    }\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. class\n                    // document author).\n                    content = renderContentInContext(rawContent, classSyntax, authorReference,\n                        classDocument.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    XWikiDocument displayerDoc = context.getWiki().getDocument(\n                        StringUtils.substringAfter(customDisplayer, DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX), context);\n                    final String rawContent = displayerDoc.getContent();\n                    final String displayerDocSyntax = displayerDoc.getSyntax().toIdString();\n                    DocumentReference authorReference = displayerDoc.getContentAuthorReference();\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. displayer\n                    // document content author).\n                    content = renderContentInContext(rawContent, displayerDocSyntax, authorReference,\n                        displayerDoc.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    content = context.getWiki().evaluateTemplate(\n                        StringUtils.substringAfter(customDisplayer, TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX), context);\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CLASSES,\n                XWikiException.ERROR_XWIKI_CLASSES_CANNOT_PREPARE_CUSTOM_DISPLAY,\n                \"Exception while preparing the custom display of \" + fieldName, e, null);\n\n        }\n        buffer.append(content);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClass.java",
        "method_name": "displayCustom",
        "raw_code": "public void displayCustom(StringBuffer buffer, String fieldName, String prefix, String type, BaseObject object,\n        final XWikiContext context) throws XWikiException\n    {\n        String content = \"\";\n        try {\n            ScriptContext scontext = Utils.getComponent(ScriptContextManager.class).getCurrentScriptContext();\n            scontext.setAttribute(\"name\", fieldName, ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"prefix\", prefix, ScriptContext.ENGINE_SCOPE);\n            // The PropertyClass instance can be used to access meta properties in the custom displayer (e.g.\n            // dateFormat, multiSelect). It can be obtained from the XClass of the given object but only if the property\n            // has been added to the XClass. We need to have it in the Velocity context for the use case when an XClass\n            // property needs to be previewed before being added to the XClass.\n            scontext.setAttribute(\"field\", new com.xpn.xwiki.api.PropertyClass(this, context),\n                ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"object\", new com.xpn.xwiki.api.Object(object, context), ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"type\", type, ScriptContext.ENGINE_SCOPE);\n\n            BaseProperty prop = (BaseProperty) object.safeget(fieldName);\n            if (prop != null) {\n                scontext.setAttribute(\"value\", prop.getValue(), ScriptContext.ENGINE_SCOPE);\n            } else {\n                // The $value property can exist in the velocity context, we overwrite it to make sure we don't get a\n                // wrong value in the displayer when the property does not exist yet.\n                scontext.setAttribute(\"value\", null, ScriptContext.ENGINE_SCOPE);\n            }\n\n            String customDisplayer = getCachedDefaultCustomDisplayer(context);\n            if (StringUtils.isNotEmpty(customDisplayer)) {\n                if (customDisplayer.equals(CLASS_DISPLAYER_IDENTIFIER)) {\n                    final String rawContent = getCustomDisplay();\n                    XWikiDocument classDocument = getObject().getOwnerDocument();\n                    final String classSyntax = classDocument.getSyntax().toIdString();\n                    // Using author reference since the document content is not relevant in this case.\n                    DocumentReference authorReference = classDocument.getAuthorReference();\n                    if (authorReference == null && classDocument.isNew()) {\n                        // If the class document has not been saved yet (e.g. we could be previewing a class property in\n                        // the class editor) then use the context user as author (e.g. the user that is in the process\n                        // of creating the class).\n                        authorReference = context.getUserReference();\n                    }\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. class\n                    // document author).\n                    content = renderContentInContext(rawContent, classSyntax, authorReference,\n                        classDocument.getDocumentReference(), classDocument.isRestricted(), context);\n                } else if (customDisplayer.startsWith(DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    XWikiDocument displayerDoc = context.getWiki().getDocument(\n                        StringUtils.substringAfter(customDisplayer, DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX), context);\n                    final String rawContent = displayerDoc.getContent();\n                    final String displayerDocSyntax = displayerDoc.getSyntax().toIdString();\n                    DocumentReference authorReference = displayerDoc.getContentAuthorReference();\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. displayer\n                    // document content author).\n                    content = renderContentInContext(rawContent, displayerDocSyntax, authorReference,\n                        displayerDoc.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    content = context.getWiki().evaluateTemplate(\n                        StringUtils.substringAfter(customDisplayer, TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX), context);\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CLASSES,\n                XWikiException.ERROR_XWIKI_CLASSES_CANNOT_PREPARE_CUSTOM_DISPLAY,\n                \"Exception while preparing the custom display of \" + fieldName, e, null);\n\n        }\n        buffer.append(content);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClass.java",
        "method_name": "renderContentInContext",
        "raw_code": "@Deprecated\n    protected String renderContentInContext(final String content, final String syntax,\n        DocumentReference authorReference, final XWikiContext context) throws Exception\n    {\n        return renderContentInContext(content, syntax, authorReference, null, context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClass.java",
        "method_name": "renderContentInContext",
        "raw_code": "@Unstable\n    protected String renderContentInContext(final String content, final String syntax,\n        DocumentReference authorReference, DocumentReference secureDocument,\n        boolean restricted, final XWikiContext context)\n        throws Exception\n    {\n        return Utils.getComponent(AuthorExecutor.class)\n            .call(() -> context.getDoc().getRenderedContent(content, syntax, restricted, context), authorReference,\n                secureDocument);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "before",
        "raw_code": "@BeforeEach\n    public void before() throws Exception\n    {\n        DocumentReference classReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Class\");\n        XWikiDocument classDocument = new XWikiDocument(classReference);\n        classDocument.setSyntax(Syntax.XWIKI_2_1);\n        doReturn(classDocument).when(this.oldCore.getSpyXWiki()).getDocument(classReference,\n            this.oldCore.getXWikiContext());\n\n        this.xclass.setOwnerDocument(classDocument);\n\n        this.oldCore.getMocker().registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n        this.oldCore.getMocker().registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        this.oldCore.getMocker().registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "before",
        "raw_code": "@BeforeEach\n    public void before() throws Exception\n    {\n        DocumentReference classReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Class\");\n        XWikiDocument classDocument = new XWikiDocument(classReference);\n        classDocument.setSyntax(Syntax.XWIKI_2_1);\n        this.xclass.setOwnerDocument(classDocument);\n\n        this.oldCore.getMocker().registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n        this.oldCore.getMocker().registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        this.oldCore.getMocker().registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n\n        DocumentReference contextDocumentReference = new DocumentReference(\"wiki\", \"XWiki\", \"Context\");\n        this.oldCore.getXWikiContext().setDoc(new XWikiDocument(contextDocumentReference));\n\n        when(this.renderingContext.getTargetSyntax()).thenReturn(Syntax.HTML_5_0);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "displayCustomWithClassDisplayerAndClassIsNew",
        "raw_code": "@Test\n    public void displayCustomWithClassDisplayerAndClassIsNew() throws Exception\n    {\n        DocumentReference userReference = new DocumentReference(\"wiki\", \"XWiki\", \"Alice\");\n        this.oldCore.getXWikiContext().setUserReference(userReference);\n\n        displayCustomWithAuthor(userReference, this.xclass.getDocumentReference());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "displayCustomWithClassDisplayerAndClassIsNew",
        "raw_code": "@Test\n    public void displayCustomWithClassDisplayerAndClassIsNew() throws Exception\n    {\n        DocumentReference userReference = new DocumentReference(\"wiki\", \"XWiki\", \"Alice\");\n        this.oldCore.getXWikiContext().setUserReference(userReference);\n\n        displayCustomWithAuthor(userReference, this.xclass.getDocumentReference());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "displayCustomWithAuthor",
        "raw_code": "private void displayCustomWithAuthor(DocumentReference authorReference, DocumentReference secureDocument)\n        throws Exception\n    {\n        when(this.authorExecutor.call(any(Callable.class), eq(authorReference), eq(secureDocument)))\n            .thenReturn(\"output\");\n\n        PropertyClass propertyClass = new PropertyClass();\n        propertyClass.setCustomDisplay(\"test\");\n        propertyClass.setObject(this.xclass);\n\n        StringBuffer buffer = new StringBuffer();\n\n        propertyClass.displayCustom(buffer, \"date\", \"Path.To.Class_0_\", \"edit\", new BaseObject(),\n            this.oldCore.getXWikiContext());\n\n        assertEquals(\"output\", buffer.toString());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "displayCustomWithAuthor",
        "raw_code": "private void displayCustomWithAuthor(DocumentReference authorReference, DocumentReference secureDocument)\n        throws Exception\n    {\n        when(this.authorExecutor.call(any(), eq(authorReference), eq(secureDocument)))\n            .then(invocationOnMock -> {\n                Callable<String> callable = invocationOnMock.getArgument(0);\n                return callable.call();\n            });\n\n        String output = \"output\";\n        XDOM mockXDOM = mock();\n        when(this.documentDisplayer.display(any(), any())).thenReturn(mockXDOM);\n\n        doAnswer(invocationOnMock -> {\n            WikiPrinter printer = invocationOnMock.getArgument(1);\n            printer.print(output);\n            return null;\n        }).when(this.htmlRenderer).render(same(mockXDOM), any());\n\n        PropertyClass propertyClass = new PropertyClass();\n        propertyClass.setCustomDisplay(CUSTOM_DISPLAY);\n        propertyClass.setObject(this.xclass);\n\n        StringBuffer buffer = new StringBuffer();\n\n        propertyClass.displayCustom(buffer, \"date\", \"Path.To.Class_0_\", \"edit\", new BaseObject(),\n            this.oldCore.getXWikiContext());\n\n        assertEquals(output, buffer.toString());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "abdcefc0db27035b67329add836fd683e0cf92b8",
    "short_hash": "abdcefc0",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultMacroBlockRequiredRightAnalyzer.java",
        "method_name": "analyzeWithExceptions",
        "raw_code": "private List<RequiredRightAnalysisResult> analyzeWithExceptions(MacroBlock macroBlock)\n        throws RequiredRightsException\n    {\n        List<RequiredRightAnalysisResult> result;\n\n        Optional<RequiredRightAnalyzer<MacroBlock>>\n            specificAnalyzer = getMacroBlockRequiredRightAnalyzer(macroBlock);\n\n        if (specificAnalyzer.isPresent()) {\n            result = specificAnalyzer.get().analyze(macroBlock);\n        } else {\n            // Check if there is a macro analyzer for this macro, if yes, use it.\n            Optional<MacroRequiredRightsAnalyzer> macroAnalyzer = getMacroAnalyzer(macroBlock.getId());\n\n            if (macroAnalyzer.isPresent()) {\n                DefaultMacroRequiredRightReporter reporter = this.macroRequiredRightReporterProvider.get();\n                macroAnalyzer.get().analyze(macroBlock, reporter);\n                result = reporter.getResults();\n            } else {\n                // No specific analyzer found, get more information about the macro.\n                Macro<?> macro = getMacro(macroBlock);\n\n                if (macro instanceof ScriptMacro) {\n                    result = this.scriptMacroAnalyzer.analyze(macroBlock);\n                } else if (macro != null && this.shouldMacroContentBeParsed(macro)) {\n                    result = analyzeMacroContent(macroBlock, macroBlock.getContent());\n                } else {\n                    result = List.of();\n                }\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultMacroBlockRequiredRightAnalyzer.java",
        "method_name": "analyzeWithExceptions",
        "raw_code": "private List<RequiredRightAnalysisResult> analyzeWithExceptions(MacroBlock macroBlock)\n        throws RequiredRightsException\n    {\n        List<RequiredRightAnalysisResult> result;\n\n        Optional<RequiredRightAnalyzer<MacroBlock>>\n            specificAnalyzer = getMacroBlockRequiredRightAnalyzer(macroBlock);\n\n        if (specificAnalyzer.isPresent()) {\n            result = specificAnalyzer.get().analyze(macroBlock);\n        } else {\n            // Check if there is a macro analyzer for this macro, if yes, use it.\n            Optional<MacroRequiredRightsAnalyzer> macroAnalyzer = getMacroAnalyzer(macroBlock.getId());\n\n            if (macroAnalyzer.isPresent()) {\n                DefaultMacroRequiredRightReporter reporter = this.macroRequiredRightReporterProvider.get();\n                macroAnalyzer.get().analyze(macroBlock, reporter);\n                result = reporter.getResults();\n            } else {\n                // No specific analyzer found, get more information about the macro.\n                Macro<?> macro = getMacro(macroBlock);\n\n                if (macro instanceof ScriptMacro) {\n                    result = this.scriptMacroAnalyzer.analyze(macroBlock);\n                } else if (macro != null) {\n                    result = new ArrayList<>(maybeAnalyzeMacroContent(macroBlock, macro));\n                    result.addAll(maybeAnalyzeParameters(macroBlock, macro));\n                } else {\n                    result = List.of();\n                }\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49581",
    "cwe_list": [
      "CWE-270"
    ],
    "commit_hash": "c99d501ed41cbee6a3c02ff927714531570789de",
    "short_hash": "c99d501e",
    "vulnerableMethods_before": [
      {
        "filename": "ObjectPropertyRequiredRightAnalyzer.java",
        "method_name": "analyzeWikiContent",
        "raw_code": "private List<RequiredRightAnalysisResult> analyzeWikiContent(BaseObject object, String value,\n        EntityReference reference)\n        throws RequiredRightsException\n    {\n        try {\n            XDOM parsedContent = this.contentParser.parse(value, object.getOwnerDocument().getSyntax(),\n                object.getDocumentReference());\n            parsedContent.getMetaData().addMetaData(XDOMRequiredRightAnalyzer.ENTITY_REFERENCE_METADATA, reference);\n            return this.xdomRequiredRightAnalyzer.analyze(parsedContent);\n        } catch (ParseException | MissingParserException e) {\n            throw new RequiredRightsException(\"Failed to parse content of object property\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ObjectPropertyRequiredRightAnalyzer.java",
        "method_name": "analyzeWikiContent",
        "raw_code": "public List<RequiredRightAnalysisResult> analyzeWikiContent(BaseObject object, String value,\n        EntityReference reference)\n        throws RequiredRightsException\n    {\n        try {\n            XDOM parsedContent = this.contentParser.parse(value, object.getOwnerDocument().getSyntax(),\n                object.getDocumentReference());\n            parsedContent.getMetaData().addMetaData(XDOMRequiredRightAnalyzer.ENTITY_REFERENCE_METADATA, reference);\n            return this.xdomRequiredRightAnalyzer.analyze(parsedContent);\n        } catch (ParseException | MissingParserException e) {\n            throw new RequiredRightsException(\"Failed to parse content of object property\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49581",
    "cwe_list": [
      "CWE-270"
    ],
    "commit_hash": "c99d501ed41cbee6a3c02ff927714531570789de",
    "short_hash": "c99d501e",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseWiki",
        "raw_code": "private XDOM parseWiki(String macroContent, boolean inline) throws RenderingException\n    {\n        try {\n            return this.contentParser.parse(macroContent, this.syncContext, false, inline);\n        } catch (MacroExecutionException e) {\n            throw new RenderingException(\"Failed to parse the passed content\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseWiki",
        "raw_code": "private XDOM parseWiki(String macroContent, Syntax syntax, boolean transform, boolean inline)\n        throws RenderingException\n    {\n        try {\n            return this.contentParser.parse(macroContent, syntax, this.syncContext, transform, null, inline);\n        } catch (MacroExecutionException e) {\n            throw new RenderingException(\"Failed to parse the passed content\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49581",
    "cwe_list": [
      "CWE-270"
    ],
    "commit_hash": "c99d501ed41cbee6a3c02ff927714531570789de",
    "short_hash": "c99d501e",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseContent",
        "raw_code": "private XDOM parseContent(String macroContent, boolean inline) throws RenderingException\n    {\n        ContentDescriptor contentDescriptor = this.wikimacro.getDescriptor().getContentDescriptor();\n        if (contentDescriptor == null || !contentDescriptor.getType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroContent));\n            } catch (ParseException e) {\n                throw new RenderingException(\"Error while parsing the macro content in plain text.\", e);\n            }\n        } else {\n            return parseWiki(macroContent, inline);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseContent",
        "raw_code": "private XDOM parseContent(String macroContent, boolean inline) throws RenderingException\n    {\n        ContentDescriptor contentDescriptor = this.wikimacro.getDescriptor().getContentDescriptor();\n        if (contentDescriptor == null || !contentDescriptor.getType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroContent));\n            } catch (ParseException e) {\n                throw new RenderingException(\"Error while parsing the macro content in plain text.\", e);\n            }\n        } else {\n            return parseWiki(macroContent, null, false, inline);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49581",
    "cwe_list": [
      "CWE-270"
    ],
    "commit_hash": "c99d501ed41cbee6a3c02ff927714531570789de",
    "short_hash": "c99d501e",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseParameterValue",
        "raw_code": "private XDOM parseParameterValue(String macroParameterContent, String macroParameterName, boolean inline)\n        throws MacroExecutionException, RenderingException\n    {\n        MacroDescriptor macroDescriptor = this.wikimacro.getDescriptor();\n        ParameterDescriptor parameterDescriptor = null;\n        if (macroDescriptor != null) {\n            parameterDescriptor = macroDescriptor.getParameterDescriptorMap().get(macroParameterName);\n        }\n\n        if (parameterDescriptor == null || !parameterDescriptor.getParameterType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroParameterContent));\n            } catch (ParseException e) {\n                throw new MacroExecutionException(\"Error while parsing the macro parameter content in plain.\", e);\n            }\n        } else {\n            return parseWiki(macroParameterContent, inline);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseParameterValue",
        "raw_code": "private XDOM parseParameterValue(String macroParameterContent, String macroParameterName, boolean inline)\n        throws MacroExecutionException, RenderingException\n    {\n        MacroDescriptor macroDescriptor = this.wikimacro.getDescriptor();\n        ParameterDescriptor parameterDescriptor = null;\n        if (macroDescriptor != null) {\n            parameterDescriptor = macroDescriptor.getParameterDescriptorMap().get(macroParameterName);\n        }\n\n        if (parameterDescriptor == null || !parameterDescriptor.getParameterType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroParameterContent));\n            } catch (ParseException e) {\n                throw new MacroExecutionException(\"Error while parsing the macro parameter content in plain.\", e);\n            }\n        } else {\n            boolean executeWithMacroAuthor =\n                Objects.equals(macroParameterContent, parameterDescriptor.getDefaultValue());\n            if (executeWithMacroAuthor) {\n                return parseWiki(macroParameterContent, this.wikimacro.getSourceSyntax(), true, inline);\n            } else {\n                return parseWiki(macroParameterContent, null, false, inline);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "cc74dc802efe0e2d3fa2ba3355dbadc51c5fd8c7",
    "short_hash": "cc74dc80",
    "vulnerableMethods_before": [
      {
        "filename": "ContextMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        ContextMacroParameters parameters = new ContextMacroParameters();\n\n        try {\n            this.beanManager.populate(parameters, macroBlock.getParameters());\n\n            // Analyze the content only when it isn't restricted.\n            if (!parameters.isRestricted()) {\n                reporter.analyzeContent(macroBlock, macroBlock.getContent());\n            }\n        } catch (PropertyException e) {\n            // Ignore, the macro won't be executed when populating the parameters fails.\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ContextMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        ContextMacroParameters parameters = new ContextMacroParameters();\n\n        try {\n            this.beanManager.populate(parameters, macroBlock.getParameters());\n\n            // If the source parameter is set, the content is ignored, and we should analyze the source parameter\n            // instead.\n            if (parameters.getSource() != null) {\n                String sourceType = parameters.getSource().getType();\n\n                switch (sourceType) {\n                    case MacroContentSourceReference.TYPE_STRING:\n                        if (!parameters.isRestricted()) {\n                            reporter.analyzeContent(macroBlock, parameters.getSource().getReference());\n                        }\n                        break;\n\n                    case MacroContentSourceReference.TYPE_SCRIPT:\n                        if (parameters.isRestricted()) {\n                            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                                \"rendering.macro.context.requiredRights.restrictedScriptSource\");\n                        } else {\n                            // We don't know the actual content, but at least script right is needed and the content\n                            // could contain anything, so it might require programming right.\n                            reporter.report(macroBlock,\n                                List.of(MacroRequiredRight.SCRIPT, MacroRequiredRight.MAYBE_PROGRAM),\n                                \"rendering.macro.context.requiredRights.arbitraryScriptSource\");\n                        }\n                        break;\n\n                    default:\n                        // Do nothing.\n                }\n            } else if (!parameters.isRestricted()) {\n                reporter.analyzeContent(macroBlock, macroBlock.getContent());\n            }\n        } catch (PropertyException e) {\n            // Ignore, the macro won't be executed when populating the parameters fails.\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "CacheMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@Test\n    void analyze()\n    {\n        MacroBlock macroBlock = mock();\n        String idValue = \"idValue\";\n        String contentValue = \"contentValue\";\n        when(macroBlock.getParameter(\"id\")).thenReturn(idValue);\n        when(macroBlock.getContent()).thenReturn(contentValue);\n        MacroRequiredRightReporter reporter = mock();\n\n        this.analyzer.analyze(macroBlock, reporter);\n\n        verify(reporter).analyzeContent(macroBlock, idValue);\n        verify(reporter).analyzeContent(macroBlock, contentValue);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CacheMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"idValuesProvider\")\n    void analyze(String parameterName)\n    {\n        String idValue = \"idValue\";\n        String contentValue = \"contentValue\";\n        MacroBlock macroBlock = new MacroBlock(\"cache\", Map.of(parameterName, idValue), contentValue, false);\n        MacroRequiredRightReporter reporter = mock();\n\n        this.analyzer.analyze(macroBlock, reporter);\n\n        verify(reporter).analyzeContent(macroBlock, idValue);\n        verify(reporter).analyzeContent(macroBlock, contentValue);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "HTMLMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        boolean wiki = Boolean.TRUE.equals(this.converter.convert(Boolean.class, macroBlock.getParameter(\"wiki\")));\n        String cleanParameter = macroBlock.getParameter(\"clean\");\n        // Cleaning is enabled by default.\n        boolean clean =\n            cleanParameter == null || Boolean.TRUE.equals(this.converter.convert(Boolean.class, cleanParameter));\n\n        if (wiki) {\n            reporter.analyzeContent(macroBlock, macroBlock.getContent());\n        }\n\n        if (!clean) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                TRANSLATION_PREFIX + \"noClean\");\n        } else if (wiki) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.MAYBE_SCRIPT),\n                TRANSLATION_PREFIX + \"wikiContent\");\n        } else {\n            HTMLCleanerConfiguration cleanerConfiguration = this.htmlCleaner.getDefaultConfiguration();\n            Map<String, String> parameters = new HashMap<>(cleanerConfiguration.getParameters());\n            // Assume HTML 5 as there is no real way to determine the target version of the rendering action. Also,\n            // the analysis shouldn't really be affected by the HTML version.\n            parameters.put(HTMLCleanerConfiguration.HTML_VERSION, \"5\");\n            cleanerConfiguration.setParameters(parameters);\n\n            // Add the filter for detecting content that would be filtered by restricted mode.\n            List<HTMLFilter> filters = new ArrayList<>(cleanerConfiguration.getFilters());\n            filters.add(this.restrictedFilterDetector);\n            cleanerConfiguration.setFilters(filters);\n\n            Document document = this.htmlCleaner.clean(new StringReader(macroBlock.getContent()), cleanerConfiguration);\n            if (Boolean.parseBoolean(document.getDocumentElement()\n                .getAttribute(SanitizerDetectorFilter.ATTRIBUTE_FILTERED)))\n            {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    TRANSLATION_PREFIX + \"dangerousContent\");\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HTMLMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        boolean wiki = getBooleanParameterValues(macroBlock, \"wiki\").anyMatch(Boolean.TRUE::equals);\n\n        // Cleaning is enabled by default.\n        boolean clean = getBooleanParameterValues(macroBlock, \"clean\").noneMatch(Boolean.FALSE::equals);\n\n        if (wiki) {\n            reporter.analyzeContent(macroBlock, macroBlock.getContent());\n        }\n\n        if (!clean) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                TRANSLATION_PREFIX + \"noClean\");\n        } else if (wiki) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.MAYBE_SCRIPT),\n                TRANSLATION_PREFIX + \"wikiContent\");\n        } else {\n            HTMLCleanerConfiguration cleanerConfiguration = this.htmlCleaner.getDefaultConfiguration();\n            Map<String, String> parameters = new HashMap<>(cleanerConfiguration.getParameters());\n            // Assume HTML 5 as there is no real way to determine the target version of the rendering action. Also,\n            // the analysis shouldn't really be affected by the HTML version.\n            parameters.put(HTMLCleanerConfiguration.HTML_VERSION, \"5\");\n            cleanerConfiguration.setParameters(parameters);\n\n            // Add the filter for detecting content that would be filtered by restricted mode.\n            List<HTMLFilter> filters = new ArrayList<>(cleanerConfiguration.getFilters());\n            filters.add(this.restrictedFilterDetector);\n            cleanerConfiguration.setFilters(filters);\n\n            Document document = this.htmlCleaner.clean(new StringReader(macroBlock.getContent()), cleanerConfiguration);\n            if (Boolean.parseBoolean(document.getDocumentElement()\n                .getAttribute(SanitizerDetectorFilter.ATTRIBUTE_FILTERED)))\n            {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    TRANSLATION_PREFIX + \"dangerousContent\");\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "RawMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyzeTestCases",
        "raw_code": "private static Stream<Arguments> analyzeTestCases()\n    {\n        return Stream.of(\n            Arguments.of(\"plain\", Syntax.PLAIN_1_0, null),\n            Arguments.of(\"html\", Syntax.HTML_5_0, MacroRequiredRight.SCRIPT)\n        );\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RawMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyzeTestCases",
        "raw_code": "private static Stream<Arguments> analyzeTestCases()\n    {\n        return Stream.of(\n            Arguments.of(Map.of(SYNTAX_PARAMETER, PLAIN_VALUE), null),\n            Arguments.of(Map.of(SYNTAX_PARAMETER, HTML_VALUE), MacroRequiredRight.SCRIPT),\n            Arguments.of(Map.of(\"sYnTaX\", HTML_VALUE), MacroRequiredRight.SCRIPT),\n            Arguments.of(Map.of(\"sYntax\", HTML_VALUE, SYNTAX_PARAMETER, PLAIN_VALUE), MacroRequiredRight.SCRIPT),\n            Arguments.of(Map.of(\"Syntax\", PLAIN_VALUE, \"SYNTAX\", HTML_VALUE), MacroRequiredRight.SCRIPT),\n            Arguments.of(Map.of(\"syntaX\", PLAIN_VALUE), null)\n        );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "RawMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"analyzeTestCases\")\n    void analyze(String syntaxValue, Syntax expectedSyntax, MacroRequiredRight expectedRight) throws ParseException\n    {\n        when(this.syntaxRegistry.resolveSyntax(syntaxValue)).thenReturn(expectedSyntax);\n\n        MacroBlock macroBlock = mock();\n        when(macroBlock.getParameter(SYNTAX_PARAMETER)).thenReturn(syntaxValue);\n\n        MacroRequiredRightReporter reporter = mock();\n        this.analyzer.analyze(macroBlock, reporter);\n\n        verify(this.syntaxRegistry).resolveSyntax(syntaxValue);\n        if (expectedRight != null) {\n            verify(reporter).report(macroBlock, List.of(expectedRight), \"rendering.macro.rawMacroRequiredRights\");\n        } else {\n            verifyNoInteractions(reporter);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RawMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"analyzeTestCases\")\n    void analyze(Map<String, String> parameters, MacroRequiredRight expectedRight)\n    {\n        MacroBlock macroBlock = new MacroBlock(\"raw\", parameters, false);\n\n        MacroRequiredRightReporter reporter = mock();\n        this.analyzer.analyze(macroBlock, reporter);\n\n        if (expectedRight != null) {\n            verify(reporter).report(macroBlock, List.of(expectedRight), \"rendering.macro.rawMacroRequiredRights\");\n        } else {\n            verifyNoInteractions(reporter);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "RawMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        try {\n            SyntaxType syntax = this.syntaxRegistry.resolveSyntax(macroBlock.getParameter(\"syntax\")).getType();\n            if (SyntaxType.HTML_FAMILY_TYPES.contains(syntax)) {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    \"rendering.macro.rawMacroRequiredRights\");\n            }\n        } catch (ParseException e) {\n            // Ignore, this should fail the macro or at least won't produce HTML output.\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RawMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        // Check if any parameter that is equal to \"syntax\" ignoring case is an HTML syntax.\n        boolean isHTML = macroBlock.getParameters().entrySet().stream()\n            .filter(entry -> \"syntax\".equalsIgnoreCase(entry.getKey()))\n            .anyMatch(entry -> isHTMLSyntax(entry.getValue()));\n\n        if (isHTML) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT), \"rendering.macro.rawMacroRequiredRights\");\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "CacheMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        reporter.analyzeContent(macroBlock, macroBlock.getParameter(\"id\"));\n        reporter.analyzeContent(macroBlock, macroBlock.getContent());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CacheMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        macroBlock.getParameters().entrySet().stream()\n            .filter(entry -> \"id\".equalsIgnoreCase(entry.getKey()))\n            .forEach(entry -> reporter.analyzeContent(macroBlock, entry.getValue()));\n\n        reporter.analyzeContent(macroBlock, macroBlock.getContent());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractDocumentListClassPropertyValuesProvider.java",
        "method_name": "getValue",
        "raw_code": "@Override\n    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)\n        throws XWikiRestException\n    {\n\n        String reference = \"\";\n        if (rawValue != null) {\n            reference = rawValue.toString();\n        }\n        if (StringUtils.isEmpty(reference)) {\n            return null;\n        }\n\n        DocumentReference documentReference = this.documentReferenceResolver.resolve(reference, propertyReference);\n\n        PropertyValue propertyValue = null;\n        if (exists(documentReference)) {\n            propertyValue = super.getValue(propertyReference, documentReference);\n        }\n\n        if (propertyValue == null) {\n            propertyValue = new PropertyValue();\n        }\n\n        propertyValue.setValue(reference);\n\n        return propertyValue;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractDocumentListClassPropertyValuesProvider.java",
        "method_name": "getValue",
        "raw_code": "@Override\n    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)\n        throws XWikiRestException\n    {\n\n        String reference = \"\";\n        if (rawValue != null) {\n            reference = rawValue.toString();\n        }\n        if (StringUtils.isEmpty(reference)) {\n            return null;\n        }\n\n        DocumentReference documentReference = this.documentReferenceResolver.resolve(reference, propertyReference);\n\n        PropertyValue propertyValue = null;\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, documentReference) && exists(documentReference)) {\n            propertyValue = super.getValue(propertyReference, documentReference);\n        }\n\n        if (propertyValue == null) {\n            propertyValue = new PropertyValue();\n        }\n\n        propertyValue.setValue(reference);\n\n        return propertyValue;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractListClassPropertyValuesProviderTest.java",
        "method_name": "configure",
        "raw_code": "public void configure() throws Exception\n    {\n        Provider<XWikiContext> xcontextProvider = this.componentManager.getInstance(XWikiContext.TYPE_PROVIDER);\n        BaseClass xclass = mock(BaseClass.class);\n        DocumentReference authorReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n\n        when(xcontextProvider.get()).thenReturn(this.xcontext);\n        when(this.xcontext.getWiki()).thenReturn(this.xwiki);\n        when(this.classDocument.getXClass()).thenReturn(xclass);\n        when(this.classDocument.getDocumentReference()).thenReturn(this.classReference);\n        when(this.classDocument.getAuthorReference()).thenReturn(authorReference);\n\n        QueryParameter queryParameter = mock(QueryParameter.class);\n        when(this.allowedValuesQuery.bindValue(\"text\")).thenReturn(queryParameter);\n        when(this.usedValuesQuery.bindValue(\"text\")).thenReturn(queryParameter);\n        when(queryParameter.anyChars()).thenReturn(queryParameter);\n        when(queryParameter.literal(\"foo\")).thenReturn(queryParameter);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractListClassPropertyValuesProviderTest.java",
        "method_name": "configure",
        "raw_code": "public void configure() throws Exception\n    {\n        Provider<XWikiContext> xcontextProvider = this.componentManager.getInstance(XWikiContext.TYPE_PROVIDER);\n        BaseClass xclass = mock(BaseClass.class);\n        DocumentReference authorReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n\n        when(xcontextProvider.get()).thenReturn(this.xcontext);\n        when(this.readonlyXWikiContextProvider.get()).thenReturn(this.xcontext);\n        when(this.xcontext.getWiki()).thenReturn(this.xwiki);\n        when(this.classDocument.getXClass()).thenReturn(xclass);\n        when(this.classDocument.getDocumentReference()).thenReturn(this.classReference);\n        when(this.classDocument.getAuthorReference()).thenReturn(authorReference);\n\n        QueryParameter queryParameter = mock(QueryParameter.class);\n        when(this.allowedValuesQuery.bindValue(\"text\")).thenReturn(queryParameter);\n        when(this.usedValuesQuery.bindValue(\"text\")).thenReturn(queryParameter);\n        when(queryParameter.anyChars()).thenReturn(queryParameter);\n        when(queryParameter.literal(\"foo\")).thenReturn(queryParameter);\n\n        when(this.iconManager.getMetaData(anyString())).thenAnswer(i -> mock(Map.class, i.<String>getArgument(0)));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "UsersClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocal",
        "raw_code": "@Test\n    public void getValuesLocal() throws Exception\n    {\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.LOCAL_ONLY);\n\n        DocumentReference aliceReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n        when(this.allowedValuesQuery.execute())\n            .thenReturn(Collections.singletonList(new Object[]{ aliceReference, \" Alice One \" }));\n        when(this.xcontext.getWiki().getDocument(aliceReference, this.xcontext))\n            .thenReturn(mock(XWikiDocument.class, \"alice\"));\n\n        QueryFilter documentFilter = this.componentManager.getInstance(QueryFilter.class, \"document\");\n        QueryFilter viewableFilter = this.componentManager.getInstance(QueryFilter.class, \"viewable\");\n        List<QueryFilter> filters = mock(List.class);\n        DocumentReference bobReference = new DocumentReference(\"wiki\", \"Users\", \"Bob\");\n        when(this.usedValuesQuery.getFilters()).thenReturn(filters);\n        when(this.usedValuesQuery.execute())\n            .thenReturn(Arrays.asList(new Object[]{ bobReference, 17L }, new Object[]{ aliceReference, 3L }));\n\n        EntityReferenceSerializer<String> compactSerializer =\n            this.componentManager.getInstance(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n        when(compactSerializer.serialize(aliceReference, this.classReference.getWikiReference()))\n            .thenReturn(\"Users.Alice\");\n        when(compactSerializer.serialize(bobReference, this.classReference.getWikiReference())).thenReturn(\"Users.Bob\");\n\n        when(this.xcontext.getWiki().getPlainUserName(bobReference, this.xcontext)).thenReturn(\"Bob the Great\");\n\n        when(this.xcontext.getWiki().getURL(aliceReference, this.xcontext)).thenReturn(\"url/to/alice\");\n        when(this.xcontext.getWiki().getURL(bobReference, this.xcontext)).thenReturn(\"url/to/bob\");\n\n        XWikiDocument bobProfile = mock(XWikiDocument.class);\n        XWikiAttachment bobAvatar = mock(XWikiAttachment.class);\n        AttachmentReference bobAvatarReference = new AttachmentReference(\"somePhoto.png\", bobReference);\n        when(this.xcontext.getWiki().getDocument(bobReference, this.xcontext)).thenReturn(bobProfile);\n        when(bobProfile.getStringValue(\"avatar\")).thenReturn(bobAvatarReference.getName());\n        when(bobProfile.getAttachment(\"somePhoto.png\")).thenReturn(bobAvatar);\n        when(bobAvatar.isImage(this.xcontext)).thenReturn(true);\n        when(bobAvatar.getReference()).thenReturn(bobAvatarReference);\n        when(this.xcontext.getWiki().getURL(bobAvatarReference, \"download\", \"width=30&height=30&keepAspectRatio=true\",\n            null, this.xcontext)).thenReturn(\"url/to/bob/avatar\");\n\n        PropertyValues values = this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        assertEquals(2, values.getPropertyValues().size());\n\n        assertEquals(\"Users.Alice\", values.getPropertyValues().get(0).getValue());\n        assertEquals(\"Alice One\", values.getPropertyValues().get(0).getMetaData().get(\"label\"));\n        assertEquals(3L, values.getPropertyValues().get(0).getMetaData().get(\"count\"));\n        assertTrue(values.getPropertyValues().get(0).getMetaData().get(\"icon\") instanceof Map);\n        assertEquals(\"url/to/alice\", values.getPropertyValues().get(0).getMetaData().get(\"url\"));\n\n        assertEquals(\"Users.Bob\", values.getPropertyValues().get(1).getValue());\n        assertEquals(\"Bob the Great\", values.getPropertyValues().get(1).getMetaData().get(\"label\"));\n        assertEquals(17L, values.getPropertyValues().get(1).getMetaData().get(\"count\"));\n        assertTrue(values.getPropertyValues().get(1).getMetaData().get(\"icon\") instanceof Map);\n        Map icon = (Map) values.getPropertyValues().get(1).getMetaData().get(\"icon\");\n        assertEquals(\"url/to/bob/avatar\", icon.get(\"url\"));\n        assertEquals(\"IMAGE\", icon.get(\"iconSetType\"));\n        assertEquals(\"url/to/bob\", values.getPropertyValues().get(1).getMetaData().get(\"url\"));\n\n        verify(this.allowedValuesQuery, never()).setWiki(any(String.class));\n        verify(this.allowedValuesQuery, times(1)).execute();\n\n        verify(filters).clear();\n        verify(this.usedValuesQuery).addFilter(documentFilter);\n        verify(this.usedValuesQuery).addFilter(viewableFilter);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocal",
        "raw_code": "@ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void getValuesLocal(boolean hasAccess) throws Exception\n    {\n        when(this.authorizationManager.hasAccess(any(), any())).thenReturn(hasAccess);\n\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.LOCAL_ONLY);\n\n        DocumentReference aliceReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n        when(this.allowedValuesQuery.execute())\n            .thenReturn(Collections.singletonList(new Object[] { aliceReference, \" Alice One \" }));\n        when(this.xcontext.getWiki().getDocument(aliceReference, this.xcontext))\n            .thenReturn(mock(XWikiDocument.class, \"alice\"));\n\n        QueryFilter documentFilter = this.componentManager.getInstance(QueryFilter.class, \"document\");\n        QueryFilter viewableFilter = this.componentManager.getInstance(QueryFilter.class, \"viewable\");\n        List<QueryFilter> filters = mock(List.class);\n        DocumentReference bobReference = new DocumentReference(\"wiki\", \"Users\", \"Bob\");\n        when(this.usedValuesQuery.getFilters()).thenReturn(filters);\n        when(this.usedValuesQuery.execute())\n            .thenReturn(Arrays.asList(new Object[] { bobReference, 17L }, new Object[] { aliceReference, 3L }));\n\n        EntityReferenceSerializer<String> compactSerializer =\n            this.componentManager.getInstance(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n        when(compactSerializer.serialize(aliceReference, this.classReference.getWikiReference()))\n            .thenReturn(\"Users.Alice\");\n        when(compactSerializer.serialize(bobReference, this.classReference.getWikiReference())).thenReturn(\"Users.Bob\");\n\n        when(this.xcontext.getWiki().getPlainUserName(bobReference, this.xcontext)).thenReturn(\"Bob the Great\");\n\n        when(this.xcontext.getWiki().getURL(aliceReference, this.xcontext)).thenReturn(\"url/to/alice\");\n        when(this.xcontext.getWiki().getURL(bobReference, this.xcontext)).thenReturn(\"url/to/bob\");\n\n        XWikiDocument bobProfile = mock(XWikiDocument.class);\n        XWikiAttachment bobAvatar = mock(XWikiAttachment.class);\n        AttachmentReference bobAvatarReference = new AttachmentReference(\"somePhoto.png\", bobReference);\n        when(this.xcontext.getWiki().getDocument(bobReference, this.xcontext)).thenReturn(bobProfile);\n        when(bobProfile.getStringValue(\"avatar\")).thenReturn(bobAvatarReference.getName());\n        when(bobProfile.getAttachment(\"somePhoto.png\")).thenReturn(bobAvatar);\n        when(bobAvatar.isImage(this.xcontext)).thenReturn(true);\n        when(bobAvatar.getReference()).thenReturn(bobAvatarReference);\n        when(this.xcontext.getWiki().getURL(bobAvatarReference, \"download\", \"width=30&height=30&keepAspectRatio=true\",\n            null, this.xcontext)).thenReturn(\"url/to/bob/avatar\");\n\n        PropertyValues values = this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        assertEquals(2, values.getPropertyValues().size());\n\n        assertEquals(\"Users.Alice\", values.getPropertyValues().get(0).getValue());\n        assertEquals(\"Alice One\", values.getPropertyValues().get(0).getMetaData().get(\"label\"));\n        assertEquals(3L, values.getPropertyValues().get(0).getMetaData().get(\"count\"));\n        assertTrue(values.getPropertyValues().get(0).getMetaData().get(\"icon\") instanceof Map);\n        assertEquals(\"url/to/alice\", values.getPropertyValues().get(0).getMetaData().get(\"url\"));\n\n        assertEquals(\"Users.Bob\", values.getPropertyValues().get(1).getValue());\n        assertEquals(\"Bob the Great\", values.getPropertyValues().get(1).getMetaData().get(\"label\"));\n        assertEquals(17L, values.getPropertyValues().get(1).getMetaData().get(\"count\"));\n        assertTrue(values.getPropertyValues().get(1).getMetaData().get(\"icon\") instanceof Map);\n        Map icon = (Map) values.getPropertyValues().get(1).getMetaData().get(\"icon\");\n        if (hasAccess) {\n            assertEquals(\"url/to/bob/avatar\", icon.get(\"url\"));\n            assertEquals(\"IMAGE\", icon.get(\"iconSetType\"));\n        } else {\n            assertEquals(\"user\", mockingDetails(icon).getMockCreationSettings().getMockName().toString());\n        }\n        assertEquals(\"url/to/bob\", values.getPropertyValues().get(1).getMetaData().get(\"url\"));\n\n        verify(this.allowedValuesQuery, never()).setWiki(any(String.class));\n        verify(this.allowedValuesQuery, times(1)).execute();\n\n        verify(filters).clear();\n        verify(this.usedValuesQuery).addFilter(documentFilter);\n        verify(this.usedValuesQuery).addFilter(viewableFilter);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "UsersClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference userReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        try {\n            XWikiDocument userProfileDocument = xcontext.getWiki().getDocument(userReference, xcontext);\n            String avatar = userProfileDocument.getStringValue(\"avatar\");\n            XWikiAttachment avatarAttachment = userProfileDocument.getAttachment(avatar);\n            if (avatarAttachment != null && avatarAttachment.isImage(xcontext)) {\n                icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                    \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n            }\n        } catch (XWikiException e) {\n            this.logger.warn(\n                \"Failed to read the avatar of user [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                userReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n        }\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference userReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, userReference)) {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            try {\n                XWikiDocument userProfileDocument = xcontext.getWiki().getDocument(userReference, xcontext);\n                String avatar = userProfileDocument.getStringValue(\"avatar\");\n                XWikiAttachment avatarAttachment = userProfileDocument.getAttachment(avatar);\n                if (avatarAttachment != null && avatarAttachment.isImage(xcontext)) {\n                    icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                        \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                    icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n                }\n            } catch (XWikiException e) {\n                this.logger.warn(\n                    \"Failed to read the avatar of user [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                    userReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocal",
        "raw_code": "@Test\n    public void getValuesLocal() throws Exception\n    {\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.LOCAL_ONLY);\n\n        DocumentReference devsReference = new DocumentReference(\"wiki\", \"Groups\", \"Devs\");\n        XWikiDocument devsProfile = mock(XWikiDocument.class, \"devs\");\n        when(this.xcontext.getWiki().getDocument(devsReference, this.xcontext)).thenReturn(devsProfile);\n        when(devsProfile.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Developers\");\n\n        DocumentReference adminsReference = new DocumentReference(\"wiki\", \"Groups\", \"Admins\");\n        XWikiDocument adminsProfile = mock(XWikiDocument.class, \"admins\");\n        XWikiAttachment notAnImageAttachment = mock(XWikiAttachment.class, \"noAnImage\");\n        XWikiAttachment imageAttachment = mock(XWikiAttachment.class, \"image\");\n        AttachmentReference imageAttachmentReference = new AttachmentReference(\"admins.png\", adminsReference);\n        when(this.xcontext.getWiki().getDocument(adminsReference, this.xcontext)).thenReturn(adminsProfile);\n        when(adminsProfile.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Administrators\");\n        when(adminsProfile.getAttachmentList()).thenReturn(Arrays.asList(notAnImageAttachment, imageAttachment));\n        when(imageAttachment.isImage(this.xcontext)).thenReturn(true);\n        when(imageAttachment.getReference()).thenReturn(imageAttachmentReference);\n        when(this.xcontext.getWiki().getURL(imageAttachmentReference, \"download\",\n            \"width=30&height=30&keepAspectRatio=true\", null, this.xcontext)).thenReturn(\"url/to/admins/image\");\n\n        when(this.allowedValuesQuery.execute()).thenReturn(Arrays.asList(devsReference, adminsReference));\n\n        PropertyValues values = this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        assertEquals(2, values.getPropertyValues().size());\n\n        assertEquals(\"Developers\", values.getPropertyValues().get(0).getMetaData().get(\"label\"));\n        assertTrue(values.getPropertyValues().get(0).getMetaData().get(\"icon\") instanceof Map);\n\n        assertEquals(\"Administrators\", values.getPropertyValues().get(1).getMetaData().get(\"label\"));\n        assertTrue(values.getPropertyValues().get(1).getMetaData().get(\"icon\") instanceof Map);\n        Map icon = (Map) values.getPropertyValues().get(1).getMetaData().get(\"icon\");\n        assertEquals(\"url/to/admins/image\", icon.get(\"url\"));\n        assertEquals(\"IMAGE\", icon.get(\"iconSetType\"));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocal",
        "raw_code": "@ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void getValuesLocal(boolean hasAccess) throws Exception\n    {\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.LOCAL_ONLY);\n        when(this.authorizationManager.hasAccess(any(), any())).thenReturn(hasAccess);\n\n        DocumentReference devsReference = new DocumentReference(\"wiki\", \"Groups\", \"Devs\");\n        XWikiDocument devsProfile = mock(XWikiDocument.class, \"devs\");\n        when(this.xcontext.getWiki().getDocument(devsReference, this.xcontext)).thenReturn(devsProfile);\n        when(devsProfile.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Developers\");\n\n        DocumentReference adminsReference = new DocumentReference(\"wiki\", \"Groups\", \"Admins\");\n        XWikiDocument adminsProfile = mock(XWikiDocument.class, \"admins\");\n        XWikiAttachment notAnImageAttachment = mock(XWikiAttachment.class, \"noAnImage\");\n        XWikiAttachment imageAttachment = mock(XWikiAttachment.class, \"image\");\n        AttachmentReference imageAttachmentReference = new AttachmentReference(\"admins.png\", adminsReference);\n        when(this.xcontext.getWiki().getDocument(adminsReference, this.xcontext)).thenReturn(adminsProfile);\n        when(adminsProfile.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Administrators\");\n        when(adminsProfile.getAttachmentList()).thenReturn(Arrays.asList(notAnImageAttachment, imageAttachment));\n        when(imageAttachment.isImage(this.xcontext)).thenReturn(true);\n        when(imageAttachment.getReference()).thenReturn(imageAttachmentReference);\n        when(this.xcontext.getWiki().getURL(imageAttachmentReference, \"download\",\n            \"width=30&height=30&keepAspectRatio=true\", null, this.xcontext)).thenReturn(\"url/to/admins/image\");\n\n        when(this.allowedValuesQuery.execute()).thenReturn(Arrays.asList(devsReference, adminsReference));\n\n        PropertyValues values = this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        assertEquals(2, values.getPropertyValues().size());\n\n        Object devsLabel = values.getPropertyValues().get(0).getMetaData().get(\"label\");\n        if (hasAccess) {\n            assertEquals(\"Developers\", devsLabel);\n        } else {\n            assertEquals(\"Devs\", devsLabel);\n        }\n        assertInstanceOf(Map.class, values.getPropertyValues().get(0).getMetaData().get(\"icon\"));\n\n        Object adminLabel = values.getPropertyValues().get(1).getMetaData().get(\"label\");\n        if (hasAccess) {\n            assertEquals(\"Administrators\", adminLabel);\n        } else {\n            assertEquals(\"Admins\", adminLabel);\n        }\n        assertInstanceOf(Map.class, values.getPropertyValues().get(1).getMetaData().get(\"icon\"));\n        Map icon = (Map) values.getPropertyValues().get(1).getMetaData().get(\"icon\");\n        if (hasAccess) {\n            assertEquals(\"url/to/admins/image\", icon.get(\"url\"));\n            assertEquals(\"IMAGE\", icon.get(\"iconSetType\"));\n        } else {\n            assertEquals(\"group\", mockingDetails(icon).getMockCreationSettings().getMockName().toString());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocalAndGlobal",
        "raw_code": "@Test\n    public void getValuesLocalAndGlobal() throws Exception\n    {\n        // We can have local groups.\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.GLOBAL_ONLY);\n\n        WikiDescriptorManager wikiDescriptorManager = this.componentManager.getInstance(WikiDescriptorManager.class);\n        when(wikiDescriptorManager.getMainWikiId()).thenReturn(\"chess\");\n\n        this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        verify(this.allowedValuesQuery).setWiki(\"chess\");\n        verify(this.allowedValuesQuery, times(2)).execute();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocalAndGlobal",
        "raw_code": "@Test\n    void getValuesLocalAndGlobal() throws Exception\n    {\n        // We can have local groups.\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.GLOBAL_ONLY);\n\n        WikiDescriptorManager wikiDescriptorManager = this.componentManager.getInstance(WikiDescriptorManager.class);\n        when(wikiDescriptorManager.getMainWikiId()).thenReturn(\"chess\");\n\n        this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        verify(this.allowedValuesQuery).setWiki(\"chess\");\n        verify(this.allowedValuesQuery, times(2)).execute();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        try {\n            XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n            XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n            if (avatarAttachment != null) {\n                icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                    \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n            }\n        } catch (XWikiException e) {\n            this.logger.warn(\n                \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n        }\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n                XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n                if (avatarAttachment != null) {\n                    icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                        \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                    icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n                }\n            } catch (XWikiException e) {\n                this.logger.warn(\n                    \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                    groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        try {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                xcontext);\n        } catch (XWikiException e) {\n            this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            return super.getLabel(groupReference, currentLabel);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiContext xcontext = this.xcontextProvider.get();\n                return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                    xcontext);\n            } catch (XWikiException e) {\n                this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                    this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return super.getLabel(groupReference, currentLabel);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "configure",
        "raw_code": "@BeforeEach\n    public void configure() throws Exception\n    {\n        super.configure();\n\n        when(this.pageClass.getOwnerDocument()).thenReturn(this.classDocument);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "configure",
        "raw_code": "@Override\n    @BeforeEach\n    public void configure() throws Exception\n    {\n        super.configure();\n\n        when(this.pageClass.getOwnerDocument()).thenReturn(this.classDocument);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "getValues",
        "raw_code": "@Test\n    public void getValues() throws Exception\n    {\n        WikiReference wikiRef = new WikiReference(\"wiki\");\n        SpaceReference space1Ref = new SpaceReference(\"space1\", wikiRef);\n        SpaceReference space2Ref = new SpaceReference(\"space2\", space1Ref);\n        EntityReference pageRef = new DocumentReference(\"page\", space2Ref);\n\n        XWikiDocument space1Doc = mock(XWikiDocument.class);\n        XWikiDocument space2Doc = mock(XWikiDocument.class);\n        XWikiDocument pageDoc = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(space1Ref, this.xcontext)).thenReturn(space1Doc);\n        when(this.xwiki.getDocument(space2Ref, this.xcontext)).thenReturn(space2Doc);\n        when(this.xwiki.getDocument(pageRef, this.xcontext)).thenReturn(pageDoc);\n        when(space1Doc.getTranslatedDocument(this.xcontext)).thenReturn(space1Doc);\n        when(space2Doc.getTranslatedDocument(this.xcontext)).thenReturn(space2Doc);\n        when(pageDoc.getTranslatedDocument(this.xcontext)).thenReturn(pageDoc);\n        when(space1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 1\");\n        when(space2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 2\");\n        when(pageDoc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page\");\n\n        Query query = mock(Query.class);\n        when(query.execute()).thenReturn(Collections.singletonList(pageRef));\n\n        PropertyValues values = this.provider.getValues(query, 3, \"\", this.pageClass);\n        assertEquals(1, values.getPropertyValues().size());\n\n        Map<String, Object> metadata = values.getPropertyValues().get(0).getMetaData();\n        assertEquals(\"Space 1 / Space 2\", metadata.get(\"hint\"));\n        assertEquals(\"Page\", metadata.get(\"label\"));\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "getValues",
        "raw_code": "@ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void getValues(boolean hasAccess) throws Exception\n    {\n        when(this.authorizationManager.hasAccess(any(), any())).thenReturn(hasAccess);\n\n        WikiReference wikiRef = new WikiReference(\"wiki\");\n        SpaceReference space1Ref = new SpaceReference(\"space1\", wikiRef);\n        SpaceReference space2Ref = new SpaceReference(\"space2\", space1Ref);\n        EntityReference pageRef = new DocumentReference(\"page\", space2Ref);\n\n        XWikiDocument space1Doc = mock(XWikiDocument.class);\n        XWikiDocument space2Doc = mock(XWikiDocument.class);\n        XWikiDocument pageDoc = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(space1Ref, this.xcontext)).thenReturn(space1Doc);\n        when(this.xwiki.getDocument(space2Ref, this.xcontext)).thenReturn(space2Doc);\n        when(this.xwiki.getDocument(pageRef, this.xcontext)).thenReturn(pageDoc);\n        when(space1Doc.getTranslatedDocument(this.xcontext)).thenReturn(space1Doc);\n        when(space2Doc.getTranslatedDocument(this.xcontext)).thenReturn(space2Doc);\n        when(pageDoc.getTranslatedDocument(this.xcontext)).thenReturn(pageDoc);\n        when(space1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 1\");\n        when(space2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 2\");\n        when(pageDoc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page\");\n\n        Query query = mock(Query.class);\n        when(query.execute()).thenReturn(Collections.singletonList(pageRef));\n\n        PropertyValues values = this.provider.getValues(query, 3, \"\", this.pageClass);\n        assertEquals(1, values.getPropertyValues().size());\n\n        Map<String, Object> metadata = values.getPropertyValues().get(0).getMetaData();\n        if (hasAccess) {\n            assertEquals(\"Space 1 / Space 2\", metadata.get(\"hint\"));\n            assertEquals(\"Page\", metadata.get(\"label\"));\n        } else {\n            assertEquals(\"space1 / space2\", metadata.get(\"hint\"));\n            assertEquals(\"page\", metadata.get(\"label\"));\n        }\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "getValuesWithTerminalPage",
        "raw_code": "@Test\n    public void getValuesWithTerminalPage() throws Exception\n    {\n        WikiReference wikiRef = new WikiReference(\"wiki\");\n        SpaceReference space1Ref = new SpaceReference(\"space1\", wikiRef);\n        SpaceReference space2Ref = new SpaceReference(\"space2\", space1Ref);\n        EntityReference page1Ref = new DocumentReference(\"page\", space2Ref);\n        EntityReference page2Ref = new DocumentReference(XWiki.DEFAULT_SPACE_HOMEPAGE, space2Ref);\n\n        XWikiDocument space1Doc = mock(XWikiDocument.class);\n        XWikiDocument space2Doc = mock(XWikiDocument.class);\n        XWikiDocument page1Doc = mock(XWikiDocument.class);\n        XWikiDocument page2Doc = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(space1Ref, this.xcontext)).thenReturn(space1Doc);\n        when(this.xwiki.getDocument(space2Ref, this.xcontext)).thenReturn(page2Doc);\n        when(this.xwiki.getDocument(page1Ref, this.xcontext)).thenReturn(page1Doc);\n        when(this.xwiki.getDocument(page2Ref, this.xcontext)).thenReturn(page2Doc);\n        when(space1Doc.getTranslatedDocument(this.xcontext)).thenReturn(space1Doc);\n        when(space2Doc.getTranslatedDocument(this.xcontext)).thenReturn(space2Doc);\n        when(page1Doc.getTranslatedDocument(this.xcontext)).thenReturn(page1Doc);\n        when(page2Doc.getTranslatedDocument(this.xcontext)).thenReturn(page2Doc);\n        when(space1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 1\");\n        when(space2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 2\");\n        when(page1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page 1\");\n        when(page2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page 2\");\n\n        Query query = mock(Query.class);\n        when(query.execute()).thenReturn(Arrays.asList(page1Ref, page2Ref));\n\n        PropertyValues values = this.provider.getValues(query, 3, \"\", this.pageClass);\n        assertEquals(2, values.getPropertyValues().size());\n\n        Map<String, Object> metadata = values.getPropertyValues().get(0).getMetaData();\n        assertEquals(\"Space 1 / Page 2\", metadata.get(\"hint\"));\n        assertEquals(\"Page 1\", metadata.get(\"label\"));\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n\n        metadata = values.getPropertyValues().get(1).getMetaData();\n        assertEquals(\"Space 1\", metadata.get(\"hint\"));\n        assertEquals(\"Page 2\", metadata.get(\"label\"));\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "getValuesWithTerminalPage",
        "raw_code": "@ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void getValuesWithTerminalPage(boolean hasAccess) throws Exception\n    {\n        when(this.authorizationManager.hasAccess(any(), any())).thenReturn(hasAccess);\n\n        WikiReference wikiRef = new WikiReference(\"wiki\");\n        SpaceReference space1Ref = new SpaceReference(\"space1\", wikiRef);\n        SpaceReference space2Ref = new SpaceReference(\"space2\", space1Ref);\n        EntityReference page1Ref = new DocumentReference(\"page\", space2Ref);\n        EntityReference page2Ref = new DocumentReference(XWiki.DEFAULT_SPACE_HOMEPAGE, space2Ref);\n\n        XWikiDocument space1Doc = mock(XWikiDocument.class);\n        XWikiDocument space2Doc = mock(XWikiDocument.class);\n        XWikiDocument page1Doc = mock(XWikiDocument.class);\n        XWikiDocument page2Doc = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(space1Ref, this.xcontext)).thenReturn(space1Doc);\n        when(this.xwiki.getDocument(space2Ref, this.xcontext)).thenReturn(page2Doc);\n        when(this.xwiki.getDocument(page1Ref, this.xcontext)).thenReturn(page1Doc);\n        when(this.xwiki.getDocument(page2Ref, this.xcontext)).thenReturn(page2Doc);\n        when(space1Doc.getTranslatedDocument(this.xcontext)).thenReturn(space1Doc);\n        when(space2Doc.getTranslatedDocument(this.xcontext)).thenReturn(space2Doc);\n        when(page1Doc.getTranslatedDocument(this.xcontext)).thenReturn(page1Doc);\n        when(page2Doc.getTranslatedDocument(this.xcontext)).thenReturn(page2Doc);\n        when(space1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 1\");\n        when(space2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 2\");\n        when(page1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page 1\");\n        when(page2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page 2\");\n\n        Query query = mock(Query.class);\n        when(query.execute()).thenReturn(Arrays.asList(page1Ref, page2Ref));\n\n        PropertyValues values = this.provider.getValues(query, 3, \"\", this.pageClass);\n        assertEquals(2, values.getPropertyValues().size());\n\n        Map<String, Object> metadata = values.getPropertyValues().get(0).getMetaData();\n        if (hasAccess) {\n            assertEquals(\"Space 1 / Page 2\", metadata.get(\"hint\"));\n            assertEquals(\"Page 1\", metadata.get(\"label\"));\n        } else {\n            assertEquals(\"space1 / space2\", metadata.get(\"hint\"));\n            assertEquals(\"page\", metadata.get(\"label\"));\n        }\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n\n        metadata = values.getPropertyValues().get(1).getMetaData();\n        if (hasAccess) {\n            assertEquals(\"Space 1\", metadata.get(\"hint\"));\n            assertEquals(\"Page 2\", metadata.get(\"label\"));\n        } else {\n            assertEquals(\"space1\", metadata.get(\"hint\"));\n            assertEquals(\"space2\", metadata.get(\"label\"));\n        }\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "PageClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "private String getLabel(EntityReference entityReference)\n    {\n        String label;\n        try {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            XWikiDocument document;\n            document = xcontext.getWiki().getDocument(entityReference, xcontext).getTranslatedDocument(xcontext);\n            label = document.getRenderedTitle(Syntax.PLAIN_1_0, xcontext);\n        } catch (XWikiException e) {\n            this.logger.error(\"Error while loading the document [{}]. Root cause is [{}]\", entityReference,\n                ExceptionUtils.getRootCause(e));\n            if (entityReference instanceof DocumentReference) {\n                label = super.getLabel((DocumentReference) entityReference, \"\");\n            } else {\n                label = entityReference.getName();\n            }\n        }\n        return label;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PageClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "private String getLabel(EntityReference entityReference)\n    {\n        String label = null;\n\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, entityReference)) {\n            try {\n                XWikiContext xcontext = this.xcontextProvider.get();\n                XWikiDocument document;\n                document = xcontext.getWiki().getDocument(entityReference, xcontext).getTranslatedDocument(xcontext);\n                label = document.getRenderedTitle(Syntax.PLAIN_1_0, xcontext);\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while loading the document [{}]. Root cause is [{}]\", entityReference,\n                    ExceptionUtils.getRootCauseMessage(e), e);\n            }\n        }\n\n        if (label == null) {\n            if (entityReference instanceof DocumentReference documentReference) {\n                label = super.getLabel(documentReference, \"\");\n            } else {\n                label = entityReference.getName();\n            }\n        }\n        return label;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "fhir-ig-publisher",
    "cve_id": "CVE-2025-24363",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "d968694b7dd041640efab5414d7077d5028569f7",
    "short_hash": "d968694b",
    "vulnerableMethods_before": [
      {
        "filename": "Publisher.java",
        "method_name": "generateDataFile",
        "raw_code": "private void generateDataFile(DBBuilder db) throws IOException, FHIRException, SQLException {\n    JsonObject data = new JsonObject();\n    data.add(\"path\", checkAppendSlash(specPath));\n    data.add(\"canonical\", igpkp.getCanonical());\n    data.add(\"igId\", publishedIg.getId());\n    data.add(\"igName\", publishedIg.getName());\n    data.add(\"packageId\", npmName);\n    data.add(\"igVer\", workingVersion());\n    data.add(\"errorCount\", getErrorCount());\n    data.add(\"version\", version);\n    \n    StringType rl = findReleaseLabel();  \n    if (rl == null) {\n      data.add(\"releaseLabel\", \"n/a\");\n      for (String l : allLangs()) {\n        data.add(\"releaseLabel\"+l, rcLangs.get(l).formatPhrase(RenderingI18nContext._NA));\n      }\n    } else { \n      data.add(\"releaseLabel\", rl.getValue());\n      addTranslationsToJson(data, \"releaseLabel\", rl, false);\n    }\n    data.add(\"revision\", specMaps.get(0).getBuild());\n    data.add(\"versionFull\", version+\"-\"+specMaps.get(0).getBuild());\n    data.add(\"toolingVersion\", Constants.VERSION);\n    data.add(\"toolingRevision\", ToolsVersion.TOOLS_VERSION_STR);\n    data.add(\"toolingVersionFull\", Constants.VERSION+\" (\"+ToolsVersion.TOOLS_VERSION_STR+\")\");\n    data.add(\"totalFiles\", fileList.size());\n    data.add(\"processedFiles\", changeList.size());\n    \n    if (repoSource != null) {\n      data.add(\"repoSource\", gh());\n    } else {\n      String git= getGitSource();\n      if (git != null) {\n        data.add(\"repoSource\", git);\n      }\n    }\n    data.add(\"genDate\", genTime());\n    data.add(\"genDay\", genDate());\n    if (db != null) {\n      for (JsonProperty p : data.getProperties()) {\n        db.metadata(p.getName(), p.getValue().asString());\n      }\n    }\n    JsonArray rt = data.forceArray(\"resourceTypes\");\n    List<String> rtl = context.getResourceNames();\n    for (String s : rtl) {\n      rt.add(s);\n    }\n    rt = data.forceArray(\"dataTypes\");\n    ContextUtilities cu = new ContextUtilities(context);\n    for (String s : cu.getTypeNames()) {\n      if (!rtl.contains(s)) {\n        rt.add(s);\n      }\n    }\n\n    JsonObject ig = new JsonObject();\n    data.add(\"ig\", ig);\n    ig.add(\"id\", publishedIg.getId());\n    ig.add(\"name\", publishedIg.getName());\n    ig.add(\"title\", publishedIg.getTitle());\n    addTranslationsToJson(ig, \"title\", publishedIg.getTitleElement(), false);\n    ig.add(\"url\", publishedIg.getUrl());\n    ig.add(\"version\", workingVersion());\n    ig.add(\"status\", publishedIg.getStatusElement().asStringValue());\n    ig.add(\"experimental\", publishedIg.getExperimental());\n    ig.add(\"publisher\", publishedIg.getPublisher());    \n    addTranslationsToJson(ig, \"publisher\", publishedIg.getPublisherElement(), false);\n    if (db != null) {\n      db.metadata(\"gitstatus\", getGitStatus());\n    }\n    if (previousVersionComparator != null && previousVersionComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(previousVersionComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(previousVersionComparator.getLastUrl()));\n    }    \n    if (ipaComparator != null && ipaComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipaComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipaComparator.getLastUrl()));\n    }\n    if (ipsComparator != null && ipsComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipsComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipsComparator.getLastUrl()));\n    }\n\n    if (publishedIg.hasContact()) {\n      JsonArray jc = new JsonArray();\n      ig.add(\"contact\", jc);\n      for (ContactDetail c : publishedIg.getContact()) {\n        JsonObject jco = new JsonObject();\n        jc.add(jco);\n        jco.add(\"name\", c.getName());\n        if (c.hasTelecom()) {\n          JsonArray jct = new JsonArray();\n          jco.add(\"telecom\", jct);\n          for (ContactPoint cc : c.getTelecom()) {\n            jct.add(new JsonString(cc.getValue()));\n          }\n        }\n      }\n      for (String l : allLangs()) {\n        jc = new JsonArray();\n        ig.add(\"contact\"+l, jc);\n        for (ContactDetail c : publishedIg.getContact()) {\n          JsonObject jco = new JsonObject();\n          jc.add(jco);\n          jco.add(\"name\", langUtils.getTranslationOrBase(c.getNameElement(), l));\n          if (c.hasTelecom()) {\n            JsonArray jct = new JsonArray();\n            jco.add(\"telecom\", jct);\n            for (ContactPoint cc : c.getTelecom()) {\n              jct.add(new JsonString(cc.getValue()));\n            }\n          }\n        }\n        \n      }\n    }\n    ig.add(\"date\", publishedIg.getDateElement().asStringValue());\n    ig.add(\"description\", ProfileUtilities.processRelativeUrls(publishedIg.getDescription(), \"\", igpkp.specPath(), context.getResourceNames(), specMaps.get(0).listTargets(), pageTargets(), false));\n    addTranslationsToJson(ig, \"description\", publishedIg.getDescriptionElement(), true);\n\n    if (context.getTxClientManager() != null && context.getTxClientManager().getMaster() != null) {\n      ig.add(\"tx-server\", context.getTxClientManager().getMaster().getAddress());\n    }\n    ig.add(\"copyright\", publishedIg.getCopyright());\n    addTranslationsToJson(ig, \"copyright\", publishedIg.getCopyrightElement(), true);\n\n    for (Enumeration<FHIRVersion> v : publishedIg.getFhirVersion()) {\n      ig.add(\"fhirVersion\", v.asStringValue());\n      break;\n    }\n\n    for (SpecMapManager sm : specMaps) {\n      if (sm.getName() != null) {\n        data.set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase() : Utilities.appendForwardSlash(sm.getBase()));\n        if (!data.has(\"ver\")) {\n          data.add(\"ver\", new JsonObject());\n        }\n        data.getJsonObject(\"ver\").set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase2() : Utilities.appendForwardSlash(sm.getBase2()));\n      }\n    }\n    String json = org.hl7.fhir.utilities.json.parser.JsonParser.compose(data, true);\n    TextFile.stringToFile(json, Utilities.path(tempDir, \"_data\", \"fhir.json\"));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Publisher.java",
        "method_name": "generateDataFile",
        "raw_code": "private void generateDataFile(DBBuilder db) throws IOException, FHIRException, SQLException {\n    JsonObject data = new JsonObject();\n    data.add(\"path\", checkAppendSlash(specPath));\n    data.add(\"canonical\", igpkp.getCanonical());\n    data.add(\"igId\", publishedIg.getId());\n    data.add(\"igName\", publishedIg.getName());\n    data.add(\"packageId\", npmName);\n    data.add(\"igVer\", workingVersion());\n    data.add(\"errorCount\", getErrorCount());\n    data.add(\"version\", version);\n    \n    StringType rl = findReleaseLabel();  \n    if (rl == null) {\n      data.add(\"releaseLabel\", \"n/a\");\n      for (String l : allLangs()) {\n        data.add(\"releaseLabel\"+l, rcLangs.get(l).formatPhrase(RenderingI18nContext._NA));\n      }\n    } else { \n      data.add(\"releaseLabel\", rl.getValue());\n      addTranslationsToJson(data, \"releaseLabel\", rl, false);\n    }\n    data.add(\"revision\", specMaps.get(0).getBuild());\n    data.add(\"versionFull\", version+\"-\"+specMaps.get(0).getBuild());\n    data.add(\"toolingVersion\", Constants.VERSION);\n    data.add(\"toolingRevision\", ToolsVersion.TOOLS_VERSION_STR);\n    data.add(\"toolingVersionFull\", Constants.VERSION+\" (\"+ToolsVersion.TOOLS_VERSION_STR+\")\");\n\n    data.add(\"genDate\", genTime());\n    data.add(\"genDay\", genDate());\n    if (db != null) {\n      for (JsonProperty p : data.getProperties()) {\n        db.metadata(p.getName(), p.getValue().asString());\n      }\n      db.metadata(\"gitstatus\", getGitStatus());\n    }\n\n    data.add(\"totalFiles\", fileList.size());\n    data.add(\"processedFiles\", changeList.size());\n\n    if (repoSource != null) {\n      data.add(\"repoSource\", gh());\n    } else {\n      String git= getGitSource();\n      if (git != null) {\n        data.add(\"repoSource\", git);\n      }\n    }\n\n    JsonArray rt = data.forceArray(\"resourceTypes\");\n    List<String> rtl = context.getResourceNames();\n    for (String s : rtl) {\n      rt.add(s);\n    }\n    rt = data.forceArray(\"dataTypes\");\n    ContextUtilities cu = new ContextUtilities(context);\n    for (String s : cu.getTypeNames()) {\n      if (!rtl.contains(s)) {\n        rt.add(s);\n      }\n    }\n\n    JsonObject ig = new JsonObject();\n    data.add(\"ig\", ig);\n    ig.add(\"id\", publishedIg.getId());\n    ig.add(\"name\", publishedIg.getName());\n    ig.add(\"title\", publishedIg.getTitle());\n    addTranslationsToJson(ig, \"title\", publishedIg.getTitleElement(), false);\n    ig.add(\"url\", publishedIg.getUrl());\n    ig.add(\"version\", workingVersion());\n    ig.add(\"status\", publishedIg.getStatusElement().asStringValue());\n    ig.add(\"experimental\", publishedIg.getExperimental());\n    ig.add(\"publisher\", publishedIg.getPublisher());    \n    addTranslationsToJson(ig, \"publisher\", publishedIg.getPublisherElement(), false);\n\n    if (previousVersionComparator != null && previousVersionComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(previousVersionComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(previousVersionComparator.getLastUrl()));\n    }    \n    if (ipaComparator != null && ipaComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipaComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipaComparator.getLastUrl()));\n    }\n    if (ipsComparator != null && ipsComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipsComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipsComparator.getLastUrl()));\n    }\n\n    if (publishedIg.hasContact()) {\n      JsonArray jc = new JsonArray();\n      ig.add(\"contact\", jc);\n      for (ContactDetail c : publishedIg.getContact()) {\n        JsonObject jco = new JsonObject();\n        jc.add(jco);\n        jco.add(\"name\", c.getName());\n        if (c.hasTelecom()) {\n          JsonArray jct = new JsonArray();\n          jco.add(\"telecom\", jct);\n          for (ContactPoint cc : c.getTelecom()) {\n            jct.add(new JsonString(cc.getValue()));\n          }\n        }\n      }\n      for (String l : allLangs()) {\n        jc = new JsonArray();\n        ig.add(\"contact\"+l, jc);\n        for (ContactDetail c : publishedIg.getContact()) {\n          JsonObject jco = new JsonObject();\n          jc.add(jco);\n          jco.add(\"name\", langUtils.getTranslationOrBase(c.getNameElement(), l));\n          if (c.hasTelecom()) {\n            JsonArray jct = new JsonArray();\n            jco.add(\"telecom\", jct);\n            for (ContactPoint cc : c.getTelecom()) {\n              jct.add(new JsonString(cc.getValue()));\n            }\n          }\n        }\n        \n      }\n    }\n    ig.add(\"date\", publishedIg.getDateElement().asStringValue());\n    ig.add(\"description\", ProfileUtilities.processRelativeUrls(publishedIg.getDescription(), \"\", igpkp.specPath(), context.getResourceNames(), specMaps.get(0).listTargets(), pageTargets(), false));\n    addTranslationsToJson(ig, \"description\", publishedIg.getDescriptionElement(), true);\n\n    if (context.getTxClientManager() != null && context.getTxClientManager().getMaster() != null) {\n      ig.add(\"tx-server\", context.getTxClientManager().getMaster().getAddress());\n    }\n    ig.add(\"copyright\", publishedIg.getCopyright());\n    addTranslationsToJson(ig, \"copyright\", publishedIg.getCopyrightElement(), true);\n\n    for (Enumeration<FHIRVersion> v : publishedIg.getFhirVersion()) {\n      ig.add(\"fhirVersion\", v.asStringValue());\n      break;\n    }\n\n    for (SpecMapManager sm : specMaps) {\n      if (sm.getName() != null) {\n        data.set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase() : Utilities.appendForwardSlash(sm.getBase()));\n        if (!data.has(\"ver\")) {\n          data.add(\"ver\", new JsonObject());\n        }\n        data.getJsonObject(\"ver\").set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase2() : Utilities.appendForwardSlash(sm.getBase2()));\n      }\n    }\n    String json = org.hl7.fhir.utilities.json.parser.JsonParser.compose(data, true);\n    TextFile.stringToFile(json, Utilities.path(tempDir, \"_data\", \"fhir.json\"));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "SFConnectionConfigParserTest.java",
        "method_name": "createFilePathWithPermission",
        "raw_code": "private Path createFilePathWithPermission(Path path, boolean onlyUserPermission)\n      throws IOException {\n    if (Constants.getOS() != Constants.OS.WINDOWS) {\n      FileAttribute<Set<PosixFilePermission>> fileAttribute =\n          onlyUserPermission\n              ? PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rw-------\"))\n              : PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwxrw----\"));\n      return Files.createFile(path, fileAttribute);\n    } else {\n      return Files.createFile(path);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SFConnectionConfigParserTest.java",
        "method_name": "createFilePathWithPermission",
        "raw_code": "private Path createFilePathWithPermission(Path path, boolean onlyUserPermission)\n      throws IOException {\n    if (!isWindows()) {\n      FileAttribute<Set<PosixFilePermission>> fileAttribute =\n          onlyUserPermission\n              ? PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rw-------\"))\n              : PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwxrw----\"));\n      return Files.createFile(path, fileAttribute);\n    } else {\n      return Files.createFile(path);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultSFConnectionHandler.java",
        "method_name": "checkLogFolderPermissions",
        "raw_code": "private void checkLogFolderPermissions(Path path) throws SnowflakeSQLLoggedException {\n    if (Constants.getOS() != Constants.OS.WINDOWS) {\n      try {\n        Set<PosixFilePermission> folderPermissions = Files.getPosixFilePermissions(path);\n        if (folderPermissions.contains(PosixFilePermission.GROUP_WRITE)\n            || folderPermissions.contains(PosixFilePermission.GROUP_READ)\n            || folderPermissions.contains(PosixFilePermission.GROUP_EXECUTE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_WRITE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_READ)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_EXECUTE)) {\n          logger.warn(\n              \"Access permission for the logs directory '{}' is currently {} and is potentially \"\n                  + \"accessible to users other than the owner of the logs directory.\",\n              path.toString(),\n              folderPermissions.toString());\n        }\n      } catch (IOException ex) {\n        throw new SnowflakeSQLLoggedException(\n            sfSession,\n            ErrorCode.INTERNAL_ERROR,\n            String.format(\n                \"Unable to get permissions of log directory %s ,%s\",\n                path.toString(), ex.getMessage(), ex.getCause()));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultSFConnectionHandler.java",
        "method_name": "checkLogFolderPermissions",
        "raw_code": "private void checkLogFolderPermissions(Path path) throws SnowflakeSQLLoggedException {\n    if (!isWindows()) {\n      try {\n        Set<PosixFilePermission> folderPermissions = Files.getPosixFilePermissions(path);\n        if (folderPermissions.contains(PosixFilePermission.GROUP_WRITE)\n            || folderPermissions.contains(PosixFilePermission.GROUP_READ)\n            || folderPermissions.contains(PosixFilePermission.GROUP_EXECUTE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_WRITE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_READ)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_EXECUTE)) {\n          logger.warn(\n              \"Access permission for the logs directory '{}' is currently {} and is potentially \"\n                  + \"accessible to users other than the owner of the logs directory.\",\n              path.toString(),\n              folderPermissions.toString());\n        }\n      } catch (IOException ex) {\n        throw new SnowflakeSQLLoggedException(\n            sfSession,\n            ErrorCode.INTERNAL_ERROR,\n            String.format(\n                \"Unable to get permissions of log directory %s ,%s\",\n                path.toString(), ex.getMessage(), ex.getCause()));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "overrideCacheFile",
        "raw_code": "void overrideCacheFile(File newCacheFile) {\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n    FileUtil.logFileUsage(cacheFile, \"Override cache file\", true);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "overrideCacheFile",
        "raw_code": "void overrideCacheFile(File newCacheFile) {\n    if (!newCacheFile.exists()) {\n      logger.debug(\"Cache file doesn't exists. File: {}\", newCacheFile);\n    }\n    if (onlyOwnerPermissions) {\n      FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(\n          newCacheFile, \"Override cache file\");\n    } else {\n      FileUtil.logFileUsage(cacheFile, \"Override cache file\", false);\n    }\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "build",
        "raw_code": "FileCacheManager build() {\n    // try to get cacheDir from system property or environment variable\n    String cacheDirPath =\n        this.cacheDirectorySystemProperty != null\n            ? systemGetProperty(this.cacheDirectorySystemProperty)\n            : null;\n    if (cacheDirPath == null) {\n      try {\n        cacheDirPath =\n            this.cacheDirectoryEnvironmentVariable != null\n                ? systemGetEnv(this.cacheDirectoryEnvironmentVariable)\n                : null;\n      } catch (Throwable ex) {\n        logger.debug(\n            \"Cannot get environment variable for cache directory, skip using cache\", false);\n        // In Boomi cloud, System.getenv is not allowed due to policy,\n        // so we catch the exception and skip cache completely\n        return this;\n      }\n    }\n\n    if (cacheDirPath != null) {\n      this.cacheDir = new File(cacheDirPath);\n    } else {\n      // use user home directory to store the cache file\n      String homeDir = systemGetProperty(\"user.home\");\n      if (homeDir == null) {\n        // use tmp dir if not exists.\n        homeDir = systemGetProperty(\"java.io.tmpdir\");\n      } else {\n        // Checking if home directory is writable.\n        File homeFile = new File(homeDir);\n        if (!homeFile.canWrite()) {\n          logger.debug(\"Home directory not writeable, using tmpdir\", false);\n          homeDir = systemGetProperty(\"java.io.tmpdir\");\n        }\n      }\n      if (homeDir == null) {\n        // if still home directory is null, no cache dir is set.\n        return this;\n      }\n      if (Constants.getOS() == Constants.OS.WINDOWS) {\n        this.cacheDir =\n            new File(\n                new File(new File(new File(homeDir, \"AppData\"), \"Local\"), \"Snowflake\"), \"Caches\");\n      } else if (Constants.getOS() == Constants.OS.MAC) {\n        this.cacheDir = new File(new File(new File(homeDir, \"Library\"), \"Caches\"), \"Snowflake\");\n      } else {\n        this.cacheDir = new File(new File(homeDir, \".cache\"), \"snowflake\");\n      }\n    }\n\n    if (!this.cacheDir.mkdirs() && !this.cacheDir.exists()) {\n      logger.debug(\n          \"Cannot create the cache directory {}. Giving up.\", this.cacheDir.getAbsolutePath());\n      return this;\n    }\n    logger.debug(\"Verified Directory {}\", this.cacheDir.getAbsolutePath());\n\n    File cacheFileTmp = new File(this.cacheDir, this.baseCacheFileName).getAbsoluteFile();\n    try {\n      // create an empty file if not exists and return true.\n      // If exists. the method returns false.\n      // In this particular case, it doesn't matter as long as the file is\n      // writable.\n      if (cacheFileTmp.createNewFile()) {\n        logger.debug(\"Successfully created a cache file {}\", cacheFileTmp);\n      } else {\n        logger.debug(\"Cache file already exists {}\", cacheFileTmp);\n      }\n      FileUtil.logFileUsage(cacheFileTmp, \"Cache file creation\", false);\n      this.cacheFile = cacheFileTmp.getCanonicalFile();\n      this.cacheLockFile =\n          new File(this.cacheFile.getParentFile(), this.baseCacheFileName + \".lck\");\n    } catch (IOException | SecurityException ex) {\n      logger.debug(\"Failed to touch the cache file. Ignored. {}\", cacheFileTmp.getAbsoluteFile());\n    }\n    return this;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "build",
        "raw_code": "FileCacheManager build() {\n    // try to get cacheDir from system property or environment variable\n    String cacheDirPath =\n        this.cacheDirectorySystemProperty != null\n            ? systemGetProperty(this.cacheDirectorySystemProperty)\n            : null;\n    if (cacheDirPath == null) {\n      try {\n        cacheDirPath =\n            this.cacheDirectoryEnvironmentVariable != null\n                ? systemGetEnv(this.cacheDirectoryEnvironmentVariable)\n                : null;\n      } catch (Throwable ex) {\n        logger.debug(\n            \"Cannot get environment variable for cache directory, skip using cache\", false);\n        // In Boomi cloud, System.getenv is not allowed due to policy,\n        // so we catch the exception and skip cache completely\n        return this;\n      }\n    }\n\n    if (cacheDirPath != null) {\n      this.cacheDir = new File(cacheDirPath);\n    } else {\n      // use user home directory to store the cache file\n      String homeDir = systemGetProperty(\"user.home\");\n      if (homeDir != null) {\n        // Checking if home directory is writable.\n        File homeFile = new File(homeDir);\n        if (!homeFile.canWrite()) {\n          logger.debug(\"Home directory not writeable, skip using cache\", false);\n          homeDir = null;\n        }\n      }\n      if (homeDir == null) {\n        // if still home directory is null, no cache dir is set.\n        return this;\n      }\n      if (Constants.getOS() == Constants.OS.WINDOWS) {\n        this.cacheDir =\n            new File(\n                new File(new File(new File(homeDir, \"AppData\"), \"Local\"), \"Snowflake\"), \"Caches\");\n      } else if (Constants.getOS() == Constants.OS.MAC) {\n        this.cacheDir = new File(new File(new File(homeDir, \"Library\"), \"Caches\"), \"Snowflake\");\n      } else {\n        this.cacheDir = new File(new File(homeDir, \".cache\"), \"snowflake\");\n      }\n    }\n\n    if (!this.cacheDir.mkdirs() && !this.cacheDir.exists()) {\n      logger.debug(\n          \"Cannot create the cache directory {}. Giving up.\", this.cacheDir.getAbsolutePath());\n      return this;\n    }\n    logger.debug(\"Verified Directory {}\", this.cacheDir.getAbsolutePath());\n\n    File cacheFileTmp = new File(this.cacheDir, this.baseCacheFileName).getAbsoluteFile();\n    try {\n      // create an empty file if not exists and return true.\n      // If exists. the method returns false.\n      // In this particular case, it doesn't matter as long as the file is\n      // writable.\n      if (!cacheFileTmp.exists()) {\n        if (!isWindows() && onlyOwnerPermissions) {\n          Files.createFile(\n              cacheFileTmp.toPath(),\n              PosixFilePermissions.asFileAttribute(\n                  Stream.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE)\n                      .collect(Collectors.toSet())));\n        } else {\n          Files.createFile(cacheFileTmp.toPath());\n        }\n        logger.debug(\"Successfully created a cache file {}\", cacheFileTmp);\n      } else {\n        logger.debug(\"Cache file already exists {}\", cacheFileTmp);\n      }\n      FileUtil.logFileUsage(cacheFileTmp, \"Cache file creation\", false);\n      this.cacheFile = cacheFileTmp.getCanonicalFile();\n      this.cacheLockFile =\n          new File(this.cacheFile.getParentFile(), this.baseCacheFileName + \".lck\");\n    } catch (IOException | SecurityException ex) {\n      logger.info(\n          \"Failed to touch the cache file: {}. Ignored. {}\",\n          ex.getMessage(),\n          cacheFileTmp.getAbsoluteFile());\n    }\n    return this;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "readCacheFile",
        "raw_code": "JsonNode readCacheFile() {\n    if (cacheFile == null || !this.checkCacheLockFile()) {\n      // no cache or the cache is not valid.\n      return null;\n    }\n    try {\n      if (!cacheFile.exists()) {\n        logger.debug(\"Cache file doesn't exists. File: {}\", cacheFile);\n        return null;\n      }\n\n      try (Reader reader =\n          new InputStreamReader(new FileInputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        FileUtil.logFileUsage(cacheFile, \"Read cache\", false);\n        return OBJECT_MAPPER.readTree(reader);\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to read the cache file. No worry. File: {}, Err: {}\", cacheFile, ex);\n    }\n    return null;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "readCacheFile",
        "raw_code": "JsonNode readCacheFile() {\n    if (cacheFile == null || !this.checkCacheLockFile()) {\n      // no cache or the cache is not valid.\n      return null;\n    }\n    try {\n      if (!cacheFile.exists()) {\n        logger.debug(\"Cache file doesn't exists. File: {}\", cacheFile);\n        return null;\n      }\n\n      try (Reader reader =\n          new InputStreamReader(new FileInputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n\n        if (onlyOwnerPermissions) {\n          FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(cacheFile, \"Read cache\");\n          FileUtil.throwWhenOwnerDifferentThanCurrentUser(cacheFile, \"Read cache\");\n        } else {\n          FileUtil.logFileUsage(cacheFile, \"Read cache\", false);\n        }\n        return OBJECT_MAPPER.readTree(reader);\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to read the cache file. No worry. File: {}, Err: {}\", cacheFile, ex);\n    }\n    return null;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "writeCacheFile",
        "raw_code": "void writeCacheFile(JsonNode input) {\n    logger.debug(\"Writing cache file. File: {}\", cacheFile);\n    if (cacheFile == null || !tryLockCacheFile()) {\n      // no cache file or it failed to lock file\n      logger.debug(\n          \"No cache file exists or failed to lock the file. Skipping writing the cache\", false);\n      return;\n    }\n    // NOTE: must unlock cache file\n    try {\n      if (input == null) {\n        return;\n      }\n      try (Writer writer =\n          new OutputStreamWriter(new FileOutputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        FileUtil.logFileUsage(cacheFile, \"Write to cache\", false);\n        writer.write(input.toString());\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to write the cache file. File: {}\", cacheFile);\n    } finally {\n      if (!unlockCacheFile()) {\n        logger.debug(\"Failed to unlock cache file\", false);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "writeCacheFile",
        "raw_code": "void writeCacheFile(JsonNode input) {\n    logger.debug(\"Writing cache file. File: {}\", cacheFile);\n    if (cacheFile == null || !tryLockCacheFile()) {\n      // no cache file or it failed to lock file\n      logger.debug(\n          \"No cache file exists or failed to lock the file. Skipping writing the cache\", false);\n      return;\n    }\n    // NOTE: must unlock cache file\n    try {\n      if (input == null) {\n        return;\n      }\n      try (Writer writer =\n          new OutputStreamWriter(new FileOutputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        if (onlyOwnerPermissions) {\n          FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(cacheFile, \"Write to cache\");\n        } else {\n          FileUtil.logFileUsage(cacheFile, \"Write to cache\", false);\n        }\n        writer.write(input.toString());\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to write the cache file. File: {}\", cacheFile);\n    } finally {\n      if (!unlockCacheFile()) {\n        logger.debug(\"Failed to unlock cache file\", false);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "SFConnectionConfigParser.java",
        "method_name": "verifyFilePermissionSecure",
        "raw_code": "private static void verifyFilePermissionSecure(Path configFilePath)\n      throws IOException, SnowflakeSQLException {\n    if (Constants.getOS() != Constants.OS.WINDOWS) {\n      PosixFileAttributeView posixFileAttributeView =\n          Files.getFileAttributeView(configFilePath, PosixFileAttributeView.class);\n      if (!posixFileAttributeView.readAttributes().permissions().stream()\n          .allMatch(\n              o ->\n                  Arrays.asList(PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_READ)\n                      .contains(o))) {\n        logger.error(\n            \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n            configFilePath);\n        throw new SnowflakeSQLException(\n            String.format(\n                \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n                configFilePath));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SFConnectionConfigParser.java",
        "method_name": "verifyFilePermissionSecure",
        "raw_code": "private static void verifyFilePermissionSecure(Path configFilePath)\n      throws IOException, SnowflakeSQLException {\n    if (!isWindows()) {\n      PosixFileAttributeView posixFileAttributeView =\n          Files.getFileAttributeView(configFilePath, PosixFileAttributeView.class);\n      if (!posixFileAttributeView.readAttributes().permissions().stream()\n          .allMatch(\n              o ->\n                  Arrays.asList(PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_READ)\n                      .contains(o))) {\n        logger.error(\n            \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n            configFilePath);\n        throw new SnowflakeSQLException(\n            String.format(\n                \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n                configFilePath));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileUtil.java",
        "method_name": "logFileUsage",
        "raw_code": "public static void logFileUsage(Path filePath, String context, boolean logReadAccess) {\n    logger.info(\"{}Accessing file: {}\", getContextStr(context), filePath);\n    logWarnWhenAccessibleByOthers(filePath, context, logReadAccess);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileUtil.java",
        "method_name": "logFileUsage",
        "raw_code": "public static void logFileUsage(Path filePath, String context, boolean logReadAccess) {\n    logWarnWhenAccessibleByOthers(filePath, context, logReadAccess);\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileUtil.java",
        "method_name": "logWarnWhenAccessibleByOthers",
        "raw_code": "private static void logWarnWhenAccessibleByOthers(\n      Path filePath, String context, boolean logReadAccess) {\n    // we do not check the permissions for Windows\n    if (Constants.getOS() == Constants.OS.WINDOWS) {\n      return;\n    }\n\n    try {\n      Collection<PosixFilePermission> filePermissions = Files.getPosixFilePermissions(filePath);\n      logger.debug(\n          \"{}File {} access rights: {}\", getContextStr(context), filePath, filePermissions);\n\n      boolean isWritableByOthers = isPermPresent(filePermissions, WRITE_BY_OTHERS);\n      boolean isReadableByOthers = isPermPresent(filePermissions, READ_BY_OTHERS);\n\n      if (isWritableByOthers || (isReadableByOthers && logReadAccess)) {\n        logger.warn(\n            \"{}File {} is accessible by others to:{}{}\",\n            getContextStr(context),\n            filePath,\n            isReadableByOthers && logReadAccess ? \" read\" : \"\",\n            isWritableByOthers ? \" write\" : \"\");\n      }\n    } catch (IOException e) {\n      logger.warn(\n          \"{}Unable to access the file to check the permissions: {}. Error: {}\",\n          getContextStr(context),\n          filePath,\n          e);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileUtil.java",
        "method_name": "logWarnWhenAccessibleByOthers",
        "raw_code": "private static void logWarnWhenAccessibleByOthers(\n      Path filePath, String context, boolean logReadAccess) {\n    // we do not check the permissions for Windows\n    if (isWindows()) {\n      return;\n    }\n\n    try {\n      Collection<PosixFilePermission> filePermissions = Files.getPosixFilePermissions(filePath);\n      logger.debug(\n          \"{}File {} access rights: {}\", getContextStr(context), filePath, filePermissions);\n\n      boolean isWritableByOthers = isPermPresent(filePermissions, WRITE_BY_OTHERS);\n      boolean isReadableByOthers = isPermPresent(filePermissions, READ_BY_OTHERS);\n      boolean isExecutable = isPermPresent(filePermissions, EXECUTABLE);\n\n      if (isWritableByOthers || (isReadableByOthers || isExecutable)) {\n        logger.warn(\n            \"{}File {} is accessible by others to:{}{}\",\n            getContextStr(context),\n            filePath,\n            isReadableByOthers && logReadAccess ? \" read\" : \"\",\n            isWritableByOthers ? \" write\" : \"\",\n            isExecutable ? \" executable\" : \"\");\n      }\n    } catch (IOException e) {\n      logger.warn(\n          \"{}Unable to access the file to check the permissions: {}. Error: {}\",\n          getContextStr(context),\n          filePath,\n          e);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24789",
    "cwe_list": [
      "CWE-426"
    ],
    "commit_hash": "4f01bb8f9b708c71e7a2111c87371dbfc1d53dd6",
    "short_hash": "4f01bb8f",
    "vulnerableMethods_before": [
      {
        "filename": "SessionUtilExternalBrowser.java",
        "method_name": "openBrowser",
        "raw_code": "void openBrowser(String ssoUrl) throws SFException;",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionUtilExternalBrowser.java",
        "method_name": "openBrowser",
        "raw_code": "@Override\n    public void openBrowser(String ssoUrl) throws SFException {\n      if (!URLUtil.isValidURL(ssoUrl)) {\n        throw new SFException(ErrorCode.INVALID_CONNECTION_URL, \"Invalid SSOUrl found - \" + ssoUrl);\n      }\n      try {\n        // start web browser\n        Runtime runtime = Runtime.getRuntime();\n        Constants.OS os = Constants.getOS();\n        if (Desktop.isDesktopSupported()\n            && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {\n          Desktop.getDesktop().browse(new URI(ssoUrl));\n        } else if (os == Constants.OS.MAC) {\n          runtime.exec(\"open \" + ssoUrl);\n        } else if (os == Constants.OS.WINDOWS) {\n          runtime.exec(new String[] {\"rundll32\", \"url.dll,FileProtocolHandler\", ssoUrl});\n        } else {\n          runtime.exec(\"xdg-open \" + ssoUrl);\n        }\n      } catch (URISyntaxException | IOException ex) {\n        throw new SFException(ex, ErrorCode.NETWORK_ERROR, ex.getMessage());\n      }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdater.java",
        "method_name": "renameLinks",
        "raw_code": "private void renameLinks(XWikiDocument document, EntityReference oldTarget, EntityReference newTarget,\n        XWikiContext xcontext, boolean relative, RenameLambda renameLambda) throws XWikiException\n    {\n        DocumentReference currentDocumentReference = document.getDocumentReference();\n\n        ComponentManager componentManager = this.contextComponentManagerProvider.get();\n\n        // We support only the syntaxes for which there is an available renderer.\n        if (!componentManager.hasComponent(BlockRenderer.class, document.getSyntax().toIdString())) {\n            this.logger.warn(\n                \"We can't rename the links from [{}] because there is no renderer available for its syntax [{}].\",\n                currentDocumentReference, document.getSyntax());\n\n            return;\n        }\n\n        // Load the renderer\n        BlockRenderer renderer;\n        try {\n            renderer = componentManager.getInstance(BlockRenderer.class, document.getSyntax().toIdString());\n        } catch (ComponentLookupException e) {\n            this.logger.error(\n                \"We can't rename the links from [{}] because the renderer for syntax [{}] cannot be loaded.\",\n                currentDocumentReference, document.getSyntax(), e);\n\n            return;\n        }\n\n        // Document content\n        boolean modified = renameLinks(document, relative, renameLambda);\n\n        // XObjects properties\n        for (List<BaseObject> xobjects : document.getXObjects().values()) {\n            for (BaseObject xobject : xobjects) {\n                if (xobject != null) {\n                    modified |= renameLinks(xobject, document, renderer, xcontext, relative, renameLambda);\n                }\n            }\n        }\n\n        if (modified) {\n            if (relative) {\n                saveDocumentPreservingContentAuthor(document, \"Updated the relative links.\", true);\n\n                info(\"Updated the relative links from [{}].\", currentDocumentReference);\n            } else {\n                saveDocumentPreservingContentAuthor(document, \"Renamed back-links.\", false);\n\n                info(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                    document.getDocumentReferenceWithLocale(), oldTarget, newTarget);\n            }\n        } else {\n            if (relative) {\n                info(\"No relative links to update in [{}].\", currentDocumentReference);\n            } else {\n                info(\"No back-links to update in [{}].\", currentDocumentReference);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdater.java",
        "method_name": "renameLinks",
        "raw_code": "private void renameLinks(XWikiDocument document, EntityReference oldTarget, EntityReference newTarget,\n        XWikiContext xcontext, boolean relative, RenameLambda renameLambda) throws XWikiException\n    {\n        DocumentReference currentDocumentReference = document.getDocumentReference();\n\n        ComponentManager componentManager = this.contextComponentManagerProvider.get();\n\n        // We support only the syntaxes for which there is an available renderer.\n        if (!componentManager.hasComponent(BlockRenderer.class, document.getSyntax().toIdString())) {\n            this.logger.warn(\n                \"We can't rename the links from [{}] because there is no renderer available for its syntax [{}].\",\n                currentDocumentReference, document.getSyntax());\n\n            return;\n        }\n\n        // Load the renderer\n        BlockRenderer renderer;\n        try {\n            renderer = componentManager.getInstance(BlockRenderer.class, document.getSyntax().toIdString());\n        } catch (ComponentLookupException e) {\n            this.logger.error(\n                \"We can't rename the links from [{}] because the renderer for syntax [{}] cannot be loaded.\",\n                currentDocumentReference, document.getSyntax(), e);\n\n            return;\n        }\n\n        // Document content\n        boolean modified = renameLinks(document, relative, renameLambda);\n\n        // XObjects properties\n        for (List<BaseObject> xobjects : document.getXObjects().values()) {\n            for (BaseObject xobject : xobjects) {\n                if (xobject != null) {\n                    modified |= renameLinks(xobject, document, renderer, xcontext, relative, renameLambda);\n                }\n            }\n        }\n\n        if (modified) {\n            if (relative) {\n                saveDocumentPreservingAuthors(document, \"refactoring.referenceUpdater.saveMessage.relativeLink\");\n\n                info(\"Updated the relative links from [{}].\", currentDocumentReference);\n            } else {\n                saveDocumentPreservingAuthors(document, \"refactoring.referenceUpdater.saveMessage.backlinks\");\n\n                info(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                    document.getDocumentReferenceWithLocale(), oldTarget, newTarget);\n            }\n        } else {\n            if (relative) {\n                info(\"No relative links to update in [{}].\", currentDocumentReference);\n            } else {\n                info(\"No back-links to update in [{}].\", currentDocumentReference);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "beforeEach",
        "raw_code": "@BeforeEach\n    void beforeEach() throws Exception\n    {\n        XWiki xwiki = mock(XWiki.class);\n        when(this.xcontext.getWiki()).thenReturn(xwiki);\n        when(xwiki.exists(any(DocumentReference.class), eq(this.xcontext))).thenReturn(true);\n\n        when(this.xcontextProvider.get()).thenReturn(this.xcontext);\n        when(this.componentManagerProvider.get()).thenReturn(this.componentManager);\n\n        when(this.jobContext.getCurrentJob()).thenReturn(this.job);\n        when(this.job.getRequest()).thenReturn(jobrequest);\n        when(this.jobrequest.isVerbose()).thenReturn(true);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "beforeEach",
        "raw_code": "@BeforeEach\n    void beforeEach() throws Exception\n    {\n        XWiki xwiki = mock(XWiki.class);\n        when(this.xcontext.getWiki()).thenReturn(xwiki);\n        when(xwiki.exists(any(DocumentReference.class), eq(this.xcontext))).thenReturn(true);\n\n        when(this.xcontextProvider.get()).thenReturn(this.xcontext);\n        when(this.componentManagerProvider.get()).thenReturn(this.componentManager);\n\n        when(this.jobContext.getCurrentJob()).thenReturn(this.job);\n        when(this.job.getRequest()).thenReturn(jobrequest);\n        when(this.jobrequest.isVerbose()).thenReturn(true);\n        when(this.localizationManager.getDefaultLocale()).thenReturn(Locale.FRENCH);\n        when(this.localizationManager.getTranslationPlain(SAVE_COMMENT_RELATIVE_LINK_KEY, Locale.FRENCH))\n            .thenReturn(TRANSLATED_RELATIVE_COMMENT);\n        when(this.localizationManager.getTranslationPlain(SAVE_COMMENT_BACKLINK_KEY, Locale.FRENCH))\n            .thenReturn(TRANSLATED_BACKLINK_COMMENT);\n        when(this.userReferenceResolver.resolve(CurrentUserReference.INSTANCE)).thenReturn(currentUserReference);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateRelativeLinks",
        "raw_code": "@Test\n    void updateRelativeLinks() throws Exception\n    {\n        DocumentReference oldReference = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldImageTargetAttachment = new AttachmentReference(\"attachment.txt\", oldReference);\n        DocumentReference newReference = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newImageTargetAttachment = new AttachmentReference(\"attachment.txt\", newReference);\n        AttachmentReference absoluteTargetAttachment = new AttachmentReference(\"attachment.txt\",\n            new DocumentReference(\"wiki\", \"Main\", \"WebHome\"));\n\n        XWikiDocument newDocument = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(newReference, this.xcontext)).thenReturn(newDocument);\n        when(newDocument.getDocumentReference()).thenReturn(newReference);\n        when(newDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // Setup document content\n        ResourceReference docLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock docLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n        ResourceReference spaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n        ResourceReference imageReference = new AttachmentResourceReference(\"attachment.txt\");\n        ImageBlock imageBlock = new ImageBlock(imageReference, false);\n        ResourceReference absoluteDocLinkResourceReference = new ResourceReference(\"xwiki:C.WebHome\",\n            ResourceType.DOCUMENT);\n        LinkBlock absoluteDocLinkBlock =\n            new LinkBlock(List.of(), absoluteDocLinkResourceReference, false);\n        when(newDocument.getXDOM())\n            .thenReturn(new XDOM(List.of(docLinkBlock, spaceLinkBlock, imageBlock, absoluteDocLinkBlock)));\n\n        // Setup object content\n        ResourceReference xobjectDocLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock xobjectDocLinkBlock = new LinkBlock(List.of(), xobjectDocLinkReference, false);\n        ResourceReference xobjectSpaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock xobjectSpaceLinkBlock =\n            new LinkBlock(List.of(), xobjectSpaceLinkReference, false);\n        ResourceReference xobjectImageReference = new AttachmentResourceReference(\"attachment.txt\");\n        ImageBlock xobjectImageBlock = new ImageBlock(xobjectImageReference, false);\n        setTextarea(newDocument,\n            new XDOM(List.of(xobjectDocLinkBlock, xobjectSpaceLinkBlock, xobjectImageBlock)));\n\n        DocumentReference originalDocLinkReference = new DocumentReference(\"WebHome\",\n            new SpaceReference(\"C\", oldReference.getLastSpaceReference()));\n        DocumentReference absoluteDocLinkReference = new DocumentReference(\"WebHome\", new SpaceReference(\"wiki\", \"C\"));\n        EntityReference relativeDocLinkReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"C\", EntityType.SPACE));\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(absoluteDocLinkResourceReference, null, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null, oldReference))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(xobjectDocLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(imageReference, null))\n            .thenReturn(absoluteTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, oldReference))\n            .thenReturn(oldImageTargetAttachment);\n        when(this.relativeEntityReferenceResolver.resolve(imageReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        DocumentReference newDocLinkReference = new DocumentReference(\"WebHome\",\n            new SpaceReference(\"C\", newReference.getLastSpaceReference()));\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, newReference))\n            .thenReturn(newImageTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null, newReference))\n            .thenReturn(new DocumentReference(\"WebHome\", new SpaceReference(\"wiki\", \"E\")));\n\n        SpaceReference originalSpaceReference = new SpaceReference(\"wiki\", \"Z\");\n        EntityReference relativeSpaceReference = new EntityReference(\"Z\", EntityType.SPACE);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(originalSpaceReference);\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, newReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null, newReference))\n            .thenReturn(originalSpaceReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(originalDocLinkReference, newReference)).thenReturn(\"A.C\");\n        when(this.defaultEntityReferenceSerializer.serialize(absoluteDocLinkReference, newReference))\n            .thenReturn(\"wiki:C.WebHome\");\n\n        updater.update(newReference, oldReference, newReference);\n\n        // Document link block is updated.\n        assertEquals(\"A.C\", docLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, docLinkBlock.getReference().getType());\n        assertEquals(\"wiki:C.WebHome\", absoluteDocLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, absoluteDocLinkBlock.getReference().getType());\n        // Space link block stays the same, since they were on the same wiki.\n        assertEquals(\"Z\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        // Image link relative to the document stay the same\n        assertEquals(\"attachment.txt\", imageBlock.getReference().getReference());\n\n        // XObject Document link block is updated.\n        assertEquals(\"A.C\", xobjectDocLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, xobjectDocLinkBlock.getReference().getType());\n        // XObject Space link block stays the same, since they were on the same wiki.\n        assertEquals(\"Z\", xobjectSpaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, xobjectSpaceLinkBlock.getReference().getType());\n        // Image link relative to the document stay the same\n        assertEquals(\"attachment.txt\", xobjectImageBlock.getReference().getReference());\n\n        verifyDocumentSave(newDocument, \"Updated the relative links.\", true, true);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateRelativeLinks",
        "raw_code": "@Test\n    void updateRelativeLinks() throws Exception\n    {\n        DocumentReference oldReference = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldImageTargetAttachment = new AttachmentReference(\"attachment.txt\", oldReference);\n        DocumentReference newReference = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newImageTargetAttachment = new AttachmentReference(\"attachment.txt\", newReference);\n        AttachmentReference absoluteTargetAttachment = new AttachmentReference(\"attachment.txt\",\n            new DocumentReference(\"wiki\", \"Main\", \"WebHome\"));\n\n        XWikiDocument newDocument = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(newDocument.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(newReference, this.xcontext)).thenReturn(newDocument);\n        when(newDocument.getDocumentReference()).thenReturn(newReference);\n        when(newDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // Setup document content\n        ResourceReference docLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock docLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n        ResourceReference spaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n        ResourceReference imageReference = new AttachmentResourceReference(\"attachment.txt\");\n        ImageBlock imageBlock = new ImageBlock(imageReference, false);\n        ResourceReference absoluteDocLinkResourceReference = new ResourceReference(\"xwiki:C.WebHome\",\n            ResourceType.DOCUMENT);\n        LinkBlock absoluteDocLinkBlock =\n            new LinkBlock(List.of(), absoluteDocLinkResourceReference, false);\n        when(newDocument.getXDOM())\n            .thenReturn(new XDOM(List.of(docLinkBlock, spaceLinkBlock, imageBlock, absoluteDocLinkBlock)));\n\n        // Setup object content\n        ResourceReference xobjectDocLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock xobjectDocLinkBlock = new LinkBlock(List.of(), xobjectDocLinkReference, false);\n        ResourceReference xobjectSpaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock xobjectSpaceLinkBlock =\n            new LinkBlock(List.of(), xobjectSpaceLinkReference, false);\n        ResourceReference xobjectImageReference = new AttachmentResourceReference(\"attachment.txt\");\n        ImageBlock xobjectImageBlock = new ImageBlock(xobjectImageReference, false);\n        setTextarea(newDocument,\n            new XDOM(List.of(xobjectDocLinkBlock, xobjectSpaceLinkBlock, xobjectImageBlock)));\n\n        DocumentReference originalDocLinkReference = new DocumentReference(\"WebHome\",\n            new SpaceReference(\"C\", oldReference.getLastSpaceReference()));\n        DocumentReference absoluteDocLinkReference = new DocumentReference(\"WebHome\", new SpaceReference(\"wiki\", \"C\"));\n        EntityReference relativeDocLinkReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"C\", EntityType.SPACE));\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(absoluteDocLinkResourceReference, null, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null, oldReference))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(xobjectDocLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(imageReference, null))\n            .thenReturn(absoluteTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, oldReference))\n            .thenReturn(oldImageTargetAttachment);\n        when(this.relativeEntityReferenceResolver.resolve(imageReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        DocumentReference newDocLinkReference = new DocumentReference(\"WebHome\",\n            new SpaceReference(\"C\", newReference.getLastSpaceReference()));\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, newReference))\n            .thenReturn(newImageTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null, newReference))\n            .thenReturn(new DocumentReference(\"WebHome\", new SpaceReference(\"wiki\", \"E\")));\n\n        SpaceReference originalSpaceReference = new SpaceReference(\"wiki\", \"Z\");\n        EntityReference relativeSpaceReference = new EntityReference(\"Z\", EntityType.SPACE);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(originalSpaceReference);\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, newReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null, newReference))\n            .thenReturn(originalSpaceReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(originalDocLinkReference, newReference)).thenReturn(\"A.C\");\n        when(this.defaultEntityReferenceSerializer.serialize(absoluteDocLinkReference, newReference))\n            .thenReturn(\"wiki:C.WebHome\");\n\n        updater.update(newReference, oldReference, newReference);\n\n        // Document link block is updated.\n        assertEquals(\"A.C\", docLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, docLinkBlock.getReference().getType());\n        assertEquals(\"wiki:C.WebHome\", absoluteDocLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, absoluteDocLinkBlock.getReference().getType());\n        // Space link block stays the same, since they were on the same wiki.\n        assertEquals(\"Z\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        // Image link relative to the document stay the same\n        assertEquals(\"attachment.txt\", imageBlock.getReference().getReference());\n\n        // XObject Document link block is updated.\n        assertEquals(\"A.C\", xobjectDocLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, xobjectDocLinkBlock.getReference().getType());\n        // XObject Space link block stays the same, since they were on the same wiki.\n        assertEquals(\"Z\", xobjectSpaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, xobjectSpaceLinkBlock.getReference().getType());\n        // Image link relative to the document stay the same\n        assertEquals(\"attachment.txt\", xobjectImageBlock.getReference().getReference());\n\n        verifyDocumentSave(newDocument, true);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateRelativeLinksAcrossWikis",
        "raw_code": "@Test\n    void updateRelativeLinksAcrossWikis() throws Exception\n    {\n        DocumentReference oldReference = new DocumentReference(\"wiki1\", \"A\", \"B\");\n        DocumentReference newReference = new DocumentReference(\"wiki2\", \"X\", \"Y\");\n\n        XWikiDocument newDocument = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(newReference, this.xcontext)).thenReturn(newDocument);\n        when(newDocument.getDocumentReference()).thenReturn(newReference);\n        when(newDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        XDOM xdom = mock(XDOM.class);\n        when(newDocument.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock docLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(docLinkBlock, spaceLinkBlock));\n\n        DocumentReference originalDocLinkReference = new DocumentReference(\"C\", oldReference.getLastSpaceReference());\n        DocumentReference absoluteDocLinkReference = new DocumentReference(\"C\", new SpaceReference(\"xwiki\", \"Main\"));\n        EntityReference relativeDocLinkReference = new EntityReference(\"C\", EntityType.DOCUMENT,\n            new EntityReference(\"B\", EntityType.SPACE));\n        EntityReference relativeSpaceLinkReference = new EntityReference(\"Z\", EntityType.SPACE);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null)).thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        DocumentReference newDocLinkReference = new DocumentReference(\"C\", newReference.getLastSpaceReference());\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n\n        SpaceReference originalSpaceReference = new SpaceReference(\"wiki1\", \"Z\");\n        SpaceReference absoluteSpaceReference = new SpaceReference(\"xwiki\", \"Z\");\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null)).thenReturn(absoluteSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        SpaceReference newSpaceReference = new SpaceReference(\"wiki2\", \"Z\");\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, newReference))\n            .thenReturn(newSpaceReference);\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceLinkReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(originalDocLinkReference, newReference))\n            .thenReturn(\"wiki1:A.C\");\n        when(this.compactEntityReferenceSerializer.serialize(originalSpaceReference, newReference))\n            .thenReturn(\"wiki1:Z\");\n\n        updater.update(newReference, oldReference, newReference);\n\n        // Document link block is updated.\n        assertEquals(\"wiki1:A.C\", docLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, docLinkBlock.getReference().getType());\n        // Space link is also updated, since they were referring entities on a different wiki.\n        assertEquals(\"wiki1:Z\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(newDocument, \"Updated the relative links.\", true, true);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateRelativeLinksAcrossWikis",
        "raw_code": "@Test\n    void updateRelativeLinksAcrossWikis() throws Exception\n    {\n        DocumentReference oldReference = new DocumentReference(\"wiki1\", \"A\", \"B\");\n        DocumentReference newReference = new DocumentReference(\"wiki2\", \"X\", \"Y\");\n\n        XWikiDocument newDocument = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(newDocument.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(newReference, this.xcontext)).thenReturn(newDocument);\n        when(newDocument.getDocumentReference()).thenReturn(newReference);\n        when(newDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        XDOM xdom = mock(XDOM.class);\n        when(newDocument.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock docLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(docLinkBlock, spaceLinkBlock));\n\n        DocumentReference originalDocLinkReference = new DocumentReference(\"C\", oldReference.getLastSpaceReference());\n        DocumentReference absoluteDocLinkReference = new DocumentReference(\"C\", new SpaceReference(\"xwiki\", \"Main\"));\n        EntityReference relativeDocLinkReference = new EntityReference(\"C\", EntityType.DOCUMENT,\n            new EntityReference(\"B\", EntityType.SPACE));\n        EntityReference relativeSpaceLinkReference = new EntityReference(\"Z\", EntityType.SPACE);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null)).thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        DocumentReference newDocLinkReference = new DocumentReference(\"C\", newReference.getLastSpaceReference());\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n\n        SpaceReference originalSpaceReference = new SpaceReference(\"wiki1\", \"Z\");\n        SpaceReference absoluteSpaceReference = new SpaceReference(\"xwiki\", \"Z\");\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null)).thenReturn(absoluteSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        SpaceReference newSpaceReference = new SpaceReference(\"wiki2\", \"Z\");\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, newReference))\n            .thenReturn(newSpaceReference);\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceLinkReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(originalDocLinkReference, newReference))\n            .thenReturn(\"wiki1:A.C\");\n        when(this.compactEntityReferenceSerializer.serialize(originalSpaceReference, newReference))\n            .thenReturn(\"wiki1:Z\");\n\n        updater.update(newReference, oldReference, newReference);\n\n        // Document link block is updated.\n        assertEquals(\"wiki1:A.C\", docLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, docLinkBlock.getReference().getType());\n        // Space link is also updated, since they were referring entities on a different wiki.\n        assertEquals(\"wiki1:Z\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(newDocument, true);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "update",
        "raw_code": "@Test\n    void update() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        // Setup document content\n        ResourceReference linkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n        ResourceReference absoluteLinkReference = new ResourceReference(\"xwiki:A.B.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock absoluteLinkBlock = new LinkBlock(List.of(), absoluteLinkReference, false);\n        XDOM xdom = new XDOM(List.of(linkBlock, absoluteLinkBlock));\n        when(document.getXDOM()).thenReturn(xdom);\n\n        // Setup object content\n        ResourceReference xobjectLinkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock xobjectLinkBlock = new LinkBlock(List.of(), xobjectLinkReference, false);\n        XDOM xobjectXDOM = new XDOM(List.of(xobjectLinkBlock));\n        setTextarea(document, xobjectXDOM);\n\n        EntityReference relativeLinkReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n        EntityReference relativeAbsoluteLinkReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"B\", EntityType.SPACE, new EntityReference(\"B\", EntityType.SPACE,\n                new EntityReference(\"xwiki\", EntityType.WIKI))));\n\n        when(this.resourceReferenceResolver.resolve(linkReference, null)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(absoluteLinkReference, null)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(absoluteLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(xobjectLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(xobjectLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.relativeEntityReferenceResolver.resolve(xobjectLinkReference,null, null))\n            .thenReturn(relativeLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null))\n            .thenReturn(relativeLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(absoluteLinkReference, null, null))\n            .thenReturn(relativeAbsoluteLinkReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.defaultEntityReferenceSerializer.serialize(newLinkTarget, documentReference))\n            .thenReturn(\"xwiki:X.Y.WebHome\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.Y\", linkBlock.getReference().getReference());\n        assertEquals(\"xwiki:X.Y.WebHome\", absoluteLinkBlock.getReference().getReference());\n        assertEquals(\"X.Y\", xobjectLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, linkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "update",
        "raw_code": "@Test\n    void update() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        // Setup document content\n        ResourceReference linkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n        ResourceReference absoluteLinkReference = new ResourceReference(\"xwiki:A.B.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock absoluteLinkBlock = new LinkBlock(List.of(), absoluteLinkReference, false);\n        XDOM xdom = new XDOM(List.of(linkBlock, absoluteLinkBlock));\n        when(document.getXDOM()).thenReturn(xdom);\n\n        // Setup object content\n        ResourceReference xobjectLinkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock xobjectLinkBlock = new LinkBlock(List.of(), xobjectLinkReference, false);\n        XDOM xobjectXDOM = new XDOM(List.of(xobjectLinkBlock));\n        setTextarea(document, xobjectXDOM);\n\n        EntityReference relativeLinkReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n        EntityReference relativeAbsoluteLinkReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"B\", EntityType.SPACE, new EntityReference(\"B\", EntityType.SPACE,\n                new EntityReference(\"xwiki\", EntityType.WIKI))));\n\n        when(this.resourceReferenceResolver.resolve(linkReference, null)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(absoluteLinkReference, null)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(absoluteLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(xobjectLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(xobjectLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.relativeEntityReferenceResolver.resolve(xobjectLinkReference,null, null))\n            .thenReturn(relativeLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null))\n            .thenReturn(relativeLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(absoluteLinkReference, null, null))\n            .thenReturn(relativeAbsoluteLinkReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.defaultEntityReferenceSerializer.serialize(newLinkTarget, documentReference))\n            .thenReturn(\"xwiki:X.Y.WebHome\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.Y\", linkBlock.getReference().getReference());\n        assertEquals(\"xwiki:X.Y.WebHome\", absoluteLinkBlock.getReference().getReference());\n        assertEquals(\"X.Y\", xobjectLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, linkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameImage",
        "raw_code": "@Test\n    void renameImage() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldImageTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldImageTargetAttachment = new AttachmentReference(\"attachment.txt\", oldImageTarget);\n        DocumentReference newImageTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newImageTargetAttachment = new AttachmentReference(\"attachment.txt\", newImageTarget);\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference imageReference = new AttachmentResourceReference(\"A.B@attachment.txt\");\n        ImageBlock imageBlock = new ImageBlock(imageReference, false);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(imageBlock));\n\n        EntityReference relativeReference = new EntityReference(\"attachment.txt\", EntityType.ATTACHMENT,\n            new EntityReference(\"B\", EntityType.DOCUMENT, new EntityReference(\"A\", EntityType.SPACE)));\n\n        when(this.resourceReferenceResolver.resolve(imageReference, null)).thenReturn(oldImageTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, documentReference))\n            .thenReturn(oldImageTargetAttachment);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldImageTargetAttachment))\n            .thenReturn(oldImageTarget);\n        when(this.relativeEntityReferenceResolver.resolve(imageReference, null, null)).thenReturn(relativeReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newImageTargetAttachment, documentReference))\n            .thenReturn(\"X.Y@attachment.txt\");\n\n        updater.update(documentReference, oldImageTarget, newImageTarget);\n\n        assertEquals(\"X.Y@attachment.txt\", imageBlock.getReference().getReference());\n        assertEquals(ResourceType.ATTACHMENT, imageBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameImage",
        "raw_code": "@Test\n    void renameImage() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldImageTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldImageTargetAttachment = new AttachmentReference(\"attachment.txt\", oldImageTarget);\n        DocumentReference newImageTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newImageTargetAttachment = new AttachmentReference(\"attachment.txt\", newImageTarget);\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference imageReference = new AttachmentResourceReference(\"A.B@attachment.txt\");\n        ImageBlock imageBlock = new ImageBlock(imageReference, false);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(imageBlock));\n\n        EntityReference relativeReference = new EntityReference(\"attachment.txt\", EntityType.ATTACHMENT,\n            new EntityReference(\"B\", EntityType.DOCUMENT, new EntityReference(\"A\", EntityType.SPACE)));\n\n        when(this.resourceReferenceResolver.resolve(imageReference, null)).thenReturn(oldImageTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, documentReference))\n            .thenReturn(oldImageTargetAttachment);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldImageTargetAttachment))\n            .thenReturn(oldImageTarget);\n        when(this.relativeEntityReferenceResolver.resolve(imageReference, null, null)).thenReturn(relativeReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newImageTargetAttachment, documentReference))\n            .thenReturn(\"X.Y@attachment.txt\");\n\n        updater.update(documentReference, oldImageTarget, newImageTarget);\n\n        assertEquals(\"X.Y@attachment.txt\", imageBlock.getReference().getReference());\n        assertEquals(ResourceType.ATTACHMENT, imageBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameAttachment",
        "raw_code": "@Test\n    void renameAttachment() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldLinkTargetAttachment = new AttachmentReference(\"attachment.txt\", oldLinkTarget);\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newLinkTargetAttachment = new AttachmentReference(\"attachment.txt\", newLinkTarget);\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference linkReference = new AttachmentResourceReference(\"A.B@attachment.txt\");\n        LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(linkBlock));\n\n        EntityReference relativeReference = new EntityReference(\"attachment.txt\", EntityType.ATTACHMENT,\n            new EntityReference(\"B\", EntityType.DOCUMENT, new EntityReference(\"A\", EntityType.SPACE)));\n\n        when(this.resourceReferenceResolver.resolve(linkReference, null))\n            .thenReturn(oldLinkTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference))\n            .thenReturn(oldLinkTargetAttachment);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTargetAttachment)).thenReturn(oldLinkTarget);\n        when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null)).thenReturn(relativeReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTargetAttachment, documentReference))\n            .thenReturn(\"X.Y@attachment.txt\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.Y@attachment.txt\", linkBlock.getReference().getReference());\n        assertEquals(ResourceType.ATTACHMENT, linkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameAttachment",
        "raw_code": "@Test\n    void renameAttachment() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldLinkTargetAttachment = new AttachmentReference(\"attachment.txt\", oldLinkTarget);\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newLinkTargetAttachment = new AttachmentReference(\"attachment.txt\", newLinkTarget);\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference linkReference = new AttachmentResourceReference(\"A.B@attachment.txt\");\n        LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(linkBlock));\n\n        EntityReference relativeReference = new EntityReference(\"attachment.txt\", EntityType.ATTACHMENT,\n            new EntityReference(\"B\", EntityType.DOCUMENT, new EntityReference(\"A\", EntityType.SPACE)));\n\n        when(this.resourceReferenceResolver.resolve(linkReference, null))\n            .thenReturn(oldLinkTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference))\n            .thenReturn(oldLinkTargetAttachment);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTargetAttachment)).thenReturn(oldLinkTarget);\n        when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null)).thenReturn(relativeReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTargetAttachment, documentReference))\n            .thenReturn(\"X.Y@attachment.txt\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.Y@attachment.txt\", linkBlock.getReference().getReference());\n        assertEquals(ResourceType.ATTACHMENT, linkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameNonTerminalDocumentLinks",
        "raw_code": "@Test\n    void renameNonTerminalDocumentLinks() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a non-terminal document to another non-terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"WebHome\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"WebHome\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"A.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n        EntityReference relativeReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"A\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n        EntityReference relativeSpaceReference = new EntityReference(\"A\", EntityType.SPACE);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(documentLinkBlock, spaceLinkBlock));\n\n        // Doc link\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.WebHome\");\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null)).thenReturn(relativeReference);\n\n        // Space link\n        SpaceReference spaceReference = oldLinkTarget.getLastSpaceReference();\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(spaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, documentReference))\n            .thenReturn(spaceReference);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(spaceReference)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget.getLastSpaceReference(), documentReference))\n            .thenReturn(\"X\");\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.WebHome\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        assertEquals(\"X\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameNonTerminalDocumentLinks",
        "raw_code": "@Test\n    void renameNonTerminalDocumentLinks() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a non-terminal document to another non-terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"WebHome\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"WebHome\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"A.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n        EntityReference relativeReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"A\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n        EntityReference relativeSpaceReference = new EntityReference(\"A\", EntityType.SPACE);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(documentLinkBlock, spaceLinkBlock));\n\n        // Doc link\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.WebHome\");\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null)).thenReturn(relativeReference);\n\n        // Space link\n        SpaceReference spaceReference = oldLinkTarget.getLastSpaceReference();\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(spaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, documentReference))\n            .thenReturn(spaceReference);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(spaceReference)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget.getLastSpaceReference(), documentReference))\n            .thenReturn(\"X\");\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.WebHome\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        assertEquals(\"X\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameNonTerminalToTerminalDocumentLinks",
        "raw_code": "@Test\n    void renameNonTerminalToTerminalDocumentLinks() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a non-terminal document to a terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"WebHome\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"A.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n\n        EntityReference relativeReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"A\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n\n        EntityReference relativeSpaceReference = new EntityReference(\"A\", EntityType.SPACE);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(documentLinkBlock, spaceLinkBlock));\n\n        // Doc link\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null)).thenReturn(relativeReference);\n\n        // Space link\n        SpaceReference spaceReference = oldLinkTarget.getLastSpaceReference();\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(spaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, documentReference))\n            .thenReturn(spaceReference);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(spaceReference)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget.getLastSpaceReference(), documentReference))\n            .thenReturn(\"X\");\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        // Note that both resulting renamed back-links are of type document. (i.e. the space link was converted to a doc\n        // link)\n        assertEquals(\"X.Y\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        assertEquals(\"X.Y\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameNonTerminalToTerminalDocumentLinks",
        "raw_code": "@Test\n    void renameNonTerminalToTerminalDocumentLinks() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a non-terminal document to a terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"WebHome\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"A.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n\n        EntityReference relativeReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"A\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n\n        EntityReference relativeSpaceReference = new EntityReference(\"A\", EntityType.SPACE);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(documentLinkBlock, spaceLinkBlock));\n\n        // Doc link\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null)).thenReturn(relativeReference);\n\n        // Space link\n        SpaceReference spaceReference = oldLinkTarget.getLastSpaceReference();\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(spaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, documentReference))\n            .thenReturn(spaceReference);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(spaceReference)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget.getLastSpaceReference(), documentReference))\n            .thenReturn(\"X\");\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        // Note that both resulting renamed back-links are of type document. (i.e. the space link was converted to a doc\n        // link)\n        assertEquals(\"X.Y\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        assertEquals(\"X.Y\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateFromMacros",
        "raw_code": "@Test\n    void updateFromMacros(MockitoComponentManager componentManager) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        Map<String, String> includeParameters = new HashMap<String, String>();\n        includeParameters.put(\"reference\", \"A.B\");\n        MacroBlock includeMacroBlock1 = new MacroBlock(\"include\", includeParameters, false);\n        includeMacroBlock1.setParent(xdom);\n\n        Map<String, String> includeOldParameters = new HashMap<String, String>();\n        includeOldParameters.put(\"document\", \"A.B\");\n        MacroBlock includeMacroBlock2 = new MacroBlock(\"include\", includeOldParameters, false);\n        includeMacroBlock2.setParent(xdom);\n\n        Map<String, String> displayParameters = new HashMap<String, String>();\n        displayParameters.put(\"reference\", \"A.B\");\n        MacroBlock displayMacroBlock = new MacroBlock(\"display\", displayParameters, false);\n        displayMacroBlock.setParent(xdom);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(includeMacroBlock1, includeMacroBlock2, displayMacroBlock));\n\n        ResourceReference macroResourceReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n\n        when(this.resourceReferenceResolver.resolve(macroResourceReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(macroResourceReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n\n        MacroRefactoring includeMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"include\");\n        MacroRefactoring displayMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"display\");\n        when(displayMacroRefactoring.replaceReference(any(), any(), any(DocumentReference.class), any(), anyBoolean()\n            , any()))\n            .thenReturn(Optional.of(displayMacroBlock));\n        when(this.documentAccessBridge.getDocumentInstance(documentReference)).thenReturn(document);\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock1, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock2, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(displayMacroRefactoring).replaceReference(displayMacroBlock, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(this.mutableRenderingContext, times(3)).push(any(), any(), eq(Syntax.XWIKI_2_1), any(), anyBoolean(),\n            any());\n        verify(this.mutableRenderingContext, times(3)).pop();\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateFromMacros",
        "raw_code": "@Test\n    void updateFromMacros(MockitoComponentManager componentManager) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        Map<String, String> includeParameters = new HashMap<String, String>();\n        includeParameters.put(\"reference\", \"A.B\");\n        MacroBlock includeMacroBlock1 = new MacroBlock(\"include\", includeParameters, false);\n        includeMacroBlock1.setParent(xdom);\n\n        Map<String, String> includeOldParameters = new HashMap<String, String>();\n        includeOldParameters.put(\"document\", \"A.B\");\n        MacroBlock includeMacroBlock2 = new MacroBlock(\"include\", includeOldParameters, false);\n        includeMacroBlock2.setParent(xdom);\n\n        Map<String, String> displayParameters = new HashMap<String, String>();\n        displayParameters.put(\"reference\", \"A.B\");\n        MacroBlock displayMacroBlock = new MacroBlock(\"display\", displayParameters, false);\n        displayMacroBlock.setParent(xdom);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(includeMacroBlock1, includeMacroBlock2, displayMacroBlock));\n\n        ResourceReference macroResourceReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n\n        when(this.resourceReferenceResolver.resolve(macroResourceReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(macroResourceReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n\n        MacroRefactoring includeMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"include\");\n        MacroRefactoring displayMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"display\");\n        when(displayMacroRefactoring.replaceReference(any(), any(), any(DocumentReference.class), any(), anyBoolean()\n            , any()))\n            .thenReturn(Optional.of(displayMacroBlock));\n        when(this.documentAccessBridge.getDocumentInstance(documentReference)).thenReturn(document);\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock1, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock2, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(displayMacroRefactoring).replaceReference(displayMacroBlock, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(this.mutableRenderingContext, times(3)).push(any(), any(), eq(Syntax.XWIKI_2_1), any(), anyBoolean(),\n            any());\n        verify(this.mutableRenderingContext, times(3)).pop();\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateAttachments",
        "raw_code": "@Test\n    void updateAttachments() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference sourceDocument = new DocumentReference(\"wiki\", \"Space\", \"Source\");\n        AttachmentReference oldLinkTarget = new AttachmentReference(\"oldname.txt\", sourceDocument);\n        DocumentReference targetDocument = new DocumentReference(\"wiki\", \"Space\", \"Target\");\n        AttachmentReference newLinkTarget = new AttachmentReference(\"newname.txt\", targetDocument);\n        ResourceReference resourceReference = new ResourceReference(\"oldname.txt\", ResourceType.ATTACHMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), resourceReference, false);\n\n        XWikiDocument document = mock(XWikiDocument.class);\n        XDOM xdom = mock(XDOM.class);\n\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getTranslationLocales(this.xcontext)).thenReturn(List.of());\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n        when(document.getXDOM()).thenReturn(xdom);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(documentLinkBlock));\n        when(this.resourceReferenceResolver.resolve(resourceReference, null)).thenReturn(\n            new AttachmentReference(\"oldname.txt\", new DocumentReference(\"wiki\", \"Main\", \"WebHome\")));\n        when(this.resourceReferenceResolver.resolve(resourceReference, null, documentReference)).thenReturn(\n            oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\n            \"newname.txt\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(this.progressManager).pushLevelProgress(1, updater);\n        verify(document).setContent(xdom);\n        verify(document).setContentDirty(false);\n        verify(document).setMetaDataDirty(true);\n        verify(this.xcontext.getWiki()).saveDocument(document, \"Renamed back-links.\", false, this.xcontext);\n        verify(this.progressManager).popLevelProgress(updater);\n        assertEquals(1, this.logCapture.size());\n        assertEquals(\n            \"The links from [null] that were targeting [Attachment wiki:Space.Source@oldname.txt] have \"\n                + \"been updated to target [Attachment wiki:Space.Target@newname.txt].\", this.logCapture.getMessage(0));\n        assertEquals(Level.INFO, this.logCapture.getLogEvent(0).getLevel());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateAttachments",
        "raw_code": "@Test\n    void updateAttachments() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference sourceDocument = new DocumentReference(\"wiki\", \"Space\", \"Source\");\n        AttachmentReference oldLinkTarget = new AttachmentReference(\"oldname.txt\", sourceDocument);\n        DocumentReference targetDocument = new DocumentReference(\"wiki\", \"Space\", \"Target\");\n        AttachmentReference newLinkTarget = new AttachmentReference(\"newname.txt\", targetDocument);\n        ResourceReference resourceReference = new ResourceReference(\"oldname.txt\", ResourceType.ATTACHMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), resourceReference, false);\n\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        XDOM xdom = mock(XDOM.class);\n\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getTranslationLocales(this.xcontext)).thenReturn(List.of());\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n        when(document.getXDOM()).thenReturn(xdom);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(documentLinkBlock));\n        when(this.resourceReferenceResolver.resolve(resourceReference, null)).thenReturn(\n            new AttachmentReference(\"oldname.txt\", new DocumentReference(\"wiki\", \"Main\", \"WebHome\")));\n        when(this.resourceReferenceResolver.resolve(resourceReference, null, documentReference)).thenReturn(\n            oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\n            \"newname.txt\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(this.progressManager).pushLevelProgress(1, updater);\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateFromLinksAndMacros",
        "raw_code": "@Test\n    void updateFromLinksAndMacros(MockitoComponentManager componentManager) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        Map<String, String> includeParameters = new HashMap<>();\n        includeParameters.put(\"reference\", \"A.B\");\n        MacroBlock includeMacroBlock = new MacroBlock(\"include\", includeParameters, false);\n\n        ResourceReference resourceReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), resourceReference, false);\n        EntityReference relativeReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(includeMacroBlock, documentLinkBlock));\n\n        when(this.resourceReferenceResolver.resolve(resourceReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(resourceReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.relativeEntityReferenceResolver.resolve(resourceReference, null, null)).thenReturn(relativeReference);\n\n        MacroRefactoring includeMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"include\");\n        when(this.documentAccessBridge.getDocumentInstance(documentReference)).thenReturn(document);\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        assertEquals(\"X.Y\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateFromLinksAndMacros",
        "raw_code": "@Test\n    void updateFromLinksAndMacros(MockitoComponentManager componentManager) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        Map<String, String> includeParameters = new HashMap<>();\n        includeParameters.put(\"reference\", \"A.B\");\n        MacroBlock includeMacroBlock = new MacroBlock(\"include\", includeParameters, false);\n\n        ResourceReference resourceReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), resourceReference, false);\n        EntityReference relativeReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(includeMacroBlock, documentLinkBlock));\n\n        when(this.resourceReferenceResolver.resolve(resourceReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(resourceReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.relativeEntityReferenceResolver.resolve(resourceReference, null, null)).thenReturn(relativeReference);\n\n        MacroRefactoring includeMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"include\");\n        when(this.documentAccessBridge.getDocumentInstance(documentReference)).thenReturn(document);\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        assertEquals(\"X.Y\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "verifyDocumentSave",
        "raw_code": "private void verifyDocumentSave(XWikiDocument document, String comment, boolean minorEdit, boolean relative)\n        throws Exception\n    {\n        // Verify we preserve the content author.\n        verify(document).setContentDirty(false);\n        // Verify the version is going to be incremented.\n        verify(document).setMetaDataDirty(true);\n        verify(this.xcontext.getWiki()).saveDocument(document, comment, minorEdit, this.xcontext);\n        ILoggingEvent logEvent = this.logCapture.getLogEvent(this.logIndex++);\n        if (relative) {\n            assertEquals(\"Updated the relative links from [{}].\", logEvent.getMessage());\n        } else {\n            assertEquals(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                logEvent.getMessage());\n        }\n        assertEquals(Level.INFO, logEvent.getLevel());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "verifyDocumentSave",
        "raw_code": "private void verifyDocumentSave(XWikiDocument document, boolean relative)\n        throws Exception\n    {\n        // Verify we preserve the content author.\n        verify(document).setContentDirty(false);\n        // Verify the version is going to be incremented.\n        verify(document).setMetaDataDirty(true);\n        String comment = (relative) ? TRANSLATED_RELATIVE_COMMENT : TRANSLATED_BACKLINK_COMMENT;\n        verify(this.xcontext.getWiki()).saveDocument(document, comment, true, this.xcontext);\n        verify(document.getAuthors()).setOriginalMetadataAuthor(currentUserReference);\n        ILoggingEvent logEvent = this.logCapture.getLogEvent(this.logIndex++);\n        if (relative) {\n            assertEquals(\"Updated the relative links from [{}].\", logEvent.getMessage());\n        } else {\n            assertEquals(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                logEvent.getMessage());\n        }\n        assertEquals(Level.INFO, logEvent.getLevel());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateAndTranslations",
        "raw_code": "@Test\n    void updateAndTranslations() throws Exception\n    {\n        DocumentReference baseDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument baseDocument = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(baseDocumentReference, this.xcontext)).thenReturn(baseDocument);\n        when(baseDocument.getDocumentReference()).thenReturn(baseDocumentReference);\n\n        when(baseDocument.getTranslationLocales(xcontext)).thenReturn(List.of(Locale.FRENCH, Locale.ENGLISH));\n        DocumentReference frenchDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\", Locale.FRENCH);\n        XWikiDocument frenchDocument = mock(XWikiDocument.class);\n        when(baseDocument.getTranslatedDocument(Locale.FRENCH, xcontext)).thenReturn(frenchDocument);\n        when(frenchDocument.getDocumentReference()).thenReturn(frenchDocumentReference);\n\n        DocumentReference englishDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\", Locale.ENGLISH);\n        XWikiDocument englishDocument = mock(XWikiDocument.class);\n        when(baseDocument.getTranslatedDocument(Locale.ENGLISH, xcontext)).thenReturn(englishDocument);\n        when(englishDocument.getDocumentReference()).thenReturn(englishDocumentReference);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        List<XWikiDocument> documentsToUpdate = List.of(baseDocument, frenchDocument, englishDocument);\n\n        for (XWikiDocument xWikiDocument : documentsToUpdate) {\n            DocumentReference documentReference = xWikiDocument.getDocumentReference();\n            when(xWikiDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n            XDOM xdom = mock(XDOM.class);\n            when(xWikiDocument.getXDOM()).thenReturn(xdom);\n\n            ResourceReference linkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n            EntityReference relativeReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n                new EntityReference(\"A\", EntityType.SPACE));\n            LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n            when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(linkBlock));\n\n            when(this.resourceReferenceResolver.resolve(linkReference, null))\n                .thenReturn(oldLinkTarget);\n            when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference))\n                .thenReturn(oldLinkTarget);\n            when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n            when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n            when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null))\n                .thenReturn(relativeReference);\n        }\n        updater.update(baseDocumentReference, oldLinkTarget, newLinkTarget);\n\n        for (XWikiDocument xWikiDocument : documentsToUpdate) {\n            verifyDocumentSave(xWikiDocument, \"Renamed back-links.\", false, false);\n            LinkBlock linkBlock =\n                (LinkBlock) xWikiDocument.getXDOM().getBlocks(mock(BlockMatcher.class), Block.Axes.DESCENDANT).get(0);\n            assertEquals(\"X.Y\", linkBlock.getReference().getReference());\n            assertEquals(ResourceType.DOCUMENT, linkBlock.getReference().getType());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateAndTranslations",
        "raw_code": "@Test\n    void updateAndTranslations() throws Exception\n    {\n        DocumentReference baseDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument baseDocument = mock(XWikiDocument.class);\n        DocumentAuthors baseAuthors = mock(DocumentAuthors.class);\n        when(baseDocument.getAuthors()).thenReturn(baseAuthors);\n        when(this.xcontext.getWiki().getDocument(baseDocumentReference, this.xcontext)).thenReturn(baseDocument);\n        when(baseDocument.getDocumentReference()).thenReturn(baseDocumentReference);\n\n        when(baseDocument.getTranslationLocales(xcontext)).thenReturn(List.of(Locale.FRENCH, Locale.ENGLISH));\n        DocumentReference frenchDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\", Locale.FRENCH);\n        XWikiDocument frenchDocument = mock(XWikiDocument.class);\n        DocumentAuthors frenchAuthors = mock(DocumentAuthors.class);\n        when(frenchDocument.getAuthors()).thenReturn(frenchAuthors);\n        when(baseDocument.getTranslatedDocument(Locale.FRENCH, xcontext)).thenReturn(frenchDocument);\n        when(frenchDocument.getDocumentReference()).thenReturn(frenchDocumentReference);\n\n        DocumentReference englishDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\", Locale.ENGLISH);\n        XWikiDocument englishDocument = mock(XWikiDocument.class);\n        DocumentAuthors englishAuthors = mock(DocumentAuthors.class);\n        when(englishDocument.getAuthors()).thenReturn(englishAuthors);\n        when(baseDocument.getTranslatedDocument(Locale.ENGLISH, xcontext)).thenReturn(englishDocument);\n        when(englishDocument.getDocumentReference()).thenReturn(englishDocumentReference);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        List<XWikiDocument> documentsToUpdate = List.of(baseDocument, frenchDocument, englishDocument);\n\n        for (XWikiDocument xWikiDocument : documentsToUpdate) {\n            DocumentReference documentReference = xWikiDocument.getDocumentReference();\n            when(xWikiDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n            XDOM xdom = mock(XDOM.class);\n            when(xWikiDocument.getXDOM()).thenReturn(xdom);\n\n            ResourceReference linkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n            EntityReference relativeReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n                new EntityReference(\"A\", EntityType.SPACE));\n            LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n            when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(linkBlock));\n\n            when(this.resourceReferenceResolver.resolve(linkReference, null))\n                .thenReturn(oldLinkTarget);\n            when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference))\n                .thenReturn(oldLinkTarget);\n            when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n            when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n            when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null))\n                .thenReturn(relativeReference);\n        }\n        updater.update(baseDocumentReference, oldLinkTarget, newLinkTarget);\n\n        for (XWikiDocument xWikiDocument : documentsToUpdate) {\n            verifyDocumentSave(xWikiDocument, false);\n            LinkBlock linkBlock =\n                (LinkBlock) xWikiDocument.getXDOM().getBlocks(mock(BlockMatcher.class), Block.Axes.DESCENDANT).get(0);\n            assertEquals(\"X.Y\", linkBlock.getReference().getReference());\n            assertEquals(ResourceType.DOCUMENT, linkBlock.getReference().getType());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "list",
        "raw_code": "@Override\n    public final PageSet<? extends StorageMetadata> list(String container,\n            ListContainerOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var delimiter = options.getDelimiter();\n        if (\"\".equals(delimiter)) {\n            delimiter = null;\n        } else if (delimiter != null && !delimiter.equals(\"/\")) {\n            throw new IllegalArgumentException(\"Delimiters other than / not supported\");\n        }\n\n        var prefix = options.getPrefix();\n        var dirPrefix = root.resolve(container);\n        if (prefix != null) {\n            int idx = prefix.lastIndexOf('/');\n            if (idx != -1) {\n                dirPrefix = dirPrefix.resolve(prefix.substring(0, idx));\n            }\n        } else {\n            prefix = \"\";\n        }\n        var pathPrefix = root.resolve(container).resolve(prefix);\n        var set = ImmutableSortedSet.<StorageMetadata>naturalOrder();\n        try {\n            listHelper(set, container, dirPrefix, pathPrefix, delimiter);\n            var sorted = set.build();\n            if (options.getMarker() != null) {\n                var found = false;\n                for (var blob : sorted) {\n                    if (blob.getName().compareTo(options.getMarker()) > 0) {\n                        sorted = sorted.tailSet(blob);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    sorted = ImmutableSortedSet.of();\n                }\n            }\n            String marker = null;\n            if (options.getMaxResults() != null) {\n                // TODO: efficiency?\n                var temp = ImmutableSortedSet.copyOf(sorted.stream().limit(options.getMaxResults().intValue()).collect(Collectors.toSet()));\n                if (!temp.isEmpty()) {\n                    var next = sorted.higher(temp.last());\n                    if (next != null) {\n                        marker = temp.last().getName();\n                    }\n                }\n                sorted = temp;\n            }\n            return new PageSetImpl<StorageMetadata>(sorted, marker);\n        } catch (IOException ioe) {\n            logger.error(\"unexpected exception\", ioe);\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "list",
        "raw_code": "@Override\n    public final PageSet<? extends StorageMetadata> list(String container,\n            ListContainerOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var delimiter = options.getDelimiter();\n        if (\"\".equals(delimiter)) {\n            delimiter = null;\n        } else if (delimiter != null && !delimiter.equals(\"/\")) {\n            throw new IllegalArgumentException(\"Delimiters other than / not supported\");\n        }\n\n        var prefix = options.getPrefix();\n        var dirPrefix = root.resolve(container);\n        if (prefix != null) {\n            int idx = prefix.lastIndexOf('/');\n            if (idx != -1) {\n                dirPrefix = dirPrefix.resolve(prefix.substring(0, idx));\n            }\n        } else {\n            prefix = \"\";\n        }\n        var containerPath = root.resolve(container);\n        var pathPrefix = containerPath.resolve(prefix).normalize();\n        checkValidPath(containerPath, pathPrefix);\n        logger.debug(\"Listing blobs at: {}\", pathPrefix);\n        var set = ImmutableSortedSet.<StorageMetadata>naturalOrder();\n        try {\n            listHelper(set, container, dirPrefix, pathPrefix, delimiter);\n            var sorted = set.build();\n            if (options.getMarker() != null) {\n                var found = false;\n                for (var blob : sorted) {\n                    if (blob.getName().compareTo(options.getMarker()) > 0) {\n                        sorted = sorted.tailSet(blob);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    sorted = ImmutableSortedSet.of();\n                }\n            }\n            String marker = null;\n            if (options.getMaxResults() != null) {\n                // TODO: efficiency?\n                var temp = ImmutableSortedSet.copyOf(sorted.stream().limit(options.getMaxResults().intValue()).collect(Collectors.toSet()));\n                if (!temp.isEmpty()) {\n                    var next = sorted.higher(temp.last());\n                    if (next != null) {\n                        marker = temp.last().getName();\n                    }\n                }\n                sorted = temp;\n            }\n            return new PageSetImpl<StorageMetadata>(sorted, marker);\n        } catch (IOException ioe) {\n            logger.error(\"unexpected exception\", ioe);\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key);\n        checkValidPath(containerPath, path);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "putBlob",
        "raw_code": "@Override\n    public final String putBlob(String container, Blob blob, PutOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var path = root.resolve(container).resolve(blob.getMetadata().getName());\n        // TODO: should we use a known suffix to filter these out during list?\n        var tmpPath = root.resolve(container).resolve(blob.getMetadata().getName() + \"-\" + UUID.randomUUID());\n        logger.debug(\"Creating blob at: {}\", path);\n\n        if (blob.getMetadata().getName().endsWith(\"/\")) {\n            try {\n                logger.debug(\"Creating directory blob: {}\", path);\n                Files.createDirectories(path);\n            } catch (FileAlreadyExistsException faee) {\n                logger.debug(\"Parent directories already exist: {}\", path.getParent());\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            try {\n                writeCommonMetadataAttr(view, blob);\n                view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(DIRECTORY_MD5));\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            return BaseEncoding.base16().lowerCase().encode(DIRECTORY_MD5);\n        }\n\n        // Create parent directories.\n        try {\n            Files.createDirectories(path.getParent());\n        } catch (FileAlreadyExistsException faee) {\n            logger.debug(\"Parent directories already exist: {}\", path.getParent());\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n\n        var metadata = blob.getMetadata().getContentMetadata();\n        try (var is = new HashingInputStream(Hashing.md5(), blob.getPayload().openStream());\n             var os = Files.newOutputStream(tmpPath)) {\n            var count = is.transferTo(os);\n            var actualHashCode = is.hash();\n            var expectedHashCode = metadata.getContentMD5AsHashCode();\n            if (expectedHashCode != null && !actualHashCode.equals(expectedHashCode)) {\n                Files.delete(tmpPath);\n                throw returnResponseException(400);\n            }\n\n            var view = Files.getFileAttributeView(tmpPath, UserDefinedFileAttributeView.class);\n            if (view != null) {\n                try {\n                    var eTag = actualHashCode.asBytes();\n                    view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(eTag));\n                    writeStringAttributeIfPresent(view, XATTR_CACHE_CONTROL, metadata.getCacheControl());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_DISPOSITION, metadata.getContentDisposition());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_ENCODING, metadata.getContentEncoding());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_LANGUAGE, metadata.getContentLanguage());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_TYPE, metadata.getContentType());\n                    var expires = metadata.getExpires();\n                    if (expires != null) {\n                        ByteBuffer buf = ByteBuffer.allocate(Longs.BYTES).putLong(expires.getTime());\n                        buf.flip();\n                        view.write(XATTR_EXPIRES, buf);\n                    }\n                    writeStringAttributeIfPresent(view, XATTR_STORAGE_TIER, blob.getMetadata().getTier().toString());\n                    for (var entry : blob.getMetadata().getUserMetadata().entrySet()) {\n                        writeStringAttributeIfPresent(view, XATTR_USER_METADATA_PREFIX + entry.getKey(), entry.getValue());\n                    }\n                } catch (IOException e) {\n                    // TODO:\n                    //logger.debug(\"xattrs not supported on %s\", path);\n                }\n            }\n\n            Files.move(tmpPath, path, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n\n            setBlobAccess(container, blob.getMetadata().getName(), options.getBlobAccess());\n\n            return \"\\\"\" + actualHashCode + \"\\\"\";\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "putBlob",
        "raw_code": "@Override\n    public final String putBlob(String container, Blob blob, PutOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(blob.getMetadata().getName());\n        checkValidPath(containerPath, path);\n        // TODO: should we use a known suffix to filter these out during list?\n        var tmpPath = root.resolve(container).resolve(blob.getMetadata().getName() + \"-\" + UUID.randomUUID());\n        logger.debug(\"Creating blob at: {}\", path);\n\n        if (blob.getMetadata().getName().endsWith(\"/\")) {\n            try {\n                logger.debug(\"Creating directory blob: {}\", path);\n                Files.createDirectories(path);\n            } catch (FileAlreadyExistsException faee) {\n                logger.debug(\"Parent directories already exist: {}\", path.getParent());\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            try {\n                writeCommonMetadataAttr(view, blob);\n                view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(DIRECTORY_MD5));\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            return BaseEncoding.base16().lowerCase().encode(DIRECTORY_MD5);\n        }\n\n        // Create parent directories.\n        try {\n            Files.createDirectories(path.getParent());\n        } catch (FileAlreadyExistsException faee) {\n            logger.debug(\"Parent directories already exist: {}\", path.getParent());\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n\n        var metadata = blob.getMetadata().getContentMetadata();\n        try (var is = new HashingInputStream(Hashing.md5(), blob.getPayload().openStream());\n             var os = Files.newOutputStream(tmpPath)) {\n            var count = is.transferTo(os);\n            var actualHashCode = is.hash();\n            var expectedHashCode = metadata.getContentMD5AsHashCode();\n            if (expectedHashCode != null && !actualHashCode.equals(expectedHashCode)) {\n                Files.delete(tmpPath);\n                throw returnResponseException(400);\n            }\n\n            var view = Files.getFileAttributeView(tmpPath, UserDefinedFileAttributeView.class);\n            if (view != null) {\n                try {\n                    var eTag = actualHashCode.asBytes();\n                    view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(eTag));\n                    writeStringAttributeIfPresent(view, XATTR_CACHE_CONTROL, metadata.getCacheControl());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_DISPOSITION, metadata.getContentDisposition());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_ENCODING, metadata.getContentEncoding());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_LANGUAGE, metadata.getContentLanguage());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_TYPE, metadata.getContentType());\n                    var expires = metadata.getExpires();\n                    if (expires != null) {\n                        ByteBuffer buf = ByteBuffer.allocate(Longs.BYTES).putLong(expires.getTime());\n                        buf.flip();\n                        view.write(XATTR_EXPIRES, buf);\n                    }\n                    writeStringAttributeIfPresent(view, XATTR_STORAGE_TIER, blob.getMetadata().getTier().toString());\n                    for (var entry : blob.getMetadata().getUserMetadata().entrySet()) {\n                        writeStringAttributeIfPresent(view, XATTR_USER_METADATA_PREFIX + entry.getKey(), entry.getValue());\n                    }\n                } catch (IOException e) {\n                    // TODO:\n                    //logger.debug(\"xattrs not supported on %s\", path);\n                }\n            }\n\n            Files.move(tmpPath, path, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n\n            setBlobAccess(container, blob.getMetadata().getName(), options.getBlobAccess());\n\n            return \"\\\"\" + actualHashCode + \"\\\"\";\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "removeBlob",
        "raw_code": "@Override\n    public final void removeBlob(String container, String key) {\n        try {\n            var containerPath = root.resolve(container);\n            var path = containerPath.resolve(key);\n            Files.delete(path);\n            removeEmptyParentDirectories(containerPath, path.getParent());\n        } catch (NoSuchFileException nsfe) {\n            return;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "removeBlob",
        "raw_code": "@Override\n    public final void removeBlob(String container, String key) {\n        try {\n            var containerPath = root.resolve(container);\n            var path = containerPath.resolve(key).normalize();\n            checkValidPath(containerPath, path);\n            logger.debug(\"Deleting blob at: {}\", path);\n            Files.delete(path);\n            removeEmptyParentDirectories(containerPath, path.getParent());\n        } catch (NoSuchFileException nsfe) {\n            return;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlobAccess",
        "raw_code": "@Override\n    public final BlobAccess getBlobAccess(String container, String key) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = Files.getPosixFilePermissions(path);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n        return permissions.contains(PosixFilePermission.OTHERS_READ) ?\n                BlobAccess.PUBLIC_READ : BlobAccess.PRIVATE;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlobAccess",
        "raw_code": "@Override\n    public final BlobAccess getBlobAccess(String container, String key) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key).normalize();\n        checkValidPath(containerPath, path);\n\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = Files.getPosixFilePermissions(path);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n        return permissions.contains(PosixFilePermission.OTHERS_READ) ?\n                BlobAccess.PUBLIC_READ : BlobAccess.PRIVATE;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "setBlobAccess",
        "raw_code": "@Override\n    public final void setBlobAccess(String container, String key, BlobAccess access) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = new HashSet<>(Files.getPosixFilePermissions(path));\n            if (access == BlobAccess.PRIVATE) {\n                permissions.remove(PosixFilePermission.OTHERS_READ);\n            } else if (access == BlobAccess.PUBLIC_READ) {\n                permissions.add(PosixFilePermission.OTHERS_READ);\n            }\n            Files.setPosixFilePermissions(path, permissions);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "setBlobAccess",
        "raw_code": "@Override\n    public final void setBlobAccess(String container, String key, BlobAccess access) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key).normalize();\n        checkValidPath(containerPath, path);\n\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = new HashSet<>(Files.getPosixFilePermissions(path));\n            if (access == BlobAccess.PRIVATE) {\n                permissions.remove(PosixFilePermission.OTHERS_READ);\n            } else if (access == BlobAccess.PUBLIC_READ) {\n                permissions.add(PosixFilePermission.OTHERS_READ);\n            }\n            Files.setPosixFilePermissions(path, permissions);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "opal",
    "cve_id": "CVE-2025-27101",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "fca7dc9c8348064741b2e8b2c31b66660a935743",
    "short_hash": "fca7dc9c",
    "vulnerableMethods_before": [
      {
        "filename": "FilesResource.java",
        "method_name": "moveToFolder",
        "raw_code": "private Response moveToFolder(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      Response check = checkSourceFile(resolveFileInFileSystem(sourcePath));\n      if (check != null) return check;\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        sourceFile.moveTo(destinationFile);\n      }\n    }\n\n    return Response.ok().build();\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FilesResource.java",
        "method_name": "moveToFolder",
        "raw_code": "private Response moveToFolder(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      Response check = checkSourceFile(resolveFileInFileSystem(sourcePath));\n      if (check != null) return check;\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        checkSourceIsNotParent(sourceFile, destinationFolder);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        sourceFile.moveTo(destinationFile);\n      }\n    }\n\n    return Response.ok().build();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "opal",
    "cve_id": "CVE-2025-27101",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "fca7dc9c8348064741b2e8b2c31b66660a935743",
    "short_hash": "fca7dc9c",
    "vulnerableMethods_before": [
      {
        "filename": "FilesResource.java",
        "method_name": "copyFrom",
        "raw_code": "private Response copyFrom(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n      if (!sourceFile.exists()) getPathNotExistResponse(sourcePath);\n      if (!sourceFile.isReadable()) {\n        return Response.status(Status.FORBIDDEN).entity(\"Source file is not readable: \" + sourcePath).build();\n      }\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        FileSelector selector = sourceFile.getType() == FileType.FOLDER ? Selectors.SELECT_ALL : Selectors.SELECT_SELF;\n        destinationFile.copyFrom(sourceFile, selector);\n      }\n    }\n\n    return Response.ok().build();\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FilesResource.java",
        "method_name": "copyFrom",
        "raw_code": "private Response copyFrom(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n      if (!sourceFile.exists()) getPathNotExistResponse(sourcePath);\n      if (!sourceFile.isReadable()) {\n        return Response.status(Status.FORBIDDEN).entity(\"Source file is not readable: \" + sourcePath).build();\n      }\n      checkSourceIsNotParent(sourceFile, destinationFolder);\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        FileSelector selector = sourceFile.getType() == FileType.FOLDER ? Selectors.SELECT_ALL : Selectors.SELECT_SELF;\n        destinationFile.copyFrom(sourceFile, selector);\n      }\n    }\n\n    return Response.ok().build();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-48063",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "2557813aef3b863988d6cca58de996e207086898",
    "short_hash": "2557813a",
    "vulnerableMethods_before": [
      {
        "filename": "RightsFilterListenerTest.java",
        "method_name": "checkEnforcedButAllowedRequiredRights",
        "raw_code": "@Test\n    void checkEnforcedButAllowedRequiredRights() throws AccessDeniedException\n    {\n        XWikiDocument document = createTestDocument();\n        XWikiDocument originalDocument = document.clone();\n        document.setOriginalDocument(originalDocument);\n\n        DocumentRequiredRights requiredRights = new DocumentRequiredRights(true,\n            Set.of(new DocumentRequiredRight(Right.SCRIPT, EntityType.DOCUMENT)));\n        DocumentRequiredRights previousRequiredRights = new DocumentRequiredRights(true, Set.of());\n\n        when(this.requiredRightsReader.readRequiredRights(same(document))).thenReturn(requiredRights);\n        when(this.requiredRightsReader.readRequiredRights(same(originalDocument))).thenReturn(previousRequiredRights);\n\n        UserUpdatingDocumentEvent event = new UserUpdatingDocumentEvent();\n        this.listener.onEvent(event, document, null);\n        assertFalse(event.isCanceled());\n        verify(this.authorization).checkAccess(Right.SCRIPT, null, document.getDocumentReference());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RightsFilterListenerTest.java",
        "method_name": "checkEnforcedButAllowedRequiredRights",
        "raw_code": "@Test\n    void checkEnforcedButAllowedRequiredRights() throws AccessDeniedException\n    {\n        XWikiDocument document = createTestDocument();\n        XWikiDocument originalDocument = document.clone();\n        document.setOriginalDocument(originalDocument);\n\n        DocumentRequiredRights requiredRights = new DocumentRequiredRights(true,\n            Set.of(new DocumentRequiredRight(Right.SCRIPT, EntityType.DOCUMENT)));\n        DocumentRequiredRights previousRequiredRights = new DocumentRequiredRights(true, Set.of());\n\n        when(this.requiredRightsReader.readRequiredRights(same(document))).thenReturn(requiredRights);\n        when(this.requiredRightsReader.readRequiredRights(same(originalDocument))).thenReturn(previousRequiredRights);\n\n        UserUpdatingDocumentEvent event = new UserUpdatingDocumentEvent();\n        this.listener.onEvent(event, document, null);\n        assertFalse(event.isCanceled());\n        verify(this.authorization).checkAccess(Right.SCRIPT, null, document.getDocumentReference());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-48063",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "2557813aef3b863988d6cca58de996e207086898",
    "short_hash": "2557813a",
    "vulnerableMethods_before": [
      {
        "filename": "RightsFilterListener.java",
        "method_name": "checkModifiedRequiredRights",
        "raw_code": "private void checkModifiedRequiredRights(DocumentReference user, XWikiDocument document,\n        CancelableEvent event)\n    {\n        XWikiDocument originalDocument = document.getOriginalDocument();\n        DocumentRequiredRights originalRequiredRights =\n            this.documentRequiredRightsReader.readRequiredRights(originalDocument);\n        DocumentRequiredRights requiredRights = this.documentRequiredRightsReader.readRequiredRights(document);\n\n        if (!originalRequiredRights.equals(requiredRights) && requiredRights.enforce()) {\n            // We can assume that the current user has all existing required rights as otherwise editing would be\n            // denied.\n            // Therefore, only check if the user has all rights specified in the updated document that could either\n            // have changed required rights or where enforcing has just been enabled.\n            for (DocumentRequiredRight requiredRight : requiredRights.rights()) {\n                try {\n                    this.authorization.checkAccess(requiredRight.right(), user,\n                        document.getDocumentReference().extractReference(requiredRight.scope()));\n                } catch (AccessDeniedException e) {\n                    event.cancel(\n                        \"The author doesn't have the right [%s] on the [%s] level that has been specified as required.\"\n                            .formatted(requiredRight.right().getName(), requiredRight.scope().getLowerCase()));\n                    break;\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RightsFilterListener.java",
        "method_name": "checkModifiedRequiredRights",
        "raw_code": "private void checkModifiedRequiredRights(DocumentReference user, XWikiDocument document,\n        CancelableEvent event)\n    {\n        XWikiDocument originalDocument = document.getOriginalDocument();\n        DocumentRequiredRights originalRequiredRights =\n            this.documentRequiredRightsReader.readRequiredRights(originalDocument);\n        DocumentRequiredRights requiredRights = this.documentRequiredRightsReader.readRequiredRights(document);\n\n        if (!originalRequiredRights.equals(requiredRights) && requiredRights.enforce()) {\n            // We can assume that the current user has all existing required rights as otherwise editing would be\n            // denied.\n            // Therefore, only check if the user has all rights specified in the updated document that could either\n            // have changed required rights or where enforcing has just been enabled.\n            for (DocumentRequiredRight requiredRight : requiredRights.rights()) {\n                try {\n                    this.authorization.checkAccess(requiredRight.right(), user,\n                        document.getDocumentReference().extractReference(requiredRight.scope()));\n                } catch (AccessDeniedException e) {\n                    event.cancel(\n                        \"The author doesn't have the right [%s] on the [%s] level that has been specified as required.\"\n                            .formatted(requiredRight.right().getName(), requiredRight.scope()));\n                    break;\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-25193",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "d1fbda62d3a47835d3fb35db8bd42ecc205a5386",
    "short_hash": "d1fbda62",
    "vulnerableMethods_before": [
      {
        "filename": "BoundedInputStream.java",
        "method_name": "read",
        "raw_code": "@Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        checkMaxBytesRead();\n\n        // Calculate the maximum number of bytes that we should try to read.\n        int num = Math.min(len, maxBytesRead - numRead + 1);\n\n        int b = super.read(buf, off, num);\n\n        if (b > 0) {\n            numRead += b;\n        }\n\n        checkMaxBytesRead();\n        return b;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BoundedInputStream.java",
        "method_name": "read",
        "raw_code": "@Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        checkMaxBytesRead();\n\n        // Calculate the maximum number of bytes that we should try to read.\n        int num = Math.min(len, maxBytesRead - numRead + 1);\n\n        int b = super.read(buf, off, num);\n\n        if (b != -1) {\n            numRead += b;\n        }\n        return b;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-25193",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "d1fbda62d3a47835d3fb35db8bd42ecc205a5386",
    "short_hash": "d1fbda62",
    "vulnerableMethods_before": [
      {
        "filename": "BoundedInputStreamTest.java",
        "method_name": "testBoundEnforced",
        "raw_code": "@Test\n    void testBoundEnforced() throws IOException {\n        final byte[] bytes = new byte[64];\n        PlatformDependent.threadLocalRandom().nextBytes(bytes);\n        final BoundedInputStream reader = new BoundedInputStream(new ByteArrayInputStream(bytes), bytes.length - 1);\n        assertEquals(bytes[0], (byte) reader.read());\n\n        assertThrows(IOException.class, new Executable() {\n            @Override\n            public void execute() throws Throwable {\n                reader.read(new byte[64], 0, 64);\n            }\n        });\n        reader.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BoundedInputStreamTest.java",
        "method_name": "testBoundEnforced",
        "raw_code": "@RepeatedTest(50)\n    void testBoundEnforced() throws IOException {\n        final byte[] bytes = new byte[64];\n        PlatformDependent.threadLocalRandom().nextBytes(bytes);\n        final BoundedInputStream reader = new BoundedInputStream(new ByteArrayInputStream(bytes), bytes.length - 1);\n        assertEquals(bytes[0], (byte) reader.read());\n\n        assertThrows(IOException.class, new Executable() {\n            @Override\n            public void execute() throws Throwable {\n                int max = bytes.length;\n                do {\n                    int result = reader.read(new byte[max], 0, max);\n                    assertThat(result).isNotEqualTo(-1);\n                    max -= result;\n                } while (max > 0);\n            }\n        });\n        reader.close();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-25193",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "d1fbda62d3a47835d3fb35db8bd42ecc205a5386",
    "short_hash": "d1fbda62",
    "vulnerableMethods_before": [
      {
        "filename": "BoundedInputStreamTest.java",
        "method_name": "testBigReadsPermittedIfUnderlyingStreamIsSmall",
        "raw_code": "@Test\n    void testBigReadsPermittedIfUnderlyingStreamIsSmall() throws IOException {\n        final byte[] bytes = new byte[64];\n        PlatformDependent.threadLocalRandom().nextBytes(bytes);\n        final BoundedInputStream reader = new BoundedInputStream(new ByteArrayInputStream(bytes), 8192);\n        final byte[] buffer = new byte[10000];\n        reader.read(buffer, 0, 10000);\n        assertArrayEquals(bytes, Arrays.copyOfRange(buffer, 0, 64));\n        reader.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BoundedInputStreamTest.java",
        "method_name": "testBigReadsPermittedIfUnderlyingStreamIsSmall",
        "raw_code": "@RepeatedTest(50)\n    void testBigReadsPermittedIfUnderlyingStreamIsSmall() throws IOException {\n        final byte[] bytes = new byte[64];\n        PlatformDependent.threadLocalRandom().nextBytes(bytes);\n        final BoundedInputStream reader = new BoundedInputStream(new ByteArrayInputStream(bytes), 8192);\n        final byte[] buffer = new byte[10000];\n        assertThat(reader.read(buffer, 0, 10000)).isEqualTo(64);\n        assertArrayEquals(bytes, Arrays.copyOfRange(buffer, 0, 64));\n        reader.close();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-24970",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "87f40725155b2f89adfde68c7732f97c153676c4",
    "short_hash": "87f40725",
    "vulnerableMethods_before": [
      {
        "filename": "SslUtils.java",
        "method_name": "getEncryptedPacketLength",
        "raw_code": "private static int getEncryptedPacketLength(ByteBuffer buffer) {\n        int packetLength = 0;\n        int pos = buffer.position();\n        // SSLv3 or TLS - Check ContentType\n        boolean tls;\n        switch (unsignedByte(buffer.get(pos))) {\n            case SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:\n            case SSL_CONTENT_TYPE_ALERT:\n            case SSL_CONTENT_TYPE_HANDSHAKE:\n            case SSL_CONTENT_TYPE_APPLICATION_DATA:\n            case SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT:\n                tls = true;\n                break;\n            default:\n                // SSLv2 or bad data\n                tls = false;\n        }\n\n        if (tls) {\n            // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1 - Check ProtocolVersion\n            int majorVersion = unsignedByte(buffer.get(pos + 1));\n            if (majorVersion == 3 || buffer.getShort(pos + 1) == GMSSL_PROTOCOL_VERSION) {\n                // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1\n                packetLength = unsignedShortBE(buffer, pos + 3) + SSL_RECORD_HEADER_LENGTH;\n                if (packetLength <= SSL_RECORD_HEADER_LENGTH) {\n                    // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                    tls = false;\n                }\n            } else {\n                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                tls = false;\n            }\n        }\n\n        if (!tls) {\n            // SSLv2 or bad data - Check the version\n            int headerLength = (unsignedByte(buffer.get(pos)) & 0x80) != 0 ? 2 : 3;\n            int majorVersion = unsignedByte(buffer.get(pos + headerLength + 1));\n            if (majorVersion == 2 || majorVersion == 3) {\n                // SSLv2\n                packetLength = headerLength == 2 ?\n                        (shortBE(buffer, pos) & 0x7FFF) + 2 : (shortBE(buffer, pos) & 0x3FFF) + 3;\n                if (packetLength <= headerLength) {\n                    return NOT_ENOUGH_DATA;\n                }\n            } else {\n                return NOT_ENCRYPTED;\n            }\n        }\n        return packetLength;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SslUtils.java",
        "method_name": "getEncryptedPacketLength",
        "raw_code": "private static int getEncryptedPacketLength(ByteBuffer buffer) {\n        int remaining = buffer.remaining();\n        if (remaining < SSL_RECORD_HEADER_LENGTH) {\n            return NOT_ENOUGH_DATA;\n        }\n        int packetLength = 0;\n        int pos = buffer.position();\n\n        // SSLv3 or TLS - Check ContentType\n        boolean tls;\n        switch (unsignedByte(buffer.get(pos))) {\n            case SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:\n            case SSL_CONTENT_TYPE_ALERT:\n            case SSL_CONTENT_TYPE_HANDSHAKE:\n            case SSL_CONTENT_TYPE_APPLICATION_DATA:\n            case SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT:\n                tls = true;\n                break;\n            default:\n                // SSLv2 or bad data\n                tls = false;\n        }\n\n        if (tls) {\n            // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1 - Check ProtocolVersion\n            int majorVersion = unsignedByte(buffer.get(pos + 1));\n            if (majorVersion == 3 || buffer.getShort(pos + 1) == GMSSL_PROTOCOL_VERSION) {\n                // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1\n                packetLength = unsignedShortBE(buffer, pos + 3) + SSL_RECORD_HEADER_LENGTH;\n                if (packetLength <= SSL_RECORD_HEADER_LENGTH) {\n                    // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                    tls = false;\n                }\n            } else {\n                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                tls = false;\n            }\n        }\n\n        if (!tls) {\n            // SSLv2 or bad data - Check the version\n            int headerLength = (unsignedByte(buffer.get(pos)) & 0x80) != 0 ? 2 : 3;\n            int majorVersion = unsignedByte(buffer.get(pos + headerLength + 1));\n            if (majorVersion == 2 || majorVersion == 3) {\n                // SSLv2\n                packetLength = headerLength == 2 ?\n                        (shortBE(buffer, pos) & 0x7FFF) + 2 : (shortBE(buffer, pos) & 0x3FFF) + 3;\n                if (packetLength <= headerLength) {\n                    // If there's no data then consider this package as not encrypted.\n                    return NOT_ENCRYPTED;\n                }\n            } else {\n                return NOT_ENCRYPTED;\n            }\n        }\n        return packetLength;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-24970",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "87f40725155b2f89adfde68c7732f97c153676c4",
    "short_hash": "87f40725",
    "vulnerableMethods_before": [
      {
        "filename": "ReferenceCountedOpenSslEngine.java",
        "method_name": "unwrap",
        "raw_code": "public final SSLEngineResult unwrap(\n            final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,\n            final ByteBuffer[] dsts, int dstsOffset, final int dstsLength) throws SSLException {\n\n        // Throw required runtime exceptions\n        checkNotNullWithIAE(srcs, \"srcs\");\n        if (srcsOffset >= srcs.length\n                || srcsOffset + srcsLength > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + srcsOffset + \", length: \" + srcsLength +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n        checkNotNullWithIAE(dsts, \"dsts\");\n        if (dstsOffset >= dsts.length || dstsOffset + dstsLength > dsts.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + dstsOffset + \", length: \" + dstsLength +\n                            \" (expected: offset <= offset + length <= dsts.length (\" + dsts.length + \"))\");\n        }\n        long capacity = 0;\n        final int dstsEndOffset = dstsOffset + dstsLength;\n        for (int i = dstsOffset; i < dstsEndOffset; i ++) {\n            ByteBuffer dst = checkNotNullArrayParam(dsts[i], i, \"dsts\");\n            if (dst.isReadOnly()) {\n                throw new ReadOnlyBufferException();\n            }\n            capacity += dst.remaining();\n        }\n\n        final int srcsEndOffset = srcsOffset + srcsLength;\n        long len = 0;\n        for (int i = srcsOffset; i < srcsEndOffset; i++) {\n            ByteBuffer src = checkNotNullArrayParam(srcs[i], i, \"srcs\");\n            len += src.remaining();\n        }\n\n        synchronized (this) {\n            if (isInboundDone()) {\n                return isOutboundDone() || isDestroyed() ? CLOSED_NOT_HANDSHAKING : NEED_WRAP_CLOSED;\n            }\n\n            SSLEngineResult.HandshakeStatus status = NOT_HANDSHAKING;\n            HandshakeState oldHandshakeState = handshakeState;\n            // Prepare OpenSSL to work in server mode and receive handshake\n            if (handshakeState != HandshakeState.FINISHED) {\n                if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                    // Update accepted so we know we triggered the handshake via wrap\n                    handshakeState = HandshakeState.STARTED_IMPLICITLY;\n                }\n\n                status = handshake();\n\n                if (status == NEED_TASK) {\n                    return newResult(status, 0, 0);\n                }\n\n                if (status == NEED_WRAP) {\n                    return NEED_WRAP_OK;\n                }\n                // Check if the inbound is considered to be closed if so let us try to wrap again.\n                if (isInboundDone) {\n                    return NEED_WRAP_CLOSED;\n                }\n            }\n\n            int sslPending = sslPending0();\n            int packetLength;\n            // The JDK implies that only a single SSL packet should be processed per unwrap call [1]. If we are in\n            // JDK compatibility mode then we should honor this, but if not we just wrap as much as possible. If there\n            // are multiple records or partial records this may reduce thrashing events through the pipeline.\n            // [1] https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html\n            if (jdkCompatibilityMode ||\n                    // If the handshake was not finished before we entered the method, we also ensure we only\n                    // unwrap one record. We do this to ensure we not produce any extra data before the caller\n                    // of the method is able to observe handshake completion and react on it.\n                    oldHandshakeState != HandshakeState.FINISHED) {\n                if (len < SSL_RECORD_HEADER_LENGTH) {\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n\n                packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);\n                if (packetLength == SslUtils.NOT_ENCRYPTED) {\n                    throw new NotSslRecordException(\"not an SSL/TLS record\");\n                }\n\n                final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;\n                if (packetLengthDataOnly > capacity) {\n                    // Not enough space in the destination buffer so signal the caller that the buffer needs to be\n                    // increased.\n                    if (packetLengthDataOnly > MAX_RECORD_SIZE) {\n                        // The packet length MUST NOT exceed 2^14 [1]. However we do accommodate more data to support\n                        // legacy use cases which may violate this condition (e.g. OpenJDK's SslEngineImpl). If the max\n                        // length is exceeded we fail fast here to avoid an infinite loop due to the fact that we\n                        // won't allocate a buffer large enough.\n                        // [1] https://tools.ietf.org/html/rfc5246#section-6.2.1\n                        throw new SSLException(\"Illegal packet length: \" + packetLengthDataOnly + \" > \" +\n                                                session.getApplicationBufferSize());\n                    } else {\n                        session.tryExpandApplicationBufferSize(packetLengthDataOnly);\n                    }\n                    return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n                }\n\n                if (len < packetLength) {\n                    // We either don't have enough data to read the packet length or not enough for reading the whole\n                    // packet.\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n            } else if (len == 0 && sslPending <= 0) {\n                return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n            } else if (capacity == 0) {\n                return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n            } else {\n                packetLength = (int) min(MAX_VALUE, len);\n            }\n\n            // This must always be the case when we reached here as if not we returned BUFFER_UNDERFLOW.\n            assert srcsOffset < srcsEndOffset;\n\n            // This must always be the case if we reached here.\n            assert capacity > 0;\n\n            // Number of produced bytes\n            int bytesProduced = 0;\n            int bytesConsumed = 0;\n            try {\n                srcLoop:\n                for (;;) {\n                    ByteBuffer src = srcs[srcsOffset];\n                    int remaining = src.remaining();\n                    final ByteBuf bioWriteCopyBuf;\n                    int pendingEncryptedBytes;\n                    if (remaining == 0) {\n                        if (sslPending <= 0) {\n                            // We must skip empty buffers as BIO_write will return 0 if asked to write something\n                            // with length 0.\n                            if (++srcsOffset >= srcsEndOffset) {\n                                break;\n                            }\n                            continue;\n                        } else {\n                            bioWriteCopyBuf = null;\n                            pendingEncryptedBytes = SSL.bioLengthByteBuffer(networkBIO);\n                        }\n                    } else {\n                        // Write more encrypted data into the BIO. Ensure we only read one packet at a time as\n                        // stated in the SSLEngine javadocs.\n                        pendingEncryptedBytes = min(packetLength, remaining);\n                        try {\n                            bioWriteCopyBuf = writeEncryptedData(src, pendingEncryptedBytes);\n                        } catch (SSLException e) {\n                            // Ensure we correctly handle the error stack.\n                            return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                        }\n                    }\n                    try {\n                        for (;;) {\n                            ByteBuffer dst = dsts[dstsOffset];\n                            if (!dst.hasRemaining()) {\n                                // No space left in the destination buffer, skip it.\n                                if (++dstsOffset >= dstsEndOffset) {\n                                    break srcLoop;\n                                }\n                                continue;\n                            }\n\n                            int bytesRead;\n                            try {\n                                bytesRead = readPlaintextData(dst);\n                            } catch (SSLException e) {\n                                // Ensure we correctly handle the error stack.\n                                return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                            }\n                            // We are directly using the ByteBuffer memory for the write, and so we only know what has\n                            // been consumed after we let SSL decrypt the data. At this point we should update the\n                            // number of bytes consumed, update the ByteBuffer position, and release temp ByteBuf.\n                            int localBytesConsumed = pendingEncryptedBytes - SSL.bioLengthByteBuffer(networkBIO);\n                            bytesConsumed += localBytesConsumed;\n                            packetLength -= localBytesConsumed;\n                            pendingEncryptedBytes -= localBytesConsumed;\n                            src.position(src.position() + localBytesConsumed);\n\n                            if (bytesRead > 0) {\n                                bytesProduced += bytesRead;\n\n                                if (!dst.hasRemaining()) {\n                                    sslPending = sslPending0();\n                                    // Move to the next dst buffer as this one is full.\n                                    if (++dstsOffset >= dstsEndOffset) {\n                                        return sslPending > 0 ?\n                                                newResult(BUFFER_OVERFLOW, status, bytesConsumed, bytesProduced) :\n                                                newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                                        bytesConsumed, bytesProduced);\n                                    }\n                                } else if (packetLength == 0 || jdkCompatibilityMode) {\n                                    // We either consumed all data or we are in jdkCompatibilityMode and have consumed\n                                    // a single TLS packet and should stop consuming until this method is called again.\n                                    break srcLoop;\n                                }\n                            } else {\n                                int sslError = SSL.getError(ssl, bytesRead);\n                                if (sslError == SSL.SSL_ERROR_WANT_READ || sslError == SSL.SSL_ERROR_WANT_WRITE) {\n                                    // break to the outer loop as we want to read more data which means we need to\n                                    // write more to the BIO.\n                                    break;\n                                } else if (sslError == SSL.SSL_ERROR_ZERO_RETURN) {\n                                    // This means the connection was shutdown correctly, close inbound and outbound\n                                    if (!receivedShutdown) {\n                                        closeAll();\n                                    }\n                                    return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                            bytesConsumed, bytesProduced);\n                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||\n                                        sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY ||\n                                        sslError == SSL.SSL_ERROR_WANT_PRIVATE_KEY_OPERATION) {\n                                    return newResult(isInboundDone() ? CLOSED : OK,\n                                            NEED_TASK, bytesConsumed, bytesProduced);\n                                } else {\n                                    return sslReadErrorResult(sslError, SSL.getLastErrorNumber(), bytesConsumed,\n                                            bytesProduced);\n                                }\n                            }\n                        }\n\n                        if (++srcsOffset >= srcsEndOffset) {\n                            break;\n                        }\n                    } finally {\n                        if (bioWriteCopyBuf != null) {\n                            bioWriteCopyBuf.release();\n                        }\n                    }\n                }\n            } finally {\n                SSL.bioClearByteBuffer(networkBIO);\n                rejectRemoteInitiatedRenegotiation();\n            }\n\n            // Check to see if we received a close_notify message from the peer.\n            if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {\n                closeAll();\n            }\n\n            return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status, bytesConsumed, bytesProduced);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ReferenceCountedOpenSslEngine.java",
        "method_name": "unwrap",
        "raw_code": "public final SSLEngineResult unwrap(\n            final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,\n            final ByteBuffer[] dsts, int dstsOffset, final int dstsLength) throws SSLException {\n\n        // Throw required runtime exceptions\n        checkNotNullWithIAE(srcs, \"srcs\");\n        if (srcsOffset >= srcs.length\n                || srcsOffset + srcsLength > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + srcsOffset + \", length: \" + srcsLength +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n        checkNotNullWithIAE(dsts, \"dsts\");\n        if (dstsOffset >= dsts.length || dstsOffset + dstsLength > dsts.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + dstsOffset + \", length: \" + dstsLength +\n                            \" (expected: offset <= offset + length <= dsts.length (\" + dsts.length + \"))\");\n        }\n        long capacity = 0;\n        final int dstsEndOffset = dstsOffset + dstsLength;\n        for (int i = dstsOffset; i < dstsEndOffset; i ++) {\n            ByteBuffer dst = checkNotNullArrayParam(dsts[i], i, \"dsts\");\n            if (dst.isReadOnly()) {\n                throw new ReadOnlyBufferException();\n            }\n            capacity += dst.remaining();\n        }\n\n        final int srcsEndOffset = srcsOffset + srcsLength;\n        long len = 0;\n        for (int i = srcsOffset; i < srcsEndOffset; i++) {\n            ByteBuffer src = checkNotNullArrayParam(srcs[i], i, \"srcs\");\n            len += src.remaining();\n        }\n\n        synchronized (this) {\n            if (isInboundDone()) {\n                return isOutboundDone() || isDestroyed() ? CLOSED_NOT_HANDSHAKING : NEED_WRAP_CLOSED;\n            }\n\n            SSLEngineResult.HandshakeStatus status = NOT_HANDSHAKING;\n            HandshakeState oldHandshakeState = handshakeState;\n            // Prepare OpenSSL to work in server mode and receive handshake\n            if (handshakeState != HandshakeState.FINISHED) {\n                if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                    // Update accepted so we know we triggered the handshake via wrap\n                    handshakeState = HandshakeState.STARTED_IMPLICITLY;\n                }\n\n                status = handshake();\n\n                if (status == NEED_TASK) {\n                    return newResult(status, 0, 0);\n                }\n\n                if (status == NEED_WRAP) {\n                    return NEED_WRAP_OK;\n                }\n                // Check if the inbound is considered to be closed if so let us try to wrap again.\n                if (isInboundDone) {\n                    return NEED_WRAP_CLOSED;\n                }\n            }\n\n            int sslPending = sslPending0();\n            int packetLength;\n            // The JDK implies that only a single SSL packet should be processed per unwrap call [1]. If we are in\n            // JDK compatibility mode then we should honor this, but if not we just wrap as much as possible. If there\n            // are multiple records or partial records this may reduce thrashing events through the pipeline.\n            // [1] https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html\n            if (jdkCompatibilityMode ||\n                    // If the handshake was not finished before we entered the method, we also ensure we only\n                    // unwrap one record. We do this to ensure we not produce any extra data before the caller\n                    // of the method is able to observe handshake completion and react on it.\n                    oldHandshakeState != HandshakeState.FINISHED) {\n                if (len < SSL_RECORD_HEADER_LENGTH) {\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n\n                packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);\n                if (packetLength == SslUtils.NOT_ENCRYPTED) {\n                    throw new NotSslRecordException(\"not an SSL/TLS record\");\n                }\n\n                assert packetLength >= 0;\n\n                final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;\n                if (packetLengthDataOnly > capacity) {\n                    // Not enough space in the destination buffer so signal the caller that the buffer needs to be\n                    // increased.\n                    if (packetLengthDataOnly > MAX_RECORD_SIZE) {\n                        // The packet length MUST NOT exceed 2^14 [1]. However we do accommodate more data to support\n                        // legacy use cases which may violate this condition (e.g. OpenJDK's SslEngineImpl). If the max\n                        // length is exceeded we fail fast here to avoid an infinite loop due to the fact that we\n                        // won't allocate a buffer large enough.\n                        // [1] https://tools.ietf.org/html/rfc5246#section-6.2.1\n                        throw new SSLException(\"Illegal packet length: \" + packetLengthDataOnly + \" > \" +\n                                                session.getApplicationBufferSize());\n                    } else {\n                        session.tryExpandApplicationBufferSize(packetLengthDataOnly);\n                    }\n                    return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n                }\n\n                if (len < packetLength) {\n                    // We either don't have enough data to read the packet length or not enough for reading the whole\n                    // packet.\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n            } else if (len == 0 && sslPending <= 0) {\n                return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n            } else if (capacity == 0) {\n                return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n            } else {\n                packetLength = (int) min(MAX_VALUE, len);\n            }\n\n            // This must always be the case when we reached here as if not we returned BUFFER_UNDERFLOW.\n            assert srcsOffset < srcsEndOffset;\n\n            // This must always be the case if we reached here.\n            assert capacity > 0;\n\n            // Number of produced bytes\n            int bytesProduced = 0;\n            int bytesConsumed = 0;\n            try {\n                srcLoop:\n                for (;;) {\n                    ByteBuffer src = srcs[srcsOffset];\n                    int remaining = src.remaining();\n                    final ByteBuf bioWriteCopyBuf;\n                    int pendingEncryptedBytes;\n                    if (remaining == 0) {\n                        if (sslPending <= 0) {\n                            // We must skip empty buffers as BIO_write will return 0 if asked to write something\n                            // with length 0.\n                            if (++srcsOffset >= srcsEndOffset) {\n                                break;\n                            }\n                            continue;\n                        } else {\n                            bioWriteCopyBuf = null;\n                            pendingEncryptedBytes = SSL.bioLengthByteBuffer(networkBIO);\n                        }\n                    } else {\n                        // Write more encrypted data into the BIO. Ensure we only read one packet at a time as\n                        // stated in the SSLEngine javadocs.\n                        pendingEncryptedBytes = min(packetLength, remaining);\n                        try {\n                            bioWriteCopyBuf = writeEncryptedData(src, pendingEncryptedBytes);\n                        } catch (SSLException e) {\n                            // Ensure we correctly handle the error stack.\n                            return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                        }\n                    }\n                    try {\n                        for (;;) {\n                            ByteBuffer dst = dsts[dstsOffset];\n                            if (!dst.hasRemaining()) {\n                                // No space left in the destination buffer, skip it.\n                                if (++dstsOffset >= dstsEndOffset) {\n                                    break srcLoop;\n                                }\n                                continue;\n                            }\n\n                            int bytesRead;\n                            try {\n                                bytesRead = readPlaintextData(dst);\n                            } catch (SSLException e) {\n                                // Ensure we correctly handle the error stack.\n                                return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                            }\n                            // We are directly using the ByteBuffer memory for the write, and so we only know what has\n                            // been consumed after we let SSL decrypt the data. At this point we should update the\n                            // number of bytes consumed, update the ByteBuffer position, and release temp ByteBuf.\n                            int localBytesConsumed = pendingEncryptedBytes - SSL.bioLengthByteBuffer(networkBIO);\n                            bytesConsumed += localBytesConsumed;\n                            packetLength -= localBytesConsumed;\n                            pendingEncryptedBytes -= localBytesConsumed;\n                            src.position(src.position() + localBytesConsumed);\n\n                            if (bytesRead > 0) {\n                                bytesProduced += bytesRead;\n\n                                if (!dst.hasRemaining()) {\n                                    sslPending = sslPending0();\n                                    // Move to the next dst buffer as this one is full.\n                                    if (++dstsOffset >= dstsEndOffset) {\n                                        return sslPending > 0 ?\n                                                newResult(BUFFER_OVERFLOW, status, bytesConsumed, bytesProduced) :\n                                                newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                                        bytesConsumed, bytesProduced);\n                                    }\n                                } else if (packetLength == 0 || jdkCompatibilityMode) {\n                                    // We either consumed all data or we are in jdkCompatibilityMode and have consumed\n                                    // a single TLS packet and should stop consuming until this method is called again.\n                                    break srcLoop;\n                                }\n                            } else {\n                                int sslError = SSL.getError(ssl, bytesRead);\n                                if (sslError == SSL.SSL_ERROR_WANT_READ || sslError == SSL.SSL_ERROR_WANT_WRITE) {\n                                    // break to the outer loop as we want to read more data which means we need to\n                                    // write more to the BIO.\n                                    break;\n                                } else if (sslError == SSL.SSL_ERROR_ZERO_RETURN) {\n                                    // This means the connection was shutdown correctly, close inbound and outbound\n                                    if (!receivedShutdown) {\n                                        closeAll();\n                                    }\n                                    return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                            bytesConsumed, bytesProduced);\n                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||\n                                        sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY ||\n                                        sslError == SSL.SSL_ERROR_WANT_PRIVATE_KEY_OPERATION) {\n                                    return newResult(isInboundDone() ? CLOSED : OK,\n                                            NEED_TASK, bytesConsumed, bytesProduced);\n                                } else {\n                                    return sslReadErrorResult(sslError, SSL.getLastErrorNumber(), bytesConsumed,\n                                            bytesProduced);\n                                }\n                            }\n                        }\n\n                        if (++srcsOffset >= srcsEndOffset) {\n                            break;\n                        }\n                    } finally {\n                        if (bioWriteCopyBuf != null) {\n                            bioWriteCopyBuf.release();\n                        }\n                    }\n                }\n            } finally {\n                SSL.bioClearByteBuffer(networkBIO);\n                rejectRemoteInitiatedRenegotiation();\n            }\n\n            // Check to see if we received a close_notify message from the peer.\n            if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {\n                closeAll();\n            }\n\n            return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status, bytesConsumed, bytesProduced);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "addFieldToQuery",
        "raw_code": "private void addFieldToQuery(String fieldName, String fieldAlias, boolean hasClassName, List<String> selectClause,\n        List<String> fromClause, List<String> whereClause, Map<String, Object> parameters)\n    {\n        if (fieldName.startsWith(DOC_PREFIX) || fieldName.startsWith(OBJ_PREFIX)) {\n            selectClause.add(fieldName);\n        } else if (!hasClassName) {\n            selectClause.add(DOC_PREFIX + fieldName);\n        } else {\n            selectClause.add(fieldAlias + \".value\");\n            fromClause.add(\"StringProperty as \" + fieldAlias);\n            whereClause.add(String.format(\"obj.id = %1$s.id.id and %1$s.id.name = :%1$s\", fieldAlias));\n            parameters.put(fieldAlias, fieldName);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "addFieldToQuery",
        "raw_code": "private void addFieldToQuery(String fieldName, String fieldAlias, DBListQuerySpec spec, List<String> selectClause,\n        List<String> fromClause, List<String> whereClause, Map<String, Object> parameters) throws QueryException\n    {\n        if (fieldName.startsWith(DOC_PREFIX) || fieldName.startsWith(OBJ_PREFIX)) {\n            checkSimpleFieldName(fieldName);\n            selectClause.add(fieldName);\n        } else if (!spec.hasClassName) {\n            checkSimpleFieldName(fieldName);\n            selectClause.add(DOC_PREFIX + fieldName);\n        } else {\n            try {\n                // Only load the XClass when really needed.\n                if (spec.xClass == null) {\n                    // Resolve the reference relative to the specified wiki.\n                    DocumentReference classReference = this.documentReferenceResolver.resolve(spec.className,\n                        new WikiReference(spec.wiki));\n                    XWikiContext xWikiContext = this.contextProvider.get();\n                    spec.xClass = xWikiContext.getWiki().getXClass(classReference, xWikiContext);\n                }\n\n                PropertyInterface propertyInterface = spec.xClass.get(fieldName);\n                if (propertyInterface instanceof PasswordClass) {\n                    throw new QueryException(\"Queries for password field [%s] on class [%s] aren't allowed\"\n                        .formatted(fieldName, spec.className), null);\n                } else if (propertyInterface instanceof EmailClass && this.mailConfiguration.shouldObfuscate()) {\n                    throw new QueryException((\"Queries for email property [%s] on class [%s] aren't allowed as email \"\n                        + \"obfuscation is enabled.\").formatted(fieldName, spec.className), null);\n                }\n                selectClause.add(fieldAlias + \".value\");\n                fromClause.add(\"StringProperty as \" + fieldAlias);\n                whereClause.add(String.format(\"obj.id = %1$s.id.id and %1$s.id.name = :%1$s\", fieldAlias));\n                parameters.put(fieldAlias, fieldName);\n            } catch (XWikiException e) {\n                throw new QueryException(\"Failed to get the XClass definition\", null, e);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "getStatementWhenIdOrValueFieldsAreSpecified",
        "raw_code": "private String getStatementWhenIdOrValueFieldsAreSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n    {\n        // Make sure we always have an id field. Ignore the value field if it duplicates the id field and there's no\n        // parent field specified.\n        if (!spec.hasIdField || (spec.idField.equals(spec.valueField) && !spec.hasParentField)) {\n            // If the parent field is specified then we need to include the value field, even if it duplicates the id\n            // field, because otherwise we can't distinguish between the value and the parent.\n            spec.idField = spec.valueField;\n            spec.hasIdField = true;\n            spec.valueField = spec.hasParentField ? spec.valueField : \"\";\n            spec.hasValueField = spec.hasParentField;\n        } else if (!spec.hasValueField && spec.hasParentField) {\n            // Same as above, we need to include the value field when the parent field is specified.\n            spec.valueField = spec.idField;\n            spec.hasValueField = true;\n        }\n\n        return getStatementWhenIdFieldIsSpecified(spec, parameters);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "getStatementWhenIdOrValueFieldsAreSpecified",
        "raw_code": "private String getStatementWhenIdOrValueFieldsAreSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n        throws QueryException\n    {\n        // Make sure we always have an id field. Ignore the value field if it duplicates the id field and there's no\n        // parent field specified.\n        if (!spec.hasIdField || (spec.idField.equals(spec.valueField) && !spec.hasParentField)) {\n            // If the parent field is specified then we need to include the value field, even if it duplicates the id\n            // field, because otherwise we can't distinguish between the value and the parent.\n            spec.idField = spec.valueField;\n            spec.hasIdField = true;\n            spec.valueField = spec.hasParentField ? spec.valueField : \"\";\n            spec.hasValueField = spec.hasParentField;\n        } else if (!spec.hasValueField && spec.hasParentField) {\n            // Same as above, we need to include the value field when the parent field is specified.\n            spec.valueField = spec.idField;\n            spec.hasValueField = true;\n        }\n\n        return getStatementWhenIdFieldIsSpecified(spec, parameters);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "getStatementWhenIdFieldIsSpecified",
        "raw_code": "private String getStatementWhenIdFieldIsSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n    {\n        List<String> selectClause = new ArrayList<>();\n        List<String> fromClause = new ArrayList<>();\n        List<String> whereClause = new ArrayList<>();\n\n        // We need to select the document in order to be able to check access rights on the results. At the same time we\n        // want to skip this column when filtering the Database List property values.\n        selectClause.add(\"doc.fullName as unfilterable0\");\n        fromClause.add(\"XWikiDocument as doc\");\n\n        // We need to join the objects table if the class name is specified or if one of the selected columns is an\n        // object property.\n        if (spec.hasClassName || spec.idField.startsWith(OBJ_PREFIX) || spec.valueField.startsWith(OBJ_PREFIX)\n            || spec.parentField.startsWith(OBJ_PREFIX)) {\n            fromClause.add(\"BaseObject as obj\");\n            whereClause.add(\"doc.fullName = obj.name\");\n            if (spec.hasClassName) {\n                whereClause.add(\"obj.className = :className and doc.fullName <> :templateName\");\n                parameters.put(CLASS_NAME, spec.className);\n                parameters.put(TEMPLATE_NAME, getTemplateName(spec.className));\n            }\n        }\n\n        addFieldToQuery(spec.idField, \"idProp\", spec.hasClassName, selectClause, fromClause, whereClause, parameters);\n\n        if (spec.hasValueField) {\n            addFieldToQuery(spec.valueField, \"valueProp\", spec.hasClassName, selectClause, fromClause, whereClause,\n                parameters);\n\n            // We cannot include the parent field if there's no value field because we would confuse it with the value\n            // field (the second column in the result set is reserved for the value).\n            if (spec.hasParentField) {\n                addFieldToQuery(spec.parentField, \"parentProp\", spec.hasClassName, selectClause, fromClause,\n                    whereClause, parameters);\n            }\n        }\n\n        StringBuilder statementBuilder =\n            new StringBuilder(\"select distinct \").append(StringUtils.join(selectClause, COLUMN_SEPARATOR))\n                .append(\" from \").append(StringUtils.join(fromClause, COLUMN_SEPARATOR));\n        if (whereClause.size() > 0) {\n            statementBuilder.append(\" where \").append(StringUtils.join(whereClause, \" and \"));\n        }\n\n        return statementBuilder.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "getStatementWhenIdFieldIsSpecified",
        "raw_code": "private String getStatementWhenIdFieldIsSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n        throws QueryException\n    {\n        List<String> selectClause = new ArrayList<>();\n        List<String> fromClause = new ArrayList<>();\n        List<String> whereClause = new ArrayList<>();\n\n        // We need to select the document in order to be able to check access rights on the results. At the same time we\n        // want to skip this column when filtering the Database List property values.\n        selectClause.add(\"doc.fullName as unfilterable0\");\n        fromClause.add(\"XWikiDocument as doc\");\n\n        // We need to join the objects table if the class name is specified or if one of the selected columns is an\n        // object property.\n        if (spec.hasClassName || spec.idField.startsWith(OBJ_PREFIX) || spec.valueField.startsWith(OBJ_PREFIX)\n            || spec.parentField.startsWith(OBJ_PREFIX)) {\n            fromClause.add(\"BaseObject as obj\");\n            whereClause.add(\"doc.fullName = obj.name\");\n            if (spec.hasClassName) {\n                whereClause.add(\"obj.className = :className and doc.fullName <> :templateName\");\n                parameters.put(CLASS_NAME, spec.className);\n                parameters.put(TEMPLATE_NAME, getTemplateName(spec.className));\n            }\n        }\n\n        addFieldToQuery(spec.idField, \"idProp\", spec, selectClause, fromClause, whereClause, parameters);\n\n        if (spec.hasValueField) {\n            addFieldToQuery(spec.valueField, \"valueProp\", spec, selectClause, fromClause, whereClause,\n                parameters);\n\n            // We cannot include the parent field if there's no value field because we would confuse it with the value\n            // field (the second column in the result set is reserved for the value).\n            if (spec.hasParentField) {\n                addFieldToQuery(spec.parentField, \"parentProp\", spec, selectClause, fromClause,\n                    whereClause, parameters);\n            }\n        }\n\n        StringBuilder statementBuilder =\n            new StringBuilder(\"select distinct \").append(StringUtils.join(selectClause, COLUMN_SEPARATOR))\n                .append(\" from \").append(StringUtils.join(fromClause, COLUMN_SEPARATOR));\n        if (whereClause.size() > 0) {\n            statementBuilder.append(\" where \").append(StringUtils.join(whereClause, \" and \"));\n        }\n\n        return statementBuilder.toString();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "configure",
        "raw_code": "@Before\n    public void configure() throws Exception\n    {\n        this.queryManager = this.mocker.getInstance(QueryManager.class);\n        this.viewableValueFilter = this.mocker.getInstance(QueryFilter.class, \"viewableAllowedDBListPropertyValue\");\n\n        XWikiDocument ownerDocument = mock(XWikiDocument.class);\n        when(ownerDocument.getDocumentReference()).thenReturn(new DocumentReference(\"tests\", \"Some\", \"Page\"));\n        this.dbListClass.setOwnerDocument(ownerDocument);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "configure",
        "raw_code": "@BeforeEach\n    void configure()\n    {\n        XWikiDocument ownerDocument = mock(XWikiDocument.class);\n        when(ownerDocument.getDocumentReference()).thenReturn(new DocumentReference(\"tests\", \"Some\", \"Page\"));\n        this.dbListClass.setOwnerDocument(ownerDocument);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "assertQuery",
        "raw_code": "private Query assertQuery(String statement) throws Exception\n    {\n        Query query = mock(Query.class);\n        when(this.queryManager.createQuery(statement, Query.HQL)).thenReturn(query);\n\n        assertSame(query, this.mocker.getComponentUnderTest().build(this.dbListClass));\n        return query;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "assertQuery",
        "raw_code": "private Query assertQuery(String statement) throws Exception\n    {\n        Query query = mock(Query.class);\n        when(this.queryManager.createQuery(statement, Query.HQL)).thenReturn(query);\n\n        assertSame(query, this.implicitlyAllowedValuesDBListQueryBuilder.build(this.dbListClass));\n        return query;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildDefaultQuery",
        "raw_code": "@Test\n    public void buildDefaultQuery() throws Exception\n    {\n        Query query = assertQuery(\"select doc.name from XWikiDocument doc where 1 = 0\");\n\n        verify(query).setWiki(\"tests\");\n        verify(query).addFilter(this.viewableValueFilter);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildDefaultQuery",
        "raw_code": "@Test\n    void buildDefaultQuery() throws Exception\n    {\n        Query query = assertQuery(\"select doc.name from XWikiDocument doc where 1 = 0\");\n\n        verify(query).setWiki(\"tests\");\n        verify(query).addFilter(this.viewableValueFilter);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithClassName",
        "raw_code": "@Test\n    public void buildWithClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"Blog.CategoryClass\");\n\n        Query query = assertQuery(\"select distinct doc.fullName from XWikiDocument as doc, BaseObject as obj\"\n            + \" where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        verify(query).bindValue(\"className\", \"Blog.CategoryClass\");\n        verify(query).bindValue(\"templateName\", \"Blog.CategoryTemplate\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithClassName",
        "raw_code": "@Test\n    void buildWithClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"Blog.CategoryClass\");\n\n        Query query = assertQuery(\"select distinct doc.fullName from XWikiDocument as doc, BaseObject as obj\"\n            + \" where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        verify(query).bindValue(\"className\", \"Blog.CategoryClass\");\n        verify(query).bindValue(\"templateName\", \"Blog.CategoryTemplate\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithId",
        "raw_code": "@Test\n    public void buildWithId() throws Exception\n    {\n        this.dbListClass.setIdField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \" + \"where doc.fullName = obj.name\");\n\n        this.dbListClass.setIdField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithId",
        "raw_code": "@Test\n    void buildWithId() throws Exception\n    {\n        this.dbListClass.setIdField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \" + \"where doc.fullName = obj.name\");\n\n        this.dbListClass.setIdField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithValue",
        "raw_code": "@Test\n    public void buildWithValue() throws Exception\n    {\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \" + \"where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithValue",
        "raw_code": "@Test\n    void buildWithValue() throws Exception\n    {\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \" + \"where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdAndClassName",
        "raw_code": "@Test\n    public void buildWithIdAndClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"XWiki.XWikiUsers\");\n        this.dbListClass.setIdField(\"doc.name\");\n        Query query = assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.name \" + \"from XWikiDocument as doc, BaseObject as obj \"\n                + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n        verify(query).bindValue(\"className\", \"XWiki.XWikiUsers\");\n        verify(query).bindValue(\"templateName\", \"XWiki.XWikiUsersTemplate\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setIdField(\"property\");\n        query = assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\"\n            + \" and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n        verify(query).bindValue(\"idProp\", \"property\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdAndClassName",
        "raw_code": "@Test\n    void buildWithIdAndClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"XWiki.XWikiUsers\");\n        this.dbListClass.setIdField(\"doc.name\");\n        Query query = assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.name \" + \"from XWikiDocument as doc, BaseObject as obj \"\n                + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n        verify(query).bindValue(\"className\", \"XWiki.XWikiUsers\");\n        verify(query).bindValue(\"templateName\", \"XWiki.XWikiUsersTemplate\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setIdField(\"property\");\n        query = assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\"\n            + \" and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n        verify(query).bindValue(\"idProp\", \"property\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdAndValue",
        "raw_code": "@Test\n    public void buildWithIdAndValue() throws Exception\n    {\n        this.dbListClass.setIdField(\"doc.name\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"doc.creator\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.creator from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.property from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"obj.id\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, obj.id \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.property \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setIdField(\"property\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"otherProperty\");\n        assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.property, doc.otherProperty from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdAndValue",
        "raw_code": "@Test\n    void buildWithIdAndValue() throws Exception\n    {\n        this.dbListClass.setIdField(\"doc.name\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"doc.creator\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.creator from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.property from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"obj.id\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, obj.id \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.property \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setIdField(\"property\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"otherProperty\");\n        assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.property, doc.otherProperty from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdValueAndClassName",
        "raw_code": "@Test\n    public void buildWithIdValueAndClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"XWiki.TagClass\");\n        this.dbListClass.setIdField(\"doc.name\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.name \" + \"from XWikiDocument as doc, BaseObject as obj \"\n                + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"doc.creator\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.creator \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.id\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, obj.id \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n\n        this.dbListClass.setIdField(\"property\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"otherProperty\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdValueAndClassName",
        "raw_code": "@Test\n    void buildWithIdValueAndClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"XWiki.TagClass\");\n        this.dbListClass.setIdField(\"doc.name\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.name \" + \"from XWikiDocument as doc, BaseObject as obj \"\n                + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"doc.creator\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.creator \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.id\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, obj.id \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n\n        this.dbListClass.setIdField(\"property\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"otherProperty\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithParent",
        "raw_code": "@Test\n    public void buildWithParent() throws Exception\n    {\n        DBTreeListClass dbTreeListClass = new DBTreeListClass();\n        dbTreeListClass.setOwnerDocument(this.dbListClass.getOwnerDocument());\n        dbTreeListClass.setParentField(\"parent\");\n\n        this.dbListClass = dbTreeListClass;\n        assertQuery(\"select doc.name from XWikiDocument doc where 1 = 0\");\n\n        this.dbListClass.setIdField(\"doc.fullName\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.fullName, doc.fullName, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"\");\n        this.dbListClass.setValueField(\"title\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.title, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n        \n        this.dbListClass.setIdField(\"title\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.title, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"fullName\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.fullName, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setClassname(\"XWiki.TagClass\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, valueProp.value, parentProp.value\"\n            + \" from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp, StringProperty as valueProp,\"\n            + \" StringProperty as parentProp where doc.fullName = obj.name and obj.className = :className and\"\n            + \" doc.fullName <> :templateName and obj.id = idProp.id.id and idProp.id.name = :idProp and\"\n            + \" obj.id = valueProp.id.id and valueProp.id.name = :valueProp and obj.id = parentProp.id.id and\"\n            + \" parentProp.id.name = :parentProp\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithParent",
        "raw_code": "@Test\n    void buildWithParent() throws Exception\n    {\n        DBTreeListClass dbTreeListClass = new DBTreeListClass();\n        dbTreeListClass.setOwnerDocument(this.dbListClass.getOwnerDocument());\n        dbTreeListClass.setParentField(\"parent\");\n\n        this.dbListClass = dbTreeListClass;\n        assertQuery(\"select doc.name from XWikiDocument doc where 1 = 0\");\n\n        this.dbListClass.setIdField(\"doc.fullName\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.fullName, doc.fullName, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"\");\n        this.dbListClass.setValueField(\"title\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.title, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"title\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.title, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"fullName\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.fullName, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setClassname(\"XWiki.TagClass\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, valueProp.value, parentProp.value\"\n            + \" from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp, StringProperty as valueProp,\"\n            + \" StringProperty as parentProp where doc.fullName = obj.name and obj.className = :className and\"\n            + \" doc.fullName <> :templateName and obj.id = idProp.id.id and idProp.id.name = :idProp and\"\n            + \" obj.id = valueProp.id.id and valueProp.id.name = :valueProp and obj.id = parentProp.id.id and\"\n            + \" parentProp.id.name = :parentProp\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "solon",
    "cve_id": "CVE-2025-1584",
    "cwe_list": [
      "CWE-24"
    ],
    "commit_hash": "f46e47fd1f8455b9467d7ead3cdb0509115b2ef1",
    "short_hash": "f46e47fd",
    "vulnerableMethods_before": [
      {
        "filename": "StaticMappings.java",
        "method_name": "find",
        "raw_code": "public static URL find(String path) throws Exception {\n        URL rst = null;\n\n        for (StaticLocation m : locationMap.values()) {\n            if (path.startsWith(m.pathPrefix)) {\n                if (m.repositoryIncPrefix) {\n                    //path = /demo/file.htm\n                    //relativePath = demo/file.htm '/'\n                    rst = m.repository.find(path.substring(1));\n                } else {\n                    //path = /demo/file.htm\n                    //relativePath = demo/file.htm '/'\n                    if (m.pathPrefixAsFile) {\n                        //\n                        int idx = m.pathPrefix.lastIndexOf(\"/\");\n                        rst = m.repository.find(m.pathPrefix.substring(idx + 1));\n                    } else {\n                        //\n                        rst = m.repository.find(path.substring(m.pathPrefix.length()));\n                    }\n                }\n\n                if (rst != null) {\n                    return rst;\n                }\n            }\n        }\n\n        return rst;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StaticMappings.java",
        "method_name": "find",
        "raw_code": "public static URL find(String path) throws Exception {\n        URL rst = null;\n\n        if (path.contains(\"/../\") == false) {\n            // '/../' \n            for (StaticLocation m : locationMap.values()) {\n                if (path.startsWith(m.pathPrefix)) {\n                    if (m.repositoryIncPrefix) {\n                        //path = /demo/file.htm\n                        //relativePath = demo/file.htm '/'\n                        rst = m.repository.find(path.substring(1));\n                    } else {\n                        //path = /demo/file.htm\n                        //relativePath = demo/file.htm '/'\n                        if (m.pathPrefixAsFile) {\n                            //\n                            int idx = m.pathPrefix.lastIndexOf(\"/\");\n                            rst = m.repository.find(m.pathPrefix.substring(idx + 1));\n                        } else {\n                            //\n                            rst = m.repository.find(path.substring(m.pathPrefix.length()));\n                        }\n                    }\n\n                    if (rst != null) {\n                        return rst;\n                    }\n                }\n            }\n        }\n\n        return rst;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "local-s3",
    "cve_id": "CVE-2025-27136",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "d6ed756ceb30c1eb9d4263321ac683d734f8836f",
    "short_hash": "d6ed756c",
    "vulnerableMethods_before": [
      {
        "filename": "LocalS3.java",
        "method_name": "createServiceFactory",
        "raw_code": "private ServiceFactory createServiceFactory() {\n\n    LocalS3Manager manager;\n    if (mode == LocalS3Mode.IN_MEMORY) {\n      log.info(\"Created in-memory LocalS3 manager.\");\n      manager = LocalS3Manager.createInMemoryS3Manager(dataPath, initialDataCacheEnabled);\n    } else {\n      log.info(\"Created file system LocalS3 manager.\");\n      manager = LocalS3Manager.createFileSystemS3Manager(dataPath);\n    }\n\n    ServiceFactory serviceFactory = new DefaultServiceFactory();\n    BucketService bucketService = manager.bucketService();\n    ObjectService objectService = manager.objectService();\n    serviceFactory.register(BucketService.class, () -> bucketService);\n    serviceFactory.register(ObjectService.class, () -> objectService);\n\n    XMLInputFactory input = new WstxInputFactory();\n    input.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.FALSE);\n    XmlMapper xmlMapper = new XmlMapper(new XmlFactory(input, new WstxOutputFactory()));\n    xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n    xmlMapper.registerModule(new Jdk8Module());\n    xmlMapper.registerModule(new JavaTimeModule());\n    serviceFactory.register(XmlMapper.class, () -> xmlMapper);\n    return serviceFactory;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LocalS3.java",
        "method_name": "createServiceFactory",
        "raw_code": "private ServiceFactory createServiceFactory() {\n\n    LocalS3Manager manager;\n    if (mode == LocalS3Mode.IN_MEMORY) {\n      log.info(\"Created in-memory LocalS3 manager.\");\n      manager = LocalS3Manager.createInMemoryS3Manager(dataPath, initialDataCacheEnabled);\n    } else {\n      log.info(\"Created file system LocalS3 manager.\");\n      manager = LocalS3Manager.createFileSystemS3Manager(dataPath);\n    }\n\n    ServiceFactory serviceFactory = new DefaultServiceFactory();\n    BucketService bucketService = manager.bucketService();\n    ObjectService objectService = manager.objectService();\n    serviceFactory.register(BucketService.class, () -> bucketService);\n    serviceFactory.register(ObjectService.class, () -> objectService);\n\n    XMLInputFactory input = new WstxInputFactory();\n    input.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.FALSE);\n    input.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE); // Disable DTDs\n    input.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE); // Disable external entities\n\n    XmlMapper xmlMapper = new XmlMapper(new XmlFactory(input, new WstxOutputFactory()));\n    xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n    xmlMapper.registerModule(new Jdk8Module());\n    xmlMapper.registerModule(new JavaTimeModule());\n    serviceFactory.register(XmlMapper.class, () -> xmlMapper);\n    return serviceFactory;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithObject",
        "raw_code": "@Test\n    void createShortenedURLWithObject() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n\n        // The URLShortenerClass object already exists\n        BaseObject urlObject = new BaseObject();\n        urlObject.setStringValue(PAGE_ID, PAGE_ID_VALUE);\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(urlObject);\n\n        Response response = this.urlShortenerResource.createShortenedURL(currentDocRefStr);\n        assertEquals(\"{pageID=12345}\", String.valueOf(response.getEntity()));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithObject",
        "raw_code": "@Test\n    void createShortenedURLWithObject() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n        when(xwiki.exists(currentDocRef, xcontext)).thenReturn(true);\n\n        // The URLShortenerClass object already exists\n        BaseObject urlObject = new BaseObject();\n        urlObject.setStringValue(PAGE_ID, PAGE_ID_VALUE);\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(urlObject);\n\n        Response response = this.urlShortenerResource.createShortenedURL(currentDocRefStr);\n        assertEquals(\"{pageID=12345}\", String.valueOf(response.getEntity()));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithoutObject",
        "raw_code": "@Test\n    void createShortenedURLWithoutObject() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n\n        // The URLShortenerClass object does not exist.\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(null);\n        when(document.newXObject(URL_SHORTENER_CLASS_REFERENCE, xcontext)).thenReturn(object);\n\n        // There is no other document with the generated ID.\n        SolrDocumentList solrDocumentList = new SolrDocumentList();\n        when(queryManager.createQuery(any(String.class), eq(\"solr\"))).thenReturn(query);\n        when(query.execute()).thenReturn(Collections.singletonList(queryResponse));\n        when(queryResponse.getResults()).thenReturn(solrDocumentList);\n\n        this.urlShortenerResource.createShortenedURL(currentDocRefStr);\n\n        verify(xwiki).saveDocument(document, \"Created URL Shortener.\", true, xcontext);\n        verify(object).set(eq(PAGE_ID), any(String.class), eq(xcontext));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithoutObject",
        "raw_code": "@Test\n    void createShortenedURLWithoutObject() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n        when(xwiki.exists(currentDocRef, xcontext)).thenReturn(true);\n\n        // The URLShortenerClass object does not exist.\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(null);\n        when(document.newXObject(URL_SHORTENER_CLASS_REFERENCE, xcontext)).thenReturn(object);\n\n        // There is no other document with the generated ID.\n        SolrDocumentList solrDocumentList = new SolrDocumentList();\n        when(queryManager.createQuery(any(String.class), eq(\"solr\"))).thenReturn(query);\n        when(query.execute()).thenReturn(Collections.singletonList(queryResponse));\n        when(queryResponse.getResults()).thenReturn(solrDocumentList);\n\n        this.urlShortenerResource.createShortenedURL(currentDocRefStr);\n\n        verify(xwiki).saveDocument(document, \"Created URL Shortener.\", true, xcontext);\n        verify(object).set(eq(PAGE_ID), any(String.class), eq(xcontext));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithoutViewAccess",
        "raw_code": "@Test\n    void createShortenedURLWithoutViewAccess() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(false);\n\n        WebApplicationException exception = assertThrows(WebApplicationException.class,\n            () -> this.urlShortenerResource.createShortenedURL(currentDocRefStr));\n        assertEquals(Response.Status.UNAUTHORIZED.getStatusCode(), exception.getResponse().getStatus());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithoutViewAccess",
        "raw_code": "@Test\n    void createShortenedURLWithoutViewAccess() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(false);\n        when(xwiki.exists(currentDocRef, xcontext)).thenReturn(true);\n\n        WebApplicationException exception = assertThrows(WebApplicationException.class,\n            () -> this.urlShortenerResource.createShortenedURL(currentDocRefStr));\n        assertEquals(Response.Status.UNAUTHORIZED.getStatusCode(), exception.getResponse().getStatus());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithErrorOnPageID",
        "raw_code": "@Test\n    void createShortenedURLWithErrorOnPageID() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(currentDocRef);\n\n        // The URLShortenerClass object does not exist.\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(null);\n        when(document.newXObject(URL_SHORTENER_CLASS_REFERENCE, xcontext)).thenThrow(new XWikiException());\n\n        WebApplicationException exception = assertThrows(WebApplicationException.class,\n            () -> this.urlShortenerResource.createShortenedURL(currentDocRefStr));\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), exception.getResponse().getStatus());\n\n        assertEquals(1, logCapture.size());\n        assertEquals(Level.ERROR, logCapture.getLogEvent(0).getLevel());\n        assertEquals(String.format(\n            \"Error while computing the shortened URL for document [%s]. Root cause: [XWikiException: Error number\"\n                + \" 0 in 0]\", currentDocRef.toString()), logCapture.getMessage(0));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithErrorOnPageID",
        "raw_code": "@Test\n    void createShortenedURLWithErrorOnPageID() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(currentDocRef);\n        when(xwiki.exists(currentDocRef, xcontext)).thenReturn(true);\n\n        // The URLShortenerClass object does not exist.\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(null);\n        when(document.newXObject(URL_SHORTENER_CLASS_REFERENCE, xcontext)).thenThrow(new XWikiException());\n\n        WebApplicationException exception = assertThrows(WebApplicationException.class,\n            () -> this.urlShortenerResource.createShortenedURL(currentDocRefStr));\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), exception.getResponse().getStatus());\n\n        assertEquals(1, logCapture.size());\n        assertEquals(Level.ERROR, logCapture.getLogEvent(0).getLevel());\n        assertEquals(String.format(\n            \"Error while computing the shortened URL for document [%s]. Root cause: [XWikiException: Error number\"\n                + \" 0 in 0]\", currentDocRef.toString()), logCapture.getMessage(0));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResource.java",
        "method_name": "createShortenedURL",
        "raw_code": "@Override\n    public Response createShortenedURL(String currentDocRef) throws Exception\n    {\n\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference documentReference = documentReferenceResolver.resolve(currentDocRef);\n        if (authorization.hasAccess(Right.VIEW, documentReference)) {\n            XWikiDocument currentDoc = xcontext.getWiki().getDocument(documentReference, xcontext);\n            String pageID = addURLShortenerXObject(currentDoc);\n            if (pageID == null || pageID.isEmpty()) {\n                throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);\n            }\n\n            return Response.ok().entity(Map.of(PAGE_ID, pageID)).type(MediaType.APPLICATION_JSON).build();\n        } else {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResource.java",
        "method_name": "createShortenedURL",
        "raw_code": "@Override\n    public Response createShortenedURL(String currentDocRef) throws Exception\n    {\n\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference documentReference = documentReferenceResolver.resolve(currentDocRef);\n\n        if (!xcontext.getWiki().exists(documentReference, xcontext)) {\n            return Response.status(Response.Status.NOT_FOUND).type(MediaType.APPLICATION_JSON).build();\n        }\n\n        if (authorization.hasAccess(Right.VIEW, documentReference)) {\n            XWikiDocument currentDoc = xcontext.getWiki().getDocument(documentReference, xcontext);\n            String pageID = addURLShortenerXObject(currentDoc);\n            if (pageID == null || pageID.isEmpty()) {\n                throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);\n            }\n\n            return Response.ok().entity(Map.of(PAGE_ID, pageID)).type(MediaType.APPLICATION_JSON).build();\n        } else {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54125",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "742ee3482ef6c2bd4ad03d0de9cdd81d0e8f3d59",
    "short_hash": "742ee348",
    "vulnerableMethods_before": [
      {
        "filename": "BaseObjectEventGenerator.java",
        "method_name": "write",
        "raw_code": "@Override\n    public void write(BaseObject xobject, Object filter, BaseObjectFilter objectFilter,\n        DocumentInstanceInputProperties properties) throws FilterException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        // > WikiObject\n\n        FilterEventParameters objectParameters = new FilterEventParameters();\n\n        objectParameters.put(WikiObjectFilter.PARAMETER_NAME, xobject.getName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_CLASS_REFERENCE, xobject.getClassName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_GUID, xobject.getGuid());\n        objectParameters.put(WikiObjectFilter.PARAMETER_NUMBER, xobject.getNumber());\n\n        objectFilter.beginWikiObject(xobject.getReference() != null ? xobject.getReference().getName() : null,\n            objectParameters);\n\n        // Object class\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n        ((BaseClassEventGenerator) this.classEventGenerator).write(xclass, filter, objectFilter, properties);\n\n        // Properties\n\n        // Iterate over values/properties sorted by field name so that the values are\n        // exported to XML in a consistent order.\n        Iterator<BaseProperty<?>> it = xobject.getSortedIterator();\n        while (it.hasNext()) {\n            BaseProperty<?> xproperty = it.next();\n\n            String pname = xproperty.getName();\n            if (pname != null && !pname.trim().equals(\"\")) {\n                ((BasePropertyEventGenerator) this.propertyEventGenerator).write(xproperty, filter,\n                    (Map<String, Object>) properties);\n            }\n        }\n\n        // < WikiObject\n\n        objectFilter.endWikiObject(xobject.getReference().getName(), objectParameters);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BaseObjectEventGenerator.java",
        "method_name": "write",
        "raw_code": "@Override\n    public void write(BaseObject xobject, Object filter, BaseObjectFilter objectFilter,\n        DocumentInstanceInputProperties properties) throws FilterException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        // > WikiObject\n\n        FilterEventParameters objectParameters = new FilterEventParameters();\n\n        objectParameters.put(WikiObjectFilter.PARAMETER_NAME, xobject.getName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_CLASS_REFERENCE, xobject.getClassName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_GUID, xobject.getGuid());\n        objectParameters.put(WikiObjectFilter.PARAMETER_NUMBER, xobject.getNumber());\n\n        objectFilter.beginWikiObject(xobject.getReference() != null ? xobject.getReference().getName() : null,\n            objectParameters);\n\n        // Object class\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n        ((BaseClassEventGenerator) this.classEventGenerator).write(xclass, filter, objectFilter, properties);\n\n        // Properties\n\n        // Iterate over values/properties sorted by field name so that the values are\n        // exported to XML in a consistent order.\n        Iterator<BaseProperty<?>> it = xobject.getSortedIterator();\n        while (it.hasNext()) {\n            BaseProperty<?> xproperty = it.next();\n\n            String pname = xproperty.getName();\n            if (StringUtils.isNotBlank(pname)\n                && (!(xclass.get(pname) instanceof PropertyClass propertyClass)\n                || !properties.getExcludedPropertyTypes().contains(propertyClass.getClassType())))\n            {\n                ((BasePropertyEventGenerator) this.propertyEventGenerator).write(xproperty, filter,\n                    (Map<String, Object>) properties);\n            }\n        }\n\n        // < WikiObject\n\n        objectFilter.endWikiObject(xobject.getReference().getName(), objectParameters);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54125",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "742ee3482ef6c2bd4ad03d0de9cdd81d0e8f3d59",
    "short_hash": "742ee348",
    "vulnerableMethods_before": [
      {
        "filename": "Document.java",
        "method_name": "getXMLContent",
        "raw_code": "public String getXMLContent() throws XWikiException\n    {\n        String xml = this.doc.getXMLContent(getXWikiContext());\n        return getXWikiContext().getUtil().substitute(\"s/<email>.*?<\\\\/email>/<email>********<\\\\/email>/goi\",\n            getXWikiContext().getUtil().substitute(\"s/<password>.*?<\\\\/password>/<password>********<\\\\/password>/goi\",\n                xml));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Document.java",
        "method_name": "getXMLContent",
        "raw_code": "public String getXMLContent() throws XWikiException\n    {\n        StringWriter writer = new StringWriter();\n        OutputTarget outputTarget = new DefaultWriterOutputTarget(writer);\n\n        DocumentInstanceInputProperties documentProperties = new DocumentInstanceInputProperties();\n        documentProperties.setWithWikiDocumentContentHTML(true);\n        documentProperties.setWithWikiAttachmentsContent(false);\n        documentProperties.setWithJRCSRevisions(false);\n        documentProperties.setWithRevisions(false);\n        documentProperties.setExcludedPropertyTypes(Set.of(\"Email\", \"Password\"));\n\n        // Output\n        XAROutputProperties xarProperties = new XAROutputProperties();\n        xarProperties.setPreserveVersion(false);\n        xarProperties.setTarget(outputTarget);\n\n        this.doc.toXML(documentProperties, xarProperties);\n\n        return writer.toString();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "faction",
    "cve_id": "CVE-2025-27422",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "0a6848d388d6dba1c81918cce2772b1e805cd3d6",
    "short_hash": "0a6848d3",
    "vulnerableMethods_before": [
      {
        "filename": "Login.java",
        "method_name": "execute",
        "raw_code": "@Action(value = \"index\", results = { @Result(name = \"createAccount\", location = \"/WEB-INF/jsp/newInstance.jsp\"),\n\t\t\t@Result(name = \"failedAuth\", location = \"/index.jsp\"),\n\t\t\t@Result(name = \"redirect_to_oauth\", location = \"/oauth\"),\n\t\t\t@Result(name = \"assessorQueue\", type = \"redirectAction\", location = \"portal/Dashboard\"),\n\t\t\t@Result(name = \"engagement\", type = \"redirectAction\", location = \"portal/Engagement\"),\n\t\t\t@Result(name = \"admin\", type = \"redirectAction\", location = \"portal/Users\"),\n\t\t\t@Result(name = \"calendar\", type = \"redirectAction\", location = \"portal/Calendar\"),\n\t\t\t@Result(name = \"remediation\", type = \"redirectAction\", location = \"portal/Remediation\") })\n\tpublic String execute() {\n\t\t\n\n\t\tif (AccessControl.isNewInstance(em) && action == null) {\n\t\t\treturn \"createAccount\";\n\t\t} else if (AccessControl.isAuthenticated(this.JSESSION)) {\n\t\t\treturn redirectIt(this.getSessionUser());\n\t\t}else if ( (username != null && !username.equals(\"\")) || (getProfiles() != null && getProfiles().size()>0) ) {\n\t\t\tAuthResult result = AccessControl.Authenticate(username, password, request, em, getProfiles());\n\t\t\tif (result == AuthResult.SUCCESS) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tHttpSession session = ServletActionContext.getRequest().getSession();\n\t\t\t\tAuditLog.audit(username, this, \"Successsfully logged in\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tUser user = (User) session.getAttribute(\"user\");\n\t\t\t\tSystemSettings ss = (SystemSettings) em.createQuery(\"from SystemSettings\").getResultList().stream()\n\t\t\t\t\t\t.findFirst().orElse(null);\n\t\t\t\tString tier = this.getTier();\n\t\t\t\tsession.setAttribute(\"tier\", tier);\n\t\t\t\tif (tier == \"consultant\") {\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", false);\n\t\t\t\t} else {\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", ss.getPeerreview());\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", ss.getEnablefeed());\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", true);\n\t\t\t\t}\n\t\t\t\tsession.setAttribute(\"title1\", ss.getBoldTitle() == null ? \"FACTION\" : ss.getBoldTitle());\n\t\t\t\tsession.setAttribute(\"title2\", ss.getOtherTitle() == null ? \"oss\" : ss.getOtherTitle());\n\n\t\t\t\treturn redirectIt(user);\n\t\t\t} else if (result == AuthResult.FAILED_AUTH) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, \" Failed Authentication\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.LOCKEDOUT) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account Lock Out\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.INACTIVITY) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account was Lock Out due to inactivity\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked due to inactivity. Please contact your administrator\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.REDIRECT_OAUTH) {\n\t\t\t\tMap<String,String[]> map = request.getParameterMap();\n\t\t\t\treturn \"redirect_to_oauth\";\n\t\t\t}else if (result == AuthResult.NOT_VALID_OAUTH_ACCOUNT) {\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Not a valid OAuth User. Try another account or contact the administrator.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.error(username, this, \"Access control result of \" + result, AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t}\n\n\t\t} else if (action != null && action.equals(\"create\")) {\n\t\t\tif (adminUsername == null || adminUsername.trim().equals(\"\")) {\n\t\t\t\tthis.message = \"Username is blank\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\tif (adminPassword == null || confirm == null || !adminPassword.equals(confirm)) {\n\t\t\t\tthis.message = \"Passwords do not match\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\t\t\tif (first == null || last == null || first.equals(\"\") || last.equals(\"\")) {\n\t\t\t\tthis.message = \"First and/or Last Name are missing\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (email == null || email.equals(\"\")) {\n\t\t\t\tthis.message = \"Email address is missing\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\t\n\t\t\tString errorMessage = AccessControl.checkPassword(adminPassword, confirm);\n\t\t\tif(!errorMessage.equals(\"\")) {\n\t\t\t\tthis.message = errorMessage;\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (adminPassword.equals(confirm)) {\n\t\t\t\tif (this.team.equals(\"\"))\n\t\t\t\t\tthis.team = \"Hacking Team\";\n\n\t\t\t\tUser testAdmin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tif (testAdmin != null) {\n\t\t\t\t\tthis.message = \"Username already taken\";\n\t\t\t\t\treturn \"createAccount\";\n\t\t\t\t}\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAccessControl.createAdmin(adminUsername.trim().toLowerCase(), adminPassword, first, last, email, em);\n\n\t\t\t\tSystemSettings settings = em.find(SystemSettings.class, 2l);\n\t\t\t\tTeams theTeam = em.createQuery(\"from Teams where TeamName = :team\", Teams.class)\n\t\t\t\t\t\t.setParameter(\"team\", team).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tList<AssessmentType> atype = em.createQuery(\"from AssessmentType\").getResultList();\n\t\t\t\tList<Campaign> campaigns = em.createQuery(\"from Campaign\").getResultList();\n\t\t\t\tList<RiskLevel> levels = em.createQuery(\"from RiskLevel\").getResultList();\n\t\t\t\tList<ReportTemplates> reportTemplates = em.createQuery(\"from ReportTemplates\").getResultList();\n\t\t\t\tCategory cat = new Category();\n\t\t\t\tcat.setName(\"Uncategorized\");\n\t\t\t\tDefaultVulnerability dv = new DefaultVulnerability();\n\t\t\t\tdv.setActive(true);\n\t\t\t\tdv.setCategory(cat);\n\t\t\t\tdv.setName(\"Generic Vulnerability\");\n\t\t\t\tdv.setLikelyhood(4);\n\t\t\t\tdv.setOverall(4);\n\t\t\t\tdv.setImpact(4);\n\t\t\t\tdv.setDescription(\"\");\n\t\t\t\tdv.setRecommendation(\"\");\n\t\t\t\tem.persist(cat);\n\t\t\t\tem.persist(dv);\n\t\t\t\tif (settings == null) {\n\t\t\t\t\tsettings = new SystemSettings();\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t\tList<String> status = new ArrayList<String>();\n\t\t\t\t\tstatus.add(\"Open\");\n\t\t\t\t\tstatus.add(\"In Progress\");\n\t\t\t\t\tstatus.add(\"On Hold\");\n\t\t\t\t\tstatus.add(\"Closed\");\n\t\t\t\t\tsettings.setStatus(status);\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t}\n\t\t\t\tif (theTeam == null)\n\t\t\t\t\ttheTeam = new Teams();\n\t\t\t\tif (levels == null || levels.size() == 0) {\n\t\t\t\t\tString[] risk = { \"Informational\", \"Recommended\", \"Low\", \"Medium\", \"High\", \"Critical\" };\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tRiskLevel level = new RiskLevel();\n\t\t\t\t\t\tlevel.setRiskId(i);\n\t\t\t\t\t\tif (i < risk.length)\n\t\t\t\t\t\t\tlevel.setRisk(risk[i]);\n\t\t\t\t\t\tem.persist(level);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (campaigns == null || campaigns.size() == 0) {\n\t\t\t\t\tCampaign camp = new Campaign();\n\t\t\t\t\tDate now = new Date();\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy\");\n\t\t\t\t\tcamp.setName(\"\" + sdf.format(now) + \" Assessments\");\n\t\t\t\t\tem.persist(camp);\n\n\t\t\t\t}\n\n\t\t\t\ttheTeam.setTeamName(this.team);\n\t\t\t\tem.persist(settings);\n\t\t\t\tem.persist(theTeam);\n\t\t\t\tUser admin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername.trim()).getSingleResult();\n\t\t\t\tadmin.getPermissions().setAssessor(true);\n\t\t\t\tadmin.getPermissions().setEngagement(true);\n\t\t\t\tadmin.getPermissions().setManager(true);\n\t\t\t\tadmin.getPermissions().setRemediation(true);\n\n\t\t\t\tadmin.setTeam(theTeam);\n\t\t\t\tem.persist(admin);\n\n\t\t\t\tif (atype == null || atype.isEmpty()) {\n\n\t\t\t\t\tAssessmentType newType = new AssessmentType();\n\t\t\t\t\tnewType.setType(\"Security Assessment\");\n\t\t\t\t\tem.persist(newType);\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (reportTemplates == null || reportTemplates.isEmpty()) {\n\t\t\t\t\t\t\tReportTemplates reportTemplate = new ReportTemplates();\n\t\t\t\t\t\t\treportTemplate.initDefaultTemplate(theTeam, newType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(Exception ex) {\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAuditLog.audit(adminUsername, this, \"Admin Account Created\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t}\n\t\t\treturn SUCCESS;\n\n\t\t}else {\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Login.java",
        "method_name": "execute",
        "raw_code": "@Action(value = \"index\", results = { @Result(name = \"createAccount\", location = \"/WEB-INF/jsp/newInstance.jsp\"),\n\t\t\t@Result(name = \"failedAuth\", location = \"/index.jsp\"),\n\t\t\t@Result(name = \"redirect_to_oauth\", location = \"/oauth\"),\n\t\t\t@Result(name = \"assessorQueue\", type = \"redirectAction\", location = \"portal/Dashboard\"),\n\t\t\t@Result(name = \"engagement\", type = \"redirectAction\", location = \"portal/Engagement\"),\n\t\t\t@Result(name = \"admin\", type = \"redirectAction\", location = \"portal/Users\"),\n\t\t\t@Result(name = \"calendar\", type = \"redirectAction\", location = \"portal/Calendar\"),\n\t\t\t@Result(name = \"remediation\", type = \"redirectAction\", location = \"portal/Remediation\") })\n\tpublic String execute() {\n\t\t\n\n\t\tif (AccessControl.isNewInstance(em) && action == null) {\n\t\t\treturn \"createAccount\";\n\t\t} else if (AccessControl.isAuthenticated(this.JSESSION)) {\n\t\t\treturn redirectIt(this.getSessionUser());\n\t\t}else if ( (username != null && !username.equals(\"\")) || (getProfiles() != null && getProfiles().size()>0) ) {\n\t\t\tAuthResult result = AccessControl.Authenticate(username, password, request, em, getProfiles());\n\t\t\tif (result == AuthResult.SUCCESS) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tHttpSession session = ServletActionContext.getRequest().getSession();\n\t\t\t\tAuditLog.audit(username, this, \"Successsfully logged in\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tUser user = (User) session.getAttribute(\"user\");\n\t\t\t\tSystemSettings ss = (SystemSettings) em.createQuery(\"from SystemSettings\").getResultList().stream()\n\t\t\t\t\t\t.findFirst().orElse(null);\n\t\t\t\tString tier = this.getTier();\n\t\t\t\tsession.setAttribute(\"tier\", tier);\n\t\t\t\tif (tier == \"consultant\") {\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", false);\n\t\t\t\t} else {\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", ss.getPeerreview());\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", ss.getEnablefeed());\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", true);\n\t\t\t\t}\n\t\t\t\tsession.setAttribute(\"title1\", ss.getBoldTitle() == null ? \"FACTION\" : ss.getBoldTitle());\n\t\t\t\tsession.setAttribute(\"title2\", ss.getOtherTitle() == null ? \"oss\" : ss.getOtherTitle());\n\n\t\t\t\treturn redirectIt(user);\n\t\t\t} else if (result == AuthResult.FAILED_AUTH) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, \" Failed Authentication\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.LOCKEDOUT) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account Lock Out\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.INACTIVITY) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account was Lock Out due to inactivity\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked due to inactivity. Please contact your administrator\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.REDIRECT_OAUTH) {\n\t\t\t\tMap<String,String[]> map = request.getParameterMap();\n\t\t\t\treturn \"redirect_to_oauth\";\n\t\t\t}else if (result == AuthResult.NOT_VALID_OAUTH_ACCOUNT) {\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Not a valid OAuth User. Try another account or contact the administrator.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.error(username, this, \"Access control result of \" + result, AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t}\n\n\t\t} else if (AccessControl.isNewInstance(em) && (action != null && action.equals(\"create\"))) {\n\t\t\tif (adminUsername == null || adminUsername.trim().equals(\"\")) {\n\t\t\t\tthis.message = \"Username is blank\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\tif (adminPassword == null || confirm == null || !adminPassword.equals(confirm)) {\n\t\t\t\tthis.message = \"Passwords do not match\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\t\t\tif (first == null || last == null || first.equals(\"\") || last.equals(\"\")) {\n\t\t\t\tthis.message = \"First and/or Last Name are missing\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (email == null || email.equals(\"\")) {\n\t\t\t\tthis.message = \"Email address is missing\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\t\n\t\t\tString errorMessage = AccessControl.checkPassword(adminPassword, confirm);\n\t\t\tif(!errorMessage.equals(\"\")) {\n\t\t\t\tthis.message = errorMessage;\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (adminPassword.equals(confirm)) {\n\t\t\t\tif (this.team.equals(\"\"))\n\t\t\t\t\tthis.team = \"Hacking Team\";\n\n\t\t\t\tUser testAdmin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tif (testAdmin != null) {\n\t\t\t\t\tthis.message = \"Username already taken\";\n\t\t\t\t\treturn \"createAccount\";\n\t\t\t\t}\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAccessControl.createAdmin(adminUsername.trim().toLowerCase(), adminPassword, first, last, email, em);\n\n\t\t\t\tSystemSettings settings = em.find(SystemSettings.class, 2l);\n\t\t\t\tTeams theTeam = em.createQuery(\"from Teams where TeamName = :team\", Teams.class)\n\t\t\t\t\t\t.setParameter(\"team\", team).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tList<AssessmentType> atype = em.createQuery(\"from AssessmentType\").getResultList();\n\t\t\t\tList<Campaign> campaigns = em.createQuery(\"from Campaign\").getResultList();\n\t\t\t\tList<RiskLevel> levels = em.createQuery(\"from RiskLevel\").getResultList();\n\t\t\t\tList<ReportTemplates> reportTemplates = em.createQuery(\"from ReportTemplates\").getResultList();\n\t\t\t\tCategory cat = new Category();\n\t\t\t\tcat.setName(\"Uncategorized\");\n\t\t\t\tDefaultVulnerability dv = new DefaultVulnerability();\n\t\t\t\tdv.setActive(true);\n\t\t\t\tdv.setCategory(cat);\n\t\t\t\tdv.setName(\"Generic Vulnerability\");\n\t\t\t\tdv.setLikelyhood(4);\n\t\t\t\tdv.setOverall(4);\n\t\t\t\tdv.setImpact(4);\n\t\t\t\tdv.setDescription(\"\");\n\t\t\t\tdv.setRecommendation(\"\");\n\t\t\t\tem.persist(cat);\n\t\t\t\tem.persist(dv);\n\t\t\t\tif (settings == null) {\n\t\t\t\t\tsettings = new SystemSettings();\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t\tList<String> status = new ArrayList<String>();\n\t\t\t\t\tstatus.add(\"Open\");\n\t\t\t\t\tstatus.add(\"In Progress\");\n\t\t\t\t\tstatus.add(\"On Hold\");\n\t\t\t\t\tstatus.add(\"Closed\");\n\t\t\t\t\tsettings.setStatus(status);\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t}\n\t\t\t\tif (theTeam == null)\n\t\t\t\t\ttheTeam = new Teams();\n\t\t\t\tif (levels == null || levels.size() == 0) {\n\t\t\t\t\tString[] risk = { \"Informational\", \"Recommended\", \"Low\", \"Medium\", \"High\", \"Critical\" };\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tRiskLevel level = new RiskLevel();\n\t\t\t\t\t\tlevel.setRiskId(i);\n\t\t\t\t\t\tif (i < risk.length)\n\t\t\t\t\t\t\tlevel.setRisk(risk[i]);\n\t\t\t\t\t\tem.persist(level);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (campaigns == null || campaigns.size() == 0) {\n\t\t\t\t\tCampaign camp = new Campaign();\n\t\t\t\t\tDate now = new Date();\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy\");\n\t\t\t\t\tcamp.setName(\"\" + sdf.format(now) + \" Assessments\");\n\t\t\t\t\tem.persist(camp);\n\n\t\t\t\t}\n\n\t\t\t\ttheTeam.setTeamName(this.team);\n\t\t\t\tem.persist(settings);\n\t\t\t\tem.persist(theTeam);\n\t\t\t\tUser admin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername.trim()).getSingleResult();\n\t\t\t\tadmin.getPermissions().setAssessor(true);\n\t\t\t\tadmin.getPermissions().setEngagement(true);\n\t\t\t\tadmin.getPermissions().setManager(true);\n\t\t\t\tadmin.getPermissions().setRemediation(true);\n\n\t\t\t\tadmin.setTeam(theTeam);\n\t\t\t\tem.persist(admin);\n\n\t\t\t\tif (atype == null || atype.isEmpty()) {\n\n\t\t\t\t\tAssessmentType newType = new AssessmentType();\n\t\t\t\t\tnewType.setType(\"Security Assessment\");\n\t\t\t\t\tem.persist(newType);\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (reportTemplates == null || reportTemplates.isEmpty()) {\n\t\t\t\t\t\t\tReportTemplates reportTemplate = new ReportTemplates();\n\t\t\t\t\t\t\treportTemplate.initDefaultTemplate(theTeam, newType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(Exception ex) {\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAuditLog.audit(adminUsername, this, \"Admin Account Created\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t}\n\t\t\treturn SUCCESS;\n\n\t\t}else {\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenDJ",
    "cve_id": "CVE-2025-27497",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
    "short_hash": "08aee472",
    "vulnerableMethods_before": [
      {
        "filename": "LocalBackendSearchOperation.java",
        "method_name": "processSearch",
        "raw_code": "private void processSearch(AtomicBoolean executePostOpPlugins) throws CanceledOperationException\n  {\n    // Process the search base and filter to convert them from their raw forms\n    // as provided by the client to the forms required for the rest of the\n    // search processing.\n    baseDN = getBaseDN();\n    filter = getFilter();\n\n    if (baseDN == null || filter == null)\n    {\n      return;\n    }\n\n    // Check to see if there are any controls in the request. If so, then\n    // see if there is any special processing required.\n    try\n    {\n      handleRequestControls();\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n\n      setResponseData(de);\n      return;\n    }\n\n\n    // Check to see if the client has permission to perform the search.\n\n    // FIXME: for now assume that this will check all permission\n    // pertinent to the operation. This includes proxy authorization\n    // and any other controls specified.\n    try\n    {\n      if (!getAccessControlHandler().isAllowed(this))\n      {\n        setResultCode(ResultCode.INSUFFICIENT_ACCESS_RIGHTS);\n        appendErrorMessage(ERR_SEARCH_AUTHZ_INSUFFICIENT_ACCESS_RIGHTS.get(baseDN));\n        return;\n      }\n    }\n    catch (DirectoryException e)\n    {\n      setResultCode(e.getResultCode());\n      appendErrorMessage(e.getMessageObject());\n      return;\n    }\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Invoke the pre-operation search plugins.\n    executePostOpPlugins.set(true);\n    if (!processOperationResult(this, getPluginConfigManager().invokePreOperationSearchPlugins(this)))\n    {\n      return;\n    }\n\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Get the backend that should hold the search base. If there is none,\n    // then fail.\n    if (backend == null)\n    {\n      setResultCode(ResultCode.NO_SUCH_OBJECT);\n      appendErrorMessage(ERR_SEARCH_BASE_DOESNT_EXIST.get(baseDN));\n      return;\n    }\n\n\n    // We'll set the result code to \"success\". If a problem occurs, then it\n    // will be overwritten.\n    setResultCode(ResultCode.SUCCESS);\n\n    try\n    {\n      //DereferenceAliasesPolicy\n      if (\n              DereferenceAliasesPolicy.ALWAYS.equals(getDerefPolicy())\n              || DereferenceAliasesPolicy.FINDING_BASE.equals(getDerefPolicy())\n              || (DereferenceAliasesPolicy.IN_SEARCHING.equals(getDerefPolicy()) && SearchScope.WHOLE_SUBTREE.equals(getScope()))\n      ) {\n        final Entry baseEntry=DirectoryServer.getEntry(baseDN);\n        if (baseEntry!=null && baseEntry.isAlias()) {\n          setBaseDN(baseEntry.getAliasedDN());\n          processSearch(executePostOpPlugins);\n          return;\n        }\n      }\n\n      // If there's a persistent search, then register it with the server.\n      boolean processSearchNow = true;\n      if (persistentSearch != null)\n      {\n        // If we're only interested in changes, then we do not actually want\n        // to process the search now.\n        processSearchNow = !persistentSearch.isChangesOnly();\n\n        // The Core server maintains the count of concurrent persistent searches\n        // so that all the backends (Remote and Local) are aware of it. Verify\n        // with the core if we have already reached the threshold.\n        if (!DirectoryServer.allowNewPersistentSearch())\n        {\n          setResultCode(ResultCode.ADMIN_LIMIT_EXCEEDED);\n          appendErrorMessage(ERR_MAX_PSEARCH_LIMIT_EXCEEDED.get());\n          return;\n        }\n        backend.registerPersistentSearch(persistentSearch);\n        persistentSearch.enable();\n      }\n\n\n      if (processSearchNow)\n      {\n        // Process the search in the backend and all its subordinates.\n        backend.search(this);\n      }\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n      setResponseData(de);\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      return;\n    }\n    catch (CanceledOperationException coe)\n    {\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      throw coe;\n    }\n    catch (Exception e)\n    {\n      logger.traceException(e);\n\n      setResultCode(DirectoryServer.getCoreConfigManager().getServerErrorResultCode());\n      appendErrorMessage(ERR_SEARCH_BACKEND_EXCEPTION\n          .get(getExceptionMessage(e)));\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LocalBackendSearchOperation.java",
        "method_name": "processSearch",
        "raw_code": "private void processSearch(AtomicBoolean executePostOpPlugins) throws CanceledOperationException\n  {\n    // Process the search base and filter to convert them from their raw forms\n    // as provided by the client to the forms required for the rest of the\n    // search processing.\n    baseDN = getBaseDN();\n    filter = getFilter();\n\n    if (baseDN == null || filter == null)\n    {\n      return;\n    }\n\n    // Check to see if there are any controls in the request. If so, then\n    // see if there is any special processing required.\n    try\n    {\n      handleRequestControls();\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n\n      setResponseData(de);\n      return;\n    }\n\n\n    // Check to see if the client has permission to perform the search.\n\n    // FIXME: for now assume that this will check all permission\n    // pertinent to the operation. This includes proxy authorization\n    // and any other controls specified.\n    try\n    {\n      if (!getAccessControlHandler().isAllowed(this))\n      {\n        setResultCode(ResultCode.INSUFFICIENT_ACCESS_RIGHTS);\n        appendErrorMessage(ERR_SEARCH_AUTHZ_INSUFFICIENT_ACCESS_RIGHTS.get(baseDN));\n        return;\n      }\n    }\n    catch (DirectoryException e)\n    {\n      setResultCode(e.getResultCode());\n      appendErrorMessage(e.getMessageObject());\n      return;\n    }\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Invoke the pre-operation search plugins.\n    executePostOpPlugins.set(true);\n    if (!processOperationResult(this, getPluginConfigManager().invokePreOperationSearchPlugins(this)))\n    {\n      return;\n    }\n\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Get the backend that should hold the search base. If there is none,\n    // then fail.\n    if (backend == null)\n    {\n      setResultCode(ResultCode.NO_SUCH_OBJECT);\n      appendErrorMessage(ERR_SEARCH_BASE_DOESNT_EXIST.get(baseDN));\n      return;\n    }\n\n\n    // We'll set the result code to \"success\". If a problem occurs, then it\n    // will be overwritten.\n    setResultCode(ResultCode.SUCCESS);\n\n    try\n    {\n      //DereferenceAliasesPolicy\n      if (\n              DereferenceAliasesPolicy.ALWAYS.equals(getDerefPolicy())\n              || DereferenceAliasesPolicy.FINDING_BASE.equals(getDerefPolicy())\n              || (DereferenceAliasesPolicy.IN_SEARCHING.equals(getDerefPolicy()) && SearchScope.WHOLE_SUBTREE.equals(getScope()))\n      ) {\n        final Entry baseEntry=DirectoryServer.getEntry(baseDN);\n        if (baseEntry!=null && baseEntry.isAlias()) {\n          final DN aliasedDn = baseEntry.getAliasedDN();\n          if(!dereferencingDNs.contains(aliasedDn)) { //detect recursive search\n            dereferencingDNs.add(aliasedDn);\n            setBaseDN(aliasedDn);\n            try {\n              processSearch(executePostOpPlugins);\n            } catch (StackOverflowError error) {\n              throw new Exception(error);\n            }\n            dereferencingDNs.remove(aliasedDn);\n            return;\n          }\n        }\n      }\n\n      // If there's a persistent search, then register it with the server.\n      boolean processSearchNow = true;\n      if (persistentSearch != null)\n      {\n        // If we're only interested in changes, then we do not actually want\n        // to process the search now.\n        processSearchNow = !persistentSearch.isChangesOnly();\n\n        // The Core server maintains the count of concurrent persistent searches\n        // so that all the backends (Remote and Local) are aware of it. Verify\n        // with the core if we have already reached the threshold.\n        if (!DirectoryServer.allowNewPersistentSearch())\n        {\n          setResultCode(ResultCode.ADMIN_LIMIT_EXCEEDED);\n          appendErrorMessage(ERR_MAX_PSEARCH_LIMIT_EXCEEDED.get());\n          return;\n        }\n        backend.registerPersistentSearch(persistentSearch);\n        persistentSearch.enable();\n      }\n\n\n      if (processSearchNow)\n      {\n        // Process the search in the backend and all its subordinates.\n        backend.search(this);\n      }\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n      setResponseData(de);\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      return;\n    }\n    catch (CanceledOperationException coe)\n    {\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      throw coe;\n    }\n    catch (Exception e)\n    {\n      logger.traceException(e);\n\n      setResultCode(DirectoryServer.getCoreConfigManager().getServerErrorResultCode());\n      appendErrorMessage(ERR_SEARCH_BACKEND_EXCEPTION\n          .get(getExceptionMessage(e)));\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenDJ",
    "cve_id": "CVE-2025-27497",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
    "short_hash": "08aee472",
    "vulnerableMethods_before": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "startServer",
        "raw_code": "@BeforeClass\n    public void startServer() throws Exception {\n        TestCaseUtils.startServer();\n        TestCaseUtils.initializeTestBackend(true);\n\n        TestCaseUtils.addEntries(\n                 \"dn: o=MyCompany, o=test\",\n                        \"o: MyCompany\",\n                        \"objectclass:organization\",\n                        \"\",\n                        \"dn: ou=Area1, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"ou: Area1\",\n                        \"aliasedObjectName: o=MyCompany, o=test\",\n                        \"\",\n                        \"dn: cn=John Doe, o=MyCompany, o=test\",\n                        \"cn: John Doe\",\n                        \"sn: Doe\",\n                        \"objectclass: person\",\n                        \"\",\n                        \"dn: cn=President, o=MyCompany, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"cn: President\",\n                        \"aliasedobjectname: cn=John Doe, o=MyCompany, o=test\",\n                        \"\"\n        );\n\n        final LDAPConnectionFactory factory =new LDAPConnectionFactory(\"localhost\", TestCaseUtils.getServerLdapPort());\n        connection = factory.getConnection();\n        connection.bind(\"cn=Directory Manager\", \"password\".toCharArray());\n        assertThat(connection.isValid()).isTrue();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "startServer",
        "raw_code": "@BeforeClass\n    public void startServer() throws Exception {\n        TestCaseUtils.startServer();\n        TestCaseUtils.initializeTestBackend(true);\n\n        TestCaseUtils.addEntries(\n                 \"dn: o=MyCompany, o=test\",\n                        \"o: MyCompany\",\n                        \"objectclass:organization\",\n                        \"\",\n                        \"dn: ou=Area1, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"ou: Area1\",\n                        \"aliasedObjectName: o=MyCompany, o=test\",\n                        \"\",\n                        \"dn: cn=John Doe, o=MyCompany, o=test\",\n                        \"cn: John Doe\",\n                        \"sn: Doe\",\n                        \"objectclass: person\",\n                        \"\",\n                        \"dn: cn=President, o=MyCompany, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"cn: President\",\n                        \"aliasedobjectname: cn=John Doe, o=MyCompany, o=test\",\n                        \"\",\n\n                        \"dn: ou=employees,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: employees\",\n                        \"description: All employees\",\n                        \"\",\n                        \"dn: uid=jdoe,ou=employees,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=jdoe,ou=researchers,o=test\",\n                        \"uid: jdoe\",\n                        \"\",\n                        \"dn: ou=researchers,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: researchers\",\n                        \"description: All reasearchers\",\n                        \"\",\n                        \"dn: uid=jdoe,ou=researchers,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=jdoe,ou=employees,o=test\",\n                        \"uid: jdoe\",\n\n                        \"\",\n                        \"dn: ou=students,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: students\",\n                        \"description: All students\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=students,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=researchers,o=test\",\n                        \"uid: janedoe\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=researchers,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=employees,o=test\",\n                        \"uid: janedoe\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=employees,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=students,o=test\",\n                        \"uid: janedoe\",\n                        \"\"\n        );\n\n        final LDAPConnectionFactory factory =new LDAPConnectionFactory(\"localhost\", TestCaseUtils.getServerLdapPort());\n        connection = factory.getConnection();\n        connection.bind(\"cn=Directory Manager\", \"password\".toCharArray());\n        assertThat(connection.isValid()).isTrue();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenDJ",
    "cve_id": "CVE-2025-27497",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
    "short_hash": "08aee472",
    "vulnerableMethods_before": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "search",
        "raw_code": "public HashMap<String,SearchResultEntry> search(SearchScope scope,DereferenceAliasesPolicy policy) throws SearchResultReferenceIOException, LdapException {\n        final SearchRequest request =Requests.newSearchRequest(\"ou=Area1,o=test\", scope,\"(objectclass=*)\")\n                .setDereferenceAliasesPolicy(policy);\n        System.out.println(\"---------------------------------------------------------------------------------------\");\n        System.out.println(request);\n\n        HashMap<String,SearchResultEntry> res=new HashMap<>();\n        final ConnectionEntryReader reader = connection.search(request);\n        while (reader.hasNext()) {\n            final SearchResultEntry srEntry = reader.readEntry();\n            System.out.println(srEntry);\n            assertThat(res.put(srEntry.getName().toString(),srEntry)).isNull();\n        }\n        return res;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "search",
        "raw_code": "public HashMap<String,SearchResultEntry> search(String dn, SearchScope scope,DereferenceAliasesPolicy policy) throws SearchResultReferenceIOException, LdapException {\n        final SearchRequest request =Requests.newSearchRequest(dn, scope,\"(objectclass=*)\")\n                .setDereferenceAliasesPolicy(policy);\n        System.out.println(\"---------------------------------------------------------------------------------------\");\n        System.out.println(request);\n\n        HashMap<String,SearchResultEntry> res=new HashMap<>();\n        final ConnectionEntryReader reader = connection.search(request);\n        while (reader.hasNext()) {\n            final SearchResultEntry srEntry = reader.readEntry();\n            System.out.println(srEntry);\n            assertThat(res.put(srEntry.getName().toString(),srEntry)).isNull();\n        }\n        return res;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenDJ",
    "cve_id": "CVE-2025-27497",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
    "short_hash": "08aee472",
    "vulnerableMethods_before": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "test_base_search",
        "raw_code": "@Test\n    public void test_base_search() throws SearchResultReferenceIOException, LdapException  {\n        HashMap<String,SearchResultEntry> res=search(SearchScope.BASE_OBJECT,DereferenceAliasesPolicy.IN_SEARCHING);\n\n        assertThat(res.containsKey(\"ou=Area1,o=test\")).isTrue();\n        assertThat(res.containsKey(\"o=MyCompany,o=test\")).isFalse();\n        assertThat(res.containsKey(\"cn=President,o=MyCompany,o=test\")).isFalse();\n        assertThat(res.containsKey(\"cn=John Doe,o=MyCompany,o=test\")).isFalse();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "test_base_search",
        "raw_code": "@Test\n    public void test_base_search() throws SearchResultReferenceIOException, LdapException  {\n        HashMap<String,SearchResultEntry> res=search(SearchScope.BASE_OBJECT, DereferenceAliasesPolicy.IN_SEARCHING);\n\n        assertThat(res.containsKey(\"ou=Area1,o=test\")).isTrue();\n        assertThat(res.containsKey(\"o=MyCompany,o=test\")).isFalse();\n        assertThat(res.containsKey(\"cn=President,o=MyCompany,o=test\")).isFalse();\n        assertThat(res.containsKey(\"cn=John Doe,o=MyCompany,o=test\")).isFalse();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cuba",
    "cve_id": "CVE-2025-32959",
    "cwe_list": [
      "CWE-770"
    ],
    "commit_hash": "42b6c00fd0572b8e52ae31afd1babc827a3161a1",
    "short_hash": "42b6c00f",
    "vulnerableMethods_before": [
      {
        "filename": "FileStorage.java",
        "method_name": "saveStream",
        "raw_code": "@Override\n    public long saveStream(final FileDescriptor fileDescr, final InputStream inputStream) throws FileStorageException {\n        checkFileDescriptor(fileDescr);\n\n        File[] roots = getStorageRoots();\n\n        // Store to primary storage\n\n        checkStorageDefined(roots, fileDescr);\n        checkPrimaryStorageAccessible(roots, fileDescr);\n\n        File dir = getStorageDir(roots[0], fileDescr);\n        dir.mkdirs();\n        checkDirectoryExists(dir);\n\n        final File file = new File(dir, getFileName(fileDescr));\n        checkFileExists(file);\n\n        long size = 0;\n        OutputStream os = null;\n        try {\n            os = FileUtils.openOutputStream(file);\n            size = IOUtils.copyLarge(inputStream, os);\n            os.flush();\n            writeLog(file, false);\n        } catch (IOException e) {\n            IOUtils.closeQuietly(os);\n            FileUtils.deleteQuietly(file);\n\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, file.getAbsolutePath(), e);\n        } finally {\n            IOUtils.closeQuietly(os);\n        }\n\n        // Copy file to secondary storages asynchronously\n\n        final SecurityContext securityContext = AppContext.getSecurityContext();\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileDescr, roots[i]);\n                continue;\n            }\n\n            File copyDir = getStorageDir(roots[i], fileDescr);\n            final File fileCopy = new File(copyDir, getFileName(fileDescr));\n\n            writeExecutor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        AppContext.setSecurityContext(securityContext);\n                        FileUtils.copyFile(file, fileCopy, true);\n                        writeLog(fileCopy, false);\n                    } catch (Exception e) {\n                        log.error(\"Error saving {} into {} : {}\", fileDescr, fileCopy.getAbsolutePath(), e.getMessage());\n                    } finally {\n                        AppContext.setSecurityContext(null);\n                    }\n                }\n            });\n        }\n\n        return size;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileStorage.java",
        "method_name": "saveStream",
        "raw_code": "@Override\n    public long saveStream(final FileDescriptor fileDescr, final InputStream inputStream) throws FileStorageException {\n        checkFileDescriptor(fileDescr);\n\n        File[] roots = getStorageRoots();\n\n        // Store to primary storage\n\n        checkStorageDefined(roots, fileDescr);\n        checkPrimaryStorageAccessible(roots, fileDescr);\n\n        File dir = getStorageDir(roots[0], fileDescr);\n        dir.mkdirs();\n        checkDirectoryExists(dir);\n\n        final File file = new File(dir, getFileName(fileDescr));\n        checkFileExists(file);\n\n        ServerConfig serverConfig = configuration.getConfig(ServerConfig.class);\n        long maxAllowedSize = serverConfig.getFileStorageMaxFileSize().toBytes();\n        long size = 0;\n        OutputStream os = null;\n        try {\n            os = FileUtils.openOutputStream(file);\n            size = IOUtils.copyLarge(inputStream, os, 0, maxAllowedSize);\n\n            if (size >= maxAllowedSize) {\n                if (inputStream.read() != IOUtils.EOF) {\n                    os.close();\n                    if (file.exists()) {\n                        if (!file.delete()) {\n                            log.warn(\"Failed to delete an incorrectly uploaded file '{}'. \" +\n                                            \"File was to large and has been rejected but already loaded part was not deleted.\",\n                                    file.getAbsolutePath());\n                        }\n                    }\n                    throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                            String.format(\"File is too large: '%s'. Max file size = %s MB is exceeded but there are unread bytes left.\",\n                                    file.getAbsolutePath(),\n                                    serverConfig.getFileStorageMaxFileSize().toMegabytes()));\n                }\n            }\n            os.flush();\n            writeLog(file, false);\n        } catch (IOException e) {\n            IOUtils.closeQuietly(os);\n            FileUtils.deleteQuietly(file);\n\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, file.getAbsolutePath(), e);\n        } finally {\n            IOUtils.closeQuietly(os);\n        }\n\n        // Copy file to secondary storages asynchronously\n\n        final SecurityContext securityContext = AppContext.getSecurityContext();\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileDescr, roots[i]);\n                continue;\n            }\n\n            File copyDir = getStorageDir(roots[i], fileDescr);\n            final File fileCopy = new File(copyDir, getFileName(fileDescr));\n\n            writeExecutor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        AppContext.setSecurityContext(securityContext);\n                        FileUtils.copyFile(file, fileCopy, true);\n                        writeLog(fileCopy, false);\n                    } catch (Exception e) {\n                        log.error(\"Error saving {} into {} : {}\", fileDescr, fileCopy.getAbsolutePath(), e.getMessage());\n                    } finally {\n                        AppContext.setSecurityContext(null);\n                    }\n                }\n            });\n        }\n\n        return size;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-27496",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
    "short_hash": "ef81582c",
    "vulnerableMethods_before": [
      {
        "filename": "SnowflakeFileTransferAgent.java",
        "method_name": "parseCommandInGS",
        "raw_code": "private static JsonNode parseCommandInGS(SFStatement statement, String command)\n      throws SnowflakeSQLException {\n    Object result = null;\n    // send the command to GS\n    try {\n      result =\n          statement.executeHelper(\n              command,\n              \"application/json\",\n              null, // bindValues\n              false, // describeOnly\n              false, // internal\n              false, // async\n              new ExecTimeTelemetryData()); // OOB telemetry timing queries\n    } catch (SFException ex) {\n      throw new SnowflakeSQLException(\n          ex.getQueryId(), ex, ex.getSqlState(), ex.getVendorCode(), ex.getParams());\n    }\n\n    JsonNode jsonNode = (JsonNode) result;\n    logger.debug(\"Response: {}\", jsonNode.toString());\n\n    SnowflakeUtil.checkErrorAndThrowException(jsonNode);\n    return jsonNode;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SnowflakeFileTransferAgent.java",
        "method_name": "parseCommandInGS",
        "raw_code": "private static JsonNode parseCommandInGS(SFStatement statement, String command)\n      throws SnowflakeSQLException {\n    Object result = null;\n    // send the command to GS\n    try {\n      result =\n          statement.executeHelper(\n              command,\n              \"application/json\",\n              null, // bindValues\n              false, // describeOnly\n              false, // internal\n              false, // async\n              new ExecTimeTelemetryData()); // OOB telemetry timing queries\n    } catch (SFException ex) {\n      throw new SnowflakeSQLException(\n          ex.getQueryId(), ex, ex.getSqlState(), ex.getVendorCode(), ex.getParams());\n    }\n\n    JsonNode jsonNode = (JsonNode) result;\n\n    logger.debug(\"Response: {}\", SecretDetector.maskSecrets(jsonNode.toString()));\n\n    SnowflakeUtil.checkErrorAndThrowException(jsonNode);\n    return jsonNode;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-27496",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
    "short_hash": "ef81582c",
    "vulnerableMethods_before": [
      {
        "filename": "SecretDetector.java",
        "method_name": "maskSecrets",
        "raw_code": "public static String maskSecrets(String text) {\n    return filterAccessTokens(\n        filterConnectionTokens(\n            filterPassword(filterSASTokens(filterAWSKeys(filterOAuthTokens(text))))));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SecretDetector.java",
        "method_name": "maskSecrets",
        "raw_code": "public static String maskSecrets(String text) {\n    return filterAccessTokens(\n        filterConnectionTokens(\n            filterPassword(\n                filterSASTokens(\n                    filterAWSKeys(filterOAuthTokens(filterEncryptionMaterial(text)))))));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-27496",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
    "short_hash": "ef81582c",
    "vulnerableMethods_before": [
      {
        "filename": "SecretDetector.java",
        "method_name": "filterAccessTokens",
        "raw_code": "public static String filterAccessTokens(String message) {\n    Matcher awsMatcher = AWS_TOKEN_PATTERN.matcher(message);\n\n    // aws\n    if (awsMatcher.find()) {\n      message = awsMatcher.replaceAll(\"$1\\\":\\\"XXXX\\\"\");\n    }\n\n    // azure\n    Matcher azureMatcher = SAS_TOKEN_PATTERN.matcher(message);\n\n    if (azureMatcher.find()) {\n      message = azureMatcher.replaceAll(\"$1=XXXX\");\n    }\n\n    // GCS\n    Matcher gcsMatcher = PRIVATE_KEY_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message =\n          gcsMatcher.replaceAll(\n              \"-----BEGIN PRIVATE KEY-----\" // #pragma: allowlist secret\n                  + \"\\\\\\\\nXXXX\\\\\\\\n\"\n                  + \"-----END PRIVATE KEY-----\");\n    }\n\n    gcsMatcher = PRIVATE_KEY_DATA_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message = gcsMatcher.replaceAll(\"\\\"privateKeyData\\\": \\\"XXXX\\\"\");\n    }\n\n    return message;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SecretDetector.java",
        "method_name": "filterAccessTokens",
        "raw_code": "public static String filterAccessTokens(String message) {\n    Matcher awsMatcher = AWS_TOKEN_PATTERN.matcher(message);\n\n    // aws\n    if (awsMatcher.find()) {\n      message = awsMatcher.replaceAll(\"$1\\\":\\\"XXXX\\\"\");\n    }\n\n    // azure\n    Matcher azureMatcher = SAS_TOKEN_PATTERN.matcher(message);\n\n    if (azureMatcher.find()) {\n      message = azureMatcher.replaceAll(\"$1=XXXX\");\n    }\n\n    // GCS\n    Matcher gcsMatcher = PRIVATE_KEY_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message =\n          gcsMatcher.replaceAll(\n              \"-----BEGIN PRIVATE KEY-----\" // #pragma: allowlist secret\n                  + \"\\\\\\\\nXXXX\\\\\\\\n\"\n                  + \"-----END PRIVATE KEY-----\");\n    }\n\n    gcsMatcher = PRIVATE_KEY_DATA_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message = gcsMatcher.replaceAll(\"\\\"privateKeyData\\\": \\\"XXXX\\\"\");\n    }\n\n    return message;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jpawebapi",
    "cve_id": "CVE-2025-32961",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "78b837d7e2b12d0df69cef1bc6042ebf3bdaf22c",
    "short_hash": "78b837d7",
    "vulnerableMethods_before": [
      {
        "filename": "RestFileDownloadController.java",
        "method_name": "download",
        "raw_code": "@RequestMapping(value = \"/download\", method = RequestMethod.GET)\n    public ModelAndView download(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        UserSession userSession = getSession(request, response);\n        if (userSession == null) {\n            error(response);\n            return null;\n        }\n\n        AppContext.setSecurityContext(new SecurityContext(userSession));\n        try {\n            UUID fileId;\n            try {\n                fileId = UUID.fromString(request.getParameter(\"f\"));\n            } catch (Exception e) {\n                log.error(e.toString());\n                error(response);\n                return null;\n            }\n\n            FileDescriptor fd = dataService.load(new LoadContext<>(FileDescriptor.class).setId(fileId));\n            if (fd == null) {\n                log.warn(\"Unable to find file with id \" + fileId);\n                error(response);\n                return null;\n            }\n\n            String fileName = URLEncodeUtils.encodeUtf8(fd.getName());\n\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Pragma\", \"no-cache\");\n\n            boolean attach = Boolean.valueOf(request.getParameter(\"a\"));\n            response.setHeader(\"Content-Disposition\", (attach ? \"attachment\" : \"inline\")\n                    + \"; filename=\" + fileName);\n\n            writeResponse(response, userSession, fd);\n\n        } finally {\n            AppContext.setSecurityContext(null);\n        }\n        return null;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestFileDownloadController.java",
        "method_name": "download",
        "raw_code": "@RequestMapping(value = \"/download\", method = RequestMethod.GET)\n    public ModelAndView download(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        UserSession userSession = getSession(request, response);\n        if (userSession == null) {\n            error(response);\n            return null;\n        }\n\n        AppContext.setSecurityContext(new SecurityContext(userSession));\n        try {\n            UUID fileId;\n            try {\n                fileId = UUID.fromString(request.getParameter(\"f\"));\n            } catch (Exception e) {\n                log.error(e.toString());\n                error(response);\n                return null;\n            }\n\n            FileDescriptor fd = dataService.load(new LoadContext<>(FileDescriptor.class).setId(fileId));\n            if (fd == null) {\n                log.warn(\"Unable to find file with id \" + fileId);\n                error(response);\n                return null;\n            }\n\n            String fileName = URLEncodeUtils.encodeUtf8(fd.getName());\n\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Pragma\", \"no-cache\");\n\n            boolean attach = Boolean.valueOf(request.getParameter(\"a\"));\n\n            attach = resolveAttachmentValue(attach, fd);\n\n            response.setHeader(\"Content-Disposition\", (attach ? \"attachment\" : \"inline\")\n                    + \"; filename=\" + fileName);\n\n            writeResponse(response, userSession, fd);\n\n        } finally {\n            AppContext.setSecurityContext(null);\n        }\n        return null;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-6466",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "4e93ac86d4891c59ecfcd27c051de9b3c5379315",
    "short_hash": "4e93ac86",
    "vulnerableMethods_before": [
      {
        "filename": "SseServiceImpl.java",
        "method_name": "speechToTextTranscriptionsV2",
        "raw_code": "@Override\n    public WhisperResponse speechToTextTranscriptionsV2(MultipartFile file) {\n        // \n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot convert an empty MultipartFile\");\n        }\n        // \n        File fileA = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + file.getOriginalFilename());\n        try {\n            //  MultipartFile \n            file.transferTo(fileA);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to convert MultipartFile to File\", e);\n        }\n        return openAiStreamClient.speechToTextTranscriptions(fileA);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SseServiceImpl.java",
        "method_name": "speechToTextTranscriptionsV2",
        "raw_code": "@Override\n    public WhisperResponse speechToTextTranscriptionsV2(MultipartFile file) {\n        // \n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot convert an empty MultipartFile\");\n        }\n        if (!FileUtils.isValidFileExtention(file, MimeTypeUtils.AUDIO__EXTENSION)) {\n            throw new IllegalStateException(\"File Extention not supported\");\n        }\n        // \n        File fileA = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + file.getOriginalFilename());\n        try {\n            //  MultipartFile \n            file.transferTo(fileA);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to convert MultipartFile to File\", e);\n        }\n        return openAiStreamClient.speechToTextTranscriptions(fileA);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-6466",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "4e93ac86d4891c59ecfcd27c051de9b3c5379315",
    "short_hash": "4e93ac86",
    "vulnerableMethods_before": [
      {
        "filename": "SseServiceImpl.java",
        "method_name": "upload",
        "raw_code": "@Override\n    public UploadFileResponse upload(MultipartFile file) {\n        openAiStreamClient = chatConfig.getOpenAiStreamClient();\n        return openAiStreamClient.uploadFile(\"fine-tune\", convertMultiPartToFile(file));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SseServiceImpl.java",
        "method_name": "upload",
        "raw_code": "@Override\n    public UploadFileResponse upload(MultipartFile file) {\n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot upload an empty MultipartFile\");\n        }\n        if (!FileUtils.isValidFileExtention(file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION)) {\n            throw new IllegalStateException(\"File Extention not supported\");\n        }\n        openAiStreamClient = chatConfig.getOpenAiStreamClient();\n        return openAiStreamClient.uploadFile(\"fine-tune\", convertMultiPartToFile(file));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigureModule.java",
        "method_name": "configure",
        "raw_code": "protected void configure() {\n        this.bindConstant().annotatedWith(Names.named(filesDirectoryParameter)).to(this.context.getInitParameter(filesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(baseUrlParameter)).to(this.context.getInitParameter(baseUrlParameter));\n        this.bindConstant().annotatedWith(Names.named(pluginFilesDirectoryParameter)).to(this.context.getInitParameter(pluginFilesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(usageScenarioParameter)).to(this.context.getInitParameter(usageScenarioParameter));\n        String secureEnrollment = this.context.getInitParameter(secureEnrollmentParameter);\n        this.bindConstant().annotatedWith(Names.named(secureEnrollmentParameter)).to(\n                secureEnrollment != null && (secureEnrollment.equals(\"1\") || secureEnrollment.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(hashSecretParameter)).to(this.context.getInitParameter(hashSecretParameter));\n        String hsts = this.context.getInitParameter(hstsParameter);\n        this.bindConstant().annotatedWith(Names.named(hstsParameter)).to(\n                hsts != null && (hsts.equals(\"1\") || hsts.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(aaptCommandParameter)).to(this.context.getInitParameter(aaptCommandParameter));\n        this.bindConstant().annotatedWith(Names.named(roleOrgadminIdParameter)).to(\n                Integer.parseInt(this.context.getInitParameter(roleOrgadminIdParameter))\n        );\n        String launcherPackage = this.context.getInitParameter(launcherPackageParameter);\n        if (launcherPackage == null) {\n            launcherPackage = Application.DEFAULT_LAUNCHER_PACKAGE;\n        }\n        this.bindConstant().annotatedWith(Names.named(launcherPackageParameter)).to(launcherPackage);\n\n        // Optional parameters (Guice doesn't allow to bind string to null)\n        String opt;\n\n        opt = this.context.getInitParameter(baseDirectoryParameter);\n        this.bindConstant().annotatedWith(Names.named(baseDirectoryParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(transmitPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(transmitPasswordParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(authClassParameter);\n        try {\n            Class authImpl = opt != null ? Class.forName(\"com.hmdm.auth.\" + opt + \"Auth\") : LocalAuth.class;\n            this.bind(HmdmAuthInterface.class).annotatedWith(Names.named(authClassParameter))\n                    .to(authImpl);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // Rebranding\n        opt = this.context.getInitParameter(rebrandingNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingLogoParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingLogoParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingMobileNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingMobileNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingSignupLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingSignupLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingTermsLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingTermsLinkParameter)).to(opt != null ? opt : \"\");\n\n        // SMTP\n        opt = this.context.getInitParameter(smtpHostParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpHostParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPortParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPortParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 25);\n        opt = this.context.getInitParameter(smtpSslParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpStartTlsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpStartTlsParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpSslProtocolsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslProtocolsParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpSslTrustParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslTrustParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpUsernameParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpUsernameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPasswordParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpFromParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpFromParameter)).to(opt != null ? opt : \"\");\n\n        // Other\n        opt = this.context.getInitParameter(deviceFastSearchCharsParameter);\n        this.bindConstant().annotatedWith(Names.named(deviceFastSearchCharsParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 5);\n        opt = this.context.getInitParameter(sqlInitScriptPath);\n        this.bindConstant().annotatedWith(Names.named(sqlInitScriptPath)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyAddresses);\n        this.bindConstant().annotatedWith(Names.named(proxyAddresses)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyIpHeader);\n        this.bindConstant().annotatedWith(Names.named(proxyIpHeader)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerAutoStatus);\n        this.bindConstant().annotatedWith(Names.named(customerAutoStatus)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(adminEmail);\n        this.bindConstant().annotatedWith(Names.named(adminEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpUrl);\n        this.bindConstant().annotatedWith(Names.named(mailchimpUrl)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpKey);\n        this.bindConstant().annotatedWith(Names.named(mailchimpKey)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignup);\n        this.bindConstant().annotatedWith(Names.named(customerSignup)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupCopySettings);\n        this.bindConstant().annotatedWith(Names.named(customerSignupCopySettings)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupConfigurations);\n        this.bindConstant().annotatedWith(Names.named(customerSignupConfigurations)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSupportEmail);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSupportEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceLimit);\n        // I have absolutely no idea why int can't be bound here but it can't!!!\n        // Let's proceed as an Indian and send String to SignupResource instead of int :-/\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSizeLimit);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSizeLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupExpiryDays);\n        this.bindConstant().annotatedWith(Names.named(customerSignupExpiryDays)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceConfig);\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceConfig)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(emailRecoverySubj);\n        this.bindConstant().annotatedWith(Names.named(emailRecoverySubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailRecoveryBody);\n        this.bindConstant().annotatedWith(Names.named(emailRecoveryBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteBody)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(ldapAdminBind);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminBind)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(ldapHost);\n        this.bindConstant().annotatedWith(Names.named(ldapHost)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapPort);\n        this.bindConstant().annotatedWith(Names.named(ldapPort)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 389);\n        opt = this.context.getInitParameter(ldapBaseDn);\n        this.bindConstant().annotatedWith(Names.named(ldapBaseDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminDn);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminPassword);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminPassword)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUsernameAttribute);\n        this.bindConstant().annotatedWith(Names.named(ldapUsernameAttribute)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUserDn);\n        this.bindConstant().annotatedWith(Names.named(ldapUserDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapDefaultRole);\n        this.bindConstant().annotatedWith(Names.named(ldapDefaultRole)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapCustomerId);\n        this.bindConstant().annotatedWith(Names.named(ldapCustomerId)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 1);\n        opt = this.context.getInitParameter(deviceAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(deviceAllowedAddress)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(uiAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(uiAllowedAddress)).to(opt != null ? opt : \"\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigureModule.java",
        "method_name": "configure",
        "raw_code": "protected void configure() {\n        this.bindConstant().annotatedWith(Names.named(filesDirectoryParameter)).to(this.context.getInitParameter(filesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(baseUrlParameter)).to(this.context.getInitParameter(baseUrlParameter));\n        this.bindConstant().annotatedWith(Names.named(pluginFilesDirectoryParameter)).to(this.context.getInitParameter(pluginFilesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(usageScenarioParameter)).to(this.context.getInitParameter(usageScenarioParameter));\n        String secureEnrollment = this.context.getInitParameter(secureEnrollmentParameter);\n        this.bindConstant().annotatedWith(Names.named(secureEnrollmentParameter)).to(\n                secureEnrollment != null && (secureEnrollment.equals(\"1\") || secureEnrollment.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(hashSecretParameter)).to(this.context.getInitParameter(hashSecretParameter));\n        String hsts = this.context.getInitParameter(hstsParameter);\n        this.bindConstant().annotatedWith(Names.named(hstsParameter)).to(\n                hsts != null && (hsts.equals(\"1\") || hsts.equalsIgnoreCase(\"true\"))\n        );\n        String preventDuplicate = this.context.getInitParameter(preventDuplicateParameter);\n        this.bindConstant().annotatedWith(Names.named(preventDuplicateParameter)).to(\n                preventDuplicate != null && (preventDuplicate.equals(\"1\") || preventDuplicate.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(aaptCommandParameter)).to(this.context.getInitParameter(aaptCommandParameter));\n        this.bindConstant().annotatedWith(Names.named(roleOrgadminIdParameter)).to(\n                Integer.parseInt(this.context.getInitParameter(roleOrgadminIdParameter))\n        );\n        String launcherPackage = this.context.getInitParameter(launcherPackageParameter);\n        if (launcherPackage == null) {\n            launcherPackage = Application.DEFAULT_LAUNCHER_PACKAGE;\n        }\n        this.bindConstant().annotatedWith(Names.named(launcherPackageParameter)).to(launcherPackage);\n\n        // Optional parameters (Guice doesn't allow to bind string to null)\n        String opt;\n\n        opt = this.context.getInitParameter(baseDirectoryParameter);\n        this.bindConstant().annotatedWith(Names.named(baseDirectoryParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(transmitPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(transmitPasswordParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(authClassParameter);\n        try {\n            Class authImpl = opt != null ? Class.forName(\"com.hmdm.auth.\" + opt + \"Auth\") : LocalAuth.class;\n            this.bind(HmdmAuthInterface.class).annotatedWith(Names.named(authClassParameter))\n                    .to(authImpl);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // Rebranding\n        opt = this.context.getInitParameter(rebrandingNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingLogoParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingLogoParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingMobileNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingMobileNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingSignupLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingSignupLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingTermsLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingTermsLinkParameter)).to(opt != null ? opt : \"\");\n\n        // SMTP\n        opt = this.context.getInitParameter(smtpHostParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpHostParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPortParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPortParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 25);\n        opt = this.context.getInitParameter(smtpSslParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpStartTlsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpStartTlsParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpSslProtocolsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslProtocolsParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpSslTrustParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslTrustParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpUsernameParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpUsernameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPasswordParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpFromParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpFromParameter)).to(opt != null ? opt : \"\");\n\n        // Other\n        opt = this.context.getInitParameter(deviceFastSearchCharsParameter);\n        this.bindConstant().annotatedWith(Names.named(deviceFastSearchCharsParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 5);\n        opt = this.context.getInitParameter(sqlInitScriptPath);\n        this.bindConstant().annotatedWith(Names.named(sqlInitScriptPath)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyAddresses);\n        this.bindConstant().annotatedWith(Names.named(proxyAddresses)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyIpHeader);\n        this.bindConstant().annotatedWith(Names.named(proxyIpHeader)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerAutoStatus);\n        this.bindConstant().annotatedWith(Names.named(customerAutoStatus)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(adminEmail);\n        this.bindConstant().annotatedWith(Names.named(adminEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpUrl);\n        this.bindConstant().annotatedWith(Names.named(mailchimpUrl)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpKey);\n        this.bindConstant().annotatedWith(Names.named(mailchimpKey)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignup);\n        this.bindConstant().annotatedWith(Names.named(customerSignup)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupCopySettings);\n        this.bindConstant().annotatedWith(Names.named(customerSignupCopySettings)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupConfigurations);\n        this.bindConstant().annotatedWith(Names.named(customerSignupConfigurations)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSupportEmail);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSupportEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceLimit);\n        // I have absolutely no idea why int can't be bound here but it can't!!!\n        // Let's proceed as an Indian and send String to SignupResource instead of int :-/\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSizeLimit);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSizeLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupExpiryDays);\n        this.bindConstant().annotatedWith(Names.named(customerSignupExpiryDays)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceConfig);\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceConfig)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(emailRecoverySubj);\n        this.bindConstant().annotatedWith(Names.named(emailRecoverySubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailRecoveryBody);\n        this.bindConstant().annotatedWith(Names.named(emailRecoveryBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteBody)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(ldapAdminBind);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminBind)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(ldapHost);\n        this.bindConstant().annotatedWith(Names.named(ldapHost)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapPort);\n        this.bindConstant().annotatedWith(Names.named(ldapPort)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 389);\n        opt = this.context.getInitParameter(ldapBaseDn);\n        this.bindConstant().annotatedWith(Names.named(ldapBaseDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminDn);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminPassword);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminPassword)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUsernameAttribute);\n        this.bindConstant().annotatedWith(Names.named(ldapUsernameAttribute)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUserDn);\n        this.bindConstant().annotatedWith(Names.named(ldapUserDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapDefaultRole);\n        this.bindConstant().annotatedWith(Names.named(ldapDefaultRole)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapCustomerId);\n        this.bindConstant().annotatedWith(Names.named(ldapCustomerId)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 1);\n        opt = this.context.getInitParameter(deviceAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(deviceAllowedAddress)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(uiAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(uiAllowedAddress)).to(opt != null ? opt : \"\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getAllConfigurations",
        "raw_code": "@ApiOperation(\n            value = \"Get configurations\",\n            notes = \"Gets the list of available configurations\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getAllConfigurations() {\n        // There should be different permissions to view and edit configurations\n        // By now, let's just remove this check to avoid issues with getting config lists\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configurations\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurations();\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getAllConfigurations",
        "raw_code": "@ApiOperation(\n            value = \"Get configurations\",\n            notes = \"Gets the list of available configurations\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getAllConfigurations() {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configurations\");\n            return Response.PERMISSION_DENIED();\n        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurations();\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "searchConfigurations",
        "raw_code": "@ApiOperation(\n            value = \"Search configurations\",\n            notes = \"Searches configurations meeting the specified filter value\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search/{value}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response searchConfigurations(@PathParam(\"value\") String value) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configurations\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurationsByValue(value);\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "searchConfigurations",
        "raw_code": "@ApiOperation(\n            value = \"Search configurations\",\n            notes = \"Searches configurations meeting the specified filter value\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search/{value}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response searchConfigurations(@PathParam(\"value\") String value) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configurations\");\n            return Response.PERMISSION_DENIED();\n        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurationsByValue(value);\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getConfigurationApplications",
        "raw_code": "@ApiOperation(\n            value = \"Get configuration applications\",\n            notes = \"Gets the list of all applications in context of usage by the requested configuration\",\n            response = Application.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/applications/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationApplications(@PathParam(\"id\") @ApiParam(\"Configuration ID\") Integer id) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configuration applications\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        return Response.OK(this.configurationDAO.getConfigurationApplications(id));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getConfigurationApplications",
        "raw_code": "@ApiOperation(\n            value = \"Get configuration applications\",\n            notes = \"Gets the list of all applications in context of usage by the requested configuration\",\n            response = Application.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/applications/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationApplications(@PathParam(\"id\") @ApiParam(\"Configuration ID\") Integer id) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configuration applications\");\n            return Response.PERMISSION_DENIED();\n        }\n        return Response.OK(this.configurationDAO.getConfigurationApplications(id));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getConfigurationById",
        "raw_code": "@ApiOperation(\n            value = \"Get configuration\",\n            notes = \"Gets the details for configuration referenced by the specified ID\",\n            response = Configuration.class\n    )\n    @GET\n    @Path(\"/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationById(@PathParam(\"id\") Integer id) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access the configuration \" + id);\n//            return Response.PERMISSION_DENIED();\n//        }\n\n        Configuration configurationById = getConfiguration(id);\n\n        return Response.OK(configurationById);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getConfigurationById",
        "raw_code": "@ApiOperation(\n            value = \"Get configuration\",\n            notes = \"Gets the details for configuration referenced by the specified ID\",\n            response = Configuration.class\n    )\n    @GET\n    @Path(\"/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationById(@PathParam(\"id\") Integer id) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access the configuration \" + id);\n            return Response.PERMISSION_DENIED();\n        }\n\n        Configuration configurationById = getConfiguration(id);\n\n        return Response.OK(configurationById);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "SyncResource.java",
        "method_name": "getDeviceSetting",
        "raw_code": "@ApiOperation(\n            value = \"Get device settings\",\n            notes = \"Gets the device info and settings from the MDM server.\",\n            response = SyncResponse.class\n    )\n    @GET\n    @Path(\"/configuration/{deviceId}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getDeviceSetting(@PathParam(\"deviceId\")\n                                     @ApiParam(\"An identifier of device within MDM server\")\n                                     String number,\n                                     @Context HttpServletRequest request,\n                                     @Context HttpServletResponse response) {\n        logger.debug(\"/public/sync/configuration/{}\", number);\n\n        if (secureEnrollment) {\n            if (!CryptoUtil.checkRequestSignature(request.getHeader(HEADER_ENROLLMENT_SIGNATURE), hashSecret + number)) {\n                logger.warn(\"Failed to setup device {}: signature mismatch\", number);\n                return Response.PERMISSION_DENIED();\n            }\n        }\n\n        try {\n            Device dbDevice = this.unsecureDAO.getDeviceByNumber(number);\n            boolean migration = false;\n            boolean foundByImeiOrSerial = false;\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByOldNumber(number);\n                migration = dbDevice != null;\n            }\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByImeiOrSerial(number);\n                foundByImeiOrSerial = dbDevice != null;\n            }\n\n            // Device creation on demand\n            if (dbDevice == null) {\n                if (unsecureDAO.isSingleCustomer()) {\n                    dbDevice = unsecureDAO.createNewDeviceOnDemand(number);\n                } else {\n                    logger.warn(\"Not allowed to create devices in the multi-tenant setup\");\n                }\n            }\n\n            if (dbDevice != null) {\n                return getDeviceSettingInternal(dbDevice, migration, foundByImeiOrSerial, request, response);\n            } else {\n                logger.warn(\"Requested device {} was not found\", number);\n                return Response.DEVICE_NOT_FOUND_ERROR();\n            }\n        } catch (Exception e) {\n            logger.error(\"Unexpected error when getting device settings\", e);\n            e.printStackTrace();\n            return Response.INTERNAL_ERROR();\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SyncResource.java",
        "method_name": "getDeviceSetting",
        "raw_code": "@ApiOperation(\n            value = \"Get device settings\",\n            notes = \"Gets the device info and settings from the MDM server.\",\n            response = SyncResponse.class\n    )\n    @GET\n    @Path(\"/configuration/{deviceId}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getDeviceSetting(@PathParam(\"deviceId\")\n                                     @ApiParam(\"An identifier of device within MDM server\")\n                                     String number,\n                                     @Context HttpServletRequest request,\n                                     @Context HttpServletResponse response) {\n        logger.debug(\"/public/sync/configuration/{}\", number);\n\n        if (secureEnrollment) {\n            if (!CryptoUtil.checkRequestSignature(request.getHeader(HEADER_ENROLLMENT_SIGNATURE), hashSecret + number)) {\n                logger.warn(\"Failed to setup device {}: signature mismatch\", number);\n                return Response.PERMISSION_DENIED();\n            }\n        }\n\n        try {\n            Device dbDevice = this.unsecureDAO.getDeviceByNumber(number);\n            boolean migration = false;\n            boolean foundByImeiOrSerial = false;\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByOldNumber(number);\n                migration = dbDevice != null;\n            }\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByImeiOrSerial(number);\n                foundByImeiOrSerial = dbDevice != null;\n                if (foundByImeiOrSerial) {\n                    logger.info(\"IMEI/Serial {}: assigned existing number: {}\", number, dbDevice.getNumber());\n                }\n            }\n\n            // Device creation on demand\n            if (dbDevice == null) {\n                if (unsecureDAO.isSingleCustomer()) {\n                    dbDevice = unsecureDAO.createNewDeviceOnDemand(number);\n                } else {\n                    logger.warn(\"Not allowed to create devices in the multi-tenant setup\");\n                }\n            }\n\n            if (dbDevice != null) {\n                return getDeviceSettingInternal(dbDevice, migration, foundByImeiOrSerial, request, response);\n            } else {\n                logger.warn(\"Requested device {} was not found\", number);\n                return Response.DEVICE_NOT_FOUND_ERROR();\n            }\n        } catch (Exception e) {\n            logger.error(\"Unexpected error when getting device settings\", e);\n            e.printStackTrace();\n            return Response.INTERNAL_ERROR();\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "HqlQueryUtils.java",
        "method_name": "isShortFormStatement",
        "raw_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), \",\", \"where \", \"order by\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HqlQueryUtils.java",
        "method_name": "isShortFormStatement",
        "raw_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), COMMA, WHERE, ORDER_BY);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "createSQLQuery",
        "raw_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        StringBuilder sql = new StringBuilder(queryPrefix);\n\n        String normalizedWhereSQL;\n        if (StringUtils.isBlank(whereSQL)) {\n            normalizedWhereSQL = \"\";\n        } else {\n            normalizedWhereSQL = whereSQL.trim();\n        }\n\n        sql.append(getColumnsForSelectStatement(normalizedWhereSQL));\n        sql.append(\" from XWikiDocument as doc\");\n\n        if (!normalizedWhereSQL.equals(\"\")) {\n            if ((!normalizedWhereSQL.startsWith(\"where\")) && (!normalizedWhereSQL.startsWith(\",\"))) {\n                sql.append(\" where \");\n            } else {\n                sql.append(\" \");\n            }\n            sql.append(normalizedWhereSQL);\n        }\n\n        return sql.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "createSQLQuery",
        "raw_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        return HqlQueryUtils.createLegacySQLQuery(queryPrefix, whereSQL);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "getColumnsForSelectStatement",
        "raw_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        StringBuilder columns = new StringBuilder();\n\n        int orderByPos = whereSQL.toLowerCase().indexOf(\"order by\");\n        if (orderByPos >= 0) {\n            String orderByStatement = whereSQL.substring(orderByPos + \"order by\".length() + 1);\n            StringTokenizer tokenizer = new StringTokenizer(orderByStatement, \",\");\n            while (tokenizer.hasMoreTokens()) {\n                String column = tokenizer.nextToken().trim();\n                // Remove \"desc\" or \"asc\" from the column found\n                column = StringUtils.removeEndIgnoreCase(column, \" desc\");\n                column = StringUtils.removeEndIgnoreCase(column, \" asc\");\n                columns.append(\", \").append(column.trim());\n            }\n        }\n\n        return columns.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "getColumnsForSelectStatement",
        "raw_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        return HqlQueryUtils.getColumnsForSelectStatement(whereSQL);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "getMetaclass",
        "raw_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "getMetaclass",
        "raw_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocuments",
        "raw_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocuments",
        "raw_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedWhereClause);\n\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocumentsNames",
        "raw_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocumentsNames",
        "raw_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            checkSearchQueryAllowed(parameterizedWhereClause);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchSpacesNames",
        "raw_code": "public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchSpacesNames",
        "raw_code": "public List<String> searchSpacesNames(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parameterizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchAttachments",
        "raw_code": "public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchAttachments",
        "raw_code": "public List<Attachment> searchAttachments(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return convertAttachments(\n            this.xwiki.searchAttachments(parameterizedSqlClause, true, nb, start, parameterValues, this.context));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "countAttachments",
        "raw_code": "public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "countAttachments",
        "raw_code": "public int countAttachments(String parameterizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.countAttachments(parameterizedSqlClause, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "HqlQueryUtils.java",
        "method_name": "isShortFormStatement",
        "raw_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), \",\", \"where \", \"order by\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HqlQueryUtils.java",
        "method_name": "isShortFormStatement",
        "raw_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), COMMA, WHERE, ORDER_BY);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "createSQLQuery",
        "raw_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        StringBuilder sql = new StringBuilder(queryPrefix);\n\n        String normalizedWhereSQL;\n        if (StringUtils.isBlank(whereSQL)) {\n            normalizedWhereSQL = \"\";\n        } else {\n            normalizedWhereSQL = whereSQL.trim();\n        }\n\n        sql.append(getColumnsForSelectStatement(normalizedWhereSQL));\n        sql.append(\" from XWikiDocument as doc\");\n\n        if (!normalizedWhereSQL.equals(\"\")) {\n            if ((!normalizedWhereSQL.startsWith(\"where\")) && (!normalizedWhereSQL.startsWith(\",\"))) {\n                sql.append(\" where \");\n            } else {\n                sql.append(\" \");\n            }\n            sql.append(normalizedWhereSQL);\n        }\n\n        return sql.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "createSQLQuery",
        "raw_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        return HqlQueryUtils.createLegacySQLQuery(queryPrefix, whereSQL);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "getColumnsForSelectStatement",
        "raw_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        StringBuilder columns = new StringBuilder();\n\n        int orderByPos = whereSQL.toLowerCase().indexOf(\"order by\");\n        if (orderByPos >= 0) {\n            String orderByStatement = whereSQL.substring(orderByPos + \"order by\".length() + 1);\n            StringTokenizer tokenizer = new StringTokenizer(orderByStatement, \",\");\n            while (tokenizer.hasMoreTokens()) {\n                String column = tokenizer.nextToken().trim();\n                // Remove \"desc\" or \"asc\" from the column found\n                column = StringUtils.removeEndIgnoreCase(column, \" desc\");\n                column = StringUtils.removeEndIgnoreCase(column, \" asc\");\n                columns.append(\", \").append(column.trim());\n            }\n        }\n\n        return columns.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "getColumnsForSelectStatement",
        "raw_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        return HqlQueryUtils.getColumnsForSelectStatement(whereSQL);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "getMetaclass",
        "raw_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "getMetaclass",
        "raw_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocuments",
        "raw_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocuments",
        "raw_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedWhereClause);\n\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocumentsNames",
        "raw_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocumentsNames",
        "raw_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            checkSearchQueryAllowed(parameterizedWhereClause);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchSpacesNames",
        "raw_code": "public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchSpacesNames",
        "raw_code": "public List<String> searchSpacesNames(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parameterizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchAttachments",
        "raw_code": "public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchAttachments",
        "raw_code": "public List<Attachment> searchAttachments(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return convertAttachments(\n            this.xwiki.searchAttachments(parameterizedSqlClause, true, nb, start, parameterValues, this.context));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "countAttachments",
        "raw_code": "public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "countAttachments",
        "raw_code": "public int countAttachments(String parameterizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.countAttachments(parameterizedSqlClause, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3199",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
    "short_hash": "c0daf641",
    "vulnerableMethods_before": [
      {
        "filename": "SysModelController.java",
        "method_name": "export",
        "raw_code": "@Log(title = \"\", businessType = BusinessType.EXPORT)\n    @PostMapping(\"/export\")\n    public void export(SysModelBo bo, HttpServletResponse response) {\n        List<SysModelVo> list = sysModelService.queryList(bo);\n        ExcelUtil.exportExcel(list, \"\", SysModelVo.class, response);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysModelController.java",
        "method_name": "export",
        "raw_code": "@SaCheckPermission(\"system:model:export\")\n    @Log(title = \"\", businessType = BusinessType.EXPORT)\n    @PostMapping(\"/export\")\n    public void export(SysModelBo bo, HttpServletResponse response) {\n        List<SysModelVo> list = sysModelService.queryList(bo);\n        ExcelUtil.exportExcel(list, \"\", SysModelVo.class, response);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3199",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
    "short_hash": "c0daf641",
    "vulnerableMethods_before": [
      {
        "filename": "SysModelController.java",
        "method_name": "add",
        "raw_code": "@Log(title = \"\", businessType = BusinessType.INSERT)\n    @PostMapping()\n    public R<Void> add(@Validated(AddGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.insertByBo(bo));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysModelController.java",
        "method_name": "add",
        "raw_code": "@SaCheckPermission(\"system:model:add\")\n    @Log(title = \"\", businessType = BusinessType.INSERT)\n    @PostMapping()\n    public R<Void> add(@Validated(AddGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.insertByBo(bo));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3199",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
    "short_hash": "c0daf641",
    "vulnerableMethods_before": [
      {
        "filename": "SysModelController.java",
        "method_name": "edit",
        "raw_code": "@Log(title = \"\", businessType = BusinessType.UPDATE)\n    @RepeatSubmit()\n    @PutMapping()\n    public R<Void> edit(@Validated(EditGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.updateByBo(bo));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysModelController.java",
        "method_name": "edit",
        "raw_code": "@SaCheckPermission(\"system:model:edit\")\n    @Log(title = \"\", businessType = BusinessType.UPDATE)\n    @RepeatSubmit()\n    @PutMapping()\n    public R<Void> edit(@Validated(EditGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.updateByBo(bo));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3202",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6382e177bf90cc56ff70521842409e35c50df32d",
    "short_hash": "6382e177",
    "vulnerableMethods_before": [
      {
        "filename": "SysNoticeController.java",
        "method_name": "list",
        "raw_code": "@GetMapping(\"/list\")\n    public TableDataInfo<SysNoticeVo> list(SysNoticeBo notice, PageQuery pageQuery) {\n        //1 2\n        notice.setNoticeType(\"2\");\n        return noticeService.selectPageNoticeList(notice, pageQuery);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysNoticeController.java",
        "method_name": "list",
        "raw_code": "@SaCheckPermission(\"system:notice:list\")\n    @GetMapping(\"/list\")\n    public TableDataInfo<SysNoticeVo> list(SysNoticeBo notice, PageQuery pageQuery) {\n        //1 2\n        notice.setNoticeType(\"2\");\n        return noticeService.selectPageNoticeList(notice, pageQuery);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3202",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6382e177bf90cc56ff70521842409e35c50df32d",
    "short_hash": "6382e177",
    "vulnerableMethods_before": [
      {
        "filename": "SysNoticeController.java",
        "method_name": "edit",
        "raw_code": "@Log(title = \"\", businessType = BusinessType.UPDATE)\n    @PutMapping\n    public R<Void> edit(@Validated @RequestBody SysNoticeBo notice) {\n        return toAjax(noticeService.updateNotice(notice));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysNoticeController.java",
        "method_name": "edit",
        "raw_code": "@SaCheckPermission(\"system:notice:edit\")\n    @Log(title = \"\", businessType = BusinessType.UPDATE)\n    @PutMapping\n    public R<Void> edit(@Validated @RequestBody SysNoticeBo notice) {\n        return toAjax(noticeService.updateNotice(notice));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "open-kilda",
    "cve_id": "CVE-2025-54992",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
    "short_hash": "1eddb498",
    "vulnerableMethods_before": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateCreateProvider",
        "raw_code": "public void validateCreateProvider(MultipartFile file, String name, String entityId, String url, \n            boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = samlRepository.findByEntityIdOrNameEqualsIgnoreCase(entityId, name);\n        if (samlConfigEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file == null && url == null) {\n            throw new RequestValidationException(messageUtil.getAttributeNotNull(\"Metadata file or url\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        String metadataEntityId = validateEntityId(file, url);\n        if (!metadataEntityId.equals(entityId)) { \n            throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateCreateProvider",
        "raw_code": "public void validateCreateProvider(MultipartFile file, String name, String entityId, String url,\n            boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = samlRepository.findByEntityIdOrNameEqualsIgnoreCase(entityId, name);\n        if (samlConfigEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file == null && url == null) {\n            throw new RequestValidationException(messageUtil.getAttributeNotNull(\"Metadata file or url\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        String metadataEntityId = validateEntityId(file, url);\n        if (!metadataEntityId.equals(entityId)) {\n            throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "open-kilda",
    "cve_id": "CVE-2025-54992",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
    "short_hash": "1eddb498",
    "vulnerableMethods_before": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateUpdateProvider",
        "raw_code": "public SamlConfigEntity validateUpdateProvider(String uuid, MultipartFile file, String name, \n            String entityId, String url, boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = getEntityByUuid(uuid);\n        SamlConfigEntity configEntity = samlRepository.findByUuidNotAndEntityIdOrUuidNotAndNameEqualsIgnoreCase(\n                uuid, entityId, uuid, name);\n        if (configEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        if (file == null && url == null) {\n            if (!samlConfigEntity.getEntityId().equals(entityId)) {\n                throw new RequestValidationException(messageUtil.getAttributeInvalid(\"Entity Id\", entityId));\n            }\n        } else {\n            String metadataEntityId = validateEntityId(file, url);\n            if (!metadataEntityId.equals(entityId)) {\n                throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n            } \n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n        return samlConfigEntity;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateUpdateProvider",
        "raw_code": "public SamlConfigEntity validateUpdateProvider(String uuid, MultipartFile file, String name,\n            String entityId, String url, boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = getEntityByUuid(uuid);\n        SamlConfigEntity configEntity = samlRepository.findByUuidNotAndEntityIdOrUuidNotAndNameEqualsIgnoreCase(\n                uuid, entityId, uuid, name);\n        if (configEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        if (file == null && url == null) {\n            if (!samlConfigEntity.getEntityId().equals(entityId)) {\n                throw new RequestValidationException(messageUtil.getAttributeInvalid(\"Entity Id\", entityId));\n            }\n        } else {\n            String metadataEntityId = validateEntityId(file, url);\n            if (!metadataEntityId.equals(entityId)) {\n                throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n            }\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n        return samlConfigEntity;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "open-kilda",
    "cve_id": "CVE-2025-54992",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
    "short_hash": "1eddb498",
    "vulnerableMethods_before": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateEntityId",
        "raw_code": "private String validateEntityId(MultipartFile file, String url) {\n        String entityId = null;\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();\n            Document doc = null; \n            if (file != null) {\n                doc = docBuilder.parse(file.getInputStream());\n            } else if (url != null) {\n                doc = docBuilder.parse(new URL(url).openStream());\n            }\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(doc.getDocumentElement().getNodeName());\n            for (int temp = 0; temp < nodeList.getLength(); temp++) {\n                Node node = nodeList.item(temp);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element element = (Element) node;\n                    entityId = element.getAttribute(\"entityID\");\n                }\n            }\n            return entityId;\n        } catch (Exception e) {\n            LOGGER.error(\"Error occurred while validating entity ID\" + e);\n            throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"url\"));\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateEntityId",
        "raw_code": "private String validateEntityId(MultipartFile file, String url) {\n        String entityId = null;\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();\n            Document doc = null;\n            if (file != null) {\n                doc = docBuilder.parse(file.getInputStream());\n            } else if (url != null) {\n                doc = docBuilder.parse(new URL(url).openStream());\n            }\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(doc.getDocumentElement().getNodeName());\n            for (int temp = 0; temp < nodeList.getLength(); temp++) {\n                Node node = nodeList.item(temp);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element element = (Element) node;\n                    entityId = element.getAttribute(\"entityID\");\n                }\n            }\n            return entityId;\n        } catch (Exception e) {\n            LOGGER.error(\"Error occurred while validating entity ID\" + e);\n            throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"url\"));\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "get",
        "raw_code": "@Override\n  public Optional<Object> get(WebContext context, String key) {\n    Optional sessionValue =\n        getSessionOrEmpty(context)\n            .map(session -> session.get(key))\n            .map(SessionStoreImpl::strToObject)\n            .orElseGet(Optional::empty);\n    return sessionValue;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "get",
        "raw_code": "@Override\n  public Optional<Object> get(WebContext context, String key) {\n    return getSessionOrEmpty(context)\n        .map(session -> session.get(key))\n        .flatMap(value -> strToObject(context(context).require(Serializer.class), value));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "set",
        "raw_code": "@Override\n  public void set(WebContext context, String key, Object value) {\n    if (value == null || value.toString().length() == 0) {\n      getSessionOrEmpty(context).ifPresent(session -> session.remove(key));\n    } else {\n      String encoded = objToStr(value);\n      getSession(context).put(key, encoded);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "set",
        "raw_code": "@Override\n  public void set(WebContext context, String key, Object value) {\n    if (value == null || value.toString().isEmpty()) {\n      getSessionOrEmpty(context).ifPresent(session -> session.remove(key));\n    } else {\n      String encoded = objToStr(context(context).require(Serializer.class), value);\n      getSession(context).put(key, encoded);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "renewSession",
        "raw_code": "@Override\n  public boolean renewSession(WebContext context) {\n    getSessionOrEmpty(context).ifPresent(session -> session.renewId());\n    return true;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "renewSession",
        "raw_code": "@Override\n  public boolean renewSession(WebContext context) {\n    var session = getSessionOrEmpty(context);\n    session.ifPresent(Session::renewId);\n    return session.isPresent();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "strToObject",
        "raw_code": "static Optional<Object> strToObject(final Value node) {\n    if (node.isMissing()) {\n      return Optional.empty();\n    }\n    String value = node.value();\n    if (value.startsWith(BIN)) {\n      try {\n        byte[] bytes = Base64.getDecoder().decode(value.substring(BIN.length()));\n        return Optional.of(new ObjectInputStream(new ByteArrayInputStream(bytes)).readObject());\n      } catch (Exception x) {\n        throw SneakyThrows.propagate(x);\n      }\n    } else if (value.startsWith(PAC4J)) {\n      return Optional.of(strToAction(value.substring(PAC4J.length())));\n    }\n    return Optional.of(value);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "strToObject",
        "raw_code": "static Optional<Object> strToObject(Serializer serializer, Value node) {\n    if (node.isMissing()) {\n      return Optional.empty();\n    }\n    String value = node.value();\n    if (value.startsWith(BIN)) {\n      return Optional.of(serializer.deserializeFromString(value.substring(BIN.length())));\n    } else if (value.startsWith(PAC4J)) {\n      return Optional.of(strToAction(value.substring(PAC4J.length())));\n    }\n    return Optional.of(value);\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "objToStr",
        "raw_code": "static String objToStr(final Object value) {\n    if (value instanceof CharSequence || value instanceof Number || value instanceof Boolean) {\n      return value.toString();\n    } else if (value instanceof HttpAction) {\n      return actionToStr((HttpAction) value);\n    }\n    try {\n      ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n      ObjectOutputStream stream = new ObjectOutputStream(bytes);\n      stream.writeObject(value);\n      stream.flush();\n      return BIN + Base64.getEncoder().encodeToString(bytes.toByteArray());\n    } catch (IOException x) {\n      throw SneakyThrows.propagate(x);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "objToStr",
        "raw_code": "static String objToStr(Serializer serializer, Object value) {\n    if (value instanceof CharSequence || value instanceof Number || value instanceof Boolean) {\n      return value.toString();\n    } else if (value instanceof HttpAction) {\n      return actionToStr((HttpAction) value);\n    } else {\n      return BIN + serializer.serializeToString(value);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "Pac4jOptions.java",
        "method_name": "setLogoutUrlPattern",
        "raw_code": "public void setLogoutUrlPattern(String logoutUrlPattern) {\n    this.logoutUrlPattern = logoutUrlPattern;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Pac4jOptions.java",
        "method_name": "setLogoutUrlPattern",
        "raw_code": "public @NonNull Pac4jOptions setLogoutUrlPattern(String logoutUrlPattern) {\n    this.logoutUrlPattern = logoutUrlPattern;\n    return this;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "Pac4jModule.java",
        "method_name": "install",
        "raw_code": "@Override\n  public void install(@NonNull Jooby app) throws Exception {\n    app.getServices().putIfAbsent(Pac4jOptions.class, options);\n\n    var clients =\n        ofNullable(options.getClients())\n            /* No client? set a default one: */\n            .orElseGet(Clients::new);\n\n    /* No client instance added from DSL, init them from pac4j config. */\n    if (clientMap == null) {\n      clientMap = initializeClients(options);\n    }\n\n    var contextPath = app.getContextPath().equals(\"/\") ? \"\" : app.getContextPath();\n\n    Map<String, List<ClientReference>> allClients = new LinkedHashMap<>();\n\n    /* Should add simple login form? */\n    var devLogin = false;\n    if (clientMap.isEmpty()) {\n      devLogin = true;\n      client(\n          conf ->\n              new FormClient(\n                  contextPath + \"/login\", new SimpleTestUsernamePasswordAuthenticator()));\n    }\n    var conf = app.getConfig();\n    /* Initialize clients from DSL: */\n    for (var routing : clientMap.entrySet()) {\n      var localClients = allClients.computeIfAbsent(routing.getKey(), k -> new ArrayList<>());\n      var path = routing.getValue();\n      for (var candidate : path.clients) {\n        if (candidate instanceof Class) {\n          localClients.add(new ClientReference((Class<Client>) candidate));\n        } else if (candidate instanceof Client) {\n          localClients.add(new ClientReference((Client) candidate));\n        } else {\n          Function<com.typesafe.config.Config, Client> clientProvider =\n              (Function<com.typesafe.config.Config, Client>) candidate;\n          localClients.add(new ClientReference(clientProvider.apply(conf)));\n        }\n      }\n      allClients.put(routing.getKey(), localClients);\n\n      // check for forwarding authorizers\n      for (var authorizerName : path.authorizers) {\n        Authorizer authorizer = options.getAuthorizers().get(authorizerName);\n        if (authorizer instanceof ForwardingAuthorizer) {\n          ((ForwardingAuthorizer) authorizer).setRegistry(app);\n        }\n      }\n    }\n\n    options.getAuthorizers().put(NoopAuthorizer.NAME, new NoopAuthorizer());\n\n    /* Default callback URL if none was set at client level: */\n    clients.setCallbackUrl(\n        ofNullable(clients.getCallbackUrl()).orElse(contextPath + options.getCallbackPath()));\n    /* Default URL resolver if none was set at client level: */\n    clients.setUrlResolver(\n        ofNullable(clients.getUrlResolver()).orElseGet(Pac4jModule::newUrlResolver));\n\n    /* Set resolved clients: */\n    clients.setClients(\n        allClients.values().stream()\n            .flatMap(List::stream)\n            .filter(ClientReference::isResolved)\n            .map(ClientReference::getClient)\n            .collect(Collectors.toList()));\n    options.setClients(clients);\n\n    /* Delay setting unresolved clients: */\n    var unresolved =\n        allClients.values().stream().flatMap(List::stream).filter(r -> !r.isResolved()).toList();\n\n    if (!unresolved.isEmpty()) {\n      app.onStarting(\n          () -> {\n            List<Client> clientList = new ArrayList<>(clients.getClients());\n            unresolved.stream()\n                .peek(r -> r.resolve(app::require))\n                .map(ClientReference::getClient)\n                .forEachOrdered(clientList::add);\n            clients.setClients(clientList);\n\n            /** If the global client was unresolved at initialization, try to set it now: */\n            List<ClientReference> defaultSecurityFilter = allClients.get(\"*\");\n            if (defaultSecurityFilter != null && options.getDefaultClient() == null) {\n              options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n            }\n          });\n    }\n\n    /* Set default http action adapter: */\n    options.setHttpActionAdapter(\n        ofNullable(options.getHttpActionAdapter()).orElseGet(Pac4jModule::newActionAdapter));\n\n    /* WebContextFactory: */\n    options.setWebContextFactory(\n        ofNullable(options.getWebContextFactory()).orElseGet(ContextFactoryImpl::new));\n    options.setSessionStoreFactory(\n        ofNullable(options.getSessionStoreFactory()).orElseGet(SessionStoreFactoryImpl::new));\n    options.setProfileManagerFactory(\n        ofNullable(options.getProfileManagerFactory()).orElse(ProfileManagerFactory.DEFAULT));\n\n    if (devLogin) {\n      app.get(\"/login\", new DevLoginForm(options, contextPath + options.getCallbackPath()));\n    }\n\n    /*\n     * If we have multiple clients on specific paths, we collect those path and configure pac4j to\n     * ignore them. So after login they are redirected to the requested url and not to one of this\n     * sign-in endpoints.\n     *\n     * <pre>\n     *   install(new Pac4jModule()\n     *     .client(\"/google\", ...)\n     *     .client(\"/twitter\", ....);\n     *   );\n     * </pre>\n     *\n     * So <code>google</code> and <code>twitter</code> paths are never saved as requested urls.\n     */\n    var excludes =\n        allClients.keySet().stream()\n            .filter(it -> !it.equals(\"*\"))\n            .map(it -> contextPath + it)\n            .collect(Collectors.toSet());\n\n    var callbackLogic = options.getCallbackLogic();\n    if (callbackLogic == null) {\n      options.setCallbackLogic(newCallbackLogic(excludes));\n    }\n    var direct = clients.getClients().stream().allMatch(it -> it instanceof DirectClient);\n    if (!direct || options.isForceCallbackRoutes()) {\n      CallbackFilterImpl callbackFilter = new CallbackFilterImpl(options, options);\n      app.get(options.getCallbackPath(), callbackFilter);\n      app.post(options.getCallbackPath(), callbackFilter);\n    }\n\n    var securityLogic = options.getSecurityLogic();\n    if (securityLogic == null) {\n      options.setSecurityLogic(newSecurityLogic(excludes));\n    }\n\n    /** For each client to a specific path, add a security handler. */\n    for (var entry : allClients.entrySet()) {\n      String pattern = entry.getKey();\n      if (!pattern.equals(\"*\")) {\n        List<String> keys = Router.pathKeys(pattern);\n        if (keys.isEmpty()) {\n          SecurityFilterImpl securityFilter =\n              new SecurityFilterImpl(\n                  null,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers);\n          app.get(pattern, securityFilter);\n          // POST for direct authentication\n          app.post(pattern, securityFilter);\n        } else {\n          app.use(\n              new SecurityFilterImpl(\n                  pattern,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers));\n        }\n      }\n    }\n\n    /* Is there is a global client, use it as decorator/filter (default client): */\n    var defaultSecurityFilter = allClients.get(\"*\");\n    if (defaultSecurityFilter != null) {\n      if (options.getDefaultClient() == null && defaultSecurityFilter.get(0).isResolved()) {\n        options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n      }\n      app.use(\n          new SecurityFilterImpl(\n              null,\n              options,\n              options,\n              lazyClientNameList(defaultSecurityFilter),\n              clientMap.get(\"*\").authorizers));\n    }\n\n    /* Logout configuration: */\n    var logoutLogic = options.getLogoutLogic();\n    if (logoutLogic == null) {\n      options.setLogoutLogic(newLogoutLogic());\n    }\n    if (!direct || options.isForceLogoutRoutes()) {\n      app.get(options.getLogoutPath(), new LogoutImpl(options, options));\n    }\n\n    /* Better response code for some errors. */\n    app.errorCode(UnauthorizedAction.class, StatusCode.UNAUTHORIZED);\n    app.errorCode(ForbiddenAction.class, StatusCode.FORBIDDEN);\n\n    /* Compute default url as next available route. We only select static path patterns. */\n    if (options.getDefaultUrl() == null) {\n      int index = app.getRoutes().size();\n      app.onStarting(\n          () -> {\n            List<Route> routes = app.getRoutes();\n            String defaultUrl = app.getContextPath();\n            if (index < routes.size()) {\n              Route route = routes.get(index);\n              if (route.getPathKeys().isEmpty()) {\n                defaultUrl = contextPath + route.getPattern();\n              }\n            }\n            options.setDefaultUrl(defaultUrl);\n          });\n    }\n\n    app.getServices().put(Config.class, options);\n\n    /* Set current user provider */\n    app.setCurrentUser(new Pac4jCurrentUser(options));\n    // cleanup\n    clientMap.clear();\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Pac4jModule.java",
        "method_name": "install",
        "raw_code": "@Override\n  public void install(@NonNull Jooby app) throws Exception {\n    var services = app.getServices();\n    services.putIfAbsent(Pac4jOptions.class, options);\n    // Set defaults:\n    services.putIfAbsent(Serializer.class, options.getSerializer());\n\n    var clients =\n        ofNullable(options.getClients())\n            /* No client? set a default one: */\n            .orElseGet(Clients::new);\n\n    /* No client instance added from DSL, init them from pac4j config. */\n    if (clientMap == null) {\n      clientMap = initializeClients(options);\n    }\n\n    var contextPath = app.getContextPath().equals(\"/\") ? \"\" : app.getContextPath();\n\n    Map<String, List<ClientReference>> allClients = new LinkedHashMap<>();\n\n    /* Should add simple login form? */\n    var devLogin = false;\n    if (clientMap.isEmpty()) {\n      devLogin = true;\n      client(\n          conf ->\n              new FormClient(\n                  contextPath + \"/login\", new SimpleTestUsernamePasswordAuthenticator()));\n    }\n    var conf = app.getConfig();\n    /* Initialize clients from DSL: */\n    for (var routing : clientMap.entrySet()) {\n      var localClients = allClients.computeIfAbsent(routing.getKey(), k -> new ArrayList<>());\n      var path = routing.getValue();\n      for (var candidate : path.clients) {\n        if (candidate instanceof Class) {\n          localClients.add(new ClientReference((Class<Client>) candidate));\n        } else if (candidate instanceof Client) {\n          localClients.add(new ClientReference((Client) candidate));\n        } else {\n          Function<com.typesafe.config.Config, Client> clientProvider =\n              (Function<com.typesafe.config.Config, Client>) candidate;\n          localClients.add(new ClientReference(clientProvider.apply(conf)));\n        }\n      }\n      allClients.put(routing.getKey(), localClients);\n\n      // check for forwarding authorizers\n      for (var authorizerName : path.authorizers) {\n        Authorizer authorizer = options.getAuthorizers().get(authorizerName);\n        if (authorizer instanceof ForwardingAuthorizer) {\n          ((ForwardingAuthorizer) authorizer).setRegistry(app);\n        }\n      }\n    }\n\n    options.getAuthorizers().put(NoopAuthorizer.NAME, new NoopAuthorizer());\n\n    /* Default callback URL if none was set at client level: */\n    clients.setCallbackUrl(\n        ofNullable(clients.getCallbackUrl()).orElse(contextPath + options.getCallbackPath()));\n    /* Default URL resolver if none was set at client level: */\n    clients.setUrlResolver(\n        ofNullable(clients.getUrlResolver()).orElseGet(Pac4jModule::newUrlResolver));\n\n    /* Set resolved clients: */\n    clients.setClients(\n        allClients.values().stream()\n            .flatMap(List::stream)\n            .filter(ClientReference::isResolved)\n            .map(ClientReference::getClient)\n            .collect(Collectors.toList()));\n    options.setClients(clients);\n\n    /* Delay setting unresolved clients: */\n    var unresolved =\n        allClients.values().stream().flatMap(List::stream).filter(r -> !r.isResolved()).toList();\n\n    if (!unresolved.isEmpty()) {\n      app.onStarting(\n          () -> {\n            List<Client> clientList = new ArrayList<>(clients.getClients());\n            unresolved.stream()\n                .peek(r -> r.resolve(app::require))\n                .map(ClientReference::getClient)\n                .forEachOrdered(clientList::add);\n            clients.setClients(clientList);\n\n            /** If the global client was unresolved at initialization, try to set it now: */\n            List<ClientReference> defaultSecurityFilter = allClients.get(\"*\");\n            if (defaultSecurityFilter != null && options.getDefaultClient() == null) {\n              options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n            }\n          });\n    }\n\n    /* Set default http action adapter: */\n    options.setHttpActionAdapter(\n        ofNullable(options.getHttpActionAdapter()).orElseGet(Pac4jModule::newActionAdapter));\n\n    /* WebContextFactory: */\n    options.setWebContextFactory(\n        ofNullable(options.getWebContextFactory()).orElseGet(ContextFactoryImpl::new));\n    options.setSessionStoreFactory(\n        ofNullable(options.getSessionStoreFactory()).orElseGet(SessionStoreFactoryImpl::new));\n    options.setProfileManagerFactory(\n        ofNullable(options.getProfileManagerFactory()).orElse(ProfileManagerFactory.DEFAULT));\n\n    if (devLogin) {\n      app.get(\"/login\", new DevLoginForm(options, contextPath + options.getCallbackPath()));\n    }\n\n    /*\n     * If we have multiple clients on specific paths, we collect those path and configure pac4j to\n     * ignore them. So after login they are redirected to the requested url and not to one of this\n     * sign-in endpoints.\n     *\n     * <pre>\n     *   install(new Pac4jModule()\n     *     .client(\"/google\", ...)\n     *     .client(\"/twitter\", ....);\n     *   );\n     * </pre>\n     *\n     * So <code>google</code> and <code>twitter</code> paths are never saved as requested urls.\n     */\n    var excludes =\n        allClients.keySet().stream()\n            .filter(it -> !it.equals(\"*\"))\n            .map(it -> contextPath + it)\n            .collect(Collectors.toSet());\n\n    var callbackLogic = options.getCallbackLogic();\n    if (callbackLogic == null) {\n      options.setCallbackLogic(newCallbackLogic(excludes));\n    }\n    var direct = clients.getClients().stream().allMatch(it -> it instanceof DirectClient);\n    if (!direct || options.isForceCallbackRoutes()) {\n      CallbackFilterImpl callbackFilter = new CallbackFilterImpl(options, options);\n      app.get(options.getCallbackPath(), callbackFilter);\n      app.post(options.getCallbackPath(), callbackFilter);\n    }\n\n    var securityLogic = options.getSecurityLogic();\n    if (securityLogic == null) {\n      options.setSecurityLogic(newSecurityLogic(excludes));\n    }\n    app.use(new UntrustedSessionDataDetector());\n\n    /** For each client to a specific path, add a security handler. */\n    for (var entry : allClients.entrySet()) {\n      String pattern = entry.getKey();\n      if (!pattern.equals(\"*\")) {\n        List<String> keys = Router.pathKeys(pattern);\n        if (keys.isEmpty()) {\n          SecurityFilterImpl securityFilter =\n              new SecurityFilterImpl(\n                  null,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers);\n          app.get(pattern, securityFilter);\n          // POST for direct authentication\n          app.post(pattern, securityFilter);\n        } else {\n          app.use(\n              new SecurityFilterImpl(\n                  pattern,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers));\n        }\n      }\n    }\n\n    /* Is there is a global client, use it as decorator/filter (default client): */\n    var defaultSecurityFilter = allClients.get(\"*\");\n    if (defaultSecurityFilter != null) {\n      if (options.getDefaultClient() == null && defaultSecurityFilter.get(0).isResolved()) {\n        options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n      }\n      app.use(\n          new SecurityFilterImpl(\n              null,\n              options,\n              options,\n              lazyClientNameList(defaultSecurityFilter),\n              clientMap.get(\"*\").authorizers));\n    }\n\n    /* Logout configuration: */\n    var logoutLogic = options.getLogoutLogic();\n    if (logoutLogic == null) {\n      options.setLogoutLogic(newLogoutLogic());\n    }\n    if (!direct || options.isForceLogoutRoutes()) {\n      app.get(options.getLogoutPath(), new LogoutImpl(options, options));\n    }\n\n    /* Better response code for some errors. */\n    app.errorCode(UnauthorizedAction.class, StatusCode.UNAUTHORIZED);\n    app.errorCode(ForbiddenAction.class, StatusCode.FORBIDDEN);\n\n    /* Compute default url as next available route. We only select static path patterns. */\n    if (options.getDefaultUrl() == null) {\n      int index = app.getRoutes().size();\n      app.onStarting(\n          () -> {\n            List<Route> routes = app.getRoutes();\n            String defaultUrl = app.getContextPath();\n            if (index < routes.size()) {\n              Route route = routes.get(index);\n              if (route.getPathKeys().isEmpty()) {\n                defaultUrl = contextPath + route.getPattern();\n              }\n            }\n            options.setDefaultUrl(defaultUrl);\n          });\n    }\n\n    app.getServices().put(Config.class, options);\n\n    /* Set current user provider */\n    app.setCurrentUser(new Pac4jCurrentUser(options));\n    // cleanup\n    clientMap.clear();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-30373",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "31bc13d3cd6f550ec83473d0f8666cd3ebf50f10",
    "short_hash": "31bc13d3",
    "vulnerableMethods_before": [
      {
        "filename": "HttpHandler.java",
        "method_name": "channelRead0",
        "raw_code": "@Override\n    protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) throws Exception {\n        final Channel channel = ctx.channel();\n        final boolean keepAlive = HttpUtil.isKeepAlive(request);\n        final HttpVersion httpRequestVersion = request.protocolVersion();\n        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);\n\n        if (isNotBlank(authorizationHeader)) {\n            // Authentication is required.\n            final String suppliedAuthHeaderValue = request.headers().get(authorizationHeader);\n            if (isBlank(suppliedAuthHeaderValue) || !suppliedAuthHeaderValue.equals(authorizationHeaderValue)) {\n                writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.UNAUTHORIZED, origin);\n            }\n        }\n\n        // to allow for future changes, let's be at least a little strict in what we accept here.\n        if (HttpMethod.OPTIONS.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.OK, origin);\n            return;\n        } else if (!HttpMethod.POST.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.METHOD_NOT_ALLOWED, origin);\n            return;\n        }\n\n        final boolean correctPath = path.equals(request.uri());\n        if (correctPath && request instanceof FullHttpRequest) {\n            final FullHttpRequest fullHttpRequest = (FullHttpRequest) request;\n            final ByteBuf buffer = fullHttpRequest.content();\n\n            // send on to raw message handler\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.ACCEPTED, origin);\n            ctx.fireChannelRead(buffer.retain());\n        } else {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.NOT_FOUND, origin);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HttpHandler.java",
        "method_name": "channelRead0",
        "raw_code": "@Override\n    protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) throws Exception {\n        final Channel channel = ctx.channel();\n        final boolean keepAlive = HttpUtil.isKeepAlive(request);\n        final HttpVersion httpRequestVersion = request.protocolVersion();\n        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);\n\n        if (isNotBlank(authorizationHeader)) {\n            // Authentication is required.\n            final String suppliedAuthHeaderValue = request.headers().get(authorizationHeader);\n            if (isBlank(suppliedAuthHeaderValue) || !suppliedAuthHeaderValue.equals(authorizationHeaderValue)) {\n                writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.UNAUTHORIZED, origin);\n                return;\n            }\n        }\n\n        // to allow for future changes, let's be at least a little strict in what we accept here.\n        if (HttpMethod.OPTIONS.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.OK, origin);\n            return;\n        } else if (!HttpMethod.POST.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.METHOD_NOT_ALLOWED, origin);\n            return;\n        }\n\n        final boolean correctPath = path.equals(request.uri());\n        if (correctPath && request instanceof FullHttpRequest) {\n            final FullHttpRequest fullHttpRequest = (FullHttpRequest) request;\n            final ByteBuf buffer = fullHttpRequest.content();\n\n            // send on to raw message handler\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.ACCEPTED, origin);\n            ctx.fireChannelRead(buffer.retain());\n        } else {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.NOT_FOUND, origin);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-30373",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "31bc13d3cd6f550ec83473d0f8666cd3ebf50f10",
    "short_hash": "31bc13d3",
    "vulnerableMethods_before": [
      {
        "filename": "HttpHandlerTest.java",
        "method_name": "testAuthentication",
        "raw_code": "private void testAuthentication(String expectedAuthHeader, String expectedAuthHeaderValue, AsciiString suppliedAuthHeader, String suppliedAuthHeaderValue,\n                                    HttpResponseStatus expectedStatus) {\n        final FullHttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/gelf\");\n        httpRequest.headers().add(HOST, \"localhost\");\n        httpRequest.headers().add(ORIGIN, \"http://example.com\");\n        httpRequest.headers().add(CONNECTION, HttpHeaderValues.CLOSE);\n        if (suppliedAuthHeader != null) {\n            httpRequest.headers().add(suppliedAuthHeader, suppliedAuthHeaderValue);\n        }\n\n        httpRequest.content().writeBytes(GELF_MESSAGE);\n\n        channel = new EmbeddedChannel(new HttpHandler(true, expectedAuthHeader, expectedAuthHeaderValue, \"/gelf\"));\n        channel.writeInbound(httpRequest);\n        channel.finish();\n\n        final HttpResponse httpResponse = channel.readOutbound();\n        // Request should be successful.\n        assertThat(httpResponse.status()).isEqualTo(expectedStatus);\n        final HttpHeaders headers = httpResponse.headers();\n        assertThat(headers.get(CONTENT_LENGTH)).isEqualTo(\"0\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_ORIGIN)).isEqualTo(\"http://example.com\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_CREDENTIALS)).isEqualTo(\"true\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_HEADERS)).isEqualTo(\"Authorization, Content-Type\");\n        assertThat(headers.get(CONNECTION)).isEqualTo(HttpHeaderValues.CLOSE.toString());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HttpHandlerTest.java",
        "method_name": "testAuthentication",
        "raw_code": "private void testAuthentication(String expectedAuthHeader, String expectedAuthHeaderValue, AsciiString suppliedAuthHeader, String suppliedAuthHeaderValue,\n                                    HttpResponseStatus expectedStatus) {\n        final FullHttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/gelf\");\n        httpRequest.headers().add(HOST, \"localhost\");\n        httpRequest.headers().add(ORIGIN, \"http://example.com\");\n        httpRequest.headers().add(CONNECTION, HttpHeaderValues.CLOSE);\n        if (suppliedAuthHeader != null) {\n            httpRequest.headers().add(suppliedAuthHeader, suppliedAuthHeaderValue);\n        }\n\n        httpRequest.content().writeBytes(GELF_MESSAGE);\n\n        final DownstreamHandler downstreamHandler = new DownstreamHandler();\n        channel = new EmbeddedChannel(new HttpHandler(true, expectedAuthHeader, expectedAuthHeaderValue, \"/gelf\"), downstreamHandler);\n        channel.writeInbound(httpRequest);\n        channel.finish();\n\n        final HttpResponse httpResponse = channel.readOutbound();\n        // Request should be successful.\n        assertThat(httpResponse.status()).isEqualTo(expectedStatus);\n        final HttpHeaders headers = httpResponse.headers();\n        assertThat(headers.get(CONTENT_LENGTH)).isEqualTo(\"0\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_ORIGIN)).isEqualTo(\"http://example.com\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_CREDENTIALS)).isEqualTo(\"true\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_HEADERS)).isEqualTo(\"Authorization, Content-Type\");\n        assertThat(headers.get(CONNECTION)).isEqualTo(HttpHeaderValues.CLOSE.toString());\n        if (expectedStatus == HttpResponseStatus.ACCEPTED) {\n            assertThat(downstreamHandler.received).isTrue();\n        }else if (expectedStatus == HttpResponseStatus.UNAUTHORIZED) {\n            assertThat(downstreamHandler.received).isFalse();\n        } else {\n            throw new AssertionError(\"Unexpected status: \" + expectedStatus);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "importBot",
        "raw_code": "@Override\n    public void importBot(InputStream zippedBotConfigFiles, AsyncResponse response) {\n        try {\n            if (response != null) response.setTimeout(60, TimeUnit.SECONDS);\n            File targetDir = new File(FileUtilities.buildPath(tmpPath.toString(), UUID.randomUUID().toString()));\n            importBotZipFile(zippedBotConfigFiles, targetDir, response);\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "importBot",
        "raw_code": "@Override\n    public void importBot(InputStream zippedBotConfigFiles, AsyncResponse response) {\n        try {\n            if (response != null) response.setTimeout(60, TimeUnit.SECONDS);\n            File targetDir = new File(FileUtilities.buildPath(tmpPath.toString(), UUID.randomUUID().toString()));\n            importBotZipFile(zippedBotConfigFiles, targetDir, response);\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            if (response != null) {\n                response.resume(new InternalServerErrorException());\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "importBotZipFile",
        "raw_code": "private void importBotZipFile(InputStream zippedBotConfigFiles, File targetDir, AsyncResponse response) throws\n            IOException {\n        this.zipArchive.unzip(zippedBotConfigFiles, targetDir);\n\n        String targetDirPath = targetDir.getPath();\n        Files.newDirectoryStream(Paths.get(targetDirPath),\n                        path -> path.toString().endsWith(BOT_FILE_ENDING))\n                .forEach(botFilePath -> {\n                    try {\n                        String botFileString = readFile(botFilePath);\n                        BotConfiguration botConfiguration =\n                                jsonSerialization.deserialize(botFileString, BotConfiguration.class);\n                        botConfiguration.getPackages().forEach(packageUri ->\n                                parsePackage(targetDirPath, packageUri, botConfiguration, response));\n\n                        URI newBotUri = createNewBot(botConfiguration);\n                        updateDocumentDescriptor(Paths.get(targetDirPath), buildOldBotUri(botFilePath), newBotUri);\n                        response.resume(Response.ok().location(newBotUri).build());\n                    } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException e) {\n                        log.error(e.getLocalizedMessage(), e);\n                        response.resume(new InternalServerErrorException());\n                    }\n                });\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "importBotZipFile",
        "raw_code": "private void importBotZipFile(InputStream zippedBotConfigFiles, File targetDir, AsyncResponse response)\n            throws IOException {\n\n        this.zipArchive.unzip(zippedBotConfigFiles, targetDir);\n        var targetDirPath = targetDir.getPath();\n        try (var directoryStream = Files.newDirectoryStream(Paths.get(targetDirPath),\n                path -> path.toString().endsWith(BOT_FILE_ENDING))) {\n            directoryStream.forEach(botFilePath -> {\n                try {\n                    String botFileString = readFile(botFilePath);\n                    BotConfiguration botConfiguration =\n                            jsonSerialization.deserialize(botFileString, BotConfiguration.class);\n                    botConfiguration.getPackages().forEach(packageUri ->\n                            parsePackage(targetDirPath, packageUri, botConfiguration, response));\n\n                    URI newBotUri = createNewBot(botConfiguration);\n                    updateDocumentDescriptor(Paths.get(targetDirPath), buildOldBotUri(botFilePath), newBotUri);\n                    response.resume(Response.ok().location(newBotUri).build());\n                } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException e) {\n                    log.error(e.getLocalizedMessage(), e);\n                    response.resume(new InternalServerErrorException());\n                }\n            });\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "parsePackage",
        "raw_code": "private void parsePackage(String targetDirPath, URI packageUri, BotConfiguration\n            botConfiguration, AsyncResponse response) {\n        try {\n            IResourceId packageResourceId = RestUtilities.extractResourceId(packageUri);\n            String packageId = packageResourceId.getId();\n            String packageVersion = String.valueOf(packageResourceId.getVersion());\n\n            Files.newDirectoryStream(Paths.get(FileUtilities.buildPath(targetDirPath, packageId, packageVersion)),\n                            packageFilePath -> packageFilePath.toString().endsWith(\".package.json\")).\n                    forEach(packageFilePath -> {\n                        try {\n                            Path packagePath = packageFilePath.getParent();\n                            String packageFileString = readFile(packageFilePath);\n\n                            // loading old resources, creating them in the new system,\n                            // updating document descriptor and replacing references in package config\n\n                            // ... for dictionaries\n                            List<URI> dictionaryUris = extractResourcesUris(packageFileString, DICTIONARY_URI_PATTERN);\n                            List<URI> newDictionaryUris = createNewDictionaries(\n                                    readResources(dictionaryUris, packagePath,\n                                            DICTIONARY_EXT, RegularDictionaryConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, dictionaryUris, newDictionaryUris);\n                            packageFileString = replaceURIs(packageFileString, dictionaryUris, newDictionaryUris);\n\n                            // ... for behavior\n                            List<URI> behaviorUris = extractResourcesUris(packageFileString, BEHAVIOR_URI_PATTERN);\n                            List<URI> newBehaviorUris = createNewBehaviors(\n                                    readResources(behaviorUris, packagePath,\n                                            BEHAVIOR_EXT, BehaviorConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, behaviorUris, newBehaviorUris);\n                            packageFileString = replaceURIs(packageFileString, behaviorUris, newBehaviorUris);\n\n                            // ... for http calls\n                            List<URI> httpCallsUris = extractResourcesUris(packageFileString, HTTPCALLS_URI_PATTERN);\n                            List<URI> newHttpCallsUris = createNewHttpCalls(\n                                    readResources(httpCallsUris, packagePath,\n                                            HTTPCALLS_EXT, HttpCallsConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, httpCallsUris, newHttpCallsUris);\n                            packageFileString = replaceURIs(packageFileString, httpCallsUris, newHttpCallsUris);\n\n                            // ... for langchain\n                            List<URI> langchainUris = extractResourcesUris(packageFileString, LANGCHAIN_URI_PATTERN);\n                            List<URI> newLangchainUris = createNewLangchain(\n                                    readResources(langchainUris, packagePath,\n                                            LANGCHAIN_EXT, LangChainConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, langchainUris, newLangchainUris);\n                            packageFileString = replaceURIs(packageFileString, langchainUris, newLangchainUris);\n\n                            // ... for property\n                            List<URI> propertyUris = extractResourcesUris(packageFileString, PROPERTY_URI_PATTERN);\n                            List<URI> newPropertyUris = createNewProperties(\n                                    readResources(propertyUris, packagePath,\n                                            PROPERTY_EXT, PropertySetterConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, propertyUris, newPropertyUris);\n                            packageFileString = replaceURIs(packageFileString, propertyUris, newPropertyUris);\n\n                            // ... for output\n                            List<URI> outputUris = extractResourcesUris(packageFileString, OUTPUT_URI_PATTERN);\n                            List<URI> newOutputUris = createNewOutputs(\n                                    readResources(outputUris, packagePath,\n                                            OUTPUT_EXT, OutputConfigurationSet.class));\n\n                            updateDocumentDescriptor(packagePath, outputUris, newOutputUris);\n                            packageFileString = replaceURIs(packageFileString, outputUris, newOutputUris);\n\n                            // creating updated package and replacing references in bot config\n                            URI newPackageUri = createNewPackage(packageFileString);\n                            updateDocumentDescriptor(packagePath, packageUri, newPackageUri);\n                            botConfiguration.setPackages(botConfiguration.getPackages().stream().\n                                    map(uri -> uri.equals(packageUri) ? newPackageUri : uri).\n                                    collect(Collectors.toList()));\n\n                        } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException |\n                                 CallbackMatcher.CallbackMatcherException e) {\n                            log.error(e.getLocalizedMessage(), e);\n                            response.resume(new InternalServerErrorException());\n                        }\n                    });\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "parsePackage",
        "raw_code": "private void parsePackage(String targetDirPath, URI packageUri, BotConfiguration\n            botConfiguration, AsyncResponse response) {\n        try {\n            IResourceId packageResourceId = RestUtilities.extractResourceId(packageUri);\n            if (packageResourceId == null) {\n                return;\n            }\n            String packageId = packageResourceId.getId();\n            String packageVersion = String.valueOf(packageResourceId.getVersion());\n\n            var dir = Paths.get(FileUtilities.buildPath(targetDirPath, packageId, packageVersion));\n            try(var directoryStream = Files.newDirectoryStream(dir,\n                    packageFilePath -> packageFilePath.toString().endsWith(\".package.json\"))) {\n                directoryStream.\n                        forEach(packageFilePath -> {\n                            try {\n                                Path packagePath = packageFilePath.getParent();\n                                String packageFileString = readFile(packageFilePath);\n\n                                // loading old resources, creating them in the new system,\n                                // updating document descriptor and replacing references in package config\n\n                                // ... for dictionaries\n                                List<URI> dictionaryUris = extractResourcesUris(packageFileString, DICTIONARY_URI_PATTERN);\n                                List<URI> newDictionaryUris = createNewDictionaries(\n                                        readResources(dictionaryUris, packagePath,\n                                                DICTIONARY_EXT, RegularDictionaryConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, dictionaryUris, newDictionaryUris);\n                                packageFileString = replaceURIs(packageFileString, dictionaryUris, newDictionaryUris);\n\n                                // ... for behavior\n                                List<URI> behaviorUris = extractResourcesUris(packageFileString, BEHAVIOR_URI_PATTERN);\n                                List<URI> newBehaviorUris = createNewBehaviors(\n                                        readResources(behaviorUris, packagePath,\n                                                BEHAVIOR_EXT, BehaviorConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, behaviorUris, newBehaviorUris);\n                                packageFileString = replaceURIs(packageFileString, behaviorUris, newBehaviorUris);\n\n                                // ... for http calls\n                                List<URI> httpCallsUris = extractResourcesUris(packageFileString, HTTPCALLS_URI_PATTERN);\n                                List<URI> newHttpCallsUris = createNewHttpCalls(\n                                        readResources(httpCallsUris, packagePath,\n                                                HTTPCALLS_EXT, HttpCallsConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, httpCallsUris, newHttpCallsUris);\n                                packageFileString = replaceURIs(packageFileString, httpCallsUris, newHttpCallsUris);\n\n                                // ... for langchain\n                                List<URI> langchainUris = extractResourcesUris(packageFileString, LANGCHAIN_URI_PATTERN);\n                                List<URI> newLangchainUris = createNewLangchain(\n                                        readResources(langchainUris, packagePath,\n                                                LANGCHAIN_EXT, LangChainConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, langchainUris, newLangchainUris);\n                                packageFileString = replaceURIs(packageFileString, langchainUris, newLangchainUris);\n\n                                // ... for property\n                                List<URI> propertyUris = extractResourcesUris(packageFileString, PROPERTY_URI_PATTERN);\n                                List<URI> newPropertyUris = createNewProperties(\n                                        readResources(propertyUris, packagePath,\n                                                PROPERTY_EXT, PropertySetterConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, propertyUris, newPropertyUris);\n                                packageFileString = replaceURIs(packageFileString, propertyUris, newPropertyUris);\n\n                                // ... for output\n                                List<URI> outputUris = extractResourcesUris(packageFileString, OUTPUT_URI_PATTERN);\n                                List<URI> newOutputUris = createNewOutputs(\n                                        readResources(outputUris, packagePath,\n                                                OUTPUT_EXT, OutputConfigurationSet.class));\n\n                                updateDocumentDescriptor(packagePath, outputUris, newOutputUris);\n                                packageFileString = replaceURIs(packageFileString, outputUris, newOutputUris);\n\n                                // creating updated package and replacing references in bot config\n                                URI newPackageUri = createNewPackage(packageFileString);\n                                updateDocumentDescriptor(packagePath, packageUri, newPackageUri);\n                                botConfiguration.setPackages(botConfiguration.getPackages().stream().\n                                        map(uri -> uri.equals(packageUri) ? newPackageUri : uri).\n                                        collect(Collectors.toList()));\n\n                            } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException |\n                                     CallbackMatcher.CallbackMatcherException e) {\n                                log.error(e.getLocalizedMessage(), e);\n                                response.resume(new InternalServerErrorException());\n                            }\n                        });\n\n            }\n\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "updateDocumentDescriptor",
        "raw_code": "private void updateDocumentDescriptor(Path directoryPath, List<URI> oldUris, List<URI> newUris)\n            throws RestInterfaceFactory.RestInterfaceFactoryException {\n\n        IRestDocumentDescriptorStore restDocumentDescriptorStore = getRestResourceStore(IRestDocumentDescriptorStore.class);\n        IntStream.range(0, oldUris.size()).forEach(idx -> {\n            try {\n                URI oldUri = oldUris.get(idx);\n                IResourceId oldResourceId = RestUtilities.extractResourceId(oldUri);\n                DocumentDescriptor oldDocumentDescriptor = readDocumentDescriptorFromFile(directoryPath, oldResourceId);\n\n                URI newUri = newUris.get(idx);\n                IResourceId newResourceId = RestUtilities.extractResourceId(newUri);\n\n                PatchInstruction<DocumentDescriptor> patchInstruction = new PatchInstruction<>();\n                patchInstruction.setOperation(PatchInstruction.PatchOperation.SET);\n                patchInstruction.setDocument(oldDocumentDescriptor);\n\n                restDocumentDescriptorStore.patchDescriptor(newResourceId.getId(), newResourceId.getVersion(), patchInstruction);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n            }\n        });\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "updateDocumentDescriptor",
        "raw_code": "private void updateDocumentDescriptor(Path directoryPath, List<URI> oldUris, List<URI> newUris)\n            throws RestInterfaceFactory.RestInterfaceFactoryException {\n\n        IRestDocumentDescriptorStore restDocumentDescriptorStore = getRestResourceStore(IRestDocumentDescriptorStore.class);\n        IntStream.range(0, oldUris.size()).forEach(idx -> {\n            try {\n                URI oldUri = oldUris.get(idx);\n                IResourceId oldResourceId = RestUtilities.extractResourceId(oldUri);\n                if (oldResourceId != null) {\n                    var oldDocumentDescriptor = readDocumentDescriptorFromFile(directoryPath, oldResourceId);\n\n                    URI newUri = newUris.get(idx);\n                    IResourceId newResourceId = RestUtilities.extractResourceId(newUri);\n\n                    if (newResourceId != null) {\n                        PatchInstruction<DocumentDescriptor> patchInstruction = new PatchInstruction<>();\n                        patchInstruction.setOperation(PatchInstruction.PatchOperation.SET);\n                        patchInstruction.setDocument(oldDocumentDescriptor);\n\n                        restDocumentDescriptorStore.patchDescriptor(newResourceId.getId(),\n                                newResourceId.getVersion(), patchInstruction);\n                    }\n                }\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n            }\n        });\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "readResources",
        "raw_code": "@SuppressWarnings(\"unchecked\")\n    private <T> List<T> readResources(List<URI> uris, Path packagePath, String extension, Class<T> clazz) {\n        return uris.stream().map(uri -> {\n            Path resourcePath = null;\n            String resourceContent = null;\n            try {\n                IResourceId resourceId = RestUtilities.extractResourceId(uri);\n                resourcePath = createResourcePath(packagePath, resourceId.getId(), extension);\n                resourceContent = readFile(resourcePath);\n                if (uri.toString().startsWith(IRestPropertySetterStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedPropertySetterDocument =\n                            migrationManager.migratePropertySetter().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedPropertySetterDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedPropertySetterDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestHttpCallsStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedHttpCallsDocument =\n                            migrationManager.migrateHttpCalls().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedHttpCallsDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedHttpCallsDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestOutputStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedOutputDocument =\n                            migrationManager.migrateOutput().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedOutputDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedOutputDocument);\n                    }\n                }\n                return jsonSerialization.deserialize(resourceContent, clazz);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n                log.error(String.format(\"uri is: %s\", uri));\n                log.error(String.format(\"packagePath is: %s\", packagePath));\n                log.error(String.format(\"resourcePath is: %s\", resourcePath));\n                log.error(String.format(\"resourceContent is:\\n%s\", resourceContent));\n                return null;\n            }\n        }).collect(Collectors.toList());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "readResources",
        "raw_code": "@SuppressWarnings(\"unchecked\")\n    private <T> List<T> readResources(List<URI> uris, Path packagePath, String extension, Class<T> clazz) {\n        return uris.stream().map(uri -> {\n            Path resourcePath = null;\n            String resourceContent = null;\n            try {\n                IResourceId resourceId = RestUtilities.extractResourceId(uri);\n                if (resourceId == null) {\n                    throw new IOException(\"resourceId was null\");\n                }\n                resourcePath = createResourcePath(packagePath, resourceId.getId(), extension);\n                resourceContent = readFile(resourcePath);\n                if (uri.toString().startsWith(IRestPropertySetterStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedPropertySetterDocument =\n                            migrationManager.migratePropertySetter().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedPropertySetterDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedPropertySetterDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestHttpCallsStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedHttpCallsDocument =\n                            migrationManager.migrateHttpCalls().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedHttpCallsDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedHttpCallsDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestOutputStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedOutputDocument =\n                            migrationManager.migrateOutput().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedOutputDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedOutputDocument);\n                    }\n                }\n                return jsonSerialization.deserialize(resourceContent, clazz);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n                log.error(String.format(\"uri is: %s\", uri));\n                log.error(String.format(\"packagePath is: %s\", packagePath));\n                log.error(String.format(\"resourcePath is: %s\", resourcePath));\n                log.error(String.format(\"resourceContent is:\\n%s\", resourceContent));\n                return null;\n            }\n        }).collect(Collectors.toList());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "ZipArchive.java",
        "method_name": "writeZipFile",
        "raw_code": "private static void writeZipFile(String targetZipFile, File directoryToZip, List<File> fileList) throws IOException {\n        FileOutputStream fos = new FileOutputStream(targetZipFile);\n        ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(fos));\n\n        for (File file : fileList) {\n            if (!file.isDirectory()) { // we only zip files, not directories\n                addToZip(directoryToZip, file, zos);\n            }\n        }\n\n        zos.close();\n        fos.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ZipArchive.java",
        "method_name": "writeZipFile",
        "raw_code": "private static void writeZipFile(String targetZipFile, File directoryToZip, List<File> fileList) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(targetZipFile);\n             ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(fos))) {\n\n            for (File file : fileList) {\n                if (!file.isDirectory()) {\n                    addToZip(directoryToZip, file, zos);\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "ZipArchive.java",
        "method_name": "addToZip",
        "raw_code": "private static void addToZip(File directoryToZip, File file, ZipOutputStream zos) throws IOException {\n        FileInputStream fis = new FileInputStream(file);\n\n        String zipFilePath = file.getCanonicalPath().\n                substring(directoryToZip.getCanonicalPath().length() + 1).replace('\\\\', '/');\n        ZipEntry zipEntry = new ZipEntry(zipFilePath);\n        zos.putNextEntry(zipEntry);\n\n        byte[] bytes = new byte[1024];\n        int length;\n        while ((length = fis.read(bytes)) >= 0) {\n            zos.write(bytes, 0, length);\n        }\n\n        zos.closeEntry();\n        fis.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ZipArchive.java",
        "method_name": "addToZip",
        "raw_code": "private static void addToZip(File directoryToZip, File file, ZipOutputStream zos) throws IOException {\n        // Use try-with-resources for automatic stream closing\n        try (FileInputStream fis = new FileInputStream(file)) {\n            // Ensure consistent path separators and protect against traversal in entry name creation itself\n            var zipEntry = getZipEntry(directoryToZip, file);\n            zos.putNextEntry(zipEntry);\n\n            byte[] bytes = new byte[BUFFER_SIZE];\n            int length;\n            while ((length = fis.read(bytes)) >= 0) {\n                zos.write(bytes, 0, length);\n            }\n            zos.closeEntry();\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "ZipArchive.java",
        "method_name": "unzip",
        "raw_code": "@Override\n    public void unzip(InputStream zipFile, File targetDir) throws IOException {\n        if (!targetDir.exists()) {\n            targetDir.mkdir();\n        }\n        ZipInputStream zipIn = new ZipInputStream(zipFile);\n\n        ZipEntry entry = zipIn.getNextEntry();\n        // iterates over entries in the zip file\n        while (entry != null) {\n            String filePath = targetDir.getPath() + File.separator + entry.getName();\n            if (!entry.isDirectory()) {\n                // if the entry is a file, extracts it\n                new File(filePath).getParentFile().mkdirs();\n                extractFile(zipIn, filePath);\n            } else {\n                // if the entry is a directory, make the directory\n                File dir = new File(filePath);\n                dir.mkdirs();\n            }\n            zipIn.closeEntry();\n            entry = zipIn.getNextEntry();\n        }\n        zipIn.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ZipArchive.java",
        "method_name": "unzip",
        "raw_code": "@Override\n    public void unzip(InputStream zipFile, File targetDir) throws IOException {\n        if (!targetDir.exists()) {\n            if (!targetDir.mkdirs()) {\n                throw new IOException(\"Could not create target directory: \" + targetDir);\n            }\n        }\n\n        String targetDirPath = targetDir.getCanonicalPath();\n        try (ZipInputStream zipIn = new ZipInputStream(new BufferedInputStream(zipFile))) {\n            ZipEntry entry;\n            while ((entry = zipIn.getNextEntry()) != null) {\n                File destFile = new File(targetDir, entry.getName());\n                String destFilePath = destFile.getCanonicalPath();\n\n                // Ensure the resolved destination path starts with the target directory path\n                if (!destFilePath.startsWith(targetDirPath + File.separator)) {\n                    throw new IOException(\"Entry is outside of the target dir: \" + entry.getName());\n                }\n\n                if (entry.isDirectory()) {\n                    if (!destFile.mkdirs() && !destFile.isDirectory()) {\n                        throw new IOException(\"Could not create directory: \" + destFilePath);\n                    }\n                } else {\n                    File parentDir = destFile.getParentFile();\n                    if (!parentDir.mkdirs() && !parentDir.isDirectory()) {\n                        throw new IOException(\"Could not create parent directories for: \" + destFilePath);\n                    }\n                    extractFile(zipIn, destFile);\n                }\n                zipIn.closeEntry();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "ZipArchive.java",
        "method_name": "extractFile",
        "raw_code": "private void extractFile(ZipInputStream zipIn, String filePath) throws IOException {\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath));\n        byte[] bytesIn = new byte[BUFFER_SIZE];\n        int read;\n        while ((read = zipIn.read(bytesIn)) != -1) {\n            bos.write(bytesIn, 0, read);\n        }\n        bos.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ZipArchive.java",
        "method_name": "extractFile",
        "raw_code": "private void extractFile(ZipInputStream zipIn, File destFile) throws IOException {\n        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile))) {\n            byte[] bytesIn = new byte[BUFFER_SIZE];\n            int read;\n            while ((read = zipIn.read(bytesIn)) != -1) {\n                bos.write(bytesIn, 0, read);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-32429",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "dfd0744e9c18d24ac66a0d261dc6cafd1c209101",
    "short_hash": "dfd0744e",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultHQLStatementValidator.java",
        "method_name": "checkOrderBySafe",
        "raw_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Usafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultHQLStatementValidator.java",
        "method_name": "checkOrderBySafe",
        "raw_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Unsafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-32429",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "f502b5d5fd36284a50890ad26d168b7d8dc80bd3",
    "short_hash": "f502b5d5",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultHQLStatementValidator.java",
        "method_name": "checkOrderBySafe",
        "raw_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Usafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultHQLStatementValidator.java",
        "method_name": "checkOrderBySafe",
        "raw_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Unsafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "dataease",
    "cve_id": "CVE-2025-48999",
    "cwe_list": [
      "CWE-923"
    ],
    "commit_hash": "03b18db8a0fb7e9dc2c44f6d26d8c6221b7748c4",
    "short_hash": "03b18db8",
    "vulnerableMethods_before": [
      {
        "filename": "Redshift.java",
        "method_name": "getJdbc",
        "raw_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        return \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getLHost().trim())\n                .replace(\"PORT\", getLPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Redshift.java",
        "method_name": "getJdbc",
        "raw_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).contains(illegalParameter)) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        return \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getLHost().trim())\n                .replace(\"PORT\", getLPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJob.java",
        "method_name": "runInternal",
        "raw_code": "@Override\n    protected void runInternal() throws Exception\n    {\n        if (!this.request.getDocuments().isEmpty()) {\n            this.requiredSkinExtensionsRecorder.start();\n            render(this.request.getDocuments());\n            if (!this.status.isCanceled()) {\n                this.status.setRequiredSkinExtensions(this.requiredSkinExtensionsRecorder.stop());\n            }\n\n            if (this.request.isServerSide() && !this.status.isCanceled()) {\n                saveAsPDF();\n                this.status.getDocumentRenderingResults().clear();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJob.java",
        "method_name": "runInternal",
        "raw_code": "@Override\n    protected void runInternal() throws Exception\n    {\n        try {\n            exportAsPDF();\n        } finally {\n            cleanup();\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runServerSide",
        "raw_code": "@Test\n    void runServerSide() throws Exception\n    {\n        when(this.requiredSkinExtensionsRecorder.stop()).thenReturn(\"required skin extensions\");\n\n        URL printPreviewURL = new URL(\"http://www.xwiki.org\");\n        when(this.printPreviewURLBuilder.getPrintPreviewURL(this.request)).thenReturn(printPreviewURL);\n\n        InputStream pdfContent = mock(InputStream.class);\n        when(this.pdfPrinter.print(printPreviewURL)).thenReturn(pdfContent);\n\n        this.request.setServerSide(true);\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        verify(this.requiredSkinExtensionsRecorder).start();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertEquals(\"required skin extensions\", jobStatus.getRequiredSkinExtensions());\n        assertEquals(0, jobStatus.getDocumentRenderingResults().size());\n\n        TemporaryResourceReference pdfFileReference = jobStatus.getPDFFileReference();\n        verify(this.temporaryResourceStore).createTemporaryFile(pdfFileReference, pdfContent);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runServerSide",
        "raw_code": "@Test\n    void runServerSide() throws Exception\n    {\n        when(this.requiredSkinExtensionsRecorder.stop()).thenReturn(\"required skin extensions\");\n\n        URL printPreviewURL = new URL(\"http://www.xwiki.org\");\n        when(this.printPreviewURLBuilder.getPrintPreviewURL(this.request)).thenReturn(printPreviewURL);\n\n        InputStream pdfContent = mock(InputStream.class);\n        when(this.pdfPrinter.print(printPreviewURL)).thenReturn(pdfContent);\n\n        this.request.setServerSide(true);\n        this.request.getContext().put(\"request.session\", \"session\");\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        verify(this.requiredSkinExtensionsRecorder).start();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertEquals(\"required skin extensions\", jobStatus.getRequiredSkinExtensions());\n        assertEquals(0, jobStatus.getDocumentRenderingResults().size());\n\n        TemporaryResourceReference pdfFileReference = jobStatus.getPDFFileReference();\n        verify(this.temporaryResourceStore).createTemporaryFile(pdfFileReference, pdfContent);\n\n        assertFalse(this.request.getContext().containsKey(\"request.session\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runClientSide",
        "raw_code": "@Test\n    void runClientSide() throws Exception\n    {\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertNull(jobStatus.getPDFFileReference());\n\n        verify(this.temporaryResourceStore, never()).createTemporaryFile(any(TemporaryResourceReference.class),\n            any(InputStream.class));\n\n        List<DocumentRenderingResult> renderingResults = jobStatus.getDocumentRenderingResults();\n        assertEquals(2, renderingResults.size());\n        assertSame(this.firstPageRendering, renderingResults.get(0));\n        assertSame(this.secondPageRendering, renderingResults.get(1));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runClientSide",
        "raw_code": "@Test\n    void runClientSide() throws Exception\n    {\n        this.request.getContext().put(\"request.headers\", \"headers\");\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertNull(jobStatus.getPDFFileReference());\n\n        verify(this.temporaryResourceStore, never()).createTemporaryFile(any(TemporaryResourceReference.class),\n            any(InputStream.class));\n\n        List<DocumentRenderingResult> renderingResults = jobStatus.getDocumentRenderingResults();\n        assertEquals(2, renderingResults.size());\n        assertSame(this.firstPageRendering, renderingResults.get(0));\n        assertSame(this.secondPageRendering, renderingResults.get(1));\n\n        assertFalse(this.request.getContext().containsKey(\"request.headers\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runWithoutDocuments",
        "raw_code": "@Test\n    void runWithoutDocuments() throws Exception\n    {\n        this.request.setDocuments(Collections.emptyList());\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertNull(jobStatus.getPDFFileReference());\n        assertNull(jobStatus.getRequiredSkinExtensions());\n        assertEquals(0, jobStatus.getDocumentRenderingResults().size());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runWithoutDocuments",
        "raw_code": "@Test\n    void runWithoutDocuments() throws Exception\n    {\n        this.request.getContext().put(\"request.cookies\", \"cookies\");\n        this.request.setDocuments(Collections.emptyList());\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertNull(jobStatus.getPDFFileReference());\n        assertNull(jobStatus.getRequiredSkinExtensions());\n        assertEquals(0, jobStatus.getDocumentRenderingResults().size());\n\n        assertFalse(this.request.getContext().containsKey(\"request.cookies\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runWithContentSizeLimitExceeded",
        "raw_code": "@Test\n    void runWithContentSizeLimitExceeded() throws Exception\n    {\n        DocumentRenderingResult largeResult = new DocumentRenderingResult(this.secondPageReference,\n            new XDOM(Collections.singletonList(new WordBlock(\"second\"))), StringUtils.repeat('x', 1000));\n        when(this.documentRenderer.render(this.secondPageReference, this.rendererParameters)).thenReturn(largeResult);\n\n        this.pdfExportJob.initialize(this.request);\n        try {\n            this.pdfExportJob.runInternal();\n            fail();\n        } catch (Exception e) {\n            assertEquals(\n                \"The content size exceeds the configured 1KB limit. Wiki administrators can increase\"\n                    + \" or disable this limit from the PDF Export administration section or from XWiki properties.\",\n                e.getMessage());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runWithContentSizeLimitExceeded",
        "raw_code": "@Test\n    void runWithContentSizeLimitExceeded() throws Exception\n    {\n        DocumentRenderingResult largeResult = new DocumentRenderingResult(this.secondPageReference,\n            new XDOM(Collections.singletonList(new WordBlock(\"second\"))), StringUtils.repeat('x', 1000));\n        when(this.documentRenderer.render(this.secondPageReference, this.rendererParameters)).thenReturn(largeResult);\n\n        this.request.getContext().put(\"request.cookies\", \"cookies\");\n        this.request.getContext().put(\"request.foo\", \"bar\");\n        this.pdfExportJob.initialize(this.request);\n        try {\n            this.pdfExportJob.runInternal();\n            fail();\n        } catch (Exception e) {\n            assertEquals(\n                \"The content size exceeds the configured 1KB limit. Wiki administrators can increase\"\n                    + \" or disable this limit from the PDF Export administration section or from XWiki properties.\",\n                e.getMessage());\n        }\n\n        assertFalse(this.request.getContext().containsKey(\"request.cookies\"));\n        assertEquals(\"bar\", this.request.getContext().get(\"request.foo\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-blog",
    "cve_id": "CVE-2025-58365",
    "cwe_list": [
      "CWE-95"
    ],
    "commit_hash": "b98ab6f17da3029576f42d12b4442cd555c7e0b4",
    "short_hash": "b98ab6f1",
    "vulnerableMethods_before": [
      {
        "filename": "BlogScriptService.java",
        "method_name": "renderRSSDescription",
        "raw_code": "public String renderRSSDescription(String contentToRender, Document blogDocument) throws XWikiException\n    {\n        XWikiContext context = this.xwikiContextProvider.get();\n        XWikiURLFactory currentURLFactory = context.getURLFactory();\n        try {\n            context.setURLFactory(new ExternalServletURLFactory(context));\n            return blogDocument.getRenderedContent(contentToRender, blogDocument.getSyntax().toIdString());\n        } finally {\n            context.setURLFactory(currentURLFactory);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BlogScriptService.java",
        "method_name": "renderRSSDescription",
        "raw_code": "@Deprecated\n    public String renderRSSDescription(String contentToRender, Document blogDocument) throws XWikiException\n    {\n        XWikiContext context = this.xwikiContextProvider.get();\n        XWikiURLFactory currentURLFactory = context.getURLFactory();\n        try {\n            context.setURLFactory(new ExternalServletURLFactory(context));\n            return blogDocument.getRenderedContent(contentToRender, blogDocument.getSyntax().toIdString());\n        } finally {\n            context.setURLFactory(currentURLFactory);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-55747",
    "cwe_list": [
      "CWE-23"
    ],
    "commit_hash": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
    "short_hash": "9e7b4c03",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractServletResourceReferenceHandler.java",
        "method_name": "handle",
        "raw_code": "@Override\n    public void handle(ResourceReference resourceReference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        @SuppressWarnings(\"unchecked\")\n        R typedResourceReference = (R) resourceReference;\n\n        if (!isResourceAccessible(typedResourceReference)) {\n            sendError(HttpStatus.SC_FORBIDDEN, \"You are not allowed to view [%s].\",\n                getResourceName(typedResourceReference));\n        } else if (!shouldBrowserUseCachedContent(typedResourceReference)) {\n            // If we get here then either the resource is not cached by the browser or the resource is dynamic.\n            try (InputStream resourceStream = getResourceStream(typedResourceReference)) {\n                if (resourceStream != null) {\n                    try (InputStream filteredSteam = filterResource(typedResourceReference, resourceStream)) {\n                        serveResource(typedResourceReference, filteredSteam);\n                    }\n                } else {\n                    sendError(HttpStatus.SC_NOT_FOUND, \"Resource not found [%s].\",\n                        getResourceName(typedResourceReference));\n                }\n            } catch (IOException | ResourceReferenceHandlerException e) {\n                this.logger.error(e.getMessage(), e);\n                sendError(HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n            }\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority handler has something to do for this\n        // resource reference.\n        chain.handleNext(resourceReference);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractServletResourceReferenceHandler.java",
        "method_name": "handle",
        "raw_code": "@Override\n    public void handle(ResourceReference resourceReference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        @SuppressWarnings(\"unchecked\")\n        R typedResourceReference = (R) resourceReference;\n\n        if (!isResourceAccessible(typedResourceReference)) {\n            sendError(HttpStatus.SC_FORBIDDEN, \"You are not allowed to view [%s].\",\n                getResourceName(typedResourceReference));\n        } else if (!shouldBrowserUseCachedContent(typedResourceReference)) {\n            // If we get here then either the resource is not cached by the browser or the resource is dynamic.\n            try (InputStream resourceStream = getResourceStream(typedResourceReference)) {\n                if (resourceStream != null) {\n                    try (InputStream filteredSteam = filterResource(typedResourceReference, resourceStream)) {\n                        serveResource(typedResourceReference, filteredSteam);\n                    }\n                } else {\n                    sendError(HttpStatus.SC_NOT_FOUND, \"Resource not found [%s].\",\n                        getResourceName(typedResourceReference));\n                }\n            } catch (Exception e) {\n                this.logger.error(e.getMessage(), e);\n                sendError(HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n            }\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority handler has something to do for this\n        // resource reference.\n        chain.handleNext(resourceReference);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-55747",
    "cwe_list": [
      "CWE-23"
    ],
    "commit_hash": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
    "short_hash": "9e7b4c03",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "InternalTemplateManager.java",
        "method_name": "getClassloaderTemplate",
        "raw_code": "private Template getClassloaderTemplate(ClassLoader classloader, String prefixPath, String templateName)\n    {\n        URL url;\n        try {\n            url = ClassLoaderUtils.getResource(classloader, prefixPath, templateName);\n        } catch (IllegalArgumentException e) {\n            this.logger.warn(\"The template name [{}] is trying to execute a path traversal attack!\", templateName);\n\n            return null;\n        }\n\n        return url != null ? new ClassloaderTemplate(new ClassloaderResource(url, templateName)) : null;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-55747",
    "cwe_list": [
      "CWE-23"
    ],
    "commit_hash": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
    "short_hash": "9e7b4c03",
    "vulnerableMethods_before": [
      {
        "filename": "WebJarsResourceReferenceHandler.java",
        "method_name": "getResourceStream",
        "raw_code": "@Override\n    protected InputStream getResourceStream(WebJarsResourceReference resourceReference)\n    {\n        String resourcePath = String.format(\"%s%s\", WEBJARS_RESOURCE_PREFIX, getResourceName(resourceReference));\n        return getClassLoader(resourceReference.getNamespace()).getResourceAsStream(resourcePath);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "WebJarsResourceReferenceHandler.java",
        "method_name": "getResourceStream",
        "raw_code": "@Override\n    protected InputStream getResourceStream(WebJarsResourceReference resourceReference)\n    {\n        return ClassLoaderUtils.getResourceAsStream(getClassLoader(resourceReference.getNamespace()),\n            WEBJARS_RESOURCE_PREFIX, getResourceName(resourceReference));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-55747",
    "cwe_list": [
      "CWE-23"
    ],
    "commit_hash": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
    "short_hash": "9e7b4c03",
    "vulnerableMethods_before": [
      {
        "filename": "SxResourceSource.java",
        "method_name": "getContent",
        "raw_code": "@Override\n    public String getContent()\n    {\n        try {\n            // Load from the current context class loader to allow extensions to contribute skin extensions.\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            try (InputStream in = contextClassLoader.getResourceAsStream(this.resourceName)) {\n                return IOUtils.toString(in, StandardCharsets.UTF_8);\n            }\n        } catch (NullPointerException e) {\n            // This happens when the file was not found. Forward an IAE so that the sx action returns 404\n            throw new IllegalArgumentException(e);\n        } catch (IOException e) {\n            return \"\";\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SxResourceSource.java",
        "method_name": "getContent",
        "raw_code": "@Override\n    public String getContent()\n    {\n        try {\n            // Load from the current context class loader to allow extensions to contribute skin extensions.\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            try (InputStream in = ClassLoaderUtils.getResourceAsStream(contextClassLoader, this.resourceName)) {\n                return IOUtils.toString(in, StandardCharsets.UTF_8);\n            }\n        } catch (NullPointerException e) {\n            // This happens when the file was not found. Forward an IAE so that the sx action returns 404\n            throw new IllegalArgumentException(e);\n        } catch (IOException e) {\n            return \"\";\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "Java-springboot-codebase",
    "cve_id": "CVE-2025-46822",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "c835c6f7799eacada4c0fc77e0816f250af01ad2",
    "short_hash": "c835c6f7",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "FileSystemStorageService.java",
        "method_name": "store",
        "raw_code": "@Override\n    public int store(MultipartFile file, String nameAndExt) {\n        Path location = Paths.get(rootLocation+\"/\");\n\n        try {\n            Files.createDirectories(location);\n            if (file.isEmpty()) {\n                return OP_STATUS_FILE_EMPTY;\n            }\n            if (nameAndExt.contains(\"..\") || !fileNamePattern.matcher(nameAndExt).matches()) {\n                // This is a security check\n               return OP_STATUS_INVALID_FILE_NAME;\n            }\n\n            if(!isAllowedFileType(file)) return OP_STATUS_FILE_TYPE_NOT_ALLOWED;\n\n            try (InputStream inputStream = file.getInputStream()) {\n\n                Files.copy(inputStream, location.resolve(nameAndExt),\n                        StandardCopyOption.REPLACE_EXISTING);\n\n                if(isImage(FilenameUtils.getExtension(file.getOriginalFilename()))){\n                    createThumbnail(file,thumbWidth,nameAndExt);\n                }\n            }\n            return OP_STATUS_SUCCESS;\n        }\n        catch (IOException e) {\n            log.error(\"[EXCEPTION] store : {},{}\",e.getMessage(),e.getCause());\n            return OP_STATUS_FAILED;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "Java-springboot-codebase",
    "cve_id": "CVE-2025-46822",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "c835c6f7799eacada4c0fc77e0816f250af01ad2",
    "short_hash": "c835c6f7",
    "vulnerableMethods_before": [
      {
        "filename": "FileSystemStorageService.java",
        "method_name": "loadAsResource",
        "raw_code": "@Override\n    public Resource loadAsResource(String filename) {\n        try {\n            Path location = Paths.get(rootLocation+\"/\");\n            Path file = load(filename,location);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            }\n            else {\n              return null;\n            }\n        } catch (MalformedURLException e) {\n           log.error(\"[EXCEPTION] loadAsResource: {},{}\",e.getMessage(),e.getCause());\n           return null;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileSystemStorageService.java",
        "method_name": "loadAsResource",
        "raw_code": "@Override\n    public Resource loadAsResource(String filename) {\n        try {\n            if(!fileNamePattern.matcher(filename).matches()){\n                log.error(\"[ERROR] loadAsResource: invalid file name\");\n                return null;\n            }\n            Path location = Paths.get(rootLocation+\"/\");\n            Path file = load(filename,location);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            }\n            else {\n              return null;\n            }\n        } catch (MalformedURLException e) {\n           log.error(\"[EXCEPTION] loadAsResource: {},{}\",e.getMessage(),e.getCause());\n           return null;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "fess",
    "cve_id": "CVE-2025-48382",
    "cwe_list": [
      "CWE-732"
    ],
    "commit_hash": "25b2009fea2a0f6ccd5aa8154aa54b536c08f6c4",
    "short_hash": "25b2009f",
    "vulnerableMethods_before": [
      {
        "filename": "SystemHelper.java",
        "method_name": "createTempFile",
        "raw_code": "public File createTempFile(final String prefix, final String suffix) {\n        try {\n            final File file = File.createTempFile(prefix, suffix);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Create {} as a temp file.\", file.getAbsolutePath());\n            }\n            return file;\n        } catch (final IOException e) {\n            throw new IORuntimeException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SystemHelper.java",
        "method_name": "createTempFile",
        "raw_code": "public File createTempFile(final String prefix, final String suffix) {\n        try {\n            final File file = File.createTempFile(prefix, suffix);\n            file.setReadable(false, false);\n            file.setReadable(true, true);\n            file.setWritable(false, false);\n            file.setWritable(true, true);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Create {} as a temp file.\", file.getAbsolutePath());\n            }\n            return file;\n        } catch (final IOException e) {\n            throw new IORuntimeException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "para",
    "cve_id": "CVE-2025-48955",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "1e8a89558542854bb0683ab234c4429ad93b0835",
    "short_hash": "1e8a8955",
    "vulnerableMethods_before": [
      {
        "filename": "HealthUtils.java",
        "method_name": "saveConfigFile",
        "raw_code": "private void saveConfigFile(String confFile, Map<String, String> rootAppCredentials) {\n\t\t\tif (rootAppCredentials.containsKey(\"secretKey\")) {\n\t\t\t\tString confString = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tconfString = loadConfigFile(confFile);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlogger.info(\"Initialized root app with access key '{}' and secret '{}', \"\n\t\t\t\t\t\t\t+ \"but could not write these to {}.\",\n\t\t\t\t\t\t\trootAppCredentials.get(\"accessKey\"), rootAppCredentials.get(\"secretKey\"), confFile);\n\t\t\t\t}\n\t\t\t\tString accessKey = \"para.root_access_key = \\\"\" + rootAppCredentials.get(\"accessKey\") + \"\\\"\";\n\t\t\t\tString secretKey = \"para.root_secret_key = \\\"\" + rootAppCredentials.get(\"secretKey\") + \"\\\"\";\n\t\t\t\tif (confString.contains(\"para.root_access_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_access_key\\\\s*=\\\\s*\\\".*?\\\"\", accessKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + accessKey;\n\t\t\t\t}\n\t\t\t\tif (confString.contains(\"para.root_secret_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_secret_key\\\\s*=\\\\s*\\\".*?\\\"\", secretKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + secretKey;\n\t\t\t\t}\n\t\t\t\tPara.getFileStore().store(confFile, new ByteArrayInputStream(confString.\n\t\t\t\t\t\tgetBytes(StandardCharsets.UTF_8)));\n\t\t\t\tlogger.info(\"Saved root app credentials to {}.\", confFile);\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Server is unhealthy - failed to initialize root app. Open http://localhost:\" +\n\t\t\t\t\t\tPara.getConfig().serverPort() + \"/v1/_setup in the browser to initialize Para manually.\");\n\t\t\t}\n\t\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HealthUtils.java",
        "method_name": "saveConfigFile",
        "raw_code": "private void saveConfigFile(String confFile, Map<String, String> rootAppCredentials) {\n\t\t\tif (rootAppCredentials.containsKey(\"secretKey\")) {\n\t\t\t\tString confString = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tconfString = loadConfigFile(confFile);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlogger.info(\"Initialized root app with access key '{}', \"\n\t\t\t\t\t\t\t+ \"but could not write to {}.\", rootAppCredentials.get(\"accessKey\"), confFile);\n\t\t\t\t}\n\t\t\t\tString accessKey = \"para.root_access_key = \\\"\" + rootAppCredentials.get(\"accessKey\") + \"\\\"\";\n\t\t\t\tString secretKey = \"para.root_secret_key = \\\"\" + rootAppCredentials.get(\"secretKey\") + \"\\\"\";\n\t\t\t\tif (confString.contains(\"para.root_access_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_access_key\\\\s*=\\\\s*\\\".*?\\\"\", accessKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + accessKey;\n\t\t\t\t}\n\t\t\t\tif (confString.contains(\"para.root_secret_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_secret_key\\\\s*=\\\\s*\\\".*?\\\"\", secretKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + secretKey;\n\t\t\t\t}\n\t\t\t\tPara.getFileStore().store(confFile, new ByteArrayInputStream(confString.\n\t\t\t\t\t\tgetBytes(StandardCharsets.UTF_8)));\n\t\t\t\tlogger.info(\"Saved root app credentials to {}.\", confFile);\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Server is unhealthy - failed to initialize root app. Open http://localhost:\" +\n\t\t\t\t\t\tPara.getConfig().serverPort() + \"/v1/_setup in the browser to initialize Para manually.\");\n\t\t\t}\n\t\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "para",
    "cve_id": "CVE-2025-49009",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "46a908d887da02037384193f70a69345f04887cf",
    "short_hash": "46a908d8",
    "vulnerableMethods_before": [
      {
        "filename": "FacebookAuthFilter.java",
        "method_name": "getOrCreateUser",
        "raw_code": "@SuppressWarnings(\"unchecked\")\n\tpublic UserAuthentication getOrCreateUser(App app, String accessToken) throws IOException {\n\t\tif (accessToken == null) {\n\t\t\treturn SecurityUtils.checkIfActive(null, null, false);\n\t\t}\n\t\tHttpGet profileGet = new HttpGet(PROFILE_URL + accessToken);\n\t\treturn httpclient.execute(profileGet, (resp2) -> {\n\t\t\tUserAuthentication userAuth = null;\n\t\t\tUser user = new User();\n\t\t\ttry {\n\t\t\t\tHttpEntity respEntity = resp2.getEntity();\n\t\t\t\tif (respEntity != null) {\n\t\t\t\t\tMap<String, Object> profile = jreader.readValue(respEntity.getContent());\n\n\t\t\t\t\tif (profile != null && profile.containsKey(\"id\")) {\n\t\t\t\t\t\tString fbId = (String) profile.get(\"id\");\n\t\t\t\t\t\tString email = (String) profile.get(\"email\");\n\t\t\t\t\t\tString name = (String) profile.get(\"name\");\n\n\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\tuser.setEmail(email);\n\t\t\t\t\t\tuser = User.readUserForIdentifier(user);\n\t\t\t\t\t\tif (user == null) {\n\t\t\t\t\t\t\t//user is new\n\t\t\t\t\t\t\tuser = new User();\n\t\t\t\t\t\t\tuser.setActive(true);\n\t\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\t\tuser.setEmail(StringUtils.isBlank(email) ? Utils.getNewId() + \"@facebook.com\" : email);\n\t\t\t\t\t\t\tuser.setName(StringUtils.isBlank(name) ? \"No Name\" : name);\n\t\t\t\t\t\t\tuser.setPassword(Utils.generateSecurityToken());\n\t\t\t\t\t\t\tuser.setPicture(getPicture(fbId));\n\t\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\t\tString id = user.create();\n\t\t\t\t\t\t\tif (id == null) {\n\t\t\t\t\t\t\t\tthrow new AuthenticationServiceException(\"Authentication failed: cannot create new user.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (updateUserInfo(user, fbId, email, name)) {\n\t\t\t\t\t\t\t\tuser.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuserAuth = new UserAuthentication(new AuthenticatedUserDetails(user));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.info(\"Authentication request failed because user profile doesn't contain the expected attributes\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(\"Authentication request failed because response was missing or contained invalid JSON.\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.warn(\"Facebook auth request failed: GET \" + PROFILE_URL + accessToken, e);\n\t\t\t}\n\t\t\treturn SecurityUtils.checkIfActive(userAuth, user, false);\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FacebookAuthFilter.java",
        "method_name": "getOrCreateUser",
        "raw_code": "@SuppressWarnings(\"unchecked\")\n\tpublic UserAuthentication getOrCreateUser(App app, String accessToken) throws IOException {\n\t\tif (accessToken == null) {\n\t\t\treturn SecurityUtils.checkIfActive(null, null, false);\n\t\t}\n\t\tHttpGet profileGet = new HttpGet(PROFILE_URL + accessToken);\n\t\treturn httpclient.execute(profileGet, (resp2) -> {\n\t\t\tUserAuthentication userAuth = null;\n\t\t\tUser user = new User();\n\t\t\ttry {\n\t\t\t\tHttpEntity respEntity = resp2.getEntity();\n\t\t\t\tif (respEntity != null) {\n\t\t\t\t\tMap<String, Object> profile = jreader.readValue(respEntity.getContent());\n\n\t\t\t\t\tif (profile != null && profile.containsKey(\"id\")) {\n\t\t\t\t\t\tString fbId = (String) profile.get(\"id\");\n\t\t\t\t\t\tString email = (String) profile.get(\"email\");\n\t\t\t\t\t\tString name = (String) profile.get(\"name\");\n\n\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\tuser.setEmail(email);\n\t\t\t\t\t\tuser = User.readUserForIdentifier(user);\n\t\t\t\t\t\tif (user == null) {\n\t\t\t\t\t\t\t//user is new\n\t\t\t\t\t\t\tuser = new User();\n\t\t\t\t\t\t\tuser.setActive(true);\n\t\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\t\tuser.setEmail(StringUtils.isBlank(email) ? Utils.getNewId() + \"@facebook.com\" : email);\n\t\t\t\t\t\t\tuser.setName(StringUtils.isBlank(name) ? \"No Name\" : name);\n\t\t\t\t\t\t\tuser.setPassword(Utils.generateSecurityToken());\n\t\t\t\t\t\t\tuser.setPicture(getPicture(fbId));\n\t\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\t\tString id = user.create();\n\t\t\t\t\t\t\tif (id == null) {\n\t\t\t\t\t\t\t\tthrow new AuthenticationServiceException(\"Authentication failed: cannot create new user.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (updateUserInfo(user, fbId, email, name)) {\n\t\t\t\t\t\t\t\tuser.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuserAuth = new UserAuthentication(new AuthenticatedUserDetails(user));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.info(\"Authentication request failed because user profile doesn't contain the expected attributes\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(\"Authentication request failed because response was missing or contained invalid JSON.\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.warn(\"Facebook auth request failed: GET \" + PROFILE_URL + \"{access_token}\", e);\n\t\t\t}\n\t\t\treturn SecurityUtils.checkIfActive(userAuth, user, false);\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jans",
    "cve_id": "CVE-2025-53003",
    "cwe_list": [
      "CWE-284"
    ],
    "commit_hash": "92eea4d4637f1cae16ad2f07b2c16378ff3fc5f1",
    "short_hash": "92eea4d4",
    "vulnerableMethods_before": [
      {
        "filename": "AuthUtil.java",
        "method_name": "findMissingElements",
        "raw_code": "public List<String> findMissingElements(List<String> list1, List<String> list2) {\n        if (list1 == null || list1.isEmpty() || list2 == null || list2.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return list1.stream().filter(e -> !list2.contains(e)).collect(Collectors.toList());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AuthUtil.java",
        "method_name": "findMissingElements",
        "raw_code": "public List<String> findMissingElements(List<String> list1, List<String> list2) {\n        if (list1 == null || list1.isEmpty()) {\n            return Collections.emptyList();\n        }\n        if(list2==null || list2.isEmpty()) {\n            return list1;\n        }\n        return list1.stream().filter(e -> !list2.contains(e)).collect(Collectors.toList());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jans",
    "cve_id": "CVE-2025-53003",
    "cwe_list": [
      "CWE-284"
    ],
    "commit_hash": "92eea4d4637f1cae16ad2f07b2c16378ff3fc5f1",
    "short_hash": "92eea4d4",
    "vulnerableMethods_before": [
      {
        "filename": "OpenIdAuthorizationService.java",
        "method_name": "validateScope",
        "raw_code": "private String validateScope(String accessToken, List<String> tokenScopes, ResourceInfo resourceInfo, String issuer)\n            throws WebApplicationException {\n        logger.info(\"Validate scope, accessToken:{}, tokenScopes:{}, resourceInfo: {}, issuer: {}\", accessToken,\n                tokenScopes, resourceInfo, issuer);\n        try {\n            // Get resource scope\n            Map<ProtectionScopeType, List<String>> resourceScopesByType = getRequestedScopes(resourceInfo);\n            List<String> resourceScopes = getAllScopeList(resourceScopesByType);\n            logger.debug(\"Validate scope, resourceScopesByType: {}, resourceScopes: {}\", resourceScopesByType,\n                    resourceScopes);\n\n            // find missing scopes\n            List<String> missingScopes = findMissingScopes(resourceScopesByType, tokenScopes);\n            logger.info(\"missingScopes:{}\", missingScopes);\n\n            // Check if resource requires auth server specific scope\n            List<String> authSpecificScope = getAuthSpecificScopeRequired(resourceInfo);\n            logger.info(\" resourceScopes:{}, authSpecificScope:{} \", resourceScopes, authSpecificScope);\n\n            // If No auth scope required OR if token contains the authSpecificScope\n            if ((authSpecificScope == null || authSpecificScope.isEmpty())) {\n                logger.info(\"Validating token scopes as no authSpecificScope required\");\n                if ((missingScopes != null && !missingScopes.isEmpty())) {\n                    logger.error(\"Insufficient scopes! Required scope:{} -  however token scopes:{}\", resourceScopes,\n                            tokenScopes);\n                    throw new WebApplicationException(\"Insufficient scopes! , Required scope: \" + resourceScopes\n                            + \", however token scopes: \" + tokenScopes,\n                            Response.status(Response.Status.UNAUTHORIZED).build());\n                }\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            // If only authSpecificScope missing then proceed with token creation else throw\n            // error\n            if (missingScopes != null && !missingScopes.isEmpty()\n                    && !isEqualCollection(missingScopes, authSpecificScope)) {\n                logger.error(\"Insufficient scopes!! Required scope:{}, , however token scopes:{} \", resourceScopes,\n                        tokenScopes);\n                throw new WebApplicationException(\"Insufficient scopes!! , Required scope: \" + resourceScopes\n                        + \", however token scopes: \" + tokenScopes,\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n            \n            //If no scope is missing\n            if (missingScopes == null || missingScopes.isEmpty()) {\n                logger.info(\" No missing scopes and hence returning original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            logger.info(\"Generating new token with authSpecificScope\");\n            // Generate token with required resourceScopes\n            resourceScopes.addAll(authSpecificScope);\n            accessToken = openIdService.requestAccessToken(authUtil.getClientId(), resourceScopes);\n            logger.debug(\"Introspecting new accessToken:{}\", accessToken);\n\n            // Introspect\n            IntrospectionResponse introspectionResponse = openIdService\n                    .getIntrospectionResponse(AUTHENTICATION_SCHEME + accessToken, accessToken, authUtil.getIssuer());\n\n            // Validate Token Scope\n            if (!validateScope(introspectionResponse.getScope(), resourceScopes)) {\n                logger.error(\"Insufficient scopes!!! for new token as well - Required scope:{}, token scopes:{}\",\n                        resourceScopes, introspectionResponse.getScope());\n                throw new WebApplicationException(\n                        \"Insufficient scopes!!! Required scope: \" + resourceScopes + \", token scopes: \"\n                                + introspectionResponse.getScope(),\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n\n            logger.info(\"Token scopes Valid Returning accessToken:{}\", accessToken);\n            return AUTHENTICATION_SCHEME + accessToken;\n        } catch (Exception ex) {\n            if (logger.isErrorEnabled()) {\n                logger.error(\"oAuth authorization error:{} \", ex.getMessage());\n            }\n            throw new WebApplicationException(\"oAuth authorization error \" + ex.getMessage(),\n                    Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenIdAuthorizationService.java",
        "method_name": "validateScope",
        "raw_code": "private String validateScope(String accessToken, List<String> tokenScopes, ResourceInfo resourceInfo, String issuer)\n            throws WebApplicationException {\n        logger.info(\"Validate scope, accessToken:{}, tokenScopes:{}, resourceInfo: {}, issuer: {}\", accessToken,\n                tokenScopes, resourceInfo, issuer);\n        try {\n            // Get resource scope\n            Map<ProtectionScopeType, List<String>> resourceScopesByType = getRequestedScopes(resourceInfo);\n            List<String> resourceScopes = getAllScopeList(resourceScopesByType);\n            logger.debug(\"Validate scope, resourceScopesByType: {}, resourceScopes: {}\", resourceScopesByType,\n                    resourceScopes);\n          \n            //If no scope required\n            if (resourceScopes == null || resourceScopes.isEmpty()) {\n                logger.info(\" If no resource scopes required return original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n            \n            // find missing scopes\n            List<String> missingScopes = findMissingScopes(resourceScopesByType, tokenScopes);\n            logger.info(\"missingScopes:{}\", missingScopes);\n\n            // Check if resource requires auth server specific scope\n            List<String> authSpecificScope = getAuthSpecificScopeRequired(resourceInfo);\n            logger.info(\" resourceScopes:{}, authSpecificScope:{} \", resourceScopes, authSpecificScope);\n\n            // If No auth scope required OR if token contains the authSpecificScope\n            if ((authSpecificScope == null || authSpecificScope.isEmpty())) {\n                logger.info(\"Validating token scopes as no authSpecificScope required\");\n                if ((missingScopes != null && !missingScopes.isEmpty())) {\n                    logger.error(\"Insufficient scopes! Required scope:{} -  however token scopes:{}\", resourceScopes,\n                            tokenScopes);\n                    throw new WebApplicationException(\"Insufficient scopes! , Required scope: \" + resourceScopes\n                            + \", however token scopes: \" + tokenScopes,\n                            Response.status(Response.Status.UNAUTHORIZED).build());\n                }\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            // If only authSpecificScope missing then proceed with token creation else throw\n            // error\n            if (missingScopes != null && !missingScopes.isEmpty()\n                    && !isEqualCollection(missingScopes, authSpecificScope)) {\n                logger.error(\"Insufficient scopes!! Required scope:{}, , however token scopes:{} \", resourceScopes,\n                        tokenScopes);\n                throw new WebApplicationException(\"Insufficient scopes!! , Required scope: \" + resourceScopes\n                        + \", however token scopes: \" + tokenScopes,\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n            \n            //If no scope is missing\n            if (missingScopes == null || missingScopes.isEmpty()) {\n                logger.info(\" No missing scopes and hence returning original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            logger.info(\"Generating new token with authSpecificScope\");\n            // Generate token with required resourceScopes\n            resourceScopes.addAll(authSpecificScope);\n            accessToken = openIdService.requestAccessToken(authUtil.getClientId(), resourceScopes);\n            logger.debug(\"Introspecting new accessToken:{}\", accessToken);\n\n            // Introspect\n            IntrospectionResponse introspectionResponse = openIdService\n                    .getIntrospectionResponse(AUTHENTICATION_SCHEME + accessToken, accessToken, authUtil.getIssuer());\n\n            // Validate Token Scope\n            if (!validateScope(introspectionResponse.getScope(), resourceScopes)) {\n                logger.error(\"Insufficient scopes!!! for new token as well - Required scope:{}, token scopes:{}\",\n                        resourceScopes, introspectionResponse.getScope());\n                throw new WebApplicationException(\n                        \"Insufficient scopes!!! Required scope: \" + resourceScopes + \", token scopes: \"\n                                + introspectionResponse.getScope(),\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n\n            logger.info(\"Token scopes Valid Returning accessToken:{}\", accessToken);\n            return AUTHENTICATION_SCHEME + accessToken;\n        } catch (Exception ex) {\n            if (logger.isErrorEnabled()) {\n                logger.error(\"oAuth authorization error:{} \", ex.getMessage());\n            }\n            throw new WebApplicationException(\"oAuth authorization error \" + ex.getMessage(),\n                    Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "pgjdbc",
    "cve_id": "CVE-2025-49146",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "9217ed16cb2918ab1b6b9258ae97e6ede244d8a0",
    "short_hash": "9217ed16",
    "vulnerableMethods_before": [
      {
        "filename": "ConnectionFactoryImpl.java",
        "method_name": "doAuthentication",
        "raw_code": "private static void doAuthentication(PGStream pgStream, String host, String user, Properties info) throws IOException, SQLException {\n    // Now get the response from the backend, either an error message\n    // or an authentication request\n\n    /* SSPI negotiation state, if used */\n    ISSPIClient sspiClient = null;\n\n    /* SCRAM authentication state, if used */\n    ScramAuthenticator scramAuthenticator = null;\n    // TODO: figure out how to deal with new protocols\n    int protocol = 3 << 16;\n\n    try {\n      authloop: while (true) {\n        int beresp = pgStream.receiveChar();\n\n        switch (beresp) {\n          case PgMessageType.NEGOTIATE_PROTOCOL_RESPONSE:  // Negotiate Protocol Version\n            // read the length and ignore it.\n            pgStream.receiveInteger4();\n            protocol = pgStream.receiveInteger4();\n            int numOptionsNotRecognized = pgStream.receiveInteger4();\n            if (numOptionsNotRecognized > 0) {\n              // do not connect and throw an error\n              String errorMessage = \"Protocol error, received invalid options: \";\n              for (int i = 0; i < numOptionsNotRecognized; i++) {\n                errorMessage  += i > 0 ? \"\" : \",\" + pgStream.receiveString();\n              }\n              LOGGER.log(Level.FINEST, errorMessage);\n              throw new PSQLException(errorMessage, PSQLState.PROTOCOL_VIOLATION);\n            }\n            int major = protocol >> 16 & 0xff;\n            int minor = protocol & 0xff;\n            pgStream.setProtocolVersion( ProtocolVersion.fromMajorMinor(major, minor));\n            break;\n          case PgMessageType.ERROR_RESPONSE:\n            // An error occurred, so pass the error message to the\n            // user.\n            //\n            // The most common one to be thrown here is:\n            // \"User authentication failed\"\n            //\n            int elen = pgStream.receiveInteger4();\n\n            ServerErrorMessage errorMsg =\n                new ServerErrorMessage(pgStream.receiveErrorString(elen - 4));\n            LOGGER.log(Level.FINEST, \" <=BE ErrorMessage({0})\", errorMsg);\n            throw new PSQLException(errorMsg, PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n\n          case PgMessageType.AUTHENTICATION_RESPONSE:\n            // Authentication request.\n            // Get the message length\n            int msgLen = pgStream.receiveInteger4();\n\n            // Get the type of request\n            int areq = pgStream.receiveInteger4();\n\n            // Process the request.\n            switch (areq) {\n              case AUTH_REQ_MD5: {\n                byte[] md5Salt = pgStream.receive(4);\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" <=BE AuthenticationReqMD5(salt={0})\", Utils.toHexString(md5Salt));\n                }\n\n                byte[] digest = AuthenticationPluginManager.withEncodedPassword(\n                    AuthenticationRequestType.MD5_PASSWORD, info,\n                    encodedPassword -> MD5Digest.encode(user.getBytes(StandardCharsets.UTF_8),\n                        encodedPassword, md5Salt)\n                );\n\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" FE=> Password(md5digest={0})\", new String(digest, StandardCharsets.US_ASCII));\n                }\n\n                try {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + digest.length + 1);\n                  pgStream.send(digest);\n                } finally {\n                  Arrays.fill(digest, (byte) 0);\n                }\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_PASSWORD: {\n                LOGGER.log(Level.FINEST, \"<=BE AuthenticationReqPassword\");\n                LOGGER.log(Level.FINEST, \" FE=> Password(password=<not shown>)\");\n\n                AuthenticationPluginManager.withEncodedPassword(AuthenticationRequestType.CLEARTEXT_PASSWORD, info, encodedPassword -> {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + encodedPassword.length + 1);\n                  pgStream.send(encodedPassword);\n                  return void.class;\n                });\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_GSS:\n              case AUTH_REQ_SSPI:\n                /*\n                 * Use GSSAPI if requested on all platforms, via JSSE.\n                 *\n                 * For SSPI auth requests, if we're on Windows attempt native SSPI authentication if\n                 * available, and if not disabled by setting a kerberosServerName. On other\n                 * platforms, attempt JSSE GSSAPI negotiation with the SSPI server.\n                 *\n                 * Note that this is slightly different to libpq, which uses SSPI for GSSAPI where\n                 * supported. We prefer to use the existing Java JSSE Kerberos support rather than\n                 * going to native (via JNA) calls where possible, so that JSSE system properties\n                 * etc continue to work normally.\n                 *\n                 * Note that while SSPI is often Kerberos-based there's no guarantee it will be; it\n                 * may be NTLM or anything else. If the client responds to an SSPI request via\n                 * GSSAPI and the other end isn't using Kerberos for SSPI then authentication will\n                 * fail.\n                 */\n                final String gsslib = PGProperty.GSS_LIB.getOrDefault(info);\n                final boolean usespnego = PGProperty.USE_SPNEGO.getBoolean(info);\n\n                boolean useSSPI = false;\n\n                /*\n                 * Use SSPI if we're in auto mode on windows and have a request for SSPI auth, or if\n                 * it's forced. Otherwise use gssapi. If the user has specified a Kerberos server\n                 * name we'll always use JSSE GSSAPI.\n                 */\n                if (\"gssapi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE, \"Using JSSE GSSAPI, param gsslib=gssapi\");\n                } else if (areq == AUTH_REQ_GSS && !\"sspi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE,\n                      \"Using JSSE GSSAPI, gssapi requested by server and gsslib=sspi not forced\");\n                } else {\n                  /* Determine if SSPI is supported by the client */\n                  sspiClient = createSSPI(pgStream, PGProperty.SSPI_SERVICE_CLASS.getOrDefault(info),\n                      /* Use negotiation for SSPI, or if explicitly requested for GSS */\n                      areq == AUTH_REQ_SSPI || (areq == AUTH_REQ_GSS && usespnego));\n\n                  useSSPI = sspiClient.isSSPISupported();\n                  LOGGER.log(Level.FINE, \"SSPI support detected: {0}\", useSSPI);\n\n                  if (!useSSPI) {\n                    /* No need to dispose() if no SSPI used */\n                    sspiClient = null;\n\n                    if (\"sspi\".equals(gsslib)) {\n                      throw new PSQLException(\n                          \"SSPI forced with gsslib=sspi, but SSPI not available; set loglevel=2 for details\",\n                          PSQLState.CONNECTION_UNABLE_TO_CONNECT);\n                    }\n                  }\n\n                  if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Using SSPI: {0}, gsslib={1} and SSPI support detected\", new Object[]{useSSPI, gsslib});\n                  }\n                }\n\n                if (useSSPI) {\n                  /* SSPI requested and detected as available */\n                  castNonNull(sspiClient).startSSPI();\n                } else {\n                  /* Use JGSS's GSSAPI for this request */\n                  AuthenticationPluginManager.withPassword(AuthenticationRequestType.GSS, info, password -> {\n                    MakeGSS.authenticate(false, pgStream, host, user, password,\n                        PGProperty.JAAS_APPLICATION_NAME.getOrDefault(info),\n                        PGProperty.KERBEROS_SERVER_NAME.getOrDefault(info), usespnego,\n                        PGProperty.JAAS_LOGIN.getBoolean(info),\n                        PGProperty.GSS_USE_DEFAULT_CREDS.getBoolean(info),\n                        PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n                    return void.class;\n                  });\n                }\n                break;\n\n              case AUTH_REQ_GSS_CONTINUE:\n                /*\n                 * Only called for SSPI, as GSS is handled by an inner loop in MakeGSS.\n                 */\n                castNonNull(sspiClient).continueSSPI(msgLen - 8);\n                break;\n\n              case AUTH_REQ_SASL:\n                scramAuthenticator = AuthenticationPluginManager.withPassword(AuthenticationRequestType.SASL, info, password -> {\n                  if (password == null) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but no password was provided.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  if (password.length == 0) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but the password is an empty string.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  return new ScramAuthenticator(password, pgStream, info);\n                });\n                scramAuthenticator.handleAuthenticationSASL();\n                break;\n\n              case AUTH_REQ_SASL_CONTINUE:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLContinue(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_SASL_FINAL:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLFinal(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_OK:\n                /* Cleanup after successful authentication */\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationOk\");\n                break authloop; // We're done.\n\n              default:\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationReq (unsupported type {0})\", areq);\n                throw new PSQLException(GT.tr(\n                    \"The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.\",\n                    areq), PSQLState.CONNECTION_REJECTED);\n            }\n\n            break;\n\n          default:\n            throw new PSQLException(GT.tr(\"Protocol error.  Session setup failed.\"),\n                PSQLState.PROTOCOL_VIOLATION);\n        }\n      }\n    } finally {\n      /* Cleanup after successful or failed authentication attempts */\n      if (sspiClient != null) {\n        try {\n          sspiClient.dispose();\n        } catch (RuntimeException ex) {\n          LOGGER.log(Level.FINE, \"Unexpected error during SSPI context disposal\", ex);\n        }\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConnectionFactoryImpl.java",
        "method_name": "doAuthentication",
        "raw_code": "private static void doAuthentication(PGStream pgStream, String host, String user, Properties info) throws IOException, SQLException {\n    // Now get the response from the backend, either an error message\n    // or an authentication request\n\n    /* SSPI negotiation state, if used */\n    ISSPIClient sspiClient = null;\n\n    /* SCRAM authentication state, if used */\n    ScramAuthenticator scramAuthenticator = null;\n    // TODO: figure out how to deal with new protocols\n    int protocol = 3 << 16;\n\n    boolean saslHandshakeCompleted = false;\n\n    try {\n      authloop: while (true) {\n        int beresp = pgStream.receiveChar();\n\n        switch (beresp) {\n          case PgMessageType.NEGOTIATE_PROTOCOL_RESPONSE:  // Negotiate Protocol Version\n            // read the length and ignore it.\n            pgStream.receiveInteger4();\n            protocol = pgStream.receiveInteger4();\n            int numOptionsNotRecognized = pgStream.receiveInteger4();\n            if (numOptionsNotRecognized > 0) {\n              // do not connect and throw an error\n              String errorMessage = \"Protocol error, received invalid options: \";\n              for (int i = 0; i < numOptionsNotRecognized; i++) {\n                errorMessage  += i > 0 ? \"\" : \",\" + pgStream.receiveString();\n              }\n              LOGGER.log(Level.FINEST, errorMessage);\n              throw new PSQLException(errorMessage, PSQLState.PROTOCOL_VIOLATION);\n            }\n            int major = protocol >> 16 & 0xff;\n            int minor = protocol & 0xff;\n            pgStream.setProtocolVersion( ProtocolVersion.fromMajorMinor(major, minor));\n            break;\n          case PgMessageType.ERROR_RESPONSE:\n            // An error occurred, so pass the error message to the\n            // user.\n            //\n            // The most common one to be thrown here is:\n            // \"User authentication failed\"\n            //\n            int elen = pgStream.receiveInteger4();\n\n            ServerErrorMessage errorMsg =\n                new ServerErrorMessage(pgStream.receiveErrorString(elen - 4));\n            LOGGER.log(Level.FINEST, \" <=BE ErrorMessage({0})\", errorMsg);\n            throw new PSQLException(errorMsg, PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n\n          case PgMessageType.AUTHENTICATION_RESPONSE:\n            // Authentication request.\n            // Get the message length\n            int msgLen = pgStream.receiveInteger4();\n\n            // Get the type of request\n            int areq = pgStream.receiveInteger4();\n\n            if (ChannelBindingOption.of(info) == ChannelBindingOption.REQUIRE) {\n              if (areq == AUTH_REQ_OK) {\n                if (!saslHandshakeCompleted) {\n                  throw new PSQLException(\n                      GT.tr(\"Channel binding is required, but server skipped authentication. \"\n                          + \"Channel binding is only supported with SCRAM authentication over encrypted connections.\"),\n                      PSQLState.CONNECTION_REJECTED);\n                }\n              } else if (areq != AUTH_REQ_SASL && areq != AUTH_REQ_SASL_CONTINUE && areq != AUTH_REQ_SASL_FINAL) {\n                throw new PSQLException(\n                      GT.tr(\"Channel binding is required, but server requested ''{0}'' authentication. \"\n                          + \"Channel binding is only supported with SCRAM authentication over encrypted connections.\",\n                          getAuthenticationMethodName(areq)),\n                      PSQLState.CONNECTION_REJECTED);\n              }\n            }\n\n            // Process the request.\n            switch (areq) {\n              case AUTH_REQ_MD5: {\n                byte[] md5Salt = pgStream.receive(4);\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" <=BE AuthenticationReqMD5(salt={0})\", Utils.toHexString(md5Salt));\n                }\n\n                byte[] digest = AuthenticationPluginManager.withEncodedPassword(\n                    AuthenticationRequestType.MD5_PASSWORD, info,\n                    encodedPassword -> MD5Digest.encode(user.getBytes(StandardCharsets.UTF_8),\n                        encodedPassword, md5Salt)\n                );\n\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" FE=> Password(md5digest={0})\", new String(digest, StandardCharsets.US_ASCII));\n                }\n\n                try {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + digest.length + 1);\n                  pgStream.send(digest);\n                } finally {\n                  Arrays.fill(digest, (byte) 0);\n                }\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_PASSWORD: {\n                LOGGER.log(Level.FINEST, \"<=BE AuthenticationReqPassword\");\n                LOGGER.log(Level.FINEST, \" FE=> Password(password=<not shown>)\");\n\n                AuthenticationPluginManager.withEncodedPassword(AuthenticationRequestType.CLEARTEXT_PASSWORD, info, encodedPassword -> {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + encodedPassword.length + 1);\n                  pgStream.send(encodedPassword);\n                  return void.class;\n                });\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_GSS:\n              case AUTH_REQ_SSPI:\n                /*\n                 * Use GSSAPI if requested on all platforms, via JSSE.\n                 *\n                 * For SSPI auth requests, if we're on Windows attempt native SSPI authentication if\n                 * available, and if not disabled by setting a kerberosServerName. On other\n                 * platforms, attempt JSSE GSSAPI negotiation with the SSPI server.\n                 *\n                 * Note that this is slightly different to libpq, which uses SSPI for GSSAPI where\n                 * supported. We prefer to use the existing Java JSSE Kerberos support rather than\n                 * going to native (via JNA) calls where possible, so that JSSE system properties\n                 * etc continue to work normally.\n                 *\n                 * Note that while SSPI is often Kerberos-based there's no guarantee it will be; it\n                 * may be NTLM or anything else. If the client responds to an SSPI request via\n                 * GSSAPI and the other end isn't using Kerberos for SSPI then authentication will\n                 * fail.\n                 */\n                final String gsslib = PGProperty.GSS_LIB.getOrDefault(info);\n                final boolean usespnego = PGProperty.USE_SPNEGO.getBoolean(info);\n\n                boolean useSSPI = false;\n\n                /*\n                 * Use SSPI if we're in auto mode on windows and have a request for SSPI auth, or if\n                 * it's forced. Otherwise use gssapi. If the user has specified a Kerberos server\n                 * name we'll always use JSSE GSSAPI.\n                 */\n                if (\"gssapi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE, \"Using JSSE GSSAPI, param gsslib=gssapi\");\n                } else if (areq == AUTH_REQ_GSS && !\"sspi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE,\n                      \"Using JSSE GSSAPI, gssapi requested by server and gsslib=sspi not forced\");\n                } else {\n                  /* Determine if SSPI is supported by the client */\n                  sspiClient = createSSPI(pgStream, PGProperty.SSPI_SERVICE_CLASS.getOrDefault(info),\n                      /* Use negotiation for SSPI, or if explicitly requested for GSS */\n                      areq == AUTH_REQ_SSPI || (areq == AUTH_REQ_GSS && usespnego));\n\n                  useSSPI = sspiClient.isSSPISupported();\n                  LOGGER.log(Level.FINE, \"SSPI support detected: {0}\", useSSPI);\n\n                  if (!useSSPI) {\n                    /* No need to dispose() if no SSPI used */\n                    sspiClient = null;\n\n                    if (\"sspi\".equals(gsslib)) {\n                      throw new PSQLException(\n                          \"SSPI forced with gsslib=sspi, but SSPI not available; set loglevel=2 for details\",\n                          PSQLState.CONNECTION_UNABLE_TO_CONNECT);\n                    }\n                  }\n\n                  if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Using SSPI: {0}, gsslib={1} and SSPI support detected\", new Object[]{useSSPI, gsslib});\n                  }\n                }\n\n                if (useSSPI) {\n                  /* SSPI requested and detected as available */\n                  castNonNull(sspiClient).startSSPI();\n                } else {\n                  /* Use JGSS's GSSAPI for this request */\n                  AuthenticationPluginManager.withPassword(AuthenticationRequestType.GSS, info, password -> {\n                    MakeGSS.authenticate(false, pgStream, host, user, password,\n                        PGProperty.JAAS_APPLICATION_NAME.getOrDefault(info),\n                        PGProperty.KERBEROS_SERVER_NAME.getOrDefault(info), usespnego,\n                        PGProperty.JAAS_LOGIN.getBoolean(info),\n                        PGProperty.GSS_USE_DEFAULT_CREDS.getBoolean(info),\n                        PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n                    return void.class;\n                  });\n                }\n                break;\n\n              case AUTH_REQ_GSS_CONTINUE:\n                /*\n                 * Only called for SSPI, as GSS is handled by an inner loop in MakeGSS.\n                 */\n                castNonNull(sspiClient).continueSSPI(msgLen - 8);\n                break;\n\n              case AUTH_REQ_SASL:\n                scramAuthenticator = AuthenticationPluginManager.withPassword(AuthenticationRequestType.SASL, info, password -> {\n                  if (password == null) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but no password was provided.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  if (password.length == 0) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but the password is an empty string.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  return new ScramAuthenticator(password, pgStream, info);\n                });\n                scramAuthenticator.handleAuthenticationSASL();\n                break;\n\n              case AUTH_REQ_SASL_CONTINUE:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLContinue(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_SASL_FINAL:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLFinal(msgLen - 4 - 4);\n                saslHandshakeCompleted = true;\n                break;\n\n              case AUTH_REQ_OK:\n                /* Cleanup after successful authentication */\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationOk\");\n                break authloop; // We're done.\n\n              default:\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationReq (unsupported type {0})\", areq);\n                throw new PSQLException(GT.tr(\n                    \"The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.\",\n                    areq), PSQLState.CONNECTION_REJECTED);\n            }\n\n            break;\n\n          default:\n            throw new PSQLException(GT.tr(\"Protocol error.  Session setup failed.\"),\n                PSQLState.PROTOCOL_VIOLATION);\n        }\n      }\n    } finally {\n      /* Cleanup after successful or failed authentication attempts */\n      if (sspiClient != null) {\n        try {\n          sspiClient.dispose();\n        } catch (RuntimeException ex) {\n          LOGGER.log(Level.FINE, \"Unexpected error during SSPI context disposal\", ex);\n        }\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "oidc",
    "cve_id": "CVE-2025-49594",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "d90d717172283aaa96bb5bb44e357f910ae64adb",
    "short_hash": "d90d7171",
    "vulnerableMethods_before": [
      {
        "filename": "OIDCTest.java",
        "method_name": "init",
        "raw_code": "@BeforeClass\n    public static void init() throws Exception\n    {\n        // This will not be null if we are in the middle of allTests\n        if (context == null) {\n            PersistentTestContext persistentTestContext =\n                new PersistentTestContext(Arrays.asList(new XWikiExecutor(0)/*, new XWikiExecutor(1)*/));\n            initializeSystem(persistentTestContext);\n\n            // Start XWiki\n            persistentTestContext.start();\n\n            // Cache the initial CSRF token since that token needs to be passed to all forms (this is done automatically\n            // in TestUtils), including the login form. Whenever a new user logs in we need to recache.\n            // Note that this requires a running XWiki instance.\n            getUtil().recacheSecretToken();\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OIDCTest.java",
        "method_name": "init",
        "raw_code": "@BeforeClass\n    public static void init() throws Exception\n    {\n        // This will not be null if we are in the middle of allTests\n        if (context == null) {\n            PersistentTestContext persistentTestContext =\n                new PersistentTestContext(Arrays.asList(new XWikiExecutor(0)/* , new XWikiExecutor(1) */));\n            initializeSystem(persistentTestContext);\n\n            // Start XWiki\n            persistentTestContext.start();\n\n            // Cache the initial CSRF token since that token needs to be passed to all forms (this is done automatically\n            // in TestUtils), including the login form. Whenever a new user logs in we need to recache.\n            // Note that this requires a running XWiki instance.\n            getUtil().recacheSecretToken();\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "oidc",
    "cve_id": "CVE-2025-49594",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "d90d717172283aaa96bb5bb44e357f910ae64adb",
    "short_hash": "d90d7171",
    "vulnerableMethods_before": [
      {
        "filename": "OIDCTest.java",
        "method_name": "logout",
        "raw_code": "private void logout(int index)\n    {\n        getUtil().switchExecutor(index);\n        getUtil().gotoPage(getURL(index, \"/bin/logout/XWiki/XWikiLogout?xredirect=%2Fxwiki%2Fbin%2Fview%2FMain%2F\"));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OIDCTest.java",
        "method_name": "logout",
        "raw_code": "private void logout(int index)\n    {\n        getUtil().switchExecutor(index);\n        getUtil().gotoPage(getURL(index, \"/bin/logout/XWiki/XWikiLogout?xredirect=%2Fxwiki%2Fbin%2Fview%2FMain%2F\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "oidc",
    "cve_id": "CVE-2025-49594",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "d90d717172283aaa96bb5bb44e357f910ae64adb",
    "short_hash": "d90d7171",
    "vulnerableMethods_before": [
      {
        "filename": "OIDCTest.java",
        "method_name": "authenticate",
        "raw_code": "@Test\n    public void authenticate() throws Exception\n    {\n        cleanupClient();\n        cleanupProvider();\n\n        // Create a user on the provider\n        gotoHome(1);\n        getUtil().recacheSecretToken();\n        getUtil().createUser(\"provideruser\", \"providerpassword\", null);\n\n        // Login on the client\n        gotToClientLogin();\n\n        // We are asked for the provider to use, set it\n        OIDCClientProviderPage providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        LoginPage loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // A consent is asked, accept\n        OIDCProviderConsentPage consentPage = new OIDCProviderConsentPage();\n        consentPage.clickAccept();\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Log out of the client\n        logout(0);\n\n        // We are logged out of the provider and come back on the client\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure we are logged out of the client\n        assertNull(getCurrentUserReference());\n\n        // Make sure we are logged out of the provider too\n        gotoHome(1);\n        assertNull(getCurrentUserReference());\n\n        // Login again\n        gotToClientLogin();\n\n        // We are asked for the provider to use, set it\n        providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // No consent is needed this time\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Make sure the user is logged in the provider\n        gotoHome(1);\n        assertEquals(\"xwiki:XWiki.provideruser\", getCurrentUserReference());\n\n        // Create a token on the provider\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        OIDCApplicationsUserProfilePage applications = new OIDCApplicationsUserProfilePage(\"provideruser\");\n\n        applications.setApplicationName(\"My Application\");\n        applications = applications.clickCreate();\n\n        String token = applications.getToken();\n\n        URL url = new URL(getURL(1, \"/rest/\"));\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + token);\n        connection.connect();\n\n        assertEquals(\"xwiki:XWiki.provideruser\", connection.getHeaderField(\"XWiki-User\"));\n\n        // TODO: Add support on provider side to automatically catch standard logout and send a backchannel logout to\n        // all registered clients\n        // Log out of the provider\n        // logout(1);\n        //\n        // Make sure we are logged out of the provider\n        // assertNull(getCurrentUserReference());\n        //\n        // Make sure we are also logged out of the client\n        // gotoHome(0);\n        // assertNull(getCurrentUserReference());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OIDCTest.java",
        "method_name": "authenticate",
        "raw_code": "@Test\n    public void authenticate() throws Exception\n    {\n        cleanupClient();\n        cleanupProvider();\n\n        // Create a user on the provider\n        gotoHome(1);\n        getUtil().recacheSecretToken();\n        getUtil().createUser(\"provideruser\", \"providerpassword\", null);\n\n        // Go to token management of provideruser\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        // Make sure guest user is not allowed to access the user token management\n        assertFalse(OIDCApplicationsUserProfilePage.isAllowed());\n\n        // Login on the client\n        gotToLogin(0);\n\n        // We are asked for the provider to use, set it\n        OIDCClientProviderPage providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        LoginPage loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // A consent is asked, accept\n        OIDCProviderConsentPage consentPage = new OIDCProviderConsentPage();\n        consentPage.clickAccept();\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Log out of the client\n        logout(0);\n\n        // We are logged out of the provider and come back on the client\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure we are logged out of the client\n        assertNull(getCurrentUserReference());\n\n        // Make sure we are logged out of the provider too\n        gotoHome(1);\n        assertNull(getCurrentUserReference());\n\n        // Login again\n        gotToLogin(0);\n\n        // We are asked for the provider to use, set it\n        providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // No consent is needed this time\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Make sure the user is logged in the provider\n        gotoHome(1);\n        assertEquals(\"xwiki:XWiki.provideruser\", getCurrentUserReference());\n\n        // Create a token on the provider\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        OIDCApplicationsUserProfilePage applications = new OIDCApplicationsUserProfilePage(\"provideruser\");\n\n        applications.setApplicationName(\"My Application\");\n        applications = applications.clickCreate();\n\n        String token = applications.getToken();\n\n        URL url = new URL(getURL(1, \"/rest/\"));\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + token);\n        connection.connect();\n\n        assertEquals(\"xwiki:XWiki.provideruser\", connection.getHeaderField(\"XWiki-User\"));\n\n        // TODO: Add support on provider side to automatically catch standard logout and send a backchannel logout to\n        // all registered clients\n        // Log out of the provider\n        // logout(1);\n        //\n        // Make sure we are logged out of the provider\n        // assertNull(getCurrentUserReference());\n        //\n        // Make sure we are also logged out of the client\n        // gotoHome(0);\n        // assertNull(getCurrentUserReference());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "ModificationsResourceImpl.java",
        "method_name": "getModifications",
        "raw_code": "@Override\n    public History getModifications(String wikiName, Integer start, Integer number, String order, Long ts,\n            Boolean withPrettyNames) throws XWikiRestException\n    {\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            History history = new History();\n\n            String query = String.format(\"select doc.space, doc.name, doc.language, rcs.id, rcs.date, rcs.author,\"\n                + \" rcs.comment from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" rcs.date > :date order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\",\n                validOrder, validOrder, validOrder);\n\n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"date\", new Date(ts))\n                .setLimit(number).setOffset(start).setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[0];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[1];\n\n                DocumentReference documentReference =\n                    this.resolver.resolve(Utils.getPageId(wikiName, spaces, pageName));\n                if (this.authorizationManager.hasAccess(VIEW, documentReference)) {\n                    String language = (String) fields[2];\n                    if (language.equals(\"\")) {\n                        language = null;\n                    }\n                    XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[3];\n                    Timestamp timestamp = (Timestamp) fields[4];\n                    Date modified = new Date(timestamp.getTime());\n                    String modifier = (String) fields[5];\n                    String comment = (String) fields[6];\n\n                    HistorySummary historySummary =\n                        DomainObjectFactory.createHistorySummary(this.objectFactory, this.uriInfo.getBaseUri(),\n                            wikiName, spaces, pageName, language, nodeId.getVersion(), modifier, modified, comment,\n                            Utils.getXWikiApi(this.componentManager), withPrettyNames);\n                    history.getHistorySummaries().add(historySummary);\n                }\n            }\n\n            return history;\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PageHistoryResourceImpl.java",
        "method_name": "getPageHistory",
        "raw_code": "@Override\n    public History getPageHistory(String wikiName, String spaceName, String pageName, Integer start, Integer number,\n            String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        DocumentReference documentReference = new DocumentReference(wikiName, spaces, pageName);\n        try {\n            this.contextualAuthorizationManager.checkAccess(Right.VIEW, documentReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        History history = new History();\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            // Note that the query is made to work with Oracle which treats empty strings as null.\n            String query = String.format(\"select doc.space, doc.name, rcs.id, rcs.date, rcs.author, rcs.comment\"\n                + \" from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" doc.space = :space and doc.name = :name and (doc.language = '' or doc.language is null)\"\n                + \" order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\", validOrder, validOrder, validOrder);\n\n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"space\", spaceId)\n                .bindValue(\"name\", pageName).setLimit(number).setOffset(start).setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[2];\n                Timestamp timestamp = (Timestamp) fields[3];\n                Date modified = new Date(timestamp.getTime());\n                String modifier = (String) fields[4];\n                String comment = (String) fields[5];\n\n                HistorySummary historySummary = DomainObjectFactory.createHistorySummary(objectFactory,\n                        uriInfo.getBaseUri(), wikiName, spaces, pageName, null, nodeId.getVersion(), modifier,\n                        modified, comment, Utils.getXWikiApi(componentManager), withPrettyNames);\n\n                history.getHistorySummaries().add(historySummary);\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n\n        return history;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PageTranslationHistoryResourceImpl.java",
        "method_name": "getPageTranslationHistory",
        "raw_code": "@Override\n    public History getPageTranslationHistory(String wikiName, String spaceName, String pageName, String language,\n            Integer start, Integer number, String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        DocumentReference documentReference = new DocumentReference(wikiName, spaces, pageName);\n        try {\n            this.contextualAuthorizationManager.checkAccess(Right.VIEW, documentReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        History history = new History();\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            String query = String.format(\"select doc.space, doc.name, rcs.id, rcs.date, rcs.author, rcs.comment\"\n                + \" from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" doc.space = :space and doc.name = :name and doc.language = :language\"\n                + \" order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\", validOrder, validOrder, validOrder);\n            \n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"space\", spaceId)\n                .bindValue(\"name\", pageName).setLimit(number).bindValue(\"language\", language).setOffset(start)\n                .setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[2];\n                Timestamp timestamp = (Timestamp) fields[3];\n                Date modified = new Date(timestamp.getTime());\n                String modifier = (String) fields[4];\n                String comment = (String) fields[5];\n\n                HistorySummary historySummary = DomainObjectFactory.createHistorySummary(objectFactory,\n                        uriInfo.getBaseUri(), wikiName, spaces, pageName, language, nodeId.getVersion(), modifier,\n                        modified, comment, Utils.getXWikiApi(componentManager), withPrettyNames);\n\n                history.getHistorySummaries().add(historySummary);\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n\n        return history;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchPages",
        "raw_code": "protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, String orderField, String order,\n        Boolean withPrettyNames, Boolean isLocaleAware) throws QueryException, IllegalArgumentException,\n            UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (searchScopes.contains(SearchScope.NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (isLocaleAware) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                    + \" from XWikiDocument as doc2\"\n                                    + \" where doc2.fullName = doc.fullName\"\n                                    + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                    + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.queryManager.createQuery(queryString, Query.HQL)\n                    .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                    .addFilter(Utils.getHiddenQueryFilter(this.componentManager)).setOffset(start)\n                    // Worst case scenario when making the locale aware query:\n                    // e.g.: Search matches a document translated in fr_CA and fr\n                    .setLimit(number * 2);\n\n            if (space != null) {\n                query.bindValue(\"space\", space);\n            }\n\n            if (searchScopes.contains(SearchScope.NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (isLocaleAware && searchScopes.contains(SearchScope.TITLE)) {\n                Locale userLocale = localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), wikiName, withPrettyNames, number, isLocaleAware);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchPages",
        "raw_code": "protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, String orderField, String order,\n        Boolean withPrettyNames, Boolean isLocaleAware) throws QueryException, IllegalArgumentException,\n            UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (searchScopes.contains(SearchScope.NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (isLocaleAware) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                    + \" from XWikiDocument as doc2\"\n                                    + \" where doc2.fullName = doc.fullName\"\n                                    + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                    + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause = String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(order, \"asc\"));\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.secureQueryManager.createQuery(queryString, Query.HQL)\n                    .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                    .addFilter(Utils.getHiddenQueryFilter(this.componentManager)).setOffset(start)\n                    // Worst case scenario when making the locale aware query:\n                    // e.g.: Search matches a document translated in fr_CA and fr\n                    .setLimit(number * 2);\n\n            if (space != null) {\n                query.bindValue(\"space\", space);\n            }\n\n            if (searchScopes.contains(SearchScope.NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (isLocaleAware && searchScopes.contains(SearchScope.TITLE)) {\n                Locale userLocale = localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), wikiName, withPrettyNames, number, isLocaleAware);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchSpaces",
        "raw_code": "protected List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<SearchResult>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = queryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(uriInfo.getBaseUri(), SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchSpaces",
        "raw_code": "protected List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<SearchResult>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.secureQueryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(uriInfo.getBaseUri(), SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchObjects",
        "raw_code": "protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String orderField, String order, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext xwikiContext = Utils.getXWikiContext(componentManager);\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\n                    \" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaces, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && xwikiContext.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthorReference(), componentManager));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName, restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(uriInfo.getBaseUri(), ObjectResource.class, wikiName,\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchObjects",
        "raw_code": "protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String orderField, String order, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext xwikiContext = Utils.getXWikiContext(componentManager);\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\n                    \" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaces, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && xwikiContext.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthorReference(), componentManager));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName, restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(uriInfo.getBaseUri(), ObjectResource.class, wikiName,\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [
      {
        "filename": "HqlQueryUtilsTest.java",
        "method_name": "toCompleteStatement",
        "raw_code": "@Test\n    public void toCompleteStatement()\n    {\n        assertEquals(\"from table\", HqlQueryUtils.toCompleteStatement(\"from table\"));\n        assertEquals(\"select * from table\", HqlQueryUtils.toCompleteStatement(\"select * from table\"));\n\n        assertEquals(\"select doc.fullName from XWikiDocument doc where doc.name = 'name'\",\n            HqlQueryUtils.toCompleteStatement(\"where doc.name = 'name'\"));\n        assertEquals(\"select doc.fullName from XWikiDocument doc order by doc.name\",\n            HqlQueryUtils.toCompleteStatement(\"order by doc.name\"));\n        assertEquals(\"select doc.fullName from XWikiDocument doc , XWikiSpace space\",\n            HqlQueryUtils.toCompleteStatement(\", XWikiSpace space\"));\n\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HqlQueryUtilsTest.java",
        "method_name": "toCompleteStatement",
        "raw_code": "@Test\n    public void toCompleteStatement()\n    {\n        assertEquals(\"from table\", HqlQueryUtils.toCompleteStatement(\"from table\"));\n        assertEquals(\"select * from table\", HqlQueryUtils.toCompleteStatement(\"select * from table\"));\n\n        assertEquals(\"select doc.fullName from XWikiDocument doc where doc.name = 'name'\",\n            HqlQueryUtils.toCompleteStatement(\"where doc.name = 'name'\"));\n        assertEquals(\"select doc.fullName from XWikiDocument doc order by doc.name\",\n            HqlQueryUtils.toCompleteStatement(\"order by doc.name\"));\n        assertEquals(\"select doc.fullName from XWikiDocument doc , XWikiSpace space\",\n            HqlQueryUtils.toCompleteStatement(\", XWikiSpace space\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
    "short_hash": "a45eca2a",
    "vulnerableMethods_before": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchPages",
        "raw_code": "private List<SearchResult> searchPages(KeywordSearchOptions options, String keywords, URI baseURI)\n        throws QueryException, IllegalArgumentException,\n        UriBuilderException, XWikiException\n    {\n        String database = this.contextProvider.get().getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try (Formatter f = new Formatter()) {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (options.searchScopes().contains(NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < options.searchScopes().size(); i++) {\n                KeywordSearchScope scope = options.searchScopes().get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (Boolean.TRUE.equals(options.isLocaleAware())) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                + \" from XWikiDocument as doc2\"\n                                + \" where doc2.fullName = doc.fullName\"\n                                + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                    default:\n                        // Ignore other scopes.\n                }\n\n                if (i != options.searchScopes().size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause =\n                    String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(options.order(), \"asc\"));\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.secureQueryManager.createQuery(queryString, Query.HQL)\n                .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                .addFilter(this.hiddenDocumentFilterProvider.get()).setOffset(options.start())\n                // Worst case scenario when making the locale aware query:\n                // e.g.: Search matches a document translated in fr_CA and fr\n                .setLimit(options.number() * 2);\n\n            if (options.space() != null) {\n                query.bindValue(\"space\", options.space());\n            }\n\n            if (options.searchScopes().contains(NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (options.isLocaleAware() && options.searchScopes().contains(TITLE)) {\n                Locale userLocale = this.localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), options.wikiName(), options.withPrettyNames(),\n                options.number(), options.isLocaleAware(), baseURI);\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchPages",
        "raw_code": "private List<SearchResult> searchPages(KeywordSearchOptions options, String keywords, URI baseURI)\n        throws QueryException, IllegalArgumentException,\n        UriBuilderException, XWikiException\n    {\n        String database = this.contextProvider.get().getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try (Formatter f = new Formatter()) {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            QueryManager finalQueryManager = this.queryManager;\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (options.searchScopes().contains(NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < options.searchScopes().size(); i++) {\n                KeywordSearchScope scope = options.searchScopes().get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (Boolean.TRUE.equals(options.isLocaleAware())) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                + \" from XWikiDocument as doc2\"\n                                + \" where doc2.fullName = doc.fullName\"\n                                + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                    default:\n                        // Ignore other scopes.\n                }\n\n                if (i != options.searchScopes().size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause =\n                    String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(options.order(), \"asc\"));\n\n                if (!StringUtils.isAlphanumeric(orderField)) {\n                    finalQueryManager = this.secureQueryManager;\n                }\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = finalQueryManager.createQuery(queryString, Query.HQL)\n                .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                .addFilter(this.hiddenDocumentFilterProvider.get()).setOffset(options.start())\n                // Worst case scenario when making the locale aware query:\n                // e.g.: Search matches a document translated in fr_CA and fr\n                .setLimit(options.number() * 2);\n\n            if (options.space() != null) {\n                query.bindValue(\"space\", options.space());\n            }\n\n            if (options.searchScopes().contains(NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (options.isLocaleAware() && options.searchScopes().contains(TITLE)) {\n                Locale userLocale = this.localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), options.wikiName(), options.withPrettyNames(),\n                options.number(), options.isLocaleAware(), baseURI);\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
    "short_hash": "a45eca2a",
    "vulnerableMethods_before": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchSpaces",
        "raw_code": "private List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.secureQueryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWikiContext context = this.contextProvider.get();\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(baseURI, SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(baseURI, PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchSpaces",
        "raw_code": "private List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.queryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWikiContext context = this.contextProvider.get();\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(baseURI, SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(baseURI, PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
    "short_hash": "a45eca2a",
    "vulnerableMethods_before": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchObjects",
        "raw_code": "private List<SearchResult> searchObjects(String keywords, KeywordSearchOptions options,\n        boolean hasProgrammingRights, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext context = this.contextProvider.get();\n\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n\n        String database = context.getWikiId();\n\n        try (Formatter f = new Formatter()) {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.isEmpty() || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, \"\n                    + \"LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName \"\n                    + \"and sp.id.id = obj.id and lsp.id.id = obj.id \"\n                    + \"and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, \"\n                    + \"LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id \"\n                    + \"and lsp.id.id = obj.id and (upper(sp.value) like :keywords \"\n                    + \"or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(options.order()) || \"desc\".equals(options.order())) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, options.order());\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' \"\n                        + \"and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an\n            exception */\n            if (options.space() != null) {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", options.space()).setLimit(options.number()).execute();\n            } else {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .setLimit(options.number())\n                        .execute();\n            }\n\n            /* Build the result. */\n            ObjectFactory objectFactory = new ObjectFactory();\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(options.wikiName(), spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(options.wikiName(), spaces, pageName);\n                String pageFullName = Utils.getPageFullName(options.wikiName(), spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && context.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(options.wikiName());\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (options.withPrettyNames()) {\n                        searchResult.setAuthorName(\n                            context.getWiki().getPlainUserName(doc.getAuthorReference(), context));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(baseURI, PageResource.class, options.wikiName(), restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(baseURI, ObjectResource.class, options.wikiName(),\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchObjects",
        "raw_code": "private List<SearchResult> searchObjects(KeywordSearchOptions options, URI baseURI, List<Object> queryResult,\n        XWikiContext context) throws UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n\n        /* Build the result. */\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            Object[] fields = (Object[]) object;\n\n            String spaceId = (String) fields[1];\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            String pageName = (String) fields[2];\n            String className = (String) fields[3];\n            int objectNumber = (Integer) fields[4];\n\n            String id = Utils.getObjectId(options.wikiName(), spaces, pageName, className, objectNumber);\n\n            String pageId = Utils.getPageId(options.wikiName(), spaces, pageName);\n            String pageFullName = Utils.getPageFullName(options.wikiName(), spaces, pageName);\n\n            /*\n             * Check if the user has the right to see the found document. We also prevent guest users to access object\n             * data in order to avoid leaking important information such as emails to crawlers.\n             */\n            if (xwikiApi.hasAccessLevel(\"view\", pageId) && context.getUserReference() != null) {\n                Document doc = xwikiApi.getDocument(pageFullName);\n                String title = doc.getDisplayTitle();\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"object\");\n                searchResult.setId(id);\n                searchResult.setPageFullName(pageFullName);\n                searchResult.setTitle(title);\n                searchResult.setWiki(options.wikiName());\n                searchResult.setSpace(spaceId);\n                searchResult.setPageName(pageName);\n                searchResult.setVersion(doc.getVersion());\n                searchResult.setClassName(className);\n                searchResult.setObjectNumber(objectNumber);\n                searchResult.setAuthor(doc.getAuthor());\n                Calendar calendar = Calendar.getInstance();\n                calendar.setTime(doc.getDate());\n                searchResult.setModified(calendar);\n\n                if (options.withPrettyNames()) {\n                    searchResult.setAuthorName(context.getWiki().getPlainUserName(doc.getAuthorReference(), context));\n                }\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                String pageUri = Utils\n                    .createURI(baseURI, PageResource.class, options.wikiName(), restSpacesValue, pageName).toString();\n                Link pageLink = new Link();\n                pageLink.setHref(pageUri);\n                pageLink.setRel(Relations.PAGE);\n                searchResult.getLinks().add(pageLink);\n\n                String objectUri = Utils.createURI(baseURI, ObjectResource.class, options.wikiName(), restSpacesValue,\n                    pageName, className, objectNumber).toString();\n                Link objectLink = new Link();\n                objectLink.setHref(objectUri);\n                objectLink.setRel(Relations.OBJECT);\n                searchResult.getLinks().add(objectLink);\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-48058",
    "cwe_list": [
      "CWE-1333"
    ],
    "commit_hash": "72f79dec6d4292f892fbddd68a19c67935c7d81f",
    "short_hash": "72f79dec",
    "vulnerableMethods_before": [
      {
        "filename": "ConversionUtil.java",
        "method_name": "getElementCount",
        "raw_code": "public static long getElementCount(String xmlFile, String className) {\n        String regex = \"(<cim:\" + className + \" (rdf:ID=\\\"_|rdf:about=\\\"#_).*?\\\")>\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(xmlFile);\n        return matcher.results().count();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversionUtil.java",
        "method_name": "getElementCount",
        "raw_code": "public static long getElementCount(String xmlFile, String className) {\n        String regex = \"(<cim:\" + className + \" (rdf:ID=\\\"_|rdf:about=\\\"#_).*?\\\")>\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(xmlFile);\n        return matcherCount(matcher);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-48058",
    "cwe_list": [
      "CWE-1333"
    ],
    "commit_hash": "72f79dec6d4292f892fbddd68a19c67935c7d81f",
    "short_hash": "72f79dec",
    "vulnerableMethods_before": [
      {
        "filename": "CgmesExportTest.java",
        "method_name": "testModelEquipmentOperationProfile",
        "raw_code": "@Test\n    void testModelEquipmentOperationProfile() throws IOException {\n        String importDir = \"/issues/switches/\";\n        Network network = readCgmesResources(importDir, \"disconnected_terminal_EQ.xml\");\n\n        String exportDir = \"/testModelProfile\";\n        try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n            Path tmpDir = Files.createDirectory(fs.getPath(exportDir));\n            String eqFile = writeCgmesProfile(network, \"EQ\", tmpDir);\n\n            String regex = \"<md:Model.profile>http://entsoe.eu/CIM/EquipmentOperation/3/1</md:Model.profile>\";\n            Pattern pattern = Pattern.compile(regex);\n            Matcher matcher = pattern.matcher(eqFile);\n            assertEquals(1, matcher.results().count());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CgmesExportTest.java",
        "method_name": "testModelEquipmentOperationProfile",
        "raw_code": "@Test\n    void testModelEquipmentOperationProfile() throws IOException {\n        String importDir = \"/issues/switches/\";\n        Network network = readCgmesResources(importDir, \"disconnected_terminal_EQ.xml\");\n\n        String exportDir = \"/testModelProfile\";\n        try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n            Path tmpDir = Files.createDirectory(fs.getPath(exportDir));\n            String eqFile = writeCgmesProfile(network, \"EQ\", tmpDir);\n\n            String regex = \"<md:Model.profile>http://entsoe.eu/CIM/EquipmentOperation/3/1</md:Model.profile>\";\n            Pattern pattern = Pattern.compile(regex);\n            Matcher matcher = pattern.matcher(eqFile);\n            assertEquals(1, matcherCount(matcher));\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-48058",
    "cwe_list": [
      "CWE-1333"
    ],
    "commit_hash": "72f79dec6d4292f892fbddd68a19c67935c7d81f",
    "short_hash": "72f79dec",
    "vulnerableMethods_before": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "testWriteBoundaryTnInTopologicalIsland",
        "raw_code": "@Test\n    void testWriteBoundaryTnInTopologicalIsland() throws XMLStreamException {\n        Network network = Network.read(CgmesConformity1Catalog.microGridBaseCaseNL().dataSource());\n        Optional<? extends Terminal> terminal = network.getBusBreakerView().getBus(\"97d7d14a-7294-458f-a8d7-024700a08717\").getConnectedTerminalStream().findFirst();\n        assertTrue(terminal.isPresent());\n        ReferenceTerminals.addTerminal(terminal.get());\n        String sv = exportSvAsString(network, false);\n        Pattern p = Pattern.compile(\"<cim:TopologicalIsland.TopologicalNodes rdf:resource=\");\n        assertEquals(10, p.matcher(sv).results().count());\n        // 10 is the number of topological nodes in the island associated to buses and to dangling lines\n        assertEquals(5, network.getBusBreakerView().getBusStream().count());\n        assertEquals(5, network.getDanglingLineStream().count());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "testWriteBoundaryTnInTopologicalIsland",
        "raw_code": "@Test\n    void testWriteBoundaryTnInTopologicalIsland() throws XMLStreamException {\n        Network network = Network.read(CgmesConformity1Catalog.microGridBaseCaseNL().dataSource());\n        Optional<? extends Terminal> terminal = network.getBusBreakerView().getBus(\"97d7d14a-7294-458f-a8d7-024700a08717\").getConnectedTerminalStream().findFirst();\n        assertTrue(terminal.isPresent());\n        ReferenceTerminals.addTerminal(terminal.get());\n        String sv = exportSvAsString(network, false);\n        Pattern p = Pattern.compile(\"<cim:TopologicalIsland.TopologicalNodes rdf:resource=\");\n        assertEquals(10, matcherCount(p.matcher(sv)));\n        // 10 is the number of topological nodes in the island associated to buses and to dangling lines\n        assertEquals(5, network.getBusBreakerView().getBusStream().count());\n        assertEquals(5, network.getDanglingLineStream().count());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readSvShuntCompensatorSections",
        "raw_code": "private static SvShuntCompensatorSections readSvShuntCompensatorSections(String sv) {\n        final String svShuntCompensatorSections = \"SvShuntCompensatorSections\";\n        final String svShuntCompensatorSectionsSections = \"SvShuntCompensatorSections.sections\";\n        final String svShuntCompensatorSectionsShuntCompensator = \"SvShuntCompensatorSections.ShuntCompensator\";\n        final String attrResource = \"resource\";\n\n        SvShuntCompensatorSections svdata = new SvShuntCompensatorSections();\n        try (InputStream is = new ByteArrayInputStream(sv.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            Integer sections = null;\n            String shuntCompensatorId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(svShuntCompensatorSections)) {\n                        sections = null;\n                        shuntCompensatorId = null;\n                    } else if (reader.getLocalName().equals(svShuntCompensatorSectionsSections)) {\n                        String text = reader.getElementText();\n                        sections = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(svShuntCompensatorSectionsShuntCompensator)) {\n                        shuntCompensatorId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrResource).substring(2);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(svShuntCompensatorSections) && sections != null) {\n                        svdata.add(shuntCompensatorId, sections);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return svdata;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readSvShuntCompensatorSections",
        "raw_code": "private static SvShuntCompensatorSections readSvShuntCompensatorSections(String sv) {\n        final String svShuntCompensatorSections = \"SvShuntCompensatorSections\";\n        final String svShuntCompensatorSectionsSections = \"SvShuntCompensatorSections.sections\";\n        final String svShuntCompensatorSectionsShuntCompensator = \"SvShuntCompensatorSections.ShuntCompensator\";\n        final String attrResource = \"resource\";\n\n        SvShuntCompensatorSections svdata = new SvShuntCompensatorSections();\n        try (InputStream is = new ByteArrayInputStream(sv.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            Integer sections = null;\n            String shuntCompensatorId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(svShuntCompensatorSections)) {\n                        sections = null;\n                        shuntCompensatorId = null;\n                    } else if (reader.getLocalName().equals(svShuntCompensatorSectionsSections)) {\n                        String text = reader.getElementText();\n                        sections = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(svShuntCompensatorSectionsShuntCompensator)) {\n                        shuntCompensatorId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrResource).substring(2);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(svShuntCompensatorSections) && sections != null) {\n                        svdata.add(shuntCompensatorId, sections);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return svdata;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readFirstTopologicalIslandDescription",
        "raw_code": "private static String readFirstTopologicalIslandDescription(Path sv) {\n        String description = \"\";\n        boolean insideTopologicalIsland = false;\n        try (InputStream is = Files.newInputStream(sv)) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int token = reader.next();\n                if (token == XMLStreamConstants.START_ELEMENT) {\n                    // Retrieve the TopologicalIsland node\n                    if (reader.getLocalName().equals(CgmesNames.TOPOLOGICAL_ISLAND)) {\n                        insideTopologicalIsland = true;\n                    }\n                    if (insideTopologicalIsland && reader.getLocalName().equals(CgmesNames.IDENTIFIED_OBJECT_DESCRIPTION)) {\n                        description = reader.getElementText();\n                    }\n                } else if (token == XMLStreamConstants.END_ELEMENT && reader.getLocalName().equals(CgmesNames.TOPOLOGICAL_ISLAND)) {\n                    break;\n                }\n            }\n            reader.close();\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return description;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readFirstTopologicalIslandDescription",
        "raw_code": "private static String readFirstTopologicalIslandDescription(Path sv) {\n        String description = \"\";\n        boolean insideTopologicalIsland = false;\n        try (InputStream is = Files.newInputStream(sv)) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int token = reader.next();\n                if (token == XMLStreamConstants.START_ELEMENT) {\n                    // Retrieve the TopologicalIsland node\n                    if (reader.getLocalName().equals(CgmesNames.TOPOLOGICAL_ISLAND)) {\n                        insideTopologicalIsland = true;\n                    }\n                    if (insideTopologicalIsland && reader.getLocalName().equals(CgmesNames.IDENTIFIED_OBJECT_DESCRIPTION)) {\n                        description = reader.getElementText();\n                    }\n                } else if (token == XMLStreamConstants.END_ELEMENT && reader.getLocalName().equals(CgmesNames.TOPOLOGICAL_ISLAND)) {\n                    break;\n                }\n            }\n            reader.close();\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return description;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readSvTapSteps",
        "raw_code": "private static SvTapSteps readSvTapSteps(String sv) {\n        final String svTapStep = \"SvTapStep\";\n        final String svTapStepPosition = \"SvTapStep.position\";\n        final String svTapStepTapChanger = \"SvTapStep.TapChanger\";\n        final String attrResource = \"resource\";\n\n        SvTapSteps svTapSteps = new SvTapSteps();\n        try (InputStream is = new ByteArrayInputStream(sv.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            Integer position = null;\n            String tapChangerId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(svTapStep)) {\n                        position = null;\n                        tapChangerId = null;\n                    } else if (reader.getLocalName().equals(svTapStepPosition)) {\n                        String text = reader.getElementText();\n                        position = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(svTapStepTapChanger)) {\n                        tapChangerId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrResource).substring(2);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(svTapStep) && position != null) {\n                        svTapSteps.add(tapChangerId, position);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return svTapSteps;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readSvTapSteps",
        "raw_code": "private static SvTapSteps readSvTapSteps(String sv) {\n        final String svTapStep = \"SvTapStep\";\n        final String svTapStepPosition = \"SvTapStep.position\";\n        final String svTapStepTapChanger = \"SvTapStep.TapChanger\";\n        final String attrResource = \"resource\";\n\n        SvTapSteps svTapSteps = new SvTapSteps();\n        try (InputStream is = new ByteArrayInputStream(sv.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            Integer position = null;\n            String tapChangerId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(svTapStep)) {\n                        position = null;\n                        tapChangerId = null;\n                    } else if (reader.getLocalName().equals(svTapStepPosition)) {\n                        String text = reader.getElementText();\n                        position = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(svTapStepTapChanger)) {\n                        tapChangerId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrResource).substring(2);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(svTapStep) && position != null) {\n                        svTapSteps.add(tapChangerId, position);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return svTapSteps;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "TapChangerNeutralStepTest.java",
        "method_name": "readTapChangerNeutralSteps",
        "raw_code": "private static Map<String, Integer> readTapChangerNeutralSteps(Path eq) {\n        Map<String, Integer> map = new HashMap<>();\n        String tapChangerId = null;\n        Integer neutralStep = null;\n        try (InputStream is = Files.newInputStream(eq)) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (isTapChanger(reader.getLocalName())) {\n                        tapChangerId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, ATTR_ID).substring(1);\n                    } else if (reader.getLocalName().equals(TAP_CHANGER_NEUTRAL_STEP)) {\n                        neutralStep = Integer.parseInt(reader.getElementText());\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (isTapChanger(reader.getLocalName()) && tapChangerId != null && neutralStep != null) {\n                        map.put(tapChangerId, neutralStep);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return map;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "TapChangerNeutralStepTest.java",
        "method_name": "readTapChangerNeutralSteps",
        "raw_code": "private static Map<String, Integer> readTapChangerNeutralSteps(Path eq) {\n        Map<String, Integer> map = new HashMap<>();\n        String tapChangerId = null;\n        Integer neutralStep = null;\n        try (InputStream is = Files.newInputStream(eq)) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (isTapChanger(reader.getLocalName())) {\n                        tapChangerId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, ATTR_ID).substring(1);\n                    } else if (reader.getLocalName().equals(TAP_CHANGER_NEUTRAL_STEP)) {\n                        neutralStep = Integer.parseInt(reader.getElementText());\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (isTapChanger(reader.getLocalName()) && tapChangerId != null && neutralStep != null) {\n                        map.put(tapChangerId, neutralStep);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return map;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "ConversionUtil.java",
        "method_name": "xmlContains",
        "raw_code": "public static boolean xmlContains(InputStream is, String clazz, String ns, String attr, String expectedValue) {\n        try {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(clazz)) {\n                    String actualValue = reader.getAttributeValue(ns, attr);\n                    if (expectedValue.equals(actualValue)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversionUtil.java",
        "method_name": "xmlContains",
        "raw_code": "public static boolean xmlContains(InputStream is, String clazz, String ns, String attr, String expectedValue) {\n        try {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(clazz)) {\n                    String actualValue = reader.getAttributeValue(ns, attr);\n                    if (expectedValue.equals(actualValue)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "CgmesImport.java",
        "method_name": "separateByModelingAuthority",
        "raw_code": "private Set<ReadOnlyDataSource> separateByModelingAuthority() {\n            xmlInputFactory = XMLInputFactory.newInstance();\n            Map<String, List<String>> igmNames = new CgmesOnDataSource(dataSource).names().stream()\n                    // We consider IGMs only the modeling authorities that have an EQ file\n                    // The CGM SV should have the MA of the merging agent\n                    .filter(CgmesSubset.EQUIPMENT::isValidName)\n                    .map(name -> readModelingAuthority(name).map(ma -> Map.entry(ma, name)))\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toMap(Map.Entry::getKey, e -> new ArrayList<>(List.of(e.getValue()))));\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM EQ files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, v.get(0)));\n            }\n            // If we only have found one IGM there is no need to partition\n            if (igmNames.size() == 1) {\n                return Set.of(dataSource);\n            }\n            Set<String> shared = new HashSet<>();\n            new CgmesOnDataSource(dataSource).names().stream()\n                    // We read the modeling authorities present in the rest of instance files\n                    // and mark the instance name as linked to an IGM or as shared\n                    .filter(not(CgmesSubset.EQUIPMENT::isValidName))\n                    .filter(not(MultipleGridModelChecker::isBoundary))\n                    .forEach(name -> {\n                        Optional<String> ma = readModelingAuthority(name);\n                        if (ma.isPresent() && igmNames.containsKey(ma.get())) {\n                            igmNames.get(ma.get()).add(name);\n                        } else {\n                            shared.add(name);\n                        }\n                    });\n            // Build one data source for each IGM found\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, String.join(\",\", v)));\n                if (!shared.isEmpty()) {\n                    LOGGER.info(\"Shared files:\");\n                    shared.forEach(name -> LOGGER.info(\"  {}\", name));\n                }\n                LOGGER.info(\"Boundaries:\");\n                try {\n                    dataSource.listNames(\".*\").stream().filter(MultipleGridModelChecker::isBoundary).forEach(name -> LOGGER.info(\"  {}\", name));\n                } catch (IOException e) {\n                    throw new PowsyblException(e);\n                }\n            }\n            return igmNames.keySet().stream()\n                    .map(ma -> new FilteredReadOnlyDataSource(dataSource,\n                            name -> isBoundary(name) || igmNames.get(ma).contains(name) || shared.contains(name)))\n                    .collect(Collectors.toSet());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CgmesImport.java",
        "method_name": "separateByModelingAuthority",
        "raw_code": "private Set<ReadOnlyDataSource> separateByModelingAuthority() {\n            xmlInputFactory = getXMLInputFactory();\n            Map<String, List<String>> igmNames = new CgmesOnDataSource(dataSource).names().stream()\n                    // We consider IGMs only the modeling authorities that have an EQ file\n                    // The CGM SV should have the MA of the merging agent\n                    .filter(CgmesSubset.EQUIPMENT::isValidName)\n                    .map(name -> readModelingAuthority(name).map(ma -> Map.entry(ma, name)))\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toMap(Map.Entry::getKey, e -> new ArrayList<>(List.of(e.getValue()))));\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM EQ files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, v.get(0)));\n            }\n            // If we only have found one IGM there is no need to partition\n            if (igmNames.size() == 1) {\n                return Set.of(dataSource);\n            }\n            Set<String> shared = new HashSet<>();\n            new CgmesOnDataSource(dataSource).names().stream()\n                    // We read the modeling authorities present in the rest of instance files\n                    // and mark the instance name as linked to an IGM or as shared\n                    .filter(not(CgmesSubset.EQUIPMENT::isValidName))\n                    .filter(not(MultipleGridModelChecker::isBoundary))\n                    .forEach(name -> {\n                        Optional<String> ma = readModelingAuthority(name);\n                        if (ma.isPresent() && igmNames.containsKey(ma.get())) {\n                            igmNames.get(ma.get()).add(name);\n                        } else {\n                            shared.add(name);\n                        }\n                    });\n            // Build one data source for each IGM found\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, String.join(\",\", v)));\n                if (!shared.isEmpty()) {\n                    LOGGER.info(\"Shared files:\");\n                    shared.forEach(name -> LOGGER.info(\"  {}\", name));\n                }\n                LOGGER.info(\"Boundaries:\");\n                try {\n                    dataSource.listNames(\".*\").stream().filter(MultipleGridModelChecker::isBoundary).forEach(name -> LOGGER.info(\"  {}\", name));\n                } catch (IOException e) {\n                    throw new PowsyblException(e);\n                }\n            }\n            return igmNames.keySet().stream()\n                    .map(ma -> new FilteredReadOnlyDataSource(dataSource,\n                            name -> isBoundary(name) || igmNames.get(ma).contains(name) || shared.contains(name)))\n                    .collect(Collectors.toSet());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readAttributes",
        "raw_code": "@Test\n    void readAttributes() throws XMLStreamException {\n        AtomicReference<Boolean> attrBoolBoxed = new AtomicReference<>(false);\n        AtomicBoolean attrBool = new AtomicBoolean(false);\n        AtomicReference<Integer> attrInteger = new AtomicReference<>(-1);\n        AtomicInteger attrInt = new AtomicInteger(-1);\n        AtomicReference<Double> attrDbl = new AtomicReference<>(0d);\n        AtomicReference<Float> attrFloat = new AtomicReference<>(0f);\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            xmlReader.next();\n            try {\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    if (\"b\".equals(elementName)) {\n                        attrBoolBoxed.set(XmlUtil.readBooleanAttribute(xmlReader, \"attrBool\"));\n                        attrBool.set(XmlUtil.readBooleanAttribute(xmlReader, \"attrBool\", false));\n                        attrInteger.set(XmlUtil.readIntegerAttribute(xmlReader, \"attrInt\"));\n                        attrInt.set(XmlUtil.readIntAttribute(xmlReader, \"attrInt\", -1));\n                        attrDbl.set(XmlUtil.readDoubleAttribute(xmlReader, \"attrDbl\", 0));\n                        attrFloat.set(XmlUtil.readFloatAttribute(xmlReader, \"attrFlt\", 0));\n                    }\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n\n        assertTrue(attrBoolBoxed::get);\n        assertTrue(attrBool.get());\n        assertEquals(34, attrInteger.get());\n        assertEquals(34, attrInt.get());\n        assertEquals(2e-65, attrDbl.get(), 1e-80);\n        assertEquals(0.054864f, attrFloat.get(), 1e-15);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readAttributes",
        "raw_code": "@Test\n    void readAttributes() throws XMLStreamException {\n        AtomicReference<Boolean> attrBoolBoxed = new AtomicReference<>(false);\n        AtomicBoolean attrBool = new AtomicBoolean(false);\n        AtomicReference<Integer> attrInteger = new AtomicReference<>(-1);\n        AtomicInteger attrInt = new AtomicInteger(-1);\n        AtomicReference<Double> attrDbl = new AtomicReference<>(0d);\n        AtomicReference<Float> attrFloat = new AtomicReference<>(0f);\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            xmlReader.next();\n            try {\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    if (\"b\".equals(elementName)) {\n                        attrBoolBoxed.set(XmlUtil.readBooleanAttribute(xmlReader, \"attrBool\"));\n                        attrBool.set(XmlUtil.readBooleanAttribute(xmlReader, \"attrBool\", false));\n                        attrInteger.set(XmlUtil.readIntegerAttribute(xmlReader, \"attrInt\"));\n                        attrInt.set(XmlUtil.readIntAttribute(xmlReader, \"attrInt\", -1));\n                        attrDbl.set(XmlUtil.readDoubleAttribute(xmlReader, \"attrDbl\", 0));\n                        attrFloat.set(XmlUtil.readFloatAttribute(xmlReader, \"attrFlt\", 0));\n                    }\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n\n        assertTrue(attrBoolBoxed::get);\n        assertTrue(attrBool.get());\n        assertEquals(34, attrInteger.get());\n        assertEquals(34, attrInt.get());\n        assertEquals(2e-65, attrDbl.get(), 1e-80);\n        assertEquals(0.054864f, attrFloat.get(), 1e-15);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readUntilEndElementWithDepthTest",
        "raw_code": "@Test\n    void readUntilEndElementWithDepthTest() throws XMLStreamException {\n        Map<String, Integer> depths = new HashMap<>();\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            xmlReader.next();\n            try {\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    depths.put(elementName, 0);\n                    XmlUtil.readSubElements(xmlReader, elementName1 -> {\n                        depths.put(elementName1, 1);\n                        XmlUtil.skipSubElements(xmlReader);\n                    });\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n        assertEquals(ImmutableMap.of(\"b\", 0, \"c\", 1, \"d\", 0), depths);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readUntilEndElementWithDepthTest",
        "raw_code": "@Test\n    void readUntilEndElementWithDepthTest() throws XMLStreamException {\n        Map<String, Integer> depths = new HashMap<>();\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            xmlReader.next();\n            try {\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    depths.put(elementName, 0);\n                    XmlUtil.readSubElements(xmlReader, elementName1 -> {\n                        depths.put(elementName1, 1);\n                        XmlUtil.skipSubElements(xmlReader);\n                    });\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n        assertEquals(ImmutableMap.of(\"b\", 0, \"c\", 1, \"d\", 0), depths);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "nestedReadUntilEndElementWithDepthTest",
        "raw_code": "@Test\n    void nestedReadUntilEndElementWithDepthTest() throws XMLStreamException {\n        Map<String, Integer> depths = new HashMap<>();\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            try {\n                xmlReader.next();\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    depths.put(elementName, 0);\n                    // consume b and c\n                    if (elementName.equals(\"b\")) {\n                        XmlUtil.readSubElements(xmlReader, elementName1 -> {\n                            depths.put(elementName1, 1);\n                            XmlUtil.skipSubElements(xmlReader);\n                        });\n                    }\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n        assertEquals(ImmutableMap.of(\"b\", 0, \"c\", 1, \"d\", 0), depths);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "nestedReadUntilEndElementWithDepthTest",
        "raw_code": "@Test\n    void nestedReadUntilEndElementWithDepthTest() throws XMLStreamException {\n        Map<String, Integer> depths = new HashMap<>();\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                xmlReader.next();\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    depths.put(elementName, 0);\n                    // consume b and c\n                    if (elementName.equals(\"b\")) {\n                        XmlUtil.readSubElements(xmlReader, elementName1 -> {\n                            depths.put(elementName1, 1);\n                            XmlUtil.skipSubElements(xmlReader);\n                        });\n                    }\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n        assertEquals(ImmutableMap.of(\"b\", 0, \"c\", 1, \"d\", 0), depths);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readUntilStartElementTest",
        "raw_code": "private void readUntilStartElementTest(String path, String expected) throws XMLStreamException {\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(path, xmlReader, elementName -> assertEquals(expected, xmlReader.getLocalName()));\n            } finally {\n                xmlReader.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readUntilStartElementTest",
        "raw_code": "private void readUntilStartElementTest(String path, String expected) throws XMLStreamException {\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(path, xmlReader, elementName -> assertEquals(expected, xmlReader.getLocalName()));\n            } finally {\n                xmlReader.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readTextTest",
        "raw_code": "@Test\n    void readTextTest() throws XMLStreamException {\n        String xml = \"<a>hello</a>\";\n        try (StringReader reader = new StringReader(xml)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            try {\n                String text = null;\n                while (xmlReader.hasNext()) {\n                    int next = xmlReader.next();\n                    if (next == XMLStreamConstants.START_ELEMENT && xmlReader.getLocalName().equals(\"a\")) {\n                        text = XmlUtil.readText(xmlReader);\n                    }\n                }\n                assertEquals(\"hello\", text);\n            } finally {\n                xmlReader.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readTextTest",
        "raw_code": "@Test\n    void readTextTest() throws XMLStreamException {\n        String xml = \"<a>hello</a>\";\n        try (StringReader reader = new StringReader(xml)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                String text = null;\n                while (xmlReader.hasNext()) {\n                    int next = xmlReader.next();\n                    if (next == XMLStreamConstants.START_ELEMENT && xmlReader.getLocalName().equals(\"a\")) {\n                        text = XmlUtil.readText(xmlReader);\n                    }\n                }\n                assertEquals(\"hello\", text);\n            } finally {\n                xmlReader.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XMLImporter.java",
        "method_name": "exists",
        "raw_code": "protected boolean exists(ReadOnlyDataSource dataSource, String ext) throws IOException {\n        try {\n            if (ext != null) {\n                try (InputStream is = dataSource.newInputStream(null, ext)) {\n                    // check the first root element is network and namespace is IIDM\n                    XMLStreamReader xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n                    try {\n                        while (xmlsr.hasNext()) {\n                            int eventType = xmlsr.next();\n                            if (eventType == XMLStreamConstants.START_ELEMENT) {\n                                String name = xmlsr.getLocalName();\n                                String ns = xmlsr.getNamespaceURI();\n                                return NetworkSerDe.NETWORK_ROOT_ELEMENT_NAME.equals(name)\n                                        && (Stream.of(IidmVersion.values()).anyMatch(v -> v.getNamespaceURI().equals(ns))\n                                        || Stream.of(IidmVersion.values()).filter(v -> v.compareTo(IidmVersion.V_1_7) >= 0).anyMatch(v -> v.getNamespaceURI(false).equals(ns)));\n                            }\n                        }\n                    } finally {\n                        cleanClose(xmlsr);\n                    }\n                }\n            }\n            return false;\n        } catch (XMLStreamException e) {\n            // not a valid xml file\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XMLImporter.java",
        "method_name": "exists",
        "raw_code": "protected boolean exists(ReadOnlyDataSource dataSource, String ext) throws IOException {\n        try {\n            if (ext != null) {\n                try (InputStream is = dataSource.newInputStream(null, ext)) {\n                    // check the first root element is network and namespace is IIDM\n                    XMLStreamReader xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n                    try {\n                        while (xmlsr.hasNext()) {\n                            int eventType = xmlsr.next();\n                            if (eventType == XMLStreamConstants.START_ELEMENT) {\n                                String name = xmlsr.getLocalName();\n                                String ns = xmlsr.getNamespaceURI();\n                                return NetworkSerDe.NETWORK_ROOT_ELEMENT_NAME.equals(name)\n                                        && (Stream.of(IidmVersion.values()).anyMatch(v -> v.getNamespaceURI().equals(ns))\n                                        || Stream.of(IidmVersion.values()).filter(v -> v.compareTo(IidmVersion.V_1_7) >= 0).anyMatch(v -> v.getNamespaceURI(false).equals(ns)));\n                            }\n                        }\n                    } finally {\n                        cleanClose(xmlsr);\n                    }\n                }\n            }\n            return false;\n        } catch (XMLStreamException e) {\n            // not a valid xml file\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XMLImporter.java",
        "method_name": "cleanClose",
        "raw_code": "private void cleanClose(XMLStreamReader xmlStreamReader) {\n        try {\n            xmlStreamReader.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        } catch (XMLStreamException e) {\n            LOGGER.error(e.toString(), e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XMLImporter.java",
        "method_name": "cleanClose",
        "raw_code": "private void cleanClose(XMLStreamReader xmlStreamReader) {\n        try {\n            xmlStreamReader.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        } catch (XMLStreamException e) {\n            LOGGER.error(e.toString(), e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlReader.java",
        "method_name": "close",
        "raw_code": "@Override\n    public void close() {\n        try {\n            reader.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlReader.java",
        "method_name": "close",
        "raw_code": "@Override\n    public void close() {\n        try {\n            reader.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "CommonGridModelExportTest.java",
        "method_name": "readVersion",
        "raw_code": "private static Optional<Integer> readVersion(InputStream is) {\n        try {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"Model.version\")) {\n                    String version = reader.getElementText();\n                    reader.close();\n                    return Optional.of(Integer.parseInt(version));\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return Optional.empty();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CommonGridModelExportTest.java",
        "method_name": "readVersion",
        "raw_code": "private static Optional<Integer> readVersion(InputStream is) {\n        try {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"Model.version\")) {\n                    String version = reader.getElementText();\n                    reader.close();\n                    return Optional.of(Integer.parseInt(version));\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return Optional.empty();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "CommonGridModelExportTest.java",
        "method_name": "readId",
        "raw_code": "private static String readId(InputStream is) {\n        try {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"FullModel\")) {\n                    String id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, \"about\");\n                    reader.close();\n                    return id;\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return null;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CommonGridModelExportTest.java",
        "method_name": "readId",
        "raw_code": "private static String readId(InputStream is) {\n        try {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"FullModel\")) {\n                    String id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, \"about\");\n                    reader.close();\n                    return id;\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return null;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "FullModel.java",
        "method_name": "parse",
        "raw_code": "public static FullModel parse(Reader reader) {\n        Objects.requireNonNull(reader);\n        ParsingContext context = new ParsingContext();\n        try {\n            XMLStreamReader xmlReader = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(new String[] {\"/\", CgmesNames.RDF, CgmesNames.FULL_MODEL}, xmlReader, elementName1 -> {\n                    context.id = xmlReader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, CgmesNames.ABOUT);\n                    XmlUtil.readSubElements(xmlReader, subElementName -> readSubElement(subElementName, context, xmlReader));\n                });\n            } finally {\n                xmlReader.close();\n                XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n            }\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n        // the other attributes are checked in the constructor\n        if (context.version == null) {\n            throw new PowsyblException(\"Version is missing\");\n        }\n        return new FullModel(context.id, context.scenarioTime, context.created, context.description, context.version,\n                             context.profiles, context.dependentOn, context.supersedes, context.modelingAuthoritySet);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FullModel.java",
        "method_name": "parse",
        "raw_code": "public static FullModel parse(Reader reader) {\n        Objects.requireNonNull(reader);\n        ParsingContext context = new ParsingContext();\n        try {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(new String[] {\"/\", CgmesNames.RDF, CgmesNames.FULL_MODEL}, xmlReader, elementName1 -> {\n                    context.id = xmlReader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, CgmesNames.ABOUT);\n                    XmlUtil.readSubElements(xmlReader, subElementName -> readSubElement(subElementName, context, xmlReader));\n                });\n            } finally {\n                xmlReader.close();\n                XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n            }\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n        // the other attributes are checked in the constructor\n        if (context.version == null) {\n            throw new PowsyblException(\"Version is missing\");\n        }\n        return new FullModel(context.id, context.scenarioTime, context.created, context.description, context.version,\n                             context.profiles, context.dependentOn, context.supersedes, context.modelingAuthoritySet);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "NamespaceReader.java",
        "method_name": "namespaces1",
        "raw_code": "private static Set<String> namespaces1(InputStream is) throws XMLStreamException {\n        Set<String> found = new HashSet<>();\n        XMLStreamReader xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n        try {\n            boolean root = false;\n            while (xmlsr.hasNext() && !root) {\n                int eventType = xmlsr.next();\n                if (eventType == XMLStreamConstants.START_ELEMENT) {\n                    root = true;\n                    for (int k = 0; k < xmlsr.getNamespaceCount(); k++) {\n                        found.add(xmlsr.getNamespaceURI(k));\n                    }\n                }\n            }\n        } finally {\n            xmlsr.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        }\n        return found;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "NamespaceReader.java",
        "method_name": "namespaces1",
        "raw_code": "private static Set<String> namespaces1(InputStream is) throws XMLStreamException {\n        Set<String> found = new HashSet<>();\n        XMLStreamReader xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n        try {\n            boolean root = false;\n            while (xmlsr.hasNext() && !root) {\n                int eventType = xmlsr.next();\n                if (eventType == XMLStreamConstants.START_ELEMENT) {\n                    root = true;\n                    for (int k = 0; k < xmlsr.getNamespaceCount(); k++) {\n                        found.add(xmlsr.getNamespaceURI(k));\n                    }\n                }\n            }\n        } finally {\n            xmlsr.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        }\n        return found;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "NamespaceReader.java",
        "method_name": "base",
        "raw_code": "public static String base(InputStream is) {\n        XMLStreamReader xmlsr;\n        try {\n            xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n            try {\n                while (xmlsr.hasNext()) {\n                    int eventType = xmlsr.next();\n                    if (eventType == XMLStreamConstants.START_ELEMENT) {\n                        return xmlsr.getAttributeValue(null, \"base\");\n                    }\n                }\n            } finally {\n                xmlsr.close();\n                XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n            }\n            return null;\n        } catch (XMLStreamException e) {\n            throw new CgmesModelException(\"base\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "NamespaceReader.java",
        "method_name": "base",
        "raw_code": "public static String base(InputStream is) {\n        XMLStreamReader xmlsr;\n        try {\n            xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n            try {\n                while (xmlsr.hasNext()) {\n                    int eventType = xmlsr.next();\n                    if (eventType == XMLStreamConstants.START_ELEMENT) {\n                        return xmlsr.getAttributeValue(null, \"base\");\n                    }\n                }\n            } finally {\n                xmlsr.close();\n                XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n            }\n            return null;\n        } catch (XMLStreamException e) {\n            throw new CgmesModelException(\"base\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "CgmesExportTest.java",
        "method_name": "xmlFileContainsRegulatingControl",
        "raw_code": "private static boolean xmlFileContainsRegulatingControl(String expectedRdfIdAttributeValue, String rdfIdAttributeName, Path file) throws IOException, XMLStreamException {\n        try (InputStream is = Files.newInputStream(file)) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"TapChangerControl\")) {\n                    String id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, rdfIdAttributeName);\n                    if (expectedRdfIdAttributeValue.equals(id)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        }\n        return false;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CgmesExportTest.java",
        "method_name": "xmlFileContainsRegulatingControl",
        "raw_code": "private static boolean xmlFileContainsRegulatingControl(String expectedRdfIdAttributeValue, String rdfIdAttributeName, Path file) throws IOException, XMLStreamException {\n        try (InputStream is = Files.newInputStream(file)) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"TapChangerControl\")) {\n                    String id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, rdfIdAttributeName);\n                    if (expectedRdfIdAttributeValue.equals(id)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        }\n        return false;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "PropertiesModuleConfigRepository.java",
        "method_name": "writeXml",
        "raw_code": "public static void writeXml(Path configDir, Path xmlFile) throws IOException, XMLStreamException {\n        XMLOutputFactory output = XMLOutputFactory.newInstance();\n        try (Writer writer = Files.newBufferedWriter(xmlFile, StandardCharsets.UTF_8)) {\n            XMLStreamWriter xmlWriter = output.createXMLStreamWriter(writer);\n            try {\n                xmlWriter.writeStartDocument(StandardCharsets.UTF_8.toString(), \"1.0\");\n                xmlWriter.writeStartElement(\"config\");\n                try (DirectoryStream<Path> ds = Files.newDirectoryStream(configDir, entry -> Files.isRegularFile(entry) && entry.getFileName().toString().endsWith(\".properties\"))) {\n                    for (Path file : ds) {\n                        String fileName = file.getFileName().toString();\n                        String fileNameWithoutExtension = fileName.substring(0, fileName.length() - 11);\n                        xmlWriter.writeStartElement(fileNameWithoutExtension);\n                        Properties properties = new Properties();\n                        try (Reader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {\n                            properties.load(reader);\n                        }\n                        for (String name : properties.stringPropertyNames()) {\n                            String value = properties.getProperty(name);\n                            xmlWriter.writeStartElement(name);\n                            xmlWriter.writeCharacters(value);\n                            xmlWriter.writeEndElement();\n                        }\n                        xmlWriter.writeEndElement();\n                    }\n                }\n                xmlWriter.writeEndElement();\n                xmlWriter.writeEndDocument();\n            } finally {\n                xmlWriter.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertiesModuleConfigRepository.java",
        "method_name": "writeXml",
        "raw_code": "public static void writeXml(Path configDir, Path xmlFile) throws IOException, XMLStreamException {\n        XMLOutputFactory output = getXMLOutputFactory();\n        try (Writer writer = Files.newBufferedWriter(xmlFile, StandardCharsets.UTF_8)) {\n            XMLStreamWriter xmlWriter = output.createXMLStreamWriter(writer);\n            try {\n                xmlWriter.writeStartDocument(StandardCharsets.UTF_8.toString(), \"1.0\");\n                xmlWriter.writeStartElement(\"config\");\n                try (DirectoryStream<Path> ds = Files.newDirectoryStream(configDir, entry -> Files.isRegularFile(entry) && entry.getFileName().toString().endsWith(\".properties\"))) {\n                    for (Path file : ds) {\n                        String fileName = file.getFileName().toString();\n                        String fileNameWithoutExtension = fileName.substring(0, fileName.length() - 11);\n                        xmlWriter.writeStartElement(fileNameWithoutExtension);\n                        Properties properties = new Properties();\n                        try (Reader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {\n                            properties.load(reader);\n                        }\n                        for (String name : properties.stringPropertyNames()) {\n                            String value = properties.getProperty(name);\n                            xmlWriter.writeStartElement(name);\n                            xmlWriter.writeCharacters(value);\n                            xmlWriter.writeEndElement();\n                        }\n                        xmlWriter.writeEndElement();\n                    }\n                }\n                xmlWriter.writeEndElement();\n                xmlWriter.writeEndDocument();\n            } finally {\n                xmlWriter.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "SteadyStateHypothesisExportTest.java",
        "method_name": "readSshLinearShuntCompensator",
        "raw_code": "private static SshLinearShuntCompensators readSshLinearShuntCompensator(String ssh) {\n        final String sshLinearShuntCompensator = \"LinearShuntCompensator\";\n        final String sshLinearShuntCompensatorSections = \"ShuntCompensator.sections\";\n        final String sshLinearShuntCompensatorControlEnabled = \"RegulatingCondEq.controlEnabled\";\n        final String attrAbout = \"about\";\n\n        SshLinearShuntCompensators sshLinearShuntCompensators = new SshLinearShuntCompensators();\n        try (InputStream is = new ByteArrayInputStream(ssh.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            Integer sections = null;\n            Boolean controlEnabled = null;\n            String shuntCompensatorId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(sshLinearShuntCompensator)) {\n                        sections = null;\n                        controlEnabled = null;\n                        shuntCompensatorId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrAbout).substring(2);\n                    } else if (reader.getLocalName().equals(sshLinearShuntCompensatorSections)) {\n                        String text = reader.getElementText();\n                        sections = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(sshLinearShuntCompensatorControlEnabled)) {\n                        String text = reader.getElementText();\n                        controlEnabled = Boolean.valueOf(text);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(sshLinearShuntCompensator) && sections != null && controlEnabled != null) {\n                        sshLinearShuntCompensators.add(shuntCompensatorId, sections, controlEnabled);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sshLinearShuntCompensators;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SteadyStateHypothesisExportTest.java",
        "method_name": "readSshLinearShuntCompensator",
        "raw_code": "private static SshLinearShuntCompensators readSshLinearShuntCompensator(String ssh) {\n        final String sshLinearShuntCompensator = \"LinearShuntCompensator\";\n        final String sshLinearShuntCompensatorSections = \"ShuntCompensator.sections\";\n        final String sshLinearShuntCompensatorControlEnabled = \"RegulatingCondEq.controlEnabled\";\n        final String attrAbout = \"about\";\n\n        SshLinearShuntCompensators sshLinearShuntCompensators = new SshLinearShuntCompensators();\n        try (InputStream is = new ByteArrayInputStream(ssh.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            Integer sections = null;\n            Boolean controlEnabled = null;\n            String shuntCompensatorId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(sshLinearShuntCompensator)) {\n                        sections = null;\n                        controlEnabled = null;\n                        shuntCompensatorId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrAbout).substring(2);\n                    } else if (reader.getLocalName().equals(sshLinearShuntCompensatorSections)) {\n                        String text = reader.getElementText();\n                        sections = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(sshLinearShuntCompensatorControlEnabled)) {\n                        String text = reader.getElementText();\n                        controlEnabled = Boolean.valueOf(text);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(sshLinearShuntCompensator) && sections != null && controlEnabled != null) {\n                        sshLinearShuntCompensators.add(shuntCompensatorId, sections, controlEnabled);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sshLinearShuntCompensators;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "SteadyStateHypothesisExportTest.java",
        "method_name": "readSshControlAreas",
        "raw_code": "private static Collection<SshExportedControlArea> readSshControlAreas(Path ssh) {\n        List<SshExportedControlArea> sshExportedControlAreas = new ArrayList<>();\n        SshExportedControlArea sshExportedControlArea = null;\n        try (InputStream is = Files.newInputStream(ssh)) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(CONTROL_AREA)) {\n                        sshExportedControlArea = new SshExportedControlArea();\n                        sshExportedControlArea.id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, ATTR_ABOUT).substring(2);\n                    } else if (reader.getLocalName().equals(CONTROL_AREA_NET_INTERCHANGE) && sshExportedControlArea != null) {\n                        sshExportedControlArea.netInterchange = Double.parseDouble(reader.getElementText());\n                    } else if (reader.getLocalName().equals(CONTROL_AREA_P_TOLERANCE) && sshExportedControlArea != null) {\n                        sshExportedControlArea.pTolerance = Double.parseDouble(reader.getElementText());\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(CONTROL_AREA) && sshExportedControlArea != null) {\n                        sshExportedControlAreas.add(sshExportedControlArea);\n                        sshExportedControlArea = null;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sshExportedControlAreas;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SteadyStateHypothesisExportTest.java",
        "method_name": "readSshControlAreas",
        "raw_code": "private static Collection<SshExportedControlArea> readSshControlAreas(Path ssh) {\n        List<SshExportedControlArea> sshExportedControlAreas = new ArrayList<>();\n        SshExportedControlArea sshExportedControlArea = null;\n        try (InputStream is = Files.newInputStream(ssh)) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(CONTROL_AREA)) {\n                        sshExportedControlArea = new SshExportedControlArea();\n                        sshExportedControlArea.id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, ATTR_ABOUT).substring(2);\n                    } else if (reader.getLocalName().equals(CONTROL_AREA_NET_INTERCHANGE) && sshExportedControlArea != null) {\n                        sshExportedControlArea.netInterchange = Double.parseDouble(reader.getElementText());\n                    } else if (reader.getLocalName().equals(CONTROL_AREA_P_TOLERANCE) && sshExportedControlArea != null) {\n                        sshExportedControlArea.pTolerance = Double.parseDouble(reader.getElementText());\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(CONTROL_AREA) && sshExportedControlArea != null) {\n                        sshExportedControlAreas.add(sshExportedControlArea);\n                        sshExportedControlArea = null;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sshExportedControlAreas;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47771",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "8ed16ce41683c4aef5f6aa1dd5ae8642aa5ed2bd",
    "short_hash": "8ed16ce4",
    "vulnerableMethods_before": [
      {
        "filename": "SparseMatrix.java",
        "method_name": "read",
        "raw_code": "public static SparseMatrix read(InputStream inputStream) {\n        Objects.requireNonNull(inputStream);\n        try (ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n            return (SparseMatrix) objectInputStream.readObject();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (ClassNotFoundException e) {\n            throw new UncheckedClassNotFoundException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SparseMatrix.java",
        "method_name": "read",
        "raw_code": "public static SparseMatrix read(InputStream inputStream) {\n        Objects.requireNonNull(inputStream);\n        try (ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n            // Check that the object to deserialize is really a SparseMatrix.\n            // This check is done prior to its complete deserialization to prevent security problems (RCE).\n            // - Check that all non-null encountered classes are among the accepted ones (the one composing a SparseMatrix).\n            ObjectInputFilter allowedClassesFilter = ObjectInputFilter.allowFilter(ALLOWED_CLASSES::contains, ObjectInputFilter.Status.REJECTED);\n            objectInputStream.setObjectInputFilter(allowedClassesFilter);\n            return (SparseMatrix) objectInputStream.readObject();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (ClassNotFoundException e) {\n            throw new UncheckedClassNotFoundException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "allure2",
    "cve_id": "CVE-2025-52888",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
    "short_hash": "cbcb3371",
    "vulnerableMethods_before": [
      {
        "filename": "XunitXmlPlugin.java",
        "method_name": "parseAssemblies",
        "raw_code": "private void parseAssemblies(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement assembliesElement = new XmlElement(document.getDocumentElement());\n            final String elementName = assembliesElement.getName();\n            if (!ASSEMBLIES_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid XUnit xml file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n\n            assembliesElement.get(ASSEMBLY_ELEMENT_NAME)\n                    .forEach(element -> parseAssembly(element, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XunitXmlPlugin.java",
        "method_name": "parseAssemblies",
        "raw_code": "private void parseAssemblies(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement assembliesElement = new XmlElement(document.getDocumentElement());\n            final String elementName = assembliesElement.getName();\n            if (!ASSEMBLIES_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid XUnit xml file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n\n            assembliesElement.get(ASSEMBLY_ELEMENT_NAME)\n                    .forEach(element -> parseAssembly(element, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "allure2",
    "cve_id": "CVE-2025-52888",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
    "short_hash": "cbcb3371",
    "vulnerableMethods_before": [
      {
        "filename": "TrxPlugin.java",
        "method_name": "parseTestRun",
        "raw_code": "protected void parseTestRun(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement testRunElement = new XmlElement(document.getDocumentElement());\n            final String elementName = testRunElement.getName();\n            if (!TEST_RUN_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid TRX file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n            final Map<String, UnitTest> tests = new HashMap<>();\n            testRunElement.getFirst(TEST_DEFINITIONS_ELEMENT)\n                    .ifPresent(testDefinitions -> {\n                        testDefinitions.get(UNIT_TEST_ELEMENT).forEach(unitTestElement -> {\n                            final UnitTest unitTest = parseUnitTest(unitTestElement);\n                            tests.put(unitTest.getExecutionId(), unitTest);\n                        });\n                    });\n            testRunElement.getFirst(RESULTS_ELEMENT_NAME)\n                    .ifPresent(resultsElement -> parseResults(resultsElement, tests, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "TrxPlugin.java",
        "method_name": "parseTestRun",
        "raw_code": "protected void parseTestRun(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement testRunElement = new XmlElement(document.getDocumentElement());\n            final String elementName = testRunElement.getName();\n            if (!TEST_RUN_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid TRX file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n            final Map<String, UnitTest> tests = new HashMap<>();\n            testRunElement.getFirst(TEST_DEFINITIONS_ELEMENT)\n                    .ifPresent(testDefinitions -> {\n                        testDefinitions.get(UNIT_TEST_ELEMENT).forEach(unitTestElement -> {\n                            final UnitTest unitTest = parseUnitTest(unitTestElement);\n                            tests.put(unitTest.getExecutionId(), unitTest);\n                        });\n                    });\n            testRunElement.getFirst(RESULTS_ELEMENT_NAME)\n                    .ifPresent(resultsElement -> parseResults(resultsElement, tests, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "allure2",
    "cve_id": "CVE-2025-52888",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
    "short_hash": "cbcb3371",
    "vulnerableMethods_before": [
      {
        "filename": "XunitXmlPluginTest.java",
        "method_name": "shouldSetStatusDetails",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"data\")\n    void shouldSetStatusDetails(final String resource,\n                                final String fileName,\n                                final String message,\n                                final String trace) throws Exception {\n        process(resource, fileName);\n\n        final ArgumentCaptor<TestResult> captor = ArgumentCaptor.captor();\n        verify(visitor, times(1)).visitTestResult(captor.capture());\n\n        assertThat(captor.getAllValues())\n                .hasSize(1)\n                .extracting(TestResult::getStatusMessage, TestResult::getStatusTrace)\n                .containsExactlyInAnyOrder(\n                        Tuple.tuple(message, trace)\n                );\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XunitXmlPluginTest.java",
        "method_name": "shouldSetStatusDetails",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"data\")\n    void shouldSetStatusDetails(final String resource,\n                                final String fileName,\n                                final String message,\n                                final String trace) throws Exception {\n        process(resource, fileName);\n\n        final ArgumentCaptor<TestResult> captor = ArgumentCaptor.captor();\n        verify(visitor, times(1)).visitTestResult(captor.capture());\n\n        assertThat(captor.getAllValues())\n                .hasSize(1)\n                .extracting(TestResult::getStatusMessage, TestResult::getStatusTrace)\n                .containsExactlyInAnyOrder(\n                        Tuple.tuple(message, trace)\n                );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "allure2",
    "cve_id": "CVE-2025-52888",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
    "short_hash": "cbcb3371",
    "vulnerableMethods_before": [
      {
        "filename": "JunitXmlPlugin.java",
        "method_name": "parseRootElement",
        "raw_code": "private void parseRootElement(final Path resultsDirectory, final Path parsedFile,\n                                  final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n\n            final XmlElement rootElement = new XmlElement(builder.parse(parsedFile.toFile()).getDocumentElement());\n            final String elementName = rootElement.getName();\n\n            if (TEST_SUITE_ELEMENT_NAME.equals(elementName)) {\n                parseTestSuite(rootElement, parsedFile, context, visitor, resultsDirectory);\n                return;\n            }\n            if (TEST_SUITES_ELEMENT_NAME.equals(elementName)) {\n                rootElement.get(TEST_SUITE_ELEMENT_NAME)\n                        .forEach(element -> parseTestSuite(element, parsedFile, context, visitor, resultsDirectory));\n                return;\n            }\n            LOGGER.debug(\"File {} is not a valid JUnit xml. Unknown root element {}\", parsedFile, elementName);\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "JunitXmlPlugin.java",
        "method_name": "parseRootElement",
        "raw_code": "private void parseRootElement(final Path resultsDirectory, final Path parsedFile,\n                                  final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n\n            final XmlElement rootElement = new XmlElement(builder.parse(parsedFile.toFile()).getDocumentElement());\n            final String elementName = rootElement.getName();\n\n            if (TEST_SUITE_ELEMENT_NAME.equals(elementName)) {\n                parseTestSuite(rootElement, parsedFile, context, visitor, resultsDirectory);\n                return;\n            }\n            if (TEST_SUITES_ELEMENT_NAME.equals(elementName)) {\n                rootElement.get(TEST_SUITE_ELEMENT_NAME)\n                        .forEach(element -> parseTestSuite(element, parsedFile, context, visitor, resultsDirectory));\n                return;\n            }\n            LOGGER.debug(\"File {} is not a valid JUnit xml. Unknown root element {}\", parsedFile, elementName);\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenFailsIfCreateNotAllowed",
        "raw_code": "@Test\n    public void createTokenFailsIfCreateNotAllowed() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME);\n        createTokenAndPrepareMocks(userProps, false);\n\n        try {\n            final UsersResource.GenerateTokenTTL ttl = new UsersResource.GenerateTokenTTL(Optional.of(PeriodDuration.of(Duration.ofDays(30))));\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, ttl));\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenFailsIfCreateNotAllowed",
        "raw_code": "@Test\n    public void createTokenFailsIfCreateNotAllowed() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME);\n        createTokenAndPrepareMocks(userProps, false);\n\n        try {\n            final UsersResource.GenerateTokenTTL ttl = new UsersResource.GenerateTokenTTL(Optional.of(PeriodDuration.of(Duration.ofDays(30))));\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, ttl));\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenSucceedsEvenWithNULLBody",
        "raw_code": "@Test\n    public void createTokenSucceedsEvenWithNULLBody() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME, UserImpl.EXTERNAL_USER, \"FALSE\");\n        final Token expected = createTokenAndPrepareMocks(userProps, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenSucceedsEvenWithNULLBody",
        "raw_code": "@Test\n    public void createTokenSucceedsEvenWithNULLBody() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME, UserImpl.EXTERNAL_USER, \"FALSE\");\n        final Token expected = createTokenAndPrepareMocks(userProps, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "adminCanCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void adminCanCreateTokensForOtherUsers() {\n        final String adminUserName = \"admin\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, adminUserName);\n        final Token expected = createTokenAndPrepareMocks(owningUser, callingUser, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + adminUserName);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "adminCanCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void adminCanCreateTokensForOtherUsers() {\n        final String adminUserName = \"admin\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, adminUserName);\n        final Token expected = createTokenAndPrepareMocks(owningUser, callingUser, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "regularUserCannotCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void regularUserCannotCreateTokensForOtherUsers() {\n        final String otherUserName = \"Dee-Dee\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, otherUserName);\n        createTokenAndPrepareMocks(owningUser, callingUser, false);\n\n        try {\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, null));\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + otherUserName);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "regularUserCannotCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void regularUserCannotCreateTokensForOtherUsers() {\n        final String otherUserName = \"Dee-Dee\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, otherUserName);\n        createTokenAndPrepareMocks(owningUser, callingUser, false);\n\n        try {\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, null));\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenAndPrepareMocks",
        "raw_code": "private Token createTokenAndPrepareMocks(Map<String, Object> userProps, boolean allowCreateToken) {\n        final String token = \"someToken\";\n        final DateTime lastAccess = Tools.nowUTC();\n        final Map<String, Object> tokenProps = Map.of(AccessTokenImpl.NAME, TOKEN_NAME, AccessTokenImpl.TOKEN, token, AccessTokenImpl.LAST_ACCESS, lastAccess);\n        final ObjectId tokenId = new ObjectId();\n        final AccessToken accessToken = new AccessTokenImpl(tokenId, tokenProps);\n\n        prepareMocks(userProps, accessToken, allowCreateToken);\n\n        return Token.create(tokenId.toHexString(), TOKEN_NAME, token, lastAccess);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenAndPrepareMocks",
        "raw_code": "private Token createTokenAndPrepareMocks(Map<String, Object> userProps, boolean allowCreateToken) {\n        final String token = \"someToken\";\n        final DateTime lastAccess = Tools.nowUTC();\n        final Map<String, Object> tokenProps = Map.of(AccessTokenImpl.NAME, TOKEN_NAME, AccessTokenImpl.TOKEN, token, AccessTokenImpl.LAST_ACCESS, lastAccess);\n        final ObjectId tokenId = new ObjectId();\n        final AccessToken accessToken = allowCreateToken ? new AccessTokenImpl(tokenId, tokenProps) : null;\n\n        prepareMocks(userProps, accessToken, allowCreateToken);\n\n        return Token.create(tokenId.toHexString(), TOKEN_NAME, token, lastAccess);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "prepareMocks",
        "raw_code": "private void prepareMocks(Map<String, Object> userProps, AccessToken accessToken, boolean allow) {\n        final User user = userImplFactory.create(userProps);\n        when(subject.getPrincipal()).thenReturn(USERNAME);\n        when(userService.loadById(USERNAME)).thenReturn(user);\n        when(userManagementService.loadById(USERNAME)).thenReturn(user);\n        when(subject.isPermitted(USERS_TOKENCREATE + \":\" + USERNAME)).thenReturn(allow);\n        when(clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES)).thenReturn(UserConfiguration.DEFAULT_VALUES);\n        if (accessToken != null) {\n            when(accessTokenService.create(USERNAME, UsersResourceTest.TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)))).thenReturn(accessToken);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "prepareMocks",
        "raw_code": "private void prepareMocks(Map<String, Object> userProps, AccessToken accessToken, boolean allow) {\n        final User user = userImplFactory.create(userProps);\n        when(userManagementService.loadById(USERNAME)).thenReturn(user);\n        when(subject.isPermitted(USERS_TOKENCREATE + \":\" + USERNAME)).thenReturn(allow);\n        if (allow) {\n            when(clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES)).thenReturn(UserConfiguration.DEFAULT_VALUES);\n        }\n        if (accessToken != null) {\n            when(accessTokenService.create(USERNAME, UsersResourceTest.TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)))).thenReturn(accessToken);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResource.java",
        "method_name": "generateNewToken",
        "raw_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n        final User currentUser = getCurrentUser();\n\n        if (currentUser == null) {\n            throw new ForbiddenException(\"Not allowed to create tokens for unknown user.\");\n        }\n        if (!isPermitted(USERS_TOKENCREATE, currentUser.getName())) {\n            throw new ForbiddenException(currentUser.getName() + \" is not allowed to create token.\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResource.java",
        "method_name": "generateNewToken",
        "raw_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n\n        if (!isPermitted(USERS_TOKENCREATE, futureOwner.getName())) {\n            throw new ForbiddenException(\"You are not allowed to create a token for user \" + futureOwner.getName() + \".\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenFailsIfCreateNotAllowed",
        "raw_code": "@Test\n    public void createTokenFailsIfCreateNotAllowed() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME);\n        createTokenAndPrepareMocks(userProps, false);\n\n        try {\n            final UsersResource.GenerateTokenTTL ttl = new UsersResource.GenerateTokenTTL(Optional.of(PeriodDuration.of(Duration.ofDays(30))));\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, ttl));\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenFailsIfCreateNotAllowed",
        "raw_code": "@Test\n    public void createTokenFailsIfCreateNotAllowed() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME);\n        createTokenAndPrepareMocks(userProps, false);\n\n        try {\n            final UsersResource.GenerateTokenTTL ttl = new UsersResource.GenerateTokenTTL(Optional.of(PeriodDuration.of(Duration.ofDays(30))));\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, ttl));\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenSucceedsEvenWithNULLBody",
        "raw_code": "@Test\n    public void createTokenSucceedsEvenWithNULLBody() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME, UserImpl.EXTERNAL_USER, \"FALSE\");\n        final Token expected = createTokenAndPrepareMocks(userProps, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenSucceedsEvenWithNULLBody",
        "raw_code": "@Test\n    public void createTokenSucceedsEvenWithNULLBody() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME, UserImpl.EXTERNAL_USER, \"FALSE\");\n        final Token expected = createTokenAndPrepareMocks(userProps, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "adminCanCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void adminCanCreateTokensForOtherUsers() {\n        final String adminUserName = \"admin\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, adminUserName);\n        final Token expected = createTokenAndPrepareMocks(owningUser, callingUser, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + adminUserName);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "adminCanCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void adminCanCreateTokensForOtherUsers() {\n        final String adminUserName = \"admin\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, adminUserName);\n        final Token expected = createTokenAndPrepareMocks(owningUser, callingUser, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "regularUserCannotCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void regularUserCannotCreateTokensForOtherUsers() {\n        final String otherUserName = \"Dee-Dee\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, otherUserName);\n        createTokenAndPrepareMocks(owningUser, callingUser, false);\n\n        try {\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, null));\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + otherUserName);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "regularUserCannotCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void regularUserCannotCreateTokensForOtherUsers() {\n        final String otherUserName = \"Dee-Dee\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, otherUserName);\n        createTokenAndPrepareMocks(owningUser, callingUser, false);\n\n        try {\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, null));\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenAndPrepareMocks",
        "raw_code": "private Token createTokenAndPrepareMocks(Map<String, Object> userProps, boolean allowCreateToken) {\n        final String token = \"someToken\";\n        final DateTime lastAccess = Tools.nowUTC();\n        final Map<String, Object> tokenProps = Map.of(AccessTokenImpl.NAME, TOKEN_NAME, AccessTokenImpl.TOKEN, token, AccessTokenImpl.LAST_ACCESS, lastAccess);\n        final ObjectId tokenId = new ObjectId();\n        final AccessToken accessToken = new AccessTokenImpl(tokenId, tokenProps);\n\n        prepareMocks(userProps, accessToken, allowCreateToken);\n\n        return Token.create(tokenId.toHexString(), TOKEN_NAME, token, lastAccess);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenAndPrepareMocks",
        "raw_code": "private Token createTokenAndPrepareMocks(Map<String, Object> userProps, boolean allowCreateToken) {\n        final String token = \"someToken\";\n        final DateTime lastAccess = Tools.nowUTC();\n        final Map<String, Object> tokenProps = Map.of(AccessTokenImpl.NAME, TOKEN_NAME, AccessTokenImpl.TOKEN, token, AccessTokenImpl.LAST_ACCESS, lastAccess);\n        final ObjectId tokenId = new ObjectId();\n        final AccessToken accessToken = allowCreateToken ? new AccessTokenImpl(tokenId, tokenProps) : null;\n\n        prepareMocks(userProps, accessToken, allowCreateToken);\n\n        return Token.create(tokenId.toHexString(), TOKEN_NAME, token, lastAccess);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "prepareMocks",
        "raw_code": "private void prepareMocks(Map<String, Object> userProps, AccessToken accessToken, boolean allow) {\n        final User user = userImplFactory.create(userProps);\n        when(subject.getPrincipal()).thenReturn(USERNAME);\n        when(userService.loadById(USERNAME)).thenReturn(user);\n        when(userManagementService.loadById(USERNAME)).thenReturn(user);\n        when(subject.isPermitted(USERS_TOKENCREATE + \":\" + USERNAME)).thenReturn(allow);\n        when(clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES)).thenReturn(UserConfiguration.DEFAULT_VALUES);\n        if (accessToken != null) {\n            when(accessTokenService.create(USERNAME, UsersResourceTest.TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)))).thenReturn(accessToken);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "prepareMocks",
        "raw_code": "private void prepareMocks(Map<String, Object> userProps, AccessToken accessToken, boolean allow) {\n        final User user = userImplFactory.create(userProps);\n        when(userManagementService.loadById(USERNAME)).thenReturn(user);\n        when(subject.isPermitted(USERS_TOKENCREATE + \":\" + USERNAME)).thenReturn(allow);\n        if (allow) {\n            when(clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES)).thenReturn(UserConfiguration.DEFAULT_VALUES);\n        }\n        if (accessToken != null) {\n            when(accessTokenService.create(USERNAME, UsersResourceTest.TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)))).thenReturn(accessToken);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResource.java",
        "method_name": "generateNewToken",
        "raw_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n        final User currentUser = getCurrentUser();\n\n        if (currentUser == null) {\n            throw new ForbiddenException(\"Not allowed to create tokens for unknown user.\");\n        }\n        if (!isPermitted(USERS_TOKENCREATE, currentUser.getName())) {\n            throw new ForbiddenException(currentUser.getName() + \" is not allowed to create token.\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResource.java",
        "method_name": "generateNewToken",
        "raw_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n\n        if (!isPermitted(USERS_TOKENCREATE, futureOwner.getName())) {\n            throw new ForbiddenException(\"You are not allowed to create a token for user \" + futureOwner.getName() + \".\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "ContextualEmitterImpl.java",
        "method_name": "sendMessage",
        "raw_code": "@Override\n    @CheckReturnValue\n    public <M extends Message<? extends T>> Uni<Void> sendMessage(M msg) {\n        if (msg == null) {\n            throw ex.illegalArgumentForNullValue();\n        }\n\n        // If we are running on a Vert.x context, we need to capture the context to switch back\n        // during the emission.\n        Context context = Vertx.currentContext();\n        // context propagation capture and duplicate the context\n        var msgUni = Uni.createFrom().item(() -> ContextAwareMessage.withContextMetadata((Message<? extends T>) msg));\n        if (context != null) {\n            msgUni = msgUni.emitOn(r -> context.runOnContext(x -> r.run()));\n        }\n        // emit the message, skip context propagation as it is unnecessary here\n        Uni<Void> uni = transformToUni(msgUni, message -> ContextualEmitterImpl.emitter(e -> {\n            try {\n                emit(message\n                        .withAck(() -> {\n                            e.complete(null);\n                            return msg.ack();\n                        })\n                        .withNack(t -> {\n                            e.fail(t);\n                            return msg.nack(t);\n                        }));\n            } catch (Exception t) {\n                // Capture synchronous exception and nack the message.\n                msg.nack(t);\n                throw t;\n            }\n        }));\n        // switch back to the caller context\n        if (context != null) {\n            return uni.emitOn(r -> context.runOnContext(x -> r.run()));\n        } else {\n            return uni;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ContextualEmitterImpl.java",
        "method_name": "sendMessage",
        "raw_code": "@Override\n    @CheckReturnValue\n    public <M extends Message<? extends T>> Uni<Void> sendMessage(M msg) {\n        if (msg == null) {\n            throw ex.illegalArgumentForNullValue();\n        }\n\n        // If we are running on a Vert.x context, we need to capture the context to switch back\n        // during the emission.\n        Context context = Vertx.currentContext();\n        // context propagation capture and duplicate the context\n        var msgUni = Uni.createFrom().item(() -> createContextualMessage((Message<? extends T>) msg, context));\n        if (context != null) {\n            msgUni = msgUni.emitOn(r -> context.runOnContext(x -> r.run()));\n        }\n        // emit the message, skip context propagation as it is unnecessary here\n        Uni<Void> uni = transformToUni(msgUni, message -> ContextualEmitterImpl.emitter(e -> {\n            try {\n                emit(message\n                        .withAck(() -> {\n                            e.complete(null);\n                            return msg.ack();\n                        })\n                        .withNack(t -> {\n                            e.fail(t);\n                            return msg.nack(t);\n                        }));\n            } catch (Exception t) {\n                // Capture synchronous exception and nack the message.\n                msg.nack(t);\n                throw t;\n            }\n        }));\n        // switch back to the caller context\n        if (context != null) {\n            return uni.emitOn(r -> context.runOnContext(x -> r.run()));\n        } else {\n            return uni;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testNonBlocking",
        "raw_code": "@Test\n        void testNonBlocking() {\n            given().body(\"rose\").post(\"/flowers\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testNonBlocking",
        "raw_code": "@Test\n        void testNonBlocking() {\n            given().body(\"rose\").post(\"/flowers/mutiny\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testNonBlockingUni",
        "raw_code": "@Test\n        void testNonBlockingUni() {\n            given().body(\"rose\").post(\"/flowers/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testNonBlockingUni",
        "raw_code": "@Test\n        void testNonBlockingUni() {\n            given().body(\"rose\").post(\"/flowers/mutiny/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlocking",
        "raw_code": "@Test\n        void testBlocking() {\n            given().body(\"rose\").post(\"/flowers/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlocking",
        "raw_code": "@Test\n        void testBlocking() {\n            given().body(\"rose\").post(\"/flowers/mutiny/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingUni",
        "raw_code": "@Test\n        void testBlockingUni() {\n            given().body(\"rose\").post(\"/flowers/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingUni",
        "raw_code": "@Test\n        void testBlockingUni() {\n            given().body(\"rose\").post(\"/flowers/mutiny/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingNamed",
        "raw_code": "@Test\n        void testBlockingNamed() {\n            given().body(\"rose\").post(\"/flowers/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingNamed",
        "raw_code": "@Test\n        void testBlockingNamed() {\n            given().body(\"rose\").post(\"/flowers/mutiny/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingNamedUni",
        "raw_code": "@Test\n        void testBlockingNamedUni() {\n            given().body(\"rose\").post(\"/flowers/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingNamedUni",
        "raw_code": "@Test\n        void testBlockingNamedUni() {\n            given().body(\"rose\").post(\"/flowers/mutiny/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testVirtualThread",
        "raw_code": "@Test\n        @EnabledForJreRange(min = JRE.JAVA_21)\n        void testVirtualThread() {\n            given().body(\"rose\").post(\"/flowers/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testVirtualThread",
        "raw_code": "@Test\n        @EnabledForJreRange(min = JRE.JAVA_21)\n        void testVirtualThread() {\n            given().body(\"rose\").post(\"/flowers/mutiny/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testVirtualThreadUni",
        "raw_code": "@Test\n        @EnabledForJreRange(min = JRE.JAVA_21)\n        void testVirtualThreadUni() {\n            given().body(\"rose\").post(\"/flowers/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testVirtualThreadUni",
        "raw_code": "@Test\n        @EnabledForJreRange(min = JRE.JAVA_21)\n        void testVirtualThreadUni() {\n            given().body(\"rose\").post(\"/flowers/mutiny/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "testPlanExecutionStarted",
        "raw_code": "@Override\n\tpublic void testPlanExecutionStarted(TestPlan testPlan) {\n\t\tConfigurationParameters config = testPlan.getConfigurationParameters();\n\t\tif (isEnabled(config)) {\n\t\t\tNamespaceRegistry namespaceRegistry = NamespaceRegistry.builder(Namespace.REPORTING_CORE) //\n\t\t\t\t\t.add(\"e\", Namespace.REPORTING_EVENTS) //\n\t\t\t\t\t.add(\"git\", Namespace.REPORTING_GIT) //\n\t\t\t\t\t.add(\"java\", Namespace.REPORTING_JAVA) //\n\t\t\t\t\t.add(\"junit\", JUnitFactory.NAMESPACE, \"https://schemas.junit.org/open-test-reporting/junit-1.9.xsd\") //\n\t\t\t\t\t.build();\n\t\t\toutputDir = testPlan.getOutputDirectoryProvider().getRootDirectory();\n\t\t\tPath eventsXml = outputDir.resolve(\"open-test-report.xml\");\n\t\t\ttry {\n\t\t\t\teventsFileWriter = Events.createDocumentWriter(namespaceRegistry, eventsXml);\n\t\t\t\treportInfrastructure();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new JUnitException(\"Failed to initialize XML events file: \" + eventsXml, e);\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "testPlanExecutionStarted",
        "raw_code": "@Override\n\tpublic void testPlanExecutionStarted(TestPlan testPlan) {\n\t\tConfigurationParameters config = testPlan.getConfigurationParameters();\n\t\tif (isEnabled(config)) {\n\t\t\tNamespaceRegistry namespaceRegistry = NamespaceRegistry.builder(Namespace.REPORTING_CORE) //\n\t\t\t\t\t.add(\"e\", Namespace.REPORTING_EVENTS) //\n\t\t\t\t\t.add(\"git\", Namespace.REPORTING_GIT) //\n\t\t\t\t\t.add(\"java\", Namespace.REPORTING_JAVA) //\n\t\t\t\t\t.add(\"junit\", JUnitFactory.NAMESPACE, \"https://schemas.junit.org/open-test-reporting/junit-1.9.xsd\") //\n\t\t\t\t\t.build();\n\t\t\toutputDir = testPlan.getOutputDirectoryProvider().getRootDirectory();\n\t\t\tPath eventsXml = outputDir.resolve(\"open-test-report.xml\");\n\t\t\ttry {\n\t\t\t\teventsFileWriter = Events.createDocumentWriter(namespaceRegistry, eventsXml);\n\t\t\t\treportInfrastructure(config);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new JUnitException(\"Failed to initialize XML events file: \" + eventsXml, e);\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "isEnabled",
        "raw_code": "private Boolean isEnabled(ConfigurationParameters config) {\n\t\treturn config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "isEnabled",
        "raw_code": "private boolean isEnabled(ConfigurationParameters config) {\n\t\treturn config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "reportInfrastructure",
        "raw_code": "private void reportInfrastructure() {\n\t\teventsFileWriter.append(infrastructure(), infrastructure -> {\n\t\t\ttry {\n\t\t\t\tString hostName = InetAddress.getLocalHost().getHostName();\n\t\t\t\tinfrastructure.append(hostName(hostName));\n\t\t\t}\n\t\t\tcatch (UnknownHostException ignored) {\n\t\t\t}\n\t\t\tinfrastructure //\n\t\t\t\t\t.append(userName(System.getProperty(\"user.name\"))) //\n\t\t\t\t\t.append(operatingSystem(System.getProperty(\"os.name\"))) //\n\t\t\t\t\t.append(cpuCores(Runtime.getRuntime().availableProcessors())) //\n\t\t\t\t\t.append(javaVersion(System.getProperty(\"java.version\"))) //\n\t\t\t\t\t.append(fileEncoding(System.getProperty(\"file.encoding\"))) //\n\t\t\t\t\t.append(heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));\n\n\t\t\taddGitInfo(infrastructure);\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "reportInfrastructure",
        "raw_code": "private void reportInfrastructure(ConfigurationParameters config) {\n\t\teventsFileWriter.append(infrastructure(), infrastructure -> {\n\t\t\ttry {\n\t\t\t\tString hostName = InetAddress.getLocalHost().getHostName();\n\t\t\t\tinfrastructure.append(hostName(hostName));\n\t\t\t}\n\t\t\tcatch (UnknownHostException ignored) {\n\t\t\t}\n\t\t\tinfrastructure //\n\t\t\t\t\t.append(userName(System.getProperty(\"user.name\"))) //\n\t\t\t\t\t.append(operatingSystem(System.getProperty(\"os.name\"))) //\n\t\t\t\t\t.append(cpuCores(Runtime.getRuntime().availableProcessors())) //\n\t\t\t\t\t.append(javaVersion(System.getProperty(\"java.version\"))) //\n\t\t\t\t\t.append(fileEncoding(System.getProperty(\"file.encoding\"))) //\n\t\t\t\t\t.append(heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));\n\n\t\t\tif (isGitEnabled(config)) {\n\t\t\t\tGitInfoCollector.get(workingDir).ifPresent(git -> addGitInfo(infrastructure, git));\n\t\t\t}\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "addGitInfo",
        "raw_code": "private void addGitInfo(Infrastructure infrastructure) {\n\t\tboolean gitInstalled = exec(\"git\", \"--version\").isPresent();\n\t\tif (gitInstalled) {\n\t\t\texec(\"git\", \"config\", \"--get\", \"remote.origin.url\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(\n\t\t\t\t\t\tgitUrl -> infrastructure.append(repository(), repository -> repository.withOriginUrl(gitUrl)));\n\t\t\texec(\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(branch -> infrastructure.append(branch(branch)));\n\t\t\texec(\"git\", \"rev-parse\", \"--verify\", \"HEAD\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(gitCommitHash -> infrastructure.append(commit(gitCommitHash)));\n\t\t\texec(\"git\", \"status\", \"--porcelain\") //\n\t\t\t\t\t.ifPresent(statusOutput -> infrastructure.append(status(statusOutput),\n\t\t\t\t\t\tstatus -> status.withClean(statusOutput.isEmpty())));\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "addGitInfo",
        "raw_code": "private void addGitInfo(Infrastructure infrastructure, GitInfoCollector git) {\n\t\tgit.getOriginUrl() //\n\t\t\t\t.ifPresent(\n\t\t\t\t\tgitUrl -> infrastructure.append(repository(), repository -> repository.withOriginUrl(gitUrl)));\n\t\tgit.getBranch() //\n\t\t\t\t.ifPresent(branch -> infrastructure.append(branch(branch)));\n\t\tgit.getCommitHash() //\n\t\t\t\t.ifPresent(gitCommitHash -> infrastructure.append(commit(gitCommitHash)));\n\t\tgit.getStatus() //\n\t\t\t\t.ifPresent(statusOutput -> infrastructure.append(status(statusOutput),\n\t\t\t\t\tstatus -> status.withClean(statusOutput.isEmpty())));\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListenerTests.java",
        "method_name": "executeTests",
        "raw_code": "private void executeTests(Path tempDirectory, TestEngine engine, Path outputDir) {\n\t\tvar build = request() //\n\t\t\t\t.selectors(selectUniqueId(UniqueId.forEngine(engine.getId()))) //\n\t\t\t\t.configurationParameter(ENABLED_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(CAPTURE_STDOUT_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(CAPTURE_STDERR_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(OUTPUT_DIR_PROPERTY_NAME, outputDir.toString()) //\n\t\t\t\t.build();\n\t\tcreateLauncher(engine).execute(build, new OpenTestReportGeneratingListener(tempDirectory));\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListenerTests.java",
        "method_name": "executeTests",
        "raw_code": "private static void executeTests(Path tempDirectory, TestEngine engine, Path outputDir,\n\t\t\tMap<String, String> extraConfigurationParameters) {\n\t\tvar request = request() //\n\t\t\t\t.selectors(selectUniqueId(UniqueId.forEngine(engine.getId()))) //\n\t\t\t\t.enableImplicitConfigurationParameters(false) //\n\t\t\t\t.configurationParameter(ENABLED_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(CAPTURE_STDOUT_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(CAPTURE_STDERR_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(OUTPUT_DIR_PROPERTY_NAME, outputDir.toString()) //\n\t\t\t\t.configurationParameters(extraConfigurationParameters) //\n\t\t\t\t.build();\n\t\tcreateLauncher(engine).execute(request, new OpenTestReportGeneratingListener(tempDirectory));\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "d1ee57e7b826872b6355cfec0ae13465840e232c",
    "short_hash": "d1ee57e7",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "31e8a3bfcf4e223788615d5ce25eb929ca251275",
    "short_hash": "31e8a3bf",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "esapi-java-legacy",
    "cve_id": "CVE-2025-5878",
    "cwe_list": [
      "CWE-138"
    ],
    "commit_hash": "f75ac2c2647a81d2cfbdc9c899f8719c240ed512",
    "short_hash": "f75ac2c2",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultEncoder.java",
        "method_name": "encodeForSQL",
        "raw_code": "public String encodeForSQL(Codec codec, String input) {\n        if( input == null ) {\n            return null;\n        }\n        return codec.encode(IMMUNE_SQL, input);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultEncoder.java",
        "method_name": "encodeForSQL",
        "raw_code": "@Deprecated\n    public String encodeForSQL(Codec codec, String input) {\n\n        // This will throw if this method is not explicitly enabled in ESAPI.properties.\n        ensureDangerousMethodExplicitlyEnabled( DefaultEncoder.class.getName() + \".encodeForSQL\",\n                                                \"<default>\",\n                                                \"see CVE-2025-5878 and ESAPI Security Bulletin #13 for details\" );\n\n        if( input == null ) {\n            return null;\n        }\n        return codec.encode(IMMUNE_SQL, input);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "esapi-java-legacy",
    "cve_id": "CVE-2025-5878",
    "cwe_list": [
      "CWE-138"
    ],
    "commit_hash": "f75ac2c2647a81d2cfbdc9c899f8719c240ed512",
    "short_hash": "f75ac2c2",
    "vulnerableMethods_before": [
      {
        "filename": "Encoder.java",
        "method_name": "encodeForSQL",
        "raw_code": "String encodeForSQL(Codec codec, String input);",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Encoder.java",
        "method_name": "encodeForSQL",
        "raw_code": "@Deprecated\n     String encodeForSQL(Codec codec, String input);",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jeesite5",
    "cve_id": "CVE-2025-7759",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "1c5e49b0818037452148e0f8ff69ed04cb8fefdc",
    "short_hash": "1c5e49b0",
    "vulnerableMethods_before": [
      {
        "filename": "FileTempleteUtils.java",
        "method_name": "getFileTempleteByResource",
        "raw_code": "public static FileTemplete getFileTempleteByResource(String fileName) throws IOException {\n\t\tResource resource = ResourceUtils.getResource(fileName);\n\t\treturn new FileTemplete(resource, fileName);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileTempleteUtils.java",
        "method_name": "getFileTempleteByResource",
        "raw_code": "public static FileTemplete getFileTempleteByResource(String fileName) {\n\t\tif (!StringUtils.startsWith(fileName, \"views/modules/cmsfront\")) {\n\t\t\tfileName = \"views/modules/cmsfront/themes/default/index.html\";\n\t\t}\n\t\tResource resource = ResourceUtils.getResource(fileName);\n\t\treturn new FileTemplete(resource, fileName);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jeesite5",
    "cve_id": "CVE-2025-7759",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "1c5e49b0818037452148e0f8ff69ed04cb8fefdc",
    "short_hash": "1c5e49b0",
    "vulnerableMethods_before": [
      {
        "filename": "ActionEnter.java",
        "method_name": "invoke",
        "raw_code": "public String invoke() {\n        if (actionType == null || !ActionMap.mapping.containsKey(actionType)) {\n            return new BaseState(false, AppInfo.INVALID_ACTION).toJSONString();\n        }\n        if (this.configManager == null || !this.configManager.valid()) {\n            return new BaseState(false, AppInfo.CONFIG_ERROR).toJSONString();\n        }\n        State state = null;\n        int actionCode = ActionMap.getType(this.actionType);\n        Map<String, Object> conf = null;\n        switch (actionCode) {\n            case ActionMap.CONFIG:\n                return this.configManager.getAllConfig().toString();\n            case ActionMap.UPLOAD_IMAGE:\n            case ActionMap.UPLOAD_SCRAWL:\n            case ActionMap.UPLOAD_VIDEO:\n            case ActionMap.UPLOAD_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"\");\n                    break;\n                }\n                conf = this.configManager.getConfig(actionCode);\n                state = new Uploader(request, conf).doExec();\n                break;\n            case ActionMap.CATCH_IMAGE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                String[] list = this.request.getParameterValues((String) conf.get(\"fieldName\"));\n                state = new ImageHunter(request, conf).capture(list);\n                break;\n            case ActionMap.LIST_IMAGE:\n            case ActionMap.LIST_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                int start = this.getStartIndex();\n                state = new FileManager(conf).listFile(this.request, start);\n                break;\n        }\n        return state.toJSONString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ActionEnter.java",
        "method_name": "invoke",
        "raw_code": "public String invoke() {\n        if (actionType == null || !ActionMap.mapping.containsKey(actionType)) {\n            return new BaseState(false, AppInfo.INVALID_ACTION).toJSONString();\n        }\n        if (this.configManager == null || !this.configManager.valid()) {\n            return new BaseState(false, AppInfo.CONFIG_ERROR).toJSONString();\n        }\n        State state = null;\n        int actionCode = ActionMap.getType(this.actionType);\n        Map<String, Object> conf = null;\n        switch (actionCode) {\n            case ActionMap.CONFIG:\n                return this.configManager.getAllConfig().toString();\n            case ActionMap.UPLOAD_IMAGE:\n            case ActionMap.UPLOAD_SCRAWL:\n            case ActionMap.UPLOAD_VIDEO:\n            case ActionMap.UPLOAD_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"\");\n                    break;\n                }\n                conf = this.configManager.getConfig(actionCode);\n                state = new Uploader(request, conf).doExec();\n                break;\n            case ActionMap.CATCH_IMAGE:\n//                if (Global.isDemoMode()) {\n//                    state = new BaseState(false, \"\");\n//                    break;\n//                }\n//                conf = configManager.getConfig(actionCode);\n//                String[] list = this.request.getParameterValues((String) conf.get(\"fieldName\"));\n//                state = new ImageHunter(request, conf).capture(list);\n\t\t\t\tstate = new BaseState(false, \"\");\n                break;\n            case ActionMap.LIST_IMAGE:\n            case ActionMap.LIST_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                int start = this.getStartIndex();\n                state = new FileManager(conf).listFile(this.request, start);\n                break;\n        }\n        return state.toJSONString();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jeesite5",
    "cve_id": "CVE-2025-7864",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "3585737d21fe490ff6948d913fcbd8d99c41fc08",
    "short_hash": "3585737d",
    "vulnerableMethods_before": [
      {
        "filename": "EncodeUtilsTest.java",
        "method_name": "main",
        "raw_code": "public static void main(String[] args) {\n\t\tEncodeUtils.xssFilter(\"1  <script>alert(document.cookie)</script>\");\n\t\tEncodeUtils.xssFilter(\"2  <strong></strong>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->3  \\\"><strong></strong>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->4  <iframe src=\\\"abcdef\\\"></iframe><strong></strong>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->5  <iframe src=\\\"abcdef\\\"/><strong></strong>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->6  <iframe src=\\\"abcdef\\\"><strong></strong>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->7  <script type=\\\"text/javascript\\\">alert(document.cookie)</script>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->8  <script\\n type=\\\"text/javascript\\\">\\nalert(document.cookie)\\n</script>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->9  <script src='' onerror='alert(document.cookie)'></script>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->10  <script type=text/javascript>alert()\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->11  <script>alert(document.cookie)</script>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->12  <script>window.location='url'\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->13  </script></iframe>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->14  eval(abc)\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->15  expression(abc)\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->16  <img src='abc.jpg' onerror='location='';alert(document.cookie);'></img>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->17  <img src='abc.jpg' onerror='alert(document.cookie);'/>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->18  <img src='abc.jpg' onerror='alert(document.cookie);'>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->19  <a onload='alert(\\\"abc\\\")'>hello</a>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->20  <a href=\\\"/abc\\\">hello</a>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->21  <a href='/abc'>hello</a>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->22  <a href='vbscript:alert(\\\"abc\\\");'>hello</a>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->23  <a href='javascript:alert(\\\"abc\\\");'>hello</a>\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->24  ?abc=def&hello=123&world={\\\"a\\\":1}\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->25  ?abc=def&hello=123&world={'a':1}\");\n\t\tEncodeUtils.sqlFilter(\"1  select * from xxx where abc=def and 1=1\");\n\t\tEncodeUtils.sqlFilter(\"2  insert into xxx values(1,2,3,4,5)\");\n\t\tEncodeUtils.sqlFilter(\"3  delete from xxx\");\n\t\tEncodeUtils.sqlFilter(\"4 a.audit_result asc,case when 1 like case when length(database())=6 then 1 else exp(111) end then 1 else 1/0 end\", \"orderBy\");\n\t\tEncodeUtils.sqlFilter(\"5 if(1=2,1,SLEEP(10)), if(mid(database(),{},1)=\\\\\\\"{}\\\\\\\",a.id,a.login_name)\", \"orderBy\");\n\t\tEncodeUtils.sqlFilter(\"6 a.audit_result asc, b.audit_result2 desc, b.AuditResult3 desc\", \"orderBy\");\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "EncodeUtilsTest.java",
        "method_name": "main",
        "raw_code": "public static void main(String[] args) {\n\t\tint i = 0;\n\t\txssFilter(i++, \" <script>alert(document.cookie)</script>\");\n\t\txssFilter(i++, \" <strong></strong>\");\n\t\txssFilter(i++, \"<!--HTML--> \\\"><strong></strong>\");\n\t\txssFilter(i++, \"<!--HTML--> <iframe src=\\\"abcdef\\\"></iframe><strong></strong>\");\n\t\txssFilter(i++, \"<!--HTML--> <iframe src=\\\"abcdef\\\"/><strong></strong>\");\n\t\txssFilter(i++, \"<!--HTML--> <iframe src=\\\"abcdef\\\"><strong></strong>\");\n\t\txssFilter(i++, \"<!--HTML--> <script type=\\\"text/javascript\\\">alert(document.cookie)</script>\");\n\t\txssFilter(i++, \"<!--HTML--> <script\\n type=\\\"text/javascript\\\">\\nalert(document.cookie)\\n</script>\");\n\t\txssFilter(i++, \"<!--HTML--> <script src='' onerror='alert(document.cookie)'></script>\");\n\t\txssFilter(i++, \"<!--HTML--> <script type=text/javascript>alert()\");\n\t\txssFilter(i++, \"<!--HTML--> <script>alert(document.cookie)</script>\");\n\t\txssFilter(i++, \"<!--HTML--> <script>window.location='url'\");\n\t\txssFilter(i++, \"<!--HTML--> </script></iframe>\");\n\t\txssFilter(i++, \"<!--HTML--> eval(abc)\");\n\t\txssFilter(i++, \"<!--HTML--> expression(abc)\");\n\t\txssFilter(i++, \"<!--HTML--> <img src='abc.jpg' onerror='location='';alert(document.cookie);'></img>\");\n\t\txssFilter(i++, \"<!--HTML--> <img src='abc.jpg' onerror='alert(document.cookie);'/>\");\n\t\txssFilter(i++, \"<!--HTML--> <img src='abc.jpg' onerror='alert(document.cookie);'>\");\n\t\txssFilter(i++, \"<!--HTML--> <a onload='alert(\\\"abc\\\")'>hello</a>\");\n\t\txssFilter(i++, \"<!--HTML--> <a href=\\\"/abc\\\">hello</a>\");\n\t\txssFilter(i++, \"<!--HTML--> <a href='/abc'>hello</a>\");\n\t\txssFilter(i++, \"<!--HTML--> <a href='vbscript:alert(\\\"abc\\\");'>hello</a>\");\n\t\txssFilter(i++, \"<!--HTML--> <a href='javascript:alert(\\\"abc\\\");'>hello</a>\");\n\t\txssFilter(i++, \"<!--HTML--> ?abc=def&hello=123&world={\\\"a\\\":1}\");\n\t\txssFilter(i++, \"<!--HTML--> ?abc=def&hello=123&world={'a':1}\");\n\t\txssFilter(i++, \"<!--HTML-->\\\"><svg/ONLOAD=confirm(3) />\");\n\t\tsqlFilter(i++, \" select * from xxx where abc=def and 1=1\", \"common\");\n\t\tsqlFilter(i++, \" insert into xxx values(1,2,3,4,5)\", \"common\");\n\t\tsqlFilter(i++, \" delete from xxx\", \"common\");\n\t\tsqlFilter(i++, \"a.audit_result asc,case when 1 like case when length(database())=6 then 1 else exp(111) end then 1 else 1/0 end\", \"orderBy\");\n\t\tsqlFilter(i++, \"if(1=2,1,SLEEP(10)), if(mid(database(),{},1)=\\\\\\\"{}\\\\\\\",a.id,a.login_name)\", \"orderBy\");\n\t\tsqlFilter(i++, \"a.audit_result asc, b.audit_result2 desc, b.AuditResult3 desc\", \"orderBy\");\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  }
]