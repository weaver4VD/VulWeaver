{
  "CVE-2016-6296_before_exclude_100:e9bd78bf:vulspec": {
    "timestamp": "2026-01-15T19:16:44.375475",
    "cve_id": "CVE-2016-6296",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e9bd78bf",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2019-19054_before_exclude_100:ce59bd52:vulspec": {
    "timestamp": "2026-01-15T19:16:44.389067",
    "cve_id": "CVE-2019-19054",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ce59bd52",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      }
    ]
  },
  "CVE-2022-0617_before_exclude_100:bdc389bc:vulspec": {
    "timestamp": "2026-01-15T19:16:44.391409",
    "cve_id": "CVE-2022-0617",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bdc389bc",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      }
    ]
  },
  "CVE-2019-19054_after_exclude_100:9c94c0dc:vulspec": {
    "timestamp": "2026-01-15T19:16:44.396025",
    "cve_id": "CVE-2019-19054",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9c94c0dc",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      }
    ]
  },
  "CVE-2016-6296_after_exclude_100:de0ced32:vulspec": {
    "timestamp": "2026-01-15T19:16:44.400653",
    "cve_id": "CVE-2016-6296",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "de0ced32",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2022-0617_after_exclude_100:e95e560b:vulspec": {
    "timestamp": "2026-01-15T19:16:44.412379",
    "cve_id": "CVE-2022-0617",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e95e560b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      }
    ]
  },
  "CVE-2022-34835_after_exclude_100:db90bcaf:vulspec": {
    "timestamp": "2026-01-15T19:16:44.421271",
    "cve_id": "CVE-2022-34835",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "db90bcaf",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      }
    ]
  },
  "CVE-2022-34835_before_exclude_100:d4fc605f:vulspec": {
    "timestamp": "2026-01-15T19:16:44.426652",
    "cve_id": "CVE-2022-34835",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d4fc605f",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      }
    ]
  },
  "CVE-2020-16166_before_exclude_100:f76bbbf0:vulspec": {
    "timestamp": "2026-01-15T19:16:44.433726",
    "cve_id": "CVE-2020-16166",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f76bbbf0",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2019-18874"
        }
      }
    ]
  },
  "CVE-2020-16166_after_exclude_100:14264f78:vulspec": {
    "timestamp": "2026-01-15T19:16:44.439490",
    "cve_id": "CVE-2020-16166",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "14264f78",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2019-18874"
        }
      }
    ]
  },
  "CVE-2022-26878_before_exclude_100:cf94634a:vulspec": {
    "timestamp": "2026-01-16T21:17:50.243454",
    "cve_id": "CVE-2022-26878",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cf94634a",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14466"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-16227"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-13044"
        }
      }
    ]
  },
  "CVE-2022-3078_before_exclude_100:d88bf678:vulspec": {
    "timestamp": "2026-01-16T21:17:50.251795",
    "cve_id": "CVE-2022-3078",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d88bf678",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-5576"
        }
      }
    ]
  },
  "CVE-2022-26878_after_exclude_100:f99047cc:vulspec": {
    "timestamp": "2026-01-16T21:17:50.292980",
    "cve_id": "CVE-2022-26878",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f99047cc",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14466"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-16227"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-13044"
        }
      }
    ]
  },
  "CVE-2018-16842_after_exclude_100:65357456:vulspec": {
    "timestamp": "2026-01-16T21:17:50.312513",
    "cve_id": "CVE-2018-16842",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "65357456",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2021-46784_before_exclude_100:10461dfe:vulspec": {
    "timestamp": "2026-01-16T21:17:50.323577",
    "cve_id": "CVE-2021-46784",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "10461dfe",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-3078_after_exclude_100:41aa8552:vulspec": {
    "timestamp": "2026-01-16T21:17:50.357834",
    "cve_id": "CVE-2022-3078",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "41aa8552",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-5576"
        }
      }
    ]
  },
  "CVE-2018-16842_before_exclude_100:8498ebe7:vulspec": {
    "timestamp": "2026-01-16T21:17:50.362146",
    "cve_id": "CVE-2018-16842",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8498ebe7",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2021-46784_after_exclude_100:376a1407:vulspec": {
    "timestamp": "2026-01-16T21:17:50.383693",
    "cve_id": "CVE-2021-46784",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "376a1407",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-33099_before_exclude_100:11b9a4d8:vulspec": {
    "timestamp": "2026-01-16T21:17:50.404336",
    "cve_id": "CVE-2022-33099",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "11b9a4d8",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2022-33099_after_exclude_100:d7b23f89:vulspec": {
    "timestamp": "2026-01-16T21:17:50.439660",
    "cve_id": "CVE-2022-33099",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d7b23f89",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2021-3416_after_exclude_100:978ae066:vulspec": {
    "timestamp": "2026-01-16T21:22:20.501228",
    "cve_id": "CVE-2021-3416",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "978ae066",
    "scores": [
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a network packet send/receive function in a QEMU network device emulator (e1000). VulSpec case is about a buffer over-read in Perl's regular expression compiler. Different domain, language, vulnerability type, and trigger conditions.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a simple packet forwarding function. VulSpec case is an integer overflow leading to heap corruption in a VNC file transfer protocol. Different domain, protocol, and vulnerability mechanism. No complex integer handling or memory allocation in target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code handles Ethernet frames in a virtual device. VulSpec case is a buffer overflow in an IPv6 router advertisement daemon parser. Different network layer, protocol, and vulnerability context. Target code does not parse complex protocol options.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both involve kernel/driver-level code and data transmission, but domains are entirely different (network vs USB/IP). The vulnerability type (NULL pointer dereference) is not apparent in the provided target code, which performs straightforward operations with no complex pointer validation shown.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a network device emulation function. VulSpec case is a buffer overflow in the FUSE filesystem's ioctl handling. Different subsystem (networking vs filesystem), interface, and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both are device driver/emulation code within the I/O subsystem. However, the target code is for a virtual PCI network device, while the VulSpec is for a physical USB serial driver. The specific vulnerability (NULL pointer dereference from missing endpoint validation) is not mirrored in the simple, linear target function.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Both involve processing network data. However, the target code is a transmitter in an emulated hardware device, while the VulSpec case is a parser in a packet analysis tool. The vulnerability (out-of-bounds read due to missing length check) is not evident in the target code, which receives a size parameter and passes it directly to send/receive functions.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is for Ethernet. VulSpec case is for the NFC wireless protocol stack. Different physical/link layer technology, protocol, and attack surface. The buffer overflow vulnerability stems from parsing variable-length fields, which the target code does not do.",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a simple, likely non-reentrant device emulation function. VulSpec case is a race condition in a filesystem's node ID allocator. Different domain (networking vs filesystem), concurrency model, and vulnerability class.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is kernel/QEMU emulation code for network transmission. VulSpec case is a double-free in a userspace library for inspecting disk images. Different environment, language (C vs likely C++), and memory management context.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2021-3416_before_exclude_100:ebca20a0:vulspec": {
    "timestamp": "2026-01-16T21:22:21.440390",
    "cve_id": "CVE-2021-3416",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ebca20a0",
    "scores": [
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a network packet transmission function in a QEMU network device emulator (e1000). VulSpec case is about a buffer over-read in Perl's regular expression compiler. Different domain, language, functionality, and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code sends packets; no complex integer calculations, memory allocation, or file transfer logic. VulSpec case is an integer overflow leading to heap corruption in a VNC file transfer protocol. Completely different context and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. Target code handles outgoing Ethernet frames in an emulated NIC. VulSpec case is a buffer overflow in an IPv6 router advertisement daemon parser. Different network layer (L2 vs L3), protocol, role (sender vs receiver), and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve system/device emulation/virtualization (USB/IP vs QEMU NIC). Both process data blocks for transmission. However, the vulnerability type differs significantly: VulSpec is a NULL pointer dereference due to insufficient validation of incoming URB fields, while the target code is a straightforward transmit function with no obvious pointer validation flaws in the shown snippet. The attack surface (network protocol) is superficially similar but the specific flaw is not.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. Target code is kernel/QEMU device model transmit path. VulSpec case is a buffer overflow in FUSE userspace filesystem ioctl handling. Different subsystem (filesystem vs networking), interface (ioctl vs packet TX), and vulnerability context.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Both are related to device drivers/emulation (USB serial vs emulated NIC). However, the vulnerability is a NULL pointer dereference during USB endpoint descriptor validation in a physical driver. The target code shows no similar descriptor parsing or validation logic; it's a simple data transmission function.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. Target code transmits packets. VulSpec case is an out-of-bounds read in a packet *dissector* (tcpdump). Opposite direction of processing (creation/transmission vs parsing/analysis). Different functionality and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. Target code is for Ethernet. VulSpec case is a buffer overflow in an NFC protocol frame parser. Different wireless technology, protocol stack layer, and code purpose (sender vs receiver/parser).",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. Target code is a simple, non-concurrent packet send function. VulSpec case is a complex race condition in a filesystem's node ID allocator. Different domain (networking vs filesystem), concurrency model, and vulnerability class.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. Target code has no dynamic memory allocation or freeing in the shown snippet. VulSpec case is a double-free in a library inspecting disk image files. Different functionality, memory management patterns, and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2017-5897_before_exclude_100:0d2019ac:vulspec": {
    "timestamp": "2026-01-16T21:22:22.143750",
    "cve_id": "CVE-2017-5897",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0d2019ac",
    "scores": [
      {
        "score": 2,
        "reasoning": "Low relevance. Target code is Linux kernel IPv6 GRE tunnel error handling, while CVE-2010-4650 is in FUSE filesystem ioctl. Different subsystems (networking vs filesystem), different vulnerability patterns (buffer overflow in FUSE vs potential bounds checking in networking).",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 is in LibVNC's file transfer handling involving integer overflow leading to OOB write. Target code processes ICMPv6 error messages for tunnels. Both involve network protocols but at different layers (application VNC vs kernel IP tunneling) with different vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 is tcpdump parser OOB read due to insufficient length validation. Target code also parses network packets (ICMPv6/GRE) and has length checks (pskb_may_pull). Both involve protocol parsing but target is kernel implementation with different security context and data validation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-16914 is USB/IP NULL pointer dereference from malformed USB requests. Target code handles IPv6/GRE tunnel errors. Different subsystems (USB vs IP networking), different vulnerability patterns (NULL dereference vs potential bounds/state issues).",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3137 is USB serial driver NULL dereference from missing endpoint validation. Target code is network tunnel error handler. Different device types (USB serial vs network tunnel), different vulnerability patterns (hardware descriptor validation vs network packet processing).",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2013-0310 is kernel CIPSO NULL dereference in setsockopt path. Target code also kernel networking code. Both involve IP packet processing and potential NULL pointer issues, but different contexts (socket options vs tunnel error handling) and different attack surfaces.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-25040 is DNS resolver infinite loop from compression pointer cycles. Target code processes ICMPv6 errors with no recursive parsing. Different protocols (DNS vs ICMPv6/GRE), different vulnerability patterns (infinite loop vs buffer bounds).",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13053 is tcpdump OOB read in BGP parsing. Target code also parses network packets with offset calculations. Both involve careful bounds checking of protocol fields, but target is kernel implementation with different memory safety guarantees and attack surfaces.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-25034 is DNS resolver integer overflow leading to OOB write. Target code has arithmetic (grehlen calculations) but no complex length calculations that could overflow. Different domains (application DNS vs kernel IP tunneling).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-16913 is USB/IP buffer overflow from missing input validation. Target code validates input with pskb_may_pull. Both involve network-provided data validation but different subsystems (USB over IP vs native IP tunneling) and different vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      }
    ]
  },
  "CVE-2017-5897_after_exclude_100:e48373a5:vulspec": {
    "timestamp": "2026-01-16T21:22:23.559495",
    "cve_id": "CVE-2017-5897",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e48373a5",
    "scores": [
      {
        "score": 2,
        "reasoning": "Low relevance. Target code is Linux kernel IPv6 GRE tunnel error handling, while CVE-2010-4650 is in the FUSE filesystem's ioctl handling. Different subsystems (networking vs. filesystem), different vulnerability patterns (buffer overflow in userspace interaction vs. ICMP packet parsing).",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Target code is kernel network protocol parsing, while CVE-2018-20750 is in a userspace VNC library's file transfer handling. Different environments (kernel vs. userspace), different vulnerability chains (integer overflow leading to heap corruption vs. network packet validation).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve network protocol parsing with potential bounds checking issues. CVE-2018-14461 is an out-of-bounds read in tcpdump's LDP parser, while target code parses GRE/ICMPv6 headers. Similar pattern: parsing variable-length headers with length fields. However, target code uses pskb_may_pull() for validation, which is a safer pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are Linux kernel subsystems handling network protocols (USB/IP vs. IPv6 GRE). CVE-2017-16914 involves NULL pointer dereference from malformed network data, similar to how target code processes ICMPv6 error packets. However, the specific vulnerability patterns differ significantly (USB request validation vs. ICMP error handling).",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3137 is a USB driver NULL pointer dereference during device initialization, while target code is network protocol error handling. Different subsystems (USB serial vs. IPv6 networking), different attack surfaces (physical USB vs. network packets).",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both are Linux kernel networking subsystems (CIPSO/IPv4 vs. IPv6 GRE). CVE-2013-0310 involves NULL pointer dereference in setsockopt() path, while target code could potentially have NULL pointer issues if skb->dev is NULL. However, target code appears to have proper device context from tunnel lookup.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-25040 is a DNS parser infinite loop vulnerability in userspace, while target code is kernel ICMPv6 error handling. Different protocols, different environments, different vulnerability patterns (compression pointer loops vs. packet validation).",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve network protocol parsing with bounds checking concerns. CVE-2017-13053 is an out-of-bounds read in tcpdump's BGP parser, similar to how target code parses GRE headers with variable-length options. Target code uses pskb_may_pull() which provides some protection, but similar pattern of parsing based on flags.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-25034 is an integer overflow in DNS name parsing in userspace, while target code is kernel network error handling. Different environments, different vulnerability patterns (integer overflow leading to buffer overflow vs. packet validation).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are Linux kernel subsystems handling network protocols. CVE-2017-16913 involves memory allocation issues in USB/IP, while target code processes ICMPv6 errors. Some similarity in network packet validation concerns, but different vulnerability patterns (memory allocation vs. header parsing).",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      }
    ]
  },
  "CVE-2022-23589_before_exclude_100:e6ea5e07:vulspec": {
    "timestamp": "2026-01-16T21:22:26.316604",
    "cve_id": "CVE-2022-23589",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e6ea5e07",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a graph optimization pass in a machine learning framework (likely TensorFlow) performing algebraic simplification. The vulnerability case is an out-of-bounds read in a Perl regex compiler due to improper NUL byte handling. The domains (ML compiler vs. text parsing), vulnerability types (logic/transformation bug vs. memory safety), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs safe graph node manipulation with multiple validation checks. The vulnerability case is an out-of-bounds read in a network protocol parser due to insufficient length validation. The domains (ML graph optimization vs. network packet dissection) and core vulnerability mechanisms (missing bounds check vs. logic transformation safety) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-13035"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse untrusted input strings or perform memory copies that could overflow. It manipulates node structures within a known graph. The vulnerability case is a stack buffer overflow in a Bluetooth configuration parser. The attack surfaces (internal graph vs. external file/CLI) and defect patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The only tangential similarity is that both codes are part of optimization subsystems (query planner vs. graph optimizer). However, the vulnerability type is completely different: CWE-284 (Improper Access Control) involving privilege checks in a database vs. a potential logic flaw in a graph transformation. The target code's safety checks focus on graph structure, not authorization.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The target code performs mathematical optimization (pushing multiplication into a convolution). The vulnerability case is a side-channel attack in a cryptographic library. The similarity is limited to both performing mathematical transformations, but the security context (constant-time requirements vs. functional correctness) and defect nature (information leakage vs. logic error) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The vulnerability involves resource management errors due to inconsistent state tracking. The target code also manages resources (graph nodes) and must maintain consistent state in `node_map_`. A flawed transformation could leave the graph in an inconsistent state, potentially causing crashes or incorrect results later. However, the specific mechanism (memory allocation tracking vs. graph node reference updating) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code transforms a computational graph. The vulnerability case is in a YANG model parser. Both process structured data, but the target code's data (graph nodes) is internal and validated, whereas the parser handles external, untrusted input. The vulnerability patterns (parsing errors vs. transformation logic bugs) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Similar to case 2, this is an out-of-bounds read in a network protocol parser. The target code does not parse byte streams or have buffer boundaries; it operates on an in-memory graph structure with object references. The domains and vulnerability root causes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The vulnerability involves a NULL pointer dereference due to an invalid stack state (unmatched push/pop). The target code manipulates a graph and must ensure the integrity of node mappings and dependencies. If the transformation incorrectly removes a control dependency or creates a cycle, it could lead to a null dereference or invalid state later in the execution pipeline. Both involve managing a stateful structure (transparency stack / computation graph) where improper operations can corrupt it.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Another out-of-bounds read in a network protocol parser (tcpdump). The target code's validations (`ShapesSymbolicallyEqual`, `IsValidConstShapeForMulConvPushDown`) are semantic checks for mathematical correctness, not bounds checks on untrusted data. The attack model and code patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-23589_after_exclude_100:fc3e963d:vulspec": {
    "timestamp": "2026-01-16T21:22:27.199334",
    "cve_id": "CVE-2022-23589",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "fc3e963d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a graph optimization pass in a machine learning framework (likely TensorFlow) performing constant folding and arithmetic transformation. CVE-2018-18313 is an out-of-bounds read in a Perl regex compiler due to improper NUL byte handling. The domains (ML compiler vs. regex parsing), vulnerability types (logic/transformation bug vs. memory safety), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs algebraic simplification on a computational graph. CVE-2017-13035 is an out-of-bounds read in a network protocol parser (tcpdump) due to insufficient length validation. The domains, functionality, and vulnerability patterns (memory corruption vs. graph transformation logic) are fundamentally dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13035"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code manipulates node properties and connections in a graph structure. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser when converting hex strings. The code deals with symbolic graph manipulation, not parsing untrusted input into fixed-size buffers.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The only slight similarity is that both codes are part of \"optimization\" systems (query planner vs. graph optimizer). However, CVE-2019-10128 is an access control flaw (CWE-284) in a database, while the target code is a purely mathematical transformation with no privilege or security context. The vulnerability mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The target code performs arithmetic operation reordering (multiplication with convolution). CVE-2015-7511 is a side-channel vulnerability (CWE-385) in a cryptographic library due to non-constant-time operations. The connection is tenuous: both involve mathematical operations, but the security concern (side-channel leakage vs. functional correctness) and domain (cryptography vs. ML graph optimization) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not involve dynamic memory allocation or resource management errors of the type in CVE-2016-7972 (CWE-399). The libass vulnerability concerns incorrect tracking of allocated glyph memory, while the constant folding code performs in-place graph node updates with careful validation checks.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code transforms nodes in a pre-defined computational graph. CVE-2019-19333 is a parser vulnerability in a YANG modeling language toolkit, likely involving input validation or type confusion. The domains (data modeling vs. graph optimization) and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Similar to case 2, CVE-2017-12899 is an out-of-bounds read in a network protocol parser (tcpdump). The target code does not parse untrusted network data and has no buffer or boundary checks that could lead to CWE-125.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. This is the most relevant case among the list. Both the target code and CVE-2016-10218 involve state manipulation within a stack or graph structure. The Ghostscript vulnerability arises from an unbalanced push/pop operation on a transparency stack (CWE-483), leading to a NULL dereference. The target code also manipulates a graph (a form of state) and must carefully manage node connections and names to avoid invalid states. While the vulnerability type (NULL dereference vs. logic error) and domain differ, the pattern of ensuring structural integrity during state transformations is conceptually similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is another out-of-bounds read in a network protocol parser (tcpdump) due to insufficient TLV length validation. The target code performs graph transformations with property validation (e.g., shape checking) but does not parse variable-length untrusted data from a network stream, making the vulnerability pattern irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2021-45936_before_exclude_100:5f87b572:vulspec": {
    "timestamp": "2026-01-16T21:22:27.865111",
    "cve_id": "CVE-2021-45936",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5f87b572",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a file transfer protocol. The target code is an MQTT client state machine with packet waiting logic, focusing on concurrency and state management. No integer overflow, memory allocation size calculation, or file transfer logic is present.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read in a packet parser due to insufficient length validation. The target code also parses network packets (MQTT), but its primary vulnerability pattern is not a missing bounds check on a TLV length. The code uses `MqttPacket_Read` and `MqttClient_DecodePacket`, which may have internal bounds checks, but the core logic shown is about state and concurrency, not direct low-level parsing flaws.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-3179 is a use-after-free due to inconsistent state management during error handling. The target code has complex state transitions (`MQTT_MSG_BEGIN`, `WAIT`, `READ`) and error paths with `goto wait_again` and early returns. While no explicit memory free is shown, the pattern of managing state (`*mms_stat`) and cleaning up resources (unlocking semaphores) on error paths is similar. A bug in state reset or semaphore unlock on certain error paths could lead to double-unlock or use-after-free of `client` resources.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code is a network client state machine, not a string/pattern parser. No regex or Unicode processing is involved.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-17498 is an integer overflow in SSH packet validation leading to out-of-bounds read. The target code reads packets and decodes them, but the shown logic does not involve arithmetic on packet fields that could overflow. The vulnerability pattern is different (integer overflow vs. state/concurrency issues).",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-14151 is a heap buffer overflow due to insufficient padding allocation in an image codec. The target code does not perform any memory allocation or buffer sizing based on image/data dimensions. It uses fixed `rx_buf` and focuses on protocol state.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-20760 is an out-of-bounds write in text encoding conversion due to missing error checks. The target code does not handle text encoding or character conversion. Its error handling is mostly about return codes from packet read/decode functions.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-15166 is improper input validation in a network protocol parser leading to potential memory issues. The target code validates `client` and `packet_obj` pointers and uses `MqttClient_DecodePacket`, which likely does internal validation. However, the core vulnerability pattern (missing bounds check on subobject length) is not directly visible. The relevance is higher than other parsing CVEs because both involve network protocol decoding, but the specific flaw type differs.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2012-5854 is a heap buffer overflow in IRC color decoding due to unsafe string concatenation. The target code does not manipulate strings or grow buffers dynamically. It works with fixed buffers and packet structures.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-20637 is improper removal of sensitive data (residual pointers) across requests in an HTTP server. The target code is a client, not a server, but it manages state (`*mms_stat`, `client->packet.stat`) across multiple packet processing cycles. If state is not properly reset (e.g., due to an early return or error), residual data from a previous packet could be incorrectly used. The pattern of state persistence and cleanup is similar, though the vulnerability outcome (information disclosure) is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      }
    ]
  },
  "CVE-2021-45936_after_exclude_100:527a6dc9:vulspec": {
    "timestamp": "2026-01-16T21:22:29.479508",
    "cve_id": "CVE-2021-45936",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "527a6dc9",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. The target code is an MQTT client state machine with packet handling and multi-threading synchronization. CVE-2018-20750 is a VNC server vulnerability involving integer overflow in file transfer leading to heap corruption. The domains (MQTT vs VNC), vulnerability patterns (state management vs arithmetic overflow), and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve network protocol parsing, but CVE-2018-14461 is about insufficient bounds checking in a packet analyzer (tcpdump) leading to out-of-bounds read. The target MQTT code does have packet reading (MqttPacket_Read) and decoding, but it appears to manage buffer lengths (client->rx_buf_len) and doesn't show the same pattern of missing length validation before accessing data. The context (client library vs passive sniffer) reduces relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2016-3179 involves Use-After-Free due to improper state management during error handling. The target code has complex state transitions (MQTT_MSG_BEGIN, WAIT, READ, etc.) and error paths with goto and break statements. While no explicit memory free is shown, similar patterns of state inconsistency on errors could exist. However, the specific vulnerability mechanism (UAF) is not directly mirrored in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 is a regex compiler issue with NUL byte handling leading to out-of-bounds read. The target code is a network client state machine. No regex parsing or similar string processing with embedded NULs is present. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-17498 involves integer overflow in SSH packet validation leading to out-of-bounds read. The target MQTT code does parse packets and uses integer fields (packet_id as word16). However, the code shows decoding via MqttClient_DecodePacket and does not exhibit obvious integer arithmetic that could overflow. The relevance is limited to the broad category of network protocol message parsing.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-14151 is a JPEG2000 encoder heap buffer overflow due to incorrect size calculation. The target code is a protocol client state machine, not a media codec. It handles network buffers but does not show complex size calculations or padding logic that could lead to similar miscalculations.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-20760 is a text encoding conversion issue leading to out-of-bounds write. The target code deals with binary MQTT packet data, not text encoding conversions. The error handling patterns (checking rc) are superficially similar but the core vulnerability mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Similar to case 2, CVE-2019-15166 is about insufficient input validation in a packet analyzer (tcpdump). The target MQTT client code does validate inputs (client == NULL || packet_obj == NULL) and decodes packets. The pattern of parsing TLV-like structures (MQTT has type/length fields) is analogous, but the client context and lack of shown complex subobject parsing reduce direct relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2012-5854 is an IRC chat client heap overflow in string formatting/color code processing. The target code is an MQTT client with no string formatting or dynamic string buffer growth logic shown. The domains and vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-20637 involves improper state clearance between requests in an HTTP server, leading to information disclosure. The target MQTT code manages state (mms_stat) across a complex state machine and has multi-threaded shared state (pendResp). The pattern of ensuring state is properly reset (*mms_stat = MQTT_MSG_BEGIN) on exit paths is crucial. A similar vulnerability could exist if state is not fully cleared under certain error or multi-threaded conditions, potentially causing cross-request contamination. This provides valuable reference for state management bugs.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      }
    ]
  },
  "CVE-2021-43845_after_exclude_100:67c4ad2c:vulspec": {
    "timestamp": "2026-01-16T21:22:30.660735",
    "cve_id": "CVE-2021-43845",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "67c4ad2c",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves an integer overflow leading to an out-of-bounds write during file transfer. The target code parses RTCP XR packets with careful bounds checks (e.g., `(char*)rb_hdr + sizeof(*rb_rr_time) <= (char*)pkt + size`). While both handle network data, the vulnerability pattern (CWE-787 via CWE-190) and the lack of complex arithmetic or allocation in the target code make the similarity low.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a Use-After-Free (CWE-416) in a service daemon due to improper pointer management during error handling. The target code performs read-only parsing of a packet into session statistics; it does not dynamically allocate/free memory within the function or manage complex object lifecycles. The attack surfaces and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is an Out-of-bounds Read (CWE-125) in a network protocol parser (tcpdump's LDP) due to insufficient validation of a TLV length field. The target code is also a network protocol parser (RTCP XR) and performs bounds checks on block lengths and pointer arithmetic. The similarity lies in parsing structured network data with length fields. However, the target code's checks appear robust, and the specific trigger (malicious length causing over-read) is mitigated by its validation logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is an Out-of-bounds Read (CWE-125) in a regex compiler due to improper handling of NUL bytes. The target code deals with binary network packets, not string parsing with embedded terminators. The domain (compiler vs. network protocol) and the nature of the triggering input are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is an Improper Input Validation (CWE-20) leading to a buffer overflow in a decompression algorithm. The target code validates packet and block sizes but does not involve decompression algorithms or sliding window operations. Both involve parsing external input, but the complexity and vulnerability mechanisms (compression state corruption vs. structured packet parsing) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 is an Integer Overflow (CWE-190) in an SSH protocol library leading to an out-of-bounds read. The target code performs arithmetic operations (e.g., `now - lrr - dlrr`, `eedelay * 1000000 >> 16`) on untrusted network data. While the target code uses 64-bit integers for critical calculations (e.g., `eedelay`) and has sanity checks (e.g., `eedelay <= 30 * 1000 * 1000UL`), it shares the context of performing arithmetic on received protocol fields. The relevance is moderated because the target's arithmetic seems guarded and the primary vulnerability pattern in the code is more about logic validation than overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a Race Condition (CWE-362) in a kernel filesystem's resource management. The target code is a user-space library function that processes a single packet; it has no concurrent execution or shared resource management vulnerabilities. The domains and concurrency models are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a Buffer Overflow (CWE-119) due to insufficient buffer padding in an image encoder. The target code reads data into structured pointers but does not allocate buffers or write data based on complex size calculations. Both process external input, but the target code's operations are bounded by the input packet size and `sizeof` checks, making the overflow mechanism less relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an Information Disclosure (CWE-212) due to improper state clearance between HTTP requests in a proxy. The target code updates session statistics based on a received packet but does not handle sensitive data or persistent request state in a way that could leak information across independent calls. The vulnerability class and context are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a Use-After-Free (CWE-416) due to a race condition in a kernel system call. Similar to Case 2 and 7, the target code does not involve dynamic memory management, locking, or concurrency. It is a straightforward, synchronous parsing function.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      }
    ]
  },
  "CVE-2021-43845_before_exclude_100:6d429f15:vulspec": {
    "timestamp": "2026-01-16T21:22:32.595482",
    "cve_id": "CVE-2021-43845",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6d429f15",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing network protocols, but the vulnerability types differ significantly. CVE-2018-20750 is an integer overflow leading to out-of-bounds write during memory allocation. The target code performs bounds checks (`(pkt_len + 1) > (size / 4)`) and pointer arithmetic but does not involve dynamic memory allocation within the parsing loop. The primary similarity is parsing variable-length structures from untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability related to error handling and resource cleanup in a service daemon. The target code is a stateless RTCP XR packet parser that does not dynamically allocate or free the session (`sess`) or report block structures within this function. It operates on provided buffers and updates session statistics in-place.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Strong similarity in the core vulnerability pattern: insufficient validation of length fields leading to out-of-bounds read. Both CVE-2018-14461 (tcpdump LDP parser) and the target code parse TLV-like structures (RTCP XR report blocks) with length fields (`rb_len`). The target code uses `rb_len` for pointer arithmetic to traverse the packet. A key difference is the target code validates the overall packet length first and skips zero-length blocks, but the loop condition `(pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len` and pointer advance `((pj_int32_t*)rb_hdr + rb_len + 1)` could be vulnerable to an integer wrap-around or miscalculation if `rb_len` is maliciously large, leading to an out-of-bounds read.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to improper NUL byte handling in strings. The target code processes binary network packets, not null-terminated strings. While both could theoretically read out-of-bounds, the attack surface, data format, and triggering mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2010-1311 involves improper input validation in a decompression algorithm leading to out-of-bounds write. The target code validates the RTCP packet type and length but is primarily a reader/parser, not a complex stateful decoder like a decompression engine. The relevance is limited to the general theme of validating untrusted input from a network/file.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-17498 is an integer overflow during packet field validation leading to an out-of-bounds read. The target code performs integer arithmetic with length fields (`pkt_len`, `rb_len`) for bounds checking and pointer advancement. While no obvious overflow is present (multiplications are by 4 due to 32-bit word size), the pattern of using network-derived integers for memory operations is similar. The check `(pkt_len + 1) > (size / 4)` could theoretically overflow if `pkt_len` is `0xFFFFFFFF`, but `size` is a `pj_size_t` (likely unsigned), making the check safe. The relevance is in the vulnerability class, not a direct match.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a kernel filesystem's resource management. The target code is a user-space library function parsing a single packet. There is no concurrency, resource allocation, or complex state management involved that would lead to a similar race condition vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow due to incorrect calculation of padding in a memory allocator within an image codec. The target code does not allocate memory; it casts and traverses an existing buffer. The only calculation is pointer arithmetic, not buffer size allocation.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20637 is an information disclosure via residual pointers in an HTTP server's request workspace between connections. The target code updates a session structure (`sess`) with statistics from a single packet. It does not manage a shared workspace or reuse memory between independent requests in a way that could leak old data. The session is presumed to be persistent and owned by the caller.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-10675 is a Use-After-Free caused by a race condition in a Linux kernel system call for memory policy. The target code is a simple, synchronous user-space packet parser with no locking, concurrency, or complex resource lifecycle management.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      }
    ]
  },
  "CVE-2021-43267_after_exclude_100:6c9deecf:vulspec": {
    "timestamp": "2026-01-16T21:22:45.040227",
    "cve_id": "CVE-2021-43267",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6c9deecf",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2010-4650 is a FUSE ioctl buffer overflow in the Linux kernel filesystem layer. The target code is TIPC crypto key handling in networking. Different subsystems, different vulnerability patterns (buffer overflow vs. potential validation issues), and different attack surfaces (FUSE server vs. network packets).",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in VNC file transfer. The target code has size validations (keylen checks) but could potentially have similar integer validation issues. Both handle network data, but different protocols and vulnerability patterns (memory allocation overflow vs. key validation).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2013-1792 is a race condition in kernel keyring subsystem leading to NULL pointer dereference. The target code uses spinlocks for synchronization and doesn't show obvious race conditions. Both involve key management but different contexts (crypto keys vs. authentication keys) and different vulnerability types.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3137 is a NULL pointer dereference in USB serial driver due to missing endpoint validation. The target code is network crypto key handling with no USB or device driver components. Different subsystems and vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2014-0196 is a TTY race condition leading to buffer overflow. The target code uses spinlocks and has different concurrency patterns. Both are kernel code but different subsystems and vulnerability types (race condition vs. input validation).",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition in F2FS filesystem node management. The target code uses spinlocks for synchronization. Both involve resource management but different contexts (filesystem nodes vs. crypto keys) and different vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-16914 is a NULL pointer dereference in USB/IP subsystem. The target code doesn't show obvious NULL pointer issues and is in a different subsystem (networking/TIPC vs. USB virtualization). Different attack surfaces and vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-16913 involves improper bounds checking and memory allocation issues in USB/IP. The target code has similar validation patterns (checking size, keylen bounds) and both handle network-provided data. Similar vulnerability pattern: validating network data before processing, though different subsystems.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3136 is a NULL pointer dereference in USB serial driver. The target code is network crypto key handling with no similar error conditions or driver probe patterns. Different subsystems and vulnerability types.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2016-10154 involves improper memory buffer handling in SMB crypto operations. The target code also handles cryptographic keys and has similar validation patterns (size checks, bounds verification). Both involve network protocol crypto operations and memory handling of security-sensitive data. Similar code patterns for validating incoming network data before cryptographic operations.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2021-3746_before_exclude_100:9a9e07ec:vulspec": {
    "timestamp": "2026-01-16T21:22:47.044646",
    "cve_id": "CVE-2021-3746",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9a9e07ec",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a simple search function for an empty slot in a static array. It does not involve dynamic memory allocation, pointer management, or error handling paths that could lead to Use-After-Free (CWE-416). The vulnerability context (network service daemon) and root cause are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code performs a bounded loop over a static array with a clear termination condition (`MAX_LOADED_OBJECTS`). It does not parse complex input (like regex patterns), handle embedded NUL bytes, or perform operations that could lead to an out-of-bounds read (CWE-125). The code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not parse tokens, handle nested structures, or write to buffers based on input calculations. It simply iterates and initializes a structure. There is no similarity to the out-of-bounds write (CWE-787) vulnerability caused by incorrect parenthesis counting in a parser.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not parse network protocol data or validate length fields from external input. It operates on a purely internal, fixed-size data structure. The out-of-bounds read (CWE-125) vulnerability in a packet parser is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code contains no arithmetic operations on user-controlled input that could lead to integer overflow (CWE-190). The loop uses a fixed limit, and the index `i` is not used for memory allocation or buffer offset calculations that could wrap around.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code is a utility function with no privilege management, process state handling, or input validation related to system security. The CWE-20 (Improper Input Validation) leading to privilege issues is completely unrelated to the functionality of finding an empty object slot.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Similar to case 4, the target code is not a network protocol parser. It does not process variable-length subobjects or perform bounds checking on external data. The improper input validation (CWE-20) context is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. There is a tangential connection: both involve internal data structure management. However, the target code manages a simple static array of objects, while the vulnerability concerns dynamic buffer management and sentinel values in a network stack. The specific CWE-119 manifestation (buffer overread via missing sentinel) is not present in the simple array iteration and initialization shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not perform any memory allocation based on calculated sizes, integer conversions, or handle client-provided length fields. The out-of-bounds write (CWE-787) via integer overflow (CWE-190) chain is not applicable to this static array lookup function.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code uses `MemorySet` to initialize a structure, but it uses the exact size of the structure (`sizeof(OBJECT_ATTRIBUTES)`). There is no string length calculation, negative length values, or heap buffer operations that could lead to CWE-119. The code pattern is fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2021-43267_before_exclude_100:88fd4eb1:vulspec": {
    "timestamp": "2026-01-16T21:22:48.608741",
    "cve_id": "CVE-2021-43267",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "88fd4eb1",
    "scores": [
      {
        "score": 3,
        "reasoning": "CVE-2010-4650 involves FUSE ioctl buffer overflow due to insufficient iovec validation. The target code performs memory allocation and copying with some size validation (tipc_aead_key_size check), but the vulnerability patterns differ significantly. Both involve kernel memory operations, but the attack surfaces (FUSE server vs. TIPC network crypto) and specific flaws (buffer overflow vs. potential integer/validation issues) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-20750 involves integer overflow leading to out-of-bounds write in LibVNC. The target code has similar patterns: it receives network data (size from msg_data_sz), allocates memory (kmalloc), and copies data with calculations (skey->keylen from network data). Both involve parsing untrusted network data with potential integer handling issues. However, the target code has a size validation check, reducing direct similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2013-1792 is a race condition leading to NULL pointer dereference in kernel keyring. The target code uses spin_lock for synchronization, reducing race risks. Both are kernel subsystems handling security data, but the vulnerability patterns (concurrency vs. input validation) and attack surfaces (system calls vs. network messages) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-3137 is a NULL pointer dereference in USB driver due to missing endpoint validation. The target code doesn't involve USB or hardware descriptor parsing. Both are kernel code, but the domain (USB serial vs. network crypto) and vulnerability patterns (hardware descriptor validation vs. network data parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2014-0196 is a TTY race condition causing buffer overflow. The target code uses locking and doesn't show obvious concurrency issues. Both involve kernel memory operations, but the synchronization patterns (TTY workqueue races vs. spin_lock protected crypto) and data sources (local processes vs. network) differ substantially.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-18249 is a filesystem race condition in F2FS nid management. The target code has simpler locking and different functionality (crypto key vs. filesystem metadata). Both involve kernel resource management, but the concurrency patterns and data structures are too dissimilar for strong relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-16914 is a NULL pointer dereference in USB/IP from insufficient URB validation. The target code also parses network data and could potentially dereference invalid pointers if skey fields are corrupted. Both involve network data parsing in kernel subsystems, but the specific validation patterns differ (USB protocol vs. TIPC crypto).",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-16913 involves improper bounds checking leading to excessive memory allocation in USB/IP. The target code has similar patterns: network-provided size (msg_data_sz), kmalloc allocation, and data copying. Both need to validate network data before memory operations. The size validation in target code (tipc_aead_key_size) provides some protection, making patterns moderately similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-3136 is a USB driver NULL pointer dereference from missing endpoint validation. Similar to case 4, this involves hardware descriptor parsing which is completely absent from the network crypto target code. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-10154 involves improper memory buffer operations in CIFS crypto using scatterlist on stack memory. The target code also handles cryptographic keys and copies data. Both involve kernel crypto operations with potential memory safety issues. However, the specific vulnerability (VMAP_STACK with scatterlist) doesn't directly match the target code's patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2021-3746_after_exclude_100:02ce5c3f:vulspec": {
    "timestamp": "2026-01-16T21:22:49.489229",
    "cve_id": "CVE-2021-3746",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "02ce5c3f",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a simple object slot finder and initializer. CVE-2016-3179 is a Use-After-Free vulnerability in a network service discovery daemon. The domains (TPM object management vs. SSDP), vulnerability types (uninitialized memory vs. UAF), and code patterns are fundamentally different. The only weak similarity is the handling of internal data structures.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2022-26490_after_exclude_100:f03c2417:vulspec": {
    "timestamp": "2026-01-16T21:22:49.889227",
    "cve_id": "CVE-2022-26490",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f03c2417",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2010-4650 is a FUSE ioctl buffer overflow in the virtual filesystem layer. The target code is an NFC connectivity event handler dealing with sk_buff data validation. Different subsystems, different vulnerability patterns (ioctl vs. network packet parsing), and different memory management contexts.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer. The target code also performs length validations on incoming data (skb->len, aid_len, params_len) to prevent buffer overflows. Both involve validating attacker-controlled length fields, but the vulnerability root cause (integer overflow/wraparound vs. simple bounds check) and subsystem are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in F2FS filesystem node ID management. The target function processes a single sk_buff in what appears to be a synchronous event handler with no evident concurrency or shared resource manipulation. Different vulnerability class entirely.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-16914 is a NULL pointer dereference in USB/IP due to insufficient validation of URB fields. The target code validates sk_buff data and tags (e.g., checking for NFC_EVT_TRANSACTION_AID_TAG) and could return -EPROTO, but does not involve pointer dereference of a potentially NULL struct. Both perform protocol validation, but the defect type is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free due to a race condition in memory policy management. The target code allocates memory with devm_kzalloc and uses it locally without complex lifecycle or locking issues. Different vulnerability class and subsystem.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-1792 is a race condition leading to NULL pointer dereference in the keyring subsystem. The target code shows no evidence of concurrent execution or shared state synchronization issues. Different context and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-10154 is a buffer overflow in CIFS crypto due to scatterlist pointing to stack memory. The target code copies data from an sk_buff into a heap-allocated struct using memcpy with length checks. Both involve memory copies, but the vulnerability mechanism (VMAP_STACK interaction) and subsystem are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3137 is a NULL pointer dereference due to insufficient validation of USB endpoint descriptors. The target code validates several fields in the sk_buff data (tags, lengths) before proceeding, sharing a theme of input validation. However, the target code does not dereference pointers from the untrusted data itself; it validates content.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2014-0196 is a race condition in the TTY subsystem leading to buffer overflow. The target code is a straightforward event handler without concurrency or buffer management complexity seen in TTY line discipline. Different domain and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2012-3364 is a buffer overflow in the Linux kernel NFC subsystem (NCI) due to insufficient length validation when copying NFC-A frame data. The target code is also in the NFC subsystem (ST21NFCA driver), handles NFC events (EVT_TRANSACTION), and performs similar operations: validating lengths (skb->len, aid_len, params_len), checking tags, and using memcpy with calculated lengths. The vulnerability pattern (CWE-119: improper restriction of memory buffer operations) and the attack surface (maliciously crafted NFC frames/skb data) are nearly identical. The main difference is the specific NFC protocol layer (NCI vs. HCI/SE connectivity events).",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      }
    ]
  },
  "CVE-2022-37032_before_exclude_100:ae622302:vulspec": {
    "timestamp": "2026-01-16T21:22:49.995594",
    "cve_id": "CVE-2022-37032",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ae622302",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve BGP capability parsing with potential out-of-bounds read issues. The target code processes MP-BGP capabilities (CAPABILITY_CODE_MP) similar to CVE-2018-14467. Both require careful bounds checking of capability length fields (hdr->length in target code). The vulnerability pattern of insufficient validation before accessing structured data within a packet buffer is identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-14467"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14461 affects LDP protocol parsing in tcpdump, while the target code is BGP capability parsing in a routing daemon (likely FRRouting). Different protocols (LDP vs BGP), different systems (packet analyzer vs routing engine), and different attack contexts (passive analysis vs active protocol processing).",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve BGP capability parsing with bounds checking issues. CVE-2018-14881 deals with RESTART capability, while target code handles MP capability, but the vulnerability pattern is identical: insufficient validation of capability length (hdr->length) leading to potential out-of-bounds read. Both check \"pnt + hdr->length + 3 > end\" which is the critical safety check.",
        "case_metadata": {
          "cve_id": "CVE-2018-14881"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write in LibVNC's file transfer, involving integer overflow in memory allocation. The target code is BGP parsing with read-only operations on network buffers. Different vulnerability types (write vs read), different protocols, and completely different code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve BGP protocol parsing with bounds checking issues. CVE-2017-13053 deals with VPN route target parsing, while target code handles capability parsing. Similar pattern of parsing structured data from network packets with potential offset calculation errors. Both require careful validation of packet boundaries.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is a Perl regex engine issue with NUL byte handling leading to out-of-bounds read. The target code is network protocol parsing in C. Different domains (string processing vs network parsing), different vulnerability triggers, and completely different code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve BGP protocol parsing with offset calculation issues. CVE-2017-13043 deals with MVPN route types, while target code handles capabilities. Similar pattern of parsing structured data from packets with pointer arithmetic (pnt += hdr->length + 3). Both require careful bounds checking to prevent out-of-bounds reads.",
        "case_metadata": {
          "cve_id": "CVE-2017-13043"
        }
      },
      {
        "score": 2,
        "reasoning": "Low relevance. CVE-2019-25034 is an integer overflow leading to out-of-bounds write in DNS parsing. The target code has arithmetic (pnt + hdr->length + 3) but for bounds checking, not allocation. Different protocol domains (DNS vs BGP) and different vulnerability types (write vs read).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13054 is an LLDP parsing issue with missing length validation. While both involve network protocol parsing with TLV-like structures (BGP capabilities are similar to TLVs), the protocols and specific code patterns differ significantly. Both share the general principle of validating length before data access.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-15166 involves LMP protocol parsing with improper input validation. The target code also validates input (action values, length checks). Both involve parsing network protocol messages with subcomponents, but different protocols and specific validation patterns. The general principle of bounds checking is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2022-37032_after_exclude_100:0c62c137:vulspec": {
    "timestamp": "2026-01-16T21:22:54.243980",
    "cve_id": "CVE-2022-37032",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0c62c137",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. Both involve parsing BGP capabilities, specifically MP-BGP (CAPABILITY_CODE_MP). The target code performs bounds checking on `hdr->length` before a `memcpy` of `struct capability_mp_data`, which is the exact pattern that could lead to CWE-125 (Out-of-bounds Read) if the check is insufficient or flawed. The vulnerability context (BGP capability parsing) and the data structure being processed are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-14467"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The vulnerability is in a different protocol (LDP vs. BGP) and a different system (packet analyzer vs. routing daemon). While both involve parsing TLVs/capabilities and checking lengths, the domain and code patterns are distinct. The target code is from an active BGP implementation, not a passive dissector.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Both involve parsing BGP capabilities and require careful bounds checking of capability-specific data structures. CVE-2018-14881 is an out-of-bounds read in BGP RESTART capability parsing. The target code shows a similar pattern: it validates the generic capability length (`hdr->length`) and then copies/processes a specific capability structure (`capability_mp_data`). The risk pattern is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14881"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The vulnerability is in a completely different system (VNC file transfer) and vulnerability class (CWE-787 Out-of-bounds Write due to integer overflow). The target code performs reads and length checks but does not involve dynamic memory allocation or integer wraparound in a similar way.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Both involve BGP protocol parsing and the risk of out-of-bounds reads due to incorrect offset/length calculations. While CVE-2017-13053 is in VPN route target parsing and the target code is in capability parsing, the underlying security principlemeticulously validating all data accesses against packet boundariesis the same. The code patterns (pointer arithmetic, length checks) are comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The vulnerability is in a Perl regex engine, dealing with string parsing and NUL bytes. The domain (network protocol parsing vs. regular expression compilation) and the nature of the out-of-bounds read are fundamentally different from the structured binary protocol parsing in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Similar to case 5, this is another BGP parsing vulnerability (MVPN) in tcpdump. The relevance stems from the same core issue: ensuring pointer arithmetic and structure accesses stay within the bounds of the received packet. The target code demonstrates this pattern with its multiple checks (`pnt + 3 > end`, `pnt + hdr->length + 3 > end`).",
        "case_metadata": {
          "cve_id": "CVE-2017-13043"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The vulnerability is an integer overflow leading to an out-of-bounds write in a DNS resolver. The target code performs bounded reads and uses `bgp_size_t` (likely unsigned) for length, but does not contain arithmetic that could wrap around to a smaller value, which is the core of CVE-2019-25034.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The vulnerability is in LLDP parsing (a different protocol) but shares the common theme of missing length validation before accessing TLV data. The target code explicitly performs this validation for BGP capabilities. The similarity is in the generic \"validate before access\" pattern, but the protocols and specific code structures differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The vulnerability is in LMP parsing, another network protocol. The connection is the general need for input validation in protocol parsers (CWE-20). The target code shows robust validation (multiple length checks, action value check), which is the defensive pattern needed to avoid such vulnerabilities. The relevance is in the contrasting example: one shows missing checks, the other shows extensive checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2022-26490_before_exclude_100:1930cc86:vulspec": {
    "timestamp": "2026-01-16T21:22:56.531413",
    "cve_id": "CVE-2022-26490",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1930cc86",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2010-4650 is a buffer overflow in the FUSE subsystem due to improper iovec length validation. The target code is in the NFC subsystem and involves parsing a transaction structure from an sk_buff. While both involve data validation, the vulnerability type (ioctl retry path vs. protocol parsing), subsystem, and attack surface (malicious FUSE server vs. malicious NFC frame) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write in a VNC file transfer. The target code performs length checks (`skb->len < NFC_MIN_AID_LENGTH + 2`) and uses `skb->len - 2` for allocation, which could be problematic if `skb->len` is less than 2, but this is a simple underflow/overflow check, not a complex integer wraparound during size calculation. The core vulnerability patterns are not strongly similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in F2FS node ID management. The target function `st21nfca_connectivity_event_received` is a synchronous event handler for an NFC HCI driver. There is no indication of concurrent access to shared data structures, locking, or the check-time-of-use pattern typical of race conditions. The contexts are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-16914 is a NULL pointer dereference in the USB/IP subsystem due to insufficient validation of URB fields. The target code validates data tags (`skb->data[0]`, `skb->data[transaction->aid_len + 2]`) but does not perform null checks on the allocated `transaction` pointer after `devm_kzalloc`. However, `devm_kzalloc` returns NULL on failure, and the code returns `-ENOMEM` immediately, preventing a dereference. The similarity is superficial (input validation theme) but the specific flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition and improper locking in the memory policy subsystem. The target NFC code is a simple, synchronous event handler with no dynamic resource management (the `transaction` object is managed by `devm_kzalloc`), locking, or shared state that could lead to a UAF. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-1792 is a race condition leading to a NULL pointer dereference during keyring initialization. The target code has no concurrency mechanisms, no shared global state initialization, and its only NULL check is on the result of `devm_kzalloc`, which is handled. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2016-10154 is a buffer overflow in the CIFS crypto code related to scatterlist and stack memory. The target code uses `memcpy` with lengths derived from the packet (`skb->data[1]`, `skb->data[transaction->aid_len + 3]`). While both involve copying data based on input, the target code validates the initial tag and has a length check, though the validation of `params_len` against remaining buffer size is incomplete. The specific vulnerability mechanism (VMAP stack, scatterlist) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-3137 is a NULL pointer dereference due to missing validation of USB endpoint descriptors. The target code validates data fields within the SKB but does not validate that `skb->data` has enough elements before the second `memcpy` (e.g., checking `transaction->aid_len + 4 + transaction->params_len <= skb->len`). This is a missing bounds check, which shares a theme of insufficient input validation, but the manifestation (dereference vs. overflow) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2014-0196 is a race condition in the TTY subsystem leading to a buffer overflow. The target NFC code is not concurrent, does not manage a circular buffer, and has no workqueues or similar mechanisms. The vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. CVE-2012-3364 is a buffer overflow in the Linux kernel NFC subsystem (specifically NCI) due to lack of bounds checking when copying frame data. The target code is also in the NFC subsystem (`st21nfca` driver) and parses an incoming transaction from an sk_buff. It uses lengths (`skb->data[1]`, `skb->data[transaction->aid_len + 3]`) from the packet to control `memcpy` operations without fully verifying that these lengths are within the bounds of the received `skb->len`. This is a classic CWE-119 vulnerability pattern identical to the referenced case: insufficient validation of variable-length fields in a communication protocol. The domain, vulnerability type, and code pattern are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      }
    ]
  },
  "CVE-2022-24786_after_exclude_100:788752a4:vulspec": {
    "timestamp": "2026-01-16T21:23:01.895644",
    "cve_id": "CVE-2022-24786",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "788752a4",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing network protocol data and integer calculations for buffer sizes, but the vulnerability types differ. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write during memory allocation. The target code performs bounds checks (e.g., `padlen >= 32`, `rpsi_len*8 - 16 - padlen`) to prevent overflows and reads, not writes. The core vulnerability pattern (allocation size calculation flaw) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free caused by improper resource cleanup and state management. The target code is a pure parsing function with no dynamic memory allocation, deallocation, or persistent state. The attack surfaces and failure modes are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-18313 is an out-of-bounds read due to improper handling of embedded NUL bytes in input data. The target code also parses input buffers and has logic to prevent reading out-of-bounds (length validation, padding checks). While the specific trigger (NUL byte) is not present, both involve careful validation of input lengths and offsets to prevent buffer over-reads (CWE-125). The code patterns share the theme of calculating derived lengths from packet headers.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser (tcpdump's LDP) due to insufficient validation of a TLV length field. The target code is also a network protocol parser (RTCP RPSI) that validates a length field (`hdr->rtcp_common.length`) and performs multiple checks (`length >= ...`, `rpsi_len` calculation, padding validation) to prevent reading beyond the buffer. The vulnerability type (CWE-125), domain (network protocol parsing), and defensive pattern are similar. The main difference is the specific protocol and structure.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in a kernel ioctl handler due to insufficient validation of user-supplied iovec lengths. The target code validates lengths from a network packet but does not handle dynamic arrays of buffers or kernel-user interface interactions. The context and attack surface are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a filesystem's resource management. The target code is a single-threaded, stateless parsing function with no shared resources or concurrency. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to an incorrect size calculation for a memory allocation with padding. The target code performs size calculations (`rpsi_len*8 - 16 - padlen`) and checks for overflow conditions (`padlen >= 32`, comparison of `rpsi_len*8` with `16+padlen`). Both involve arithmetic on length fields, but the target code validates to prevent overflow, whereas the vulnerability occurred due to insufficient padding. The domain (image encoding vs. network parsing) is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2010-1311 involves improper input validation in a decompression algorithm leading to out-of-bounds write. The target code also validates input (length, padding, PT/FMT fields) but for a different purpose and protocol. The connection is the general theme of validating attacker-controlled length fields to prevent memory corruption, but the specific mechanisms (sliding window decompression vs. RTCP parsing) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2017-17787 is an out-of-bounds read in a file format parser due to improper validation of string data. The target code parses a binary format and carefully validates lengths and offsets to prevent reading out-of-bounds. Both are parsers that take untrusted input and must calculate safe read boundaries. The target code deals with binary length fields, while the vulnerability dealt with string termination, but the defensive coding goal is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2014-0196 is a race condition in a kernel TTY subsystem leading to a buffer overflow. The target code has no concurrency, no shared buffers, and operates on a single input buffer. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2022-24786_before_exclude_100:11ce9716:vulspec": {
    "timestamp": "2026-01-16T21:23:02.120343",
    "cve_id": "CVE-2022-24786",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "11ce9716",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing network/data structures and potential integer handling issues (CWE-190/197 vs. calculations with `rpsi_len`). However, the core vulnerability differs: CVE-2018-20750 is an out-of-bounds write from integer overflow in allocation, while the target code performs bounds checks (`length < rpsi_len + 12`) and is a parser, not an allocator. The attack surface (file transfer vs. RTCP feedback) and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free vulnerability related to memory management and error handling in a service daemon. The target code is a simple parser with no dynamic memory allocation, complex state, or error cleanup paths that could lead to use-after-free. The functional domains (SSDP daemon vs. RTCP parsing) and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The primary link is CWE-125 (Out-of-bounds Read). The target code reads a variable-length `rpsi` field based on a calculated length (`rpsi_len`) derived from the network packet. Insufficient validation could lead to an over-read similar to the Perl regex issue. However, the target code has a bounds check (`length < rpsi_len + 12`). The vulnerability patterns differ: one is NUL-byte handling in strings, the other is arithmetic on network-derived lengths. The reference value is limited to the general concept of length validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Strongest similarity so far. Both are network protocol parsers (LDP vs. RTCP) where a length field from the packet (`hdr->length`) is used to calculate the size of a subsequent data field (`rpsi_len`). Both are susceptible to CWE-125 if the calculated length is not properly validated against the actual buffer size. The target code performs a check (`length < rpsi_len + 12`), making it safer, but the code pattern and potential vulnerability logic are similar. The reference value for understanding length field validation pitfalls is significant.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in a kernel FUSE component due to insufficient validation of iovec lengths from a userspace server. The target code is a user-space library parser validating its own input buffer. The vulnerability patterns (complex kernel ioctl retry path vs. simple packet parsing), attack surfaces, and code contexts are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition (CWE-362) in a filesystem's resource management. The target code is a single-threaded, stateless parsing function with no concurrency, shared resources, or stateful allocation logic. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The connection is the potential for buffer size miscalculation leading to overflow (CWE-119). The target code calculates `rpsi_len` and uses it to set a string length, but does not perform a write based on that length beyond the `pj_strset` which uses the calculated size. The primary risk here is an over-read, not an overflow during encoding/compression. The domains (image codec vs. network protocol) and specific flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing compressed/encoded data from an external source. CVE-2010-1311 stems from CWE-20 (Improper Input Validation) of match offsets against window boundaries, leading to out-of-bounds write. The target code also validates input (length fields) but is far simpler and only reads data. The relevance lies in the general principle of rigorously validating all parser inputs derived from untrusted data, but the specific mechanisms and vulnerabilities differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The link is CWE-125 (Out-of-bounds Read) during the parsing of external file/network data. Both functions parse a data structure and extract a variable-length field (string/RPSI data) based on internal length indicators. The target code's `padlen` and `rpsi_bit_len` calculations are analogous to parsing string lengths in an image file. The check `length < rpsi_len + 12` is crucial to prevent the over-read. The reference value is in validating length fields for derived data.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2014-0196 is a concurrency race condition (CWE-362) in a kernel TTY buffer. The target code is a simple, reentrant but not thread-safe, parsing function with no shared buffers or concurrent execution considerations. The vulnerability class and context are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2022-40299_after_exclude_100:a35de213:vulspec": {
    "timestamp": "2026-01-16T21:23:16.033012",
    "cve_id": "CVE-2022-40299",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a35de213",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code does not involve use-after-free, uninitialized pointers, or double-free patterns. It carefully frees resources (omFree, si_unlink) and checks for NULL. The vulnerability domain (network service daemon) and root cause (CWE-416) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not perform complex parsing of network protocol data or have out-of-bounds read vulnerabilities. It deals with local file editing and process forking, not SMB authentication or security blob validation.",
        "case_metadata": {
          "cve_id": "CVE-2010-1642"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      }
    ]
  },
  "CVE-2016-7132_after_exclude_100:566d15ce:vulspec": {
    "timestamp": "2026-01-16T21:23:21.633489",
    "cve_id": "CVE-2016-7132",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "566d15ce",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3179 is a Use-After-Free in a network daemon's local socket interface. The target code is a PHP WDDX deserialization function. While both involve memory management, the vulnerability type (UAF vs. potential deserialization issues), attack surfaces (local socket vs. data parsing), and code patterns (network state handling vs. XML element stack processing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-17807 is a Missing Authorization flaw in the Linux kernel's KEYS subsystem. The target code is a user-space PHP data parsing function with no authorization logic. The domains (kernel security vs. application data parsing), vulnerability types (permission bypass vs. memory/object manipulation), and code constructs are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-9226 is an Out-of-bounds Write in a regex library's character class compiler. The target code is a WDDX deserializer that processes XML elements, not regular expressions. The vulnerability mechanism (octal escape sequence validation) and the data processing domain (regex compilation vs. XML deserialization) have no overlap with the target code's functionality.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-11222 is an Out-of-bounds Write in a multimedia framework's binary data parser. The target code also parses data (WDDX/XML) and has complex pointer/zval manipulation. There is a superficial similarity in parsing untrusted input and managing memory buffers. However, the specific vulnerability (hex parsing OOB write) and code patterns (binary vs. structured XML parsing) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-0380 is an Information Exposure via uninitialized stack buffer in a Tor logging function. The target code initializes its stack variables and does not contain logging of sensitive data. While both are C code, the vulnerability class (info leak via uninitialized memory) and context (protocol error logging vs. data structure population) are not relevant to the target's logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-0380"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2011-1003 is a Double Free in an antivirus file parser triggered during error conditions. The target code is also a parser (WDDX) that performs complex memory allocation/free operations (`efree`, `zval_ptr_dtor`) on a stack of entries. Both involve managing nested parsed elements and cleaning up resources. The pattern of freeing memory in error/cleanup paths is similar, though the specific trigger (VBA strings vs. XML elements) differs.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-9228 is another Oniguruma OOB Write due to uninitialized state during regex compilation. The target code does not compile regexes and does not have analogous state machine logic for character classes. The code domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-9228"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2015-0241 is a Buffer Overflow in a database formatting function. The target code performs string operations (e.g., `strcmp`, `strlen`) and copies zvals, but does not use fixed-size buffers in a similar way. The vulnerability mechanism (unchecked template-driven writes) and context (numeric formatting) are not present in the WDDX deserializer.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-9227 is an Out-of-bounds Read in a regex library's search function. The target code does not perform pattern matching or forward searches. The code's purpose and the vulnerability's root cause (invalid pointer arithmetic in search) are irrelevant to the XML element stack processing shown.",
        "case_metadata": {
          "cve_id": "CVE-2017-9227"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-9229 is a NULL Pointer Dereference in a regex library's search range function. The target code does dereference pointers (e.g., `ent1->data`), but they are retrieved from a stack that is checked for `top == 0`. The context (regex multi-byte processing) and the specific cause (invalid `dmax` calculation) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-9229"
        }
      }
    ]
  },
  "CVE-2021-41206_before_exclude_100:427e3588:vulspec": {
    "timestamp": "2026-01-16T21:24:13.099671",
    "cve_id": "CVE-2021-41206",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "427e3588",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a grouped convolution operator in a machine learning framework (likely TensorFlow), performing tensor shuffling and spatial convolution. It does not involve cryptographic operations, side-channel resistance, or secret-dependent branching. The vulnerability context (ECC in libgcrypt) is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs numerical tensor operations for deep learning. It does not involve DNSSEC, cryptographic algorithm validation, key processing, or error handling related to unsupported algorithms. The functional domains are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a computational kernel with no privilege separation, daemon initialization, or input validation of security-critical state like `privsep_init`. The vulnerability context (network daemon privilege management) is unrelated to tensor manipulation.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. There is a conceptual similarity in processing structured data (ISO descriptors vs. tensor dimensions) and performing calculations on sizes. The target code uses `int64_t` for dimensions and has array indexing, which could theoretically be mis-calculated. However, no integer overflow is evident in the shown code; dimensions are derived from existing tensor shapes and used for allocation and shuffling. The risk profile is much lower.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve mathematical calculations on parameters (blur coefficients vs. convolution strides/dilations). The target code uses user-provided parameters like `row_stride`, `col_stride`, `row_dilation`, `col_dilation`, and `explicit_paddings` in calculations. If these values were extremely large, they could potentially cause issues in the `SpatialConvolution` functor (not shown). However, the direct buffer overflow pattern from libass is not visible in this snippet.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The similarity lies in processing external data parameters (image dimensions vs. tensor dimensions) and performing calculations that could lead to allocation issues. The target code calculates shapes like `post_shuffle(input)` which divides `tensor.dim_size(3)` by `num_groups`. If `num_groups` is zero or doesn't divide evenly, it could cause problems, but this is likely validated elsewhere. The integer overflow leading to heap overflow pattern is not directly evident.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse untrusted string input (like hexadecimal config lines) into buffers. It operates on already-structured tensor data within a controlled framework. The stack-based buffer overflow context from BlueZ is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve allocating buffers for data processing (code blocks vs. temporary tensors for shuffling). The target code allocates `input_shuffled`, `filter_shuffled`, and `output_shuffled` based on calculated shapes. An error in shape calculation could lead to an undersized allocation, but the code does not show the subsequent write pattern that would cause a heap overflow. The vulnerability pattern is less direct.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The most relevant similarity is the potential for integer issues in shape calculations. The target code performs division (`tensor.dim_size(3) / num_groups`) and multiplication when computing shuffled shapes. If `num_groups` is zero or negative, or if dimensions are extremely large, it could lead to unexpected behavior. However, the code uses `int64_t` and likely has upstream validation. The specific integer overflow in mathematical computations for codebooks is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2011-1678_after_exclude_100:555756dc:vulspec": {
    "timestamp": "2026-01-16T21:24:13.649593",
    "cve_id": "CVE-2011-1678",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "555756dc",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a filesystem utility function for updating the mount table. The domains (regex parsing vs. system administration), vulnerability types (memory corruption vs. potential privilege/race issues), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management. The target code manages a file (mtab) with locking and signal blocking, but does not involve complex dynamic memory allocation or freeing of structures in a way that would lead to a use-after-free pattern similar to the MiniSSDPd case.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2011-3603 involves a privilege management flaw where a daemon continues with elevated privileges after a security mechanism (privilege separation) fails. The target code also deals with privilege: it calls `setreuid()` to drop privileges and uses `toggle_dac_capability()` (likely manipulating capabilities like CAP_DAC_OVERRIDE). If an error occurs after `setreuid` but before the capability is dropped, or if `toggle_dac_capability` fails, the process might retain elevated access. The pattern of \"partial privilege drop failure\" is similar, though the specific mechanisms (privsep vs. capability toggling) differ.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network protocol file transfer. The target code performs file I/O with fixed-size buffers (`MTAB_OPTIONS_LEN`) and uses safe string functions (`strlcat`). There are no dynamic memory allocations based on user-controlled integers that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-1642 is an out-of-bounds read in a network authentication protocol parser. The target code reads/writes a structured file (/etc/mtab) but does not parse complex, variable-length network packets. The data flow is simple and local.",
        "case_metadata": {
          "cve_id": "CVE-2010-1642"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double-free in a file parser. The target code has a single `calloc` and a corresponding `SAFE_FREE`, with no complex error paths that would free the same pointer twice. The memory management is straightforward.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in a kernel FUSE ioctl handler. The target code is a userspace utility with no kernel interaction or iovec manipulation. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13001 is an out-of-bounds read in a network packet decoder. The target code reads a file descriptor with `fstat` and writes with `addmntent`, but does not perform low-level, unbounded memory copies of external data.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition in a filesystem's node ID management. The target code uses file locking (`lock_mtab()`) and signal blocking to protect against concurrent access to the mtab file. This shows a concern for synchronization, but the context is different (userspace file update vs. kernel in-memory data structure). The pattern of using locks to prevent corruption is similar at a high level, but the specific race condition vulnerability (check-then-use) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow in an image codec due to incorrect size calculation. The target code uses a fixed-size buffer (`MTAB_OPTIONS_LEN`) for options, preventing overflow. There are no complex size calculations based on image data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-40299_before_exclude_100:8e58a059:vulspec": {
    "timestamp": "2026-01-16T21:24:14.390581",
    "cve_id": "CVE-2022-40299",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8e58a059",
    "scores": [
      {
        "score": 2,
        "reasoning": "CWE-416 (Use After Free) is the primary issue in CVE-2016-3179. The target code does manage memory (omAlloc/omFree), but there is no clear pattern of using a pointer after it has been freed. The error handling frees resources before returning. The system domains (network daemon vs. local utility) and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2010-1642 involves CWE-125 (Out-of-bounds Read) due to insufficient validation of a length field in a network protocol. The target code performs file I/O and string manipulation but does not parse complex binary structures or network packets. There is no direct similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2010-1642"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-18313 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code uses strlen on a body which could theoretically be problematic if not NUL-terminated, but this is not the core functionality. The domains (parsing engine vs. editor launcher) and vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-1838 is an out-of-bounds read in an XML parser. The target code does not parse structured markup languages. While both involve reading data, the vulnerability mechanism (parser state corruption) and code patterns are not present in the simple file reading via fread.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2011-1003 is a Double Free (CWE-415). The target code uses omFree and omAlloc but shows no obvious double-free pattern. However, there is a general similarity in manual memory management which could lead to similar resource management errors if the control flow were more complex, but the current logic appears safe.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write. The target code uses `strlen` and `sprintf` which, if inputs were uncontrolled, could lead to buffer overflows. The `sprintf` into `filename` is safe due to fixed offset and pid. The `sprintf(p,\"%s %s\",editor,filename)` is more concerning but uses allocated space. Weak relevance due to potential for buffer overflows in command construction, but the primary integer overflow mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-14151 is a heap buffer overflow due to insufficient allocation in an image codec. The target code allocates based on file length (`len`). If `len` came from an untrusted file, it could be a similar issue, but here `len` is derived from `ftell` on a file just written and read locally. The domains and specific allocation patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-25034 is an integer overflow in domain name parsing leading to an out-of-bounds write. The target code performs arithmetic with `strlen` and addition, but the sizes are small and not attacker-controlled in a way that would wrap. The domains (DNS resolver vs. local editor) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-15166 is CWE-20 (Improper Input Validation) in a network packet parser. The target code reads from a file (`myfread`) into an allocated buffer. If the file content is malicious, lack of validation could be an issue, but the code trusts the file it just created. There is a tangential similarity in processing external data, but the attack surface (local file vs. network packet) and vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-14164 is an out-of-bounds write due to missing buffer size validation when writing image data. The target code writes to a file, not a fixed-size buffer in memory (except for the `sprintf` into allocated `p`, which is correctly sized). The core vulnerability mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      }
    ]
  },
  "CVE-2016-7132_before_exclude_100:ffbb0fdf:vulspec": {
    "timestamp": "2026-01-16T21:24:15.059886",
    "cve_id": "CVE-2016-7132",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ffbb0fdf",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3179 is a Use-After-Free in a network daemon (MiniSSDPd). The target code is PHP's WDDX deserialization function. While both involve memory management, the domain (network protocol vs. data deserialization), attack surface (local socket vs. crafted data), and specific error patterns (uninitialized pointers in structures vs. stack and hash table management) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-17807 is a Missing Authorization flaw in the Linux kernel's KEYS subsystem. The target code performs data deserialization in user-space PHP with no apparent authorization checks related to its core vulnerability pattern. The domains (kernel security vs. application data parsing) and vulnerability classes (CWE-862 vs. potential memory/object injection issues) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-9226 is an Out-of-bounds Write in the Oniguruma regex library due to octal escape sequence validation. The target code is a WDDX deserializer. While PHP uses Oniguruma, this specific code path does not process regular expressions. The vulnerability mechanism (parsing regex character classes) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-11222 is an Out-of-bounds Write during binary data parsing in a multimedia framework. The target code also parses data (WDDX/XML) and performs writes (to hash tables, object properties). There is a superficial similarity in parsing untrusted input. However, the specific flaw (hex string parsing without bounds checks) and context (multimedia vs. serialization) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-0380 is an Information Exposure via uninitialized stack buffer in Tor's logging. The target code has no logging component shown. While both handle network-originating data, the vulnerability pattern (CWE-532/457) is not mirrored in the provided code, which focuses on data structure manipulation, not information leakage via logs.",
        "case_metadata": {
          "cve_id": "CVE-2017-0380"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2011-1003 is a Double Free in ClamAV's file parser. The target code is also a parser (WDDX) and contains complex memory management with `efree()`, `zval_ptr_dtor()`, and reference counting (`Z_DELREF`). The pattern of managing allocated resources (like `ent1->varname`) across multiple error and success paths creates a similar context where double-free or use-after-free bugs could occur due to state management errors.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-9228 is another Oniguruma Out-of-bounds Write due to uninitialized state. As with case 3, the target code does not involve regex compilation or character class state machines. The code patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-9228"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2015-0241 is a Buffer Overflow in PostgreSQL's numeric formatting. The target code performs string operations (e.g., `strcmp`, `strlen`) and base64 decoding, but does not show classic fixed-size buffer copies without length checks. Its memory safety relies on Zend memory manager and hash table APIs. The vulnerability pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-9227 is an Out-of-bounds Read in Oniguruma's regex engine. The target code does not perform similar pattern matching or character position calculations that could lead to out-of-bounds reads from a pattern-based offset.",
        "case_metadata": {
          "cve_id": "CVE-2017-9227"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-9229 is a NULL Pointer Dereference in Oniguruma's search function. The target code does dereference pointers (e.g., `ent1->data`), but they are checked via stack top verification and type checks. The context (regex matching state corruption) is not applicable to this deserialization stack machine.",
        "case_metadata": {
          "cve_id": "CVE-2017-9229"
        }
      }
    ]
  },
  "CVE-2021-23521_after_exclude_100:0c9ba7e2:vulspec": {
    "timestamp": "2026-01-16T21:24:15.467755",
    "cve_id": "CVE-2021-23521",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0c9ba7e2",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve ZIP archive handling, but the vulnerability types differ significantly. CVE-2018-16548 is a memory leak (CWE-772) in a low-level parsing library (zziplib) due to missing cleanup on error paths. The target code is a higher-level extraction function in JUCE, focusing on file system operations, path validation, and symlink handling. The attack surface (malicious ZIP) is similar, but the vulnerability patterns (resource management vs. path traversal/symlink issues) are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-16548"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Same as Case 1. The target code does not show the same low-level memory management patterns or error path cleanup issues central to CVE-2018-16548. Its primary security concerns are path validation and symbolic link safety, not memory resource leaks during parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-16548"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow (CWE-119) in an image codec (OpenJPEG) during memory allocation for encoding. The target code is a file extraction routine for ZIP archives. The domains (image processing vs. archive extraction), vulnerability types (buffer overflow vs. path/symlink issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14152 is a use-after-free (CWE-416) in an image codec's parameter validation. The target code performs sequential file operations with RAII-style management (std::unique_ptr) and does not exhibit complex pointer lifecycle management or the specific parameter validation flaws relevant to this CVE.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write (CWE-787) in a network protocol library (LibVNCServer) due to alignment issues in WebSocket handling. The target code deals with local file system operations during ZIP extraction. The domains, data sources (network streams vs. archive entries), and vulnerability patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-12982 is a buffer overflow/allocation issue (CWE-119) in a BMP-to-JPEG2000 converter due to unchecked header values. The target code validates paths and handles streams but does not parse complex binary headers in a way that leads to similar integer overflow or allocation miscalculation vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2014-9652 is an out-of-bounds read (CWE-119) in a file type detection utility due to improper validation of Pascal string lengths. The target code does not parse complex, variable-length data structures from untrusted files in a similar manner. Its parsing is limited to reading entry names as strings and streaming content.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14164 is an out-of-bounds write (CWE-787) in an image codec when writing marker segments. The target code writes files to the filesystem using controlled output streams, not writing raw binary data to fixed-size buffers where size validation is critical. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2015-1191 is a path traversal vulnerability (CWE-22) in a compression tool (pigz). The target code performs a very similar function: extracting files from an archive (ZIP) to a target directory. It explicitly includes path validation (`targetFile.isAChildOf(targetDirectory)`) to prevent directory traversal, which is the core mitigation for this CVE type. The attack surface (malicious archive with crafted entry paths) and the defensive code pattern are highly similar, providing valuable reference for testing the robustness of the path containment check.",
        "case_metadata": {
          "cve_id": "CVE-2015-1191"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-9098 is an information leak (CWE-200) via uninitialized memory in an image decoder. The target code writes data from an input stream directly to an output stream or creates symlinks. While it handles untrusted data, there is no indication of buffer allocation without initialization that could leak memory contents. The vulnerability patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9098"
        }
      }
    ]
  },
  "CVE-2011-1678_before_exclude_100:1e7e2d84:vulspec": {
    "timestamp": "2026-01-16T21:24:15.909574",
    "cve_id": "CVE-2011-1678",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1e7e2d84",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a mount table management function in a system utility, dealing with file operations and privilege management. CVE-2018-18313 is a regex parsing vulnerability (CWE-125) in Perl, involving complex string parsing with embedded NUL bytes. The domains, vulnerability types, and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free (CWE-416) in a network daemon (MiniSSDPd) related to memory management of service structures. The target code performs synchronous file I/O (mtab updates) with signal blocking and privilege manipulation. There is no dynamic memory management of complex structures or similar error paths that could lead to a use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2011-3603 involves a privilege management flaw (CWE-250) where a daemon (radvd) continues running with root privileges after privilege separation fails. The target code explicitly manipulates privileges using `setreuid()` and `toggle_dac_capability()`. The core similarity is the pattern of dropping privileges (or capabilities) and the critical need to ensure the process does not continue with unintended elevated rights if the security transition fails. The error handling after `setreuid` and `toggle_dac_capability` is crucial in both contexts.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write (CWE-787) in a network protocol library (LibVNC). The target code performs simple string concatenation with fixed-size buffers using `strlcat`, which prevents overflows, and has no complex integer arithmetic or dynamic memory allocation based on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2010-1642 is an out-of-bounds read (CWE-125) in a network protocol authentication handler (Samba). The target code reads from local function arguments and writes to a file. It does not parse complex binary network packets or have length fields that could be maliciously manipulated to cause a buffer over-read.",
        "case_metadata": {
          "cve_id": "CVE-2010-1642"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double-free (CWE-415) in a file parser (ClamAV). The target code has a single `calloc` allocation for `mountent.mnt_opts` and a corresponding `SAFE_FREE`. There is no complex error path that could free the same memory twice, and the memory management pattern is simple and linear.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in a kernel FUSE ioctl handler. The target code is a userspace utility with no ioctl handling, kernel interaction, or complex buffer management from untrusted sources. The domains (kernel vs. userspace utility) and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13001 is an out-of-bounds read in a network packet decoder (tcpdump). The target code does not decode network packets. Its string operations use bounded functions (`strlcat`), and the data sources (function arguments) are not analogous to raw, untrusted network data.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition (CWE-362) in a kernel filesystem's (F2FS) node ID management. The target code uses file locking (`lock_mtab`) to serialize access to a shared resource (the mtab file), which is the correct pattern to prevent race conditions in this context. The code is not a concurrent kernel subsystem and does not exhibit a check-then-act race pattern on shared memory.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow in an image codec (OpenJPEG) due to incorrect size calculation. The target code uses a fixed-size buffer (`MTAB_OPTIONS_LEN`) for string options and safe concatenation functions. There is no complex arithmetic for buffer sizing or encoding/decoding of binary data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2010-1311_before_exclude_100:91fa0fa4:vulspec": {
    "timestamp": "2026-01-16T21:24:16.024271",
    "cve_id": "CVE-2010-1311",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "91fa0fa4",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The target code is the exact function (qtm_decompress) from ClamAV's mspack module that contains CVE-2010-1311. Both involve Quantum decompression in CAB archives, with vulnerabilities stemming from improper input validation (CWE-20) leading to boundary checks bypass and potential out-of-bounds writes. The code patterns, context (compression/decompression), and vulnerability type are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-14151 involves memory allocation and buffer sizing for JPEG 2000 encoding in OpenJPEG. The target code is a decompression routine with different logic (sliding window LZ77/arithmetic coding) and does not involve similar allocation or padding calculations. The vulnerability type (heap overflow from insufficient padding) is not directly applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon (MiniSSDPd) related to service registration and socket handling. The target code is a file decompression function with no network components, dynamic memory management of complex structures, or similar error path cleanup patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-18313 involves regex pattern parsing with NUL byte handling leading to out-of-bounds reads. The target code processes compressed binary data, not text patterns. While both require careful input validation, the parsing logic, data structures, and specific vulnerability triggers (embedded NULs vs. match offsets) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2011-1003 is also in ClamAV (double free in VBA extraction), sharing the same broader system. However, the vulnerability type (double free vs. boundary validation), component (document parsing vs. compression), and code patterns (memory state management vs. bitstream decoding) differ significantly. The commonality is the need for robust error handling in a security-critical parser.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves integer overflow/wraparound (CWE-190) leading to out-of-bounds write in a protocol handler. The target code performs arithmetic on match_offset and window_posn which, if improperly validated, could lead to similar issues (as hinted by the check `if (match_offset > window_posn)`). The pattern of validating offsets/window boundaries is conceptually similar, though the specific integer overflow vector is less obvious in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code validates lengths/offsets (e.g., checking `j > (int) qtm->window_size`) and reads from a bitstream, not a packet buffer. Both require careful bounds checking, but the domain (network protocol vs. compression algorithm) and data access patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-15166 involves improper input validation (CWE-20) in a network protocol parser, similar to case 7. The target code also performs input validation (e.g., on match_offset). The general principle of validating externally supplied integers before using them as offsets is shared, but the application context is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-13219 is an integer overflow in an audio codec's mathematical computations. The target code performs arithmetic (e.g., `match_offset - window_posn`, `match_length + extra`) which could theoretically overflow if inputs are malicious, but the code uses unsigned ints and the context is different (compression model decoding vs. codebook calculation). The risk pattern is similar but not prominent in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to insufficient bounds checking on tag processing. The target code reads from a bitstream and window buffer with explicit checks. Both involve parsing structured data with potential for boundary violations, but the parsing models (grammar-based vs. stream decoding) and data structures are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2021-23521_before_exclude_100:a58335b1:vulspec": {
    "timestamp": "2026-01-16T21:24:16.378318",
    "cve_id": "CVE-2021-23521",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a58335b1",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve ZIP archive processing, but the vulnerability types differ significantly. CVE-2018-16548 is a memory leak (CWE-772) in a low-level parsing function due to missing cleanup on error paths. The target code is a higher-level extraction function focusing on file system operations (writing files, creating symlinks) and does not show similar low-level memory management patterns or error path resource cleanup issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-16548"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Same reasoning as Case 1. The target code and the VulSpec case both process ZIP files, but the core vulnerability mechanism (missing resource release on error) is not apparent in the provided `uncompressEntry` function, which uses RAII (`std::unique_ptr`) for the stream and returns error results without complex, stateful cleanup of allocated structures.",
        "case_metadata": {
          "cve_id": "CVE-2018-16548"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow (CWE-119) in an image codec's memory allocation for encoding. The target code is a ZIP extraction routine performing file I/O and symlink creation. The domains (image processing vs. archive extraction), vulnerability types (heap overflow vs. path traversal/symlink risks), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14152 is a Use-After-Free (CWE-416) in JPEG 2000 parameter validation. The target code does not involve complex internal state management of image parameters or dynamic memory that could lead to UAF. Its primary risks are related to file system operations, not memory corruption from parsed data structures.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write (CWE-787) due to alignment issues in a network protocol (WebSocket) decoder. The target code deals with file extraction, stream copying, and symlink creation. There are no low-level bit/byte manipulations of network data assuming alignment, making the vulnerability pattern irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-12982 is a buffer overflow/allocation issue (CWE-119) due to unchecked header values in a BMP-to-JPEG2000 converter. The target code reads from a validated ZIP stream and writes to the filesystem. It does not parse complex binary image headers where integer overflows in allocation calculations are a concern.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2014-9652 is an out-of-bounds read (CWE-119) in a file type detection utility parsing Pascal strings. The target code does not parse length-prefixed strings from untrusted data in a way that could cause OOB reads. Its parsing is limited to ZIP metadata already processed by the library.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14164 is an out-of-bounds write (CWE-787) in a JPEG 2000 marker writer. The target code writes file contents via `FileOutputStream`, which is a higher-level abstraction, and does not perform manual, unsafe writes to fixed-size buffers based on untrusted size values.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2015-1191 is a Path Traversal (CWE-22) vulnerability in a compression tool (pigz). The target code shares a highly similar context: extracting files from an archive (ZIP) to a target directory. The key similarity is the construction of `targetFile` using `targetDirectory.getChildFile(entryPath)` without any apparent sanitization of `entryPath` (e.g., stripping `..` or leading slashes). If `entryPath` contains directory traversal sequences (like `../../etc/passwd`), it could lead to file writes outside `targetDirectory`. The trigger condition (malicious archive entry name) and the vulnerability type are closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2015-1191"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-9098 is an information leak (CWE-200) via uninitialized memory in an image decoder. The target code does not allocate pixel buffers or have paths where uninitialized memory could be exposed. Its data flow involves reading from a stream and writing it directly to a file or creating a symlink.",
        "case_metadata": {
          "cve_id": "CVE-2017-9098"
        }
      }
    ]
  },
  "CVE-2021-41206_after_exclude_100:5388e22d:vulspec": {
    "timestamp": "2026-01-16T21:24:17.826802",
    "cve_id": "CVE-2021-41206",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5388e22d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a grouped convolution operator in a machine learning framework (likely TensorFlow), performing tensor shuffling and spatial convolution. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library (libgcrypt) related to non-constant-time elliptic curve operations. The domains (ML vs. cryptography), vulnerability types (logic/performance vs. timing side-channel), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 is a vulnerability in BIND9's DNSSEC key processing, involving broken cryptographic algorithms and NULL pointer dereference. The target code performs numerical tensor operations and memory allocations for convolution. There is no cryptographic logic, key processing, or similar error handling patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-14152 is a Use-After-Free in an image codec due to improper bounds checking and state management. The target code involves tensor allocation and manipulation but uses RAII-style resource management (Tensor objects) and does not exhibit manual memory management or pointer-based state inconsistencies that could lead to UAF. The similarity is limited to being in a data processing domain.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-3603 is a privilege management vulnerability in a network daemon due to improper input validation of initialization state. The target code is a computational kernel function with no privilege separation, process control, or external input validation of that nature.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 is an Integer Overflow in a file parser leading to miscalculated positions. The target code performs arithmetic on tensor dimensions (e.g., `in_depth / patch_depth`, `tensor.dim_size(3) / num_groups`). While integer overflows are a potential concern in dimension calculations, the code uses 64-bit integers (`int64_t`) and the operations are divisions, not multiplications or additions that typically overflow. The pattern is superficially similar but the risk level and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7970 is a Buffer Overflow in a subtitle renderer due to unchecked parameters in a mathematical effect calculation. The target code performs mathematical operations in a convolution loop. Both involve loops and calculations, but the target code's buffer sizes are determined by allocated tensor shapes, and there is no direct pattern of calculating array indices from untrusted parameters without bounds checks. The vulnerability mechanism is not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2009-3909 is an Integer Overflow leading to a Heap Buffer Overflow in an image file parser. Similar to case 5, the target code has dimension calculations. The allocation `ctx->allocate_temp` uses the calculated `post_shuffle` dimensions. If an integer overflow occurred in those calculations, it could lead to an undersized allocation and a buffer overflow in subsequent tensor operations. This provides a conceptual link, but the code does not show the specific overflow-prone arithmetic (like multiplication of large dimensions).",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser due to unsafe string parsing. The target code does not parse string input, does not use stack buffers, and does not have analogous buffer copy operations. The only vague similarity is processing input data.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a Heap Buffer Overflow in an image encoder due to insufficient padding allocation. The target code allocates temporary tensors (`allocate_temp`) and performs in-bounds writes via Eigen tensor operations. While both involve memory allocation for processing data, the target code's allocation size is directly derived from tensor metadata, and the overflow mechanism (padding miscalculation) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-13219 is an Integer Overflow in an audio decoder during codebook size calculations. This is the most relevant among the cases because it shares the theme of integer overflow in size calculations derived from input data (like `num_groups = in_depth / patch_depth`). However, the target code's calculations are simpler divisions, and the subsequent allocation uses these values indirectly. The potential for an overflow exists if `in_depth` and `patch_depth` lead to an incorrect `num_groups`, but the pattern is not as direct as the vulnerable computations in the Vorbis decoder.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2022-2126_after_exclude_100:01f7ac1d:vulspec": {
    "timestamp": "2026-01-16T21:24:18.982307",
    "cve_id": "CVE-2022-2126",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "01f7ac1d",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a spell suggestion algorithm in Vim that walks a trie structure. CVE-2018-14353 is an integer underflow in NeoMutt's IMAP string quoting. Both involve string processing, but the vulnerability type (integer underflow vs. potential buffer overflow in trie walking), domain (email client vs. text editor spell check), and code patterns (protocol parsing vs. recursive tree traversal) are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-14361 is an improper input validation/memory handling issue in NeoMutt's NNTP header fetching. The target code is a complex state machine for spell suggestions with extensive stack and array usage but includes bounds checks (e.g., MAXWLEN). The vulnerability type (memory allocation failure handling) and context are not similar. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-14361"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-5094 is an integer overflow in PHP's HTML entity conversion leading to memory corruption. The target code performs string operations within fixed-size stack buffers (MAXWLEN) and includes length checks. While both involve string transformation and potential length calculation issues, the target code's primary risk is buffer overflow within its fixed arrays, not integer overflow in dynamic allocation. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5094"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2018-14350 is a stack buffer overflow in NeoMutt's IMAP date parsing due to missing bounds checking. The target code uses fixed-size stack buffers (tword[MAXWLEN], preword[MAXWLEN*3], etc.) and copies data (e.g., STRCPY, mch_memmove). It has some length-aware operations but could be vulnerable to similar issues if input exceeds buffer sizes without proper checks. However, the domain and specific parsing logic are different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-14350"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-6905 is an out-of-bounds read in libgd's TGA RLE decompression. The target code reads from tree structures (byts/idxs arrays) and could theoretically have out-of-bounds reads if tree data is corrupted, but the code's logic is about traversing a known structure, not parsing untrusted compressed data. The vulnerability pattern is different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-6905"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-16357 is a buffer overflow/Integer overflow in radare2's ELF parser due to insufficient validation of size fields. The target code uses external data (spell files) to populate its trees. If this data is malicious, similar issues could arise (e.g., arridx exceeding array bounds). However, the code patterns (parsing binary structures vs. walking a trie) and vulnerability triggers are different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-16357"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2016-4301 is a stack buffer overflow in libarchive's mtree device number parsing due to writing more comma-separated values than a fixed buffer can hold. The target code uses fixed-size stack buffers (e.g., compflags[MAXWLEN]) and could overflow if not careful with indices (e.g., ts_complen). The pattern of writing to a fixed array based on untrusted input is similar, but the context is different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-4301"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-16359 is a NULL pointer dereference/pointer arithmetic issue in radare2's ELF parser. The target code uses pointer arithmetic (e.g., arridx + sp->ts_curi) but generally within bounds of arrays obtained from spell data. NULL dereference is less likely as the code doesn't heavily dereference pointers from untrusted data. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-16359"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-18397 is a buffer overflow in GNU FriBidi due to a counter exceeding array bounds when processing nested structures. The target code uses a stack array (stack[MAXWLEN]) and a depth counter; if the trie is too deep, depth could exceed MAXWLEN, causing a stack overflow. The pattern of recursive/iterative processing with a depth limit is similar. However, the target code checks depth >= 0 && depth < MAXWLEN in loops? It checks depth >= 0 but not explicitly depth < MAXWLEN before incrementing. The go_deeper macro might have checks. Moderate-weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-18397"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2019-11222 is an out-of-bounds write in GPAC's binary data parser due to insufficient bounds checking during hex parsing. The target code writes to buffers (tword, preword) with indices like ts_twordlen, but these are controlled by the algorithm, not direct parsing of untrusted hex data. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      }
    ]
  },
  "CVE-2010-1311_after_exclude_100:cc1e3461:vulspec": {
    "timestamp": "2026-01-16T21:24:19.007870",
    "cve_id": "CVE-2010-1311",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cc1e3461",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. Both involve decompression logic (Quantum vs. CAB Quantum) with similar vulnerability patterns: improper input validation leading to out-of-bounds writes. The target code performs match offset/length validation against window boundaries (window_size), which is the exact failure point in CVE-2010-1311. The functional domain (compression/decompression), error handling patterns, and potential for crafted input to bypass bounds checks are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-14151 is about insufficient memory allocation (padding) for an arithmetic coder in an image codec. The target code uses arithmetic coding but focuses on stream decoding and window buffer management, not on calculating allocation sizes with padding. The vulnerability patterns (heap overflow due to size miscalculation vs. out-of-bounds write due to invalid offsets) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's service state management. The target code is a decompression function with no dynamic memory allocation/free of pointers within its main logic; it operates on a pre-allocated window buffer. The code patterns and vulnerability classes are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code could theoretically have out-of-bounds reads if bit/byte reading macros (QTM_READ_BITS, QTM_GET_SYMBOL) lack checks, but its primary vulnerability pattern is out-of-bounds write. The domains (string parsing vs. binary stream decompression) and typical flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2011-1003 is a double-free in ClamAV's VBA extractor, sharing the same broader system (ClamAV) as Case 1. The relevance comes from similar error handling patterns (`return qtm->error = ret;`) and the context of parsing untrusted file formats. However, the specific vulnerability type (memory corruption vs. double-free) and code patterns are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in allocation. The target code has integer-heavy operations (match_offset, window_posn calculations) and checks for boundaries, which is the defensive code needed to prevent such issues. The relevance is in the common theme of integer handling and bounds validation for preventing corruption, though the trigger (allocation overflow vs. offset validation) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code reads a compressed bitstream and must validate lengths (match_length) and offsets against boundaries. The pattern of validating fields from untrusted input against a buffer size is similar, though the data source and specific vulnerability class (read vs. write) differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Similar to Case 7, CVE-2019-15166 involves improper input validation in a network protocol parser leading to potential memory issues. The target code's validation of `match_offset > window_posn` and `j > (int) qtm->window_size` exemplifies the kind of bounds checking that, if missing or flawed, could cause a similar vulnerability. The domains differ but the input validation principle is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-13219 is an integer overflow in an audio codec's codebook calculation. The target code uses arithmetic coding and reads variable-length fields (extra bits) which involve integer operations. While a direct integer overflow is not obvious in the shown code, the decoding logic (e.g., `match_offset = qtm->position_base[sym] + extra + 1`) could be susceptible if `position_base` and `extra` are large. The domain (codec decoding) is similar, but the specific flaw pattern is less directly matched.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking during end tag processing. The connection is the general need for bounds checking when parsing structured data. However, the target code deals with binary compression formats and explicit length/offset checks, while the XML vulnerability is more about parser state and string handling. The similarity is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-28463_after_exclude_100:d22eea59:vulspec": {
    "timestamp": "2026-01-16T21:24:19.186423",
    "cve_id": "CVE-2022-28463",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d22eea59",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve image format parsing (BMP vs CIN/DPX) and memory safety concerns, but the specific vulnerability pattern differs. CVE-2017-12982 is about unchecked header values leading to allocation failure, while the target code performs bounds checks (e.g., checking cin.file.image_offset, validating blob reads). The functional domain is similar but the vulnerability mechanism is not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate-weak relevance. Both are image file parsers (XWD vs CIN) with potential for out-of-bounds writes due to header validation issues. The target code reads many header fields into a fixed-size struct and could theoretically have similar issues if array bounds are not respected, but the code shows careful offset tracking and uses safe functions like CopyMagickString. The similarity is in the general problem domain, not the specific flaw.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's service registration, involving complex state management. The target code is a straightforward image file decoder with linear resource allocation/deallocation (AcquireImage, DestroyImage). No similar pointer management or error path cleanup patterns exist.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-1000222 is a double-free in BMP compression error handling. The target code allocates resources (QuantumInfo, StringInfo) but frees them consistently with DestroyQuantumInfo/DestroyStringInfo. Error paths use ThrowReaderException which likely performs cleanup. The resource management pattern is different and safer.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code reads binary image data with explicit length checks (ReadBlob, count checks). No string parsing or NUL-termination issues are apparent. Different vulnerability class and domain.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a file transfer protocol. The target code has similar integer handling: it reads 32-bit values (ReadBlobLong) and uses them in calculations (e.g., image->columns * image->rows). It performs a size check: `if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))`. This shows awareness of the issue, making it relevant for defensive reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are ImageMagick coders (PSD vs CIN) parsing binary file formats with similar patterns: reading headers, tracking offsets, processing resource/data blocks. CVE-2016-7532 is an out-of-bounds read due to insufficient bounds checking. The target code shows similar offset management and uses ReadBlob with length checks. The pattern of reading `cin.file.user_length` and checking `if (cin.file.user_length > GetBlobSize(image))` is directly comparable to the PSD vulnerability. The code structure and potential attack surface are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7532"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate-strong relevance. CVE-2016-8670 is a buffer overflow in PHP's GD wrapper due to incorrect bounds checking. The target code uses GetBytesPerRow to calculate buffer lengths and imports pixels with ImportQuantumPixels, which should perform bounds checking. The relevance is in the image data processing pipeline and the need to validate sizes. The code uses `length=GetBytesPerRow(...)` and checks `if ((size_t) count != length)`, showing similar concerns.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-20840 is an out-of-bounds write due to unaligned memory access in a WebSocket decoder. The target code reads binary data but uses byte-by-byte or structured reads (ReadBlob, ReadBlobLong) that handle endianness but don't involve direct word-aligned memory access on network data. Different protocol and memory access patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-20840 is a resource management error (memory leak) in image scaling error paths. The target code allocates resources (image, quantum_info) and has error paths with ThrowReaderException. While both involve image processing resource cleanup, the target code's error handling appears more structured with explicit destruction calls. The similarity is only in the general domain of image processing error handling.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      }
    ]
  },
  "CVE-2022-2126_before_exclude_100:bf77af48:vulspec": {
    "timestamp": "2026-01-16T21:24:19.327246",
    "cve_id": "CVE-2022-2126",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bf77af48",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a spell suggestion trie walker in Vim, performing string matching and transformation. CVE-2018-14353 is an integer underflow in NeoMutt's IMAP string quoting. The domains (text editor vs. email client), functionality (spell checking vs. protocol handling), and vulnerability patterns (tree traversal vs. buffer length calculation) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not involve network protocol handling (NNTP) or memory allocation failure management as in CVE-2018-14361. It is a local, stack-based algorithm for generating spelling suggestions with fixed-size arrays (e.g., `tword[MAXWLEN]`). The vulnerability patterns (input validation leading to improper error handling) do not align.",
        "case_metadata": {
          "cve_id": "CVE-2018-14361"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve string processing, but the contexts differ vastly. CVE-2016-5094 is an integer overflow in PHP's HTML entity conversion leading to memory corruption. The target code performs character-by-character traversal and scoring within fixed buffers, with careful length checks (e.g., `depth >= 0 && depth < MAXWLEN`). While both handle strings, the vulnerability mechanism (integer overflow in length calculation) is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-5094"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14350 is a stack buffer overflow in NeoMutt's IMAP date parsing due to missing bounds checking. The target code also uses stack buffers (`tword[MAXWLEN]`, `preword[MAXWLEN * 3]`) and copies/processes string data. There is a superficial similarity in the potential for buffer overflows if indices exceed bounds, but the target code appears to have extensive index checks (e.g., `depth < MAXWLEN - 1`, loop conditions on `ts_curi` and `byts[arridx]`). The attack surface (network protocol vs. local dictionary) is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14350"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-6905 is an out-of-bounds read in an image library's RLE decompression. The target code walks a trie data structure for spell checking. There is no similarity in functionality (image parsing vs. dictionary lookup), data structures (compressed pixel data vs. character arrays), or vulnerability pattern (malformed compressed data leading to OOB read).",
        "case_metadata": {
          "cve_id": "CVE-2016-6905"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-16357 involves parsing malicious ELF file structures with invalid size fields, leading to memory corruption. The target code processes trusted dictionary files (internal trie structures: `byts`, `idxs`) and user-input misspelled words. It does not parse complex binary file formats or allocate memory based on untrusted size fields. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16357"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-4301 is a stack buffer overflow in libarchive's mtree device number parsing due to a fixed-size array (`numbers[8]`) being overrun. The target code also uses fixed-size stack arrays (`stack[MAXWLEN]`, `compflags[MAXWLEN]`). Both involve parsing formatted input (dictionary traversal vs. archive metadata). The relevance is weak because the parsing logic and data formats are completely different, but the pattern of using fixed stack buffers for parsed elements is a common point.",
        "case_metadata": {
          "cve_id": "CVE-2016-4301"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-16359 is a NULL pointer dereference/pointer arithmetic issue in ELF parsing. The target code does not perform complex pointer arithmetic on untrusted data; it uses array indices to navigate static trie data. There is no similarity in the vulnerability trigger or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16359"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-18397 is a buffer overflow in a Unicode bidirectional algorithm due to nested levels exceeding a fixed limit. The target code implements a state machine with a stack (`trystate_T stack[MAXWLEN]`) and tracks depth. Both algorithms involve managing a depth level and have a maximum bound (`MAXWLEN`). The vulnerability pattern of exceeding a predefined maximum depth due to malicious/complex input is conceptually similar, though the application domains (text layout vs. spell suggestion) are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-18397"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-11222 is an out-of-bounds write in a multimedia framework's hex parsing function. The target code does not parse hex strings or perform similar binary data conversions. Its operations are on character arrays for dictionary matching. No meaningful similarity in code patterns or vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      }
    ]
  },
  "CVE-2022-30292_before_exclude_100:e650447d:vulspec": {
    "timestamp": "2026-01-16T21:24:19.585196",
    "cve_id": "CVE-2022-30292",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e650447d",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a thread call function in a scripting language runtime (likely Squirrel). It involves moving parameters between virtual machine stacks. CVE-2016-3179 is a Use-After-Free in a network daemon (MiniSSDPd) related to socket message handling and memory management of service structures. The domain (scripting VM vs. network protocol), vulnerability type (stack/object manipulation vs. UAF), and code patterns are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code performs stack operations and error propagation in a VM. CVE-2018-20760 is an out-of-bounds write in a text encoding conversion function (UTF-8/UTF-16) within a multimedia framework. The core issue is improper handling of return codes leading to buffer overflows. The target code shows no buffer operations, string handling, or similar error code validation patterns. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "The target code manipulates VM stack objects and calls functions. CVE-2017-14151 is a heap buffer overflow in an image codec due to incorrect size calculation for padding. While both involve resource management (memory/stack objects), the vulnerability mechanism (arithmetic error leading to OOB write) and domain (image encoding vs. VM interpreter) are dissimilar. The target code's `sq_move` operations are bounded by stack indices, not calculated sizes. Weak relevance at best.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code is a high-level VM operation. CVE-2019-20840 is an out-of-bounds write in a WebSocket decoder due to unaligned memory access assumptions. The vulnerability is deeply tied to low-level memory layout and network data parsing. The target code operates on abstract VM objects (`SQObjectPtr`) and uses API calls (`sq_move`, `sq_call`), insulating it from such low-level memory corruption. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "The target code involves moving data between execution contexts (threads/VMs), which is conceptually related to buffer/data management between components, as in CVE-2016-8860 (Tor's buffer management). However, the Tor vulnerability is about missing sentinel values and low-level buffer overreads in C strings, while the target code uses a managed stack API. There's a weak similarity in the theme of data transfer between entities, but the implementation and vulnerability patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code is a VM interpreter function. CVE-2018-18313 is an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The domains (regex compilation vs. thread scheduling) and vulnerability patterns (string parsing OOB read vs. stack/error state management) are completely different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "There is a moderate conceptual link. CVE-2011-1003 is a double free in ClamAV triggered during error handling in a parsing module. The target code also has an error path (`return SQ_ERROR`) where it propagates an error object (`v->_lasterror = _thread(o)->_lasterror`). If the `_lasterror` object is not handled correctly after this assignment, it could lead to use-after-free or double free issues in the broader VM's garbage collector. The relevance is in the pattern of error state propagation between execution contexts, which can create complex ownership states. However, the specific code shown does not obviously contain the bug.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code performs stack indexing and function calls. CVE-2019-25034 is an integer overflow leading to OOB write in DNS name parsing. The target code uses `SQInteger` for indices but performs simple arithmetic (`i<(nparams+1)`) with no complex calculations that could overflow. The vulnerability types and domains are unrelated. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code is a well-defined VM operation. CVE-2017-9228 is an out-of-bounds write in a regex library due to an uninitialized state variable used as an array index. The target code shows no similar state machine or array indexing based on uninitialized data. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-9228"
        }
      },
      {
        "score": 3,
        "reasoning": "The target code includes error handling that propagates state and returns an error code. CVE-2011-3603 involves improper handling of an initialization failure (privilege separation), leading to continued execution in a privileged state. A weak analogy exists: if `sq_type(o) != OT_THREAD`, the function throws an error, which is proper validation. The relevance is minimal, limited to the generic concept of checking input/state and handling failure, but the specific security consequence (privilege escalation) is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2022-28463_before_exclude_100:a1898d82:vulspec": {
    "timestamp": "2026-01-16T21:24:27.256795",
    "cve_id": "CVE-2022-28463",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a1898d82",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve image format parsing (BMP vs CIN/DPX) and memory allocation, but the vulnerability specifics differ. CVE-2017-12982 is about an unchecked header value (biBitCount=0) leading to allocation failure, while the target code performs more extensive header validation (magick number, offset checks). The core issue (CWE-119) is similar, but the trigger condition and code pattern (allocation based on unvalidated user input) are not directly mirrored in the provided CIN reader.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate-weak relevance. Both are image file parsers (XWD vs CIN) that read structured headers. CVE-2013-1978 involves an out-of-bounds write due to mismatched color count and map entries. The target code reads many structured fields (like channel info arrays) but uses fixed loops (i < 8) and doesn't show a similar pattern of deriving one array size from an unchecked earlier field. The relevance is in the domain and the risk of parsing complex binary headers.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's state management. The target code is a synchronous image file decoder with linear resource allocation and cleanup (e.g., DestroyQuantumInfo). There is no apparent pattern of shared structures, error-handling leading to inconsistent state, or pointer reuse that matches the MiniSSDPd case.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-1000222 is a double-free during error handling in a BMP conversion function. The target code has error paths (ThrowReaderException) that destroy resources, but the pattern is different. Resources like `image` and `quantum_info` are freed in a clear, sequential manner (e.g., `DestroyImageList`, `DestroyQuantumInfo`). There's no visible \"free on error, then free again on cleanup\" pattern. The shared domain (image processing) provides minimal relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code reads binary data via `ReadBlob` functions which handle raw bytes. While it could theoretically read past a buffer if `length` is miscalculated, the code pattern (string parsing with embedded delimiters) and vulnerability mechanism are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate-strong relevance. CVE-2016-7532 is an out-of-bounds read in ImageMagick's PSD parser due to insufficient bounds checking when reading resource blocks. The target code is *also* from ImageMagick (ReadCINImage) and shares the same codebase patterns. It reads many fields from the file (offsets, lengths) and uses them in subsequent reads (e.g., `cin.file.user_length` used in `ReadBlob`). The check `if (cin.file.user_length > GetBlobSize(image))` is a critical bounds check. Missing similar checks for other derived lengths or offsets could lead to analogous out-of-bounds reads. The domain, library, and vulnerability pattern are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7532"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate-strong relevance. CVE-2016-8670 is a buffer overflow in PHP's GD wrapper (part of ImageMagick's ecosystem) due to incorrect bounds checking during data transfer. The target code contains the pattern `stream=ReadBlobStream(image,length,pixels,&count);` followed by `if ((size_t) count != length) break;` and `ImportQuantumPixels(...)`. If the `length` variable is incorrectly calculated (e.g., via integer overflow as in case 6) or if `pixels` buffer is too small, it could lead to a buffer overflow during the import. The code structure of reading a stream into a buffer and processing it is directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-20840 is an out-of-bounds write due to unaligned memory access in a WebSocket decoder. The target code performs byte-by-byte or structured reads via `ReadBlobLong`, `ReadBlobFloat` which handle endianness but are not typically vulnerable to alignment issues on modern CPUs in the same way. The code patterns and attack surfaces (network protocol vs. file parsing) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-20840 is a resource management error (memory leak) in an image scaling function during error handling. The target code allocates resources (e.g., `quantum_info=AcquireQuantumInfo`) and has error paths that jump to `ThrowReaderException`. It must ensure all such resources are freed before jumping. The pattern `quantum_info=DestroyQuantumInfo(quantum_info);` at the end is correct, but early returns on error could potentially leak if not careful. The relevance is in the domain and the need for robust error cleanup, but the specific leak pattern is not evident.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      }
    ]
  },
  "CVE-2022-23568_after_exclude_100:21725540:vulspec": {
    "timestamp": "2026-01-16T21:24:40.558416",
    "cve_id": "CVE-2022-23568",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "21725540",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a TensorFlow sparse tensor batch processing operation with input validation and memory management. CVE-2015-7511 is a cryptographic side-channel vulnerability in libgcrypt. There is no similarity in domain (ML vs cryptography), vulnerability type (input validation vs timing attack), or code patterns. The only weak connection is that both involve mathematical computations, but the nature is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-7837 is a stack buffer overflow in BlueZ configuration parsing. The target code performs bounds checking via OP_REQUIRES and uses standard containers. While both process input data, the vulnerability mechanism (stack overflow from hex parsing) and domain (Bluetooth vs ML tensor processing) are fundamentally different. The target code shows more robust input validation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2011-1178 is an integer overflow leading to heap overflow in GIMP's PCX loader. The target code also processes structured input with dimension calculations. There's some similarity in validating tensor/image dimensions and preventing out-of-bounds access. However, the target code uses TensorFlow's safe abstractions and explicit bounds checks, while the vulnerability involves raw integer calculations on untrusted file data.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-13219 is an integer overflow in audio codebook calculations. The target code performs dimension calculations and memory allocations for sparse tensors. Both involve processing structured data with size calculations, but the vulnerability context differs significantly (audio decoding vs tensor batching). The target code uses higher-level TensorShape utilities that likely include overflow checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-10128 is a privilege escalation vulnerability in PostgreSQL's query planner. The target code is a pure computation kernel with no authentication, authorization, or multi-user context. There is no similarity in vulnerability type (access control vs memory safety) or domain (database security vs numerical computation).",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7970 is a buffer overflow in subtitle blur effect calculations. The target code also processes multi-dimensional data and performs index calculations. Both involve iterating over data structures with dimension-based indexing. However, the vulnerability arises from mathematical parameter manipulation in libass, while the target code uses validated tensor dimensions and standard iteration patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2009-3909 is an integer overflow in PSD file dimension parsing leading to heap overflow. The target code validates tensor dimensions and allocates memory accordingly. Both process structured binary/formatted data with dimension fields. The similarity is in dimension validation and memory allocation based on those dimensions, though the target code appears to use safer allocation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-14151 is a heap buffer overflow in JPEG2000 encoding due to insufficient padding. The target code allocates tensors based on calculated sizes. Both involve memory allocation for data processing, but the vulnerability mechanism (padding calculation error) is specific to compression algorithms. The target code uses TensorFlow's memory management which likely includes proper bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-5844 is an integer overflow in ISO9660 file position calculations. The target code performs similar dimension and index calculations for sparse tensors. Both process structured format data with position/size fields that could overflow if not properly validated. The target code's validation of indices and dimensions against shape parameters is conceptually similar to validating file positions against archive boundaries.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-5745 is a cryptographic algorithm handling vulnerability leading to NULL pointer dereference in BIND9. The target code has no cryptographic functionality, no algorithm negotiation, and no complex error cleanup paths that could lead to NULL dereference. The domains (DNS security vs tensor computation) and vulnerability patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      }
    ]
  },
  "CVE-2022-23568_before_exclude_100:cd6da450:vulspec": {
    "timestamp": "2026-01-16T21:24:41.053264",
    "cve_id": "CVE-2022-23568",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cd6da450",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel timing attack in a cryptographic library (libgcrypt). The target code is a TensorFlow sparse tensor manipulation function with no cryptographic operations, secret-dependent branches, or timing-sensitive logic. The vulnerability types (CWE-200/385 vs. potential integer/buffer issues) and domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser. The target code performs input validation (shape checks) and uses safe container operations (vectors, unordered_set). While both process input, the attack surface (file/network input vs. internal tensor data), memory model (stack vs. heap/Tensor allocations), and vulnerability pattern differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2011-1178 is an integer overflow leading to heap buffer overflow in an image parser. The target code explicitly checks for integer overflow in `MultiplyWithoutOverflow` when computing `new_num_elements` from input shape dimensions, showing awareness of this vulnerability class. Both involve parsing structured input (image dimensions / tensor shape) and performing size calculations. However, the target code appears to have defensive checks.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-13219 is an integer overflow in an audio codec's mathematical computations. Similar to case 3, the target code contains an explicit integer overflow check (`MultiplyWithoutOverflow`) when computing the product of tensor dimensions. Both handle user-provided numerical parameters that could be large. The defensive pattern in the target code is directly relevant to preventing such vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability in a database query planner. The target code performs computational tensor operations with no privilege checks, authentication, or authorization logic. The vulnerability types (CWE-284 vs. memory/integer issues) and system domains (database vs. numerical computing) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-7970 is a buffer overflow in a subtitle rendering library due to unchecked mathematical parameters. The target code uses bounded iterations (`num_entries`, `rank`) and standard containers, but does involve index calculations (e.g., `output_indices_t(i, d - 1)`). Both process structured input, but the target code's validation of indices and shapes reduces risk. The connection is general (input validation importance) rather than specific.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2009-3909 is an integer overflow leading to heap overflow in an image header parser, very similar to case 3. The target code's validation of `input_shape` elements and the overflow check for `new_num_elements` directly parallel the vulnerability pattern in image dimension parsing. The defensive code is a direct countermeasure to this class of flaw.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a heap buffer overflow due to insufficient buffer allocation padding in an image encoder. The target code allocates tensors based on calculated sizes (`num_entries`, `rank-1`). If the overflow check (`MultiplyWithoutOverflow`) failed, incorrect allocations could occur. However, the target code's allocation pattern is simpler and the overflow check is present, reducing direct similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2016-5844 is an integer overflow in archive file position calculation. This is highly analogous to the target code's dimension product calculation (`new_num_elements = MultiplyWithoutOverflow(...)`). Both parse structured input containing numerical values used in subsequent size/position calculations. The target code's explicit overflow detection and error handling provide a direct reference for fixing such vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 is a cryptographic algorithm handling flaw leading to a NULL pointer dereference in a DNS server. The target code contains no cryptographic operations, algorithm selection, or complex error cleanup paths that could leave objects partially initialized. The vulnerability patterns and system domains are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      }
    ]
  },
  "CVE-2022-30292_after_exclude_100:d4d5c192:vulspec": {
    "timestamp": "2026-01-16T21:24:41.908233",
    "cve_id": "CVE-2022-30292",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d4d5c192",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a Squirrel VM thread call function, focusing on stack manipulation and parameter passing between threads. CVE-2016-3179 is a Use-After-Free in a network daemon (MiniSSDPd) related to socket message handling and memory management of service structures. The domain (scripting VM vs. network protocol), vulnerability type (no apparent use-after-free in target), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code involves moving objects between VM stacks. CVE-2018-20760 is an out-of-bounds write in a text encoding conversion function (UTF-8/UTF-16) in a multimedia framework. The core issue is improper handling of return codes and buffer sizes during string conversion, which has no parallel in the stack manipulation and thread invocation logic shown.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code performs stack operations and error propagation. CVE-2017-14151 is a buffer overflow in an image codec (OpenJPEG) due to incorrect calculation of buffer padding for compressed data. The domains (scripting VM vs. image processing) and the specific vulnerability mechanism (arithmetic error in allocation size) are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code uses `sq_move` to transfer values between VM stacks. CVE-2019-20840 is an out-of-bounds write in a VNC library's WebSocket decoder due to unaligned memory access during frame unmasking. The vulnerability root cause (alignment assumption) and context (network protocol parsing) are unrelated to the VM internal data transfer functions.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code manages a VM stack, reserving space and moving parameters. CVE-2016-8860 is a buffer management issue in Tor's network buffer code, related to missing sentinel values and improper use with string functions. There is a very weak similarity in the abstract concept of managing data buffers/chunks, but the implementation, vulnerability type (overread vs. stack call), and context are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a VM operation dispatcher. CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to improper handling of NUL bytes in patterns. The domain (regex parsing/compilation) and vulnerability trigger (embedded NULs) have no connection to the thread call function.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code propagates an error object (`v->_lasterror = _thread(o)->_lasterror`) from a child thread to a parent thread. CVE-2011-1003 is a double free in ClamAV's VBA parser during error cleanup. There is a weak but notable similarity in the theme of error state propagation and cleanup across different execution contexts (threads vs. parsing stages). However, the specific vulnerability mechanism (double free) is not evident in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code performs stack index calculations (`nparams`) and moves values. CVE-2019-25034 is an integer overflow leading to an out-of-bounds write in a DNS domain name parser. While both involve calculations based on input parameters, the target code's calculations are simple arithmetic on a stack index, with no complex length calculations or overflow risks apparent. The vulnerability types are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code uses array/stack indexing (`i`, `-1`) which are bounds-checked by the VM's `sq_move` and `stack_get` functions. CVE-2017-9228 is an out-of-bounds write in a regex library due to an uninitialized variable used as an array index. The pattern of using an index to access a data structure is generic, but the root cause (uninitialized state) and domain (regex state machine) are not relevant here.",
        "case_metadata": {
          "cve_id": "CVE-2017-9228"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code checks a parameter type (`sq_type(o) == OT_THREAD`) and returns an error if invalid. CVE-2011-3603 is an improper input validation and privilege management issue in a daemon's initialization sequence. The superficial similarity of \"input validation\" is overwhelmed by the drastic difference in context (VM parameter type checking vs. process privilege state validation) and consequence.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2009-0689_before_exclude_100:ed7c9583:vulspec": {
    "timestamp": "2026-01-16T21:24:51.068295",
    "cve_id": "CVE-2009-0689",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ed7c9583",
    "scores": [
      {
        "score": 4,
        "reasoning": "The target code involves memory allocation and a freelist, which is a common structure for Use-After-Free vulnerabilities. However, CVE-2016-3179 is specific to a network daemon's service registration logic with complex error handling leading to inconsistent state. The target code is a simple allocator with mutex protection, showing only a superficial similarity in using a freelist. The core vulnerability patterns (uninitialized pointers, complex error cleanup) are not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a memory allocator with no string parsing, buffer indexing, or input validation logic. The vulnerability types and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The connection is through memory allocation. CVE-2018-20750 involves an integer overflow in a size calculation leading to an undersized allocation and subsequent OOB write. The target code performs allocation with a size derived from a bit shift (`1 << k`). If `k` were uncontrolled and large, it could cause an integer overflow/wraparound in the `(x-1)*sizeof(Long)` calculation, leading to an undersized allocation similar to the root cause of CVE-2018-20750. However, the target code lacks the explicit integer conversion flaw and the subsequent buffer writing logic that defines the attack.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve calculating an allocation size for a data buffer. CVE-2017-14151 is a buffer overflow due to insufficient padding allocation. The target code's size calculation `sizeof(Bigint) + (x-1)*sizeof(Long)` is a typical pattern for allocating a struct with a flexible array member. If the arithmetic is incorrect (e.g., off-by-one in the `x-1` part), it could lead to a similar buffer overflow condition when the allocated `rv` is later used. The pattern of allocating a base struct plus a variable number of elements is conceptually similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-7972 is about inconsistent internal tracking of allocated memory size. The target code's `Balloc` function does track allocation size (`rv->maxwds = x`), but this is a simple assignment of a known value. The vulnerability described involves a disconnect between two internal size variables, which is a more complex state management issue not evident in this simple allocator.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The link is through arithmetic in size calculation, as with Case 4. The integer overflow in `(x-1)*sizeof(Long)` is a potential parallel to CVE-2019-25034. However, the target code's calculation is simpler and more localized. The vulnerability's context (DNS name parsing) and the specific chain leading to an OOB write are absent, making the relevance limited to the basic arithmetic hazard.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve low-level memory chunk management. CVE-2016-8860 is about missing sentinel values in buffers and improper use with string functions. The target code allocates a `Bigint` struct which includes a flexible array of `Long` (integers), not a string buffer. The vulnerability pattern of missing null termination and subsequent over-read does not apply to this integer array allocation pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The target code manages a `freelist[]`, which is a classic structure where double-free vulnerabilities can occur if the same memory pointer is added back to the list twice. CVE-2011-1003 is a double-free caused by inconsistent state during error handling. While the target code itself shows proper mutex protection and doesn't free memory, the `Balloc` function is part of a memory management suite that likely includes a `Bfree` function. The pattern of removing an item from `freelist[k]` and the potential for that item to be incorrectly re-inserted later is directly analogous to the double-free management problem. The mutex protects against concurrent double-free races, but logic errors in single-threaded code could still cause it.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2010-1311 is an input validation flaw in a decompression algorithm leading to an OOB write. The target code performs no input validation (it trusts the parameter `k`) and contains no decompression or buffer writing logic. The vulnerability types and code domains are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2009-0689_after_exclude_100:473f8495:vulspec": {
    "timestamp": "2026-01-16T21:24:51.166403",
    "cve_id": "CVE-2009-0689",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "473f8495",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve memory allocation and error handling, but the core vulnerability types differ significantly. CVE-2016-3179 is a Use-After-Free enabled by uninitialized pointers and inconsistent state cleanup. The target code uses a freelist and has mutex protection, showing a different memory management pattern. The error path in the target code calls `zend_error` which likely terminates the process, reducing the risk of inconsistent state exploitation.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve resource management with concurrency considerations. CVE-2017-18249 is a Race Condition (CWE-362) in a cache/list management system. The target code uses a mutex (`dtoa_mutex`) to protect the freelist access, which directly addresses the race condition concern. The pattern of checking a shared resource (freelist[k]) under a lock is similar to the nid management, but the target code's locking appears correct for its critical section, making the vulnerability pattern less directly applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an Out-of-bounds Read (CWE-125) due to improper NUL byte handling in string parsing. The target code performs simple arithmetic memory allocation (`(x-1)*sizeof(Long)`) and does not involve string parsing, buffer reads, or character encoding. The domains (regex compilation vs. big integer allocation) and vulnerability mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves an Integer Overflow (CWE-190) leading to an Out-of-bounds Write (CWE-787) during memory allocation size calculation. The target code has a similar pattern: it calculates an allocation size using `(x-1)*sizeof(Long)` where `x = 1 << k`. If `k` is large enough (close to or exceeding bit width of `int`), the shift operation `1 << k` could overflow, leading to an undersized allocation. The check `k > Kmax` is a boundary check but may not prevent an integer overflow within the allowed range. This is a relevant pattern for review.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-14151 is a buffer overflow (CWE-119) due to insufficient padding in memory allocation. The target code allocates `sizeof(Bigint) + (x-1)*sizeof(Long)`. While not about padding, the arithmetic for the flexible array member size (`(x-1)*sizeof(Long)`) shares a pattern with allocation size calculations that can be incorrect if `x` is zero or very large, potentially causing an integer wrap. The need to validate the allocation size calculation is a common theme.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7972 involves Resource Management Errors (CWE-399) with inconsistent memory tracking. The target code manages a freelist and tracks the `k` and `maxwds` fields in the allocated structure. While both involve tracking allocation metadata, the specific flaw of mismatch between allocated and tracked size is not evident in the simple `Balloc` function. The target code's state management (setting `sign` and `wds` after allocation) is straightforward.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2019-25034 involves an Integer Overflow (CWE-190) in a size calculation leading to an out-of-bounds write. This is highly analogous to the potential issue in the target code's `(x-1)*sizeof(Long)` calculation, where `x = 1 << k`. If `k` is sufficiently large, the multiplication with `sizeof(Long)` could overflow, resulting in a smaller allocation than intended. The attack surface differs (network data vs. internal math), but the core arithmetic vulnerability pattern is similar and relevant for security review.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-8860 is about improper buffer bounds restriction (CWE-119) and missing sentinel values in network buffers. The target code allocates a structure for internal use (big integers) and does not involve string handling or sentinel values. The functionality (data structure allocation vs. network packet buffering) and the nature of the potential memory safety violation are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2011-1003 is a Double Free (CWE-415) due to inconsistent state during error handling. The target code has an error path where `zend_error` is called after a failed `MALLOC`. If `zend_error` does not terminate the process (though `E_ERROR` suggests it does), and if the mutex is unlocked before the error is raised, there is no double-free path shown here. The freelist management under a mutex reduces this risk. The error handling pattern is simpler.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2010-1311 is an Improper Input Validation (CWE-20) in a decompression algorithm leading to out-of-bounds writes. The target code's primary input is the integer `k`, which is validated against `Kmax`. It does not process complex, untrusted data streams or perform decompression. The domains and the mechanisms for potential memory corruption are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2020-1971_before_exclude_100:91fcf226:vulspec": {
    "timestamp": "2026-01-16T21:25:07.563558",
    "cve_id": "CVE-2020-1971",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "91fcf226",
    "scores": [
      {
        "score": 1,
        "reasoning": "The target code is a simple test setup function calling a macro to add tests. VulSpec Case 1 describes a complex Use-After-Free vulnerability in a network daemon's memory management and error handling. There is no functional, contextual, or pattern similarity. The target code shows no memory operations, network handling, or error paths relevant to CWE-416.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a test harness setup. VulSpec Case 2 describes an Out-of-bounds Read in a regular expression compiler due to improper NUL byte handling. There is no similarity in functionality (parsing vs. test registration), vulnerability type, or code patterns. The target code contains no input validation, buffer operations, or string processing.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is unrelated to network packet parsing. VulSpec Case 3 describes an Out-of-bounds Read in a tcpdump protocol dissector due to insufficient length validation. The target code performs no packet data reading, bounds checking, or protocol handling. The contexts and vulnerability mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a test setup function. VulSpec Case 4 describes an Out-of-bounds Write due to integer overflow in a VNC file transfer module. The target code contains no arithmetic operations, memory allocations, file transfer logic, or network data processing that could lead to such vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a simple test registration. VulSpec Case 5 describes Improper Input Validation leading to memory issues in a network packet parser. The target code accepts no external input, performs no parsing, and has no network context. The vulnerability patterns and domains are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a test setup function. VulSpec Case 6 describes a privilege management vulnerability where a daemon fails to drop privileges. The target code does not handle privileges, process separation, or daemon initialization. The functional domains and security issues are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a test harness function. VulSpec Case 7 describes an Integer Overflow leading to a buffer overflow in a DNS domain name parser. The target code performs no string parsing, length calculations, or buffer operations. The code patterns and vulnerability mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a simple test registration. VulSpec Case 8 describes an Out-of-bounds Read in an XML parser during end tag processing. The target code is not a parser, does not process structured data like XML, and performs no bounds-checked reads. There is no relevance in functionality or vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a test setup function. VulSpec Case 9 describes an Out-of-bounds Read in an XML/HTML parser due to improper buffer management during character encoding. The target code contains no parsing logic, buffer management, or character encoding operations. The contexts are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a test harness setup. VulSpec Case 10 describes an Out-of-bounds Read in a network protocol dissector due to insufficient length validation. The target code is not related to network traffic analysis, packet dissection, or any form of data validation. No relevant code patterns or vulnerability types are present.",
        "case_metadata": {
          "cve_id": "CVE-2018-14468"
        }
      }
    ]
  },
  "CVE-2021-43975_after_exclude_100:5d227f0c:vulspec": {
    "timestamp": "2026-01-16T21:25:11.976167",
    "cve_id": "CVE-2021-43975",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5d227f0c",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve length validation checks (`sw.len > sizeof(self->rpc)`), but the core vulnerability differs. Case 1 is an integer overflow leading to an out-of-bounds write during memory allocation. The target code performs bounds checks to prevent overflow/write but does not involve dynamic memory allocation or the specific integer wraparound flaw.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve kernel code and data transfer/copy operations (`hw_atl_utils_fw_downld_dwords`). However, Case 2 is a buffer overflow in a FUSE ioctl handler due to insufficient iovec validation. The target code validates the `fw.len` before the copy, focusing on preventing buffer overflow, not suffering from one due to missing validation of a complex structure.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is a Use-After-Free vulnerability in a user-space daemon related to error handling and pointer management. The target code is kernel driver code with simple error exits (`goto err_exit`) and no dynamic memory allocation/free logic that could lead to a UAF.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a race condition in filesystem metadata management (nid allocation). The target code uses `readx_poll_timeout_atomic` for synchronization and operates on hardware registers, but its concurrency model and shared resource (hardware state vs. software cache) are fundamentally different from the filesystem race.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a race condition in the TTY subsystem leading to buffer overflow. The target code contains a polling loop but no evidence of concurrent writers to a shared software buffer without proper locking, which is the core of the TTY vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an information disclosure in an HTTP proxy due to improper state clearance between requests. The target code is a kernel hardware abstraction layer function that manages a single hardware RPC transaction, with no concept of persistent connections or residual data from previous operations.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code performs data copies with length validation and deals with binary firmware data, not string parsing with embedded terminators.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The most relevant similarity is the pattern of validating a length field (`fw.len`) before using it to read data, which is central to Case 8 (CWE-125: Out-of-bounds Read). The target code explicitly checks `fw.len > sizeof(self->rpc)` to prevent an over-read during `hw_atl_utils_fw_downld_dwords`. The context (network protocol parsing vs. firmware RPC) is different, but the defensive coding pattern against invalid length fields is directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve data copying and error handling. Case 9 is an out-of-bounds write due to unhandled error returns from a conversion function. The target code checks error returns (`err < 0`) but does not involve character encoding conversion or the specific flaw where a failing function leads to an unchecked buffer write.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in the Linux kernel and involve careful memory operations. Case 10 is a buffer access issue related to scatterlist and VMAP_STACK. The target code copies data into a fixed-size kernel structure (`self->rpc`) and validates the length, showing awareness of buffer bounds, but does not deal with the specific scatterlist/crypto API vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2021-43975_before_exclude_100:9e360ba2:vulspec": {
    "timestamp": "2026-01-16T21:25:14.687241",
    "cve_id": "CVE-2021-43975",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9e360ba2",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a network driver utility function for firmware RPC communication, involving polling and memory download. CVE-2018-20750 is an integer overflow leading to OOB write in a VNC server's file transfer protocol. The domains (driver firmware vs. remote desktop), vulnerability patterns (integer overflow/OOB write vs. race condition/polling), and code constructs are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2010-4650 is a buffer overflow in the Linux kernel FUSE ioctl handling due to insufficient iovec validation. The target code performs firmware data download with a calculated length but includes bounds checking via `(fw.len + sizeof(u32) - sizeof(u8)) / sizeof(u32)`. The context (kernel filesystem vs. hardware driver utility) and the specific vulnerability mechanism (malicious server response vs. firmware data transfer) are dissimilar. Weak relevance at best.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-3179 is a Use-After-Free in a user-space SSDP daemon related to error handling and pointer management. The target code shows no dynamic memory allocation or pointer lifecycle management that could lead to UAF. It primarily uses stack variables and polls hardware registers. The vulnerability class and code patterns are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-18249 is a race condition in the F2FS filesystem's node ID management. The target code contains a `readx_poll_timeout_atomic` loop that polls for a hardware register (`fw.tid`) to match a software value (`sw.tid`). This pattern of waiting for a shared state (the `tid`) to synchronize between software and firmware has conceptual similarity to race condition or TOCTOU issues, though the context (driver/firmware handshake vs. filesystem metadata) is different. Moderate relevance as it illustrates synchronization pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2014-0196 is a race condition in the kernel TTY subsystem leading to buffer overflow. The target code's `do...while` loop with polling (`readx_poll_timeout_atomic`) on a shared hardware state (`fw.tid`) involves concurrency concepts between the driver and the firmware hardware. While not a classic software race, it deals with synchronizing access to a shared resource (the RPC state). The vulnerability class (concurrency) is similar, but the manifestation and attack surface (hardware register vs. TTY device) differ. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-20637 is an information disclosure in Varnish Cache due to improper state clearance between HTTP requests. The target code is a single function call for a firmware RPC wait operation. It does not show persistent connection state or data residue between invocations. The vulnerability type and context are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to improper NUL byte handling. The target code involves firmware communication and data download with explicit length calculations. There is no string parsing or regex compilation involved. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-14461 is an out-of-bounds read in tcpdump's LDP parser due to insufficient length validation. The target code validates and uses a length field (`fw.len`) to calculate a download size. It performs a calculation `(fw.len + sizeof(u32) - sizeof(u8)) / sizeof(u32)` which could potentially wrap if `fw.len` is very large (near `UINT_MAX`), resembling an integer overflow concern. However, the primary vulnerability (OOB read vs. potential integer overflow in a driver) and context (packet parsing vs. firmware download) are only weakly similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-20760 is an out-of-bounds write in a multimedia framework's text encoding conversion. The target code writes firmware data into a kernel buffer (`self->rpc`) but uses a calculated length derived from a firmware-provided value. While both involve writing data based on external input, the mechanism (encoding error handling vs. hardware protocol length field) and the resulting vulnerability pattern are distinct. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-10154 is a buffer overflow in the kernel CIFS crypto code related to scatterlist usage on virtually-mapped stacks. The target code uses `hw_atl_utils_fw_downld_dwords` which likely performs MMIO or DMA to write data. There is no indication of improper scatterlist usage or stack memory issues. The context (crypto vs. firmware download) and vulnerability root cause are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2020-1971_after_exclude_100:fb2f224e:vulspec": {
    "timestamp": "2026-01-16T21:25:15.295432",
    "cve_id": "CVE-2020-1971",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "fb2f224e",
    "scores": [
      {
        "score": 1,
        "reasoning": "The target code is a simple test setup function in what appears to be an OpenSSL test suite. It adds test cases to a framework. VulSpec Case 1 (CVE-2016-3179) describes a Use-After-Free vulnerability in a network service discovery daemon (MiniSSDPd) related to local socket message handling and memory management during error paths. There is no functional, domain, or code pattern similarity. The target code shows no network handling, memory allocation, or complex error paths.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 2 (CVE-2018-18313) describes an Out-of-bounds Read in the Perl regex engine due to improper handling of NUL bytes in pattern strings. The domains (cryptography library testing vs. regex compilation) and vulnerability patterns (simple function calls vs. intricate string parsing with buffer bounds issues) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 3 (CVE-2018-14461) describes an Out-of-bounds Read in tcpdump's LDP protocol parser due to insufficient validation of a TLV length field. The target code contains no protocol parsing logic, network data handling, or length validation. The contexts are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 4 (CVE-2018-20750) describes an Out-of-bounds Write in a VNC server library due to an integer overflow in a file transfer memory allocation. The target code performs no arithmetic, memory allocation, or data processing. It is a simple control flow function for a test harness.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 5 (CVE-2019-15166) describes an Improper Input Validation issue in tcpdump's LMP protocol parser, leading to potential memory corruption. The target code does not parse any input, let alone network packet data. It merely registers test functions.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 6 (CVE-2011-3603) describes a privilege management vulnerability in radvd where the daemon continues with root privileges after privilege separation fails. The target code shows no privilege manipulation, daemon initialization, or system-level state management. It is part of a user-space test suite.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 7 (CVE-2019-25034) describes an Integer Overflow leading to an Out-of-bounds Write in a DNS resolver's domain name parsing logic. The target code contains no string parsing, integer arithmetic, or buffer operations. The functional domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 8 (CVE-2016-1838) describes an Out-of-bounds Read in libxml2's XML end tag parser due to insufficient bounds checking. The target code does not parse any structured data format (XML, HTML, etc.) and contains no loops or buffer accesses that could lead to such a vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 9 (CVE-2016-1833) describes an Out-of-bounds Read in libxml2 related to multi-byte character encoding processing. The target code performs no text processing, encoding handling, or low-level buffer management. The code patterns and vulnerability triggers are not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is a test setup function. VulSpec Case 10 (CVE-2018-14468) describes an Out-of-bounds Read in tcpdump's FRF.16 protocol dissector due to insufficient validation of an Information Element length. The target code is not a network protocol dissector, does not process packet data, and does not perform any bounds checking. There is no relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-14468"
        }
      }
    ]
  },
  "CVE-2022-23584_before_exclude_100:2895e83c:vulspec": {
    "timestamp": "2026-01-16T21:25:19.753894",
    "cve_id": "CVE-2022-23584",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2895e83c",
    "scores": [
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library (libgcrypt) related to elliptic curve operations. The target code is a PNG image decoder in TensorFlow with no cryptographic operations or secret-dependent branching that could leak information via timing or EM channels.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2017-14151 is a heap buffer overflow in an image codec (OpenJPEG) due to insufficient allocation for compressed data. The target code is also an image decoder (PNG) and performs bounds checking on width/height to prevent integer overflows and excessive allocations. Both involve parsing untrusted image data and validating dimensions to prevent memory corruption, though the specific vulnerability patterns differ (allocation padding vs. dimension validation).",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-16149 is a cryptographic signature verification flaw in a TLS library (axTLS) related to ASN.1 parsing. The target code is a non-cryptographic PNG image decoder with no certificate or signature handling.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2018-5711 is an integer signedness confusion leading to an infinite loop in a GIF decoder (PHP GD). The target code is a PNG decoder that performs extensive integer validation (width/height > 0, bounds checks, overflow checks) to prevent similar issues. Both are image parsers handling untrusted input, with the target code explicitly checking for conversion correctness (e.g., `width != static_cast<int64_t>(decode.width)`). The vulnerability patterns are similar (numeric validation), though the specific flaw (signedness) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2020-21050 is an out-of-bounds write in a GIF/LZW decoder (libsixel) due to insufficient validation of code size. The target code is a PNG decoder that validates image dimensions and total size to prevent buffer overflows. Both involve decoding compressed image formats and validating parameters to ensure allocated buffers are sufficient. The target code's checks on `width`, `height`, and `total_size` directly mitigate similar risks.",
        "case_metadata": {
          "cve_id": "CVE-2020-21050"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-5745 is a cryptographic algorithm handling flaw leading to a NULL pointer dereference in a DNS server (BIND9). The target code is a PNG image decoder with no cryptographic or DNSSEC functionality.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2017-14152 is a use-after-free in OpenJPEG due to improper bounds checking and state management. The target code performs careful dimension validation and manages decoder context lifetime (calls `png::CommonFreeDecode` on error paths). Both are image codecs validating untrusted parameters, though the specific vulnerability (use-after-free) is not evident in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-19477 is a type confusion in a document renderer (Ghostscript) when processing JBIG2 streams. The target code is a PNG decoder with strong type safety (C++ static casts, checked conversions). Both parse untrusted binary data, but the vulnerability patterns differ significantly (type confusion vs. integer overflow checks).",
        "case_metadata": {
          "cve_id": "CVE-2018-19477"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2017-12982 is a memory allocation failure due to unchecked header values in a BMP converter (OpenJPEG). The target code validates PNG dimensions to prevent excessive allocations and includes checks like `width >= (1LL << 27)`. Both involve validating image metadata to prevent resource exhaustion or allocation failures, though the target code does not directly handle BMP files.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-17787 is an out-of-bounds read in a PSP image importer (GIMP) due to improper string validation. The target code is a PNG decoder that validates numeric fields but does not process string metadata. Both are image parsers, but the vulnerability types differ (out-of-bounds read vs. integer overflow). The target code's focus on dimension validation is a related defensive practice.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      }
    ]
  },
  "CVE-2021-37690_before_exclude_100:1e524034:vulspec": {
    "timestamp": "2026-01-16T21:25:21.763571",
    "cve_id": "CVE-2021-37690",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1e524034",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is from TensorFlow's shape inference engine, dealing with graph node validation and shape propagation. CVE-2019-10128 is about PostgreSQL's query planner privilege checks (CWE-284). The domains (ML framework vs. database), vulnerability types (access control vs. potential bounds/validation issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code performs index bounds checking (`if (index < 0 || outer_context->num_inputs() <= index)`) and shape handle validation. While both involve input validation, the context (regex parsing vs. graph shape inference), vulnerability root cause, and attack surfaces are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error (CWE-399) in a subtitle renderer related to inconsistent memory tracking. The target code manages shape handles and context objects but does not show obvious memory allocation/deallocation patterns or resource tracking errors. The functional domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-16149 is a cryptographic signature verification flaw (CWE-347) in an SSL/TLS library due to ASN.1 parsing issues. The target code has no cryptographic functionality, certificate parsing, or signature verification. The domains and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow (CWE-190) in an archive library. The target code performs array index bounds checking (`index < 0 || outer_context->num_inputs() <= index`), which is a related defensive practice to prevent out-of-bounds access. However, the specific integer overflow vulnerability pattern and the context (file parsing vs. graph inference) are different. The similarity is limited to the general theme of input validation for indices/sizes.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a broken cryptographic algorithm leading to a NULL pointer dereference in a DNS server. The target code does not deal with cryptography, algorithm selection, or complex error state cleanup that could leave pointers uninitialized. The domains and vulnerability chains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-16161 is a NULL pointer dereference (CWE-476) in a regex library due to inconsistent error state handling. The target code uses `CHECK_NOTNULL` on `GetContext(node)` and checks pointer results (e.g., `if (resource)`), showing awareness of potential NULL states. Both involve careful handling of internal state and pointers, but the trigger conditions (regex error vs. shape inference logic) and code patterns are quite different.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-10218 is a NULL pointer dereference due to violation of stack pairing (unmatched push/pop) in a PDF interpreter. The target code manages context relationships between `outer_context` and `node_context`, ensuring they are valid and synchronizing data between them. While both involve managing state across contexts/stacks and avoiding invalid accesses, the specific vulnerability mechanism (stack imbalance) is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-19477 is a type confusion issue (CWE-704) in a document renderer. The target code works with strongly typed C++ objects (`InferenceContext`, `ShapeHandle`) and there is no evidence of unsafe casts or type confusion. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-19477"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2011-3603 is about improper input validation of privilege separation state, leading to unnecessary privilege execution. The target code validates array indices and shape handles, which is a form of input validation, but the scope (privilege management vs. data structure bounds) and consequences are completely different. The core vulnerability pattern is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2022-23584_after_exclude_100:ada0b9d9:vulspec": {
    "timestamp": "2026-01-16T21:25:22.468543",
    "cve_id": "CVE-2022-23584",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ada0b9d9",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a PNG image decoder in TensorFlow, focusing on size validation and safe memory allocation. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library (libgcrypt) related to elliptic curve operations. The domain (image processing vs. cryptography), vulnerability type (logic/validation vs. timing side-channel), and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve image format decoding (JPEG 2000 vs. PNG) and memory buffer management. The core vulnerability (CWE-119: buffer overflow due to insufficient allocation/validation) is conceptually similar to the risks the target code mitigates with its width/height/total_size checks. However, the specific trigger (code block encoding parameters vs. image dimensions) and system are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-16149 is a cryptographic signature verification flaw in a TLS library (axTLS) related to ASN.1 parsing. The target code is a non-cryptographic image decoder. The domains (cryptography/certificates vs. image processing), vulnerability types (CWE-347 vs. buffer/validation issues), and attack surfaces (malicious certificates vs. malicious images) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are image decoders (GIF vs. PNG) within graphics libraries. The vulnerability stems from improper numeric handling (CWE-681: incorrect conversion) leading to an infinite loop/state error. This is highly relevant to the target code's careful validation of `width`, `height`, and `total_size` to prevent overflows and ensure values fit expected types. The attack surface (malformed image file) is identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are image decoders (GIF vs. PNG) where a core vulnerability is improper input validation leading to an out-of-bounds write (CWE-787). The target code's extensive checks on `decode.width` and `decode.height` are precisely aimed at preventing such issues by ensuring dimensions are within safe bounds before allocation. The attack surface (malformed image input) is the same.",
        "case_metadata": {
          "cve_id": "CVE-2020-21050"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 is a DNS/DNSSEC vulnerability involving cryptographic algorithm handling and error state management leading to a NULL pointer dereference. The target code is a simple image decoder with no cryptographic operations. The domains (network security/cryptography vs. image processing) and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve image format processing (JPEG 2000 vs. PNG) and vulnerabilities arising from improper parameter validation. CVE-2017-14152's root cause includes improper bounds checking (CWE-125) and input validation (CWE-20), which aligns with the target code's validation of image dimensions. However, the specific flaw (use-after-free due to inconsistent state) is not directly mirrored in the provided PNG decoder snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both process embedded image data (JBIG2 in documents vs. PNG). The vulnerability type (CWE-704: incorrect type conversion) leading to type confusion is somewhat relevant to the target code's careful use of `static_cast` and checks for type consistency (e.g., `width != static_cast<int64_t>(decode.width)`). However, the context (complex document interpreter vs. standalone image decode) and specific attack surface differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-19477"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both are image processing vulnerabilities where improper validation of file header/metadata (BMP biBitCount vs. PNG width/height) can lead to memory safety issues (CWE-119). The target code's rigorous dimension checks are a direct parallel to the missing validation in the BMP converter. The attack surface (malicious image file) is identical, though the specific invalid field differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are image file parsers where improper validation of input data can lead to out-of-bounds reads (CWE-125). The target code's validation focuses on numeric dimensions to prevent overflows that could cause out-of-bounds access later. While the specific flaw (string termination) differs, the principle of rigorously validating all parsed fields from an untrusted file is highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      }
    ]
  },
  "CVE-2020-16287_before_exclude_100:f05d9927:vulspec": {
    "timestamp": "2026-01-16T21:25:23.315556",
    "cve_id": "CVE-2020-16287",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f05d9927",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The target code is the exact function `lprn_is_black()` from the Ghostscript LIPS printer driver (contrib/lips4/gdevlprn.c) mentioned in CVE-2020-16287. The vulnerability type (CWE-787 Out-of-bounds Write) stems from insufficient bounds checking on the calculated index into `lprn->ImageBuf`, which is directly applicable to analyzing the target code for the same flaw. The code patterns, system, component, and attack surface are identical.",
        "case_metadata": {
          "cve_id": "CVE-2020-16287"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is a pixel buffer checking function in a printer driver. CVE-2016-3179 is a Use-After-Free vulnerability in a network service discovery daemon (MiniSSDPd). The domains (graphics rendering vs. network protocol), vulnerability types (bounds check vs. memory lifecycle), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve potential out-of-bounds writes (CWE-787). However, the contexts are vastly different: a local image buffer scan in a printer driver vs. a network protocol integer overflow leading to heap corruption in a VNC server. The trigger conditions (malicious PDF vs. malicious file transfer request) and code patterns (simple buffer iteration vs. complex size calculation) share only the broad vulnerability category.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an Out-of-bounds Read in a regular expression compiler due to improper NUL byte handling. The target code performs a bounded read (`p[x] != 0`) within a loop but does not compile or parse complex patterns. The domains (printer graphics vs. language parsing) and vulnerability root causes are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Both involve parsing external input (image data vs. network packets) and have a theme of missing validation (CWE-20). However, the target code's validation flaw would be a bounds check on buffer indices, while CVE-2019-15166 is about missing validation on packet structure fields. The systems and code complexity are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Similar to case 5, this involves parsing external data. CVE-2018-14461 is an Out-of-bounds Read in a network protocol parser due to insufficient length validation. The target code could have an out-of-bounds read if indices are miscalculated, but the context (printer buffer vs. packet TLV) and typical attack vectors are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The connection is through integer issues leading to out-of-bounds writes (CWE-190 -> CWE-787). The target code uses integer arithmetic for `y0` and buffer offset calculation (`(y0 + y) * bpl + bx * lprn->nBw`), which could overflow/wrap if values are uncontrolled. However, CVE-2019-25034 is in a DNS domain name parser, with very different data structures and overflow triggers.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve processing external file/data formats (PDF/image buffer vs. BMP file) and improper input validation leading to memory safety issues (CWE-119). The target code's vulnerability would relate to validating `r`, `h`, `bx`, and derived indices against buffer dimensions, analogous to validating BMP headers. The core flaw of \"unchecked input leading to invalid memory access\" is similar, but the implementation domains differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition (CWE-362) in a filesystem's internal ID management. The target code is a simple, deterministic function that checks a buffer; it has no concurrency, resource management, or state transition logic that would relate to this vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-1003 is a Double Free (CWE-415) in an antivirus document parser. The target code performs read-only operations on a buffer and returns an integer. It does not allocate, free, or manage any dynamic memory, making the vulnerability class irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2017-17784_after_exclude_100:3145cc9a:vulspec": {
    "timestamp": "2026-01-16T21:25:25.891039",
    "cve_id": "CVE-2017-17784",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3145cc9a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a GIMP brush file loader, not a regular expression engine. The vulnerability type (CWE-125) is superficially similar, but the trigger conditions (embedded NUL bytes in regex patterns) and code patterns (character class parsing) are completely different. No reference value for analyzing the image parsing code.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The vulnerability involves integer overflow leading to out-of-bounds write (CWE-787) in a VNC file transfer protocol. The target code performs integer multiplications (`bh.width * bh.height * bh.bytes`) with a check against `G_MAXSIZE` to prevent overflow, but the domain (network protocol vs. image file parsing), attack surfaces, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. This is the exact CVE for the provided target code (GIMP's GBR brush file parser in file-gbr.c). The vulnerability type (CWE-125 - Out-of-bounds Read), trigger conditions (malformed UTF-8 sequences in the brush name field), and code patterns are identical. The code shows the vulnerable section where `temp[bn_size - 1] != '\\0'` is checked after a read that may be incomplete, and the subsequent `gimp_any_to_utf8` call could process an unterminated string, leading to a heap buffer over-read.",
        "case_metadata": {
          "cve_id": "CVE-2017-17784"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The vulnerability is an out-of-bounds read (CWE-125) in an XML parser (libxml2) during end tag processing. The target code parses a binary image file format, not text-based XML. The data structures, parsing logic, and memory safety issues are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve GIMP and file format parsing leading to out-of-bounds write (CWE-787). However, the specific vulnerability (color map validation in XWD plugin) is in a different component and format. The similarity is the high-level pattern of insufficient validation of header fields in an image file parser, but the code structures and specific vulnerability mechanisms differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The vulnerability is an integer signedness issue (CWE-681) in a GIF decoder within PHP's GD library, leading to an infinite loop. The target code deals with GIMP's proprietary GBR format, uses different integer handling, and has no palette decoding logic similar to GIF. The domains (graphics libraries) are related, but the vulnerability patterns are not.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The vulnerability is an out-of-bounds read (CWE-125) in libxml2 due to improper multi-byte character encoding handling. The target code processes binary data with fixed-size headers and simple integer fields. The complexities of character encoding and the associated parser state management are absent from the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The vulnerability is an out-of-bounds read (CWE-125) in a network protocol analyzer (tcpdump) when parsing NFS file handles. The target code is a local file image loader. While both involve reading data into buffers, the context (network packets vs. file I/O), protocol structures, and validation logic are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both vulnerabilities are in GIMP file importers (PSP vs. GBR) and involve CWE-125 (Out-of-bounds Read) due to improper string handling. The attack surface (malformed image file) and the high-level pattern (insufficient validation of external file data) are similar. However, the specific code patterns differ (PSP creator block parsing vs. GBR brush name UTF-8 validation), and the vulnerabilities are in different plugins.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The vulnerability involves improper bounds checking (CWE-119) in PHP's GD library image buffer operations. The target code also performs bounds checking (e.g., against `G_MAXSIZE` and `GIMP_MAX_IMAGE_SIZE`) and manages image data buffers. There is a shared theme of validating image dimensions and allocation sizes to prevent overflows, but the implementation languages (C vs. PHP internals), libraries, and specific vulnerability patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2021-37690_after_exclude_100:4ee51824:vulspec": {
    "timestamp": "2026-01-16T21:25:26.319917",
    "cve_id": "CVE-2021-37690",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4ee51824",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is about improper access control in a database query planner. The target code is a shape inference function in TensorFlow dealing with tensor dimensions and function boundaries. The domains (database security vs. ML framework internals), vulnerability types (CWE-284 vs. potential bounds/state issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read due to improper NUL byte handling in a regex parser. The target code performs index bounds checking and shape handle management. While both check array bounds (index validation), the core vulnerability mechanism (parsing embedded NULs leading to OOB read) and domain (regex compilation vs. graph shape propagation) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7972 is about resource management errors (CWE-399) in a subtitle renderer due to inconsistent memory tracking. The target code also manages resources (shape handles, contexts) and must ensure consistent state between inner/outer contexts. There is a conceptual similarity in managing paired/related objects (shaper structure vs. inference contexts), but the specific vulnerability pattern (size tracking mismatch) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-16149 is about improper cryptographic signature verification (CWE-347) in a TLS library due to ASN.1 parsing flaws. The target code performs no cryptography, no signature verification, and no complex parsing of untrusted data formats. The domains and vulnerability classes are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 involves an integer overflow (CWE-190) during file position calculation in an archive parser. The target code performs integer bounds checking (`index < 0 || outer_context->num_inputs() <= index`), which is a related defensive pattern. However, the target code does not perform arithmetic calculations that could overflow; it only checks predefined ranges. The vulnerability trigger (maliciously large integer input) is not applicable here as indices are from function definitions, not directly from untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a NULL pointer dereference (CWE-476) triggered by an unsupported cryptographic algorithm in a DNS server. The target code uses `CHECK_NOTNULL` and checks pointer results (e.g., `if (resource)`), showing awareness of NULL pointer issues. However, the vulnerability chain (cryptographic error -> cleanup failure -> NULL dereference) and domain are entirely different. The defensive coding style is similar, but the flaw pattern is not.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-16161 is a NULL pointer dereference (CWE-476) due to inconsistent error state handling in a regex library. The target code uses error return codes (`TF_RETURN_IF_ERROR`) consistently and does not expose a similar pattern of returning an error code without setting an error state object. The domain and specific error handling flaw are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-10218 is a NULL pointer dereference (CWE-476) due to violation of stack pairing (unmatched push/pop) in a graphics stack. The target code manages a relationship between an \"outer_context\" and an inner \"node_context\", ensuring data flows correctly between them. There is a conceptual similarity in managing paired contexts/states and ensuring they are valid when accessed. However, the target code does not implement a push/pop stack, and the vulnerability mechanism is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-19477 involves type confusion (CWE-704) in a document renderer due to missing type verification of a context object. The target code deals with strongly typed C++ objects (`InferenceContext`, `ShapeHandle`) and does not perform any risky type casts or interpretations of untrusted data as different types. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-19477"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-3603 is about improper input validation (CWE-20) of privilege separation state, leading to unnecessary privileges (CWE-250). The target code validates array indices (`index`), which is a form of input validation, but it does not involve privilege management, process state, or security boundaries. The similarity is superficial (both do bounds checking), but the security context and consequences are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2020-16287_after_exclude_100:2c30c96d:vulspec": {
    "timestamp": "2026-01-16T21:25:27.629975",
    "cve_id": "CVE-2020-16287",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2c30c96d",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The target code is from the Ghostscript LIPS printer driver (gdevlprn.c), specifically the lprn_is_black() function, which matches the system, component, and function name in VulSpec Case 1 (CVE-2020-16287). The vulnerability type is an out-of-bounds access (CWE-787), and the code includes a comment referencing a bug fix (Bug 701785) to prevent buffer over-read, directly aligning with the vulnerability's context. The code pattern of calculating buffer offsets (`y0 + y) * bpl + bx * lprn->nBw`) and the explicit bounds check (`if (bx * lprn->nBw + x >= bpl) break;`) are defensive measures against the exact issue described.",
        "case_metadata": {
          "cve_id": "CVE-2020-16287"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is from Ghostscript, a document interpreter, while VulSpec Case 2 (CVE-2016-3179) is about MiniSSDPd, a network service discovery daemon. The vulnerability type (Use After Free, CWE-416) and attack surface (local socket messages) are completely unrelated to the image buffer bounds checking logic in the provided C code.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve potential out-of-bounds write (CWE-787) vulnerabilities. However, the contexts are vastly different: target code is a printer driver image buffer checker, while VulSpec Case 3 (CVE-2018-20750) is a VNC server file transfer integer overflow. The code patterns (buffer offset calculation vs. size calculation for allocation) and attack surfaces (malicious PDF vs. malicious VNC client) share only a generic similarity in memory safety concerns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. VulSpec Case 4 (CVE-2018-18313) is an out-of-bounds read (CWE-125) in the Perl regex engine due to improper NUL byte handling. The target code performs bounds-checked buffer reads in a graphics context. The systems, domains, and underlying vulnerability triggers (string parsing vs. image block processing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. VulSpec Case 5 (CVE-2019-15166) is an input validation issue (CWE-20) in tcpdump's network protocol parser. The target code is an internal image processing function in Ghostscript. While both involve parsing data, the domain (network packets vs. printer image buffers), vulnerability patterns, and code structures are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Similar to Case 5, this is an out-of-bounds read (CWE-125) in tcpdump's protocol parser. The target code, while also performing bounds checking on a buffer, is from a completely different system (Ghostscript vs. tcpdump) and domain (graphics rendering vs. network analysis). The specific code patterns for validating lengths are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both could involve integer calculations that affect buffer access (CWE-190 leading to CWE-787). The target code uses integer arithmetic for buffer offsets (`(y0 + y) * bpl`), but includes a guard. VulSpec Case 7 (CVE-2019-25034) is an integer overflow in DNS domain name length calculation. The domains and specific arithmetic patterns (multiplication for offset vs. addition for length) are different, but the high-level concern of integer issues leading to buffer corruption is a loose parallel.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image processing and memory buffer safety (CWE-119). The target code reads from an image buffer, while VulSpec Case 8 (CVE-2017-12982) involves improper validation of image header values leading to allocation issues in OpenJPEG. The connection is generic (image data handling), but the specific vulnerability mechanisms (bounds check bypass vs. allocation failure due to bad input) and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. VulSpec Case 9 (CVE-2017-18249) is a race condition (CWE-362) in a Linux kernel filesystem's node ID management. The target code is a single-threaded, deterministic function for checking pixel values in a printer driver. There is no concurrency or resource management state issue present in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. VulSpec Case 10 (CVE-2011-1003) is a double free (CWE-415) in ClamAV's document parser. The target code performs read-only operations on a buffer and returns an integer. There is no dynamic memory allocation or freeing logic in the provided function, making this case irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2017-17784_before_exclude_100:aca3d5c6:vulspec": {
    "timestamp": "2026-01-16T21:25:27.734251",
    "cve_id": "CVE-2017-17784",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "aca3d5c6",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a GIMP brush file loader, not a regular expression engine. The vulnerability type (CWE-125) is superficially similar, but the trigger conditions (NUL bytes in regex patterns) and code patterns (string parsing vs. binary file parsing) are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve file parsing and potential integer issues leading to memory corruption. However, the target code performs careful size validation (checking G_MAXSIZE) and uses `gsize` for `size`. The vulnerability pattern (integer overflow/wraparound in allocation) is not directly mirrored here, as allocation uses `g_malloc(size)` after validation. The attack surface (binary brush header) is different from a network protocol.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. This is the exact vulnerability in the exact same function (`load_image` in `file-gbr.c`). The CWE-125 (Out-of-bounds Read) is triggered by improper UTF-8 validation in the brush name field. The target code shows the vulnerable pattern: reading `bn_size` bytes into `temp`, then passing it to `gimp_any_to_utf8` without guaranteed null-termination, which could lead to a heap buffer over-read. The code context, vulnerability type, and trigger conditions are identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-17784"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Both involve CWE-125, but the domains are entirely different (XML parsing vs. binary image file parsing). The code patterns (tag parsing state machines vs. structured file header reads) and attack surfaces (malformed XML vs. malformed GBR file) share no similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are GIMP file format parsers (XWD vs. GBR) and involve CWE-787 (Out-of-bounds Write). The vulnerability patterninsufficient validation of header fields leading to incorrect memory writesis conceptually similar. The target code has validation for width/height/bytes but writes pixel data via `gimp_pixel_rgn_set_rect`. A logic error in validation could lead to a similar out-of-bounds write. The reference value is moderate as it highlights a class of vulnerability common to GIMP plugins.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve image file parsing. The vulnerability (CWE-681, incorrect numeric conversion) is not prominently seen in the target code, which uses `g_ntohl` for endian conversion and checks `bh.bytes` values. The target code's switch on `bh.bytes` (1,2,4,18) and subsequent processing has some similarity to format-specific decoding, but the specific integer signedness flaw and infinite loop trigger are not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Both involve CWE-125, but the context is completely different (character encoding processing in XML vs. binary data reading). The target code reads fixed-size structures and allocated buffers based on calculated sizes. It does not perform the kind of incremental, stateful character-by-character parsing that is the source of the libxml2 vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve CWE-125 from reading data based on untrusted input. The target code calculates `size` from header fields (after validation) and reads exactly that amount with `read(fd, brush_buf, size)`. This is a simpler pattern than the network packet parsing in tcpdump. The similarity is in the general principle of validating size before read, but the code patterns and attack surfaces differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are GIMP file format parsers (PSP vs. GBR) with the same CWE-125 vulnerability related to string handling. The attack surface is similar: a malicious file with malformed string data in a metadata field (creator block in PSP, brush name in GBR). The vulnerability patternreading data into a buffer and then processing it as a string without proper termination validationis highly analogous. The PSP case provides valuable reference for the same class of bug in a different GIMP plugin.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve image processing and CWE-119/125/787 memory safety issues. The target code has explicit size calculation (`size = bh.width * bh.height * bh.bytes`) and validation (check against `G_MAXSIZE`), which is the core defense against the type of vulnerability described. The PHP/GD case is about incorrect bounds checking in a different layer (library wrapper). The relevance is in the general need for rigorous size validation when dealing with untrusted image dimensions.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2021-27212_before_exclude_100:83de7d25:vulspec": {
    "timestamp": "2026-01-16T21:25:28.938872",
    "cve_id": "CVE-2021-27212",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "83de7d25",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a parser for a GSER format string, performing bounds-checked string manipulation. CVE-2016-3179 involves use-after-free and double-free in a network service daemon's memory management. The vulnerability type (memory corruption vs. parsing logic), domain (network service vs. data format validation), and attack surface (local socket vs. crafted data string) are fundamentally different. Relevance is very low.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write in a VNC file transfer component. The target code performs careful length decrements (`x.bv_len -= ...`) and checks for sufficient length at the start, but does not perform complex arithmetic that could overflow. The core vulnerability pattern (integer overflow in allocation) is not present. The shared theme of parsing untrusted input provides only minimal relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-14461 is an out-of-bounds read in a protocol parser (tcpdump's LDP) due to insufficient validation of a length field. The target code is also a parser (for GSER) that meticulously tracks a remaining length (`x.bv_len`) and uses it to bound loops (`for ( ; tu->bv_len < x.bv_len; tu->bv_len++ )`). While the target code appears to manage bounds correctly, the functional context (parsing a structured format with length tracking) and the potential consequence of missing a check (leading to OOB read) are similar. The vulnerability type differs (OOB Read vs. the target's potential for OOB Read if logic flawed), but the defensive coding patterns are highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to improper handling of NUL bytes. The target code parses a delimited string format where quotes (`\"`) are special, but it does not treat `\\0` as a terminator; it uses explicit length (`bv_len`). The connection is tenuous, relating only to the broad category of \"parsing complex input.\" The specific vulnerability mechanism (NUL byte confusion in C strings) is not applicable to this length-tracked buffer code.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-15166 is fundamentally about improper input validation (CWE-20) in a network protocol parser (tcpdump's LMP), leading to potential OOB access. This is the most direct parallel to the target code's purpose: validating the syntax and structure of an untrusted input string. The target code performs extensive validation (checking for `{`, `}`, keywords, spaces, commas, quotes) and returns `LDAP_INVALID_SYNTAX` for any deviation. The code patterns (sequential checks, length validation) are very similar to what a secure protocol parser should do. The main difference is the specific protocol being parsed.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2019-25034 involves an integer overflow during domain name length calculation, leading to an out-of-bounds write. The target code performs simple subtraction on buffer lengths (`x.bv_len -= STRLENOF(\"issuer\")`). These operands are derived from the fixed string length of keywords and the already-checked total input length, making an integer wrap-around highly unlikely. The vulnerability pattern (arithmetic overflow on attacker-controlled data) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-19333 involves a stack overflow in a YANG model parser due to deep recursion. The target code is a simple, linear, iterative parser with no recursion. The domain (data modeling language vs. simple attribute string), vulnerability type (stack overflow vs. potential buffer mishandling), and code structure are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to insufficient bounds checking. Similar to case 3, the target code shares the context of parsing a structured format and the critical need for bounds checking. However, the XML parser's complexity (state management, element stack) is much higher than this simple, flat keyword-value parser. The relevance stems from the common requirement to prevent OOB reads when walking a buffer.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-9226 is an out-of-bounds write in a regex compiler due to improper validation of escape sequences. The target code does not compile patterns, interpret escape sequences (except for skipping double quotes `\"\"`), or write to calculated indices. Its writes are either to a fixed output structure or within a newly allocated buffer filled via simple iteration. The domains and vulnerability mechanisms are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2018-5813 involves an infinite loop due to improper validation of offsets in a file parser. The target code has several loops that decrement `x.bv_len` and could theoretically loop forever if the length decrement logic was flawed (e.g., not decrementing within the \"eat leading spaces\" loop). However, the loops are correctly structured (`for ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- )`), making an infinite loop unlikely. The connection is superficial: both parsers must ensure loop termination, but the root cause (crafted file offsets vs. malformed string syntax) and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5813"
        }
      }
    ]
  },
  "CVE-2021-27212_after_exclude_100:73ddd745:vulspec": {
    "timestamp": "2026-01-16T21:25:29.497936",
    "cve_id": "CVE-2021-27212",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "73ddd745",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a parser for a GSER format string, performing bounds-checked reads and memory allocation. CVE-2016-3179 is a Use-After-Free in a network daemon's service registration logic. The vulnerability type (UAF vs. parsing logic), domain (network service vs. data format validation), and attack surfaces (local socket vs. crafted input string) are fundamentally different. The only weak similarity is in C resource management.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write in a network protocol file transfer handler. The target code performs careful length decrements and checks (e.g., `x.bv_len < STRLENOF(...)`), and its memory allocation (`slap_sl_malloc`) uses a calculated size (`is->bv_len - numdquotes`) that is derived from validated input bounds, making an integer overflow unlikely. The domains (VNC file transfer vs. LDAP syntax validation) and primary vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both the target code and CVE-2018-14461 involve parsing a structured format (GSER vs. LDP TLV) with explicit length tracking and validation. The target code meticulously maintains `x.bv_len` and checks it before decrements and accesses, which is the correct pattern to avoid CWE-125. The vulnerability class (out-of-bounds read due to insufficient validation) is directly relevant to the kind of bugs this code aims to prevent. The scoring is not higher because the attack surface (packet vs. LDAP data) and specific parsing logic differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code is a parser for a well-delimited string format where NUL bytes are not special; it tracks length explicitly (`bv_len`) and does not rely on null-terminated strings for its core parsing logic. The vulnerability type (CWE-125) is similar, but the trigger condition (embedded NULs) and code domain (regex compilation vs. structured field parsing) are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-15166 stems from CWE-20 (Improper Input Validation) in a network protocol parser, which is highly relevant to the target code's purpose. The target code is essentially a validation function (`issuerAndThisUpdateCheck`) that performs extensive syntax and bounds checking on its input. The pattern of validating fields, checking lengths, and ensuring no leftover characters is directly comparable to the missing checks that would cause vulnerabilities like this one. The difference lies in the specific protocol being parsed.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2019-25034 involves an integer overflow in domain name length calculation leading to an out-of-bounds write. The target code performs arithmetic on lengths (e.g., `is->bv_len - numdquotes`), but `numdquotes` is counted during a bounded scan of `is->bv_len`, so the result cannot underflow. The code uses `ber_len_t` (likely unsigned) and the context is very different (DNS wire format conversion vs. GSER string parsing). The core vulnerability mechanism is not mirrored here.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-19333 is in a YANG model parser and canonical value processor. The target code is a simple, syntax-driven validator and transformer for a specific LDAP-related format. The domains (data modeling language vs. application protocol syntax), complexity, and likely vulnerability patterns (type confusion, complex state) are not comparable. Both parse structured text, but that is the extent of the similarity.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to insufficient bounds checking. The target code is also a parser that must carefully manage bounds. The key difference is that the target code explicitly tracks and validates the remaining length (`x.bv_len`) before every access and decrement, which is the correct mitigation for CWE-125. The relevance lies in the shared need for rigorous length validation in any parser, but the implementation patterns differ (explicit length variable vs. pointer comparisons).",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-9226 is an out-of-bounds write in a regex engine's compilation phase due to improper validation of escape sequences. The target code does not compile a state machine or process escape sequences in a way that could lead to miscalculated writes. Its memory write (`ni.bv_val[dst] = is->bv_val[src]`) is tightly bounded by the previously calculated `ni.bv_len`. The domains and vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2018-5813 involves improper offset validation leading to an infinite loop. The target code has several loops that condition on `x.bv_len`, which is decremented within the loops. However, the decrements are paired with pointer increments and are guarded by checks that the decrement amount does not exceed the remaining length (e.g., `x.bv_len -= is->bv_len + 1` only occurs after `is->bv_len` was counted within `x.bv_len`). This makes an infinite loop unlikely. The domain (image file parsing vs. string validation) is also different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5813"
        }
      }
    ]
  },
  "CVE-2018-20020_after_exclude_100:a908594b:vulspec": {
    "timestamp": "2026-01-16T21:25:40.925523",
    "cve_id": "CVE-2018-20020",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a908594b",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve LibVNC/libvncserver and protocol parsing. The target code handles CoRRE encoding with integer validation (hdr.nSubrects check against RFB_BUFFER_SIZE), which relates to CWE-190/787 concerns. However, the specific vulnerability in CVE-2018-20750 is in the file transfer subsystem, not the core CoRRE/BPP protocol handling. The pattern of validating counts against buffer sizes is similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free in a completely different system (MiniSSDPd) and subsystem (SSDP service discovery). The target code shows no dynamic memory allocation or pointer management that could lead to a use-after-free. The attack surfaces and functional domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing external data (BMP headers vs. VNC CoRRE packets) and have bounds checking. CVE-2017-12982's core issue is an unchecked integer leading to a huge allocation (CWE-119). The target code has a guard check (`hdr.nSubrects > RFB_BUFFER_SIZE / (4 + (BPP / 8))`) which is a similar validation pattern, but the vulnerability type (allocation failure vs. buffer overflow) and context differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code is a network protocol parser that reads structured binary data. The vulnerability patterns (string parsing vs. binary structure parsing), attack surfaces (regex patterns vs. network packets), and root causes are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve parsing binary network protocols (LDP vs. VNC RFB) and have length/field validation. CVE-2018-14461 is a CWE-125 (Out-of-bounds Read) due to insufficient TLV length validation. The target code validates `nSubrects` against a buffer size before reading, which is a similar defensive pattern. The relevance is in the protocol parsing and bounds-checking paradigm, though the specific flaw differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-1000222 is a Double Free in an image library during error handling. The target code has no apparent dynamic memory allocation/deallocation; it uses a client-provided buffer. The error paths return FALSE but don't free resources. The memory management models and vulnerability types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to insufficient allocation padding. The only faint similarity is that both deal with calculating buffer sizes based on input data (`hdr.nSubrects * (4 + (BPP / 8))`). However, the target code's calculation is simple and checked against a fixed buffer size, whereas the OpenJPEG flaw involves complex size calculations for compression. The domain and flaw specifics are distant.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2019-25034 involves an integer overflow in length calculation leading to an out-of-bounds write (CWE-190->787). The target code performs an integer calculation `hdr.nSubrects * (4 + (BPP / 8))` and uses it as a read size. The guard check uses division to prevent overflow, which is a direct mitigation for the type of integer overflow seen in this CVE. The pattern of validating a count before a multiplication is highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-8670 is a buffer handling issue in PHP's GD integration. The connection is tenuous: both involve moving data into buffers. The target code's buffer operation is straightforward with a size check, while the PHP flaw is about incorrect size calculations during data transfer. The domain (image processing vs. remote desktop protocol) and code patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to character encoding issues. The target code parses simple binary structures with explicit field sizes. The vulnerability patterns (complex text/encoding parsing vs. structured binary parsing) and root causes are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2018-20020_before_exclude_100:b0a2cd73:vulspec": {
    "timestamp": "2026-01-16T21:25:41.969662",
    "cve_id": "CVE-2018-20020",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b0a2cd73",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve LibVNC/libvncserver and protocol parsing. The target code handles CoRRE encoding, which involves reading a variable number of subrectangles (`hdr.nSubrects`). The vulnerability pattern is similar: insufficient validation of a count field (`nSubrects`) leading to potential buffer overflow. However, CVE-2018-20750 is in the file transfer subsystem, not the core CoRRE/RRE protocol handler. The integer overflow/wraparound (CWE-190) and out-of-bounds write (CWE-787) pattern is conceptually relevant to the unchecked multiplication `hdr.nSubrects * (4 + (BPP / 8))`.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free (CWE-416) in a minimal SSDP daemon (MiniSSDPd). The target code is a VNC protocol handler in LibVNC. The domains (remote desktop vs. service discovery), vulnerability types (buffer overflow vs. UAF), and code patterns (network data parsing vs. local socket state management) are fundamentally different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing untrusted input (network data vs. image files) and have potential for memory corruption due to unchecked values. CVE-2017-12982 is an allocation failure due to an unchecked header value (biBitCount=0) in OpenJPEG's BMP converter. The target code has an unchecked `nSubrects` value used in a buffer size calculation. The similarity is in the \"unchecked input leads to problematic allocation/access\" pattern, but the specific vulnerability (allocation failure vs. buffer overflow) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an Out-of-bounds Read (CWE-125) in Perl's regex engine due to improper NUL byte handling. The target code is a binary protocol parser in C. While both parse input, the vulnerability mechanism (string termination confusion vs. integer overflow/buffer bounds) and domain (textual regex vs. binary graphics protocol) are vastly different. Little reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-14461 is an Out-of-bounds Read (CWE-125) in tcpdump's LDP parser due to insufficient validation of a TLV length field. The target code reads a header with a `nSubrects` count and uses it to calculate a read size. The pattern of \"parsing a length/count from untrusted input and using it to read data without sufficient bounds checking\" is similar. However, the target code's primary risk is an out-of-bounds write to the `client->buffer` or incorrect pointer arithmetic, not just a read. The network protocol parsing context is a point of similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-1000222 is a Double Free (CWE-415) in libgd's BMP handling during error cleanup. The target code shows no dynamic memory allocation or free operations; it uses a pre-allocated `client->buffer`. The vulnerability classes and code patterns (memory ownership vs. buffer bounds checking) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2017-14151 is a buffer overflow (CWE-119) in OpenJPEG due to insufficient buffer padding calculation. The target code has a potential buffer overflow if `hdr.nSubrects * (4 + (BPP / 8))` exceeds `RFB_BUFFER_SIZE`. Both involve calculating a buffer size based on input parameters and failing to ensure it fits within a fixed or allocated buffer. The arithmetic for size calculation and the risk of overflow/wraparound are similar concepts, though the specific contexts differ (image encoding vs. protocol decoding).",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-25034 is an Integer Overflow (CWE-190) leading to an Out-of-bounds Write (CWE-787) in Unbound's DNS name parser. This is highly relevant to the target code's pattern: `hdr.nSubrects * (4 + (BPP / 8))` could overflow on 32-bit systems if `nSubrects` is large, bypassing the check against `RFB_BUFFER_SIZE` and leading to a buffer overflow in the subsequent `ReadFromRFBServer` call. The vulnerability chain (integer overflow in size calculation -> insufficient validation -> buffer overflow) is conceptually identical. The main difference is the application domain (DNS vs. VNC).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-8670 is a buffer overflow in PHP's GD wrapper due to incorrect bounds checking. The target code also has a bounds check (`> RFB_BUFFER_SIZE`). The similarity is the general theme of insufficient input validation leading to buffer operations beyond bounds. However, the specific mechanism in the PHP case is more about a logic error in size comparison, while the target code's primary risk is an integer overflow before the comparison. The reference value is limited.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an Out-of-bounds Read (CWE-125) in libxml2 due to improper multi-byte character encoding handling. The target code deals with simple binary data, not text encoding. The vulnerability patterns (complex stateful text parsing errors vs. arithmetic-based buffer size miscalculation) are not similar. No meaningful reference for the target code's issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2022-2580_after_exclude_100:4a232f61:vulspec": {
    "timestamp": "2026-01-16T21:25:47.061312",
    "cve_id": "CVE-2022-2580",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4a232f61",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. The target code is a string evaluator for Vim script, handling escape sequences and interpolation. While both parse special sequences, the vulnerability type (OOB read vs. potential buffer management issues), domain (regex vs. script string), and attack surface are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1833 is an out-of-bounds read in libxml2 due to multi-byte character processing. The target code also processes multi-byte characters (via MB_PTR_ADV, MB_COPY_CHAR) and hex/Unicode escapes, sharing a theme of careful buffer/pointer management during encoding. However, the vulnerability root cause (parser state error recovery) and domain (XML vs. script string) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's service registration. The target code performs string copying and allocation but does not involve complex state management, error cleanup, or network protocol handling that could lead to UAF in a similar manner. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1838 is an out-of-bounds read in libxml2 during end tag parsing. The target code parses string literals with delimiters (quotes) and tracks pointers (`p`, `end`), requiring careful bounds awareness. Both involve ensuring pointer stays within bounds during sequential parsing, but the specific context (XML structure vs. escape sequence expansion) and vulnerability trigger are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in allocation size calculation. The target code calculates `len` and allocates memory based on `extra` (which is incremented conditionally). If `extra` could be manipulated to cause an integer overflow or underflow in `len`, a similar vulnerability might occur. The pattern of calculating buffer size based on input features is shared, but the specific integer overflow vector is not obvious in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-1834 is a heap buffer overflow due to improper length validation in string operations. The target code allocates a buffer of size `len` and then writes data into it via `end` pointer, with a check (`if (end >= rettv->vval.v_string + len)`) to detect overflows. This mirrors the concern of writing beyond allocated bounds. The vulnerability pattern (incorrect size calculation or insufficient bounds checking during copy) is conceptually similar, though the specific trigger (negative length) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2018-14353 is an integer underflow during string quoting length calculation. The target code uses an `extra` variable to adjust the allocated length based on escape sequences (`extra += 5` for `\\<...>`, `--extra` for `{{`/`}}`). If input manipulation could cause `extra` to become negative enough to make `len` negative or wrap, it could lead to buffer under-allocation and overflow. The pattern of dynamically adjusting buffer size based on input escapes is very similar, making this a valuable reference for auditing the `extra`/`len` logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-19333 is in a YANG parser's canonical value processing. The target code evaluates string literals, not data model validation. There is no overlap in functionality, vulnerability type, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1835 is a use-after-free in libxml2 attribute processing. The target code allocates a string and writes to it but does not free and later reuse memory within this function. The memory management pattern is simple allocation and population, not complex state-dependent freeing. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-13224 is a use-after-free in Oniguruma due to encoding conversion mismatches. The target code handles multi-byte characters and encoding conversion (`mb_char2bytes`), but within a single string evaluation context without reallocation or free operations. The vulnerability pattern (UAF across encoding contexts) does not apply here.",
        "case_metadata": {
          "cve_id": "CVE-2019-13224"
        }
      }
    ]
  },
  "CVE-2022-2580_before_exclude_100:5f301891:vulspec": {
    "timestamp": "2026-01-16T21:25:50.600306",
    "cve_id": "CVE-2022-2580",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5f301891",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve string parsing and escape sequence handling, but the core vulnerability differs. CVE-2018-18313 is an out-of-bounds read in a regex engine due to NUL byte handling. The target code handles escape sequences (like \\x, \\u) and string termination with NUL, but its primary logic is about calculating buffer sizes and copying characters, with explicit checks for NUL termination. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing structured text (XML vs. Vim script string) and character encoding/escape sequence processing. CVE-2016-1833 is an out-of-bounds read in an XML parser due to multi-byte character handling. The target code also processes multi-byte characters (via MB_PTR_ADV, MB_COPY_CHAR) and calculates buffer lengths. However, the domain (XML vs. Vim script string literals) and specific trigger conditions (parser state errors vs. string interpolation) are different. The target code's extra length calculation for escapes shows some conceptual similarity to buffer management issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free in a network daemon related to memory management of service structures. The target code is a string evaluation function with static buffer allocation (via alloc()) and no complex pointer management or freeing logic. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-1838 is an out-of-bounds read in an XML end-tag parser. The target code parses string literals up to a terminating quote or expression start. Both involve bounds-checked traversal of an input buffer. However, the target code's loop condition explicitly checks for NUL and '\"', and it calculates the output buffer size beforehand, making an out-of-bounds read less likely in its core logic. The relevance is in the general pattern of parsing delimited input.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs arithmetic for an `extra` length variable and allocates based on `len`. While there is a potential for miscalculation (e.g., in the `extra += 5` for \"\\<\" or the `--extra` for \"{{\"), it uses signed ints and the final `alloc(len)` could theoretically overflow if `len` is negative or huge, but the code context (string literal parsing) makes extreme values unlikely. The vulnerability pattern (integer wrap in network data) is not directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-1834 is a buffer overflow due to improper length validation in string operations. The target code has a very similar pattern: it calculates a required buffer length (`len`) based on input parsing, allocates it, then copies processed data into it. Crucially, it has a safety check: `if (end >= rettv->vval.v_string + len) iemsg(...)` inside the `trans_special` handling, indicating awareness of buffer bounds. This mirrors the core issue of CWE-119. The relevance is strong in the pattern of calculating size, allocating, and writing, though the target code includes a check the libxml2 vulnerability lacked.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2018-14353 is an integer underflow in string quoting/escaping leading to buffer overflow. The target code's core function is string evaluation with escape sequence and interpolation handling, which is conceptually similar to quoting. It calculates an `extra` buffer size adjustment (which can be incremented or decremented) and a final `len`. The logic with `--extra` for \"{{\" and \"}}\" could, in theory, lead to a negative `len` if there are more interpolated braces than other escape expansions, though the parsing loop structure makes this unlikely. The pattern of modifying a length variable during parse and later using it for allocation is directly comparable to the vulnerability mechanism in NeoMutt.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-19333 is in a YANG model parser and canonical value processor. The target code is a low-level string evaluator for a scripting language. Both parse input, but the domains (data modeling vs. script string literals), data structures, and vulnerability patterns (type confusion/canonicalization issues vs. buffer management) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1835 is a Use-After-Free in an XML attribute parser during complex state changes. The target code allocates a single buffer and writes into it without freeing or reallocating it within the function. There is no manipulation of external data structures that could lead to a use-after-free. The vulnerability types are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-13224 is a Use-After-Free in a regex library due to encoding conversion issues. The target code handles different character encodings via `mb_char2bytes` for `\\u` and `\\U` escapes, and uses multi-byte aware macros. However, it does not dynamically change encodings mid-process or manage complex internal objects prone to use-after-free. The connection is only at the very high level of \"processing encoded text.\"",
        "case_metadata": {
          "cve_id": "CVE-2019-13224"
        }
      }
    ]
  },
  "CVE-2021-39537_before_exclude_100:019626cb:vulspec": {
    "timestamp": "2026-01-16T21:25:55.304419",
    "cve_id": "CVE-2021-39537",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "019626cb",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a character conversion function with no dynamic memory management (no malloc/free). CVE-2016-3179 is a Use-After-Free vulnerability in a network daemon's memory management for service structures. The domain (character processing vs. network service), vulnerability type (logic error vs. memory lifecycle), and code patterns are completely different. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both the target code and CVE-2018-18313 (Perl regex engine) involve parsing and interpreting escape sequences in input strings. The target code handles octal escapes (e.g., \\123) and control characters (e.g., ^A), similar to regex engines processing special characters. The vulnerability type differs (OOB read vs. potential logic/overflow in target), but the input domain and parsing logic are comparable, providing reference for escape sequence handling pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve character/encoding processing. However, CVE-2018-20760 is an out-of-bounds write in a UTF conversion function due to missing error checks on return values. The target code performs simple character conversion and formatting into a buffer (`dp`), but the buffer management (`save_string`, `save_char`) is not shown and is likely safe. The vulnerability mechanism (OOB write from unchecked conversion) is not directly mirrored in the visible logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to OOB write in a network file transfer protocol. The target code performs local, bounded arithmetic on character values (e.g., `c / 100`) with no network input, no large integers, and no dynamic allocation visible. Domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. CVE-2017-9226 is an out-of-bounds write in a regex library due to improper validation of octal escape sequences. The target code explicitly processes octal escape sequences (case '0'..'3') and calculates a value `c = UChar(8 * c + (*sp++ - '0'))`. If the input string contains a sequence like \"\\777\" (octal 511 > 255), the result is truncated by `UChar()` (likely to unsigned char). This could lead to truncation/wraparound (CWE-190/197), potentially causing logic errors or, if `c` is used as an index/size later, memory corruption. The vulnerability pattern is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-1833 is an OOB read in an XML parser due to improper buffer management during multi-byte character processing. The target code processes a character string sequentially but does not appear to perform complex multi-byte encoding or buffer bounds checks on `sp`. However, it uses `UChar(*sp)` and increments `sp` carefully within the octal digit loop. The relevance is in the general domain of parsing input strings, but the specific vulnerability (OOB read from encoding) is not strongly present.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14461 is an OOB read in a network protocol parser due to insufficient validation of a length field. The target code parses a local string format with no explicit length field. Both parse structured input, but the attack surface (network packet vs. local string), data types, and vulnerability trigger are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an OOB read in an XML parser during end tag processing. The target code is not parsing a hierarchical markup language and does not have a comparable state machine for elements/tags. The only similarity is parsing characters from an input buffer.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double-free in a file parsing module during error handling. The target code shows no dynamic memory allocation or deallocation. The domains (antivirus file parsing vs. character conversion) and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-15166 is an improper input validation (missing bounds check) in a network protocol parser. The target code validates input implicitly through switch cases and `isdigit`, but does not check if `sp` advances beyond the string's end during the octal digit loop (e.g., while `isdigit(UChar(*sp))`). If `sp` is not null-terminated, this could lead to an OOB read. However, the context and scale are different: a local string function vs. a network packet decoder. The \"improper validation\" aspect is a minor similarity.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2021-39537_after_exclude_100:449bc658:vulspec": {
    "timestamp": "2026-01-16T21:25:58.558566",
    "cve_id": "CVE-2021-39537",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "449bc658",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability in a network daemon's memory management. The target code is a character conversion function with no dynamic memory allocation, pointer manipulation, or network protocol handling. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2018-18313 involves improper handling of NUL bytes in a regex engine, leading to an out-of-bounds read. The target code also processes escape sequences and character conversions, and contains a switch case for '\\0' (NUL byte). While the vulnerability type (OOB read vs. potential logic/calculation errors) and system domain differ, both involve parsing special character sequences where NUL handling is critical, providing some reference value for input validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20760 is an out-of-bounds write in a text encoding conversion function. The target code also performs character conversion and writes to a buffer via `save_char`/`save_string`. The core similarity is text/character processing. However, the vulnerability mechanism (missing error code validation leading to OOB write) is not directly apparent in the provided code snippet, which lacks the buffer management context. The relevance is limited to the domain of character encoding/transformation.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs arithmetic on characters (e.g., `8 * c + (*sp++ - '0')`, `c / 100`) but these are on single-byte values, making overflow unlikely and of a different scale. The domains (VNC protocol vs. local character conversion) and primary vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2017-9226 is an out-of-bounds write in a regex library due to insufficient validation of octal escape sequences. The target code has a dedicated branch for parsing octal escape sequences (`case '0'...'3'`). It multiplies by 8 and adds digits, which could potentially overflow the `unsigned char c` if too many digits are processed, leading to an integer overflow/truncation. The code pattern (parsing numeric escapes) and the potential for value miscalculation are very similar, providing high reference value for validating octal digit sequences and result ranges.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper buffer management during multi-byte character processing. The target code processes a character stream but operates on a single input pointer (`sp`) without obvious complex buffer management or multi-byte decoding. The vulnerability type (OOB read) is not directly indicated in the provided function, which seems to calculate a length based on the input. The only similarity is in the broad domain of text/character processing.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code is not parsing a TLV-style network protocol. It calculates a `len` variable, but this appears to be the number of source characters consumed, not a length field read from untrusted data. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser during end tag processing. The target code is not parsing structured markup language tags. Both involve parsing sequences of characters from an input, but the specific patterns (XML tags vs. escape sequences) and the resulting vulnerability mechanism (OOB read vs. other potential issues like integer overflow in case 5) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double-free vulnerability in a document parser's error handling path. The target code shows no dynamic memory allocation or freeing. It writes to a `dp` pointer presumably managed elsewhere, but the vulnerability class (memory corruption via double-free) and the code patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-15166 is an improper input validation issue in a network protocol parser, lacking bounds checks. The target code does perform some input validation (checking for `'\\0'`) within its parsing logic, but it is not parsing complex network protocol structures with explicit length fields. The domains and the scale of the parsing problem are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2022-1195_before_exclude_100:d9ef4fdf:vulspec": {
    "timestamp": "2026-01-16T21:26:01.324254",
    "cve_id": "CVE-2022-1195",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d9ef4fdf",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in the FUSE subsystem due to improper iovec validation. The target code is a TTY line discipline close function handling resource cleanup and reference counting. Different subsystem, vulnerability type (buffer overflow vs. use-after-free/race condition prevention), and attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-10154 is a cryptographic buffer issue related to SMB authentication and VMAP_STACK. The target code is a TTY close routine performing cleanup. No cryptographic operations, scatterlist handling, or stack memory concerns are present.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2013-1792 is a race condition (CWE-362) leading to a NULL pointer dereference (CWE-476) in the keyring subsystem. The target code also involves shared resource management (disc_data_lock) and reference counting to prevent use-after-free during close. While the subsystems differ, the core concurrency issue (ensuring safe cleanup with shared references) is conceptually similar. The target code uses refcount and completion to avoid a race, which is the fix pattern for such vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-16914 is a NULL pointer dereference (CWE-476) in USB/IP due to insufficient validation of URB fields. The target code checks for a NULL `ax` pointer early, but its primary concern is safe cleanup, not input validation. The similarity is limited to the presence of pointer checks to prevent crashes, but the vulnerability patterns (protocol validation vs. lifecycle management) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2014-0196 is a race condition (CWE-362) in the TTY subsystem (n_tty line discipline) leading to memory corruption. The target code is also in the TTY subsystem (mkiss line discipline) and explicitly uses locking (disc_data_lock) and reference counting (refcount_dec_and_test) to prevent race conditions during close operations. Both involve managing concurrent access to TTY discipline data. The target code demonstrates the correct pattern to avoid such races, making it highly relevant for understanding TTY subsystem concurrency vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-18249 is a race condition (CWE-362) in F2FS nid management. The target code uses synchronization (lock, refcount, completion) to prevent race conditions during resource cleanup. While the subsystems are different (filesystem vs. TTY network driver), the core issue of ensuring safe state transitions and preventing concurrent access to shared resources (ax structure) is similar. The reference counting pattern is a common solution for such problems.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to improper NUL byte handling. The target code performs resource cleanup in a kernel driver. No string parsing, regex, or buffer over-read patterns are present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3137 is a NULL pointer dereference in a USB serial driver due to insufficient endpoint validation. The target code is also a driver (TTY line discipline) and checks for NULL. However, the vulnerability root cause differs: one is missing validation of external device descriptors, the other is internal lifecycle management. The connection is superficial (both are drivers).",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a VNC server library. The target code performs straightforward memory deallocation with no complex arithmetic, input parsing, or heap corruption patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2014-0131 is a use-after-free (CWE-416) in the networking subsystem's skbuff handling. The target code's primary purpose is to prevent a use-after-free by using reference counting (refcnt) and waiting for completion (dead) before freeing resources (ax->dev, ax->rbuff, etc.). The vulnerability patterns are related: both deal with ensuring memory is not accessed after being freed. The target code exemplifies a safe cleanup pattern relevant to fixing use-after-free vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      }
    ]
  },
  "CVE-2022-1195_after_exclude_100:f346a2fc:vulspec": {
    "timestamp": "2026-01-16T21:26:14.776836",
    "cve_id": "CVE-2022-1195",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f346a2fc",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in the FUSE subsystem's ioctl handling. The target code is a TTY line discipline close function performing cleanup and reference counting. Different subsystems, vulnerability types (buffer overflow vs. use-after-free/race condition potential), and attack surfaces.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-10154 is a buffer overflow/CWE-119 in the CIFS crypto stack related to scatterlist and VMAP_STACK. The target code performs resource cleanup in a network device driver. Different domains (filesystem crypto vs. TTY/netdevice), vulnerability patterns, and functionalities.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2013-1792 is a race condition (CWE-362) leading to a NULL pointer dereference (CWE-476) in the keyring subsystem during concurrent initialization. The target code uses `refcount_dec_and_test` and `wait_for_completion` for synchronization during close, indicating awareness of concurrency issues. While the specific bug pattern differs (race during init vs. cleanup), both involve managing shared resources (refcount/state) across concurrent execution, making the synchronization concepts relevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-16914 is a NULL pointer dereference (CWE-476) in the USB/IP subsystem due to insufficient validation of URB fields. The target code also performs cleanup and could potentially dereference NULL if `ax->dev` were incorrectly set, but the primary vulnerability pattern is different (protocol validation flaw vs. lifecycle management). Both involve kernel driver cleanup paths, providing some weak reference for ensuring pointer validity before use.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2014-0196 is a race condition (CWE-362) in the TTY subsystem's n_tty line discipline, leading to memory corruption. The target code is part of the TTY subsystem (`mkiss_close` is a TTY line discipline close function). Both deal with TTY line disciplines, concurrent access, and proper synchronization. The target code explicitly uses refcounting and completion to manage concurrency during close, directly addressing the type of concurrency issue present in this VulSpec case. The domain and core concurrency concerns are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-18249 is a race condition (CWE-362) in the F2FS filesystem's node ID management. The target code uses refcounting to manage concurrent access to a `struct mkiss` during close. While the subsystems are different (filesystem vs. TTY/networking), the core vulnerability theme is improper synchronization of shared resource state transitions (allocation/free vs. open/close). The pattern of using atomic operations (`refcount_dec_and_test`) to manage lifecycle is conceptually relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) in Perl's regex engine due to improper NUL byte handling. The target code is a kernel TTY line discipline close routine performing memory deallocation and cleanup. Different languages (C vs. Perl core), domains (kernel driver vs. userland library), and vulnerability types (memory corruption during parsing vs. resource management).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3137 is a NULL pointer dereference (CWE-476) in a USB serial driver due to insufficient validation of USB descriptors. The target code is also a driver (for a TTY-based network protocol) and performs operations like `ax->dev` dereferencing. Both are kernel drivers with cleanup paths. However, the vulnerability root cause is different (missing validation of external device input vs. managing internal object state). The driver domain provides a weak link.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write (CWE-787) due to integer overflow in a userland VNC library. The target code is a kernel TTY line discipline function performing safe deallocation (`kfree`). Different environments (userland library vs. kernel), vulnerability types (integer overflow leading to heap corruption vs. potential use-after-free), and functionalities (protocol parsing vs. object lifecycle management).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2014-0131 is a use-after-free (CWE-416) in the kernel networking subsystem's skbuff handling. The target code also deals with kernel memory management (`kfree`) and network devices (`netif_stop_queue`, `unregister_netdev`). The relevance comes from both being in the kernel and involving careful sequencing of cleanup to avoid use-after-free (e.g., stopping queue before freeing buffers). However, the specific bug pattern (orphaned fragments) is not present in the simple, linear cleanup of the target code.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      }
    ]
  },
  "CVE-2021-41204_before_exclude_100:81adf156:vulspec": {
    "timestamp": "2026-01-16T21:26:15.284538",
    "cve_id": "CVE-2021-41204",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "81adf156",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a constant folding eligibility checker in a machine learning framework (likely TensorFlow). CVE-2015-7511 is a side-channel vulnerability in a cryptographic library's elliptic curve implementation. The domains (ML graph optimization vs. cryptography), vulnerability types (logic/DoS vs. timing side-channel), and code patterns (control flow for optimization vs. low-level arithmetic) are fundamentally different. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to improper NUL byte handling. The target code performs static analysis and validation of computational graph nodes. It does not parse untrusted data formats, perform string manipulation, or have buffer access patterns. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2013-0211 involves a numeric conversion error (signed/unsigned) leading to buffer overflow in libarchive. The target code performs size checks (`out_shape.num_elements() * DataTypeSize(...) > max_constant_size_in_bytes`) which is a form of integer overflow prevention, but the context is entirely different (memory safety for archive writing vs. resource limit enforcement for graph optimization). The similarity is very weak.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7972 is a resource management error (inconsistent memory tracking) in a subtitle renderer. The target code manages resource limits (`max_constant_size_in_bytes`) to prevent folding oversized constants, which is a form of resource management. However, the vulnerability pattern (allocation size mismatch) and domain (multimedia rendering vs. graph optimization) are distinct. Only a superficial similarity in considering resource limits.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-8860 is a buffer management vulnerability in Tor's network stack involving missing sentinel values and improper bounds restrictions. The target code does not handle network buffers, perform low-level memory operations, or deal with string termination. The code patterns and attack surfaces are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser due to unsafe hex string conversion. The target code does not parse external input strings, convert data formats, or use fixed-size stacks. The vulnerability mechanism is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-5844 is an integer overflow in libarchive's ISO9660 parser during file position calculation. The target code contains an integer multiplication check (`out_shape.num_elements() * DataTypeSize(...) > max_constant_size_in_bytes`) to prevent excessive memory allocation, which is a related defensive pattern against integer issues. However, the context (parsing file metadata vs. checking tensor sizes) and the specific overflow risk differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2014-9140 is a buffer overflow in a network packet parser due to insufficient bounds checking during byte unescaping. The target code performs no parsing of byte streams, no escape sequence processing, and operates on a structured graph representation. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2014-9140"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2014-9652 is an out-of-bounds read in a file identification tool due to improper validation of a length field from untrusted data. The target code reads from internal data structures (shape_map) which are not directly attacker-controlled in the same way. It validates sizes but does not process length-prefixed data from untrusted sources. The similarity is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-12899 is an out-of-bounds read in a network protocol parser due to incorrect bounds validation after processing padding. The target code does not parse network packets, handle padding fields, or perform sequential reads from a packet buffer. The vulnerability pattern is not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      }
    ]
  },
  "CVE-2022-1586_before_exclude_100:81845804:vulspec": {
    "timestamp": "2026-01-16T21:26:17.696224",
    "cve_id": "CVE-2022-1586",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "81845804",
    "scores": [
      {
        "score": 8,
        "reasoning": "High relevance. Target code is from PCRE2's JIT compiler (compile_xclass_matchingpath), which is a regular expression engine component similar to Perl's engine. Both handle complex character class parsing with Unicode support. The vulnerability type (CWE-125 Out-of-bounds Read) is plausible in this context due to similar pattern parsing logic, character sequence handling, and potential for improper bounds checking when processing character class data structures.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is a regex JIT compiler function, while CVE-2016-3179 affects a network service discovery daemon (MiniSSDPd). Different domains (regex compilation vs. network protocol), different vulnerability types (potential memory corruption in regex parsing vs. use-after-free in service management), and completely different attack surfaces.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Very high relevance. Both target code and vulnerability affect regular expression libraries (PCRE2 vs. Oniguruma). Both involve character class parsing ([...] constructs). The vulnerability type (CWE-787 Out-of-bounds Write) is highly relevant as the target code performs extensive array indexing and bit operations on character class data. Similar attack surfaces via malicious regex patterns and state transition handling.",
        "case_metadata": {
          "cve_id": "CVE-2017-9228"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Target code is regex compilation, while CVE-2011-1003 affects ClamAV's VBA extraction module. Different domains (regex vs. antivirus file parsing). The double-free vulnerability pattern is less relevant to the target code's structure which focuses on JIT compilation without complex resource cleanup paths shown.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is regex JIT compilation, while CVE-2019-15166 affects network packet parsing in tcpdump. Completely different domains, functionality, and vulnerability contexts. The improper input validation aspect is generic but implementation patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing structured data (character classes vs. Pascal strings), but domains differ significantly (regex engine vs. file type detection). The out-of-bounds read vulnerability pattern has some similarity, but the code structures and data handling are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Target code is regex character class compilation, while CVE-2010-1311 affects compression algorithm in antivirus software. Different domains and functionality. The buffer overflow pattern is generic but the specific context of sliding window decompression doesn't match the target code's operations.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve parsing structured text formats (regex patterns vs. XML). Both handle character encoding and buffer management. The out-of-bounds read vulnerability type is relevant, and both could suffer from similar bounds checking issues during complex input parsing.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Similar to case 8, both involve parsing structured text. The end tag parsing in XML has conceptual parallels with character class termination (XCL_END) in regex. Out-of-bounds read patterns during termination/end condition processing could be similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Target code is regex JIT compilation, while CVE-2017-14151 affects image codec memory allocation. Different domains and functionality. The buffer overflow concern is generic but the specific context of image block encoding with padding requirements doesn't match the target code's operations.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2021-41204_after_exclude_100:8f97fba0:vulspec": {
    "timestamp": "2026-01-16T21:26:18.631084",
    "cve_id": "CVE-2021-41204",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8f97fba0",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a constant folding eligibility checker in a machine learning framework (likely TensorFlow). It performs static analysis on computation graphs. CVE-2015-7511 is a cryptographic side-channel vulnerability in libgcrypt related to non-constant-time operations. The domains (ML graph optimization vs. cryptography), vulnerability types (logic flaw vs. side-channel), and code patterns (control flow for optimization vs. arithmetic for ECC) are fundamentally different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to improper NUL byte handling. The target code performs predicate checks and does not parse or compile untrusted data formats. It deals with graph node properties, not string/buffer manipulation. The vulnerability mechanisms (parsing errors leading to OOB read) and code contexts are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2013-0211 involves a numeric conversion error (signed/unsigned) in libarchive leading to potential buffer overflow. The target code performs size calculations (`out_shape.num_elements() * DataTypeSize(...) > max_constant_size_in_bytes`) which could theoretically involve integer overflows if not guarded. However, the target code's check uses multiplication and comparison, which is a defensive pattern, not the vulnerable one. The context (archive writing vs. graph optimization) and specific vulnerability pattern are weakly similar at best.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7972 is a resource management error (inconsistent memory tracking) in a subtitle renderer. The target code manages no dynamic resources (memory, file descriptors) itself; it only evaluates predicates. The \"resource\" mentioned (DT_RESOURCE) is a tensor type, not a system resource. The vulnerability class and operational context are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-8860 is a buffer management flaw in Tor's network stack, involving missing sentinel values and improper use with string functions. The target code does not handle buffers, network data, or strings. It inspects node attributes and shapes. No relevance in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser due to unsafe hex string conversion. The target code does not parse any input strings or perform conversions. It operates on an already-constructed graph. The attack surfaces and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-5844 is an integer overflow in libarchive's ISO9660 parser during file position calculation. As with case 3, the target code contains an integer multiplication and comparison (`num_elements() * DataTypeSize(...)`). If `num_elements()` or `DataTypeSize` were very large, this could overflow before the comparison, potentially bypassing the size check. This is a tangential similarity in a potential flaw pattern (integer overflow in a size check), but the target code's context (graph optimization) and the specific vulnerability (archive parsing) are very different. Provides minimal reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2014-9140 is a buffer overflow in a network packet parser (tcpdump) due to insufficient bounds checking during byte unescaping. The target code performs no parsing of byte streams, no unescaping, and no bounds checking on buffers. The domains and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2014-9140"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2014-9652 is an out-of-bounds read in a file type detection utility due to improper validation of a length field from file data. The target code reads properties from internal graph node objects, not from untrusted file contents. It does not process length-prefixed data from external sources. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-12899 is an out-of-bounds read in a network protocol parser (tcpdump) due to incorrect validation of packet boundaries after processing padding. The target code does not parse network packets or any linear byte buffers. It operates on a structured graph. The vulnerability type and context are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      }
    ]
  },
  "CVE-2022-29379_before_exclude_100:663392f1:vulspec": {
    "timestamp": "2026-01-16T21:26:18.672811",
    "cve_id": "CVE-2022-29379",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "663392f1",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code is a path resolution and file opening function in a C library. The vulnerability type (CWE-125 vs. path traversal/validation), domain (regex parsing vs. filesystem), and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in a VNC file transfer. The target code performs path concatenation with length checks and uses `realpath`. While both involve input validation, the core vulnerability (CWE-787 vs. potential path traversal or symlink issues), context (network protocol vs. local filesystem), and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's service list management. The target code has no dynamic memory allocation or pointer management that could lead to a use-after-free. The functional domains and error handling patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a kernel filesystem's node ID management. The target code is a user-space function with no apparent concurrency or shared state management. The vulnerability class (CWE-362) and system context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read in an image file parser due to improper string termination validation. The target code deals with filesystem paths, not parsing file contents. While both involve processing external input, the data structures, parsing logic, and vulnerability triggers are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double free in an antivirus VBA extractor during error handling. The target code does not show complex memory ownership or cleanup patterns that could lead to a double free. The domains (document parsing vs. path resolution) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to insufficient bounds checking on end tags. The target code performs bounds checking (`length > NJS_MAX_PATH`) but for a different purpose (path length). The parsing logic and data structures are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double free in a VM inspection library during file reading error handling. The target code uses `open()` and returns error codes but does not exhibit the complex memory ownership or cleanup patterns that could cause a double free. The system contexts are different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20760 is an out-of-bounds write due to missing validation of error return codes during text encoding conversion. The target code also performs input validation (path length check) and uses function return codes (`realpath` returns NULL). There is a superficial similarity in validating external input and handling function errors, but the core vulnerability (CWE-787 vs. potential path traversal), data processing (text encoding vs. path strings), and attack surfaces are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13001 is an out-of-bounds read in a network packet decoder due to improper bounds checking when copying file handle data. The target code uses `njs_cpymem` with a calculated length and a static buffer, which involves bounds checking. However, the context (network packet parsing vs. local path resolution), data source, and specific vulnerability pattern are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      }
    ]
  },
  "CVE-2022-1586_after_exclude_100:b5d4a393:vulspec": {
    "timestamp": "2026-01-16T21:26:22.163193",
    "cve_id": "CVE-2022-1586",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b5d4a393",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve regular expression engine vulnerabilities (Perl vs PCRE2). The target code handles character class compilation with Unicode support, which is a complex parsing/compilation task similar to the Perl regex engine. While the specific CWE differs (CWE-125 vs potential logic errors in the target code), the domain (regex compilation), attack surface (malicious pattern input), and functional complexity are highly similar. The target code's extensive character property handling (PT_SCX, PT_BOOL, etc.) presents similar opportunities for state management errors.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a regex compilation function in a library, while CVE-2016-3179 affects a network service daemon (MiniSSDPd) with completely different functionality (SSDP protocol handling, socket communication). The vulnerability type (Use After Free) and attack surfaces (local socket interface) are unrelated to the regex parsing context.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. Both involve regular expression library vulnerabilities (Oniguruma vs PCRE2). The target function `compile_xclass_matchingpath` specifically compiles extended character classes (`[^...]`, `[[:class:]]`), which is exactly the component affected in CVE-2017-9228 (character class parser in Oniguruma). The vulnerability patterns (state transition errors during character class parsing) and attack surfaces (malicious regex patterns with crafted character classes) are nearly identical. Both deal with complex Unicode property handling and bitmask operations.",
        "case_metadata": {
          "cve_id": "CVE-2017-9228"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. While both involve parsing complex data structures (VBA macros vs regex patterns), the domains are different (antivirus file parsing vs regex compilation). The Double Free vulnerability in ClamAV's VBA extractor relates to Office document parsing error paths, which doesn't align with the target code's regex compilation logic. Memory management patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a regex compilation function, while CVE-2019-15166 affects a network protocol parser (tcpdump's LMP decoder). The functionality (packet analysis vs regex compilation), vulnerability context (network packet parsing vs pattern compilation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Some similarity in string/character processing, but different domains (file type detection vs regex compilation). Both involve bounds checking when processing variable-length data (Pascal strings in file utility vs character ranges in regex). However, the target code's complex Unicode property table lookups and state machine compilation differ significantly from simple string length validation.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve decompression/parsing of structured data, but the domains differ (Quantum compression in CAB archives vs regex pattern compilation). The buffer management challenges in decompression algorithms don't directly translate to the target code's character class compilation logic, though both require careful bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve parsing complex structured text (XML vs regex patterns) with character encoding challenges. The out-of-bounds read vulnerability in libxml2's UTF-8 processing shares similarities with potential bounds checking issues in the target code's Unicode character property lookups. Both handle multi-byte characters and maintain parser state, though the specific implementations differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Similar to case 8, both involve structured text parsing (XML tags vs regex character classes) with potential bounds checking issues. The target code's state machine for processing XCL_SINGLE, XCL_RANGE, and XCL_PROP elements parallels XML tag parsing state management. However, the specific vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve memory allocation for encoding/compression tasks, but the domains differ significantly (JPEG 2000 image encoding vs regex pattern compilation). The buffer overflow vulnerability in OpenJPEG's code block allocation doesn't directly relate to the target code's character class bitmask operations and Unicode property table lookups.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-29379_after_exclude_100:a40cbb37:vulspec": {
    "timestamp": "2026-01-16T21:26:22.427598",
    "cve_id": "CVE-2022-29379",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a40cbb37",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a path resolution and file opening function with no regex parsing, character class processing, or similar logic. The vulnerability type and attack surface are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs path concatenation with a length check against NJS_MAX_PATH and uses realpath() and open(). There is no arithmetic on user-controlled integers for memory allocation, which is the core of this vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free caused by uninitialized pointers and inconsistent state management in a network daemon. The target code has straightforward error handling (returns NJS_DECLINED/NJS_ERROR) and manages no dynamic memory or complex state that could lead to a use-after-free in a similar pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a kernel filesystem's node ID management. The target code is a user-space function for resolving a single module path. It contains no concurrent data structures, lock-free operations, or check-then-use patterns that could introduce a race condition.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read in an image file parser due to improper validation of external string data. The target code reads a filesystem path, not file contents. While both process external input, the target code's operations (string copy, realpath, open) are fundamentally different from parsing complex binary file formats with embedded strings.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double free in an antivirus file parser during error handling. The target code has simple, linear error paths that free no resources (it returns error codes). There is no dynamic memory allocation or free() logic present that could lead to a double free.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to insufficient bounds checking during end tag processing. The target code performs bounds-checked string copying into a fixed-size stack buffer. The vulnerability patterns are different: one is a complex stateful parser bug, the other is a straightforward buffer copy with a size guard.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double free in a disk inspection library related to memory ownership confusion. The target code allocates no heap memory and has no memory ownership transfers. Its error handling is simple and does not involve the cleanup of complex, partially allocated structures.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20760 is an out-of-bounds write due to missing validation of error return codes during text encoding conversion. The target code also performs string manipulation and calls library functions (realpath, open) that can fail. The weak similarity is in the pattern of trusting external input (path components) and library return values without exhaustive validation. However, the vulnerability type (OOB write vs. potential path traversal or buffer overflow) and code patterns are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      }
    ]
  },
  "CVE-2019-19069_after_exclude_100:221b5ea5:vulspec": {
    "timestamp": "2026-01-16T21:26:24.941709",
    "cve_id": "CVE-2019-19069",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "221b5ea5",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a FUSE-specific buffer overflow in iovec handling. The target code is a DMA buffer attachment function in a different subsystem (likely a remote procedure call driver). The vulnerability type (CWE-119), trigger conditions (malicious userspace server), and code patterns (FUSE protocol handling) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition (CWE-362) in F2FS node ID management. The target code performs DMA buffer attachment with mutex protection. While both involve kernel resource management, the vulnerability type (race vs. potential memory/validation issues), subsystem (filesystem vs. DMA/RPC), and attack surfaces (concurrent FS ops vs. device attachment) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-16914 is a NULL pointer dereference (CWE-476) in USB/IP due to insufficient validation of URB fields. The target code also performs operations on kernel objects (buffer, attachment) but shows proper allocation checks (kzalloc with NULL check). Some similarity in validating/accessing kernel structures, but different subsystems and vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3137 is a NULL pointer dereference in USB serial driver due to missing endpoint validation. The target code shows better validation patterns (checking kzalloc result). Both involve device driver initialization/attachment paths, but the vulnerability mechanism (missing descriptor checks vs. potential DMA issues) and subsystems differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-10154 involves improper memory buffer handling (CWE-119) with scatterlist operations in CIFS crypto. The target code also uses scatterlist (a->sgt) via dma_get_sgtable(). Some similarity in DMA/scatterlist operations, but different contexts (crypto vs. DMA buffer attachment) and vulnerability patterns (stack memory vs. potential DMA validation).",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to heap corruption in a userspace VNC library. The target code is kernel-space DMA buffer management. Different environments (userspace vs kernel), vulnerability types (integer overflow vs. potential DMA issues), and code patterns make this largely irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3136 is another USB serial driver NULL pointer dereference similar to case 4. The target code shows proper error handling with kfree on failure. Some similarity in driver resource initialization patterns, but different subsystems and specific vulnerability mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-16913 involves improper input validation (CWE-119) in USB/IP leading to unbounded memory allocation. The target code performs memory allocation (kzalloc) and DMA operations with potential validation concerns. Some similarity in checking externally-influenced parameters, but different subsystems (USB/IP vs. DMA/RPC) and vulnerability specifics.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-15126 is a use-after-free (CWE-416) in userfaultfd due to race conditions. The target code uses mutex protection and doesn't show obvious lifetime management issues. Different vulnerability types (UAF vs. potential DMA validation), subsystems (memory management vs. DMA), and code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15126"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2014-0131 is a use-after-free in network skbuff handling during segmentation. The target code manages DMA buffers with reference counting via attachments list. Some conceptual similarity in resource management, but different vulnerability types (UAF vs. other issues), subsystems (networking vs. DMA/RPC), and code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      }
    ]
  },
  "CVE-2019-19069_before_exclude_100:37675091:vulspec": {
    "timestamp": "2026-01-16T21:26:35.656120",
    "cve_id": "CVE-2019-19069",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "37675091",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2010-4650 is a buffer overflow in the FUSE subsystem due to improper iovec validation. The target code is a DMA buffer attachment function in a different subsystem (likely a fastrpc driver). Both involve kernel memory operations, but the vulnerability type (CWE-119 vs. potential memory management errors), attack surface (malicious userspace server vs. DMA buffer operations), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition (CWE-362) in F2FS nid management. The target code uses a mutex (`buffer->lock`) to protect list operations (`list_add`), showing awareness of concurrency. The relevance is limited to the shared concept of protecting shared data structures in a kernel driver, but the vulnerability type, subsystem, and trigger conditions (filesystem metadata race vs. DMA attachment) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-16914 is a NULL pointer dereference (CWE-476) in USB/IP due to insufficient validation of URB fields. The target code performs a `kzalloc` which could return NULL, but it is checked. The `buffer->dev` or `buffer->virt` could potentially be NULL if the `dmabuf->priv` is malformed, leading to a similar dereference in `dma_get_sgtable`. Both are kernel drivers where missing validation of internal or external inputs could cause crashes. However, the subsystems and specific patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-3137 is a NULL pointer dereference (CWE-476) in a USB serial driver due to missing validation of USB endpoint descriptors. The target code also operates on a kernel driver structure (`buffer`). If `buffer`, `buffer->dev`, or `buffer->virt` is invalid/NULL (due to a bug elsewhere), a similar dereference could occur. The shared theme is a kernel driver failing to fully validate its internal state before use. However, the attack surface (physical USB device vs. DMA buffer attachment) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-10154 involves improper scatterlist handling (CWE-119) leading to issues with non-contiguous memory (VMAP_STACK). The target code creates a scatterlist via `dma_get_sgtable` using a buffer's virtual address. If the `buffer->virt` points to a problematic memory region (e.g., stack, non-DMA memory), similar memory corruption or instability could occur. Both involve the correct setup of DMA/scatterlist structures. The vulnerability class and the potential for misuse of the DMA API provide some reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a userspace VNC library. The target code is a kernel function with simple, bounded allocations and no complex integer arithmetic. The environments (userspace library vs. kernel driver), vulnerability patterns, and code operations are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Similar to case 4 (CVE-2016-3136), this is a NULL pointer dereference in a USB serial driver probe due to missing endpoint checks. The relevance to the target code is analogous: both are driver initialization/attachment paths that rely on the correctness of internal/associated data structures. A missing or corrupted `buffer` field could lead to a crash. The core issue of insufficient validation in a driver callback function is shared, but the specific contexts differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-16913 is an unbounded memory allocation issue (CWE-119/770) in the USB/IP network protocol handler. The target code has a fixed-size allocation (`kzalloc(sizeof(*a))`) and does not process network data. The only vague similarity is that both are in kernel driver subsystems, but the vulnerability mechanism and code patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-15126 is a use-after-free (CWE-416) in the userfaultfd subsystem related to improper lifetime management of event objects. The target code adds an attachment object (`a`) to a list (`buffer->attachments`). If `buffer` is freed while `a` is still on the list, or if `a` is used after being freed, a similar lifetime issue could arise. The pattern of adding a privately allocated structure to a parent object's list is similar, but the specific vulnerability type and the complex race/event-driven nature of userfaultfd are not present here.",
        "case_metadata": {
          "cve_id": "CVE-2017-15126"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2014-0131 is a use-after-free (CWE-416) in skbuff fragment handling during segmentation. The target code manages a list of attachments (`buffer->attachments`). If the `buffer` is freed while the list is still being traversed elsewhere, a use-after-free on the `a` object could occur, though the mutex offers some protection. The shared concept is managing linked lists of kernel objects where improper lifetime coordination can lead to UAF. However, the subsystems (networking vs. DMA) and the specific triggers are very different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      }
    ]
  },
  "CVE-2016-6207_before_exclude_100:3557e3bf:vulspec": {
    "timestamp": "2026-01-16T21:26:38.968961",
    "cve_id": "CVE-2016-6207",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3557e3bf",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3179 is a Use After Free vulnerability in a network daemon's error handling. The target code also has error handling and cleanup, but the core issue (uninitialized pointers leading to UAF) and context (network service vs. memory allocation utility) are very different. The pattern of cleaning up partially allocated resources is similar, but the vulnerability mechanism is not.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an Out-of-bounds Read in a regex parser due to improper NUL byte handling. The target code performs memory allocation with overflow checks but does not involve string parsing, buffer reads, or NUL byte issues. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2018-20750 involves an Integer Overflow (CWE-190) leading to an Out-of-bounds Write during memory allocation, similar to the target code's use of `overflow2()` checks. Both functions perform multi-step allocations with size calculations that could overflow. The target code proactively checks for overflow2 on `line_length * sizeof(ContributionType)` and `windows_size * sizeof(double)`, which is the exact defensive pattern needed to prevent vulnerabilities like this one. The code patterns (safe allocation wrappers) and core vulnerability type (integer overflow in allocation size) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2017-14151 is a buffer overflow due to insufficient padding allocation in an image codec. The target code is also a memory allocation function for a graphics library (likely GD), performing careful size calculations and cleanup. While the specific flaw (padding miscalculation) is not present, the context (image processing library), the focus on safe allocation sizes, and the pattern of multi-level allocation with cleanup on failure are similar and provide good reference value for secure coding in this domain.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2016-8670 is a buffer overflow in PHP's GD library integration. The target code is explicitly a function from a graphics library (GD, as indicated by `gdMalloc`, `gdFree`) performing memory allocation for image operations. Both involve the GD library and the critical task of bounds checking during memory operations. The target code's use of `overflow2()` is a direct mitigation for the integer overflows that could lead to the types of vulnerabilities described in this case. The domain and security concerns are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a Race Condition in a filesystem's node management. The target code is a simple, synchronous memory allocation function with no concurrency, threading, or shared state management. The vulnerability patterns (non-atomic operations, state transitions) have no parallel in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20760 is an Out-of-bounds Write due to improper error handling in a text conversion function. The only similarity is that both functions include error handling and cleanup paths. However, the target code's error handling is robust (cleaning up partially allocated resources), while the vulnerability case's handling is flawed. The domains (text encoding vs. graphics memory allocation) and specific flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-13219 is an Integer Overflow in an audio decoder's mathematical computations. The target code also deals with integer overflows but in the specific context of memory allocation size calculations (`overflow2` checks). The core CWE-190 is the same, and the defensive pattern in the target code is a direct response to such threats. The application domains differ, but the underlying integer safety principle is highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1003 is a Double Free in an antivirus file parser. The target code carefully frees resources (`gdFree`) during error cleanup to avoid double-free or leak scenarios. It demonstrates the correct pattern to prevent such issues. There is a conceptual link in proper resource management during failure, but the specific vulnerability (double-free state inconsistency) is not mirrored in the target code's structure, which appears safe.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1834 is a heap buffer overflow in an XML string library due to negative length values. The target code performs arithmetic overflow checks for allocation but does not handle strings, negative values, or have the same attack surface (parsing malicious documents). The only tangential similarity is the use of size calculations before memory operations.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2016-6207_after_exclude_100:4502dad1:vulspec": {
    "timestamp": "2026-01-16T21:26:39.169229",
    "cve_id": "CVE-2016-6207",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4502dad1",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3179 is a Use After Free vulnerability in a network daemon's error handling. The target code also has error handling and frees memory, but its pattern is a clean rollback of partially allocated structures on failure, which is the correct pattern to *avoid* use-after-free. The vulnerability types and contexts are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an Out-of-bounds Read in a regex parser due to improper NUL byte handling. The target code performs memory allocation with size calculations but includes overflow checks (`overflow2`) and does not involve string parsing or buffer reads that could be influenced by embedded NULs.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2018-20750 involves an Integer Overflow (CWE-190) leading to an Out-of-bounds Write. The target code's core logic is centered on preventing integer overflows during memory allocation size calculations using the `overflow2` function. The pattern of checking `overflow2(line_length, sizeof(ContributionType))` and `overflow2(windows_size, sizeof(double))` is a direct mitigation for the exact vulnerability chain (CWE-190 -> CWE-787) present in this case. The functional context (memory allocation for a data structure) is also similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2017-14151 is a buffer overflow due to insufficient allocation size (padding). The target code is also a memory allocator for a processing structure and is meticulous about size calculations and overflow checks. While the specific cause (padding) differs, the core theme of ensuring correct allocation size to prevent buffer overflows is strongly shared. The target code's use of `overflow2` checks makes it more robust than the vulnerable pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2016-8670 is a buffer handling issue in PHP's GD library integration. The target code is *from* the GD library (`gdMalloc`, `gdFree`) and performs memory allocation for image processing (likely scaling/resampling). It directly addresses the CWE-119 (Buffer Overflow) concern through integer overflow checks. The domain (GD library) and the vulnerability mitigation pattern are highly aligned.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a Race Condition in a filesystem's resource management. The target code is a simple, synchronous allocation function with no concurrency, shared state, or check-then-use patterns. The vulnerability classes (CWE-362 vs. CWE-190/787) and contexts are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20760 is an Out-of-bounds Write due to improper error handling in a text converter. The target code has extensive error handling and cleanup, which is the correct pattern to avoid such issues. Both involve multi-step allocation, but the trigger (encoding errors vs. integer overflow) and the specific flaw are different. The relevance is in the defensive cleanup pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2019-13219 is an Integer Overflow (CWE-190) in an audio codec's calculations. The target code's primary security mechanism is preventing integer overflows in size calculations (`overflow2` checks) before allocation. The core vulnerability type is identical, and the code demonstrates the necessary mitigation. The context (media processing library helper function) is also somewhat similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1003 is a Double Free during error handling. The target code carefully avoids double free by setting `overflow_error` and ensuring cleanup only happens on allocated resources (e.g., freeing `res->ContribRow[i].Weights` only for `i<=u`). It shares the theme of complex cleanup in error paths but implements it correctly to prevent the specific vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1834 is a heap buffer overflow in a string library due to negative length values. The target code deals with unsigned lengths and checks for overflow in multiplication, which is a related but distinct arithmetic flaw (wraparound/overflow vs. signedness). The primary similarity is the focus on safe size calculation for memory operations.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2010-0001_before_exclude_100:77239ddb:vulspec": {
    "timestamp": "2026-01-16T21:26:39.726240",
    "cve_id": "CVE-2010-0001",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "77239ddb",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability in a network service daemon (MiniSSDPd). The target code is a decompression function (LZW) from a utility like gzip, with no dynamic memory allocation or pointer management that could lead to use-after-free. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code also parses a compressed data stream and could theoretically read out-of-bounds if input validation fails, but the context (regex vs. decompression), data structures, and specific trigger (NUL bytes) are not similar. Both involve parsing, but the mechanisms are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code parses a compressed data format and performs bounds checks (e.g., `if (code > free_ent)`). The similarity lies in parsing binary formats with length/code fields. However, the target code's primary vulnerability class appears to be logic errors leading to infinite loops or corruption, not a simple bounds over-read from a packet.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in memory allocation. The target code does not perform dynamic memory allocation; it uses fixed-size stack arrays (`inbuf`, `outbuf`). However, it does contain integer operations on bit positions and buffer indices (e.g., `posbits`, shifting), which could theoretically wrap or overflow if inputs are malicious, potentially leading to buffer overflows within the fixed arrays. The connection is conceptual (integer handling risks) but not direct.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper buffer management during multi-byte character processing. The target code processes a byte stream but does not involve complex character encoding. Both are parsers, but the vulnerability root cause (encoding state) and data types are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2010-1311 is an input validation flaw in a decompression module (Quantum in ClamAV) leading to memory corruption. The target code is also a decompression function (LZW in gzip). Both:\n1. Parse a proprietary compression format from untrusted input.\n2. Maintain internal state (dictionary/window, code tables).\n3. Have complex control flow with loops and error conditions.\n4. The primary risk is improper validation of codes/offsets leading to out-of-bounds writes (e.g., `tab_prefixof`/`tab_suffixof` array access) or infinite loops. The vulnerability patterns (CWE-20 leading to CWE-787) are highly relevant for auditing this code.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-14151 is a buffer overflow due to incorrect allocation size calculation in an image encoder. The target code does not perform dynamic allocation based on complex size calculations. It writes to a fixed-size output buffer (`outbuf`) with checks to prevent overflow (`OUTBUFSIZ`). The vulnerability pattern (arithmetic error in size) is not directly mirrored here.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser during end tag processing. The target code reads from a byte buffer (`inbuf`) using a bit-level `input()` function. While both read from input buffers, the target code's bit-by-bit reading with explicit position management (`posbits`) is structurally different from XML tag parsing. The OOB read risk exists but manifests differently.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-15166 is an improper input validation in a network protocol parser leading to potential OOB read. Similar to case 3, the target code also parses a structured binary format (LZW codes) and must validate codes against table bounds (`free_ent`, `maxcode`). The relevance is in the pattern of validating codes/offsets from untrusted input, though the protocols are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-25034 is an integer overflow leading to out-of-bounds write in a DNS parser. As noted in case 4, the target code uses integer arithmetic for bit positions and buffer indices. An integer overflow/wrap in variables like `posbits`, `inbits`, or `outpos` could lead to buffer overflows within the fixed arrays. The connection is conceptual but not a direct match, as the target code's arithmetic is less complex and more localized.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2022-1508_before_exclude_100:d6cd235c:vulspec": {
    "timestamp": "2026-01-16T21:26:48.135903",
    "cve_id": "CVE-2022-1508",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d6cd235c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol handler. The target code is a Linux kernel io_uring read function dealing with iovec iteration and async I/O. The domains (network protocol vs. kernel I/O subsystem), vulnerability patterns (integer overflow vs. potential logic/state errors), and code structures are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2010-4650 involves improper validation of iovec lengths leading to buffer overflow in the Linux kernel FUSE subsystem. The target code also handles iovec structures (via `io_import_iovec`, `iov_iter`) in the kernel I/O path (io_uring). Both involve kernel-level I/O operations with user-provided vectors. However, the specific vulnerability mechanism (FUSE ioctl retry path validation) and the target code's focus on async retry logic differ. The similarity in iovec handling and kernel context provides reference value.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. The target code is a synchronous/asynchronous read handler in the Linux kernel. No overlap in functionality, vulnerability type, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20760 is an out-of-bounds write in a multimedia framework's text encoding conversion utility. The target code is a kernel I/O subsystem function. The domains (userspace text processing vs. kernel I/O), vulnerability root causes (encoding errors), and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2013-2124 is a double-free in a userspace library (libguestfs) during file content processing error paths. The target code has multiple error/cleanup paths (e.g., `kfree(iovec)`, `goto done/out_free`) and manages resource ownership (async_data, iovec). There is a superficial similarity in the need for careful resource cleanup, but the context (kernel vs. userspace, I/O request lifetime vs. file reading) and specific vulnerability mechanism are very different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2011-3603 is a privilege management issue in a network daemon during privilege separation failure. The target code is a kernel function performing I/O with no privilege state transitions. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3601 is a buffer overflow in a network daemon parsing IPv6 RA messages. The target code parses kernel-internal iovec structures, not network packets. The attack surface and data validation concerns are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write due to alignment issues in a WebSocket library. The target code does not perform word-aligned access or network frame decoding. The vulnerability pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition in the Linux kernel F2FS filesystem's node ID management. The target code is also in the Linux kernel and handles asynchronous I/O requests (`force_nonblock`, `async_data`) which can involve concurrency. While the specific vulnerability (race in metadata management) differs, both are kernel code where state management and concurrency are critical. The reference value is limited to general kernel programming caution.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2011-1003 is a double-free in an antivirus engine's document parser. The target code has multiple exit paths and frees the `iovec` pointer conditionally. The general principle of ensuring consistent resource cleanup across all code paths (success, error, retry) is similar, but the execution environment and specific data structures are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2022-1508_after_exclude_100:72d278f2:vulspec": {
    "timestamp": "2026-01-16T21:26:48.866551",
    "cve_id": "CVE-2022-1508",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "72d278f2",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol handler. The target code is a Linux kernel io_uring read function dealing with iovec iteration and async I/O. The domains (userspace library vs. kernel I/O), vulnerability patterns (integer overflow vs. potential logic/state errors), and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2010-4650 involves improper validation of iovec lengths leading to buffer overflow in the Linux kernel FUSE subsystem. The target code also handles iovec structures (via `io_import_iovec`, `iov_iter`) in the kernel (io_uring). Both are in the Linux kernel I/O subsystem and involve validating/managing user-provided iovec data. However, the specific vulnerability pattern (malicious FUSE server response vs. user-controlled read request) and component (FUSE vs. io_uring) differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. The target code is a synchronous/asynchronous read path in the Linux kernel with no regex processing or character encoding issues. No meaningful similarity in vulnerability type, domain, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20760 is an out-of-bounds write in a multimedia framework's text encoding conversion utility. The target code is kernel I/O with no text encoding or UTF conversion logic. The vulnerability patterns (error return code mishandling vs. I/O state management) and domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2013-2124 is a double-free in a userspace library inspecting disk images. The target code has memory cleanup (`kfree(iovec)`) but shows no pattern of double-free or ownership confusion. Both involve file/read operations, but the context (userspace vs. kernel, error handling complexity) and specific vulnerability are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2011-3603 is a privilege management issue in a network daemon during privilege separation failure. The target code is a kernel function with no privilege escalation or daemon initialization logic. No overlap in vulnerability type or domain.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3601 is a buffer overflow in an IPv6 RA daemon parsing network packets. The target code parses iovec for file I/O but includes bounds checking via `io_import_iovec` and `rw_verify_area`. The attack surface (network protocol vs. file I/O) and vulnerability pattern (negative length calculation vs. async I/O state) are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write due to unaligned memory access in a VNC WebSocket library. The target code performs aligned kernel memory operations on iovec and iterators. The domains (userspace networking library vs. kernel I/O) and vulnerability root causes (alignment vs. logic flow) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition in the Linux kernel F2FS filesystem's node ID management. The target code is also in the Linux kernel and involves asynchronous I/O operations (`force_nonblock`, `async_data`) that could have concurrency considerations, but no explicit locking or race patterns are shown. Both are kernel subsystems, but the vulnerability type (race vs. potential logic error) and components (filesystem vs. io_uring) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2011-1003 is a double-free in an antivirus VBA parser. The target code has conditional `kfree(iovec)` calls, but the pattern is simple and linear (no double-free opportunity shown). Both involve parsing/processing input data, but the context (userspace file parsing vs. kernel I/O) and vulnerability specifics are distant.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2022-21734_before_exclude_100:568e5595:vulspec": {
    "timestamp": "2026-01-16T21:26:49.392401",
    "cve_id": "CVE-2022-21734",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "568e5595",
    "scores": [
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is a TensorFlow staging area operation performing data insertion, with no cryptographic operations, side-channel considerations, or mathematical computations on secret data. The vulnerability is specific to elliptic curve cryptography in libgcrypt.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a low-level data structure operation in TensorFlow, not a database query planner. There are no privilege checks, SQL interfaces, or view-based access control mechanisms. The functional domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve memory buffer operations, but the target code uses high-level TensorFlow abstractions (OP_REQUIRES_OK, Tensor objects) with built-in bounds checking, while the OpenJPEG vulnerability is a low-level heap buffer overflow in raw memory allocation for image encoding. The attack surfaces (image processing vs. ML tensor operations) and code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The target code performs tensor operations with potential integer considerations (NumElements), but uses high-level TensorFlow APIs that likely include validation. The libarchive vulnerability involves low-level integer overflow in file position calculations during archive parsing. Some similarity in integer handling concerns, but different abstraction levels and domains.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve writing data, but the target code uses TensorFlow's staging map abstraction while the OpenJPEG vulnerability is a low-level buffer overflow in marker segment writing. The target code shows no evidence of direct buffer manipulation or missing size validation at the same abstraction level.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code performs simple data storage operations with no cryptographic algorithms, DNSSEC validation, or key processing. The vulnerability domains (cryptography vs. tensor data management) and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve processing input data (tensors vs. audio codebooks) with potential integer considerations. However, the target code uses high-level TensorFlow APIs that likely validate tensor dimensions, while the stb_vorbis vulnerability involves low-level integer overflow in mathematical computations. Some conceptual similarity in input validation concerns.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve data buffer management, though at different abstraction levels. The target code's staging map likely implements buffer-like functionality for tensor data. However, the Tor vulnerability is specifically about missing sentinel values and low-level buffer overreads, while the TensorFlow code uses safer abstractions. Similar concerns about data boundary management exist.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code processes structured tensor inputs through validated TensorFlow APIs, while the BlueZ vulnerability is a stack-based buffer overflow in low-level hexadecimal string parsing. Different domains (ML framework vs. Bluetooth configuration) and abstraction levels.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code processes tensor data with no regular expression compilation, pattern parsing, or Unicode sequence handling. The Perl vulnerability involves specific regex engine behavior with NUL bytes, which has no counterpart in the TensorFlow staging operation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      }
    ]
  },
  "CVE-2010-0001_after_exclude_100:c2c5ca16:vulspec": {
    "timestamp": "2026-01-16T21:26:52.227855",
    "cve_id": "CVE-2010-0001",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c2c5ca16",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability in a network service daemon (MiniSSDPd). The target code is a decompression function (LZW) from what appears to be gzip, with no dynamic memory allocation, pointer management, or network service logic. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to improper NUL byte handling. The target code is a binary data decompression algorithm. While both involve parsing input, the domain (textual regex vs. binary compression), vulnerability root cause (string termination vs. logic/bounds errors in a state machine), and code structure are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser (tcpdump's LDP) due to insufficient validation of a length field. The target code also parses a stream (compressed data) and uses length/code fields. There is a conceptual similarity in parsing untrusted binary data, but the specific vulnerability pattern (missing bounds check on a TLV length) is not directly mirrored in the LZW code, which has its own bounds checking logic (e.g., `if (code > free_ent)`).",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a VNC file transfer component. The target code performs arithmetic on `code`, `free_ent`, and `maxcode`, and uses `memcpy`. There is a potential, though not obvious, risk of integer issues in calculations like `MAXCODE(n_bits)-1` or `1<<n_bits`. The relevance is weak because the target code's primary logic is a well-bounded decompression loop, and no clear integer overflow leading to a corrupt write is evident. The attack surface (file format vs. network protocol) is also different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2's character encoding processing. The target code reads bits from an input buffer (`input(inbuf,posbits,code,n_bits,bitmask)`). Both involve reading from an input buffer, but the vulnerability mechanism is different: libxml2's is related to multi-byte character buffer management, while the LZW code's primary risk would be more about reading past the buffer if `input()` or the bit-position arithmetic is flawed. The code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2010-1311 is an input validation flaw (CWE-20) in a decompression module (Quantum in ClamAV) leading to memory corruption. The target code is another decompression algorithm (LZW in gzip). Both are file format parsers/decompressors, a high-risk domain for vulnerabilities. Both must manage a dictionary/window (`tab_prefix`, `tab_suffix`) and validate codes/offsets against bounds (e.g., `if (code > free_ent)`). The specific bug pattern (failing to validate a match against window boundaries) is analogous to the LZW code's need to validate `code` against `free_ent` and `maxmaxcode`. This provides valuable reference for auditing decompression logic.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to insufficient padding allocation in an image encoder. The target code writes to an output buffer (`outbuf`) with bounds checking (`if (outpos+i >= OUTBUFSIZ)`). The relevance is in the theme of buffer management during compression/decompression. However, the specific flaw (miscalculation of needed space vs. allocated space) is not directly present in the shown code, which uses fixed-size buffers and manages writes carefully.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser during end tag processing. The target code is not a text markup parser and does not process hierarchical structures like XML tags. The vulnerability pattern (insufficient bounds checking during a specific parsing state) is generic, but the code domains and data structures are too different to be highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-15166 is an improper input validation (CWE-20) in a network protocol parser (tcpdump's LMP). Similar to case 3, the relevance lies in the pattern of parsing untrusted binary data with length fields. The target LZW code also parses a stream with variable-width codes. However, the LZW code's validation is more integrated into its core state machine (checking `code`, `free_ent`, `maxcode`), whereas the tcpdump bug is a missing pre-validation check. The similarity is thematic rather than specific.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-25034 is an integer overflow in DNS domain name parsing leading to an out-of-bounds write. The target code uses integer arithmetic for bit positions (`posbits`), buffer sizes (`insize`, `rsize`), and code values. There is a potential for integer overflows/wraparound in calculations like `posbits = ((posbits-1) + ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)))` or `inbits = ... <<3`. If `posbits` or `inbits` become negative or very large due to corrupt input, they could lead to out-of-bounds buffer access in the `input()` or `memcpy` functions. This provides a reference point for auditing integer handling in the bit manipulation logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2022-1276_before_exclude_100:83cb6276:vulspec": {
    "timestamp": "2026-01-16T21:26:52.685891",
    "cve_id": "CVE-2022-1276",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "83cb6276",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 involves Use After Free in a network daemon (MiniSSDPd) handling SSDP protocol. The target code is a compiler code generation function for assignment operations in what appears to be a Ruby-like language implementation. Different domains (network service vs. language compiler), different vulnerability types (memory management vs. potential logic/validation issues), and completely different code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves out-of-bounds read in Perl's regex engine due to NUL byte handling. While both involve parsing/compilation (regex vs. AST code generation), the vulnerability type (buffer over-read vs. potential logic errors), attack surfaces (regex patterns vs. AST nodes), and code patterns are fundamentally different. The target code handles AST node types, not byte-level pattern parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-9228"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      }
    ]
  },
  "CVE-2022-21734_after_exclude_100:9ef5feba:vulspec": {
    "timestamp": "2026-01-16T21:26:55.655892",
    "cve_id": "CVE-2022-21734",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9ef5feba",
    "scores": [
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a TensorFlow staging map operation performing data insertion. VulSpec describes a cryptographic side-channel vulnerability in libgcrypt. Different domains (ML framework vs crypto library), vulnerability types (no side channels here), and attack surfaces.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code performs a data storage operation with input validation. VulSpec describes a PostgreSQL privilege escalation via inconsistent access checks in query planning. Different systems, domains (database vs ML), and vulnerability types (no access control logic in target code).",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve memory operations, but target code uses high-level Tensor objects with bounds checking (OP_REQUIRES). VulSpec describes a low-level heap buffer overflow in an image codec due to insufficient padding. Similar CWE-119 potential, but implementation patterns and trigger conditions differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Target code performs input validation on tensor dimensions (NumElements checks). VulSpec describes an integer overflow in archive parsing. Both involve input validation, but the vulnerability type (CWE-190) and trigger conditions (large integer calculations vs tensor shape checks) are different. The pattern of checking inputs before use is a common defensive practice.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Target code validates inputs before map insertion. VulSpec describes an out-of-bounds write in an image codec due to missing buffer size validation. Both involve writing data, but target code uses abstracted containers (StagingMap) while VulSpec deals with raw buffer writes. Similar CWE-787 concern but different abstraction levels.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a data storage operation with no cryptographic operations. VulSpec describes a cryptographic algorithm handling flaw leading to NULL pointer dereference in BIND9. Different domains, vulnerability types, and code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Target code validates tensor element counts and shape. VulSpec describes integer overflow in audio codec calculations. Both involve input validation to prevent erroneous states, but the vulnerability mechanism (integer wraparound vs shape validation) and domains differ. The defensive validation pattern is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Target code uses Tensor objects which manage their own bounds. VulSpec describes buffer management issues in Tor's network stack leading to overreads. Both involve data handling, but abstraction levels differ (high-level Tensor vs low-level buffer chunks). Similar CWE-119 concern but different manifestations.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Target code processes tensor inputs with validation. VulSpec describes a stack buffer overflow in Bluetooth configuration parsing. Both process external inputs, but target code uses safe Tensor APIs while VulSpec uses unsafe string parsing. Similar input processing context but different vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code validates tensor inputs and calls map->put(). VulSpec describes an out-of-bounds read in Perl's regex engine due to NUL byte handling. Different domains, data types (binary tensors vs string patterns), and vulnerability mechanisms. Both process input, but patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      }
    ]
  },
  "CVE-2021-41203_before_exclude_100:5e0e47fd:vulspec": {
    "timestamp": "2026-01-16T21:27:01.953089",
    "cve_id": "CVE-2021-41203",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5e0e47fd",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code is a TensorFlow checkpoint reader performing file I/O, parsing protobufs, and copying tensor data. The domains (regex parsing vs. tensor serialization), vulnerability types (CWE-125 vs. potential input validation/parsing issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser (hex string to binary). The target code reads from a key-value store and parses protocol buffers. While both involve parsing external data, the vulnerability mechanism (stack overflow from hex conversion), data format, and memory operations are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1541"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error (inconsistent memory tracking) in a subtitle renderer. The target code manages memory for tensor data but shows no evidence of similar inconsistent tracking between allocation and usage. The core flaw and domain are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow in ISO9660 parsing leading to incorrect position calculation. The target code reads data slices and could potentially be vulnerable to integer issues in size calculations (e.g., in `CopyDataFromTensorSliceToTensorSlice`), but the provided code snippet does not show such arithmetic. The connection is speculative and based on a common risk category in parsers.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1835 is a use-after-free in libxml2's attribute processing. The target code uses RAII-style management (mutex_lock) and reads into local/parameter variables. There is no dynamic memory management of parsed objects that could lead to a use-after-free in the shown code path.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-1000381 is an out-of-bounds read in DNS NAPTR record parsing due to insufficient length validation. The target code reads a serialized protobuf (`ParseProtoUnlimited`) which could also be vulnerable to OOB reads if the `value` buffer is malformed. The similarity is in parsing untrusted binary formats without explicit length checks on the data being parsed, though the protocols and code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-1000381"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow in JPEG2000 encoding due to incorrect padding calculation. The target code copies data between tensor slices but does not perform complex buffer size calculations or padding. The memory safety concern is more indirect.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14164 is an out-of-bounds write due to missing buffer size validation when writing JPEG2000 markers. The target code writes to a user-provided `data` pointer but does not show explicit bounds checking on the destination buffer. This is a generic risk, but the code pattern (writing serialized data vs. image markers) and vulnerability specifics are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1833 is an out-of-bounds read in libxml2 due to improper buffer management during multi-byte character processing. The target code reads a string (`value`) and parses it as a protobuf. If `value` contains malformed binary data, the protobuf parser could perform an OOB read. The connection is thematic (parsing untrusted data) but not specific to the code patterns shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2022-1276_after_exclude_100:2d35ef58:vulspec": {
    "timestamp": "2026-01-16T21:27:03.028841",
    "cve_id": "CVE-2022-1276",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2d35ef58",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a code generation function for a compiler/interpreter (likely mruby), handling assignment operations. CVE-2016-3179 is a Use-After-Free in a network daemon (MiniSSDPd) related to socket message handling and resource cleanup. The domain (compiler backend vs. network service), vulnerability type (logic/state management vs. memory corruption), and code patterns are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-18313 is an Out-of-bounds Read in Perl's regex compiler due to improper NUL byte handling. The target code is also part of a language implementation (code generator), but its function is fundamentally different: it processes an abstract syntax tree to generate instructions, not parsing raw pattern strings. While both involve language internals, the vulnerability mechanism (input validation of raw bytes leading to buffer over-read) is not present in the logic-heavy, tree-walking target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2019-15166 is an Improper Input Validation leading to potential memory corruption in tcpdump's network protocol parser. The target code is a compiler backend function with no network input parsing, no direct buffer manipulation, and operates on validated internal data structures (AST nodes). The attack surfaces and code patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2017-9226 is an Out-of-bounds Write in the Oniguruma regex library due to invalid octal escape sequences in character classes. There is weak relevance: both the target code and Oniguruma are core components of language/runtime systems (Ruby/mruby and Oniguruma used by Ruby). Both process structured input (AST nodes vs. regex patterns) and generate output (bytecode vs. compiled regex). However, the specific vulnerability pattern (integer overflow/truncation in escape sequence processing leading to OOB write) is not visible in the target code's switch-based dispatch and stack manipulation.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2017-9228 is another OOB Write in Oniguruma, this time due to an uninitialized state variable during character class parsing. Relevance is similar to Case 4. The target code also manages state (stack pointer `sp`, scope `s`) but does so via explicit assignments and function calls. The risk of an uninitialized variable causing an OOB write is lower in this code due to its structured control flow, but the general theme of managing complex state during a compilation/translation phase is shared at a high level.",
        "case_metadata": {
          "cve_id": "CVE-2017-9228"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1838 is an Out-of-bounds Read in libxml2's end tag parser. The target code does not parse a serialized format (XML) with explicit length fields or buffers. It operates on in-memory tree structures where bounds are managed by the tree abstraction. No relevance in vulnerability mechanism or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-14461 is an Out-of-bounds Read in tcpdump's LDP protocol parser due to insufficient TLV length validation. Similar reasoning to Case 3 and 6. The target code is not a packet parser and does not process untrusted length fields from a byte stream.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2009-5155 is a Data Processing Error (state handling bug) in glibc's regex compiler (`regcomp.c`). This has moderate relevance. Both the target code (`gen_assignment`) and `regcomp.c` are compilers/translators (from AST to bytecode, from regex pattern to internal representation). Both must track complex internal state (stack index, variable indices, backreferences, grouping state) across the processing of a structured input. The vulnerability root causeimproper state handling and validation during the compilation of alternative branches (`|`)is conceptually similar to the need for correct state management (e.g., stack pointer `sp`, value flag `val`) across different assignment types in the target code. The target code's extensive switch statements and state updates are analogous to the state machine in a regex compiler.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7972 is a Resource Management Error in libass's text shaper due to inconsistent memory tracking. The target code also manages resources (stack slots) and tracks state (via `s->sp`). However, the vulnerability manifests at a different level: libass's bug is in the bookkeeping of allocated heap memory sizes, while the target code's management is more straightforward arithmetic on stack indices. The reference value is low.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1835 is a Use-After-Free in libxml2's SAX2 attribute parser during namespace processing. The target code does not involve SAX-style parsing, dynamic memory allocation/deallocation of parsed data, or complex entity/namespace state that can lead to dangling pointers. Its operations are contained within a single function call frame working on pre-allocated structures. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      }
    ]
  },
  "CVE-2021-41203_after_exclude_100:cce674a4:vulspec": {
    "timestamp": "2026-01-16T21:27:06.779834",
    "cve_id": "CVE-2021-41203",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cce674a4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in a Perl regex engine due to NUL byte handling. The target code is a TensorFlow slice reader performing data copying and validation. Different domain (ML vs. text processing), different vulnerability pattern (buffer over-read vs. data validation/copying).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow in BlueZ configuration parsing. Target code reads tensor slices from storage with bounds checking (CHECK_GE, validation of tensor sizes). Different context and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1541 is a heap buffer overflow in libarchive ZIP parsing due to size field validation issues. Target code has some similarity in parsing serialized data (ParseProtoUnlimited) and validating sizes (TensorProtoDataSize vs. num_elements), but the domain (archive vs. tensor storage) and specific vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1541"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-7972 involves resource management errors in libass subtitle rendering. Target code manages tensor data slices but shows careful resource handling with validation. Different vulnerability class (memory tracking inconsistency vs. data validation).",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 involves integer overflow in libarchive ISO parsing. Target code performs size calculations (shp_s.num_elements()) that could theoretically overflow, but includes validation comparing expected vs. actual data size. Some conceptual similarity in size validation, but different contexts and specific overflow patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1835 is a use-after-free in libxml2 attribute processing. Target code uses RAII-style mutex locking and doesn't show manual memory management patterns that could lead to use-after-free. Different vulnerability class entirely.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-1000381 involves out-of-bounds read in DNS NAPTR record parsing. Target code reads from key-value stores (sss_[idx]->Get) but includes validation checks. Different protocol parsing context and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2017-1000381"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow in OpenJPEG due to insufficient padding allocation. Target code copies tensor data between slices with validation, but doesn't show similar padding calculation issues. Different allocation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14164 is an out-of-bounds write in JPEG 2000 marker writing. Target code writes to user-provided data buffer but includes size validation. Different domain and specific write patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1833 involves out-of-bounds read in libxml2 character encoding handling. Target code processes serialized protobuf data but uses ParseProtoUnlimited with validation. Different parsing context and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2020-11038_after_exclude_100:62af2485:vulspec": {
    "timestamp": "2026-01-16T21:27:16.490283",
    "cve_id": "CVE-2020-11038",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "62af2485",
    "scores": [
      {
        "score": 4,
        "reasoning": "The target code involves careful error handling with goto chains to free resources, which is the opposite pattern of CVE-2016-3179's Use After Free caused by inconsistent state management. Both deal with resource allocation and cleanup, but the vulnerability mechanism (uninitialized pointers, double free) is not present in the target code, which appears to defensively clean up on failure.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The target code performs a size calculation `s = width * height * 4ULL` and checks for overflow against INT32_MAX. This is a defensive integer overflow check similar to the root cause (CWE-190) in CVE-2018-20750. However, the target's check prevents the vulnerability, whereas the CVE occurred due to a missing check. The domain (video decoding vs. VNC file transfer) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The core similarity is the integer overflow check (`s > INT32_MAX`) which relates to CWE-190, the primary CWE of CVE-2019-13219. The trigger condition (multiplication of user/input-controlled dimensions) is analogous. The domains differ (video context creation vs. audio codebook calculation), but the defensive coding pattern against overflow is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to character encoding issues. The target code performs memory allocation and initialization for a presentation context, with no string parsing, buffer reads, or character encoding logic. The vulnerability types and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve allocating buffers for media processing (video surfaces vs. JPEG 2000 code blocks). However, CVE-2017-14151 is a buffer overflow due to insufficient padding calculation. The target code's allocation size is a straightforward pixel count calculation with an overflow check, and there's no evidence of similar complex padding logic that could be miscalculated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The connection is in the domain of media processing and the pattern of allocating memory based on input parameters (width/height). CVE-2017-12982 involves a memory allocation failure due to unchecked header values. The target code does check for integer overflow and allocation failures, making it more robust. The specific attack vector (malicious file header) is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write due to alignment issues in WebSocket frame decoding. The target code is initializing a context structure, allocating buffers, and creating decoder objects. It involves no network data parsing, bit-level manipulation, or assumptions about memory alignment. The vulnerability types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser during end tag processing. The target code has no parsing logic for structured markup languages. It deals with resource allocation and initialization for video decoding. The code patterns and potential attack surfaces are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code performs no string parsing or regular expression compilation. Its functionality is resource management for a video subsystem. There is no meaningful overlap in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse any network protocols or TLVs. It allocates resources based on given dimensions. The domain (network packet analysis vs. video context setup) and vulnerability mechanism are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2020-11038_before_exclude_100:fb77763e:vulspec": {
    "timestamp": "2026-01-16T21:27:17.997582",
    "cve_id": "CVE-2020-11038",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "fb77763e",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. The target code features complex error handling with multiple resource allocations (calloc, h264_context_new, Stream_New, BufferPool_Take, createSurface, yuv_context_new). Similar to CVE-2016-3179's CWE-416 (Use After Free) enabled by inconsistent state management (CWE-703) and improper cleanup (CWE-404), the target's goto-based cleanup could leave dangling pointers or inconsistent state if any function (e.g., deleteSurface) fails or is called incorrectly. However, the specific context (video presentation vs. SSDP) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 involves an integer overflow (CWE-190) leading to an out-of-bounds write (CWE-787) in a file transfer protocol. The target code performs arithmetic (width * height * 4) but this is a simple multiplication for a buffer size, with no apparent integer overflow checks. However, the primary vulnerability pattern (malformed request triggering heap corruption) and the system domain (remote desktop/streaming vs. VNC) are somewhat related, but the code patterns and trigger conditions are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-13219 is an integer overflow (CWE-190) in audio codebook calculations. The target code has no complex integer computations or parsing of untrusted file data. The only arithmetic is a straightforward buffer size calculation. The domains (video decoding vs. audio decoding) are related multimedia processing, but the vulnerability mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1833 is an out-of-bounds read (CWE-125) in an XML parser due to improper buffer management during character encoding. The target code does not parse complex, untrusted data streams. It allocates buffers based on input parameters (width, height). The relevance is limited to the general concept of allocating buffers based on external inputs, but the code pattern and attack surface are very different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-14151 is a buffer overflow (CWE-119) due to insufficient padding allocation in an image codec. The target code allocates a surface buffer (width * height * 4) for video data. While both involve image/video buffer allocation, the target's calculation is simple and the overflow risk depends on the integer multiplication not wrapping. The code does not show the specific padding/alignment issue of the OpenJPEG case.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-12982 involves a memory allocation failure due to unchecked header values in an image converter. The target code allocates memory based on width and height parameters passed to PresentationContext_new. If these parameters come from an untrusted source (e.g., a network packet), they could cause excessive memory allocation or integer wrap in `width * height * 4`. This mirrors the unchecked input issue, though the target uses calloc/BufferPool_Take which may handle failure differently.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write due to alignment issues in WebSocket frame decoding. The target code does not process network frames directly, does not perform bitwise masking operations on unaligned data, and does not show similar low-level memory access patterns. The domains are both related to remote display protocols, but the vulnerability mechanism is absent.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser during end tag processing. The target code is not a parser and does not process structured text data. No relevance in code pattern or vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code does not compile patterns or parse strings in a way that would embed NUL bytes. No similarity in functionality or vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse TLVs or network packets. While the target may receive width/height from a network stream, the code itself does not contain the parsing and length validation logic that is the core of this vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-2845_before_exclude_100:74f179c6:vulspec": {
    "timestamp": "2026-01-16T21:27:20.628439",
    "cve_id": "CVE-2022-2845",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "74f179c6",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a display function in a text editor (likely Vim) handling cursor and screen updates. It does not involve regular expression parsing, Unicode processing, or the specific out-of-bounds read vulnerability (CWE-125) related to NUL bytes in Perl's regex engine. The domains and vulnerability patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs simple display logic with local cursor manipulation and character output. It does not involve network service daemon functionality, dynamic memory allocation, or the complex state management that leads to use-after-free (CWE-416) vulnerabilities. The attack surfaces and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The target code does not perform any network protocol parsing, file transfer handling, or integer arithmetic for buffer sizes. The vulnerability (CWE-787) stems from integer overflows in allocation, which is not present here. The only weak similarity is the manipulation of column positions (colnr_T), but this is simple assignment, not unsafe arithmetic leading to out-of-bounds writes.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both the target code and the WeeChat case involve functions related to display/formatting (IRC colors vs. displaying a '$' character). However, the vulnerability in WeeChat is a heap-based buffer overflow (CWE-122) due to unsafe string concatenation and buffer growth. The target code uses a fixed `edit_putchar` call with no dynamic string building or buffer management, making the vulnerability pattern fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The primary connection is the handling of multi-byte characters (`has_mbyte`, `mb_head_off`). The libxml2 vulnerability (CWE-125) involves out-of-bounds reads during multi-byte character processing due to inadequate bounds checking. The target code adjusts a column position based on multi-byte character head offset, which involves pointer arithmetic (`p + col`). If `col` is incorrectly large, `p + col` could point past the buffer, and `mb_head_off` could read out-of-bounds. This is a plausible, though not identical, vulnerability pattern. The domain (text editor display vs. XML parsing) differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse structured document formats (XML) or process tags. The out-of-bounds read (CWE-125) vulnerability in libxml2 is specific to its parser state machine and end tag validation. The cursor and column manipulation in the target code does not share this pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code is a simple display routine, not an image rendering pipeline. The Ghostscript vulnerability (CWE-787) involves complex color space conversion and incorrect position tracking leading to out-of-bounds writes. The domains, data structures, and operations are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not perform any memory allocation, buffer management for compression, or arithmetic related to buffer sizes. The OpenJPEG vulnerability (CWE-119) is a classic heap overflow due to incorrect size calculation. The target code's operations are trivial and do not involve these risks.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse network packets or any TLV (Type-Length-Value) structures. The tcpdump vulnerability (CWE-125) is specific to protocol dissection where a length field is untrusted. The target code's inputs are internal column positions, not attacker-controlled packet data.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The core issue in the tcpdump case is improper input validation (CWE-20) of packet data. The target code does have an input (`col` parameter), but it's an internal column index. There is a potential for improper validation if `col` is larger than the line length, which could lead to an out-of-bounds read in the `mb_head_off` call (as noted in case 5). This is a tangential similarity, but the context (network protocol parsing vs. internal UI function) and the specific vulnerability patterns are very different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2021-41072_after_exclude_100:2bc5ea2c:vulspec": {
    "timestamp": "2026-01-16T21:27:20.700457",
    "cve_id": "CVE-2021-41072",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2bc5ea2c",
    "scores": [
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve filesystem parsing code that reads structures from disk. The target code validates directory entry sizes (dire->size >= SQUASHFS_NAME_LEN) to prevent buffer overflows, which is conceptually similar to the bounds checking issue in CVE-2019-1010065. However, the specific vulnerability (integer overflow leading to key length bypass) and the data structure (B-tree vs. linear directory) are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's state management. The target code is a filesystem directory parser with straightforward memory allocation (malloc) and cleanup (squashfs_closedir). There is no complex state or error path that would lead to pointer reuse or double-free in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve reading and processing data from an external source. However, CVE-2019-20840 is about unaligned memory access in a network protocol decoder. The target code uses byte-by-byte reads via `read_directory_data` and performs byte-swapping with `SQUASHFS_INSWAP_DIR_ENTRY`, but there is no indication of direct word-sized access to unaligned network buffers.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve processing data from an untrusted source (filesystem image / network client). The vulnerability chain in CVE-2018-20750 involves integer overflow in allocation size calculation. The target code performs size validation (dire->size, dir_count) but does not have complex arithmetic for memory allocation; it allocates fixed-size structures. The similarity is in the need to validate attacker-controlled integers.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a kernel filesystem's concurrent resource management. The target code is a user-space, single-threaded directory parsing function with no concurrency or shared state management.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are parsers for structured data formats (filesystem vs. Office document). CVE-2011-1003 involves a double-free during error handling. The target code has a `corrupted:` error label that frees the `dir` structure, but all allocations before that point (for `dir` and `ent`) are freed in `squashfs_closedir`. There is no obvious path to a double-free in the shown flow.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing data and checking for invalid characters/bytes. CVE-2018-18313 is about out-of-bounds read due to NUL bytes in a string. The target code reads a size-prefixed string (`dire->name`) and explicitly null-terminates it (`dire->name[dire->size + 1] = '\\0'`), then validates it with `check_name`. The pattern of validating external size fields is similar, but the specific vulnerability (OOB read via embedded NUL) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve calculating buffer sizes based on input data. CVE-2017-14151 is a buffer overflow due to insufficient padding calculation. The target code uses a fixed-size stack buffer for reading directory entries and validates the `dire->size` field against `SQUASHFS_NAME_LEN` before using it. The similarity is in validating size fields to prevent buffer overflow, but the mechanism (stack buffer vs. heap allocation with padding) is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free due to a race condition in kernel memory policy locking. The target code is a simple user-space parser with no locking, shared resource management, or complex lifecycle issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve processing data from an untrusted source where size fields must be validated. CVE-2010-4650 is a buffer overflow due to insufficient validation of iovec lengths in a kernel driver. The target code validates the `dire->size` field before reading the name into a fixed-size buffer, which is a similar security principle but in a much simpler context.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      }
    ]
  },
  "CVE-2022-2845_after_exclude_100:7cad33e3:vulspec": {
    "timestamp": "2026-01-16T21:27:20.838029",
    "cve_id": "CVE-2022-2845",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7cad33e3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a display function in a text editor (likely Vim/Neovim) handling cursor and screen rendering. CVE-2018-18313 is in Perl's regex engine, involving out-of-bounds reads from NUL byte handling. The domains (UI rendering vs. regex compilation), vulnerability types (no obvious buffer read in target), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs simple cursor manipulation and character display. CVE-2016-3179 is a use-after-free in a network daemon's service registration. The code does not involve dynamic memory allocation, freeing, or network protocol parsing. The attack surfaces and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The target code does not perform any memory allocation, integer calculations for sizes, or network data handling. CVE-2018-20750 is an out-of-bounds write due to integer overflow in a network file transfer. While both involve \"display/rendering\" in a broad sense, the specific vulnerability mechanism (integer wrap leading to heap corruption) is not present in the simple, bounded display_dollar function.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both the target code and CVE-2012-5854 involve processing formatted text for display. However, the target code simply outputs a single '$' character with bounds checking (`curwin->w_wcol < curwin->w_width`), while the WeeChat vulnerability is a heap buffer overflow during dynamic string building for IRC color codes. The target code shows no dynamic buffer growth or string concatenation, making the core vulnerability pattern dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The target code has a multi-byte character handling path (`has_mbyte`, `mb_head_off`), which is a superficial similarity to CVE-2016-1833's multi-byte encoding issue in libxml2. However, the target's use is a safe adjustment of a column offset within a line, not parsing untrusted input. The vulnerability type (out-of-bounds read due to invalid parser state) and domain (XML parsing vs. editor UI) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. No relevance beyond the generic concept of \"parsing\" or \"processing input.\" The target code does not parse structured data like XML tags. The out-of-bounds read vulnerability in libxml2's end tag processing shares no code patterns or trigger conditions with the simple, arithmetic-based column adjustment in display_dollar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Both functions could be broadly categorized as \"rendering\" operations. CVE-2020-16304 is an out-of-bounds write during image pixel processing due to incorrect position tracking. The target code writes a single character to a screen buffer with an explicit bounds check. The scale, complexity, and mechanism (pixel buffer iteration vs. single char output) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code performs no memory allocation or buffer management for compressed data. CVE-2017-14151 is a buffer overflow in a JPEG 2000 encoder due to incorrect size calculation. The domains (image compression vs. text display) and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not parse network packets or any TLV structures. CVE-2018-14461 is an out-of-bounds read in a network protocol dissector due to insufficient length validation. The attack surface (network data) and code purpose are completely different from the local screen update function.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Similar to case 9, this involves network packet parsing (LMP protocol) with improper input validation. The target code operates on internal editor state (cursor column, window width) which is trusted and bounded. There is no parsing of untrusted, variable-length data streams.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2021-41072_before_exclude_100:5c5d3f13:vulspec": {
    "timestamp": "2026-01-16T21:27:26.724599",
    "cve_id": "CVE-2021-41072",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5c5d3f13",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve filesystem parsing, but the vulnerability types differ. CVE-2019-1010065 is an integer overflow (CWE-190) in an HFS B-tree traversal leading to memory corruption. The target code performs bounds checks (e.g., `dir_count > SQUASHFS_DIR_COUNT`, `dire->size >= SQUASHFS_NAME_LEN`) to prevent similar overflows, but the core flaw pattern (integer wrap-around bypassing checks) is not directly mirrored here.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free (CWE-416) in a network daemon's state management. The target code is a filesystem directory opener with straightforward memory allocation (`malloc`) and cleanup (`squashfs_closedir`). There are no complex state machines, error paths that leave dangling pointers, or double-free patterns evident in this function.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write (CWE-787) due to unaligned memory access in a network protocol decoder. The target code reads filesystem metadata into aligned buffers (note the `__attribute__((aligned))`) and uses safe, byte-by-byte operations via `read_directory_data`. No low-level memory operations on misaligned data are present.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-20750 is an out-of-bounds write due to an integer overflow in allocation (CWE-190 -> CWE-787). The target code has integer-based loop controls (`bytes < size`, `dir_count--`) and reads variable-length names (`dire->size`). While it checks for overflow-like conditions (`dire->size >= SQUASHFS_NAME_LEN`), a miscalculation in `size` or missing check could lead to a buffer over-read in the `buffer[]` or heap corruption. The pattern of validating externally controlled integers is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a kernel race condition (CWE-362) in a concurrent resource manager. The target code is a single-threaded, sequential directory parsing function in what appears to be a user-space tool (SquashFS utils). There is no concurrency, shared state, or lock management.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1003 is a double-free (CWE-415) in a file parser. The target code has a single error label (`corrupted`) that calls `squashfs_closedir(dir)`, which presumably frees the `dir` structure and its chain of `dir_ent`. If `squashfs_closedir` is not idempotent or if there were multiple error paths leading to double-free, it could be similar. However, the current function has only one cleanup path, making a double-free less likely.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) due to improper NUL-byte handling. The target code reads a string of length `dire->size + 1` and explicitly null-terminates it (`dire->name[dire->size + 1] = '\\0'`). This is a classic off-by-one error pattern: if the buffer size is exactly `sizeof(*dire) + SQUASHFS_NAME_LEN + 1`, and `dire->size` equals `SQUASHFS_NAME_LEN`, this write is out-of-bounds. The check `dire->size >= SQUASHFS_NAME_LEN` prevents this, but the code pattern is similar to a common vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow (CWE-119) due to insufficient buffer allocation. The target code uses a fixed-size stack buffer `buffer[]` to hold a directory entry and a name. The check `dire->size >= SQUASHFS_NAME_LEN` is critical to prevent an overflow when reading the name. The pattern of using a fixed buffer with size validation for variable-length data is conceptually similar, though the allocation mechanism (stack vs. heap) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-10675 is a Use-After-Free (CWE-416) due to a race condition in kernel memory policy. The target code is a simple, linear user-space function with no concurrency or complex resource lifetime management involving locks.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow (CWE-119) in a kernel ioctl interface due to insufficient validation of user-supplied iovec lengths. The target code validates sizes (`dire->size`) against a constant (`SQUASHFS_NAME_LEN`) but operates in a trusted context (parsing a filesystem image). The pattern of validating attacker-controlled lengths is present but at a much simpler level.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      }
    ]
  },
  "CVE-2022-3077_before_exclude_100:194236c8:vulspec": {
    "timestamp": "2026-01-16T21:27:28.400660",
    "cve_id": "CVE-2022-3077",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "194236c8",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to an out-of-bounds write in a user-space VNC server library. The target code is a kernel-space I2C/SMBus driver with no complex integer calculations for buffer sizes and uses DMA mapping APIs which handle size constraints safely. The vulnerability patterns and domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 is a use-after-free in a user-space daemon due to improper resource cleanup. The target kernel driver manages its own descriptor ring and uses completion for synchronization, with no apparent dynamic allocation/free of critical resources in the shown path. The context and bug pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a race condition in filesystem metadata management (nid allocation). The target I2C driver has a ring buffer (`priv->head`) that is incremented without explicit locking at the end of the function, which could suggest a potential concurrency issue if `ismt_access` is called concurrently. However, the core vulnerability pattern (race in ID management vs. potential descriptor ring corruption) is different, and I2C adapter accesses are typically serialized by the I2C core.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in a user-space regex compiler due to NUL byte handling. The target code is a kernel driver performing memory operations with explicit sizes derived from protocol commands (`dma_size`). No pattern parsing or NUL-byte-specific issues are present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 is a buffer overflow in kernel FUSE due to insufficient validation of iovec lengths from userspace. The target code also copies user-provided data (`data->block[]`) into a kernel DMA buffer (`dma_buffer`) based on a user-influenced size (`data->block[0]`). It performs bounds checking against `I2C_SMBUS_BLOCK_MAX`, which is a critical mitigation. The similarity lies in copying user-controlled data with a user-controlled size, but the target code includes validation and uses a fixed-size parent buffer (`priv->buffer`), making an overflow less likely. The attack surface (local I2C device access vs. network filesystem) is also different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a buffer access issue related to scatterlist and VMAP_STACK in a crypto module. The target code uses `dma_map_single` on a buffer aligned within a larger private structure, which is a common and generally safe pattern for DMA. There's no use of scatterlists or direct stack buffer DMA in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a use-after-free due to a race condition and improper locking in memory policy. The target code uses a completion (`priv->cmp`) to wait for an interrupt, but the descriptor (`desc`) and DMA buffer are part of the private structure (`priv`) whose lifetime is managed by the driver's probe/remove. A potential relevance exists if there's a race between the interrupt completion and driver removal, but this is not the specific pattern shown in Case 7.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is a NULL pointer dereference in a kernel USB/IP driver due to insufficient validation of URB fields. The target code validates the `size` parameter against a switch statement and checks `data->block[0]` bounds. However, it does not explicitly check if `data` or `data->block` is NULL before accessing `data->block[0]` or performing `memcpy`. If a caller passes a NULL `data` pointer for certain `size` modes (e.g., `I2C_SMBUS_BLOCK_DATA`), it could lead to a NULL pointer dereference. This mirrors the insufficient input validation aspect of Case 8, though the specific context differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is a race condition leading to a NULL pointer dereference during keyring initialization. The target code's main shared state is the descriptor ring index (`priv->head`). While a race on `priv->head` could corrupt descriptors, the pattern is not a direct analog to the keyring initialization race. The target code also lacks obvious NULL pointer dereference patterns from shared state.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is a NULL pointer dereference due to a race condition in a configfs operation. The target code dereferences pointers like `priv->pci_dev` and `dev` which are set during probe and assumed valid. A race with driver removal could theoretically cause a similar issue, but this is a common pattern for many drivers and not specific to the cluster filesystem race shown in Case 10.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      }
    ]
  },
  "CVE-2021-3968_after_exclude_100:8c0527b1:vulspec": {
    "timestamp": "2026-01-16T21:27:31.428445",
    "cve_id": "CVE-2021-3968",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8c0527b1",
    "scores": [
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a Vim function for entering visual mode, handling UI state and cursor management. VulSpec describes a Perl regex engine vulnerability (CWE-125) related to parsing malicious patterns with NUL bytes. Different language, domain (text editor UI vs. regex compilation), and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a Vim UI function. VulSpec describes a Use-After-Free (CWE-416) in a network daemon (MiniSSDPd) related to socket message handling and memory management during error cleanup. Completely different domain and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. Target code performs no memory allocation, integer calculations, or network data processing. VulSpec describes an Out-of-bounds Write (CWE-787) due to integer overflow in a VNC server's file transfer protocol. Different domain, functionality, and vulnerability root cause.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a Vim editor mode-switching function. VulSpec describes an Out-of-bounds Read (CWE-125) in libxml2's parser due to improper bounds checking during multi-byte character processing. Different domain (XML parsing vs. editor UI) and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code does not parse structured data or validate tags. VulSpec describes an Out-of-bounds Read (CWE-125) in libxml2's end tag processing. Different system, functionality, and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code handles editor visual mode state. VulSpec describes an Out-of-bounds Write (CWE-787) in Ghostscript's image rendering due to incorrect position tracking during color conversion. Different domain (graphics rendering vs. text editor) and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is not a network protocol parser. VulSpec describes an Out-of-bounds Read (CWE-125) in tcpdump's LDP protocol parser due to insufficient TLV length validation. Different domain and vulnerability context.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code performs simple variable assignments and function calls; no dynamic memory management or complex state transitions that could lead to Use-After-Free. VulSpec describes a Use-After-Free (CWE-416) in libxml2's SAX2 parser during attribute processing. Different domain and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code does not parse network packets or validate external input lengths. VulSpec describes an Improper Input Validation (CWE-20) in tcpdump's LMP protocol decoder. Different domain and functionality.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code does not manage a transparency stack, perform graphical rendering, or have operations that could cause a NULL pointer dereference from state corruption. VulSpec describes a NULL Pointer Dereference (CWE-476) in Ghostscript's PDF transparency stack due to unbalanced push/pop operations. Different domain and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      }
    ]
  },
  "CVE-2022-3077_after_exclude_100:8248ae0f:vulspec": {
    "timestamp": "2026-01-16T21:27:32.992715",
    "cve_id": "CVE-2022-3077",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8248ae0f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol handler. The target code is a Linux kernel I2C/SMBus driver with DMA buffer management. Different domains (network protocol vs. hardware bus driver), different vulnerability patterns (integer overflow in allocation vs. potential DMA/memory management issues).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3179 is a use-after-free in a userspace SSDP daemon. The target code is kernel-space I2C driver with DMA operations. While both involve memory management, the context (userspace daemon error handling vs. kernel driver DMA), attack surfaces, and root causes are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition in F2FS filesystem node management. The target I2C driver has a completion mechanism (wait_for_completion_timeout) for synchronization, but the vulnerability patterns differ significantly (concurrent nid management vs. hardware operation completion). Some reference value for concurrency considerations in kernel drivers.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. The target code is a kernel I2C driver with DMA buffer operations. Completely different domains (language interpreter vs. hardware driver) and vulnerability patterns (string parsing vs. DMA mapping).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2010-4650 is a buffer overflow in FUSE ioctl handling due to insufficient validation. The target code has DMA buffer operations with size calculations (e.g., dma_size = data->block[0] + 1) and memcpy operations. Both involve kernel-space buffer management, but different subsystems (filesystem vs. I2C) and specific vulnerability mechanisms differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-10154 involves improper buffer handling in kernel crypto operations with scatterlist pointing to stack memory. The target code uses dma_map_single on dma_buffer (which appears to be part of priv->buffer, potentially stack-allocated if priv is local). Both are kernel drivers dealing with memory mapping issues, though different subsystems (CIFS crypto vs. I2C DMA).",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-10675 is a use-after-free due to race condition in memory policy management. The target code has completion-based synchronization but no obvious shared resource race patterns similar to the mempolicy case. Both are kernel subsystems but with different concurrency models and resource management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2017-16914 is a NULL pointer dereference in USB/IP due to insufficient validation of URB fields. The target I2C driver has multiple pointer accesses (priv->pci_dev, dev, dma_buffer) and could potentially have similar issues if hardware returns unexpected states. Both are kernel device drivers handling hardware communication with potential for insufficient validation of device/state.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2013-1792 is a race condition leading to NULL pointer dereference in keyring subsystem. The target code has pointer accesses but uses completion mechanism for synchronization rather than mutexes. Different subsystems with different concurrency patterns and resource types.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-18216 is a NULL pointer dereference due to race condition in ocfs2 node manager. The target code accesses multiple pointers (priv->pci_dev, priv->hw, etc.) and has a completion mechanism. Some reference value for pointer validation and concurrency in kernel drivers, but different subsystems and specific patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      }
    ]
  },
  "CVE-2021-3968_before_exclude_100:f29999ed:vulspec": {
    "timestamp": "2026-01-16T21:27:37.848502",
    "cve_id": "CVE-2021-3968",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f29999ed",
    "scores": [
      {
        "score": 1,
        "reasoning": "The target code is a visual mode initiation function in a text editor (likely Vim/Neovim). It handles UI state changes, cursor validation, and redraw logic. CVE-2018-18313 is a buffer over-read in Perl's regex engine due to NUL byte handling. There is no functional overlap (UI vs. regex parsing), no similar vulnerability patterns (OOB read vs. state management), and completely different attack surfaces (local user interaction vs. regex pattern input). The relevance is extremely low.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code manages editor UI state. CVE-2016-3179 is a Use-After-Free in a network daemon (MiniSSDPd) related to socket message handling and memory management during error cleanup. The code domains (text editor UI vs. network service), vulnerability types (no memory allocation/free in target code), and attack surfaces (local key/mouse input vs. network packets) are fundamentally different. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code performs cursor positioning and UI flag updates. CVE-2018-20750 is an out-of-bounds write in a VNC server due to integer overflow in file transfer size calculation. The target code contains no arithmetic on user-controlled data, no network protocol parsing, and no dynamic memory allocation based on untrusted input. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is an editor function. CVE-2016-1833 is an out-of-bounds read in libxml2's parser during multi-byte character encoding processing. The code functionalities (visual mode activation vs. XML parsing), data types handled (cursor positions vs. character buffers), and vulnerability root causes (no encoding/decoding logic in target) are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code sets visual mode variables and handles cursor. CVE-2016-1838 is an out-of-bounds read in libxml2's end tag parser. There is no parsing of structured markup language tags, no buffer boundaries being checked against parsed lengths, and no similar code constructs. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is UI logic. CVE-2020-16304 is an out-of-bounds write in Ghostscript's image rendering color conversion module. The target code does not process image data, perform color space operations, or write to pixel buffers. The vulnerability mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code handles editor mode changes. CVE-2018-14461 is an out-of-bounds read in tcpdump's LDP protocol parser due to insufficient TLV length validation. The target code does not parse network packets, does not process Type-Length-Value structures, and does not read from packet buffers. No functional or vulnerability pattern overlap.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code manages visual mode state. CVE-2016-1835 is a Use-After-Free in libxml2's SAX2 attribute parser during namespace processing. The target code contains no XML parsing, no dynamic memory management of parsed data, and no complex state transitions that could leave dangling pointers. The contexts are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is part of a text editor's core UI. CVE-2019-15166 is an improper input validation (missing bounds check) in tcpdump's LMP protocol decoder for network packets. The target code validates cursor positions against tab characters but does not parse untrusted, variable-length binary data from the network. The similarity is superficial and the domains are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code initializes visual mode. CVE-2016-10218 is a NULL pointer dereference in Ghostscript's PDF transparency stack due to unbalanced push/pop operations. The target code does not manage a transparency/state stack, does not have paired push/pop operations on graphical state, and its pointer accesses (e.g., `curwin`) are assumed to be valid in normal operation. The vulnerability pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      }
    ]
  },
  "CVE-2021-28972_before_exclude_100:8e9c488c:vulspec": {
    "timestamp": "2026-01-16T21:27:43.714186",
    "cve_id": "CVE-2021-28972",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8e9c488c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a Linux kernel hotplug function handling a string buffer, while CVE-2018-18313 is in Perl's regex engine involving complex parsing and out-of-bounds reads due to NUL bytes. The domain, vulnerability pattern (OOB read vs. potential OOB write), and code context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both are in the Linux kernel, but the subsystems are entirely different (FUSE ioctl vs. DLPAR hotplug). The vulnerability type (buffer overflow due to insufficient validation) has a conceptual similarity, but the attack surfaces (malicious userspace server vs. user input to sysfs) and specific mechanisms (iovec manipulation vs. fixed-size buffer copy) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The core vulnerability pattern is highly relevant: both involve copying user-controlled data into a fixed-size stack buffer (`drc_name[MAX_DRC_NAME_LEN]`) with a size check that may be flawed. CVE-2018-20750's root cause is an integer overflow leading to OOB write, while the target code's check `if (nbytes >= MAX_DRC_NAME_LEN)` uses `>=` instead of `>`, which could allow writing exactly `MAX_DRC_NAME_LEN` bytes, overflowing the null terminator. The domain difference (VNC vs. kernel hotplug) reduces the score.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a concurrency-related race condition (CWE-362) in filesystem metadata management. The target function `add_slot_store` is a sysfs store operation, typically called serially, and shows no evidence of shared state or locking issues. The vulnerability classes are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. This is the most relevant case. Both vulnerabilities involve copying user/network input into a fixed-size buffer with an incorrect boundary check. CVE-2011-3601: DNSSL parser copies data with negative length. Target code: The check `if (nbytes >= MAX_DRC_NAME_LEN) return 0;` is problematic. If `nbytes == MAX_DRC_NAME_LEN-1`, `memcpy` copies that many bytes. If there is no newline, `end = &drc_name[nbytes]` points to the last byte, and `*end = '\\0'` writes one byte past the buffer. The pattern of an off-by-one/null-terminator overflow is very similar. The attack surface (user input via sysfs) is analogous to network input.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing external input, but CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code is a simple copy operation with a potential off-by-one write. The vulnerability class (OOB read vs. OOB write) and context differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-10154 is a cryptographic subsystem issue related to scatterlist and stack memory mapping. The target code is a straightforward string copy operation with no cryptographic elements. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a daemon's resource management. The target kernel code shows simple, linear execution with no dynamic memory allocation or free operations. No similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve copying data from an input source. CVE-2017-13001 is an out-of-bounds read in a packet decoder due to missing bounds checks. The target code has a bounds check, but it may be flawed (off-by-one leading to write). The direction of the violation (read vs. write) and the domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The relevance comes from the integer/arithmetic aspect of the buffer size check. CVE-2019-25034 involves an integer overflow in a length calculation leading to OOB write. The target code's check `nbytes >= MAX_DRC_NAME_LEN` could be seen as a similar \"boundary condition\" error, though not an integer overflow per se. The domain difference (DNS resolver vs. kernel sysfs) and the more complex arithmetic in the CVE reduce the score.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2021-28972_after_exclude_100:d00fbe86:vulspec": {
    "timestamp": "2026-01-16T21:27:47.184458",
    "cve_id": "CVE-2021-28972",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d00fbe86",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a Linux kernel sysfs store function for a hotplug slot, while CVE-2018-18313 is in Perl's regex engine. The vulnerability type (out-of-bounds read due to NUL byte handling) and domain (user-space application vs. kernel driver) are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Both are in the Linux kernel, but domains differ vastly: FUSE ioctl handling vs. a sysfs store function for DLPAR. The vulnerability mechanism (buffer overflow due to insufficient iovec validation) does not align with the target code's simple string copy and null-termination logic.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The vulnerability chain involves integer overflow leading to out-of-bounds write (CWE-190/787). The target code performs a bounded copy with `strscpy` using `nbytes + 1`, which guards against overflow if `nbytes` is less than `MAX_DRC_NAME_LEN`. The check `if (nbytes >= MAX_DRC_NAME_LEN) return 0;` prevents the overflow in `nbytes + 1` when `nbytes` is `MAX_DRC_NAME_LEN - 1`. However, the pattern of input size validation and buffer management is superficially similar, but the specific integer overflow risk is mitigated differently.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The vulnerability is a race condition (CWE-362) in F2FS node ID management. The target code is a simple, synchronous sysfs store function with no concurrency or resource management patterns. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The core vulnerability is a buffer overflow (CWE-119) due to improper input validation, specifically related to length handling. The target code shows a pattern of input validation (`if (nbytes >= MAX_DRC_NAME_LEN)`) and use of a safe copy function (`strscpy`). This is conceptually similar to the need for bounds checking seen in CVE-2011-3601, though the specific flaw (negative length) and context (network daemon vs. kernel sysfs) differ. The code serves as an example of correct bounds checking, which contrasts with the vulnerable pattern.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Vulnerability is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length validation. The target code validates length upfront and uses a safe copy, but its purpose (system control) and structure are not analogous to parsing untrusted network packets with complex TLVs.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Vulnerability involves improper memory buffer operations with kernel crypto APIs and scatterlists. The target code performs basic string copying to a stack buffer. The domains (cryptography vs. sysfs) and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Vulnerability is a use-after-free (CWE-416) due to error handling and state management in a daemon. The target code has no dynamic memory allocation or complex error paths that could lead to similar issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Vulnerability is an out-of-bounds read (CWE-125) in a network packet decoder. While both involve copying data from an input buffer, the target code's validation and safe copy pattern (`strscpy` with explicit size) is the correct antithesis of the vulnerable pattern, but the contexts are too dissimilar for strong reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The vulnerability involves integer overflow (CWE-190) in length calculation leading to buffer overflow. The target code contains a potential integer overflow in the expression `nbytes + 1` if `nbytes` is `MAX_DRC_NAME_LEN`. However, this is prevented by the preceding check `if (nbytes >= MAX_DRC_NAME_LEN)`. If `nbytes` equals `MAX_DRC_NAME_LEN - 1`, then `nbytes + 1` equals `MAX_DRC_NAME_LEN`, which is the size of the `drc_name` buffer, making the `strscpy` safe. If `nbytes` were `MAX_DRC_NAME_LEN`, the function returns early. Therefore, the code correctly avoids the overflow. The pattern of validating input size before using it in arithmetic is directly relevant to preventing CWE-190, making this case a useful contrast.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2021-3905_after_exclude_100:6f93bee1:vulspec": {
    "timestamp": "2026-01-16T21:27:47.819431",
    "cve_id": "CVE-2021-3905",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6f93bee1",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer context. The target code performs IP fragment reassembly with mutex locking and packet validation. The vulnerability type (heap corruption via integer issues), domain (remote desktop protocol), and code patterns (memory allocation vs. packet processing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser (tcpdump/LDP). While both involve network packet processing, the target code is for IP fragment reassembly in a forwarding engine, not protocol dissection. The vulnerability mechanism (insufficient length validation) differs from the target's focus on fragment handling and concurrency control.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14467 is another tcpdump out-of-bounds read in BGP parsing. Similar to case 2, both process network packets but the target code implements stateful fragment reassembly with locking, while the vulnerability involves missing bounds checks in passive protocol analysis. Different security concerns (parsing vs. state management).",
        "case_metadata": {
          "cve_id": "CVE-2018-14467"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-13053 is a tcpdump BGP parsing out-of-bounds read with offset calculation issues. The target code handles IP fragments with proper locking and calls validation functions (ipf_is_valid_v4/v6_frag). Different domains: packet forwarding vs. packet analysis. The vulnerability pattern (incorrect pointer arithmetic) doesn't match the target's pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14881 is yet another tcpdump BGP out-of-bounds read. The target code focuses on IP fragment handling with mutex protection and packet lifecycle management (delete/refill). The vulnerability mechanism (insufficient bounds checking in capability parsing) doesn't align with the target's fragment validation and reassembly logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-14881"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-13054 is an LLDP parser out-of-bounds read in tcpdump. Both process network packets, but the target code is active fragment reassembly in a networking stack component, not passive protocol dissection. Missing length validation vulnerability doesn't match the target's pattern of checking fragment validity then handling under lock.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2010-4650 is a Linux kernel FUSE buffer overflow due to insufficient iovec validation. Slightly higher relevance because both involve kernel/system-level code with concurrency considerations (mutex locking in target). However, the vulnerability type (buffer overflow in ioctl retry path) and domain (filesystem vs. networking) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-13044 is a tcpdump DHCP option parsing out-of-bounds read. Similar to other tcpdump cases: both process network data but the target implements stateful IP fragment handling with mutex protection, while the vulnerability is about missing length checks in protocol decoding.",
        "case_metadata": {
          "cve_id": "CVE-2017-13044"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-25040 involves infinite loop in DNS name decompression. Moderate relevance because both handle network protocol data (IP fragments vs. DNS names) and could involve state tracking issues. The target's ipf_handle_frag() might have similar complexity in state management, but the specific vulnerability (unreachable loop condition) differs from the target's apparent focus.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. Completely different domain (regular expression compilation vs. network packet processing). No meaningful similarity in vulnerability type, trigger conditions, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      }
    ]
  },
  "CVE-2021-28856_before_exclude_100:1a07d32e:vulspec": {
    "timestamp": "2026-01-16T21:27:52.349719",
    "cve_id": "CVE-2021-28856",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1a07d32e",
    "scores": [
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is a simple image format parser reading structured header fields. CVE-2016-3179 involves a Use-After-Free in a network service daemon's state management, with completely different functionality (SSDP vs. image parsing), attack surface (network socket vs. file input), and vulnerability pattern (memory management race condition vs. data reading).",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both the target code and CVE-2017-12982 (OpenJPEG) involve parsing image file headers (BMP vs. Mac PixMap). Both read fields like bit depth (`bi->pixelsize` vs `biBitCount`). The vulnerability pattern (CWE-119) relates to improper validation of header values which could lead to memory issues downstream. However, the target code shown only reads data without obvious allocation or bounds-checking logic, making the relevance indirect.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code reads a structured binary format with fixed offsets using `dbuf_get*` functions. The domains (text processing vs. binary image parsing), vulnerability triggers (embedded NULs vs. integer field validation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in a network file transfer protocol. The target code reads fields that could theoretically be used in a later allocation (like `pack_size`), but the code shown performs no arithmetic or memory writes. The relevance is only in the broad category of parsing untrusted input, but the specific vulnerability mechanism is absent.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking during tag parsing. The target code reads from a buffer (`dbuf`) at calculated offsets. While both involve parsing, the XML parser's state machine and complex string processing are not comparable to the simple, sequential field reading in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a heap buffer overflow in a JPEG 2000 encoder due to insufficient padding allocation. The target code reads header fields that might later influence buffer sizes (e.g., `pack_size`, `pixelsize`, `rowbytes`). The connection is that unchecked header values could lead to similar allocation problems elsewhere in the program, but the shown code itself contains no allocation or overflow.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code also parses a format with length-like fields (`pack_size`, `plane_bytes`). If these fields were not validated against the actual buffer size before later use, a similar issue could occur. The relevance is higher than other cases due to the pattern of reading length fields from untrusted input, but the target code does not show the validation or subsequent use.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2 due to improper multi-byte character encoding handling. The target code deals with fixed-size binary fields, not variable-length character data. The vulnerability patterns (encoding state errors vs. integer field parsing) and domains are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a Linux kernel filesystem's resource management. The target code is a simple, synchronous function parsing data from a file buffer. There is no concurrency, resource allocation, or state management that could lead to a race condition.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2013-1978 is an out-of-bounds write in an image file parser (GIMP XWD plugin) due to insufficient validation of header field relationships (color count vs. color map entries). The target code similarly parses an image format header (Mac PixMap) and reads multiple interrelated fields (`pixelsize`, `cmpcount`, `cmpsize`, `rowbytes`). The vulnerability pattern of using unchecked header values to calculate sizes or offsets for later memory operations is conceptually similar. The target code calculates `bi->pdwidth` based on these fields, which could be a validation point.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      }
    ]
  },
  "CVE-2021-3905_before_exclude_100:5ca21867:vulspec": {
    "timestamp": "2026-01-16T21:27:53.065682",
    "cve_id": "CVE-2021-3905",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5ca21867",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is an IP fragment reassembly function in a network stack context, while CVE-2018-20750 is an integer overflow leading to heap corruption in a VNC file transfer protocol. The domains (network packet processing vs. remote desktop protocol), vulnerability types (no obvious overflow in target code vs. CWE-787), and attack surfaces are completely different. The only weak similarity is both process untrusted network data.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-14461 is an out-of-bounds read in a network protocol parser (tcpdump's LDP). The target code also processes network packets (IP fragments) but is part of a reassembly engine, not a passive dissector. The vulnerability pattern is different: the target code uses mutex locks and focuses on stateful fragment handling, with no obvious parsing of variable-length TLV structures that could lead to CWE-125. The relevance is very low.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-14467 is another tcpdump out-of-bounds read in BGP capability parsing. Similar to case 2, the domain is network packets but the functionality (stateful fragment reassembly vs. stateless packet dissection) and the specific vulnerability pattern (missing bounds check on parsed fields) are not evident in the provided target code snippet, which focuses on locking and packet batch refilling.",
        "case_metadata": {
          "cve_id": "CVE-2018-14467"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-13053 is yet another tcpdump BGP parsing out-of-bounds read due to incorrect offset calculation. The target code does not perform complex offset calculations or parse nested structures like BGP attributes. Its primary operations are validation checks (`ipf_is_valid_v4_frag`), locking, and calling `ipf_handle_frag`. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-14881 is an out-of-bounds read in tcpdump's BGP RESTART capability parsing. The consistent theme with cases 2-5 is that they are all memory safety issues in passive, stateless protocol dissectors. The target code is part of a stateful, in-line processing module (likely a firewall or forwarder) that modifies packet batches. The code patterns and potential flaws are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2018-14881"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-13054 is an out-of-bounds read in tcpdump's LLDP parser. The analysis is identical to previous tcpdump cases: different system role (dissector vs. in-line processor), different vulnerability trigger (missing length validation on TLV vs. logic errors in fragment handling), and no relevant code pattern match.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2010-4650 is a buffer overflow in the Linux kernel FUSE subsystem due to improper validation of iovec lengths. This is slightly more relevant because both are in-kernel (or system-level) modules processing untrusted data, and both involve careful management of data buffers. However, the target code's domain (network fragment reassembly) and specific operations (mutex locks, batch refill) are still very different from FUSE ioctl handling. The vulnerability pattern (buffer overflow from miscalculated size) is not immediately apparent in the snippet.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-13044 is an out-of-bounds read in tcpdump's HNCP/DHCPv4 parser. This returns to the pattern of passive dissection vulnerabilities, which has weak relevance to the active, stateful IP fragment reassembly code shown.",
        "case_metadata": {
          "cve_id": "CVE-2017-13044"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-25040 is an infinite loop in Unbound DNS due to improper handling of compression pointers. This has moderate relevance because both the target code and Unbound process complex, untrusted network protocols (IP fragmentation vs. DNS compression) where state and recursion depth matter. The target function `ipf_handle_frag` (not shown) could potentially contain loops or deep recursion when reassembling many fragments. The vulnerability pattern (CWE-835) is a more plausible concern for a fragment reassembly engine than the out-of-bounds reads prevalent in other cases. However, the provided snippet itself does not show the loop logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to improper NUL byte handling. This is in a completely different domain (language runtime string processing) and has no meaningful similarity to network packet fragment reassembly code in terms of functionality, data structures, or vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      }
    ]
  },
  "CVE-2021-28856_after_exclude_100:b49af4a4:vulspec": {
    "timestamp": "2026-01-16T21:27:59.388686",
    "cve_id": "CVE-2021-28856",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b49af4a4",
    "scores": [
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is a simple image format (PICT/PixMap) parser reading structured header fields. CVE-2016-3179 involves a Use-After-Free in a network service daemon (MiniSSDPd) related to socket message handling and complex state management. The domain (image parsing vs. network service), vulnerability type (memory corruption vs. UAF), and code patterns (direct data reads vs. pointer/state management) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both the target code and CVE-2017-12982 (OpenJPEG) involve parsing image file headers. The vulnerability type (CWE-119) relates to improper bounds restriction due to unchecked input values. The target code reads multiple fields (pixelsize, cmpcount, etc.) from a file buffer (`dbuf *f`) without explicit validation shown, which is a similar pattern to the unchecked `biBitCount` in the BMP parser. However, the specific trigger (allocation failure vs. buffer overflow) and the exact code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regular expression compiler (Perl) due to improper NUL byte handling in strings. The target code performs structured, bounded reads (`dbuf_getu16be`, `dbuf_getu32be`) from a known position into local variables. There is no string parsing or character-by-character processing that could be confused by embedded NULs. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs integer arithmetic (`(bi->rowbytes*8)/bi->pixelsize`) which could theoretically overflow or divide by zero if `bi->pixelsize` is attacker-controlled and not validated. This is a minor similarity. However, the primary vulnerability chain (integer wrap in allocation, truncation, heap corruption) and context (network file transfer vs. local file parsing) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking during end tag processing. The target code reads a fixed set of fields from a known offset using specific byte-width read functions. There is no complex state machine or hierarchical parsing that could lose track of buffer boundaries. The similarity is limited to both being file format parsers.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow in a JPEG 2000 encoder due to insufficient padding allocation. The target code is a header parser, not an encoder/allocator. The only potential link is that the parsed fields (`pixelsize`, `cmpcount`, `rowbytes`) might later be used to calculate buffer sizes. If those calculations are incorrect and lack validation, they could lead to similar issues. However, the target code itself does not perform those allocations.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code parses a binary format with implicit length/structure defined by the fixed header format. It does not read a variable-length field based on an earlier length value. The similarity is that both parse binary structures from an input buffer, but the risk pattern (fixed-structure vs. length-guided parsing) is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2 due to improper multi-byte character encoding handling. The target code reads numeric fields in big-endian format, not character strings. There is no character encoding processing or variable-byte reading that could cause a misalignment or buffer over-read. The domains are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a Linux kernel filesystem's resource management. The target code is a simple, synchronous function reading data from a file buffer. There is no concurrency, resource allocation/deallocation, or state shared between threads. The vulnerability class and context are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2013-1978 is an out-of-bounds write in an image file parser (GIMP XWD plugin) due to insufficient validation of header field relationships (color count vs. color map entries). The target code similarly parses an image format header (Mac PICT/PixMap) and reads multiple interrelated fields (`pixelsize`, `cmpcount`, `rowbytes`, `pdwidth`). It contains logic that uses one field to calculate another (`bi->pdwidth = (bi->rowbytes*8)/bi->pixelsize`). If these fields are not validated against each other or the file size, they could lead to incorrect calculations used later for memory operations, similar to the vulnerability pattern in the XWD plugin. The domain (image parsing) and the pattern of trusting header fields are directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      }
    ]
  },
  "CVE-2019-19246_before_exclude_100:7304c7cf:vulspec": {
    "timestamp": "2026-01-16T21:28:00.788118",
    "cve_id": "CVE-2019-19246",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7304c7cf",
    "scores": [
      {
        "score": 4,
        "reasoning": "The target code is from Oniguruma/Onigmo regex library, not Perl. While both handle regex compilation, the vulnerability (CWE-125: Out-of-bounds Read due to NUL bytes) is specific to Perl's regex engine and its handling of \\N{...} sequences. The target function `expand_case_fold_string` deals with case-insensitive matching expansion, not Unicode named character parsing or NUL byte issues. Only weak relevance due to being in the same broad domain (regex compilation).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is from Oniguruma/Onigmo, not glibc. The vulnerability (CWE-19: Data Processing Errors in ERE parsing with | operator and backreferences) involves state tracking during alternative pattern parsing. The target function expands case-folded strings into alternations but does not parse the regex syntax or handle backreferences. Moderate weak relevance as both involve generating alternative patterns during compilation, but the vulnerability mechanism and code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is from a regex library (Oniguruma/Onigmo), not libxml2. The vulnerability (CWE-125: Out-of-bounds Read in XML multi-byte character processing) is specific to XML parsing and character encoding handling. The target function processes string expansion for case folding, with different memory access patterns. Very low relevance; only superficial similarity in processing byte sequences.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The target code is from Oniguruma/Onigmo (CVE-2019-16161 affects Onigmo). The vulnerability (CWE-476: NULL Pointer Dereference in error handling) is in the same library ecosystem. The target function `expand_case_fold_string` contains multiple error paths with `goto mem_err` and `goto err` that free nodes and return error codes, similar to error handling patterns that could lead to NULL pointer issues if state is inconsistent. Code patterns and library context are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is from a regex library, not libxml2. The vulnerability (CWE-125: Out-of-bounds Read in XML end tag parsing) is specific to XML document structure parsing. The target function expands strings within a regex node tree, with different bounds checking concerns. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is from a regex library, not LibVNC. The vulnerability (CWE-787: Out-of-bounds Write due to integer overflow in file transfer) involves network protocol handling and integer overflows in size calculations. The target function performs tree manipulation with careful length calculations but no network input or large integer handling. Very low relevance; only generic memory safety concern is similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is from a regex library, not libxml2. The vulnerability (CWE-416: Use After Free in XML attribute processing) involves SAX2 parser state and memory management for attributes. The target function allocates and frees regex nodes but uses a consistent ownership pattern. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The target code is from Oniguruma (CVE-2017-9226 affects Oniguruma). The vulnerability (CWE-787: Out-of-bounds Write in character class processing) is in the same library. The target function `expand_case_fold_string` processes case-folded characters via `ONIGENC_GET_CASE_FOLD_CODES_BY_STR` and expands them into alternations, which involves similar character encoding processing and node tree manipulation. While not the same function (`next_state_val`), the code patterns, library internals, and memory safety concerns are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code is from a regex library, not GPAC multimedia framework. The vulnerability (CWE-787: Out-of-bounds Write in UTF encoding conversion) involves text file import and encoding conversion. The target function handles string expansion but uses regex library-specific encoding functions. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. This is the same CVE as case 4 (CVE-2019-16161) but described from the error handling function perspective. The target code is from Oniguruma/Onigmo, and the vulnerability (CWE-476: NULL Pointer Dereference in `onig_error_code_to_str`) is directly related to error paths in regex compilation. The target function has multiple error returns (`mem_err`, `err`) that could interact with such error handling. Codebase and vulnerability patterns are almost identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      }
    ]
  },
  "CVE-2019-19246_after_exclude_100:9502304c:vulspec": {
    "timestamp": "2026-01-16T21:28:02.977795",
    "cve_id": "CVE-2019-19246",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9502304c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The target code is from Oniguruma/Onigmo regex library (expand_case_fold_string), while CVE-2018-18313 is in Perl's regex engine. Both handle regex compilation but are different codebases. The vulnerability type (CWE-125 out-of-bounds read due to NUL bytes) is not directly relevant to the case folding logic shown, which focuses on memory allocation and node manipulation. Some similarity in domain but different vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2009-5155 is in glibc's regex implementation (parse_reg_exp). The target code is from Oniguruma/Onigmo. Both are regex compilation components. The vulnerability involves state handling errors (CWE-19) during alternative pattern parsing. The target code also handles alternatives in case folding expansion (alt_num calculation), but the specific vulnerability pattern (backreference state corruption) is not evident in the provided code. Moderate domain similarity but different vulnerability mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-1833 is in libxml2 (XML parsing, character encoding). The target code is regex case folding in Oniguruma. Different domains (XML vs regex). Both involve character processing, but the vulnerability type (CWE-125 out-of-bounds read in multi-byte handling) is not directly applicable to the shown code which uses library functions like ONIGENC_GET_CASE_FOLD_CODES_BY_STR with proper bounds checking via 'end' pointer.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 9,
        "reasoning": "CVE-2019-16161 is in Onigmo (the same library family as the target code). The target function expand_case_fold_string is from Oniguruma/Onigmo. The vulnerability involves NULL pointer dereference (CWE-476) in error handling. The target code has multiple error paths with goto mem_err/err that free nodes and return error codes. It shows similar error handling patterns (onig_node_free, returning ONIGERR_MEMORY). High relevance due to same library, similar error handling patterns, and potential for NULL pointer issues in node management.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-1838 is in libxml2 (XML end tag parsing). Different domain from regex processing. Vulnerability is CWE-125 out-of-bounds read. The target code uses bounded pointer arithmetic (p < end checks) and doesn't show similar parsing patterns for hierarchical structures. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-20750 is in LibVNC (file transfer protocol). Completely different domain from regex processing. Vulnerability involves integer overflow leading to out-of-bounds write (CWE-787). The target code does arithmetic with alt_num multiplication but has a threshold check (THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION). No similarity in functionality or vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-1835 is in libxml2 (XML attribute parsing, use-after-free). Different domain. The target code manages node memory with onig_node_new_str/onig_node_free but shows careful ownership transfer (swap_node). No evident use-after-free pattern. Low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 8,
        "reasoning": "CVE-2017-9226 is in Oniguruma (the same library as the target code). Vulnerability is out-of-bounds write (CWE-787) in character class processing. The target code is also in Oniguruma's regex compilation subsystem (case folding expansion). Both handle regex compilation, memory allocation for nodes, and have similar error handling patterns. The target code uses items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM] and buf[ONIGENC_MBC_CASE_FOLD_MAXLEN] - fixed-size arrays that could be relevant for buffer overflow analysis. Strong relevance due to same codebase and similar compilation context.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-20760 is in GPAC multimedia framework (text encoding conversion). Different domain. Vulnerability is out-of-bounds write in UTF conversion. The target code does character folding but uses library functions for case conversion. No similarity in functionality or vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 9,
        "reasoning": "CVE-2019-16161 (same as case 4) is in Oniguruma error handling. The target code is from the same library family and shows extensive error handling with memory cleanup. Multiple NULL checks (IS_NULL/IS_NOT_NULL) and careful freeing of nodes indicate awareness of memory safety issues. The pattern of goto mem_err and onig_node_free(top_root) is very similar to error handling patterns that could lead to NULL dereference if not properly implemented. Highly relevant as it's the same library with similar error handling patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      }
    ]
  },
  "CVE-2021-40575_before_exclude_100:1ad0269c:vulspec": {
    "timestamp": "2026-01-16T21:28:13.432228",
    "cve_id": "CVE-2021-40575",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1ad0269c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a multimedia demuxer for MPEG video, handling packet parsing and frame reconstruction. CVE-2016-3179 is a use-after-free in a network service discovery daemon (MiniSSDPd). The domains (multimedia parsing vs. network service), vulnerability patterns (memory management in error paths vs. start code parsing), and attack surfaces (local socket vs. media stream) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow in an image codec (OpenJPEG) due to insufficient padding allocation. The target code also performs memory allocation (gf_realloc, gf_filter_pck_new_alloc) and copies data (memcpy). However, the core vulnerability pattern (arithmetic error in padding calculation leading to overflow) is not evident in the provided code, which focuses on stream parsing and packet dispatch. The domains are related (multimedia processing) but the specific flaw is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 is an out-of-bounds write in a VNC server due to integer overflow in allocation. The target code contains numerous size calculations and memory operations (e.g., `ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size`). While there is a surface similarity in handling variable-sized data blocks, the provided code does not show obvious integer overflow vulnerabilities in its allocations. The relevance is higher than other cases due to the shared theme of parsing untrusted input (media streams) and managing buffers.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-12982 is a memory allocation failure/DoS in a BMP-to-JPEG2000 converter due to unchecked header values. The target code parses MPEG video headers and allocates memory, but the vulnerability pattern (unchecked large allocation leading to failure) is not directly visible. The code uses `gf_realloc` and checks allocation success via `if (!dst_pck) return GF_OUT_OF_MEM;`, showing some defensive programming. The domains are both multimedia but the flaw type is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write in a WebSocket decoder due to unaligned memory access. The target code performs byte-aligned memory copies (`memcpy`) and bitstream parsing (`gf_bs_*` functions). There is no indication of word-aligned access or the specific alignment vulnerability. The domains (video demuxing vs. network protocol decoding) and vulnerability root causes are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-13219 is an integer overflow in an audio codec's mathematical computations. The target code performs arithmetic on sizes and offsets (e.g., `size -= 3`, `ctx->hdr_store_size + pck_size`, `remain -= current`). While integer overflows/wraparounds are a potential concern in such calculations, the provided code does not show the same complex mathematical computations on untrusted data as in the Vorbis codebook handling. The shared context of parsing compressed media streams raises relevance slightly.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-11222 is an out-of-bounds write in GPAC's binary data parser. Crucially, the target code is *from the same GPAC framework*. It shares the same codebase, utility functions (e.g., memory allocation, parsing patterns), and attack surface (parsing untrusted media streams). The vulnerability pattern (insufficient bounds checking during parsing) is highly relevant to the provided `mpgviddmx_process` function, which extensively parses start codes, frame sizes, and copies data based on parsed values. The main difference is the specific subsystem (video demuxer vs. binary utility).",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-5813 is an infinite loop in a RAW image parser due to flawed offset validation. The target code contains several loops (`while (remain)` and internal parsing loops via `gf_m4v_parse_frame`). It also uses offsets (`byte_offset`, `ctx->resume_from`). While infinite loops are a potential risk in any parser, the specific trigger (malicious metadata causing endless tag processing) is not analogous to the MPEG video start code parsing logic shown. The domains are different (image metadata vs. video elementary stream).",
        "case_metadata": {
          "cve_id": "CVE-2018-5813"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20337 is an out-of-bounds write in a camera makernote parser due to insufficient bounds checking on string data. The target code performs bounds-checked copies (e.g., `assert(remain>=size)` before `start += size`) and uses `memcpy`. The relevance stems from the general pattern of parsing untrusted file data and writing to buffers. However, the specific flaw (string handling without length checks) is not prominent in the provided code, which deals with binary video frames, not text strings.",
        "case_metadata": {
          "cve_id": "CVE-2018-20337"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-20760 is an out-of-bounds write in GPAC's text import module due to improper error handling and unsafe buffer copy. This shares the **same GPAC framework** as the target code. The vulnerability pattern (missing validation of return codes/conditions leading to unsafe memory operations) is highly relevant. The target code shows similar patterns: it checks `e == GF_EOS` and `e != GF_OK` after parser calls, but other error paths or unchecked arithmetic could exist. The shared codebase and the focus on parsing untrusted input make this a relevant reference case, though the specific module (text import vs. video demuxer) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2021-40575_after_exclude_100:0cdc46b3:vulspec": {
    "timestamp": "2026-01-16T21:28:13.751544",
    "cve_id": "CVE-2021-40575",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0cdc46b3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability in a network service discovery daemon (MiniSSDPd). The target code is a multimedia demuxer (MPEG video) in GPAC, focusing on parsing video frames and managing packets. The domains (network service vs. media parsing), vulnerability patterns (memory management errors vs. parsing logic), and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow in OpenJPEG due to insufficient padding allocation. The target code also performs memory allocation (gf_realloc) and buffer copies (memcpy) based on parsed sizes. However, the vulnerability root cause is different: OpenJPEG's is a precise calculation error for coder padding, while the target code's risk is more generic (e.g., integer overflows in size calculations before gf_realloc or memcpy). The domain (image codec vs. video demuxer) is also different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 is an out-of-bounds write in LibVNC due to integer overflow in allocation size calculation. The target code contains multiple places where integer overflows could occur (e.g., `ctx->hdr_store_size + pck_size`, `size` calculations from parser) leading to undersized allocations and subsequent buffer overflows in memcpy. The pattern is similar, but the specific context (file transfer vs. video packet aggregation) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-12982 is a memory allocation failure/DoS in OpenJPEG due to unchecked header values. The target code does check some parsed values (e.g., `remain` checks) but also has potential for unchecked large allocations (e.g., via `gf_realloc` based on `pck_size`). The core issue (untrusted input leading to resource exhaustion) is a weak similarity, but the specific vulnerability mechanism and domain are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write in LibVNCServer due to unaligned memory access during WebSocket unmasking. The target code performs byte-aligned memory operations (memcpy, array indexing) and does not involve word-sized operations on potentially unaligned data. The vulnerability pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-13219 is an integer overflow in an audio codec (stb_vorbis) during mathematical computations for codebook setup. The target code involves numerous integer operations on parsed or calculated values (e.g., `size`, `current`, `remain`, `ctx->hdr_store_size + pck_size`). While the specific computation differs, the pattern of parsing untrusted input (video bitstream) and performing arithmetic without sufficient overflow checks is a relevant similarity. Both are in the multimedia parsing domain.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2019-11222 is an out-of-bounds write in GPAC itself (the same framework as the target code) in a binary data parsing function (`gf_bin128_parse`). The target code is also within GPAC and shares the same codebase patterns and utilities (e.g., `gf_filter_pck_new_alloc`, `gf_realloc`). The vulnerability pattern (parsing untrusted input leading to OOB write) is highly similar. The specific subsystem differs (general utility vs. video demuxer), but the context and potential for similar memory safety bugs is significant.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-5813 is an infinite loop in LibRaw due to improper offset validation in a makernote parser. The target code has loops but includes break conditions based on `remain`. While a malformed stream could theoretically cause issues, the specific flaw (flawed fseek/loop condition) is not directly mirrored. The domains (image metadata vs. video elementary stream parsing) are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5813"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20337 is an out-of-bounds write in LibRaw due to insufficient bounds checking in string processing. The target code performs bounds checking (e.g., `assert(remain>=size)`, `if (remain<5)`) but these are often assertions (which may be disabled in release builds) or checks that could be circumvented by integer overflows earlier in the logic. The pattern of writing data based on parsed lengths is similar, but the implementation context differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20337"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2018-20760 is an out-of-bounds write in GPAC (the same framework) in a text import function due to improper error handling and buffer management. The target code is in the same GPAC framework, uses similar utility functions, and has complex error paths and state management (e.g., `ctx->resume_from`, `ctx->hdr_store_size`). The pattern of managing internal buffers (`ctx->hdr_store`) based on parsed stream data and copying data between them creates a very similar attack surface for memory corruption vulnerabilities. The specific module differs, but the architectural patterns and risk factors are highly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2022-1620_before_exclude_100:d1c4f390:vulspec": {
    "timestamp": "2026-01-16T21:28:17.240166",
    "cve_id": "CVE-2022-1620",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d1c4f390",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve regular expression processing (vim_regexec vs. Perl regex engine), but the vulnerability types differ significantly. CVE-2018-18313 is an out-of-bounds read in regex pattern compilation due to NUL byte handling. The target code uses a compiled regex for matching filenames; its primary risk would be in the regex execution (e.g., ReDoS) or in the regex compilation (not shown), not a direct match to the specific OOB read in Perl's regcomp.c.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code performs local filename matching with regex. There is no similarity in functionality (network protocol vs. string matching), vulnerability type (OOB write vs. potential regex issues), or attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to improper bounds checking on end tags. The target code involves regex matching on strings. While both involve parsing/processing input, the domains (XML vs. regex), data structures, and specific vulnerability mechanisms (tag parsing state vs. regex engine behavior) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition in the Linux kernel's memory policy subsystem. The target code is a simple, synchronous user-space function for filename matching with no dynamic memory allocation (except for `home_replace_save` which is properly freed) and no concurrency. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's error path due to uninitialized pointers and inconsistent state cleanup. The target code has straightforward error handling with no complex state management. The memory operations are simple alloc/free pairs. No similarity in context or flaw pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8925 is an improper resource shutdown (reference count leak) in a Linux kernel USB serial driver. The target code is a user-space utility function. While both may involve resource cleanup (`vim_free`), the scale, context (kernel driver lifecycle vs. single function call), and flaw type are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2015-0241 is a buffer over-read/overflow in a numeric-to-string formatting function. The target code uses regex matching. The only tangential similarity is that both process input strings. The vulnerability root cause (lack of bounds checking during format conversion) is not present in the shown code, which delegates bounds-checking to `vim_regexec`.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2's character encoding processing. The target code uses regex on strings. Both are parsers of a sort, but the vulnerability mechanism (multi-byte character buffer management) is specific to XML/HTML encoding and not applicable to the regex matching logic shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-8924 is an integer underflow in a USB driver leading to information disclosure. The target code performs arithmetic-free string matching. There is no integer manipulation or hardware data handling in the target code that could lead to a similar flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-8924"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in the Linux kernel key management subsystem. The target code has no authentication, authorization, or permission checks. It is a pure string utility function. No conceptual or technical overlap.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      }
    ]
  },
  "CVE-2022-1620_after_exclude_100:a6a0a37b:vulspec": {
    "timestamp": "2026-01-16T21:28:20.183207",
    "cve_id": "CVE-2022-1620",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a6a0a37b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve regular expression processing (vim_regexec vs. Perl regex engine), but the vulnerability types differ significantly. CVE-2018-18313 is an out-of-bounds read due to embedded NUL bytes in the pattern during compilation. The target code uses a pre-compiled regex (rmp->regprog) for matching, focusing on case sensitivity and path substitution, not on parsing/compiling malicious patterns. The attack surface (regex pattern input) is similar, but the specific flaw and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code performs simple string matching and path substitution with no network protocol handling, integer arithmetic, or dynamic memory allocation based on untrusted size fields. The domains (remote desktop vs. local file path matching) and vulnerability patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to improper bounds checking on end tags. The target code is a simple filename matching function using regex. Both may involve string processing, but the vulnerability mechanism (parser state exploitation), data format (structured XML vs. simple strings/paths), and system context (parsing library vs. editor utility function) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition in Linux kernel memory policy management. The target code is a simple, synchronous user-space function with no dynamic memory allocation/deallocation, no locking, and no concurrency. The vulnerability class (memory corruption via race) and environment (kernel vs. application code) are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon related to error handling and resource cleanup. The target code has no network components, no complex resource lifecycle management (just a simple vim_free), and no analogous error path that could leave pointers in an inconsistent state. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-8925 is an improper resource shutdown (reference count leak) in a Linux kernel USB driver. The target code is a user-space helper function with no reference counting, no device driver logic, and a trivial resource cleanup pattern (vim_free). The system context and vulnerability mechanism are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2015-0241 is a buffer over-read/overflow in a numeric-to-string formatting function. The target code also performs string operations (regex matching, path substitution). Both involve processing user-provided data (format template vs. filename) and calling functions that may have internal buffer handling issues (vim_regexec, home_replace_save). However, the specific flaw (lack of input size checking in a formatting engine) and the data types (numeric formatting vs. path matching) are different. There is a tangential similarity in the \"string processing with potential for boundary issues\" category.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML/HTML parser due to improper buffer management during multi-byte character encoding processing. The target code does not parse structured documents, does not handle character encodings directly, and uses higher-level regex and string functions. The vulnerability patterns and attack surfaces are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-8924 is an integer underflow in a USB driver leading to information disclosure. The target code contains no arithmetic operations on lengths or indices, no USB/device I/O, and no kernel memory exposure risks. The contexts and vulnerability mechanisms are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-8924"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in the Linux kernel key management subsystem. The target code performs no authorization checks, manages no security tokens or keys, and operates entirely in user space without privilege boundaries. The security domain and flaw type are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      }
    ]
  },
  "CVE-2021-41210_before_exclude_100:763d1061:vulspec": {
    "timestamp": "2026-01-16T21:28:21.296974",
    "cve_id": "CVE-2021-41210",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "763d1061",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a shape inference function in a tensor computation library (likely TensorFlow). It deals with dimension calculation and output shape specification. VulSpec Case 1 (CVE-2016-7972) involves memory management errors in a subtitle rendering library due to inconsistent state tracking. The domain (multimedia vs. tensor computation), vulnerability type (resource management vs. shape logic), and code patterns are fundamentally different. The only weak similarity is the handling of abstract dimensions (\"nvals\"), but this is not related to memory allocation failures.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code performs static shape inference. VulSpec Case 2 (CVE-2018-18313) is an out-of-bounds read in a Perl regex compiler due to improper NUL byte handling in string parsing. The domains (compiler/parser vs. shape function), vulnerability types (buffer over-read vs. no apparent vulnerability), and code operations (string processing vs. dimension setting) are completely unrelated. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "The target code is a simple, deterministic shape function with no cryptographic operations, secret data, or loops with secret-dependent branches. VulSpec Case 3 (CVE-2015-7511) is a side-channel vulnerability in a cryptographic library's elliptic curve multiplication. The domains and vulnerability concepts (information exposure via physical channels) have zero relevance to the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code allocates no dynamic memory and manages no pointers; it works with dimension handles. VulSpec Case 4 (CVE-2016-3179) is a Use-After-Free in a network daemon involving error handling and cleanup of allocated structures. The vulnerability mechanism and code patterns are not present in the target code. The weak similarity is \"state management,\" but the target code's state is trivial and non-persistent.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not read from buffers or parse external data formats. VulSpec Case 6 (CVE-2017-17787) is an out-of-bounds read in an image file parser due to improper string termination checks. The domains and vulnerability patterns are unrelated. The target code's manipulation of dimension objects bears no resemblance to parsing file metadata.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "The target code is part of a graph inference or compilation phase. VulSpec Case 7 (CVE-2019-10128) is an access control flaw in a database query planner. The weak relevance is that both involve a \"planner\" or \"inference\" component making decisions based on input. However, the vulnerability type (privilege escalation) and code patterns (privilege checks vs. shape math) are vastly different. Minimal reference value.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code has no dynamic memory management, pointer operations, or parser state. VulSpec Case 8 (CVE-2016-1835) is a Use-After-Free in an XML parser during attribute processing. The mechanisms and code structures are completely dissimilar. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Similar to Case 5. VulSpec Case 9 (CVE-2009-3909) is an Integer Overflow leading to a Buffer Overflow during image dimension calculation. The parallel is clear: both involve calculating sizes based on input parameters (image dimensions vs. tensor dimensions). The target code's `c->Matrix(nvals, rank)` could lead to an overflow in downstream code that uses these dimensions to allocate memory. The relevance is moderate because the vulnerability *pattern* (integer overflow in size calculation) is similar, even if the immediate code doesn't show the overflow or subsequent allocation.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not parse strings or copy data into buffers. VulSpec Case 10 (CVE-2016-7837) is a stack buffer overflow in a configuration line parser. The operations (hex string parsing vs. dimension setting) and vulnerability types are unrelated. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      }
    ]
  },
  "CVE-2021-41210_after_exclude_100:95979c48:vulspec": {
    "timestamp": "2026-01-16T21:28:25.021907",
    "cve_id": "CVE-2021-41210",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "95979c48",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a shape inference function in a machine learning framework (likely TensorFlow), performing dimension calculations and setting output shapes. VulSpec Case 1 (CVE-2016-7972) involves memory management errors in a subtitle rendering library due to inconsistent state tracking. The domain (multimedia vs. ML framework), vulnerability type (resource management vs. shape logic), and code patterns are fundamentally different. The only weak similarity is the handling of internal data structures, but the attack surfaces and root causes are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "VulSpec Case 2 (CVE-2018-18313) is an out-of-bounds read in Perl's regex engine due to improper NUL byte handling. The target code performs safe dimension inference with no input parsing of untrusted strings, no buffer operations, and no regex processing. The vulnerability class (CWE-125) and attack surface (malicious input parsing) are completely unrelated to the shape function's mathematical calculations.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "VulSpec Case 3 (CVE-2015-7511) is a side-channel vulnerability in a cryptographic library's elliptic curve operations. The target code is a non-cryptographic, deterministic shape inference function with no secret-dependent branches or data, no timing-sensitive operations, and no low-level arithmetic prone to physical attacks. The domains (cryptography vs. ML shape inference) and vulnerability types (information exposure via side channels vs. logical validation) are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "VulSpec Case 4 (CVE-2016-3179) is a use-after-free in a network daemon due to uninitialized pointers and error handling issues. The target code shows no dynamic memory allocation, pointer manipulation, or error cleanup paths that could leave resources in an inconsistent state. While both involve internal state management, the target code's operations are purely on abstract shape handles, with no heap memory management. The vulnerability mechanism is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 6,
        "reasoning": "VulSpec Case 5 (CVE-2016-5844) involves an integer overflow when calculating file positions in an archive parser. The target code performs dimension calculations (c->Dim, c->UnknownDim()) and could potentially be vulnerable to integer overflows if input dimensions are maliciously large and used in unsafe arithmetic. However, the target code uses safe dimension handles (ShapeHandle) and library functions that may include bounds checking, unlike the direct unsafe calculations in the libarchive case. The similarity lies in the domain of parsing/calculating sizes from external input, but the implementation safety level differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "VulSpec Case 6 (CVE-2017-17787) is an out-of-bounds read in an image file parser due to improper string termination validation. The target code does not parse file data, read strings, or process external buffers. It operates on already-extracted tensor dimensions. The vulnerability pattern (buffer over-read) and attack surface (malicious file format) are not relevant to the abstract shape inference logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "VulSpec Case 7 (CVE-2019-10128) is an improper access control vulnerability in a database query planner. The target code also resides in a \"planner\" component (shape inference for graph operations) and could theoretically have security implications if shape inference bypasses validation (e.g., influencing memory allocation). However, the vulnerability mechanism (privilege checks on system catalogs) is specific to database security models. The weak relevance is that both involve planner/optimizer components making decisions based on input metadata.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 2,
        "reasoning": "VulSpec Case 8 (CVE-2016-1835) is a use-after-free in an XML parser due to inconsistent memory management during attribute processing. The target code shows no manual memory management, pointer aliasing, or parser state transitions that could lead to dangling references. The shape inference functions likely work with managed objects. The vulnerability pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "VulSpec Case 9 (CVE-2009-3909) is an integer overflow in an image header parser leading to a buffer overflow. Similar to Case 5, the target code involves dimension calculations (c->Dim, c->Matrix) from input tensors. If an attacker controls the input tensor's shape (e.g., via a malicious model), large dimensions could cause integer overflows in subsequent memory allocations, though the target code itself only sets abstract shapes. The relevance is moderate because both involve parsing external data (tensor shapes / image headers) and calculating sizes, but the immediate vulnerability conversion point differs.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "VulSpec Case 10 (CVE-2016-7837) is a stack buffer overflow in a Bluetooth configuration parser due to unsafe hex string conversion. The target code does not parse strings, use stack buffers, or perform low-level data conversion. It works with pre-parsed integer dimensions. The vulnerability pattern and attack surface are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      }
    ]
  },
  "CVE-2021-4043_after_exclude_100:c7a12f6c:vulspec": {
    "timestamp": "2026-01-16T21:28:27.564623",
    "cve_id": "CVE-2021-4043",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c7a12f6c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The target code is a cleanup function that frees allocated memory. CVE-2016-3179 involves a Use After Free vulnerability triggered by complex error handling and uninitialized pointers. While both deal with memory management, the target code's pattern is a straightforward, careful deallocation loop, whereas the CVE case involves more intricate state corruption leading to use-after-free. The similarity is weak.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1838 is an Out-of-bounds Read in an XML parser. The target code performs memory deallocation and does not involve parsing, reading, or bounds checking of external data. The vulnerability types and code patterns are fundamentally different. Relevance is very low.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 7,
        "reasoning": "CVE-2011-1003 is a Double Free vulnerability. The target code is a cleanup function that iterates through an array of structures, freeing nested `name` fields before freeing the array itself, and then frees the container. This pattern is precisely the kind of careful cleanup needed to *avoid* double-free or use-after-free errors. The code structure is highly relevant for understanding correct patterns to prevent such vulnerabilities, even though the target code itself is not vulnerable. It provides a valuable reference for safe deallocation of similar data structures.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-8925 is an Improper Resource Shutdown/Release (reference count leak) in a kernel driver. The target code correctly releases memory resources (gf_free). Both involve resource cleanup, but the contexts are vastly different: user-space library memory vs. kernel driver reference counting. The core issue of ensuring all allocated resources are freed is similar, but the mechanisms and consequences differ significantly. Relevance is weak to moderate.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 1,
        "reasoning": "CVE-2017-17807 is a Missing Authorization vulnerability in a kernel keyring subsystem. The target code has no authorization, permission checks, or security context. The domains and vulnerability classes are completely unrelated. Relevance is essentially none.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-18313 is an Out-of-bounds Read in a regex compiler due to improper NUL byte handling. The target code does not read or parse input data; it only deallocates memory. No similarity in vulnerability type or code pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-9227 is an Out-of-bounds Read in a regex library due to invalid pointer calculations. The target code performs no arithmetic on pointers beyond array iteration with a counter (`i`). The vulnerability types are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9227"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-9229 is a NULL Pointer Dereference. The target code includes a NULL check for `ptr` at the beginning, demonstrating defensive programming against this exact issue. However, the CVE's root cause involves complex state corruption in a regex engine, while the target code's check is simple and standard. There is a superficial similarity in checking for NULL, but the contexts and complexity are not comparable. Relevance is low.",
        "case_metadata": {
          "cve_id": "CVE-2017-9229"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2020-16305 is an Out-of-bounds Write in a graphics driver due to incorrect order of boundary checks. The target code writes nothing; it only frees memory. No meaningful similarity exists.",
        "case_metadata": {
          "cve_id": "CVE-2020-16305"
        }
      }
    ]
  },
  "CVE-2021-4043_before_exclude_100:d448c207:vulspec": {
    "timestamp": "2026-01-16T21:28:29.087108",
    "cve_id": "CVE-2021-4043",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d448c207",
    "scores": [
      {
        "score": 4,
        "reasoning": "The target code is a cleanup function that frees allocated memory. CVE-2016-3179 involves a Use After Free vulnerability in a network daemon's error handling path. The connection is weak: both involve memory management, but the context (network service vs. multimedia box cleanup), vulnerability type (use-after-free triggered by error vs. double-free prevention), and attack surfaces are fundamentally different. The target code shows defensive checks (NULL check) and a loop to free nested resources, which is a robust pattern, not a vulnerable one.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2016-1838 is an Out-of-bounds Read in an XML parser due to insufficient bounds checking. The target code performs memory deallocation with no array indexing or buffer reads beyond the bounds of allocated memory. The operations and vulnerability class are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-11222 is an Out-of-bounds Write in a binary data parsing function due to insufficient input validation. The target code is a destructor function that only frees memory and does not parse any input or perform any writes to memory. The functionality and flaw are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2011-1003 is a Double Free vulnerability in an antivirus file parser. The target code is specifically designed to prevent double-free issues by checking `if (ptr->entries)` before freeing it. The relevance lies in the shared domain of careful resource cleanup in parsers/processing code. The target code exemplifies the correct pattern to avoid the double-free flaw present in the VulSpec case, making it a valuable reference for secure deallocation of structured data.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-8925 is an Improper Resource Shutdown (reference count leak) in a kernel driver. The target code demonstrates proper resource shutdown for a multimedia data structure. While the context is different (user-space library vs. kernel driver), the core concept of ensuring all allocated resources (strings, array, container) are correctly released is similar. The target code serves as a good example of comprehensive cleanup.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-17807 is a Missing Authorization vulnerability in a kernel key management subsystem. The target code performs memory deallocation with no authorization, permission checks, or security context involved. The domains and vulnerability types are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is an Out-of-bounds Read in a regex compiler due to improper NUL byte handling. The target code does not read or parse data; it only frees previously allocated memory. There is no functional overlap.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-9227 is an Out-of-bounds Read in a regex library during pattern matching. The target code contains no pattern matching, string scanning, or buffer reading logic. The operations are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9227"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-9229 is a NULL Pointer Dereference in a regex library. The target code explicitly guards against NULL pointer dereference with `if (ptr == NULL) return;`. It is an example of correct defensive programming against the type of flaw in this case, but the functional contexts are completely different (memory cleanup vs. pattern matching execution).",
        "case_metadata": {
          "cve_id": "CVE-2017-9229"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2020-16305 is an Out-of-bounds Write in a graphics device driver due to incorrect order of boundary checks during compression. The target code performs no compression, no boundary checks on writes, and does not process any input data. The vulnerability mechanism and code purpose are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2020-16305"
        }
      }
    ]
  },
  "CVE-2022-2453_before_exclude_100:4d8e051f:vulspec": {
    "timestamp": "2026-01-16T21:28:29.958195",
    "cve_id": "CVE-2022-2453",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4d8e051f",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 (CWE-416 Use After Free) in MiniSSDPd involves uninitialized pointers and double-free during error handling in a network service. The target code is a BIFS decoder handling node registration and quantization parameters. While both involve memory management, the vulnerability patterns (use-after-free vs. potential logic/state errors), domains (network daemon vs. media codec), and trigger conditions are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 (CWE-119 Buffer Overflow) in OpenJPEG involves a heap buffer overflow due to insufficient padding calculation during image encoding. The target code reads a variable number of fields but uses safe allocation via `gf_sg_vrml_mf_alloc` and does not show obvious arithmetic overflow or direct buffer writes. The domains (image codec vs. scene graph decoder) and vulnerability mechanisms differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 (CWE-787 Out-of-bounds Write via integer overflow) in LibVNC involves a file transfer size calculation flaw. The target code reads `NbBits` and `nbFields` from a bitstream without obvious integer overflow checks before allocation. While the pattern of reading an untrusted size and allocating is similar, the target uses library allocation functions which may have bounds checking. The attack surfaces (network file transfer vs. parsed bitstream) differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 (CWE-119 via allocation failure) in OpenJPEG involves unchecked header values leading to oversized allocation. The target code reads `nbFields` from the bitstream and passes it to `gf_sg_vrml_mf_alloc`. If `nbFields` is excessively large, it could cause allocation failure or excessive memory consumption, but this is a resource exhaustion issue rather than a direct buffer overflow. The vulnerability patterns are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 (CWE-125 Out-of-bounds Read) in tcpdump involves insufficient validation of a TLV length field leading to reading beyond buffer bounds. The target code does not parse TLVs or perform similar length-field validation before reading. Its primary operations are node creation and list management. The domains (network packet parsing vs. scene graph decoding) and vulnerability types are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 (CWE-20 Improper Input Validation) in tcpdump involves missing bounds checks in LMP subobject parsing. The target code reads a count (`nbFields`) but does not validate it against any maximum before the loop. However, the context is different: the count is used for allocation and iteration, not direct packet data access. The vulnerability pattern is only superficially similar (missing validation on an untrusted integer).",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 (CWE-190 Integer Overflow leading to CWE-787) in Unbound involves an integer overflow in domain length calculation. The target code reads `NbBits` (5 bits, so max 31) and then reads `nbFields` using that bit width. If `NbBits` is 31, `nbFields` could be up to ~2 billion, potentially causing an integer overflow in subsequent calculations or allocation size. This is a plausible similar pattern, though not explicitly shown in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CWE-125 Out-of-bounds Read) in Perl's regex engine involves embedded NUL bytes causing over-reads. The target code does not process string data in a way that would be affected by NUL bytes; it reads structured binary data from a bitstream. The vulnerability patterns and data types are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 (CWE-20 Improper Input Validation leading to CWE-787) in ClamAV involves decompression logic failing to validate match offsets against window boundaries. The target code does not implement a decompression algorithm with a sliding window. While both involve parsing untrusted data, the specific vulnerability mechanism (boundary check bypass in LZ77-style decompression) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 (CWE-787 Out-of-bounds Write due to alignment issues) in LibVNCServer involves unaligned memory access during WebSocket frame unmasking. The target code does not perform word-sized operations on potentially unaligned network data. Its operations are primarily node manipulation and list management. The vulnerability root cause (alignment assumption) is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      }
    ]
  },
  "CVE-2022-2453_after_exclude_100:2958a6e3:vulspec": {
    "timestamp": "2026-01-16T21:28:31.189192",
    "cve_id": "CVE-2022-2453",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2958a6e3",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3179 is a Use-After-Free in a network daemon's service registration. The target code is a BIFS decoder handling node registration and quantization parameters. While both involve memory management and error paths, the domain (graphics decoding vs. network discovery), vulnerability pattern (UAF vs. potential logic/state errors), and code constructs are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to insufficient padding in an image codec. The target code parses a bitstream and manages node lists. Both parse structured input, but the vulnerability mechanism (allocation size miscalculation leading to overflow) is not present in the target code, which uses safe allocation via `gf_sg_vrml_mf_alloc` and does not perform raw buffer writes.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 is an out-of-bounds write from integer overflow in a file transfer protocol. The target code reads a variable-length field (`NbBits`, `nbFields`) which could theoretically overflow if `NbBits` is large, but the code uses `gf_bs_read_int` which likely has internal bounds. The similarity is in parsing untrusted input sizes, but the specific integer overflow -> allocation -> OOB write chain is not evident here.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-12982 is a buffer overflow from unchecked header values in an image converter. The target code reads a count (`nbFields`) but does not validate it against resource limits before allocation (potential DoS). However, the primary flaw in CVE-2017-12982 is a direct allocation size miscalculation, while the target code's risk is more about uncontrolled allocation size rather than a buffer overflow during subsequent writes.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code is a decoder for a structured graphics format, but it does not exhibit similar pattern of parsing TLV-like structures with external length fields that are used to read data without proper bounds checking. The data reading is done via structured functions (`gf_bifs_dec_sf_field`, `gf_bifs_dec_node`).",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-15166 is an input validation flaw in a network protocol parser leading to potential memory corruption. The target code lacks robust validation on `nbFields` (could be very large), which is a form of CWE-20. However, the context and data structures are completely different (network packet subobjects vs. scene graph node lists). The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-25034 is an integer overflow leading to out-of-bounds write in DNS parsing. The target code reads `NbBits` (5 bits) then reads `nbFields` using that bit width. If `NbBits` can be 31, `nbFields` could be up to ~2 billion, causing extreme allocation (DoS/CWE-770). This resembles an integer overflow risk in the *allocation size calculation* internal to `gf_sg_vrml_mf_alloc`, though not directly shown. The pattern of reading an untrusted size that influences allocation is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code deals with bitstreams and node registration, with no string parsing or character class processing. No meaningful similarity in vulnerability pattern or code constructs.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2010-1311 is an input validation flaw in a decompression module leading to out-of-bounds write. The target code does not implement a compression/decompression algorithm. The only tangential similarity is that both process encoded/compressed data from an untrusted source, but the mechanisms and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2019-20840 is an out-of-bounds write due to alignment issues in WebSocket unmasking. The target code does not perform low-level byte masking or alignment-sensitive memory operations. Both handle encoded data streams, but the vulnerability root cause (alignment assumption) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      }
    ]
  },
  "CVE-2022-1289_before_exclude_100:68b960a5:vulspec": {
    "timestamp": "2026-01-16T21:28:34.975952",
    "cve_id": "CVE-2022-1289",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "68b960a5",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a GUI rendering function for a music tracker pattern editor. It handles UI layout, color selection, and user interaction. CVE-2019-13219 is an integer overflow in an audio codec's mathematical computation for codebook handling. The domains (GUI vs. audio decoding), vulnerability types (no integer overflow seen in target), and code patterns are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code performs UI drawing and event handling with no dynamic memory allocation, pointer manipulation, or network/socket communication. CVE-2016-3179 is a Use-After-Free in a network daemon's service registration logic involving complex state cleanup. The functional contexts and vulnerability mechanisms are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code contains no regular expression compilation, character class processing, or state machine for text patterns. CVE-2017-9226 is an out-of-bounds write in a regex library's octal escape sequence processing. The code domains (GUI rendering vs. text parsing) and vulnerability triggers are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code has no network protocol handling, file transfer logic, or integer overflow in allocation calculations. CVE-2018-20750 is an integer overflow leading to heap corruption in a VNC server's file transfer module. The target code's integer operations (e.g., for indices) are bounded by earlier checks (ord, i, patLen). No relevant parallel.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not handle WebSocket frames, network data unmasking, or low-level memory operations with alignment concerns. CVE-2019-20840 is an out-of-bounds write due to unaligned memory access in a WebSocket decoder. The target code's operations are high-level UI calls with no similar memory layout risks.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 3,
        "reasoning": "Very weak relevance. Both involve processing formatted data for display (IRC colors vs. music pattern data). However, the vulnerability mechanism differs significantly: CVE-2012-5854 is a heap buffer overflow due to unsafe string concatenation in a dynamic buffer. The target code uses fixed-size `sprintf` into a 32-byte stack buffer (`id`). While both format strings, the target's buffer is small but used with controlled inputs (indices, note names). The risk profile and context (chat client vs. music editor GUI) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code is a single-threaded UI rendering function with no concurrent data structure manipulation, node ID management, or filesystem operations. CVE-2017-18249 is a race condition in a kernel filesystem's node allocator. No relevance in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code reads from internal pattern data structures (`pat->data[i][index]`) which are arrays with bounds checked earlier (via `patCache` and song limits). It does not parse external file formats or untrusted binary data. CVE-2017-17787 is an out-of-bounds read in an image file parser due to missing string termination checks. Different domains and trust boundaries.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not parse BMP headers, allocate memory based on file input, or convert image formats. CVE-2017-12982 is a memory allocation failure/overflow due to unchecked header values in a BMP converter. The target's operations are purely UI-related with no analogous header validation or allocation logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      }
    ]
  },
  "CVE-2022-1289_after_exclude_100:76c26c7d:vulspec": {
    "timestamp": "2026-01-16T21:28:42.834799",
    "cve_id": "CVE-2022-1289",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "76c26c7d",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a GUI rendering function for a music tracker pattern editor. It handles UI layout, color selection, and user interaction. CVE-2019-13219 is an integer overflow in an audio codec's mathematical computation for codebook handling. The domains (GUI vs. audio decoding), vulnerability types (no integer overflow evident in target), and code patterns are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-3179 is a Use-After-Free in a network daemon's memory management during error handling. The target code performs deterministic GUI drawing with no dynamic memory allocation/deallocation, no network/socket handling, and no complex error paths that could leave dangling pointers. The contexts are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-14151 is a heap buffer overflow in an image codec due to insufficient padding allocation. The target code does not perform any image decoding or low-level buffer allocation. It uses ImGui for rendering and sprintf into a fixed-size 32-byte stack buffer (`id`). While there is a buffer (`id`), its use is simple and the overflow risk is minimal and of a different nature (string formatting vs. image data structure calculation). Weak similarity in the presence of a fixed buffer.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-9226 is an out-of-bounds write in a regex library due to improper validation of escape sequences. The target code uses `sprintf` to format strings into a fixed buffer. There is a potential for format string overflows if the `noteName` function or pattern data produces overly long strings, but the code does not process complex, untrusted grammars like regex. Some weak relevance regarding the risk of buffer overflow via unvalidated input formatting.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs arithmetic (e.g., `j32=j*32`, `chanVolMax` calculations) but these are on small, controlled indices and counts (channel numbers, volume values). There is no parsing of untrusted binary network data or associated large integer calculations that could wrap. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-20840 is an out-of-bounds write due to unaligned memory access in a WebSocket decoder. The target code is a GUI function with no network packet processing, bit-level manipulation, or assumptions about memory alignment. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2012-5854 is a heap buffer overflow in an IRC client due to unsafe string concatenation during color code decoding. The target code also processes formatted data (music pattern data) and builds strings using `sprintf` into a fixed buffer (`id`). The risk pattern is similar: formatting externally influenced data (note names, hex values) into a limited buffer without explicit length checks. The context (GUI vs. IRC) differs, but the core vulnerability pattern of unchecked string formatting is present. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-18249 is a race condition in a filesystem's node ID management. The target code is a single-threaded GUI rendering function with no concurrency, shared resource management, or lock-free algorithms. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-17787 is an out-of-bounds read in an image file parser due to improper string termination validation. The target code reads from pattern data arrays (`pat->data[i][index]`) but includes bounds checks earlier (`i<0 || i>=e->song.patLen`, `ord` checks). The risk of OOB read is mitigated. Weak similarity in reading from array structures, but the target shows more defensive checks.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-12982 is a memory allocation failure/DoS due to unchecked header values in a BMP-to-JPEG2000 converter. The target code does not parse file headers or perform memory allocation based on untrusted values. It does check array indices (`i`, `ord`, `pat->data[i][2]` against `e->song.insLen`). The similarity is only in the general concept of input validation, but the mechanisms and contexts are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      }
    ]
  },
  "CVE-2022-0943_after_exclude_100:261c012f:vulspec": {
    "timestamp": "2026-01-16T21:28:48.372857",
    "cve_id": "CVE-2022-0943",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "261c012f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a regex engine buffer over-read due to NUL byte handling. The target code is a spell-checking UI function in Vim that manipulates strings and buffers but does not parse regular expressions. The vulnerability type (CWE-125) and attack surface are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a Use-After-Free in a network daemon's memory management. The target code performs local string operations, memory allocation (`vim_strsave`, `alloc`), and cleanup (`vim_free`). While both involve memory management, the context (network service error handling vs. local editor function), vulnerability pattern, and trigger conditions are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in an XML parser due to multi-byte character handling. The target code processes single-byte character strings (`char_u`) with explicit length checks (e.g., `badlen > STRLEN(line) - curwin->w_cursor.col`). The domains (XML parsing vs. spell suggestion UI) and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is another libxml2 out-of-bounds read during end tag parsing. The target code does not parse structured markup languages. Its string operations are on known, editor-managed buffers. No relevance in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds write in an image rendering component due to incorrect position tracking. The target code performs in-memory string replacement for a spell correction. The operations (array index tracking for pixels vs. pointer arithmetic for text) and vulnerability class (CWE-787) are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference in a regex library's error handling path. The target code has extensive null checks (e.g., `if (line == NULL) goto skip;`) and does not expose a similar error state propagation pattern. The functional domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a heap buffer overflow in an IRC client due to unsafe string concatenation and buffer growth. The target code also performs string copying and concatenation (`vim_strncpy`, `STRCPY`, `STRCAT`) into fixed-size (`wcopy[MAXWLEN + 2]`) and dynamically allocated buffers. There is a superficial similarity in performing string assembly, but the target code uses bounded functions (`vim_strncpy`, `vim_snprintf`) and explicit length calculations, showing more caution. The vulnerability pattern (CWE-122) is not directly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds write due to integer overflow in a network protocol's memory allocation. The target code has one dynamic allocation (`p = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1)`) with a calculation that could theoretically overflow, but it operates on lengths derived from existing buffers, making it less likely. The context (remote file transfer vs. local text replacement) and attack surface are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a Use-After-Free in libxml2 related to buffer reallocation and stale dictionary pointers. The target code allocates and frees memory (`vim_strsave`/`vim_free`, `alloc` implied freed by `ml_replace`) but does not involve reallocation or shared dictionary structures. The memory management patterns are simple and local.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a NULL pointer dereference in a PDF interpreter due to unmatched stack operations. The target code manages no analogous stack structure. Its control flow is linear with error jumps (`goto skip`). No relevance in vulnerability pattern or code constructs.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      }
    ]
  },
  "CVE-2019-19071_before_exclude_100:26f6f9d4:vulspec": {
    "timestamp": "2026-01-16T21:28:53.089935",
    "cve_id": "CVE-2019-19071",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "26f6f9d4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Low relevance. Target code is a WiFi driver beacon preparation function. VulSpec describes a FUSE ioctl buffer overflow in the kernel's virtual filesystem layer. Different subsystems (networking/wireless vs. filesystem), different vulnerability patterns (no evident buffer overflow or ioctl handling in target code).",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Target code allocates an skb for a management frame. VulSpec describes an integer overflow leading to OOB write in a VNC server's file transfer. Different context (kernel driver vs. userspace library), different operations (skb allocation vs. memory allocation with flawed size calculation). The only weak similarity is memory allocation, but the vulnerability mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is a simple, sequential function to queue a beacon. VulSpec describes a race condition in F2FS filesystem node ID management. No concurrency or shared resource manipulation is evident in the target code. Different subsystems and vulnerability classes.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is for a WiFi driver. VulSpec describes a NULL pointer dereference in a USB serial driver due to missing endpoint validation. Different driver types, different hardware interfaces, and no USB descriptor parsing or similar validation logic in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code prepares and queues a network packet. VulSpec describes a NULL pointer dereference in the USB/IP network protocol stack due to invalid URB fields. While both involve networking concepts, the target code does not parse complex protocol structures from untrusted sources in a way that could lead to a NULL dereference of this nature.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Target code performs a straightforward skb allocation and queueing. VulSpec describes a Use-After-Free in a userspace SSDP daemon due to error path cleanup issues. Different environment (kernel vs. userspace), different resource (skb vs. generic memory), and no complex error paths or double-free patterns visible in the target function.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is a driver function with no concurrency or key management. VulSpec describes a race condition leading to NULL dereference in the kernel keyring subsystem. The target code shows no evidence of shared global state accessed without proper locking, which is the core of this VulSpec.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code manages a driver-specific TX queue. VulSpec describes a Use-After-Free in the kernel's NUMA memory policy due to a race condition and improper locking. Different subsystem (core memory management vs. network driver), and no shared resource locking or premature release patterns in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is a single-threaded beacon transmission path. VulSpec describes a race condition in the TTY subsystem between concurrent writers causing buffer overflow. The target code shows no buffer manipulation susceptible to concurrent access or similar synchronization issues.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The strongest weak similarity: both involve processing data to be sent over a network. However, the target code allocates a fixed-size skb (MAX_MGMT_PKT_SIZE) for a beacon, while the VulSpec describes unbounded memory allocation in USB/IP based on unvalidated network input. The vulnerability mechanism (missing validation leading to excessive allocation) is not present in the simple, constant-size allocation of the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      }
    ]
  },
  "CVE-2022-0943_before_exclude_100:6959df83:vulspec": {
    "timestamp": "2026-01-16T21:28:55.707725",
    "cve_id": "CVE-2022-0943",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6959df83",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a spell suggestion function in Vim, handling string manipulation and user interaction. CVE-2018-18313 is a regex compilation vulnerability in Perl involving out-of-bounds reads due to NUL byte handling. The domains (text editor UI vs. regex engine), vulnerability types (no clear buffer over-read in target), and code patterns (string copying with explicit lengths vs. complex regex parsing) are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-3179 is a Use-After-Free in a network daemon (MiniSSDPd). The target Vim code performs local spell checking with careful memory allocation/freeing (`vim_strsave`, `vim_free`, `spell_find_cleanup`). While both involve resource management, the context (network service error handling vs. local interactive function), attack surfaces, and root cause (complex state cleanup vs. straightforward linear flow) are dissimilar. Weak relevance at best.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1833 is an out-of-bounds read in libxml2's multi-byte character encoding parser. The target code uses string functions like `STRCPY`, `STRCAT`, and `vim_strncpy` with explicit length calculations (`MAXWLEN`). It processes single-byte/multi-byte characters via `MB_PTR_BACK/ADV` but within the context of a known line buffer. The vulnerability patterns (parser state corruption vs. bounded string manipulation) and domains are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1838 is another libxml2 out-of-bounds read during end tag parsing. The target code does not parse a hierarchical markup language; it manipulates a flat line buffer for spell replacement. The code patterns (XML tree traversal vs. linear string operations) and vulnerability triggers (malformed structure vs. bounded word substitution) are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2020-16304 is an out-of-bounds write in Ghostscript's image rendering due to incorrect position tracking. The target code has one buffer write via `ml_replace` after careful length calculation (`alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1)`). The risk profile is different (complex image rasterization vs. single-line text replacement). Weak relevance due to the generic concept of buffer size calculation, but the context and flaw patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-16161 is a NULL pointer dereference in a regex library due to inconsistent error state handling. The target code has multiple error checks (e.g., `if (line == NULL) goto skip;`, `if (p != NULL)`), but they are straightforward. The potential similarity is in the pattern of checking function results and managing cleanup (`skip` label). However, the specific vulnerability mechanism (error code without state) is not present. Weak to moderate relevance due to shared defensive programming context.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2012-5854 is a heap buffer overflow in an IRC client due to unsafe string concatenation during dynamic buffer growth. The target code also performs string concatenation when building the replacement string (`p` allocation and `STRCPY`/`STRCAT`). It uses calculated lengths, but a subtle integer overflow or off-by-one in the `alloc` expression could theoretically lead to a buffer overflow. This provides a moderate reference for secure buffer size calculation patterns, though the target code's growth strategy is static, not dynamic.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-20750 is an out-of-bounds write due to integer overflow in a size calculation for a network protocol. The target code has a size calculation `STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1`. If `stp->st_orglen` were larger than `STRLEN(line)`, the subtraction could wrap to a large value, leading to undersized allocation. This is a plausible, though not identical, integer handling flaw. Weak relevance due to different domains, but the arithmetic pattern is a valid point of scrutiny.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-1836 is a Use-After-Free in libxml2 due to buffer reallocation invalidating stored pointers. The target code saves a pointer (`sug.su_badptr`) derived from `line`, but `line` is not reallocated after that point; it's freed at the end. The `repl_from`/`repl_to` are saved from this pointer but used after `line` is freed? No, they are used before `ml_replace` and `spell_find_cleanup`. The pattern of holding references into a buffer is similar, but without reallocation/free-before-use, the UAF risk is much lower. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-10218 is a NULL pointer dereference due to unbalanced stack operations in Ghostscript. The target code has no stack-like state machine. The only remote similarity is checking function results (like `u_save_cursor() == OK`) to avoid operating on bad states, which is generic good practice. Very weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      }
    ]
  },
  "CVE-2020-27828_before_exclude_100:4f4351cd:vulspec": {
    "timestamp": "2026-01-16T21:28:56.514953",
    "cve_id": "CVE-2020-27828",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4f4351cd",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is from a JPEG 2000 encoder (likely JasPer), handling image encoding parameters. CVE-2016-3179 is a Use-After-Free in a network service discovery daemon (MiniSSDPd). The domain (image processing vs. network service), vulnerability type (no clear UAF pattern in target code), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. CVE-2017-14151 is in OpenJPEG, another JPEG 2000 codec library. The target code is also from a JPEG 2000 encoder (JasPer). Both deal with core encoding parameters like precinct/code block dimensions, resolution levels, and memory allocation for encoding structures. The vulnerability context (CWE-119 buffer overflow in code block encoding) is directly applicable to the validation logic in the target function (e.g., checks on cblkwidthexpn, cblkheightexpn, maxrlvls). The code patterns for parameter parsing and validation are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-20750 is an integer overflow leading to OOB write in a VNC file transfer component. The target code performs arithmetic (e.g., JPC_CEILDIV, size calculations) but with careful use of uint_fast types and explicit checks (e.g., totalsize > rawsize). The primary vulnerability pattern (integer wrap in allocation) is not evident here, and the domains (image encoding vs. remote desktop protocol) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to NUL byte handling. The target code parses an option string but uses a token-value parser (jas_tvparser) and does not show similar pattern of raw string manipulation vulnerable to embedded NULs. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-13219 is an integer overflow in an audio codec's mathematical computations. The target code has integer calculations (e.g., hsteplcm *= ..., cp->numtiles = cp->numhtiles * cp->numvtiles) but uses unsigned integers and the values involved (image dimensions, steps) are bounded by image properties. There is no obvious unchecked multiplication leading to wrap-around. The domain similarity is low (image vs. audio codec).",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2010-1311 is an input validation flaw in a decompression module leading to buffer overflow. The target code validates many user-controlled parameters (from optstr) but is in an encoder initialization phase, not in the core compression/decompression loop. The pattern of failing to validate match offsets against a sliding window is not present.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2011-1003 is a double free in an antivirus document parser. The target code has a complex error handling path with multiple `goto error` statements that free resources (ilyrrates, tvp, cp). This pattern is similar to the error cleanup that can lead to double-free or use-after-free if state management is inconsistent. However, the target code appears to set pointers to NULL after destruction (tvp = 0) and checks before freeing (if (ilyrrates)), which mitigates the risk. The domain difference is significant.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20760 is an out-of-bounds write in a text encoding conversion utility. The target code does not perform string encoding conversions or buffer copies in a similar manner. Its string handling is limited to parsing numeric values from option strings via atoi/jpc_floorlog2.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code validates lengths/values (e.g., prcwidthexpn > 15, cblkwidthexpn bounds) but these are for internal encoding parameters, not parsed from untrusted network data. The pattern of parsing a TLV-like structure is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write due to alignment issues in a WebSocket decoder. The target code does not process network frames or perform byte-wise unmasking operations. There is no manipulation of word-aligned data from unaligned sources.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      }
    ]
  },
  "CVE-2020-27828_after_exclude_100:8302d9cf:vulspec": {
    "timestamp": "2026-01-16T21:28:57.780592",
    "cve_id": "CVE-2020-27828",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8302d9cf",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 (CVE-2016-3179) is a Use-After-Free in a network daemon's service registration logic. The target code is a JPEG 2000 encoder configuration parser with heavy input validation and structured cleanup via `goto error`. While both involve error handling, the vulnerability type (UAF vs. potential overflow/validation), domain (network service vs. image codec), and code patterns (pointer management vs. arithmetic validation) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 2 (CVE-2017-14151) is a heap buffer overflow in OpenJPEG's code block encoding due to insufficient padding allocation. The target code is from a JPEG 2000 encoder (likely JasPer), sharing the same domain and similar components (code block parameters: `cblkwidthexpn`, `cblkheightexpn`). Both involve validating encoder parameters (precinct size, code block size) to prevent memory corruption. The vulnerability pattern (insufficient validation leading to buffer overflow) and the functional context are nearly identical, providing highly valuable reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 (CVE-2018-20750) is an out-of-bounds write in LibVNC due to integer overflow in allocation size calculation. The target code performs arithmetic (e.g., `JPC_CEILDIV`) and validations on user-controlled inputs (tile dimensions, rates). While both involve validating integer inputs to prevent memory issues, the vulnerability trigger (integer overflow in `malloc` argument vs. arithmetic validation failures) and domain (network protocol vs. image encoding) differ significantly. Some reference value for input validation patterns exists.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 (CVE-2018-18313) is an out-of-bounds read in Perl's regex compiler due to improper NUL byte handling. The target code parses an option string but uses a structured TV parser (`jas_tvparser_*`) and does not involve complex string parsing with embedded NULs. The vulnerability type (buffer over-read vs. potential overflow/integer issues), domain (text processing vs. image encoding), and code patterns are fundamentally dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 (CVE-2019-13219) is an integer overflow in an audio codec's mathematical computations. The target code performs arithmetic operations on user-controlled values (e.g., `prcwidthexpn`, `cblkwidthexpn`, rate calculations) and includes checks for overflow/validity (e.g., `cblkwidthexpn + cblkheightexpn > 12`). While the domain differs (audio vs. image), the core vulnerability pattern (integer handling flaws in codec parameters) and the need for rigorous bounds checking are similar, providing moderate reference value.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 (CVE-2010-1311) is an improper input validation leading to buffer overflow in a decompression module. The target code is an encoder configuration parser, not a decompressor. Both involve parsing external input, but the vulnerability context (decompression state machine vs. parameter validation) and attack surface (compressed data stream vs. configuration options) differ. Some similarity exists in the general principle of validating inputs against logical constraints.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 (CVE-2011-1003) is a double free in an antivirus's document parser during error handling. The target code has a centralized error cleanup path (`goto error`) that frees resources conditionally, which is a robust pattern against double-free. The vulnerability type (double free vs. overflow/validation), domain (document parsing vs. image encoding), and error handling complexity are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 (CVE-2018-20760) is an out-of-bounds write in a text encoding conversion due to unhandled error codes. The target code uses `atoi` and similar functions on parsed strings but does not involve complex text encoding conversions or the same error code propagation issue. The vulnerability mechanism and domain are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 (CVE-2018-14461) is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code validates lengths and sizes (e.g., `maxrlvls > JPC_MAXRLVLS`, precinct dimensions) but does not parse TLV-like structures from a network packet. The general principle of validating attacker-controlled length fields against maximum allowed values is similar, but the implementation context is very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 (CVE-2019-20840) is an out-of-bounds write due to unaligned memory access in a WebSocket decoder. The target code performs no bit-level or unaligned memory operations; it deals with arithmetic validation and structure initialization. The vulnerability type and low-level memory manipulation patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      }
    ]
  },
  "CVE-2019-19071_after_exclude_100:a21117be:vulspec": {
    "timestamp": "2026-01-16T21:29:01.258248",
    "cve_id": "CVE-2019-19071",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a21117be",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in the Linux kernel FUSE subsystem due to improper iovec validation. The target code is a Wi-Fi driver beacon preparation function that allocates a fixed-size skb and performs simple alignment. The vulnerability type (buffer overflow vs. memory management), subsystem (filesystem vs. network driver), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a VNC server library's file transfer. The target code performs a simple skb allocation with a constant size (MAX_MGMT_PKT_SIZE) and alignment adjustment. There are no complex integer calculations, user-controlled size inputs, or file transfer logic that could lead to similar overflow conditions.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in the F2FS filesystem's node ID management. The target function `rsi_send_beacon` appears to be a straightforward, sequential function that allocates a buffer, prepares data, and queues it. There is no evidence of concurrent resource management, shared state, or lock operations that would be relevant to this race condition vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2016-3137 is a NULL pointer dereference in a USB serial driver due to missing endpoint validation. The target code does check for a NULL skb after `dev_alloc_skb()` and returns -ENOMEM. However, the context is entirely different (USB device driver initialization vs. network packet handling), and the specific trigger (malicious hardware descriptor) is not applicable. The shared concept of checking for allocation failure is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-16914 is a NULL pointer dereference in the USB/IP subsystem due to insufficient validation of URB fields. The target code validates the skb pointer after allocation. While both involve checking for NULL after a resource allocation, the vulnerability context (network protocol processing of USB requests vs. local beacon frame preparation) and the attack surface are vastly different. The similarity is only in the basic defensive programming pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a service daemon due to error handling and uninitialized state. The target code has a simple error path that frees the skb with `dev_kfree_skb(skb)` and returns. There is no complex state management or cleanup of partially allocated structures that could lead to a use-after-free in this snippet. The memory management patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-1792 is a race condition leading to a NULL pointer dereference in the kernel keyring subsystem during concurrent initialization. The target function shows no signs of managing shared global state or being susceptible to concurrent execution issues in the same way. It operates on local variables and a `common` struct, but the code pattern does not suggest a similar synchronization flaw.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition in the kernel's memory policy subsystem due to improper locking. The target code is a simple driver function with no visible lock operations, shared resource management, or complex lifecycle issues that could lead to a similar use-after-free scenario.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2014-0196 is a race condition in the TTY subsystem leading to buffer overflow from concurrent writers. The target code is not a line discipline handler, does not manage a buffer with concurrent writers, and shows no evidence of the synchronization flaws present in the TTY case. The functionality and attack surface are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-16913 is an unbounded memory allocation/integer overflow in the USB/IP network protocol handler due to missing validation of network-provided length fields. The target code allocates a fixed-size skb (MAX_MGMT_PKT_SIZE) and pulls a calculated alignment offset. There are no user/network-controlled inputs affecting allocation size, making the vulnerability pattern irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      }
    ]
  },
  "CVE-2019-16234_before_exclude_100:a64adb15:vulspec": {
    "timestamp": "2026-01-16T21:29:10.392325",
    "cve_id": "CVE-2019-16234",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a64adb15",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 involves a use-after-free in a network service daemon's local socket handling. The target code is a PCI device driver initialization function with different memory management patterns (alloc_percpu, pcim_* functions) and error handling paths. The vulnerability patterns and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2010-4650 is a buffer overflow in FUSE ioctl handling due to insufficient iovec validation. The target code performs PCI device initialization with DMA mask setup and resource mapping. While both involve kernel-level operations, the vulnerability mechanisms (buffer overflow vs. resource allocation errors) and code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer. The target code has integer calculations for address_size (36/64) but uses them with DMA_BIT_MASK. Both involve size calculations, but the vulnerability patterns (integer overflow in allocation vs. DMA mask configuration) and contexts differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-18249 is a race condition in F2FS nid management. The target code initializes spinlocks (irq_lock, reg_lock) and mutexes, indicating concurrency considerations. Both involve resource initialization and state management, but the specific race condition patterns (filesystem metadata vs. PCI device initialization) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow in JPEG 2000 encoding due to insufficient padding. The target code allocates memory (alloc_percpu) and handles DMA buffers. Both involve memory allocation, but the vulnerability mechanisms (padding calculation errors vs. PCI resource allocation) and domains are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2014-0196 is a race condition in TTY line discipline leading to buffer overflow. The target code initializes synchronization primitives (spinlocks, mutex) and workqueues. Both involve concurrency considerations in kernel code, but the specific vulnerability patterns (TTY buffer race vs. PCI initialization) differ substantially.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl regex compilation due to NUL byte handling. The target code is PCI device driver initialization with hardware register access. The domains (string parsing vs. hardware initialization) and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2010-1311 involves improper input validation in decompression leading to memory corruption. The target code validates hardware capabilities (DMA mask, PCI resources) but in a different context. Both involve validation logic, but the mechanisms (archive parsing vs. hardware capability checks) differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write in WebSocket decoding due to alignment issues. The target code performs PCI memory-mapped I/O and hardware register access. The domains (network protocol parsing vs. hardware initialization) and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-3603 involves improper error handling in privilege separation initialization. The target code has extensive error handling (multiple goto out_no_pci paths) during device initialization. Both involve initialization error paths, but the security implications (privilege escalation vs. driver initialization failure) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2017-13139_before_exclude_100:3cbe0dc4:vulspec": {
    "timestamp": "2026-01-16T21:29:10.895227",
    "cve_id": "CVE-2017-13139",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3cbe0dc4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-6198 is a Linux kernel VFS/overlayfs vulnerability involving improper access control and inode identity validation during rename operations. The target code is a user-space MNG image decoder in ImageMagick with no filesystem operations, rename logic, or similar access control patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-6198"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-19646 is an SQLite PRAGMA command vulnerability involving improper validation of exceptional conditions (NULL constraints on generated columns). The target code parses MNG chunks but does not involve database operations, constraint validation, or similar command processing patterns. Both parse structured data, but the domains and vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-19646"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-10199 is a use-after-free in mruby's File object copying due to improper ordering of operations. The target code allocates and frees memory (e.g., chunk buffers) but does not involve object copying semantics, file descriptor management, or similar lifecycle patterns. Both handle resources, but the vulnerability patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-10199"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2020-16298 is a buffer overflow in Ghostscript's color correction due to insufficient bounds checking on array indices. The target code includes multiple array accesses (e.g., mng_info arrays, chunk processing) and has some bounds checks (e.g., length validation), but the specific pattern of color table index calculation is not present. Both involve parsing binary formats and risk out-of-bounds accesses.",
        "case_metadata": {
          "cve_id": "CVE-2020-16298"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-20456 is an out-of-bounds read in radare2's x86 assembler due to insufficient bounds checking on register indices. The target code reads and processes binary chunk data with length checks, but does not involve assembly parsing or register index arrays. Both involve parsing binary/structured input and validating lengths to prevent out-of-bounds reads.",
        "case_metadata": {
          "cve_id": "CVE-2018-20456"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-0755 is an authentication bypass in curl's NTLM connection reuse due to improper credential validation. The target code is an image decoder with no network, authentication, or connection management logic. The vulnerability patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-0755"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2014-3591 is a side-channel information leak in libgcrypt's Elgamal due to lack of ciphertext blinding. The target code does not perform cryptographic operations, modular exponentiation, or side-channel mitigation. Both are security-sensitive libraries, but the vulnerability types are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2014-3591"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2018-1000879 is a NULL pointer dereference in libarchive's ACL parsing due to improper input validation of zero-length fields. The target code parses MNG chunks, validates lengths (e.g., checking length > PNG_UINT_31_MAX, length > 0 for certain chunks), and could potentially dereference NULL if validation fails (e.g., p pointer from chunk). Both involve parsing binary formats, validating input lengths, and avoiding NULL dereferences. The pattern of missing validation for edge-case lengths is similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000879"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2012-1013 is a NULL pointer dereference in Kerberos kadmin due to improper handling of exceptional conditions (missing password with DISALLOW_ALL_TIX). The target code includes error handling and validation (e.g., checking chunk lengths, throwing exceptions), but does not involve authentication protocols or principal management. Both have input validation and error paths, but the specific trigger conditions differ.",
        "case_metadata": {
          "cve_id": "CVE-2012-1013"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2017-9610 is an out-of-bounds read in Ghostscript's TTF name table parsing due to insufficient validation of font table offsets. The target code reads MNG chunk data with length checks and could have similar issues if offsets within chunks are not validated (e.g., p pointer arithmetic). Both parse binary formats with internal offsets and require bounds checking to prevent out-of-bounds reads.",
        "case_metadata": {
          "cve_id": "CVE-2017-9610"
        }
      }
    ]
  },
  "CVE-2019-16234_after_exclude_100:a6e8df1a:vulspec": {
    "timestamp": "2026-01-16T21:29:11.547102",
    "cve_id": "CVE-2019-16234",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a6e8df1a",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve resource allocation and error handling, but the vulnerability types differ significantly. CVE-2016-3179 is a Use-After-Free in a network service daemon triggered by local socket messages, while the target code is a PCIe device driver initialization function with different error cleanup patterns (goto chains). The attack surfaces and system domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in FUSE ioctl handling due to insufficient iovec validation. The target code performs PCI device initialization with DMA setup and interrupt handling, but doesn't involve similar user-controlled buffer operations or protocol parsing that could lead to buffer overflows. Different vulnerability class and attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code performs PCI device initialization with fixed-size allocations (alloc_percpu, alloc_workqueue) and doesn't process variable-length user data that could cause integer overflows. Different domain and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition in F2FS nid management. The target code has initialization-time resource allocation but doesn't show the same concurrent access patterns. However, both involve kernel resource management and error paths, but the race condition aspect isn't apparent in this single-threaded initialization function.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow in image codec allocation due to insufficient padding. The target code allocates fixed-size kernel structures (trans_pcie, workqueue, percpu data) without user-controlled size calculations. Different vulnerability pattern and domain (image processing vs. device driver).",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2014-0196 is a TTY race condition leading to buffer overflow. The target code has spinlocks (irq_lock, reg_lock) and mutex initialization, suggesting concurrency considerations, but the vulnerability pattern differs. Both are kernel code with synchronization primitives, but the attack surface and vulnerability mechanism are different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl regex parsing due to NUL byte handling. The target code is device driver initialization without string parsing or regex processing. Completely different vulnerability class and functionality.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2010-1311 is an input validation flaw in archive decompression leading to memory corruption. The target code validates PCI configuration and hardware revision but doesn't parse complex file formats or compressed data. Different attack surface and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-20840 is an out-of-bounds write in WebSocket decoding due to alignment issues. The target code performs PCI memory mapping and register access but doesn't involve network protocol parsing with alignment-sensitive operations. Different domain and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-3603 involves privilege management failure in a network daemon. The target code is a kernel driver without privilege separation concerns. However, both have initialization error handling paths where cleanup must be performed correctly, though the specific vulnerability (continuing with elevated privileges) doesn't apply to kernel code.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2022-21733_before_exclude_100:ab49d2a1:vulspec": {
    "timestamp": "2026-01-16T21:29:14.054260",
    "cve_id": "CVE-2022-21733",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ab49d2a1",
    "scores": [
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a TensorFlow string n-gram generator performing data validation and memory allocation. VulSpec describes a cryptographic side-channel vulnerability in libgcrypt. Different domains (ML vs crypto), different vulnerability types (no side channels in target), different attack surfaces.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code performs input validation and array indexing. VulSpec describes a cryptographic algorithm handling and NULL pointer dereference in BIND9 DNSSEC. Different systems, different vulnerability patterns (no crypto, no pointer dereference in target).",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both process input data, but target code uses TensorFlow's safe indexing and validation. VulSpec describes a stack buffer overflow in hex parsing. Target code operates on validated tensor indices, not raw string parsing. Different memory safety patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code reads from tensor arrays with bounds checking. VulSpec describes out-of-bounds read in file parsing. Both process data, but target uses container abstractions (tensors) with size checks, while VulSpec deals with raw buffer reads from files.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is computational kernel with no privilege or access control logic. VulSpec describes privilege escalation in PostgreSQL query planner. Completely different security domains (access control vs memory safety).",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. Target code is a pure computation function with no privilege separation or daemon logic. VulSpec describes privilege management failure in network daemon. Different system types and vulnerability classes.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve bounds validation of computed indices/positions. Target code validates split values against data_size, similar to validating file positions in archives. However, target uses simple inequality checks while VulSpec describes integer overflow in position calculation. Similar validation intent but different arithmetic risks.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code processes string tensors with explicit size tracking. VulSpec describes out-of-bounds read in regex parsing with NUL bytes. Both handle string data, but target uses length-delimited strings (tstring) rather than null-terminated, reducing similar risks.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both involve memory allocation and buffer management. Target code allocates output tensors based on calculated sizes. VulSpec describes heap buffer overflow in image encoding due to insufficient padding. However, target uses TensorFlow's allocation APIs which handle sizing, while VulSpec shows manual buffer calculation errors.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2017-13139_after_exclude_100:25ce6ac9:vulspec": {
    "timestamp": "2026-01-16T21:29:22.634273",
    "cve_id": "CVE-2017-13139",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "25ce6ac9",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is an MNG image decoder in ImageMagick, dealing with parsing chunked binary data. CVE-2016-6198 is a Linux kernel VFS/overlayfs vulnerability related to filesystem rename operations and inode identity management. The domain (user-space image parsing vs. kernel filesystem), vulnerability type (logic/state error vs. access control), and attack surface (binary file parsing vs. system call) are completely different. There is minimal relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-6198"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code parses MNG chunks and does not involve SQL database operations, PRAGMA commands, or constraint validation on generated columns. CVE-2019-19646 is specific to SQLite's query processing and integrity check logic. The functional domains and vulnerability patterns (parsing binary formats vs. evaluating database constraints) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-19646"
        }
      },
      {
        "score": 3,
        "reasoning": "Both involve parsing external data (MNG files vs. Ruby File objects), but the vulnerability types differ. CVE-2018-10199 is a use-after-free in an object copy operation within a language runtime. The target code has extensive memory management (AcquireQuantumMemory/RelinquishMagickMemory) but no obvious object copying with the same lifecycle flaw. The reference value is low, though both caution about proper resource management during complex parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-10199"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both are in the domain of parsing complex, externally-supplied file formats (MNG/PNG/JNG vs. PDF/PostScript/XPS) for rendering. CVE-2020-16298 is a buffer overflow in a color correction array index calculation. The target code performs many array/buffer operations (e.g., on `chunk`, `global_plte`, `global_trns`) and reads many length fields from the file. While no identical unchecked index calculation is obvious, the pattern of reading chunk data based on a `length` variable and then processing it with pointers (`p`) shares the risk of buffer overflows if length validation is insufficient (e.g., the check `if (length > PNG_UINT_31_MAX)` exists but others may be missing). This provides a valuable reference for auditing similar file parsers.",
        "case_metadata": {
          "cve_id": "CVE-2020-16298"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-20456 is an out-of-bounds read in an assembler parser due to insufficient bounds checking on register indices. The target code is also a parser (for MNG chunks) that reads structured binary data and uses array accesses (e.g., `mng_info->exists[object_id]`, `mng_info->x_off[object_id]`). It includes bounds checks for `object_id` (e.g., `if (object_id > MNG_MAX_OBJECTS)`), showing awareness of the issue. The similarity lies in the need to validate indices derived from untrusted input before array access. The reference is useful for reinforcing the importance of such checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-20456"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2016-0755 is an authentication bypass in an HTTP/NTLM connection reuse mechanism. The target code is a purely local image file decoder with no network, authentication, or connection state management. The vulnerability patterns and attack surfaces are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-0755"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2014-3591 is a cryptographic side-channel vulnerability in modular exponentiation. The target code performs image processing and has no cryptographic operations. The domains and vulnerability classes are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2014-3591"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2018-1000879 is a NULL pointer dereference in libarchive's ACL text parser due to improper handling of zero-length fields. The target code is also a complex parser that reads variable-length chunks from a file, allocates memory with `AcquireQuantumMemory`, and later uses pointers (`p`) to read data. It has many code paths where `chunk` could be NULL or `p` could be incremented past valid bounds (e.g., `if ((p-chunk) < (ssize_t) (length-4))`). A missing check similar to the libarchive flaw (e.g., failing to handle a zero-length chunk or field correctly) could lead to a NULL dereference or out-of-bounds read. The code structure and risk patterns are highly similar, providing excellent reference for auditing pointer safety in parsers.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000879"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2012-1013 is a NULL pointer dereference in a Kerberos admin daemon due to exceptional condition mishandling. The target code also has potential for NULL dereference if memory allocation fails (e.g., `chunk == (unsigned char *) NULL` is checked, but not all uses of `mng_info->global_plte` may be guarded). However, the context (network auth daemon vs. file parser) and specific trigger (protocol flag without password vs. malformed binary chunk) are very different. Some reference value for defensive programming exists.",
        "case_metadata": {
          "cve_id": "CVE-2012-1013"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2017-9610 is an out-of-bounds read in a font table parser due to invalid offset validation. The target code is also a parser that reads offsets and lengths from binary data (e.g., `length=ReadBlobMSBLong(image);`, then processes `p` pointer). It includes checks like `if (length > GetBlobSize(image))` but may have other offset calculations (e.g., in `mng_read_box`, `mng_read_pair`) that could be vulnerable if not properly validated. The pattern of parsing structured binary data with internal pointers/offsets is very similar, making this a valuable reference for identifying similar flaws in the MNG decoder.",
        "case_metadata": {
          "cve_id": "CVE-2017-9610"
        }
      }
    ]
  },
  "CVE-2021-37706_before_exclude_100:6bc05e7e:vulspec": {
    "timestamp": "2026-01-16T21:29:23.929701",
    "cve_id": "CVE-2021-37706",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6bc05e7e",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing network protocol attributes, but the vulnerability types differ significantly. The target code reads a length field and copies a string, which could lead to a buffer over-read if length is not validated, but it does not involve the integer overflow/wraparound (CWE-190) leading to out-of-bounds write (CWE-787) that is central to CVE-2018-20750. The attack surface (protocol parsing) is similar, but the core vulnerability mechanism is not.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is about improper handling of NUL bytes in regex patterns leading to an out-of-bounds read. The target code is a STUN attribute decoder that uses a length field to copy a string; it does not involve NUL byte termination issues or regex parsing. The only tangential similarity is the potential for reading memory if the length field is malicious, but the context and root cause are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-20637 involves improper cleanup of sensitive data (pointers) between requests in an HTTP accelerator. The target code is a one-time decoding function for a STUN attribute that allocates and populates a new structure. There is no persistent state, connection reuse, or pointer clearance issue present. The vulnerability classes (CWE-212 vs. potential buffer issues) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. This is the most relevant case so far. Both the target code and CVE-2018-14461 involve parsing a TLV-like structure in a network protocol (STUN vs. LDP). Both read a length field from the packet (`attr->hdr.length`) and use it to calculate a pointer and copy data. The core vulnerability in CVE-2018-14461 is an out-of-bounds read (CWE-125) due to insufficient validation of the length field. The target code performs `value.slen = attr->hdr.length - 4` without checking if `length >= 4` or if `(buf + ATTR_HDR_LEN + 4 + slen)` is within bounds, making it a candidate for a similar vulnerability. The code patterns and trigger conditions are similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-25034 involves an integer overflow in a length calculation leading to an out-of-bounds write. The target code has an integer operation (`buf[6] * 100 + buf[7]`) but it's for an error code, not a memory size. The string length calculation (`attr->hdr.length - 4`) could underflow if `length < 4`, but this is not an integer overflow/wraparound of the CWE-190 type. The attack surface (parsing untrusted network data) is similar, but the specific arithmetic flaw is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow in an image codec due to incorrect allocation size calculation. The target code does not perform any memory allocation based on the parsed length (it uses `pj_strdup` which presumably allocates). The vulnerability is in a different domain (image encoding vs. protocol parsing) and the code pattern (allocation with padding) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free caused by complex state management during error cleanup. The target code is a simple, linear decoder with no apparent error paths that would free the allocated `attr` before it's used. The vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-1833 is an out-of-bounds read during multi-byte character processing in an XML parser. The target code could also lead to an out-of-bounds read if the length field is invalid, but it does not involve character encoding complexities or parser state recovery. The similarity is the general consequence (reading beyond buffer bounds), but the mechanism and code patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Similar to case 8, CVE-2016-1838 is an out-of-bounds read in an XML parser due to insufficient bounds checking. The target code shares the characteristic of reading data based on an untrusted length field without explicit bounds verification against the overall message size. However, the context (XML tag parsing vs. STUN attribute parsing) and specific code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2012-5854 is a heap buffer overflow due to unsafe string concatenation and buffer growth. The target code uses a library function (`pj_strdup`) for string duplication, which may or may not have safe bounds checking. The vulnerability could be similar if `pj_strdup` does not properly handle the length, but the code pattern shown (direct length assignment and copy) is simpler and does not involve the incremental buffer growth issue central to this CVE.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      }
    ]
  },
  "CVE-2021-37706_after_exclude_100:b6f9c5a7:vulspec": {
    "timestamp": "2026-01-16T21:29:24.452952",
    "cve_id": "CVE-2021-37706",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b6f9c5a7",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing network protocols and integer handling, but the core vulnerability types differ significantly. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write during memory allocation. The target code performs integer arithmetic (`buf[6] * 100 + buf[7]`) and has a length check, but the primary concern is a potential buffer over-read due to insufficient validation of `attr->hdr.length`, not an allocation overflow.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 involves improper handling of NUL bytes in regex patterns leading to an out-of-bounds read. The target code deals with STUN protocol attribute parsing, not string pattern parsing. The `value.slen` calculation could be negative if `attr->hdr.length < 4`, which is checked, but this is a simple length miscalculation, not a NUL-byte injection issue in a complex parser.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-20637 is an information disclosure via improper state clearance between HTTP requests (residual pointers). The target code is a stateless decoding function for a single STUN attribute. It allocates fresh memory and copies data, with no apparent state or pointer reuse across invocations.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. This is the most relevant case so far. CVE-2018-14461 is an out-of-bounds read in a network protocol parser (tcpdump's LDP) due to insufficient validation of a length field. The target code is also a network protocol (STUN) parser that reads a length field (`attr->hdr.length`) and uses it to calculate a string length and pointer offset (`value.ptr = ((char*)buf + ATTR_HDR_LEN + 4)`). The check `if (value.slen < 0)` mitigates a negative length but does not validate if `attr->hdr.length - 4` exceeds the actual available data in `buf`, leaving a potential buffer over-read similar to the tcpdump flaw.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-25034 involves an integer overflow in domain name length calculation leading to an out-of-bounds write. The target code has an integer calculation (`buf[6] * 100 + buf[7]`) which could theoretically overflow if `buf[6]` is large, but it uses `pj_uint8_t` (likely unsigned char), making a 16-bit overflow unlikely to be exploitable in the same way. The primary similarity is arithmetic on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow due to incorrect allocation size calculation for image encoding. The target code does not perform any memory allocation based on calculated lengths from the network buffer; it only duplicates a string of a calculated length. The vulnerability patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free caused by complex state management during error handling. The target code is a simple, linear decoder with no obvious error paths that would free memory incorrectly or leave dangling pointers.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper buffer management during multi-byte character processing. The target code also has a potential out-of-bounds read if `attr->hdr.length` is not validated against the parent buffer. However, the trigger condition (complex character encoding) and code pattern (linear buffer offset vs. stateful parser) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Similar to case 8, CVE-2016-1838 is an out-of-bounds read in a parser due to insufficient bounds checking. The target code shares the \"insufficient bounds checking\" characteristic for a length field derived from network data. However, the context (XML tag parsing vs. STUN attribute decoding) and specific code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2012-5854 is a heap buffer overflow due to unsafe string concatenation and buffer growth. The target code uses `pj_strdup` to copy a string, which should handle allocation internally. The vulnerability link is tenuous: both process formatted data from a network, but the target code's risk is an over-read source for the duplication, not an overflow during the concatenation/growth process itself.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      }
    ]
  },
  "CVE-2022-21733_after_exclude_100:e87f2830:vulspec": {
    "timestamp": "2026-01-16T21:29:27.655587",
    "cve_id": "CVE-2022-21733",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e87f2830",
    "scores": [
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is a TensorFlow string n-gram generation kernel performing data validation and memory allocation. CVE-2015-7511 is a cryptographic side-channel vulnerability (timing/EM) in libgcrypt's ECC implementation. The domains (ML tensor operations vs. cryptography), vulnerability types (no side channels here), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-5745 involves DNSSEC key processing, broken crypto algorithms, and NULL pointer dereference in BIND9. The target code performs input validation and arithmetic on tensor splits; it does not involve cryptography, DNS, or complex error cleanup leading to NULL dereference. The attack surfaces and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2009-3909 is an integer overflow leading to heap buffer overflow in an image parser. The target code also performs integer arithmetic (e.g., `splits_vec(i) - splits_vec(i - 1)`, `ngrams_splits_data[i - 1] + num_ngrams`) and validates indices to prevent out-of-bounds access. However, the validation appears robust (checks `splits_vec(i) <= input_data_size`), and there's no obvious integer overflow from user-controlled values like image dimensions. The context (file parsing vs. tensor processing) differs.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser. The target code uses heap allocation via `context->allocate_output` and accesses arrays with bounds checks (`OP_REQUIRES` with validation). No stack buffers or hex string parsing are present. The vulnerability class (CWE-119) is broad, but the specific manifestation and code patterns do not align.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read in a PSP image metadata parser due to improper string termination. The target code processes `tstring` arrays but does not parse external file formats or strings with implicit length assumptions. It uses explicit sizes from tensor shapes and splits. No similarity in attack surfaces or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability in PostgreSQL's query planner involving privilege checks. The target code is a TensorFlow kernel with no authentication, authorization, or database query planning concepts. The CWE-284 is entirely unrelated to the tensor manipulation and validation shown.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-3603 involves privilege separation failure in a network daemon, leading to unnecessary root execution. The target code is a user-space TensorFlow operation with no privilege management, process separation, or daemon initialization logic. The CWE-20 and CWE-250 are not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow in an ISO9660 parser calculating file positions. Similar to case 3, the target code performs integer arithmetic (subtractions, additions) on split indices. It validates inputs to ensure they are within bounds, which may mitigate overflow risks. However, the arithmetic `splits_vec(i) - splits_vec(i - 1)` could theoretically overflow if `SPLITS_TYPE` is signed and splits are maliciously crafted, but the validation `splits_vec(i) >= prev_split` and `splits_vec(i) <= input_data_size` (with `input_data_size` being the size of a flat tensor) likely limits the range. The context differs (archive parsing vs. tensor processing), but the integer operation pattern is somewhat similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to NUL byte handling. The target code processes tensor string data but does not compile patterns, parse regex, or handle embedded NULs specially. The CWE-125 is not applicable as the code uses indexed access with validated bounds.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow in a JPEG 2000 encoder due to insufficient padding allocation. The target code also allocates output tensors based on calculated sizes (`ngrams_splits_data[num_batch_items]`). However, the calculation involves counting n-grams, not compression padding. The allocation size is derived from validated input splits and ngram widths, with no obvious under-allocation pattern. The vulnerability class (CWE-119) is broad, but the specific trigger (padding miscalculation) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-25636_before_exclude_100:6d5f7016:vulspec": {
    "timestamp": "2026-01-16T21:29:30.303201",
    "cve_id": "CVE-2022-25636",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6d5f7016",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is from the Linux kernel's netfilter subsystem (nftables offload), handling network rule processing. CVE-2017-1000381 is in a userspace DNS library (c-ares) concerning NAPTR record parsing and buffer over-reads. The domain (networking vs. DNS), system layer (kernel vs. library), and vulnerability pattern (rule offload logic vs. protocol parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-1000381"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is Linux kernel netfilter offload logic. CVE-2019-25034 is in the Unbound DNS resolver concerning integer overflow during domain name string-to-wire format conversion. The systems, domains (kernel packet filtering vs. DNS resolution), and vulnerability root causes (memory management/error handling vs. integer overflow in parsing) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The target code and CVE-2011-3603 (radvd) share a broad \"system/daemon\" context and involve error handling paths (`goto err_out`). The vulnerability in radvd is about improper input validation leading to unnecessary privilege retention after privilege separation fails. The target code's error handling cleans up resources (kfree, destroy) and returns an error, which is correct. The similarity is limited to the pattern of checking operations and cleaning up on failure.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is kernel-level netfilter rule offloading. CVE-2019-25037 is in the Unbound DNS resolver concerning a reachable assertion due to improper input validation of DNS label lengths. The domains (packet filtering vs. DNS message parsing), system layers, and vulnerability patterns (assertion abuse vs. memory allocation/pointer handling) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25037"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is Linux kernel netfilter offload logic. CVE-2018-14461 is in the tcpdump packet analyzer concerning an out-of-bounds read in an LDP protocol parser. Both process network data, but at entirely different layers and contexts (kernel offload engine vs. userspace diagnostic tool, rule processing vs. passive packet dissection). The vulnerability pattern is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is Linux kernel netfilter offload logic. CVE-2017-13053 is in tcpdump concerning an out-of-bounds read in BGP packet parsing. The shared theme of \"network packet processing\" is superficial. The systems, purposes (enforcement vs. analysis), and specific vulnerability mechanisms are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is Linux kernel netfilter offload logic. CVE-2018-16227 is in tcpdump concerning an out-of-bounds read in 802.11 wireless packet parsing. Beyond the broad \"networking\" category, there is no meaningful overlap in code patterns, vulnerability type, or trigger conditions.",
        "case_metadata": {
          "cve_id": "CVE-2018-16227"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is Linux kernel netfilter offload logic. CVE-2019-25040 is in the Unbound DNS resolver concerning an infinite loop due to improper handling of DNS compression pointers. The domains, code structures, and vulnerability patterns (loop logic vs. error handling in setup) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. This is the most relevant case among the list. Both the target code and CVE-2010-4650 are within the Linux kernel. Both involve kernel subsystems passing data/operations to/from another entity (netfilter offload to hardware, FUSE ioctl to userspace server). Both require careful validation of actions and data from these external entities. The vulnerability pattern in CVE-2010-4650 is insufficient validation leading to buffer overflow, which is a relevant concern for the target code's `expr->ops->offload` callback. However, the specific subsystems (networking vs. filesystem) and data structures are different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is Linux kernel netfilter offload logic. CVE-2018-14467 is in tcpdump concerning an out-of-bounds read in BGP capability parsing. The similarity is limited to the broad domain of network protocol handling. The specific contexts, code patterns, and vulnerability triggers are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-14467"
        }
      }
    ]
  },
  "CVE-2022-25636_after_exclude_100:2b63833d:vulspec": {
    "timestamp": "2026-01-16T21:29:32.620253",
    "cve_id": "CVE-2022-25636",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2b63833d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-1000381 is in a DNS library (c-ares) and involves parsing NAPTR records leading to an out-of-bounds read. The target code is in the Linux kernel's netfilter subsystem (nftables offload), handling network rule offloading. The domain, functionality, and vulnerability pattern (parsing vs. rule processing) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-1000381"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-25034 is in a DNS resolver (Unbound) and involves integer overflow during domain name string-to-wire conversion. The target code performs rule expression iteration and memory allocation in the kernel networking stack. No domain name parsing, integer overflow on length calculations, or similar code patterns are present.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2011-3603 involves improper input validation leading to unnecessary privilege execution in a daemon's privilege separation logic. The target code also performs error handling and cleanup (`goto err_out`). The weak similarity is in the pattern of checking operations and handling failure states, but the core vulnerability (privilege management) and context (userspace daemon vs. kernel module) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-25037 is another DNS resolver (Unbound) vulnerability involving a reachable assertion due to improper input validation of label lengths. The target code does not parse DNS packets, use assertions for validation, or handle domain names. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-25037"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is a tcpdump vulnerability involving out-of-bounds read while parsing LDP protocol TLVs. The target code is kernel code for nftables offload, not a packet dissector. While both are in the networking domain, the activity (parsing untrusted network data vs. processing internal rule expressions) and vulnerability cause are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13053 is a tcpdump vulnerability involving out-of-bounds read in BGP packet parsing due to incorrect offset calculation. The target code does not parse network packets or calculate offsets from packet data. The contexts are fundamentally different (user-space analyzer vs. kernel offload engine).",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-16227 is a tcpdump vulnerability involving out-of-bounds read in 802.11 mesh control field parsing due to missing bounds checks. The target code iterates over known kernel data structures (nft_expr) and does not parse variable-length, untrusted packet data from an external source.",
        "case_metadata": {
          "cve_id": "CVE-2018-16227"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-25040 is a DNS resolver vulnerability involving an infinite loop due to improper handling of compression pointers. The target code has simple while-loop iteration over a rule's expressions with a clear termination condition. The loop pattern and the cause of the vulnerability (recursive pointer chasing vs. linear iteration) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2010-4650 is a Linux kernel FUSE vulnerability involving improper validation leading to a buffer overflow. The target code is also in the Linux kernel and involves calling function pointers (`expr->ops->offload`) and handling error paths. The higher relevance comes from the shared context (Linux kernel), the pattern of calling ops function pointers (similar to FUSE's server calls), and the careful resource management (alloc/free). However, the specific vulnerability (buffer overflow from iovec) and subsystem (filesystem vs. networking) differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14467 is another tcpdump BGP parsing vulnerability (out-of-bounds read). Similar reasoning to cases 5, 6, and 7. The target code does not parse capability advertisements or any network protocol fields where bounds checking on packet data is required.",
        "case_metadata": {
          "cve_id": "CVE-2018-14467"
        }
      }
    ]
  },
  "CVE-2022-1769_before_exclude_100:ae6a66e8:vulspec": {
    "timestamp": "2026-01-16T21:29:33.271409",
    "cve_id": "CVE-2022-1769",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ae6a66e8",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8925 is a Linux kernel USB driver issue involving improper resource shutdown/release (CWE-404) and reference counting. The target code is a Vim source file reading function with no USB, driver, or reference counting logic. The functional domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-18313 involves out-of-bounds read (CWE-125) in a regex parser due to improper NUL byte handling. The target code also processes input buffers and handles NUL bytes, but its purpose (reading source lines) and vulnerability pattern (buffer over-read in a complex parser) are different. The shared theme is careful handling of input delimiters and buffer boundaries.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-17807 is a Linux kernel keyring authorization flaw (CWE-862). The target code performs file/line reading with no security authorization, key management, or permission checks. No conceptual overlap.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2015-0241 is a buffer overflow in PostgreSQL's formatting code (CWE-120). The target code uses a growable array (ga_grow) for dynamic buffer management, which is a safer pattern. However, both involve string/buffer manipulation from external input. The relevance is in the defensive programming theme, but the specific vulnerability pattern differs.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8924 is a Linux kernel USB driver integer underflow (CWE-191). The target code performs arithmetic for buffer lengths but does not involve USB, kernel-space programming, or the specific integer underflow risk from device-provided data. Different domain and risk profile.",
        "case_metadata": {
          "cve_id": "CVE-2017-8924"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-10675 is a kernel memory policy use-after-free (CWE-416) with race conditions. The target code is single-threaded user-space file reading with no dynamic memory freeing (except at the end) and no concurrency. No meaningful overlap.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon. The target code has resource cleanup (vim_free) but no complex state or error path that could lead to a use-after-free in a similar way. Both involve processing external data, but the memory management models are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8071 is a kernel driver synchronization/deadlock issue (CWE-404/833). The target code has no locks, no concurrency, and is not a driver. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-8071"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-20750 is an out-of-bounds write (CWE-787) due to integer overflow in memory allocation in a network service. The target code uses ga_grow for buffer expansion, which could theoretically have similar integer overflow risks if the growth calculation is flawed. Both handle externally supplied data and manage dynamic buffers. The pattern of \"read data, expand buffer, process\" is similar, though the vulnerability manifestation is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2016-1833 is an out-of-bounds read (CWE-125) in libxml2 due to improper buffer management during character encoding processing. The target code carefully processes a buffer character-by-character, checks for line endings (CR/LF), and handles escape sequences (Ctrl_V). It includes bounds checks (ga.ga_maxlen - ga.ga_len) and length calculations. The relevance is high in the pattern of iterative buffer reading, stateful parsing, and the need to avoid OOB reads when examining characters relative to the buffer end. The specific vulnerability details differ, but the defensive coding lessons are directly applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2020-9759_before_exclude_100:3e29e035:vulspec": {
    "timestamp": "2026-01-16T21:29:39.629198",
    "cve_id": "CVE-2020-9759",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3e29e035",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2012-5854 is a heap buffer overflow in IRC color decoding due to unsafe string concatenation and buffer growth. The target code performs string formatting with snprintf into a newly allocated buffer of calculated size, which is safer. The vulnerability patterns (dynamic buffer growth vs fixed allocation) and attack surfaces (IRC formatting sequences vs WHO message parsing) are different.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code performs simple arithmetic for string length calculation (strlen + constants) with no complex integer operations that could overflow. The domains (IRC vs VNC) and vulnerability mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. The target code uses standard C string functions (strlen, strcmp, snprintf) on argv pointers which are NUL-terminated strings from IRC message parsing. No regex processing or similar NUL-byte edge case handling is present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in tcpdump's LDP protocol parser due to insufficient length validation. The target code processes IRC protocol messages with argc/argv bounds checking (IRC_PROTOCOL_MIN_ARGS, argc checks). While both parse network protocols, the vulnerability pattern (missing length validation vs explicit bounds checks) differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-17498 is an integer overflow in SSH packet parsing leading to out-of-bounds read. The target code has simple integer arithmetic for buffer sizing (strlen results + small constants) that cannot practically overflow given IRC message size limits. The protocols (IRC vs SSH) and vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-25034 is an integer overflow in DNS domain name parsing leading to out-of-bounds write. The target code calculates `length = strlen(argv[4]) + 1 + strlen(argv[5]) + 1` which could theoretically overflow, but IRC hostname lengths make this unlikely. However, the domain (IRC vs DNS) and specific vulnerability mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2013-2206 involves improper state management and NULL pointer handling in SCTP association cleanup. The target code has some state management (checking ptr_channel, ptr_nick) and NULL checks before dereferencing. Both handle network protocol state, but the vulnerability type (state machine issues vs memory safety) and severity differ.",
        "case_metadata": {
          "cve_id": "CVE-2013-2206"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2013-0310 is a NULL pointer dereference in kernel CIPSO validation. The target code has multiple NULL checks (ptr_channel, ptr_nick, pos_attr, pos_realname) before dereferencing, showing similar defensive programming. However, the context (user-space IRC client vs kernel networking) and specific vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-20637 involves improper cleanup of sensitive data between HTTP requests. The target code frees `str_host` after use and conditionally frees `ptr_nick->realname` before reassigning, showing some memory hygiene. However, the vulnerability type (information disclosure via residual pointers vs potential use-after-free) and domain differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-15670 is a heap buffer overflow due to off-by-one error in glibc's glob function. The target code uses `snprintf(str_host, length, ...)` with the same `length` used for allocation, preventing overflow. Both involve string manipulation, but the vulnerability mechanism (off-by-one vs bounds-checked formatting) and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2020-9759_after_exclude_100:600f438f:vulspec": {
    "timestamp": "2026-01-16T21:29:41.268946",
    "cve_id": "CVE-2020-9759",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "600f438f",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2012-5854 involves heap buffer overflow in IRC color code parsing. The target code handles IRC numeric 352 (WHO reply) and performs string formatting for display, but does not contain the complex color decoding logic or dynamic buffer growth that was vulnerable. The target code uses safe snprintf and fixed-length allocation for host string.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in VNC file transfer. The target code performs simple string concatenation with fixed size calculation (strlen + constant overhead) and uses snprintf with proper length limit. No complex integer arithmetic or dynamic allocation based on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in Perl regex engine due to NUL byte handling. The target code processes IRC protocol messages using string pointers from argv array, but doesn't perform low-level byte inspection or regex compilation that could be affected by embedded NULs.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14461 involves out-of-bounds read in tcpdump's LDP parser due to insufficient length validation. The target code processes IRC protocol fields but operates on pre-parsed argv strings rather than raw packet data. It does check argc bounds before accessing array elements.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-17498 involves integer overflow in SSH packet validation leading to out-of-bounds read. The target code performs simple arithmetic (strlen + 1 + strlen + 1) for fixed string concatenation, not complex integer operations on untrusted network data that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-25034 involves integer overflow in DNS domain name parsing leading to out-of-bounds write. The target code calculates a simple fixed length for host string (nick@host) using strlen, which cannot overflow given typical string lengths and the allocation size.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2206 involves improper state handling in Linux kernel SCTP implementation. The target code is user-space IRC client callback with simple conditional logic and no complex state machine or association management.",
        "case_metadata": {
          "cve_id": "CVE-2013-2206"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2013-0310 involves NULL pointer dereference in kernel CIPSO validation. The target code does check for NULL pointers (e.g., ptr_channel, ptr_nick checks) before dereferencing, though not exhaustively. Both involve protocol validation but at different layers.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-20637 involves improper cleanup of sensitive data between HTTP requests in Varnish. The target code frees allocated memory (str_host) but doesn't handle complex connection state or residual pointer issues. Both involve network protocol handling with memory management.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-15670 involves off-by-one heap buffer overflow in glibc glob function. The target code uses snprintf with proper length calculation, avoiding off-by-one errors. Both involve string processing but the vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-1769_after_exclude_100:552a8a06:vulspec": {
    "timestamp": "2026-01-16T21:29:42.629424",
    "cve_id": "CVE-2022-1769",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "552a8a06",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8925 is a reference counting/resource leak vulnerability in a Linux kernel USB serial driver. The target code is a user-space file/line reading function in what appears to be an editor (Vim). The vulnerability type (CWE-404), domain (kernel driver vs. application I/O), and code patterns (reference counting vs. buffer growth and line parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code reads source lines and handles line endings and escaped characters. While both involve parsing input streams, the vulnerability root cause (improper NUL handling leading to OOB read) and the context (complex regex compilation vs. simple line buffering) are not similar. The target code carefully checks buffer lengths with ga_grow and STRLEN.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in the Linux kernel keyring subsystem. The target code performs no authorization checks; it's a purely functional line-reading routine. The domains (kernel security vs. application I/O) and vulnerability classes (CWE-862 vs. potential buffer/parsing issues) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2015-0241 is a buffer overflow/over-read in a numeric formatting function. The target code also involves buffer management (using a growarray `ga`) and string operations. There is a superficial similarity in the need to manage buffer sizes during formatted output/input. However, the vulnerability mechanism (complex template parsing leading to unchecked buffer writes) is different from the target's pattern of incremental growth and careful length checks (ga_grow, checking ga_len against ga_maxlen).",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8924 is an integer underflow in a USB driver leading to information disclosure. The target code performs arithmetic on lengths and indices (e.g., `len - 2`), but these are guarded by prior checks (`len >= 2`). The context (kernel USB URB processing vs. application line reading) and the specific vulnerability pattern (manipulated device data causing underflow) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-8924"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition in kernel memory policy code. The target code is single-threaded line reading with no dynamic resource sharing or locking. The vulnerability patterns (concurrency, lock management, object lifecycle) are absent from the target.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free/double-free in a network daemon related to error path cleanup. The target code has error paths (`break` on `FAIL`) and frees memory (`vim_free`), but it manages a single growarray buffer with straightforward ownership. The complex state management and cleanup issues leading to double-free are not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-8071 is a deadlock due to improper lock selection in a kernel HID driver. The target code contains no locking or concurrency mechanisms. The domains and vulnerability classes are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8071"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-20750 is an out-of-bounds write due to an integer overflow in memory allocation. The target code uses a growarray (`ga`) for dynamic buffer allocation and has checks like `ga_grow(&ga, 120) == FAIL`. The core similarity is the need for safe, bounded buffer growth when processing untrusted input (source files). While the specific integer overflow trigger is not obvious in the target code (it uses `int` for lengths, not `uint32_t`), the general theme of preventing buffer overflows during incremental data reading is relevant. The target code appears robust due to its use of `ga_grow`.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper buffer state validation during multi-byte character processing. The target code reads a byte stream, processes characters (checking for `\\n`, `\\r`, `Ctrl_V`, `Ctrl_Z`), and performs bounds-checked buffer accesses (`buf[len - 1]`, `buf[len - 2]` guarded by `len >= 1` or `len >= 2`). The key similarity is the need for precise buffer index management and validation when performing character-by-character parsing of an input stream. The target code shows careful checks, making it less vulnerable, but the code pattern and potential pitfall are analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2021-38593_before_exclude_100:850347b3:vulspec": {
    "timestamp": "2026-01-16T21:29:55.304850",
    "cve_id": "CVE-2021-38593",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "850347b3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow in an image codec (OpenJPEG) during memory allocation for compressed data. The target code is a Qt painting engine stroke function handling vector paths and pen styles. The domain (graphics rendering vs. image compression), vulnerability pattern (allocation size calculation vs. path processing), and code constructs are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read in a PSP file importer due to improper string termination validation. The target code processes internal vector path data and pen attributes, with no file parsing or external string handling. The attack surfaces and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code performs arithmetic (e.g., patternLength calculation, extent comparisons) but with floating-point values (qreal) and for visual approximation, not memory allocation. The integer overflow/truncation vulnerability pattern does not apply here due to different data types and purposes.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2022-32546_before_exclude_100:10ecc901:vulspec": {
    "timestamp": "2026-01-16T21:29:55.779194",
    "cve_id": "CVE-2022-32546",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "10ecc901",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free vulnerability in a network service daemon (MiniSSDPd). The target code is an image file parser (PCL) in ImageMagick. The domain (network protocol vs. image parsing), vulnerability type (use-after-free vs. potential buffer/parsing issues), and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 4,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-7532"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-32546_after_exclude_100:b4b2d7c6:vulspec": {
    "timestamp": "2026-01-16T21:30:01.174418",
    "cve_id": "CVE-2022-32546",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b4b2d7c6",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability in a network service discovery daemon (MiniSSDPd). The target code is an image file parser (PCL) in ImageMagick. The domains (network protocol vs. image parsing), vulnerability types (UAF vs. potential buffer/parsing issues), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2013-1978 is an Out-of-bounds Write in an image file parser (GIMP's XWD plugin). The target code is also an image file parser (ImageMagick's PCL reader). Both involve parsing file headers and data structures from untrusted input. The vulnerability mechanism (OOB write due to insufficient validation of header fields) is a relevant pattern for the target code, which parses `CropBox` and `MediaBox` strings with `sscanf`. However, the specific file formats and data structures differ.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2017-12982 is a memory allocation failure/overflow due to unchecked header values in an image parser (OpenJPEG's BMP converter). The target code parses PCL header data (`CropBox`, `MediaBox`) using `sscanf` into stack variables, which is safer, but the pattern of parsing untrusted file data without rigorous validation is similar. The relevance is in the domain (image parsing) and the potential for issues arising from malformed header values.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2018-18313 is an Out-of-bounds Read in a regular expression compiler (Perl) due to improper NUL byte handling. The target code reads a byte stream and builds a string in a buffer (`command`) character by character, but it does not appear to have similar NUL-termination issues leading to OOB reads. The domains and primary vulnerability patterns are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2015-8877 is a resource management error (memory leak) in an image scaling function (PHP GD). The target code also performs image processing and delegates to an external command (GhostPCL). While both involve image processing and resource management, the vulnerability type (memory leak in error path) is less directly relevant to the parsing and delegation logic shown. The connection is the broader domain of image library error handling.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20750 is an Out-of-bounds Write due to integer overflow in a network protocol handler (LibVNC file transfer). The target code reads a local file and uses formatted string functions (`sscanf`, `FormatLocaleString`). While integer overflows are a concern in any parsing code, the specific context (network protocol vs. file parsing) and the mechanism (size calculation for allocation) are not directly mirrored in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2016-7532 is an Out-of-bounds Read in an ImageMagick PSD parser. The target code is another ImageMagick parser (PCL). They belong to the same system (ImageMagick), the same domain (image file parsing), and share the same codebase patterns, coding style, and helper functions (e.g., `ReadBlobByte`, `LocaleNCompare`). The vulnerability type (OOB read) is a critical concern for the pattern of reading a blob into a buffer and parsing it. This case is highly instructive for auditing the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-7532"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-1000222 is a Double Free in an image library (libgd) during BMP processing. The target code is in ImageMagick, a different but related image library. Both involve processing complex image formats. The relevance lies in the domain and the potential for memory management errors during complex parsing and delegation. However, the specific double-free pattern is not immediately evident in the provided code, which uses `DestroyString` and `DestroyImage` for cleanup.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2019-20840 is an Out-of-bounds Write due to alignment issues in a network protocol decoder (LibVNCServer WebSocket). The target code is a file parser, not a network packet decoder. The vulnerability mechanism (unaligned memory access) is highly specific to low-level data manipulation and not applicable to the string parsing and `sscanf` operations seen here.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow in a compression codec (OpenJPEG) due to insufficient padding allocation. The target code does not perform low-level compression or similar complex buffer size calculations. The connection is the broad domain of image processing and the ever-present risk of buffer overflows when handling untrusted data, but the specific code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2021-38593_after_exclude_100:07cda8ee:vulspec": {
    "timestamp": "2026-01-16T21:30:01.843373",
    "cve_id": "CVE-2021-38593",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "07cda8ee",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a Qt painting engine function for stroking vector paths. CVE-2017-14151 is a heap buffer overflow in OpenJPEG's image encoding memory allocation. Both involve graphics processing but are in completely different domains (vector graphics rendering vs. raster image compression). The vulnerability type (CWE-119) is generic, but the trigger conditions, code patterns (memory allocation vs. geometric calculations), and attack surfaces are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-17787 is an out-of-bounds read in GIMP's PSP file parser. The target code performs geometric transformations and path rendering within a trusted graphics library. There is no file parsing, no string handling, and the code does not read external, untrusted data in a similar way. The CWE-125 classification is too broad to establish meaningful relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-3179 is a use-after-free in a network daemon's service registration logic. The target code is a synchronous graphics rendering function with straightforward resource management (allocating a StrokeHandler once). There is no dynamic resource sharing, error-prone cleanup paths, or network/socket handling that could lead to similar state management issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a VNC file transfer protocol handler. The target code performs arithmetic on floating-point values (e.g., `extent / patternLength > 10000`) and geometric calculations. While both involve numeric computations, the context is vastly different: network protocol integer handling vs. local graphics coordinate math. The risk profile and attack surface (remote client vs. local rendering) are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to NUL byte handling. The target code processes structured geometric path data (arrays of points and types) with explicit bounds checks via `pointCount`. It does not parse string patterns or handle character encoding issues. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-14164 is an out-of-bounds write in OpenJPEG's JPEG 2000 marker writing due to insufficient buffer validation. The target code writes to internally managed buffers (strokeHandler->pts, strokeHandler->types) but does not involve writing to external, fixed-size buffers based on untrusted size calculations. The code patterns and trust boundaries are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-9619 is a buffer overflow in Ghostscript's font glyph index processing. The target code also processes graphical data (paths, pens) and performs array indexing (`points`, `types`). However, the target code's indexing is tightly coupled to the `pointCount` limit and uses pointer arithmetic with careful bounds (`points < lastPoint`). The font parsing attack surface (complex binary format) is more similar to the target than other cases, but the specific vulnerability pattern (unchecked index arithmetic) is not evident here.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2019-13219 is an integer overflow in an audio codec's mathematical computations. The target code performs floating-point calculations (`extent / patternLength`, `patternLength *= pen.widthF()`) which could theoretically overflow or cause division by zero, but these are with trusted `qreal` values derived from pen properties, not from untrusted file data. The domain (audio decoding vs. graphics) and data types (integer vs. float) limit relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2009-3909 is an integer overflow in PSD file dimension parsing leading to a heap overflow. The target code reads an internal `QVectorPath` structure with known element counts. While both are in graphics software, the target code does not parse file headers or allocate buffers based on product-of-dimensions calculations from untrusted sources. The similarity is weak.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1833 is an out-of-bounds read in libxml2's character encoding processing. The target code does not parse text, handle character encodings, or manage input buffers in a streaming, stateful way like an XML parser. The code patterns (pointer iteration over geometric data) are structurally different from multi-byte character decoding.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2022-31214_after_exclude_100:883392a3:vulspec": {
    "timestamp": "2026-01-16T21:30:03.406825",
    "cve_id": "CVE-2022-31214",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "883392a3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code involves directory traversal and string manipulation but does not parse complex patterns like regex, and its NUL byte insertion is temporary and controlled. The vulnerability type and context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in libxml2's XML end tag parser. The target code is a filesystem directory creation function that iterates over a path string. There is no similarity in functionality (XML parsing vs. path traversal), data structures, or the specific mechanism of the bounds violation.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob() due to an off-by-one allocation error during tilde expansion. The target code also performs filesystem operations and string traversal, but it does not involve dynamic memory allocation or pattern expansion. The vulnerability patterns (off-by-one allocation vs. in-place string modification) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13001 is an out-of-bounds read in tcpdump's NFS packet decoder. The target code is a local filesystem utility function. Both involve reading data, but the domains (network packet parsing vs. local path stat) and the nature of the bounds checking issues are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-6250 is an integer overflow leading to a heap buffer overflow in libarchive's filename processing. The target code manipulates path strings in-place and uses `stat()` and `mkdir()`. While both process filenames/paths, the target code does not perform any complex size calculations or dynamic allocations that could lead to integer overflow. The risk profile is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-6250"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3601 is a buffer overflow in a network daemon (radvd) parsing IPv6 options. The target code is a local function for building directory trees. The attack surface (network vs. local), data parsing complexity, and memory operations are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-20750 is an out-of-bounds write in LibVNC due to integer overflow in allocation. The target code does not perform any memory allocation based on user-controlled sizes. Both involve processing external input, but the vulnerability mechanism (integer overflow -> bad allocation -> OOB write) is not present in the target code's simple string iteration.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2's character encoding handler. The target code processes simple ASCII paths with '/' delimiters and does not involve multi-byte character encoding or the associated complex state management that leads to the vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2014-9512 is a path traversal/symlink issue in rsync due to improper handling of absolute paths. The target code's core functionality is also path traversal and directory creation. While the specific vulnerability (CWE-59) is not directly mirrored, the code pattern of iterating through path components and calling filesystem functions (mkdir, chmod) is similar. The target code modifies the source string in-place (`*p = '\\0'`), which could be risky if the string is not writable or if the logic is flawed, though it's not a symlink attack. The domain and operations have clear parallels.",
        "case_metadata": {
          "cve_id": "CVE-2014-9512"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's resource cleanup. The target code has no dynamic memory management (no malloc/free), uses only stack variables and library calls, and operates in a completely different context. No similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      }
    ]
  },
  "CVE-2022-31214_before_exclude_100:44b1ab47:vulspec": {
    "timestamp": "2026-01-16T21:30:03.916562",
    "cve_id": "CVE-2022-31214",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "44b1ab47",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code is a directory traversal/building function in C that modifies strings in-place and calls stat() and mkdir_attr(). The vulnerability type, domain (regex vs. filesystem), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in libxml2's XML end tag parser. The target code does not parse XML; it manipulates path strings for directory creation. The core functionality, attack surfaces, and vulnerability patterns (parsing structured data vs. string traversal) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob() due to an off-by-one allocation error during tilde expansion. The target code also deals with pathname strings and has potential for buffer issues if input strings are not properly bounded, but it does not perform dynamic memory allocation. The vulnerability mechanism (allocation miscalculation) is not present here. The shared domain (filesystem paths) provides minimal reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13001 is an out-of-bounds read in tcpdump's NFS protocol decoder. The target code is a local filesystem utility function. The domains (network packet decoding vs. local directory creation), data sources, and vulnerability triggers are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2016-6250 is an integer overflow leading to heap buffer overflow in libarchive's ISO9660 filename generation. The target code performs in-place string traversal without complex length calculations or dynamic allocations. While both process filenames, the specific vulnerability pattern (integer overflow in size calculation) is not evident in the target code, which lacks arithmetic on sizes.",
        "case_metadata": {
          "cve_id": "CVE-2016-6250"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-3601 is a buffer overflow in an IPv6 router advertisement daemon due to improper bounds checking on network data. The target code processes local path strings, not network packets. The attack surface, protocol handling, and vulnerability context are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write in LibVNC due to integer overflow in file transfer size calculation. The target code does not handle network file transfers, perform integer arithmetic on user-controlled sizes, or dynamically allocate memory based on such calculations. The vulnerability mechanism is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2's character encoding processing. The target code does not parse XML/HTML or handle multi-byte character encodings. It performs simple byte-by-byte traversal of path strings. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2014-9512 is a path validation issue in rsync (CWE-59) where absolute paths could be processed incorrectly, potentially leading to symlink attacks or directory traversal. The target code's core functionality is building directory structures based on source and destination paths (`src` and `dst`). There is a shared domain (filesystem path manipulation) and a potential similarity in the security concern: if the input paths are attacker-controlled and not properly sanitized, the function could be used to create directories in unintended locations (though the code itself uses `stat()` on `src` before creating `dst`). The vulnerability type is not identical (link resolution vs. directory creation), but the context of path traversal security is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2014-9512"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network service discovery daemon related to error handling and memory management. The target code has no dynamic memory allocation, freeing, or network components. The vulnerability class and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      }
    ]
  },
  "CVE-2021-3903_after_exclude_100:124e334d:vulspec": {
    "timestamp": "2026-01-16T21:30:09.714844",
    "cve_id": "CVE-2021-3903",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "124e334d",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a window/viewport update function in a text editor (likely Vim). It handles cursor positioning, scrolling, and screen validation. CVE-2018-18313 is a buffer over-read in Perl's regex engine due to NUL byte handling. The domains (text UI vs. regex parsing), vulnerability types (logic/state management vs. memory corruption), and code patterns are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-20750 is an integer overflow leading to heap corruption in a VNC file transfer component. The target code performs arithmetic for line counting and window dimensions but uses simple integer variables (int, long) for sizes derived from window properties, not attacker-controlled network data. There's no dynamic memory allocation or size calculation vulnerable to wrap-around. Relevance is very low.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-3179 is a Use-After-Free in a network daemon due to error handling and pointer management. The target code manages window state structures (curwin) but these are global/context pointers, not dynamically allocated and freed within this function. There's no resource deallocation or complex error path that could leave dangling references. Weak similarity in managing structured state, but vulnerability mechanism is absent.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2020-16304 is an out-of-bounds write in an image rendering component due to incorrect position tracking during pixel processing. The target code manipulates line numbers and window offsets but does not write to pixel buffers or arrays. All operations are on scalar variables and structure fields. The domain (graphics rendering vs. text display logic) and vulnerability type are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper buffer management during multi-byte character processing. The target code reads from buffer lines (via BUFEMPTY, curbuf->b_ml.ml_line_count) but these are likely abstracted data structure accesses, not raw buffer parsing with positional pointers. No character encoding or complex input validation is present. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-10675 is a Use-After-Free in the Linux kernel due to a race condition and improper locking in memory policy code. The target code is a single-threaded UI update function with no concurrency, locks, or dynamic resource lifecycle management. The concepts of race conditions and lock protection are irrelevant to this code. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1838 is an out-of-bounds read in an XML parser during end tag processing. Similar to case 5, the target code does not parse a structured, attacker-controlled data format. It operates on trusted internal state (line numbers, window properties). The code pattern of traversing lines (e.g., in folding loops) is bounded by ml_line_count, preventing over-reads. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code validates line numbers against buffer limits (e.g., lnum >= curbuf->b_ml.ml_line_count) but does not parse TLV-like structures from untrusted data. The arithmetic (e.g., curwin->w_botline - *so_ptr) uses trusted offsets. Different domain and attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-17807 is a missing authorization vulnerability in the Linux kernel's key management subsystem. The target code has no concept of permissions, authorization, or security policies. It purely manipulates UI state. The functional domains are entirely separate (security vs. user interface). No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-5711 is an integer signedness issue leading to an infinite loop in a GIF decoder. The target code uses signed integers (int, long) for counts and offsets, but the loops (e.g., for lnum) have clear termination conditions checked against line counts. There's no conversion between signed/unsigned types that could cause wrap-around or infinite loops. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      }
    ]
  },
  "CVE-2021-3903_before_exclude_100:8f1cd212:vulspec": {
    "timestamp": "2026-01-16T21:30:11.300237",
    "cve_id": "CVE-2021-3903",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8f1cd212",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a window scrolling/display update function in a text editor (likely Vim). It deals with cursor positioning, line calculations, and screen validation. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to improper NUL byte handling. The domains (text editor UI vs. regex parsing), vulnerability types (logic/state management vs. memory corruption), and code patterns are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a VNC server's file transfer protocol. The target code performs arithmetic (like `curwin->w_height / 2`) but uses `int` and `long` types for line counts and offsets within sane bounds defined by buffer size and window height. There is no dynamic memory allocation based on untrusted input, no integer overflow/wraparound vulnerability pattern. The domains and attack surfaces are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-3179 is a use-after-free in a network daemon due to error handling and inconsistent state. The target code manages window state (topline, botline) but does not dynamically allocate/free memory within its logic. It operates on existing structures (`curwin`, `curbuf`). While it has complex state validation (`w_valid` flags) and error paths (`redraw_later`), the core vulnerability mechanism (memory lifecycle bug) is not present. Weak similarity in state management complexity only.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2020-16304 is an out-of-bounds write in Ghostscript's image rendering due to incorrect position tracking during color conversion. The target code tracks line numbers and fill counts for text display but does not write to pixel buffers or arrays. Its operations are index calculations and assignments to structure fields within defined ranges. The domain (graphics rendering vs. text windowing) and vulnerability pattern are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1833 is an out-of-bounds read in libxml2 due to inadequate bounds checking during multi-byte character processing. The target code reads buffer lines via `ml_line_count` and performs checks (e.g., `lnum >= curbuf->b_ml.ml_line_count`). However, it operates on logical line numbers, not raw byte buffers, and the bounds are explicitly validated against known counts. The pattern of parsing untrusted byte streams with encoding complexities is absent.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-10675 is a use-after-free in the Linux kernel due to a race condition from premature lock release. The target code is a single-threaded UI update function with no concurrency, locks, or resource sharing. It modifies window state locally. The vulnerability class (concurrency bug) and environment (kernel vs. userland application) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1838 is an out-of-bounds read in libxml2 during end tag parsing. Similar to case 5, the target code does not parse a byte-level protocol or markup language. It calculates line offsets and validates against line counts. The code pattern of traversing a buffer based on a length field without sufficient checks is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-14461 is an out-of-bounds read in tcpdump's protocol parser due to insufficient validation of a TLV length field. The target code does not parse network packets or TLVs. It uses trusted, internal state variables (`w_p_so`, `p_so`, `w_height`). While it does check conditions like `lnum < curwin->w_botline`, these are not analogous to parsing untrusted length fields from network data.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-17807 is a missing authorization vulnerability in the Linux kernel's keyring subsystem. The target code has no concept of permissions, users, or access control. It is purely a UI logic function for determining which lines to display. The security domain (mandatory access control) is entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-5711 is an integer signedness confusion leading to an infinite loop in a GIF decoder. The target code uses signed integers (`int`, `long`) for counts and indices, but all loop conditions (e.g., `lnum < curwin->w_topline + *so_ptr`) are based on non-negative values (line numbers, offsets). There is no parsing of binary data where signedness confusion could cause infinite loops. The domain and bug pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      }
    ]
  },
  "CVE-2022-0714_after_exclude_100:37ae4423:vulspec": {
    "timestamp": "2026-01-16T21:30:14.978555",
    "cve_id": "CVE-2022-0714",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "37ae4423",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is from Vim's text editing core, handling indentation and cursor positioning. CVE-2018-18313 is in Perl's regex engine, involving out-of-bounds reads from NUL bytes in patterns. The domain (text editor vs. regex compiler), vulnerability type (no clear buffer over-read in target), and code patterns are completely different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1833 is an out-of-bounds read in libxml2's multi-byte character processing. The target Vim code performs line manipulation, cursor column calculation, and memory allocation for strings, but does not parse complex encodings or exhibit the same pattern of insufficient bounds checking during character processing. Different domain and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-3179 is a use-after-free in a network daemon. The target code allocates memory (`alloc(i + 1)`) and frees it (`vim_free(ptr)`), but manages it locally within the function scope, showing no signs of pointer aliasing or complex state corruption leading to use-after-free. Weak similarity in memory management, but different context and flaw pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a network library. The target code has an integer calculation `i = (int)curwin->w_virtcol - vcol;` used for allocation size. If `w_virtcol` is very large, `i` could be negative, leading to under-allocation and subsequent overflow when writing spaces. This is a plausible, though not identical, integer handling issue. Weak to moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1838 is an out-of-bounds read in libxml2's end tag parsing. The target code reads lines via `ml_get_curline()` and iterates with bounds checks (`ptr[new_cursor_col] == NUL`). It does not show the same pattern of parsing structured markup without adequate bounds validation. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse network packets or TLVs. It validates cursor position against line length. Different domain and vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2020-16304 is an out-of-bounds write in an image renderer due to incorrect position tracking. The target code writes spaces into an allocated buffer based on a calculated offset (`new_cursor_col`). If the offset or `i` is miscalculated, it could write out of bounds. The pattern of position tracking leading to buffer writes is somewhat similar, but the domain and specific calculations are very different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1835 is a use-after-free in libxml2's attribute processing. The target code does not exhibit complex pointer sharing, reference counting, or parser state that could lead to use-after-free. Memory is allocated and freed locally. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-1834 is a heap buffer overflow in libxml2 due to negative length handling. The target code has a similar pattern: `i = (int)curwin->w_virtcol - vcol;` could be negative if `vcol > w_virtcol`. This negative value is passed to `alloc(i + 1)`, which, depending on `alloc`'s implementation (likely `malloc`), could cause a small allocation or wrap, leading to overflow in the `while` loop that fills the buffer with spaces. This is a notable similarity. Weak to moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2012-5854 is a heap buffer overflow in an IRC client due to unsafe string concatenation and buffer growth. The target code performs a form of string insertion (`ins_str(ptr)`) after allocating a buffer based on a calculated size. The vulnerability pattern of calculating a size, allocating, and then writing into the buffer without sufficient validation is similar. However, the target's growth is simple (adding spaces), not a complex dynamic string build. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      }
    ]
  },
  "CVE-2019-15504_before_exclude_100:bcf70463:vulspec": {
    "timestamp": "2026-01-16T21:30:18.576582",
    "cve_id": "CVE-2019-15504",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bcf70463",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a network protocol (VNC file transfer). The target code is a USB driver initialization routine with simple memory allocations using fixed sizes (2048, 252). No complex integer calculations or protocol parsing present.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-3179 is a use-after-free in a daemon's error handling. The target code has error handling paths (goto fail_rx, fail_eps) that free resources, but it follows a clear, linear initialization with no complex state management or uninitialized pointers. The patterns are superficially similar (cleanup on error) but the vulnerability mechanisms differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in FUSE ioctl handling due to insufficient validation of iovec lengths. The target code performs basic kmalloc with a fixed size and has no user-controlled buffer or length validation logic. Different subsystem, different vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in filesystem node ID management. The target code is a driver initialization function likely called once during probe. It contains no concurrency mechanisms (locks, atomics) or shared resource manipulation that could lead to a race.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2014-0196 is a concurrency bug in the TTY subsystem leading to buffer overflow. The target code is initialization-only, with no shared buffers, concurrent writers, or workqueue mechanisms. The code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-10154 is a buffer issue related to scatterlist on VMAP stack in a crypto module. The target code allocates a buffer on the heap (kmalloc) and does not use scatterlists or crypto APIs. The connection is minimal (both involve memory allocation).",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2016-3137 is a NULL pointer dereference in a USB serial driver (cypress_m8) due to insufficient validation of USB endpoint descriptors. The target code is also a USB driver initialization routine (rsi_init_usb_interface). It calls `rsi_find_bulk_in_and_out_endpoints` which likely parses USB descriptors. If this function fails to properly validate endpoints and sets `adapter->rsi_dev` but later code dereferences it, a similar NULL pointer dereference could occur. The domain (USB drivers), module type (initialization), and potential vulnerability pattern (missing checks on USB structures) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-1792 is a race condition leading to NULL pointer dereference in the keyring subsystem during concurrent initialization. The target code shows no evidence of concurrent execution (no locks, no shared global state). While both involve initialization, the concurrency aspect is absent here.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code does not parse complex input strings or compile patterns. No relevance in functionality or vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-18216 is a NULL pointer dereference due to a race condition in a filesystem node manager. The target code has a `priv` pointer assignment (`rsi_dev->priv = (void *)adapter`) and later could potentially dereference it elsewhere. The weak similarity is the presence of pointer assignments during initialization which could be misused if not validated. However, the race condition and configfs interface aspects are not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      }
    ]
  },
  "CVE-2019-15504_after_exclude_100:bdb78912:vulspec": {
    "timestamp": "2026-01-16T21:30:19.146397",
    "cve_id": "CVE-2019-15504",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bdb78912",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a network protocol handler (VNC file transfer). The target code is a USB driver initialization routine with no complex integer calculations, network protocol parsing, or dynamic buffer allocations based on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2016-3179 is a use-after-free in a daemon's error handling path. The target code has error paths with `goto` statements that free resources (`kfree`), but it follows a clear, linear initialization flow. There is no complex state management or pointer manipulation that could lead to a use-after-free in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in the FUSE subsystem's ioctl handling due to insufficient validation of user-supplied iovec lengths. The target code performs simple, fixed-size kernel allocations (`kzalloc`, `kmalloc(2048)`) and does not process any complex or untrusted data structures from userspace.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a filesystem's node ID management. The target code is a driver initialization function (`rsi_init_usb_interface`) that is typically called once during probe. It does not manage shared caches or have concurrent access patterns that could lead to a race condition.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2014-0196 is a concurrency bug in the TTY subsystem leading to buffer overflow. The target code is a initialization function with no shared buffers, concurrent writers, or workqueue mechanisms that could create a similar race condition.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-10154 is a memory corruption issue in the CIFS crypto code related to scatterlist and stack memory. The target code performs basic heap allocations and does not involve cryptographic operations, scatterlists, or the VMAP_STACK feature.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2016-3137 is a NULL pointer dereference in a USB serial driver (`cypress_m8`) due to insufficient validation of USB endpoint descriptors. The target code is also a USB driver initialization function (`rsi_init_usb_interface` for a WiFi adapter). It calls `rsi_find_bulk_in_and_out_endpoints()` to find USB endpoints, which is a similar pattern to the vulnerable code that could fail to find required endpoints. If this function fails, the code jumps to `fail_eps`, but the vulnerability pattern (missing endpoints leading to invalid pointer access later) is highly relevant for USB driver code review.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-1792 is a race condition leading to NULL pointer dereference in the kernel keyring subsystem during concurrent initialization. The target code is a device driver probe-time initialization with no shared global user state or unprotected concurrent initialization logic.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to improper NUL byte handling. The target code is a Linux kernel USB driver with no string parsing, regex compilation, or complex input processing.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-18216 is a NULL pointer dereference in a cluster filesystem due to a race condition in configfs operations. The target code has a potential NULL pointer dereference if `adapter->rsi_dev` is used after a failure before `fail_eps`, but the pattern is simple error handling, not a TOCTOU race on a shared object pointer. The domain (USB driver vs. cluster filesystem) is very different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      }
    ]
  },
  "CVE-2022-0714_before_exclude_100:ac95068c:vulspec": {
    "timestamp": "2026-01-16T21:30:22.993345",
    "cve_id": "CVE-2022-0714",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ac95068c",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is from Vim's text editing core, handling indentation and cursor positioning. CVE-2018-18313 is in Perl's regex engine, involving out-of-bounds reads from NUL bytes in patterns. The domain (text editor vs. regex compiler), vulnerability type (no clear buffer over-read in target), and code patterns are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1833 is an out-of-bounds read in libxml2's multi-byte character processing. The target Vim code performs line manipulation, cursor column calculation, and memory allocation for strings, but its operations are on known line buffers from the editor. There is no parsing of external complex data formats (like XML encodings) that could lead to similar bounds-checking failures. Low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-3179 is a use-after-free in a network daemon's resource cleanup. The target code allocates memory (`alloc(i+1)`) and frees it (`vim_free(ptr)`), but does so locally within the function with clear ownership. There are no persistent structures with uninitialized pointers or complex error paths that could cause a use-after-free. Weak similarity in memory management, but the vulnerability pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-20750 is an out-of-bounds write due to integer overflow in a network protocol's memory allocation. The target code has an integer calculation `i = (int)curwin->w_virtcol - vcol;` used for allocation. If `w_virtcol` is very large, `i` could be negative, leading to a small allocation and subsequent buffer overflow in the `while` loop that writes spaces. This is a plausible, though not identical, integer handling flaw. Weak to moderate relevance as a reminder to validate such calculations.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1838 is an out-of-bounds read in libxml2's end tag parsing. The target code reads from `ml_get_curline()` which returns the current line's buffer, and uses pointer arithmetic (`ptr + new_cursor_col`). It calculates `new_cursor_col` by incrementing until a screen column condition is met, but does not appear to check against the line length. This could theoretically lead to an out-of-bounds read if the line is shorter than expected. However, the context and data source (internal editor buffer vs. external XML) are very different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse TLVs or similar network structures. It works with editor state like cursor columns and line buffers. No relevance in functionality or vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2020-16304 is an out-of-bounds write in an image renderer due to incorrect position tracking. The target code writes spaces into a buffer `ptr` allocated based on `i`. If the position tracking (`new_cursor_col`, `vcol`) is miscalculated, the loop `while (--i >= 0)` could write out of bounds. This is a superficial similarity in the pattern of writing to a buffer based on computed indices. However, the domain (image rendering vs. text indentation) and complexity are vastly different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-1835 is a use-after-free in libxml2's attribute processing. The target code saves and restores lines (`orig_line`, `new_line`) but frees them before returning. There is no passing of freed pointers to other functions or complex state that could cause a use-after-free. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-1834 is a heap buffer overflow in libxml2 due to negative length handling. The target code's allocation size `i+1` could be problematic if `i` is negative (as noted in case 4). This is a direct parallel: insufficient validation of a computed length before allocation/buffer operation. The function `alloc` likely takes an `unsigned int`, so a negative `i` would become a large positive, causing overflow. This provides a valuable reference for validating the `w_virtcol - vcol` calculation. Weak to moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2012-5854 is a heap buffer overflow in an IRC client due to unsafe dynamic buffer growth during formatting. The target code allocates a buffer based on a calculated size (`i+1`) and then fills it with spaces. The vulnerability pattern is similar: a miscalculation of the required buffer size (e.g., integer underflow/overflow) leads to an allocation that is too small, followed by a write loop that overflows it. The target's `ins_str(ptr)` could then overflow the line buffer. This is the most relevant case, as it highlights the danger of computing buffer sizes from user-influenced values (cursor column positions) without rigorous checks. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      }
    ]
  },
  "CVE-2022-37434_before_exclude_100:7e804c61:vulspec": {
    "timestamp": "2026-01-17T00:11:42.517336",
    "cve_id": "CVE-2022-37434",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7e804c61",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code is a decompression/inflation engine (zlib) with a completely different purpose (data decompression vs. pattern compilation). The vulnerability patterns (parsing vs. stateful bitstream processing) and data structures are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve data compression/decompression libraries. Case 2 is a buffer overflow in a JPEG2000 encoder due to insufficient padding allocation. The target code is a decompressor (inflate) for DEFLATE/gzip. While the domain (compression) is similar, the specific flaw (allocation miscalculation for padding) and the code's role (encoding vs. decoding) differ significantly. The target code's primary risks are more related to bitstream parsing and state machine logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free in a network service daemon (MiniSSDPd) related to inconsistent state management during error handling. The target code is a self-contained, stateless decompression function with no dynamic resource management of the kind that leads to use-after-free. The attack surfaces (local socket vs. compressed data stream) and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read in a network protocol parser (tcpdump's LDP parser) due to insufficient validation of a TLV length field. The target code also parses a structured format (zlib/gzip header, blocks) and validates fields (e.g., header check, stored block length). There is a conceptual similarity in parsing untrusted binary formats and checking length fields, but the specific protocols, structures, and the prevalence of bit-level operations in the target code make the relevance limited.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 5 is an out-of-bounds write in LibVNC due to an integer overflow in a size calculation for a file transfer buffer. The target code performs many operations on lengths and offsets (e.g., `state->length`, `copy` calculations) and contains bounds checks (e.g., `if (copy > have) copy = have;`). While no identical integer overflow is evident in the provided snippet, the pattern of manipulating user-controlled lengths and performing bounds checks is highly relevant for vulnerability analysis of the inflate function. The domain differs (VNC vs. compression), but the low-level memory safety concern is similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 is an integer overflow leading to a buffer overflow in a DNS domain name parser. The target code performs arithmetic on lengths (e.g., `state->have + copy > state->nlen + state->ndist`) and uses user-controlled values for buffer sizes and copy operations. The pattern of calculating buffer positions and sizes based on input data is a shared vulnerability pattern. The specific overflow trigger is not present, but the class of vulnerability is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in libxml2 due to improper buffer management during multi-byte character processing. The target code also performs byte-by-byte processing of a bit/byte stream (e.g., `PULLBYTE()`, `zmemcpy`). However, the target code's logic is more focused on structured block decoding and state transitions rather than character encoding validation. The shared theme is processing untrusted input streams, but the mechanisms and flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 8 is a buffer overflow in a decompression module (ClamAV's Quantum decompressor) due to improper validation of match offsets against a sliding window. The target code is the `inflate` function in zlib, which is also a decompressor using a sliding window for LZ77 matches (see `MATCH` case, copy from `state->window`). It contains similar logic for validating distances (`state->offset > state->dmax`, `copy > state->whave`). The presence of the `INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR` compile-time option highlights the historical awareness of this exact class of vulnerability. The functionality, data structures, and vulnerability patterns are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is an out-of-bounds write in a multimedia framework's text import function due to mishandling of encoding conversion errors. The target code deals with binary compression formats, not text encoding. The error handling patterns and data types are dissimilar. The only vague similarity is processing input data into an output buffer.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a heap buffer overflow in glibc's glob due to an off-by-one allocation error. The target code uses fixed-size arrays (e.g., `hbuf[4]`) and allocated state structures but does not show dynamic allocation based on user input in the same way. Its buffer operations are primarily bounded by `have` and `left`. The relevance is limited to the general concept of buffer management, but the specific flaw pattern (off-by-one in allocation) is not apparent in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-37434_after_exclude_100:6cbc0133:vulspec": {
    "timestamp": "2026-01-17T00:11:47.570034",
    "cve_id": "CVE-2022-37434",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6cbc0133",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code is a decompression/inflation engine (zlib) with a completely different purpose (data decompression vs. pattern compilation). The vulnerability type (CWE-125) and trigger conditions (parsing embedded NULs) are not applicable to the stream-based, bitwise processing in inflate.c.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a heap buffer overflow in an image codec due to insufficient padding allocation. While both involve data decompression/processing, the domains differ (JPEG2000 vs. DEFLATE). The target code's vulnerability surface is more about integer overflows in length fields or window size calculations during stream processing, not static buffer sizing errors. Some reference value exists for general memory corruption patterns in decoders.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free in a network daemon related to inconsistent state management during error handling. The target code is a library function for data decompression with different memory management patterns (state machine within a single allocation). The flaw patterns (uninitialized pointers, double-free) are not evident in the provided inflate code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code also parses a stream format (DEFLATE/gzip) and must validate numerous length fields (e.g., `state->length`, `state->nlen`, window size). The pattern of missing bounds checks on attacker-controlled length values is conceptually similar, though the specific code structures differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 5 is an out-of-bounds write caused by an integer overflow in a length calculation leading to undersized allocation. The target code performs many arithmetic operations on length fields (e.g., `copy = state->length; if (copy > have) copy = have;`). Historical vulnerabilities in zlib/inflate often involve integer overflows/wraparounds in length calculations during window copying (e.g., CVE-2005-2096). The pattern is relevant, though the specific code location may differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 is an integer overflow leading to out-of-bounds write during domain name parsing. The target code contains multiple points where integer overflows could occur, particularly when calculating buffer sizes or copy lengths based on stream fields (e.g., `state->length`, `copy` calculations). The general vulnerability class (CWE-190 -> CWE-787) is highly relevant to decompression libraries, though the specific parsing context differs.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in an XML parser due to improper multi-byte character handling and buffer management. The target code handles bit streams, not character encodings. While both involve parsing complex formats, the vulnerability mechanisms differ significantly (character encoding state errors vs. bit buffer and length field errors). Limited reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 8 is a buffer overflow in a decompression module (Quantum within CAB) due to improper input validation of match operations against a sliding window. This is highly analogous to the target code, which is the inflate decompressor for DEFLATE, also using an LZ77-style sliding window. The `MATCH` case in the target code copies data from the window (`state->window`) based on `state->offset` and `state->length`. Insufficient validation of these values against window boundaries (`state->whave`, `state->wsize`) could lead to similar out-of-bounds writes. The vulnerability type and domain are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is an out-of-bounds write in a text encoding conversion utility due to unhandled error return codes. The target code does not perform text encoding conversion. Its error handling uses goto labels (`inf_leave`) and mode changes (`state->mode = BAD`). The flaw pattern (missing error check leading to buffer overflow) is not directly applicable to the structured state machine and explicit length checks in inflate.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a heap buffer overflow due to an off-by-one error in a path expansion function. The target code has careful length calculations and bounds checks (e.g., `if (copy > have) copy = have; if (copy > left) copy = left;`). While off-by-one errors are a general concern, the specific context (string manipulation vs. bit-stream decompression) reduces relevance. The reference value is limited to the importance of precise bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2021-41224_before_exclude_100:946b66a1:vulspec": {
    "timestamp": "2026-01-17T00:11:57.643721",
    "cve_id": "CVE-2021-41224",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "946b66a1",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a TensorFlow kernel for sparse tensor operations with input validation, while Case 1 is a cryptographic side-channel vulnerability in libgcrypt. The domains (machine learning vs. cryptography), vulnerability types (input validation/memory safety vs. timing side-channel), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing input data, but the contexts differ significantly. Case 2 is a stack buffer overflow in a Bluetooth configuration parser due to lack of bounds checking on hex string conversion. The target code performs Tensor shape validation but does not parse complex string formats. The core flaw (CWE-119) is similar in category, but the trigger conditions and data structures (tensors vs. strings) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 involves cryptographic algorithm handling and NULL pointer dereference in BIND9's DNSSEC. The target code performs basic tensor validation and delegates computation to a functor; it does not handle cryptography, complex key parsing, or have similar error cleanup paths that could lead to NULL dereference.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a resource management error (CWE-399) in a subtitle renderer due to inconsistent memory tracking. The target code validates inputs and delegates work, but does not show similar internal memory allocation patterns or state tracking inconsistencies. The domains (multimedia rendering vs. tensor algebra) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds write (CWE-787) in a JPEG 2000 encoder due to insufficient buffer validation. The target code includes input validation (OP_REQUIRES_ASYNC) for tensor shapes, which is a similar defensive pattern. However, the validation is on tensor metadata (shape) rather than buffer sizes during write operations, and the data domains are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an uninitialized pointer access in a Ruby interpreter's object copying mechanism. The target code is a C++ TensorFlow kernel with no object copying semantics, inheritance, or similar internal class handling. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-11743"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a numeric conversion error (CWE-189) leading to potential buffer overflow in libarchive. The target code uses TensorFlow's type-safe tensor abstractions, so direct integer conversion flaws are less likely. However, both involve processing external input data, and missing validation on numeric properties (like shape element counts) could be a conceptual parallel, though not directly seen in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a heap buffer overflow (CWE-119) in an image encoder due to insufficient allocation padding. The target code validates tensor shapes but delegates the actual computation (and potential internal allocations) to a functor. If the functor contains similar allocation logic with insufficient padding for tensor data, a parallel could exist, but the provided code does not show that detail.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an integer overflow (CWE-190) during file position calculation in an archive parser. The target code checks that `dense_shape_t.NumElements() != 0`, which is a basic numeric check, but does not show complex arithmetic on tensor dimensions that could overflow. The relevance is limited to the general theme of validating numeric inputs to prevent arithmetic issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a buffer overflow in a blur effect calculation due to malicious parameters. The target code validates tensor shapes but does not perform mathematical computations on the tensor contents itself. The functor it calls might, but the provided code does not expose that logic. The domains (subtitle effects vs. sparse tensor formatting) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      }
    ]
  },
  "CVE-2021-41224_after_exclude_100:85f799d9:vulspec": {
    "timestamp": "2026-01-17T00:12:15.674115",
    "cve_id": "CVE-2021-41224",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "85f799d9",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel cryptographic vulnerability (CWE-200/385) in libgcrypt. The target code is a TensorFlow kernel performing input validation and tensor operations. No cryptographic operations, secret data handling, or timing-sensitive logic is present.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow (CWE-119) in a string parsing function in BlueZ. The target code performs structured tensor validation using OP_REQUIRES_ASYNC checks. It does not parse untrusted strings or perform direct memory copies into fixed-size buffers.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves broken cryptography (CWE-327) leading to a NULL pointer dereference (CWE-476) in BIND9's DNSSEC. The target code performs shape and size validation for tensor inputs and calls a functor. No cryptographic algorithms, key processing, or complex error state cleanup is present.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error (CWE-399) in libass's text shaping module, involving inconsistent memory tracking. The target code validates inputs and delegates work. While both involve processing structured input, the target code's memory management is opaque within the called FunctorType.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14164 is an out-of-bounds write (CWE-787) in OpenJPEG due to insufficient buffer validation. The target code performs multiple input validations (OP_REQUIRES_ASYNC) on tensor shapes and sizes, which is a defensive pattern against similar issues. However, the core vulnerability (buffer overflow during marker writing) and domain (image codec vs. ML tensor op) are different. The validation logic is the primary similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-11743 is an uninitialized pointer access (CWE-824) in mruby's object copying. The target code works with initialized Tensor objects from the context and does not perform low-level object duplication or expose internal class structures.",
        "case_metadata": {
          "cve_id": "CVE-2018-11743"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2013-0211 is a numeric conversion error (CWE-189) in libarchive leading to a buffer overflow. The target code validates tensor dimensions (e.g., `indices_t.dim_size(0) == values_t.dim_size(0)`) which could prevent issues arising from mismatched sizes. However, the target code does not show explicit signed/unsigned conversions or direct buffer manipulation based on those sizes; the risk is deferred to the FunctorType.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 is a heap buffer overflow (CWE-119) in OpenJPEG due to insufficient allocation padding. The target code validates input tensor shapes and relationships, which is a first line of defense against malformed inputs that could cause downstream allocation issues. The similarity is in input validation, but the specific flaw (padding calculation) and domain are not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow (CWE-190) in libarchive's ISO parsing. The target code checks that `dense_shape_t.NumElements() != 0`, but does not perform complex arithmetic on tensor dimensions that could overflow. The validation pattern is similar, but the risk of integer overflow in subsequent calculations within the functor is not addressed in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7970 is a buffer overflow (CWE-119) in libass's blur calculation due to malicious parameters. The target code validates basic tensor properties but does not validate the *content* (values) of the tensors, which is where analogous malicious parameters would reside. The validation is structural, not semantic.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      }
    ]
  },
  "CVE-2022-1031_before_exclude_100:71a24b51:vulspec": {
    "timestamp": "2026-01-17T00:12:31.142264",
    "cve_id": "CVE-2022-1031",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "71a24b51",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 (CVE-2016-3179) involves a Use-After-Free vulnerability in a network daemon's state management. The target code is a static analysis function for extracting stack arguments/variables, performing string parsing and arithmetic operations. There is no dynamic memory allocation, pointer aliasing, or resource lifecycle management that could lead to a use-after-free. The functional domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 (CVE-2018-18313) involves an Out-of-Bounds Read in a regex compiler due to improper NUL byte handling. The target code performs string parsing (strstr, pointer decrements) on ESIL strings, which could theoretically lead to out-of-bounds reads if the string is malformed or the pointer arithmetic is incorrect. However, the target code's logic (searching for \"0x\" or commas) is simpler, and the context (static analysis vs. regex compilation) is different. The similarity is limited to the general risk of buffer over-reads during string parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 (CVE-2017-14151) is a heap buffer overflow due to incorrect size calculation for a compression buffer. The target code does not perform any dynamic memory allocation based on calculated sizes. It reads numbers from strings and performs bounds checks against `maxstackframe`. The code patterns and vulnerability mechanisms (allocation size miscalculation) are not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 (CVE-2011-1003) is a Double Free vulnerability during error handling in a file parser. The target code has a single `free(esil_buf)` at the end, with no duplicate freeing or complex error paths that could skip the free. The memory management pattern is trivial and not similar to the inconsistent state management leading to a double free in the historical case.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 (CVE-2016-7972) involves resource management errors and inconsistent tracking of allocated size in a text shaper. The target code does not manage its own allocated arrays or track sizes in a separate variable. It uses standard C library functions and performs arithmetic on offsets. The flaw pattern of a mismatch between actual and tracked allocation size is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 (CVE-2018-20750) is an Out-of-Bounds Write due to integer overflow in an allocation size calculation. The target code does not perform any memory allocations based on user-controlled integers. It uses `strdup` and fixed-size stack buffers. The integer operations are on offsets and are checked against `maxstackframe`. The vulnerability pattern of integer wrap-around leading to undersized allocation is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 (CVE-2019-20840) is an Out-of-Bounds Write due to unaligned memory access during WebSocket frame processing. The target code performs byte-wise pointer arithmetic and string comparisons. There are no operations that assume or require specific memory alignment (like casting to larger integer types). The flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 (CVE-2019-19012) involves an Out-of-Bounds Read due to integer overflow in pointer arithmetic. The target code performs pointer arithmetic (`addr--`) and uses the result for reading. While there is a loop guard (`addr >= esil_buf + 1`), if `esil_buf` is very short (e.g., 1 byte), `addr` could start at `esil_buf` and be decremented, potentially causing an underflow/wraparound on a 32-bit system if `esil_buf` is at a low memory address. This is a tenuous link. The primary operations are on string offsets, not large distances that would overflow a 32-bit integer.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Similar reasoning to Case 9. The vulnerability is an integer overflow leading to an out-of-bounds read. The target code's pointer decrement loop has a guard, but the guard's correctness depends on `ptr_end` being correctly located within `esil_buf`. If the string search (`strstr`) fails to find the expected pattern but returns a pointer near the start due to a malformed string, the guard might be insufficient. This is a potential edge case but not a direct parallel to the regex engine's distance calculation overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      }
    ]
  },
  "CVE-2022-1031_after_exclude_100:49c11c59:vulspec": {
    "timestamp": "2026-01-17T00:13:39.562094",
    "cve_id": "CVE-2022-1031",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "49c11c59",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2016-3179) is a Use-After-Free vulnerability in a network daemon's state management. The target code is a static analysis function for extracting stack arguments/variables, performing string parsing and arithmetic calculations. There is no dynamic memory allocation, pointer lifecycle management, or similar error handling paths that could lead to a use-after-free condition.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 (CVE-2018-18313) involves an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code parses ESIL strings and uses `strstr` and pointer arithmetic, but it carefully checks for `','` delimiters and the `\"0x\"` prefix. While there is string parsing, the logic is bounded and does not involve the same type of uncontrolled input parsing or character class decoding that leads to OOB reads in the regex engine.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 (CVE-2017-14151) is a heap buffer overflow due to incorrect size calculation for a compression buffer. The target code performs arithmetic (e.g., `frame_off = ptr - fcn->bp_off`) and has a bounds check against `maxstackframe`, but it does not perform any memory allocations based on these calculations. The risk of an integer overflow leading to an undersized buffer allocation is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 (CVE-2011-1003) is a Double Free vulnerability in a file parser during error cleanup. The target code has a single `free(esil_buf)` at the end, guarded by a NULL check after `strdup`. There are no complex error state cleanups or multiple freeing paths that could lead to a double free. The memory management pattern is simple and linear.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 (CVE-2016-7972) involves resource management errors due to inconsistent tracking of allocated size. The target code does not have a similar pattern of allocating a buffer and separately tracking its size in a way that could become desynchronized. Its operations are based on calculated offsets and string manipulation, not dynamic buffer management.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 (CVE-2011-3601) involves a buffer overflow due to a negative length value. The target code performs pointer arithmetic (`addr--`) within a loop bounded by the start of a buffer (`esil_buf`). While this is safer, it shares the conceptual similarity of moving a pointer backward based on certain conditions. However, the target code's loop condition includes a check `addr >= esil_buf + 1`, which provides a lower bound, making it fundamentally different from the unbounded negative index issue in the vulnerability case.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 (CVE-2018-20750) is an out-of-bounds write due to integer overflow in size calculation leading to undersized allocation. The target code has integer arithmetic (e.g., `frame_off = ptr - fcn->bp_off`) and a check against `maxstackframe`. While there is no allocation, an integer overflow/wraparound in the calculation of `ptr` or `frame_off` could bypass the `maxstackframe` check, leading to unexpected behavior later (e.g., in `get_stack_var` or `r_anal_function_set_var`). The connection is indirect and speculative.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 (CVE-2019-20840) is an out-of-bounds write due to unaligned memory access during WebSocket unmasking. The target code performs byte-wise pointer traversal and string comparisons. There are no operations that assume or require specific memory alignment (like 32-bit word access), which is the core flaw in the referenced case.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 9 (CVE-2019-19012) involves an out-of-bounds read due to integer overflow in pointer arithmetic. The target code performs pointer arithmetic (`addr--`) and uses the result (`addr`) for string operations (`strncmp`, `r_num_get`). While the loop has a bound check, if the initial `ptr_end` from `strstr` were incorrectly calculated or if the input string (`esil_buf`) were malformed, there is a potential for `addr` to point outside the intended buffer before the check `addr >= esil_buf + 1` is evaluated. This is a weaker, more conditional form of the pointer safety issue present in the vulnerability case.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Similar to Case 9, this CVE (also 2019-19012, different instance) involves integer overflow leading to out-of-bounds access. The relevance to the target code is the same: the target performs arithmetic on offsets (`ptr`, `frame_off`) and uses them in subsequent operations. An integer overflow/wraparound in the calculation of `ptr` (from `r_num_get` or `op->src[i]->delta`) could lead to a `frame_off` that bypasses the `maxstackframe` check, potentially causing issues in functions like `get_stack_var`. The connection is again indirect but represents a similar class of integer handling risk.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      }
    ]
  },
  "CVE-2019-18276_before_exclude_100:905b4d53:vulspec": {
    "timestamp": "2026-01-17T00:13:46.052840",
    "cve_id": "CVE-2019-18276",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "905b4d53",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve privilege management and the failure to properly drop privileges. CVE-2011-3603's core flaw is that the radvd daemon continues running with root privileges if privilege separation fails. The target code's purpose is to disable privilege mode (drop from root/elevated to a user), and it contains a failure path (the `setuid`/`setgid` calls) that could lead to the process retaining higher privileges than intended if the calls fail. The vulnerability type (CWE-250 - Execution with Unnecessary Privileges) and the trigger condition (failure of privilege-lowering system calls) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regular expression parser due to improper handling of NUL bytes. The target code performs privilege management via system calls (`setuid`, `setgid`) and has no string parsing, memory manipulation, or regex functionality. The vulnerability types and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2011-3601 is a buffer overflow in a network protocol parser (DNSSL option). The target code performs local privilege management with no network input processing, buffer operations, or parsing logic. The domains (network daemon vs. system utility privilege function) and vulnerability types (memory corruption vs. privilege state error) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2010-1642 is an out-of-bounds read in an SMB protocol authentication handler due to insufficient validation of a length field. The target code involves no network protocol parsing, length validation, or buffer reads. The functional domains and vulnerability patterns are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2010-1642"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a file transfer protocol handler. The target code performs simple integer comparisons and system calls for privilege management, with no complex integer arithmetic, memory allocation, or file transfer logic. The attack surfaces and flaw mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow in a pathname pattern matching function due to an off-by-one allocation error. The target code does not perform path expansion, pattern matching, or dynamic memory allocation. The code patterns and vulnerability class (memory corruption) are irrelevant to the privilege state management in the target.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a file content reading function during error handling. The target code has no dynamic memory allocation/deallocation, file reading, or complex error cleanup paths that could lead to double-free. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-16161 is a NULL pointer dereference in a regex library due to inconsistent error state handling. The target code does not manipulate pointers, parse complex input, or have a similar error state propagation mechanism. The flaw type and code context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2016-10156 involves incorrect permission and privilege handling during file creation, where a file may be created with overly permissive attributes (SUID/SGID) before being restricted. The target code deals with setting process privileges (UID/GID). While the specific operations differ (file vs. process attributes), both are in the domain of privilege/access control (CWE-264, CWE-250) and involve the correct sequencing and error handling of security-critical system calls. The similarity lies in the security domain and the potential for misapplied privileges.",
        "case_metadata": {
          "cve_id": "CVE-2016-10156"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-13001 is an out-of-bounds read in a network packet decoder due to insufficient bounds checking. The target code performs no packet decoding, buffer copying, or input validation from untrusted network data. The functional domains and vulnerability types are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      }
    ]
  },
  "CVE-2019-18276_after_exclude_100:eb7952c7:vulspec": {
    "timestamp": "2026-01-17T00:13:49.328117",
    "cve_id": "CVE-2019-18276",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "eb7952c7",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve privilege management and the risk of continuing execution with incorrect privileges after a failure in privilege-dropping operations. CVE-2011-3603's core flaw is a failure to properly handle privilege separation initialization, leading to CWE-250 (Execution with Unnecessary Privileges). The target code's `disable_priv_mode()` is a similar privilege-dropping function. While the specific failure path and system context differ, the vulnerability pattern (improper handling of setuid/setgid failures, potentially leaving the process with higher privileges than intended) is highly similar and provides valuable reference.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-18313 is a buffer over-read (CWE-125) in a regular expression parser due to improper handling of NUL bytes. The target code performs privilege management and system calls (`setresuid`, `setuid`, `setresgid`, `setgid`). There is no overlap in functionality, vulnerability type, or code patterns. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2011-3601 is a buffer overflow (CWE-119) in a network protocol parser for IPv6 Router Advertisement messages. The target code is a local privilege management function. The domains (network parsing vs. system security), vulnerability types (memory corruption vs. privilege logic), and code patterns are completely different. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2010-1642 is an out-of-bounds read (CWE-125) in an SMB protocol authentication handler due to insufficient validation of a length field. The target code performs privilege dropping via system calls with no complex parsing or length calculations. The vulnerability types and code contexts are fundamentally different. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2010-1642"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write (CWE-787) enabled by integer overflow (CWE-190) in a file transfer protocol handler. The target code involves simple system calls for setting UID/GID with no arithmetic, memory allocation, or protocol parsing. The vulnerability patterns are unrelated. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow (CWE-122) in a pathname pattern matching function due to an off-by-one allocation error. The target code performs privilege management with no string manipulation, pattern expansion, or dynamic memory allocation. The vulnerability mechanisms are entirely different. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double free (CWE-415) in a file content processing function due to incorrect memory ownership management during error handling. The target code has no dynamic memory allocation or deallocation. The vulnerability class (memory management error vs. privilege logic error) is different. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-16161 is a NULL pointer dereference (CWE-476) in a regular expression library due to inconsistent error state handling. The target code's error handling involves printing a message and potentially exiting, but does not manipulate complex error states or dereference function pointers based on them. The code domains and flaw patterns are dissimilar. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-10156 involves incorrect permission handling (CWE-264) during file creation, where a file is created with unsafe permissions before they are restricted. The target code deals with privilege management (setting UID/GID). The connection is in the broader domain of security-sensitive operations (file permissions vs. process privileges) and the potential for incorrect state if operations fail or are not atomic. However, the specific vulnerability mechanisms (TOCTOU in file creation vs. failure handling in setuid) are different, providing some reference value for secure privilege/state transition patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-10156"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-13001 is an out-of-bounds read (CWE-125) in a network protocol decoder due to insufficient bounds checking when copying data. The target code performs system calls with integer arguments and has no buffer copying or network data parsing. The vulnerability types and code patterns are unrelated. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      }
    ]
  },
  "CVE-2022-23645_before_exclude_100:010b21f2:vulspec": {
    "timestamp": "2026-01-17T00:13:52.607807",
    "cve_id": "CVE-2022-23645",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "010b21f2",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code performs basic header validation with length checks and does not involve complex string parsing or regex processing. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves integer handling issues (overflow/truncation) leading to out-of-bounds write. The target code uses integer operations (ntohl, ntohs) and compares lengths, which shares a theme of validating untrusted integer data from an external source (the blob header). However, the target code's checks appear robust against overflow/wraparound in this specific function, and the vulnerability class (OOB write) is different from the target's potential issues (OOB read or bad validation).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2018-14461 involves an out-of-bounds read due to insufficient validation of a length field in a network protocol TLV header. The target code validates a header length (`bh->totlen`) against an input `length` parameter. The pattern is very similar: parsing an untrusted structured header and ensuring internal consistency of length fields to prevent reading beyond buffer bounds. The core flaw pattern (missing/insufficient validation of a length field against actual data size) is identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free vulnerability related to error handling and memory management. The target code performs simple validation and returns error codes; it does not allocate or free memory, making the vulnerability type and code patterns irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-8860 involves improper buffer management and missing sentinel values. The target code checks buffer bounds but does not deal with string termination or complex buffer chunk management. There is a superficial similarity in the need to respect buffer lengths, but the specific flaw mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-25034 involves an integer overflow in length calculation leading to an out-of-bounds write. The target code performs arithmetic (via ntohl/ntohs) and length comparisons. While the target code's operations are unlikely to overflow (simple assignments and comparisons), the theme of validating attacker-controlled integers from a data blob is relevant. The vulnerability consequence (OOB write) is more severe than what the target code might allow (OOB read or bad parameter).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-12982 involves improper memory allocation due to unchecked header values. The target code validates header fields but does not perform any memory allocation itself. The similarity is limited to the act of validating header fields from untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2017-12898 involves an out-of-bounds read in a network protocol parser due to insufficient validation of length fields. This is highly analogous to the target code, which is a header validation function for a data blob (similar to a network packet). Both must ensure that the claimed length (`bh->totlen`) matches the actual available data (`length`) to prevent OOB reads in subsequent processing. The code patterns and vulnerability type are closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow during image encoding due to incorrect size calculation. The target code does not perform any memory writes or complex size calculations; it only reads and validates header metadata. The domains and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking during tag parsing. While both involve parsing structured data, the target code's logic is simple, linear validation, unlike the complex stateful parsing of XML. The specific flaw mechanism is not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-23645_after_exclude_100:a71eba38:vulspec": {
    "timestamp": "2026-01-17T00:14:20.278537",
    "cve_id": "CVE-2022-23645",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a71eba38",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code performs structured header validation with length checks and does not involve string parsing or regex compilation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves integer handling issues (CWE-190, CWE-197) leading to an out-of-bounds write. The target code performs integer comparisons (ntohl, ntohs) and size validations. While the vulnerability types differ (write vs. read/validation), both involve careful validation of integer fields from untrusted data to prevent memory corruption, making it a relevant reference for validation logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 3 involves an out-of-bounds read (CWE-125) due to insufficient validation of a TLV length field. The target code's core function is validating a blob header, checking `totlen` and `hdrsize` fields against the provided `length`. Both involve parsing a structured binary format and validating length fields to prevent reading out-of-bounds. The code patterns (checking `ntohl(bh->totlen) != length`) are conceptually similar to the missing validation in the LDP parser.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is a use-after-free vulnerability related to error handling and memory management. The target code performs pure validation with no dynamic memory allocation or pointer management, returning error codes directly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 involves improper buffer restrictions and missing sentinel values leading to overreads. The target code validates buffer bounds explicitly (`length < sizeof(bh)`). While both concern buffer safety, the vulnerability mechanism (missing termination) and context (string functions vs. structured binary parsing) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 involves an integer overflow (CWE-190) in length calculation leading to an out-of-bounds write. The target code uses `uint32_t` and `uint16_t` lengths and performs comparisons. Although the target code's checks seem safe from overflow (simple comparisons, not arithmetic), it shares the theme of validating untrusted length fields from a binary header, which is a common source of integer-related vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves a memory allocation failure due to unchecked header values violating a format spec. The target code validates header fields but does not perform any memory allocation based on those values; it only checks and returns offsets.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 8 involves an out-of-bounds read (CWE-125) due to insufficient validation of length fields in a network protocol parser. This is highly analogous to the target code, which is a validation function for a binary blob header. Both parse untrusted binary data and must validate length fields (`totlen`, `hdrsize`) against the actual available data (`length`) to prevent reads beyond buffer boundaries. The code pattern is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a heap buffer overflow due to insufficient padding allocation during an encoding operation. The target code performs read-only validation and does not involve any memory allocation or writing based on the validated data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 involves an out-of-bounds read in an XML parser due to insufficient bounds checking. The target code also aims to prevent out-of-bounds reads through bounds checking. However, the domains (textual XML parsing vs. structured binary header validation) and the specific flaw patterns (parser state corruption vs. integer field validation) are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2021-37665_before_exclude_100:d93eea82:vulspec": {
    "timestamp": "2026-01-17T00:15:20.231911",
    "cve_id": "CVE-2021-37665",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d93eea82",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel timing attack in cryptographic operations. The target code performs quantization range calculations with OpenMP parallelism but does not handle secret data or require constant-time execution. The vulnerability types and contexts are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-7970 is a buffer overflow in subtitle blur calculations. The target code involves numerical computations on tensor data but includes bounds checks (OP_REQUIRES) and uses standard containers (std::vector). While both process arrays, the flaw patterns (lack of bounds check vs. presence of checks) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-7837 is a stack buffer overflow in string parsing. The target code parses tensor data with size validation and uses heap allocation. Both process input data, but the vulnerability mechanism (stack overflow from untrusted string vs. validated tensor dimensions) is dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2011-1178 is an integer overflow leading to heap overflow in image processing. The target code performs arithmetic (multiplication, division) that could theoretically overflow, but uses float/double types and the values are derived from validated tensor dimensions. The integer overflow risk is lower but present in scale calculation.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability in a database. The target code performs numerical computations without any privilege or access control logic. The domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error in memory tracking. The target code uses standard memory allocation (OP_REQUIRES_OK for output tensors) and vectors without complex manual tracking. Both involve memory, but the flaw pattern (inconsistent size tracking) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-7163 is an integer overflow in memory allocation for image decoding. The target code allocates memory based on the `depth` variable, which is validated against input tensor dimensions. The risk of integer overflow in allocation size (e.g., `depth * sizeof(float)`) exists but is mitigated by prior validation and typical tensor size limits.",
        "case_metadata": {
          "cve_id": "CVE-2016-7163"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-5844 is an integer overflow in file position calculation. The target code calculates `scale * static_cast<float>(abs_max) / static_cast<float>(1L << 31)`. While using floats reduces integer overflow risk, the preceding operations with `int32_t` could overflow if inputs were extreme, though they are derived from tensor data. The pattern of arithmetic on untrusted sizes is similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-12973 involves uncontrolled resource consumption due to mismatched dimensions and data size. The target code validates tensor dimensions (OP_REQUIRES) but performs a loop over `depth` which is derived from `input_max.NumElements()`. If an attacker controls the input tensors, they could cause a large `depth` leading to expensive parallel computations. The pattern of processing data based on unvalidated or user-controlled size is similar, though the target code has basic validation.",
        "case_metadata": {
          "cve_id": "CVE-2019-12973"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-7515 is an out-of-bounds read due to integer overflow in pixel calculations. The target code reads from `input_min_data[i]` and `input_max_data[i]` within the loop bound `depth`. The risk of out-of-bounds access is low due to the prior size checks, but the pattern of indexing arrays based on calculated or derived sizes is conceptually similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7515"
        }
      }
    ]
  },
  "CVE-2021-37665_after_exclude_100:bc02801d:vulspec": {
    "timestamp": "2026-01-17T00:15:28.810979",
    "cve_id": "CVE-2021-37665",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bc02801d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel timing attack in cryptographic operations. The target code performs quantization calibration with parallel loops but does not handle secret data where constant-time execution is critical. The vulnerability types (CWE-200/385 vs. potential numeric issues) and domains (cryptography vs. ML tensor processing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7970 is a buffer overflow in a subtitle blur effect calculation due to unchecked mathematical operations on untrusted input. The target code validates tensor dimensions and sizes via OP_REQUIRES, performs numeric calculations within allocated vectors, and does not involve buffer writes based on unvalidated coefficients. The attack surface (file parsing vs. internal tensor computation) and flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow in a configuration parser due to unsafe string operations. The target code processes tensor data in a fixed, validated structure, uses standard C++ containers (vector), and performs arithmetic operations, not string parsing or unbounded memory copies. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1178 involves an integer overflow leading to a heap buffer overflow during image size calculation. The target code performs arithmetic operations (multiplication, division, std::abs) on signed integers (int32_t) and floats. While there is a potential for integer overflow in `abs_max` calculation or scaling, the code uses 64-bit indices and the values are derived from already-allocated tensor data, not directly from untrusted file headers. The context and immediate risk are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability in a database query planner. The target code is a computational kernel with no privilege checks or multi-user context. The CWE (284) and domain (database security vs. numerical computation) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error due to inconsistent memory tracking in a text shaper. The target code allocates memory via `ctx->allocate_output` and uses a `std::vector` with deterministic size (`depth`). There is no apparent mismatch between allocated and tracked resources. The flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7163 involves an integer overflow during memory allocation size calculation leading to out-of-bounds read. The target code does not perform dynamic memory allocation based on calculated sizes; it allocates a fixed-size vector based on `depth` (validated earlier). However, there is a similar underlying concern: arithmetic on signed integers (`min_per_channel`, `max_per_channel`, `abs_max`) could, in theory, overflow if input values were extreme, affecting the `scale * abs_max` calculation. The connection is indirect.",
        "case_metadata": {
          "cve_id": "CVE-2016-7163"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow in file position calculation within an archive parser. Similar to case 4 & 7, the target code performs integer arithmetic (`abs_max` calculation, multiplication in `ranges[i]`). The risk is that if `min_per_channel` or `max_per_channel` is `INT32_MIN`, `std::abs(INT32_MIN)` is undefined behavior (overflow on two's complement). This is a more specific integer overflow hazard than the file position calculation, but the core CWE-190 theme is present.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-12973 is an uncontrolled resource consumption (CWE-400) due to missing validation between advertised dimensions and actual data. The target code validates tensor dimensions upfront (NHWC format, channel count matching depth). The parallel loop over `depth` is bounded and not dependent on maliciously crafted data streams. The only mild similarity is the use of a loop for processing per-channel data, but with proper bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2019-12973"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7515 is an out-of-bounds read due to integer overflow in pixel allocation calculations. As with cases 4, 7, and 8, the connection is the potential for integer issues in pre-allocation calculations. The target code's `abs_max` calculation and the subsequent floating-point multiplication/division could produce unexpected values if inputs are extreme, but this is less directly tied to memory corruption than in the RLE decoder case. The relevance is limited to the broad category of numeric validation pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2016-7515"
        }
      }
    ]
  },
  "CVE-2022-31796_before_exclude_100:5f8d5a93:vulspec": {
    "timestamp": "2026-01-17T00:15:39.005902",
    "cve_id": "CVE-2022-31796",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5f8d5a93",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve image processing libraries and potential integer overflows in memory allocation calculations (e.g., `m_ucCount*8`). However, CVE-2016-6823 is specifically about BMP file header validation leading to an integer overflow in a size calculation, while the target code performs internal buffer allocation for a JPEG decoder component. The vulnerability patterns (unchecked multiplication) are similar but the context and attack surface (external file parsing vs. internal state preparation) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-6823"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free in a network service daemon (MiniSSDPd) related to error handling and pointer management. The target code is an image decoding function in a library, performing memory allocation and initialization. The domains (networking vs. image processing), vulnerability types (use-after-free vs. potential overflow/underallocation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve image decoders and potential issues arising from calculations based on input parameters (like `m_ucCount` derived from image components). CVE-2016-7515 is an out-of-bounds read in an RLE decoder due to integer overflow in pixel calculations. The target code has multiplications (`m_ucCount*8`) that could overflow if `m_ucCount` is large, but it's more about internal buffer setup than parsing untrusted file data directly. The similarity is in the arithmetic operation risk.",
        "case_metadata": {
          "cve_id": "CVE-2016-7515"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both are in image codec libraries (JPEG/JPEG2000) and involve memory allocation for codec components. CVE-2017-14151 is a buffer overflow due to insufficient padding calculation in OpenJPEG. The target code allocates buffers (`m_ppDecodingMCU`, `m_ppUpsampler`) based on component counts. The relevance lies in the pattern of allocating memory based on image parameters, but the specific flaw (padding miscalculation) is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-1000222 is a Double Free in libgd's BMP handling during error cleanup. The target code shows allocation and initialization but no explicit free operations. Both are in image libraries, but the vulnerability mechanism (double free during error handling) is not visible in the provided function, which focuses on preparation and allocation.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve image format conversion/decoding and memory allocation based on image parameters. CVE-2017-12982 is an allocation failure/overflow due to unchecked BMP header values in OpenJPEG. The target code uses `m_ucCount` (likely from image header) in allocation size calculations. The similarity is in using untrusted input (image component count) for allocation, but the target code does not show the validation (or lack thereof) for `m_ucCount`.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-8692 is a Divide-by-Zero in JasPer due to invalid sampling factors. The target code uses component sampling factors (`sx`, `sy`) but only for comparison and creating upsamplers, not as divisors. The domain is similar (image codecs using sampling factors), but the vulnerability type is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-9560 is a stack buffer overflow in JasPer due to insufficient bounds checking on an array index. The target code performs heap allocations and does not show obvious array indexing without bounds checks. Both are in JPEG2000-related code, but the vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-9560"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are in image decoders. CVE-2016-7514 is an out-of-bounds read in ImageMagick's PSD decoder due to improper validation of bit depth. The target code prepares internal structures for decoding. The connection is tenuous, limited to the broader domain of image decoder resource preparation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7514"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-11932 is a Double Free in a GIF decoder due to handling zero-size allocations. The target code allocates memory based on `m_ucCount`. If `m_ucCount` were zero, the allocations would be zero-sized (`AllocMem(0)`), which could be problematic depending on the allocator's behavior, similar to the GIF case. However, this is a speculative link, and the primary vulnerability mechanism (double free) is not directly present.",
        "case_metadata": {
          "cve_id": "CVE-2019-11932"
        }
      }
    ]
  },
  "CVE-2022-31796_after_exclude_100:e294828b:vulspec": {
    "timestamp": "2026-01-17T00:15:43.553668",
    "cve_id": "CVE-2022-31796",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e294828b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image processing and memory allocation, but the vulnerability types differ significantly. CVE-2016-6823 is an integer overflow leading to out-of-bounds write during BMP dimension calculations. The target code performs memory allocation based on component counts (m_ucCount) but does not show the same arithmetic on user-controlled dimensions that could overflow. The core flaw pattern (unchecked multiplication) is not directly present.",
        "case_metadata": {
          "cve_id": "CVE-2016-6823"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free/double-free in a network service daemon (MiniSSDPd) related to error handling and pointer management. The target code is image encoding preparation in a graphics library. The domain, functionality, and vulnerability pattern (memory allocation error path cleanup) are fundamentally different. No clear parallels in code structure or flaw mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in image processing domains (RLE decoder vs. hierarchical bitmap encoder). CVE-2016-7515 is an out-of-bounds read due to integer overflow in pixel calculations. The target code allocates memory based on component count, but the multiplication (m_ucCount * 8) uses a small fixed multiplier and a count likely derived from image components, not directly from untrusted image dimensions. The risk of integer overflow here is lower and the pattern is not identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-7515"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve JPEG 2000/related image encoding and memory allocation for encoding components. CVE-2017-14151 is a heap buffer overflow due to insufficient padding allocation for code blocks. The target code allocates memory for downsamplers and MCU lines, and improper calculation of allocation sizes (e.g., based on subsampling factors sx, sy) could lead to similar buffer overflow issues. The domain similarity and memory allocation for encoding structures provide reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-1000222 is a double-free in libgd's BMP compression error path. The target code allocates memory but does not show explicit free operations or error handling paths that could lead to double-free. The functionality (BMP compression vs. hierarchical bitmap encoding preparation) and the specific vulnerability pattern are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image format processing and memory allocation. CVE-2017-12982 is an allocation failure/unchecked header value issue in BMP-to-JPEG2000 conversion. The target code allocates based on internal component counts and subsampling factors, which could be analogous to unchecked header values, but the direct link to malicious file input and allocation failure leading to subsequent issues is not clearly demonstrated in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-8692 is a divide-by-zero in JasPer due to invalid sampling factors (XRsiz/YRsiz). The target code uses subsampling factors (sx, sy) from image components. While both handle sampling factors, the vulnerability type (divide-by-zero) is not present in the target code, which uses sx, sy only for condition checks (sx > 1 || sy > 1) and as parameters to CreateDownsampler. The potential for zero values causing issues is not evident here.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-9560 is a stack buffer overflow in JPEG-2000 wavelet band processing due to insufficient bounds checking. The target code performs heap allocations and uses loops over component counts. While both are in image codec domains, the vulnerability pattern (fixed-size stack array overflow) is not present. The target code's array accesses (e.g., m_ppDownsampler[i]) are bounded by m_ucCount, which is not shown to be derived from untrusted data without validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-9560"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in image processing (PSD decoder vs. bitmap encoder). CVE-2016-7514 is an out-of-bounds read due to improper validation of bit depth. The target code reads component subsampling factors (sx, sy) from the image frame, which could be analogous to reading untrusted parameters. However, the specific vulnerability type (OOB read) and the code pattern (pixel data reading loops) are not directly comparable to the allocation and preparation logic shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-7514"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-11932 is a double-free in a GIF decoder due to zero-size reallocation handling. The target code uses AllocMem and memset, not realloc. The domain (GIF animation vs. hierarchical bitmap encoding) and the core flaw (zero-size allocation semantics) are not relevant to the provided code, which allocates based on positive counts (m_ucCount, m_ucCount * 8).",
        "case_metadata": {
          "cve_id": "CVE-2019-11932"
        }
      }
    ]
  },
  "CVE-2022-0407_before_exclude_100:52c00f72:vulspec": {
    "timestamp": "2026-01-17T00:16:13.232966",
    "cve_id": "CVE-2022-0407",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "52c00f72",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a line copying function in an editor (likely Vim) that handles whitespace trimming. The domain (text editor vs. regex engine), vulnerability type (OOB read vs. potential buffer overflow/underflow), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management. The target code performs straightforward memory allocation and string manipulation with no complex state or error paths that could lead to a use-after-free. The attack surfaces (network protocol vs. internal editor operation) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to multi-byte character handling. The target code also manipulates strings and could theoretically have an off-by-one error if `bd->textlen` or pointer arithmetic is miscalculated, especially with the `while` loop that decrements `s`. However, the domain (XML parsing vs. line copying) and specific trigger (encoding sequences) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1838 is an out-of-bounds read in XML end tag parsing. The similarity is limited to both pieces of code processing structured data (text line vs. XML) and requiring careful bounds checking. The target code's loop condition `s > 0` and pointer decrement `pnew--` could be a source of an off-by-one error if `s` becomes negative or if `mb_head_off` behaves unexpectedly, leading to an OOB write (to `*pnew`) rather than a read.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a filesystem's node ID management. The target code is a simple, synchronous function for copying a line into an array. There is no concurrency, shared state, or resource lifecycle management that could lead to a race condition.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write. The target code has an integer addition (`bd->startspaces + bd->endspaces + bd->textlen + 1`) for allocation size. If these values are attacker-controlled and large, they could overflow, leading to a buffer overflow when `vim_memset` or `mch_memmove` is called. This is the most relevant vulnerability type so far, but the context (VNC file transfer vs. editor line copy) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read due to insufficient validation of a length field in a network protocol. The target code does validate input lengths indirectly via the `alloc` size, but the `while` loop's condition `*(bd->textstart + s - 1)` could read out-of-bounds if `s` is incorrectly calculated or if `bd->textstart` is not properly bounded. The flaw pattern (missing bounds check on a calculated index) is similar, but the domain is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1835 is a use-after-free in an XML attribute parser. The target code allocates memory and stores a pointer in an array (`y_current->y_array[y_idx] = pnew`). If this array is later accessed after the memory has been freed (e.g., due to an error elsewhere), it could be a use-after-free. However, the code shown does not demonstrate this complex state management or cleanup. The primary concern in the target code is immediate buffer overflows, not lifetime issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-15166 is improper input validation leading to potential memory corruption in a network parser. The target code's vulnerability would stem from improper validation of the `bd` structure fields (`startspaces`, `endspaces`, `textlen`) or the `textstart` pointer. If these are derived from untrusted input without validation, similar memory safety issues could arise. The pattern of trusting external input parameters is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition in kernel memory policy code. The target code has no locking, concurrency, or resource sharing mechanisms. It is a simple function operating on its local parameters and a global array.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      }
    ]
  },
  "CVE-2022-0407_after_exclude_100:a076e57e:vulspec": {
    "timestamp": "2026-01-17T00:16:59.847872",
    "cve_id": "CVE-2022-0407",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a076e57e",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regex engine due to improper NUL byte handling. The target code is a string copy/formatting function in an editor (likely Vim). The vulnerability types (CWE-125 vs. potential buffer overflow/underflow), domains (parsing vs. UI/editing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a Use-After-Free in a network daemon's memory management. The target code performs a straightforward memory allocation and copy operation with no complex state or cleanup logic that could lead to a UAF. The attack surfaces and flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an out-of-bounds read in an XML parser due to multi-byte character handling. The target code also performs buffer operations and pointer arithmetic. There is a superficial similarity in the need for careful bounds management when moving pointers (`pnew += ...`), but the context (string formatting vs. complex parser state) and specific flaw (encoding errors vs. potential integer overflows/underflows) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is another libxml2 out-of-bounds read during end tag parsing. Similar to Case 3, the only connection is the general concept of ensuring pointer arithmetic stays within bounds. The target code's logic is simpler and more self-contained, lacking the complex state machine of a parser.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a race condition in a kernel filesystem's ID allocator. The target code shows no evidence of concurrency, shared state, or atomicity concerns. It is a simple, synchronous function.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 involves an integer overflow leading to an out-of-bounds write during a memory allocation calculation. The target code has a critical similarity: it calculates an allocation size as `bd->startspaces + bd->endspaces + bd->textlen + 1`. If these fields are controlled by an attacker and are large enough, they could overflow the integer argument to `alloc()`, leading to a buffer overflow when `mch_memmove` is called. The pattern of an unchecked sum leading to allocation is a key parallel. The relevance is not higher because the target code's context (text editor) and specific flaw manifestation may differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does perform length-based operations (`bd->textlen`), but it uses this length directly from a trusted internal structure (`bd`) rather than parsing untrusted data. The risk of an out-of-bounds read/write exists if `bd->textlen` is corrupted, but the flaw pattern (missing validation of parsed input) is not directly mirrored in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a Use-After-Free in an XML parser due to complex state management. The target code allocates memory and stores a pointer in an array, but there's no visible logic for freeing or reusing that memory within the function, making a UAF pattern unlikely from this snippet alone.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an improper input validation leading to potential memory issues in a packet parser. The target code implicitly trusts the integer fields in `bd`. If `bd` is populated from untrusted data (e.g., a malformed file), similar validation failures could occur. However, the code pattern (direct structure field usage vs. parsing a byte stream) is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a Use-After-Free caused by a race condition in kernel memory policy. The target code is a simple, non-concurrent user-space function with no locking or shared resource management, sharing almost no characteristics with the case.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      }
    ]
  },
  "CVE-2021-29552_before_exclude_100:1c18874c:vulspec": {
    "timestamp": "2026-01-17T00:17:11.024092",
    "cve_id": "CVE-2021-29552",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1c18874c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a TensorFlow segment aggregation operation handling string tensors, while CVE-2015-7511 is a cryptographic side-channel vulnerability in libgcrypt. The vulnerability type (CWE-200/385), domain (cryptography), and code patterns (constant-time operations) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability in PostgreSQL's query planner involving privilege checks on system catalogs. The target code performs tensor computations without any privilege or access control logic. Different domains (database vs. tensor computation) and vulnerability types (CWE-284 vs. potential memory/validation issues).",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-14152 is a use-after-free vulnerability in OpenJPEG's image parameter handling. The target code manages TensorFlow tensors with careful allocation but doesn't involve complex state management or pointer manipulation that could lead to use-after-free. Some similarity in input validation patterns, but core vulnerability mechanism differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2009-3909 involves integer overflow in image dimension calculations leading to buffer overflow. The target code has integer calculations for strides and offsets (big_stride, small_stride) and performs bounds checking on segment_id values. While both involve bounds validation, the specific integer overflow pattern and domain (image parsing vs. tensor computation) differ.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-25035 is an out-of-bounds write in a DNS token parser due to incorrect parenthesis counting. The target code has array indexing with bounds checking (flat_segment_id(i) < num_segments) and calculates offsets. Some similarity in bounds validation concerns, but the parsing logic and vulnerability trigger (parenthesis counting vs. segment ID validation) are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 involves integer overflow in archive file position calculations. The target code calculates strides and offsets (big_stride, small_stride, relative_offset_set) which could potentially overflow if input dimensions are large. Both involve position/offset calculations that need careful bounds checking, though the specific context differs (archive parsing vs. tensor operations).",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-7837 is a stack buffer overflow in Bluetooth configuration parsing. The target code uses TensorFlow's tensor abstraction with flat() accessors rather than raw buffer manipulation. While both process input data, the memory management patterns (high-level tensor vs. low-level buffer) and vulnerability mechanisms differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-14151 is a heap buffer overflow in JPEG 2000 encoding due to insufficient padding allocation. The target code allocates output tensors based on calculated shapes and performs bounds checking. Some similarity in memory allocation based on calculated sizes, but the specific padding calculation issue doesn't apply to the tensor allocation pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-8692 involves divide-by-zero from invalid sampling factors in image parsing. The target code performs division-like operations through stride calculations but doesn't have explicit division that could divide by zero. Both involve validating input parameters that affect subsequent computations, but the specific vulnerability pattern differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-13219 involves integer overflow in audio codebook calculations. The target code has integer calculations for strides, offsets, and loop bounds that could potentially overflow with malicious input dimensions. Both involve mathematical computations on user-provided parameters that need overflow checking, though the domains differ (audio decoding vs. tensor operations).",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2021-29552_after_exclude_100:605823e9:vulspec": {
    "timestamp": "2026-01-17T00:17:22.258305",
    "cve_id": "CVE-2021-29552",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "605823e9",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs string aggregation based on segment IDs and has no cryptographic operations, side-channel considerations, or secret-dependent branching. CWE-200/385 is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a tensor computation kernel with no database query planning, privilege checks, or access control logic. CWE-284 is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Both involve input validation and bounds checking, but the target code's checks (OP_REQUIRES) appear robust for indices and dimensions. The core flaw (Use After Free) and domain (image parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The target code involves index calculations (`output_index`, `offset`) based on user-controlled `segment_id` and `num_segments`. While direct integer overflow is not obvious, miscalculations could lead to out-of-bounds access, similar to the integer overflow -> buffer overflow chain in CVE-2009-3909 (CWE-190 -> CWE-122). The pattern of validating inputs before using them in size calculations is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing structured input and writing to buffers. However, the target code's logic for building output strings is more straightforward, using validated indices for array access. The complex nested parenthesis parsing flaw (CWE-787) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Similar to Case 4, the core concern is integer arithmetic in offset calculations (`output_index`, `offset`) which, if flawed, could lead to out-of-bounds access. The target code uses `int64` for strides and offsets, which helps, but the relevance lies in the pattern of calculating positions from user data.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Both process input data, but the target code does not involve hex parsing or stack-based buffers. The memory operations are on pre-allocated tensors with bounds checked via `OP_REQUIRES`. The buffer overflow flaw (CWE-119) pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Both involve writing data to allocated buffers. However, the target code's buffer (`output_flat`) is a flat tensor, and writes are performed via indexed access that is validated earlier. The specific flaw of insufficient padding allocation (CWE-119) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code contains no division operations. The validation checks are for equality and range, not for non-zero divisors. CWE-369 is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The primary connection is the potential for integer issues in index calculations (`output_index`, `offset`, `flat_segment_id.size()`), which could conceptually lead to out-of-bounds access. However, the target code uses 64-bit integers and has explicit range checks for `flat_segment_id(i)`, making integer overflow less likely than in the audio codebook calculations of CVE-2019-13219.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2022-29694_before_exclude_100:ab5ff0c7:vulspec": {
    "timestamp": "2026-01-17T00:17:38.119487",
    "cve_id": "CVE-2022-29694",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ab5ff0c7",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 1 (CWE-416 Use After Free) involves complex state management and error handling leading to UAF. The target code shows a simple memory block free function with direct reclamation. While both deal with memory deallocation, the trigger conditions (error paths vs. direct call), code patterns (complex state vs. straightforward removal), and vulnerability type (UAF vs. potential double-free if `reclaim_ramblock` is misused) are only superficially similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 (CWE-119 Buffer Overflow) is about insufficient allocation leading to overflow during encoding. The target code is purely about memory deallocation. The domain (image encoding vs. memory management), vulnerability type (overflow vs. free), and code patterns (allocation calculation vs. list removal) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 (CWE-415 Double Free) in ClamAV involves inconsistent state during error handling. The target code's `qemu_ram_free` function, if called multiple times on the same `block` (e.g., due to missing state cleanup or race conditions), could lead to a classic double-free vulnerability. The code pattern of a `free`-like function is directly comparable. The relevance is not higher because the target code lacks the specific error path complexity described in the case.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 (CWE-787 Out-of-bounds Write) stems from integer overflow in allocation. The target code performs deallocation only. The vulnerability type (write corruption vs. free), root cause (integer error vs. state management), and functional domain (network protocol vs. memory subsystem) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 (CWE-20 Input Validation) leads to buffer overflow during decompression. The target code is a memory deallocator with no input parsing or buffer writing logic. The domains and vulnerability mechanisms are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 (CWE-362 Race Condition) in F2FS involves non-atomic operations on linked lists (`QLIST`) managing resources (nids). The target code modifies a linked list (`QLIST_REMOVE`) and a global pointer (`uc->ram_list.mru_block`) without any visible locking. If this function is called concurrently without proper synchronization, it could lead to race conditions causing use-after-free, double-free, or corruption of the list. The code pattern of list manipulation is similar, though the target code's context (QEMU RAM blocks vs. F2FS nids) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CWE-125 Out-of-bounds Read) involves parsing regex patterns with NUL bytes. The target code does not read or parse any data; it only frees a memory block. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 (CWE-787 Out-of-bounds Write) due to unaligned memory access during data decoding. The target code performs no data writing or decoding. The vulnerability types and code operations are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 (CWE-415 Double Free) in libguestfs involves a cleanup function that can double-free memory due to ownership confusion. This is highly analogous to the target `qemu_ram_free` function. If the calling code does not properly nullify the `block` pointer after freeing, or if error paths lead to duplicate calls, a double-free occurs. The code pattern is very similar: a function tasked with freeing a resource. The score is not higher because the specific trigger in the case (file reading error path) is not visible in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 (CWE-787 Out-of-bounds Write) during text encoding conversion with error handling issues. The target code does not handle input data, perform conversions, or write to buffers. The core flaw is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2022-29694_after_exclude_100:d0483ac9:vulspec": {
    "timestamp": "2026-01-17T00:18:03.523284",
    "cve_id": "CVE-2022-29694",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d0483ac9",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 1 (CWE-416: Use After Free) involves memory management errors, but the target code's primary concern is direct freeing and reclamation of a RAMBlock. The target code does not show evidence of pointer retention or reuse after free, which is the core of Use After Free. The commented-out RCU callback hints at concurrency/ordering issues, but the direct call to `reclaim_ramblock` simplifies the flow compared to the complex error handling and state inconsistency described in the case.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 (CWE-119: Buffer Overflow) is about improper buffer sizing and overflow during data writing. The target code performs memory block deallocation, not buffer allocation or data writing. The domains (image encoding vs. virtual machine memory management) and the nature of the flaw are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 (CWE-415: Double Free) is directly relevant to the target code's domain of memory management. The target function `qemu_ram_free` is responsible for freeing a RAMBlock. The presence of commented-out RCU mechanisms (`call_rcu`) and the direct call to `reclaim_ramblock` suggests potential for incorrect lifecycle management (e.g., freeing the same block twice if not properly protected). However, the target code snippet itself does not show the specific error path or state inconsistency that leads to a double free.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 (CWE-787: Out-of-bounds Write via Integer Overflow) involves a flaw in allocation size calculation leading to heap corruption. The target code is a deallocation function. The vulnerability type, trigger conditions (malformed network requests), and code patterns (integer arithmetic) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 (CWE-20: Improper Input Validation leading to buffer overflow) is centered on parsing and decompressing malicious archive data. The target code is a memory deallocation routine in a system emulator. There is no functional overlap.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 (CWE-362: Race Condition) has relevance due to the target code's context. The function manipulates a global linked list (`QLIST_REMOVE_RCU`) and a global MRU pointer (`uc->ram_list.mru_block`) which could be accessed concurrently. The commented-out `smp_wmb()` and `call_rcu` indicate the original design considered concurrency and memory ordering, but the current simplified flow (`reclaim_ramblock` called directly) might have introduced or omitted necessary synchronization. The pattern of non-atomic list operations under potential concurrent access is a shared concern.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CWE-125: Out-of-bounds Read) involves parsing regex patterns with embedded NULs. The target code performs memory deallocation and list removal. No similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 (CWE-787: Out-of-bounds Write due to alignment issues) is specific to network data decoding and unaligned memory access. The target code's operations are on internal data structures (pointers, lists) and do not involve parsing untrusted data bytes or alignment assumptions.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 9 (CWE-415: Double Free) is highly relevant in terms of vulnerability class, similar to Case 3. The context (libguestfs vs. QEMU/qemu) both involve low-level system/virtualization software where resource management is critical. The flaw patternimproper cleanup leading to double freeis a direct risk for any function like `qemu_ram_free`. The target code's simplicity (direct reclamation) must be analyzed in the broader context of how `block` pointers are managed and validated before being passed to this function.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 (CWE-787: Out-of-bounds Write in text encoding conversion) involves string processing and buffer copying. The target code deals with freeing large memory blocks and list manipulation. No meaningful similarity in functionality or flaw pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2021-37687_before_exclude_100:6a2f429c:vulspec": {
    "timestamp": "2026-01-17T00:18:46.386878",
    "cve_id": "CVE-2021-37687",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6a2f429c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a tensor gather operation in a machine learning framework, while Case 1 involves a buffer over-read in a Perl regex engine due to NUL byte handling. The domains (ML inference vs. text parsing), vulnerability types (potential bounds issues vs. specific out-of-bounds read), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a side-channel vulnerability (CWE-385) in a cryptographic library's elliptic curve implementation. The target code is a straightforward data indexing operation with no cryptographic elements or secret-dependent control flow. The attack surfaces (physical EM leakage vs. tensor data manipulation) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an access control flaw (CWE-284) in a database query planner's privilege checking. The target code performs a mathematical array operation with no authentication, authorization, or privilege concepts. The functional domains (database security vs. numerical computation) are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 involves a resource management error (CWE-399) in a subtitle renderer due to inconsistent memory tracking. The target code does not show explicit memory management. However, both involve processing structured input data (tensors/subtitles), and improper validation of indices/positions in the target `Gather` function could lead to resource issues, but the mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 combines a broken crypto algorithm (CWE-327) with a NULL pointer dereference (CWE-476) in a DNS security module. The target code has no cryptographic operations, algorithm negotiation, or complex error cleanup paths that could lead to NULL dereference in a similar way.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 is an integer overflow (CWE-190) when calculating file positions in an archive parser. The target `Gather` function uses indices (`positions`) to select data from an `input` tensor. If `positions` contain large or negative values, and bounds checking is inadequate in the underlying `optimized_ops::Gather` implementation, similar integer overflow/wraparound issues could occur when computing memory offsets, leading to out-of-bounds access. The core pattern of using untrusted indices to calculate offsets is similar, though the domains differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 is a bounds restriction issue (CWE-119) in a font glyph processor due to unsafe arithmetic on untrusted indices. This is conceptually similar to the target `Gather` operation, which uses the `positions` tensor (potentially untrusted) as indices into the `input` tensor. Failure to properly validate these indices against the input tensor's bounds could lead to out-of-bounds memory access. The code pattern of indexing into a data structure based on external input is analogous, though the data structures (font tables vs. tensors) and specific arithmetic differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a NULL pointer dereference (CWE-476) in a regex library due to inconsistent error state handling. The target code shows no error state management or pointer dereferencing patterns that would lead to a similar flaw. The functions return a status code directly.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a stack buffer overflow (CWE-119) in a Bluetooth config parser. The target code does not involve parsing string inputs or stack-based buffers. The vulnerability pattern (classic buffer overflow from untrusted input) is not evident in the high-level tensor operation shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an input validation flaw (CWE-20) leading to unnecessary privilege execution (CWE-250) in a network daemon's privilege separation logic. The target code has no privilege management, process control, or daemon initialization components. The security concern is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2021-37687_after_exclude_100:7bb5027c:vulspec": {
    "timestamp": "2026-01-17T00:18:50.147146",
    "cve_id": "CVE-2021-37687",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7bb5027c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regex engine due to improper NUL byte handling. The target code performs input validation (checking for negative indices) for a gather operation in a tensor library. The domains (regex parsing vs. tensor indexing), vulnerability types (OOB read vs. potential integer/validation issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library's elliptic curve implementation. The target code is a straightforward data indexing operation in a machine learning framework with no cryptographic or constant-time considerations. The functional domains and flaw nature are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control flaw in a database query planner related to privilege checks on system catalogs. The target code performs a data validation and copy operation with no privilege or access control logic. The contexts (database security vs. tensor manipulation) are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2016-7972 involves resource management errors (memory tracking inconsistency) in a subtitle renderer. The target code has a simple validation loop but no dynamic memory allocation or complex resource tracking. There is a superficial similarity in performing validation on input data (indices vs. font data), but the core flaw mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a cryptographic algorithm handling error leading to a NULL pointer dereference in a DNS server. The target code validates tensor indices and calls a library function. While both have validation steps, the target code's validation is simple and direct, not part of a complex error-handling chain involving unsupported features or cryptographic objects.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2017-9619 involves improper bounds checking and integer handling issues when processing glyph indices from untrusted font data. The target code processes untrusted index data (`positions` tensor) from which it derives a count (`num_indices`) and validates values are non-negative. The core similarity is validating and using untrusted integer indices to access data structures. The flaw patternensuring indices are within valid boundsis conceptually similar, though the target code's validation is more explicit but potentially incomplete (lacks upper bound check).",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-16161 is a NULL pointer dereference due to inconsistent error state handling in a regex library. The target code has simple validation that calls `TF_LITE_ENSURE` on failure, which likely handles errors without dereferencing NULL. The error handling patterns and vulnerability root cause are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2016-7837 is a buffer overflow in a parsing function for hexadecimal strings. The target code reads integer indices from a tensor buffer. Both process untrusted input data from an external source. However, the target code does not perform complex parsing or string-to-binary conversion; it directly interprets memory as an array of integers. The overflow risk in the target code would stem from an incorrect `num_indices` calculation or lack of upper bounds check, not from string parsing.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3603 involves improper input validation of privilege separation state, leading to unnecessary privilege execution. The target code validates data content (indices) but does not involve any privilege management, process state, or security boundaries. The nature of the validation and the security context are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2021-40571_before_exclude_100:c4a4e548:vulspec": {
    "timestamp": "2026-01-17T00:19:12.107717",
    "cve_id": "CVE-2021-40571",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c4a4e548",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing file formats (BMP vs. AV1 config) and have potential for memory safety issues (CWE-119). However, Case 1's flaw is an unchecked header value leading to allocation failure, while the target code's primary risk is integer handling and buffer size validation during iterative OBU parsing. The patterns are not identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Strong similarity in the core vulnerability pattern: insufficient validation of a parsed size field (`obu_size`) against an available/declared size (`size`). Both involve a loop parsing chunks where a size from the data stream is compared to a remaining size counter. The target code has the check `if (size<obu_size)`, which is a critical safety gate similar to the missing check in Case 2. The domain (file parsing) and flaw type (CWE-125/OOB read risk) are aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve memory allocation for codec data (JPEG 2000 blocks vs. AV1 OBU arrays). The potential vulnerability in the target code could be a buffer overflow if `gf_bs_read_data` reads `obu_size` bytes into `a->obu`, but `obu_size` was derived from the stream and validated against `size`. The primary similarity is in the domain of media codec parsing, but the specific flaw (insufficient padding allocation) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a Use-After-Free (CWE-416) due to error handling and pointer management in a network daemon. The target code is a media parser with linear, sequential allocation and cleanup (`gf_odf_av1_cfg_del` on error). There is no complex pointer sharing or error path that leaves dangling references. The domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The key similarity is integer handling and validation. The target code performs arithmetic `size -= (u32) obu_size;` in a loop. If `obu_size` is manipulated to be larger than `size`, the check `if (size<obu_size)` prevents the underflow. However, the cast of `obu_size` (u64) to `u32` could theoretically truncate a large value, making the check less effectivea subtle integer issue. Case 5 is a more direct integer overflow in dimension calculation. Both involve validating sizes from untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2016-6823"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a Double Free (CWE-415) during error cleanup in an image writer. The target code's error handling frees the config (`gf_odf_av1_cfg_del`) and breaks from the loop, with no apparent double-free or ownership ambiguity. The memory management patterns are simple and linear. Little reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The most relevant aspect is the buffer copy operation `gf_bs_read_data(bs, (char *) a->obu, (u32)obu_size)`. This requires that `obu_size` is correctly validated and fits within the allocated buffer. Case 7's flaw is incorrect bounds checking due to arithmetic underflow. The target code's validation (`if (size<obu_size)`) and the prior successful parse suggest `obu_size` is trusted, but a miscalculation could lead to an OOB write (CWE-787). The pattern of reading a chunk of computed size into a buffer is similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both parse structured binary formats. Case 8's flaw is unlimited allocation due to an unchecked size field (offset_size=0). The target code allocates based on `obu_size` parsed from the stream, but it is bounded by the loop's `size` counter. The potential for excessive allocation exists if many small OBUs exhaust memory, but there's no single uncontrolled allocation from an unvalidated header field. Limited similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-5835"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing data with delimiters/structure (OBU vs. DNS tokens). Case 9's flaw is an OOB write due to incorrect parenthesis counting affecting buffer bounds. The target code's parsing is done by `gf_av1_parse_obu`, and the subsequent buffer copy uses the returned `obu_size`. If the parser incorrectly calculates the size, an OOB write could occur. The similarity is indirect: reliance on a subordinate parser's correctness.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve integer handling in parsers. Case 10 is an integer overflow in length calculation leading to OOB write. The target code has integer operations (`size -= (u32) obu_size;`, cast of `obu_size` to `u32`) that could, in theory, wrap or truncate if `obu_size` is maliciously large, though the `size<obu_size` check mitigates this. The domain difference (DNS vs. media) is significant, but the integer validation concern is a common theme.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2021-40571_after_exclude_100:529ec8c9:vulspec": {
    "timestamp": "2026-01-17T00:19:23.034068",
    "cve_id": "CVE-2021-40571",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "529ec8c9",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing file formats and memory allocation, but the specific flaw is different. Case 1 is about unchecked header values leading to allocation failure, while the target code's primary risk is integer overflow/wraparound in size calculations and insufficient validation of parsed OBU sizes against the remaining buffer (`size`).",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Strong similarity in the core pattern: parsing a structured format with size fields and failing to validate that a parsed/calculated size (`obu_size`) does not exceed the available/declared input buffer (`size`). Both could lead to out-of-bounds reads. The difference is the specific format (XAR vs. AV1 config) and the exact validation gap.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 centers on Use-After-Free due to complex state management error. The target code's memory management (alloc/free) is simpler and linear, with no apparent pointer aliasing or error path that would leave dangling references. The primary risks are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. High similarity in the vulnerability pattern: integer handling issues leading to buffer access violations. The target code uses `u32 size` and subtracts `obu_size` (a `u64`), but performs a check `if (size<obu_size)` after buffer allocation and read. If `obu_size` is extremely large (e.g., >4GB), the subtraction `size -= (u32) obu_size;` could wrap around, causing the loop to continue reading far beyond the intended buffer. This is analogous to Case 5's integer overflow in dimension calculations bypassing checks.",
        "case_metadata": {
          "cve_id": "CVE-2016-6823"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a Double Free due to error handling complexity. The target code has error breaks that free allocated memory (`gf_free(a)`) but does not appear to double-free the same pointer. The memory ownership flow is simpler.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Both involve improper bounds checking during buffer read operations. Case 7's flaw is an underflow/overflow in a `remain` calculation. The target code's check `if (size<obu_size)` is performed *after* the OBU has already been read into an allocated buffer (`gf_bs_read_data`). If `obu_size` is larger than the actual data remaining in the `GF_BitStream`, `gf_bs_read_data` could read out-of-bounds. The validation logic is misplaced, similar to the flawed check in Case 7.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both parse binary formats. Case 8's flaw is unlimited allocation due to a zero metadata value. The target code allocates based on `obu_size` parsed from the stream, which could also be excessively large, but the more immediate threat is the OOB read before the size check, not the allocation itself.",
        "case_metadata": {
          "cve_id": "CVE-2017-5835"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing structured data with length fields. Case 9's flaw is an out-of-bounds write due to incorrect parenthesis counting affecting buffer position. The target code's risk is an out-of-bounds read due to insufficient validation of a parsed size against an outer limit. The parsing complexity and specific trigger differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Very similar to Case 5. Case 10 is an integer overflow in a length calculation leading to OOB write. The target code contains a critical integer overflow/wraparound vulnerability: `size` is a `u32`. The operation `size -= (u32) obu_size;` occurs after the check `if (size<obu_size)`. However, if `obu_size` is between `size+1` and `size+UINT32_MAX`, the check passes (as `obu_size` is a `u64`), but the cast and subtraction cause `size` to wrap to a large value, making the loop continue indefinitely and reading far beyond the input buffer. This is a direct parallel to integer overflow bypassing a guard check.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2022-3134_before_exclude_100:cad980e4:vulspec": {
    "timestamp": "2026-01-17T00:19:48.590735",
    "cve_id": "CVE-2022-3134",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cad980e4",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves regex parsing with NUL bytes leading to out-of-bounds read. The target code uses regex in tag searching (via find_tags), but the core vulnerability pattern (embedded NULs in patterns causing buffer over-reads) is not directly mirrored. The target code's primary operations are tag stack management and file navigation, not deep regex compilation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1838 is an XML end-tag parsing out-of-bounds read in libxml2. The target code deals with tag navigation in an editor context (like jumping to function definitions), not parsing structured markup languages. The \"tag\" concept is entirely different (code symbols vs. XML elements). No shared parsing logic or buffer boundary issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-16161 is a NULL pointer dereference in a regex library due to inconsistent error state. The target code has error handling (e.g., emsg calls) and uses regex, but the specific flaw patternreturning an error code without setting error info leading to a later NULL dereferenceis not evident. The target's error paths generally goto end_do_tag or return.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-3179 is a use-after-free due to uninitialized pointers and inconsistent state cleanup. The target code manages a tag stack with dynamic allocations (vim_strsave) and has cleanup (tagstack_clear_entry). There is potential for state corruption if allocations fail, but the specific pattern of double-free during error recovery is not clearly present. Some reference for memory management pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2 due to improper multi-byte character buffer handling. The target code processes strings (tag names) but does not involve complex character encoding transformations or byte-by-byte parsing of structured documents. No equivalent buffer state validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1834 is a heap buffer overflow due to negative length calculation in string operations. The target code uses string functions (STRCMP, vim_strsave) but does not perform manual length calculations or concatenations that could wrap to negative. Memory operations are largely via Vim's internal APIs which may have bounds checks.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-15166 is an improper input validation in a network protocol parser (tcpdump) leading to out-of-bounds read. The target code is a local editor command processor; it parses command arguments and tag patterns, not network packets. While both involve parsing external input, the domain and data structures are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1835 is a use-after-free in libxml2 due to attribute value reference invalidation during parsing. The target code saves and restores marks (saved_fmark) and tag stack entries which could become stale if buffers/windows change. However, the mechanism is different: not direct pointer dereference after free, but rather referencing buffer numbers (fnum) that may become invalid. Some conceptual similarity in state preservation risks.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to missing length validation. The target code does parse tag match data (parse_match), but the data comes from tag files, not untrusted network packets. The risk profile and validation requirements are significantly lower.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob due to off-by-one allocation. The target code allocates memory for strings (vim_strsave) but does not compute sizes manually in a way that could cause an off-by-one. The primary memory management risks here are allocation failures or use-after-free if global state is corrupted, not buffer overflow.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2008-4934_before_exclude_100:ac6bfc52:vulspec": {
    "timestamp": "2026-01-17T00:20:24.202729",
    "cve_id": "CVE-2008-4934",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ac6bfc52",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds write in a network protocol (WebSocket) due to alignment assumptions. The target code is a filesystem bitmap allocator performing local, in-kernel memory operations with no network parsing or alignment-sensitive memory access patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon's local socket handling. The target code performs synchronous bitmap manipulation under a mutex lock, with no dynamic memory allocation/free patterns that could lead to a use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Both involve HFS+ filesystem code. Case 3 is an integer overflow in HFS catalog traversal (TSK user-space). The target code is HFS+ block allocation in the kernel. While the exact vulnerability differs (integer overflow vs. potential logic/race), the domain (HFS+), context (filesystem metadata parsing), and risk patterns (manipulating on-disk structures) are highly similar, providing excellent reference for filesystem-specific flaw patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is an integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code performs arithmetic on sizes and offsets but within the controlled context of a single superblock and page mapping. The attack surface (local filesystem vs. remote protocol) and consequence severity differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 5 is a race condition in F2FS node ID allocation. The target code is a block allocator for HFS+. Both are in-kernel filesystem resource managers. While the specific vulnerability (race condition) is not immediately apparent in the target code (which uses a mutex), the functional similarity (allocating scarce filesystem resources) and context (kernel filesystem driver) provide valuable reference for concurrency and state management flaws.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an integer overflow in a file parser (libplist). The target code does perform arithmetic with `size`, `offset`, and `len` variables, but these are derived from filesystem metadata already trusted by the kernel, not directly from untrusted file input. The attack model (parsing malicious files) is less direct.",
        "case_metadata": {
          "cve_id": "CVE-2017-7982"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 is a buffer overflow in an image codec due to incorrect size calculation. The target code uses `kmapped` pages and pointer arithmetic with bounds defined by `PAGE_CACHE_BITS`. While both involve careful bounds management, the domain (image encoding vs. filesystem bitmap) and memory model (heap buffers vs. page-mapped disk data) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code processes bitmap data with no string parsing or NUL-byte sensitivity. The code patterns and vulnerability triggers are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a double-free in an antivirus file parser. The target code has no apparent dynamic memory allocation/deallocation in its critical path (`read_mapping_page` and `kunmap` are managed by the kernel's page cache). The resource management patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 is a buffer overflow in an ELF parser due to insufficient validation of size fields. The target code validates its operations against `size` and uses page boundaries, but the source of data (on-disk bitmap vs. ELF section header) and the attacker's control over the size parameters differ significantly in the kernel filesystem context.",
        "case_metadata": {
          "cve_id": "CVE-2017-16357"
        }
      }
    ]
  },
  "CVE-2022-3134_after_exclude_100:7b1c1596:vulspec": {
    "timestamp": "2026-01-17T00:20:32.803241",
    "cve_id": "CVE-2022-3134",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7b1c1596",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. The target code is a tag navigation function in Vim, handling tag stack management and file jumps. CVE-2018-18313 is a regex engine vulnerability (CWE-125) in Perl involving NUL byte handling in pattern parsing. The domains (text editor navigation vs. regex compilation), vulnerability types (logic/state management vs. buffer over-read), and code patterns are fundamentally different. Only superficial similarity exists in processing user input strings.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Target code manages an internal tag stack and performs file navigation. CVE-2016-1838 is an XML parser out-of-bounds read (CWE-125) in libxml2 during end tag parsing. The systems (Vim vs. XML library), functionality (stateful navigation vs. structured document parsing), and flaw nature (logic errors leading to invalid state vs. direct memory safety violation) are unrelated. Both parse input, but the mechanisms and vulnerability patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Target code has extensive error handling with `goto` statements and state cleanup. CVE-2019-16161 is a NULL pointer dereference (CWE-476) in a regex library due to inconsistent error state handling. There is a conceptual similarity in the importance of consistent error state management to avoid crashes. The target code's careful state restoration (e.g., `tagstackidx = oldtagstackidx`) shows awareness of this class of issue, but the specific vulnerability pattern (missing error info setup) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The primary relevance is in resource management and cleanup patterns. CVE-2016-3179 is a Use-After-Free (CWE-416) in a daemon due to uninitialized pointers and inconsistent cleanup. The target code shows careful resource management: it frees old matches (`FreeWild`), saves pointers before operations that may invalidate them (e.g., copying `saved_fmark`), and uses `goto end_do_tag` for centralized cleanup. This demonstrates defensive patterns against similar state corruption issues, though the specific flaw (double-free on error path) is not directly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Target code performs string comparisons (`STRCMP`) and manages buffers, but its core logic is navigation state. CVE-2016-1833 is an out-of-bounds read (CWE-125) in libxml2 due to improper multi-byte character buffer handling. The domains and the nature of the memory safety violation (encoding parsing error vs. navigation logic error) are too different to provide strong reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Target code uses `vim_strsave` for duplication and `FreeWild` for cleanup. CVE-2016-1834 is a heap buffer overflow (CWE-119) in libxml2 due to a negative length calculation bypassing checks. While both involve string handling, the target code's string operations are largely via safe Vim API functions, and the flaw pattern (integer underflow leading to overflow) is not evident in the presented code.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-15166 is an input validation flaw (CWE-20) in a network protocol parser (tcpdump). The target code is an internal editor command processor. The attack surfaces (network packets vs. editor commands/autocommands) and the code's purpose are completely different. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The strongest conceptual link is with CVE-2016-1835, a Use-After-Free (CWE-416) in libxml2 during attribute processing. The target code shows explicit patterns to prevent UAF: it copies the `tagstack` pointer and later checks if it changed (`tagstack != curwin->w_tagstack`) after a callback (`find_tags` which may invoke a tagfunc). This is a direct defensive measure against the window being closed or the stack being reallocated, mirroring the concern of a reference becoming invalid. The pattern of saving state before a potentially disruptive operation is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read (CWE-125) in a network protocol parser due to missing length validation. The target code does parse tag match lines via `parse_match`, but it operates on internal data structures from `find_tags`, not on untrusted network data. The trust boundary and validation requirements are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-15670 is a heap buffer overflow (CWE-122) in glibc's glob due to an off-by-one allocation error. The target code performs dynamic allocation (e.g., `vim_strsave`), but the complexity and the specific off-by-one pattern are not present. The main logic deals with managing pre-allocated stack arrays (`tagstack[TAGSTACKSIZE]`) and lists of matches, not with intricate size calculations for user-expanded paths.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2008-4934_after_exclude_100:42ea0279:vulspec": {
    "timestamp": "2026-01-17T00:21:02.525964",
    "cve_id": "CVE-2008-4934",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "42ea0279",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds write in a network protocol (WebSocket) due to alignment assumptions. The target code is a filesystem bitmap allocator performing local memory operations with kernel page mapping. The domains (network vs. filesystem), vulnerability patterns (unaligned access vs. potential integer/bounds issues), and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon's local socket handling. The target code manages kernel memory pages and bitmap data structures with no dynamic allocation/free patterns shown. The concurrency model (mutex lock) and resource management are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve HFS/HFS+ filesystem processing. Case 3's integer overflow in HFS B-tree key length validation is conceptually similar to potential integer issues in bitmap offset/size calculations (e.g., `offset / PAGE_CACHE_BITS`, `size + 31`). The attack surface (crafted filesystem image) is identical. However, the specific vulnerability type (integer overflow leading to memory corruption vs. potential logic/overflow in allocator) and code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves an integer overflow leading to out-of-bounds write in a network file transfer protocol. The target code performs local bitmap operations with size/offset calculations that could theoretically harbor integer overflows (e.g., `(curr - pptr) * 32 + i`), but the context (kernel vs. userland library, protocol parsing vs. allocator algorithm) and typical trigger conditions are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is a race condition in a filesystem's node ID allocator. The target code is also a filesystem allocator (block bitmap) and uses a mutex lock (`mutex_lock`), indicating concurrency awareness. The similarity lies in the domain (filesystem resource allocation). However, the vulnerability type (race condition vs. potential arithmetic/logic error) and the code's focus (single-threaded algorithm within a lock vs. cross-thread state management) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an integer overflow in a file parser (bplist) leading to an out-of-bounds read. The target code reads filesystem metadata pages but is not parsing untrusted file format data in the same way. Both perform offset calculations, but the trust boundary (kernel filesystem driver processing on-disk structures vs. library parsing user-supplied files) and the consequence of overflow differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-7982"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow in an image codec due to incorrect padding calculation. The target code uses `kmapp`ed kernel pages and manipulates bits within them, but there is no evident analogous padding or coder-specific buffer sizing. The domains and memory manipulation patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code does not involve string parsing or character sequence processing. The vulnerability patterns and code constructs are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a double free in a document parser's error path. The target code's error paths (`goto out`) do not show complex resource cleanup or multiple free operations. The memory management model (kernel pages vs. userland heap) and flaw type are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a buffer overflow in an ELF parser due to insufficient validation of size fields. The target code reads a filesystem bitmap page, which is a relatively simple structure compared to ELF sections. Both involve processing binary structures from storage, but the complexity of parsing, the source of size parameters (on-disk header vs. function arguments), and the typical vulnerability patterns (integer overflow on large sizes vs. bitwise logic errors) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16357"
        }
      }
    ]
  },
  "CVE-2018-16881_before_exclude_100:76d6414d:vulspec": {
    "timestamp": "2026-01-17T00:21:16.111786",
    "cve_id": "CVE-2018-16881",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "76d6414d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a service discovery daemon due to uninitialized pointers and inconsistent state management. The target code is a TCP message framing parser that manages state transitions and buffer copying but does not involve dynamic memory allocation, pointer lifecycle issues, or similar error handling patterns that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves an Out-of-bounds Write due to an Integer Overflow in a file transfer protocol. The target code performs bounds checking (e.g., `octatesToCopy + pThis->iMsg > iMaxLine`) and uses `memcpy` with calculated lengths. While the target code appears to guard against overflow via `buffLen` and `iMaxLine` checks, the pattern of calculating copy sizes based on a network-provided counter (`iOctetsRemain`) shares conceptual similarity with the vulnerability's root cause: improper validation of integer arithmetic from untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an Out-of-bounds Read in a regex compiler due to improper NUL byte handling. The target code processes a stream of characters for framing but does not involve complex string parsing with embedded NULs, character class compilation, or similar patterns that could lead to reading beyond intended buffers in the same way.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 is an Out-of-bounds Read in a protocol parser due to insufficient validation of a length field. The target code parses a TCP stream using an octet-counting framing mode where a length (`iOctetsRemain`) is read from the data stream. While the target code validates this length against `iMaxLine` and logs errors, the pattern of reading a length from the network and then using it to control parsing is conceptually similar. However, the target code's vulnerability potential seems lower due to its explicit bounds checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an Out-of-bounds Write due to unaligned memory access in a WebSocket unmasking routine. The target code uses `memcpy` for aligned buffer copies and does not perform word-sized operations on potentially unaligned network data. The code patterns and vulnerability triggers are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 involves Improper Input Validation leading to potential memory issues in a network protocol parser. The target code is also a network protocol (syslog over TCP) parser that validates input state, octet counts, and buffer sizes. The shared theme is parsing untrusted network data with state machines and length fields, making the validation logic a relevant area for comparison, though the specific flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a heap buffer overflow due to insufficient padding allocation in an image codec. The target code performs bounded memory copies into a fixed-size buffer (`pThis->pMsg` up to `iMaxLine`). While both involve preventing buffer overflows, the target code's vulnerability context is simpler (linear buffer filling) compared to the complex padding calculations in image encoding.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 8 involves an Integer Overflow that bypasses a bounds check in an SSH message parser. The target code performs arithmetic (`pThis->iOctetsRemain * 10 + c - '0'`) when parsing the octet count, which could theoretically overflow if the count is extremely large, though it's stored in an `int` and checked against `iMaxLine`. The pattern of calculating values from network data and then using them in bounds checks is similar, making integer handling a relevant reference point.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an information disclosure via improper state clearance between HTTP requests. The target code manages session state (`ptcpsess_t`) for a single TCP stream but focuses on message framing within that stream, not on clearing sensitive data between independent requests. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 10 involves an Integer Overflow leading to an Out-of-bounds Write in a DNS domain name parser. Similar to Case 2 and 8, the relevance lies in the pattern of calculating buffer copy sizes based on untrusted input (the octet count). The target code's checks (`octatesToCopy + pThis->iMsg > iMaxLine`) aim to prevent this, but the arithmetic and validation logic is a key area for scrutiny, sharing conceptual ground with the vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2018-16881_after_exclude_100:e27f20a8:vulspec": {
    "timestamp": "2026-01-17T00:21:30.238712",
    "cve_id": "CVE-2018-16881",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e27f20a8",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 involves use-after-free and double-free vulnerabilities in a service discovery daemon's memory management. The target code is a TCP message framing parser with no dynamic memory allocation or pointer lifecycle management in the shown code path. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code has integer handling (iOctetsRemain multiplication/accumulation) and buffer copying (memcpy) with size calculations. While not identical, both involve parsing network data with potential integer handling issues leading to memory corruption.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in a regex parser due to NUL byte handling. The target code processes TCP framing with delimiter checking but doesn't involve complex string parsing or NUL byte issues. The vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-14461 involves out-of-bounds read in a network protocol parser due to insufficient length validation. The target code validates octet counts against iMaxLine and has bounds checking in memcpy operations. Both involve network protocol parsing with length field validation, though specific vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-20840 involves out-of-bounds write due to unaligned memory access in WebSocket decoding. The target code uses memcpy with calculated sizes but doesn't involve word-aligned access assumptions or WebSocket masking. Some similarity in network data processing but different vulnerability mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-15166 involves improper input validation in a network protocol parser leading to potential memory issues. The target code validates octet counts, checks delimiters, and enforces maximum message sizes. Both involve network protocol parsing with input validation, though specific validation flaws differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 involves buffer overflow due to insufficient padding allocation in image encoding. The target code has buffer size checks (iMsg < iMaxLine) and truncation logic. Both involve bounds checking but in very different domains (image encoding vs. network protocol framing).",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-17498 involves integer overflow in network protocol message validation leading to out-of-bounds read. The target code has integer arithmetic (iOctetsRemain * 10 + c - '0') with a limit check (<= 200000000). Both involve integer handling in network protocol parsing with potential overflow concerns.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-20637 involves information disclosure through residual pointers in HTTP connection reuse. The target code processes TCP messages but doesn't show connection state persistence or sensitive data handling between requests. Different vulnerability class and patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2019-25034 involves integer overflow in domain name parsing leading to out-of-bounds write. The target code has integer arithmetic in octet count parsing and buffer size calculations. Both involve integer handling during protocol parsing that could lead to buffer issues, though specific overflow patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2021-41219_before_exclude_100:3e029333:vulspec": {
    "timestamp": "2026-01-17T00:22:22.651148",
    "cve_id": "CVE-2021-41219",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3e029333",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a side-channel timing vulnerability in cryptographic operations (CWE-385). The target code is a matrix multiplication kernel with no cryptographic operations, secret-dependent branches, or timing-sensitive logic. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves an integer overflow leading to a heap buffer overflow (CWE-190 -> CWE-122) in an image parser. The target code performs matrix dimension calculations (m, k, n, k2) which could theoretically overflow, but the code uses `int` for dimensions and does not perform size calculations for memory allocation based on these dimensions (the output allocation uses `TensorShape({m, n})`). The primary risk pattern (integer overflow in allocation size) is not present, but the use of unchecked integer arithmetic on user-supplied dimensions is a minor similarity.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a stack buffer overflow (CWE-119) in a string parsing utility. The target code performs numerical tensor operations with no string parsing, fixed-size stack buffers, or direct buffer indexing based on untrusted input. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is an improper access control vulnerability (CWE-284) in a database query planner. The target code is a computational kernel with no authentication, authorization, or privilege checks. The domains and flaw types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves an integer overflow (CWE-190) in file position calculation within an archive parser. Similar to Case 2, the target code performs integer arithmetic on user-controlled tensor dimensions (e.g., `a.dim_size()`). While no subsequent position calculation or memory allocation uses the multiplied result `m * n` directly in a vulnerable way, the presence of dimension calculations without explicit overflow checks is a tangential similarity. The context (file parsing vs. linear algebra) differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow (CWE-119) in a blur effect calculation due to improper array indexing. The target code uses Eigen library operations for matrix contraction and does not perform manual array indexing or buffer management. The vulnerability pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a use-after-free (CWE-416) enabled by improper bounds checking in an image codec. The target code manages memory via `std::unique_ptr` and TensorFlow's allocation system, with no apparent lifecycle or bounds validation issues related to the described flaw. The patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves an integer overflow leading to an out-of-bounds read (CWE-190 -> CWE-125) during memory size calculation in an image decoder. This shares the most conceptual similarity with Cases 2 and 5. The target code's line `ctx->allocate_output(0, TensorShape({m, n}), &output)` implicitly calculates `m * n` within `TensorShape`. If `m` and `n` are large enough to overflow a 32-bit `int`, it could lead to an incorrectly sized allocation and subsequent buffer overflow during the `contract` operation. However, the vulnerability description for Case 8 is very specific to OpenJPEG's structures, and the target code's risk is more indirect.",
        "case_metadata": {
          "cve_id": "CVE-2016-7163"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a heap buffer overflow (CWE-119) due to insufficient padding allocation in an image encoder. The target code does not perform manual buffer allocation with padding calculations. Memory management is delegated to the TensorFlow framework and Eigen library.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 10 involves a risky cryptographic algorithm leading to a NULL pointer dereference (CWE-327 -> CWE-476) in a DNS server. The target code contains no cryptographic logic, algorithm selection, or error handling paths that could lead to dereferencing invalid pointers in a similar manner.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      }
    ]
  },
  "CVE-2021-41219_after_exclude_100:48c1a440:vulspec": {
    "timestamp": "2026-01-17T00:22:24.189943",
    "cve_id": "CVE-2021-41219",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "48c1a440",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a matrix multiplication kernel in a machine learning framework (likely TensorFlow), performing numerical computations. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library (libgcrypt) related to constant-time execution for ECC operations. The domain (cryptography vs. numerical linear algebra), vulnerability type (information exposure via side-channel vs. potential memory/arithmetic issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1178 involves an integer overflow leading to a heap buffer overflow during image file parsing. The target code also performs arithmetic on dimensions (m, k, n) derived from tensor shapes. While the target code has checks (OP_REQUIRES) to ensure dimensions are non-negative, a potential similarity lies in processing externally provided shape data. However, the context (image parsing vs. tensor computation) and the specific flaw pattern (direct overflow in allocation size calculation) are not strongly mirrored in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack-based buffer overflow in a string parsing function. The target code performs numerical matrix operations with no evident string parsing or fixed-size stack buffer usage. The vulnerability types and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control (privilege escalation) vulnerability in a database query planner. The target code is a computational kernel with no authentication, authorization, or privilege checks. The domains and vulnerability classes are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 involves an integer overflow during file position calculation in an archive parser. The target code performs integer arithmetic on tensor dimensions (e.g., `a.dim_size()`) to calculate output shape and inner dimensions for multiplication. A shared theme is calculating sizes/positions from input data. The target code has validation (`OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0, ...)`) but does not explicitly check for overflow when these dimensions are large and used in subsequent computations or allocations (though `ctx->allocate_output` likely uses `int64`). The reference value is limited to the general concept of validating integer inputs used in size calculations.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7970 is a buffer overflow in a subtitle rendering library caused by miscalculated array indices. The target code uses Eigen library contractions for matrix multiplication and does not manually manage array indices in a way that is directly comparable. The code patterns and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14152 is a use-after-free vulnerability triggered by improper state management and parameter validation in an image codec. The target code manages memory via `std::unique_ptr` and TensorFlow's allocation mechanisms, with no obvious pattern of freeing and reusing memory within the function. The vulnerability types are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7163 involves an integer overflow leading to an out-of-bounds read due to insufficient memory allocation. Similar to case 2 and 5, the connection is the arithmetic on input-derived integers (tensor dimensions) that could theoretically overflow if not properly validated before being used for allocation (`ctx->allocate_output`) or loop bounds. The target code validates that dimensions are >=0 but does not check for overflow when multiplying `m * n` or similar. The relevance is weak because the specific overflow-to-allocation pattern is not explicit in the snippet, and the domains differ (image decoding vs. tensor ops).",
        "case_metadata": {
          "cve_id": "CVE-2016-7163"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow due to insufficient padding allocation in an image encoder. The target code allocates output tensors via a framework API and uses library functions (Eigen contractions) for computation. There is no manual buffer management or padding calculation evident in the target code, making the patterns dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a NULL pointer dereference stemming from the use of an unsupported cryptographic algorithm in a DNS server. The target code performs numerical linear algebra with no cryptographic operations, algorithm negotiation, or complex error state cleanup that could lead to a NULL dereference. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      }
    ]
  },
  "CVE-2022-1427_before_exclude_100:37d0f0b0:vulspec": {
    "timestamp": "2026-01-17T00:23:01.923612",
    "cve_id": "CVE-2022-1427",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "37d0f0b0",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-19204 is an out-of-bounds read in a regex parsing library (Oniguruma). The target code is a Ruby VM bytecode interpreter (mruby). The domain (regex vs. VM execution), vulnerability type (parsing vs. runtime), and code patterns are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2019-19204"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-18397 is a buffer overflow in a Unicode bidirectional text processing library (FriBidi). The target code is a Ruby VM interpreter. The functionality (text layout vs. bytecode execution), attack surface (text input vs. bytecode/object manipulation), and flaw nature (level counter overflow vs. VM logic errors) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-18397"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-9831 is an integer overflow leading to OOB write in a camera library's PTP protocol parser. The target code is a VM interpreter. While both involve parsing external data (bytecode vs. protocol), the vulnerability mechanism (unchecked multiplication in allocation) is not directly mirrored in the VM's stack/register operations shown. The code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9831"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14353 is an integer underflow in an email client's IMAP string quoting. The target code is a VM interpreter with no evident string quoting or similar length calculation logic that could underflow. Domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-20637 is an information disclosure via residual state in an HTTP cache. The target VM code has complex state management (registers, call stack, exception handling) and does clear/reset state in some paths (e.g., `mrb->exc = NULL`). There is a conceptual similarity in ensuring state is properly cleared between operations (e.g., between bytecode instructions or method calls), but the specific flaw (pointer reuse) and context are very different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14350 is a stack buffer overflow in an IMAP date parser. The target VM code performs many array/stack accesses (e.g., `regs[a]`, `e->stack[b]`) but uses explicit bounds checks in some places (e.g., `b < MRB_ENV_LEN(e)`). The general concern of bounds checking on indexed accesses is relevant, but the specific vulnerability pattern (fixed-size buffer, string copy) is not present in the shown VM code which uses dynamic stacks.",
        "case_metadata": {
          "cve_id": "CVE-2018-14350"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-6905 is an out-of-bounds read in an image library's RLE decompression. The target code does not involve decompression or similar buffer expansion logic. The domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-6905"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-6448 is a buffer overflow in a disassembler due to improper validation of payload sizes. The target code is itself a bytecode interpreter/VM. It reads and executes bytecode instructions (`pc`, `irep->iseq`). While the shown code does not explicitly parse variable-length instruction payloads like Dalvik's packed-switch, the general principle of validating bytecode structure (opcode, operands, offsets) before use is highly relevant. The VM uses bounds like `irep->ilen` in `OP_JMPUW`. However, the specific flaw pattern (size calculation overflow) is not directly visible.",
        "case_metadata": {
          "cve_id": "CVE-2017-6448"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14356 is an uninitialized pointer access in a POP3 client. The target VM code has many pointer accesses (e.g., `proc->body.irep`, `e->stack`). It includes null checks (e.g., `if (e)`). The general need to validate pointers/objects derived from external input (bytecode) is relevant, but the specific trigger (zero-length string) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14356"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-19052 is a path traversal in a web server's alias module. The target code is a VM interpreter with no filesystem or path handling logic. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-19052"
        }
      }
    ]
  },
  "CVE-2022-1427_after_exclude_100:95d321b7:vulspec": {
    "timestamp": "2026-01-17T00:23:07.734792",
    "cve_id": "CVE-2022-1427",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "95d321b7",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression parser (Oniguruma). The target code is a Ruby VM bytecode interpreter (mruby). The domains (regex parsing vs. VM execution), vulnerability types (CWE-125 vs. potential VM memory safety issues), and code patterns are fundamentally different. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2019-19204"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves a buffer overflow in a Unicode bidirectional text processing library (FriBidi). The target code is a Ruby VM interpreter. The functionality (text layout vs. bytecode execution), attack surfaces (text input vs. bytecode/object manipulation), and flaw patterns (level counter overflow vs. VM register/stack safety) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-18397"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 involves an integer overflow leading to out-of-bounds write in a camera library's protocol parser. The target VM code performs many arithmetic operations and array accesses (e.g., OP_ARRAYPUSH, OP_ARYCAT). While both involve potential integer handling issues, the context is vastly different (external protocol parsing vs. internal VM arithmetic). The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2017-9831"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves an integer underflow in an email client's IMAP string quoting logic. The target VM code has string operations (OP_STRING, OP_STRCAT) but the vulnerability pattern (backslash escaping causing length miscalculation) is specific to IMAP protocol handling and not analogous to the VM's internal string handling.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves improper state clearance between HTTP requests in a web cache, leading to information disclosure. The target VM manages execution state (registers, call stack, exception handling) and has complex state transitions (e.g., between OP_RAISE, OP_RESCUE, OP_RETURN). There is a superficial similarity in the need to clear/reset state properly, but the mechanisms and contexts are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 6 involves a stack buffer overflow in an IMAP date field parser. The target VM uses stack operations (via `regs` array) and has fixed-size buffers for opcode processing. While both involve parsing untrusted data (bytecode vs. IMAP responses) and require bounds checking, the VM's stack is managed differently and the flaw pattern is not directly analogous.",
        "case_metadata": {
          "cve_id": "CVE-2018-14350"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves an out-of-bounds read in an image library's RLE decompression. The target code does not handle image formats or RLE compression. The vulnerability pattern (compressed data exceeding buffer) has no parallel in the VM's bytecode interpretation logic.",
        "case_metadata": {
          "cve_id": "CVE-2016-6905"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 involves a buffer overflow in a disassembler due to improper validation of payload sizes in Dalvik bytecode. The target code is itself a bytecode interpreter (for mruby) that processes opcodes and operands (e.g., reading `a`, `b`, `c` from instruction stream). Both involve parsing and validating bytecode structures. The reference value is limited because the specific flaw (packed-switch payload) is Dalvik-specific, but the general principle of validating bytecode operand bounds is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-6448"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 involves an uninitialized pointer access in a POP3 UID parser. The target VM code uses pointers extensively (e.g., `mrb->c->ci`, `proc->body.irep`) and has null checks in some places. However, the flaw pattern (empty string causing NULL dereference) is specific to protocol parsing and not directly analogous to the VM's pointer management.",
        "case_metadata": {
          "cve_id": "CVE-2018-14356"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves a path traversal vulnerability in a web server's alias module. The target code is a VM interpreter with no filesystem or path handling functionality. The vulnerability type (CWE-22) and context are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-19052"
        }
      }
    ]
  },
  "CVE-2019-9923_before_exclude_100:5166b9ac:vulspec": {
    "timestamp": "2026-01-17T00:23:17.230170",
    "cve_id": "CVE-2019-9923",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5166b9ac",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in a regex parser due to NUL byte handling. The target code is a tar sparse file header decoder performing numeric parsing with bounds checking. The domain (file archive vs. regex), vulnerability type (OOB read vs. potential integer overflow/truncation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management. The target code performs sequential block reading and numeric decoding in a tar utility, with no dynamic memory deallocation shown. The flaw patterns (memory lifecycle vs. parsing logic) and domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves an integer overflow leading to out-of-bounds write in a file transfer protocol. The target code decodes numeric fields (size_t, off_t) from a tar header, which could be susceptible to integer overflows/wraparound if `decode_num` does not properly validate against `TYPE_MAXIMUM`. Both handle file/archive data and involve parsing untrusted numeric values. However, the specific vulnerability manifestation (OOB write from allocation) is not directly visible in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code reads from a block buffer with a careful loop that checks against `BLOCKSIZE` and uses a macro to copy bounded strings. It shows more structured input consumption, though the ultimate safety depends on `decode_num`. The domains (network packet vs. archive format) and primary flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to insufficient bounds checking during end tag processing. The target code is a numeric field parser for tar sparse headers with explicit buffer boundary checks in the `COPY_BUF` macro. The code structure and vulnerability pattern (string buffer traversal vs. tag parsing) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2019-25034 involves an integer overflow in domain name length calculation leading to out-of-bounds write. The target code parses numeric values for `sparse_map_size` and offset/length pairs, storing them into allocated memory. If `decode_num` allows integer overflow/wraparound when converting to `size_t` or `off_t`, similar consequences (buffer overflow via `xcalloc` or invalid `sparse_add_map`) could occur. The pattern of parsing untrusted sizes for memory operations is comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to multi-byte character encoding issues. The target code deals with ASCII numeric strings in a tar block buffer, not character encoding. The vulnerability mechanisms and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2010-1311 involves improper input validation in a decompression module leading to window buffer overflow. The target code validates numeric fields via `decode_num` and has bounds checking in `COPY_BUF`. Both process archive/compressed file formats and involve parsing untrusted data with potential for memory corruption if validation fails. However, the specific flaw (sliding window match) and code complexity are different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-15166 is improper input validation in a network protocol parser leading to potential OOB read. The target code includes validation in its copying macro and calls `decode_num` for further checks. The domains (network packet parsing vs. archive header decoding) and typical attack vectors differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to insufficient padding allocation in an image codec. The target code allocates based on a user-controlled `sparse_map_size` (`xcalloc`). If an integer overflow occurs before or inside `xcalloc`, it could lead to an undersized allocation and subsequent heap overflow when writing to `sparse_map`. The pattern of allocating based on parsed size has some similarity, but the specific context (image encoding vs. sparse map) and flaw details differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2019-9923_after_exclude_100:d7f7d56b:vulspec": {
    "timestamp": "2026-01-17T00:24:08.478916",
    "cve_id": "CVE-2019-9923",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d7f7d56b",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regex parser due to NUL byte handling. The target code is a tar sparse file header decoder that performs numeric parsing with bounds checking (UINTMAX_STRSIZE_BOUND). The vulnerability type (CWE-125), domain (parsing vs. archive processing), and code patterns (string parsing vs. block copying/decoding) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon related to memory management errors. The target code performs block-based data copying and numeric decoding with explicit error handling and no dynamic memory deallocation in the shown path (only xcalloc allocation). The vulnerability class and context are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 involves an integer overflow (CWE-190) leading to an out-of-bounds write in a file transfer protocol. The target code decodes numeric fields (size_t, off_t) from archive blocks using decode_num with TYPE_MAXIMUM bounds checks. While the target code appears to have bounds validation, both involve parsing untrusted numeric values from a data stream (archive/network) which could lead to similar integer handling flaws if decode_num is flawed or bypassed.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read due to insufficient length validation in a network protocol parser. The target code reads data blocks and copies strings with a fixed-size buffer (nbuf[UINTMAX_STRSIZE_BOUND]), checking for overflow. Both involve parsing structured data from an untrusted source, but the vulnerability mechanism (length field validation vs. bounded string copying) and domain differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is an out-of-bounds read in an XML parser due to insufficient bounds checking during end tag processing. The target code uses a macro COPY_BUF that explicitly checks for buffer boundaries (dst == buf + UINTMAX_STRSIZE_BOUND -1) and block boundaries. The parsing context and vulnerability pattern are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 involves an integer overflow in domain name length calculation leading to an out-of-bounds write. The target code decodes two size_t/off_t values (sparse_map_size, offset, numbytes) from the archive, which are used for memory allocation (xcalloc) and array indexing. If decode_num does not properly prevent integer wraparound or if sparse_map_size is extremely large, similar allocation/overflow issues could occur. The pattern of parsing untrusted sizes for memory operations is comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is an out-of-bounds read in libxml2 due to inadequate bounds checking during multi-byte character processing. The target code copies character data until a newline, with explicit source/destination bounds checks. The vulnerability type and parsing context (text encoding vs. numeric string copying) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is improper input validation (CWE-20) in a decompression module leading to out-of-bounds write. The target code validates numeric fields and string bounds within COPY_BUF. Both involve parsing complex, untrusted file formats (CAB archive vs. tar sparse archive) and emphasize the importance of rigorous input validation to prevent memory corruption. The domain (archive parsing) is similar, though the specific flaw differs.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is improper input validation in a network protocol parser lacking bounds checks. The target code includes validation in COPY_BUF and decode_num calls. Both handle untrusted structured data, but the target code's validation appears more explicit. The similarity lies in the need to validate parsed fields against buffer limits.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a buffer overflow due to insufficient padding allocation in an image codec. The target code allocates memory based on a parsed size (sparse_map_size) and copies data with bounds checking. The connection is the potential for miscalculation in size-based allocation, but the target code uses fixed-size buffers for parsing and checked numeric decoding, reducing similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2021-3559_before_exclude_100:47f906a9:vulspec": {
    "timestamp": "2026-01-17T00:25:54.884087",
    "cve_id": "CVE-2021-3559",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "47f906a9",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a local device management function with no integer overflow, network input, or dynamic memory allocation based on untrusted size calculations.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code performs simple device type enumeration and memory cleanup with no string parsing or pattern matching.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a NULL pointer dereference in a USB/IP driver due to insufficient validation of URB fields. The target code has potential for NULL pointer issues if `mdev_types` or `nmdev_types` are NULL, but the pattern is different: it's a resource cleanup/refresh function rather than protocol processing.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow in FUSE ioctl handling due to insufficient iovec length validation. The target code has no buffer operations, iovec handling, or user-controlled length validations.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a race condition leading to NULL pointer dereference in keyring initialization. The target code could potentially have concurrency issues if called simultaneously, but it's primarily a cleanup and refresh function rather than shared resource initialization. Some similarity in pointer management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 involves unbounded memory allocation and integer overflow in USB/IP packet processing. The target code has memory allocation via `virMediatedDeviceGetMdevTypes`, but no network input validation or integer overflow patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a NULL pointer dereference due to insufficient USB endpoint validation. The target code has potential NULL pointer issues if input parameters are invalid, but the context is completely different (device enumeration vs. USB driver initialization).",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is a race condition in filesystem node ID management. The target code could have concurrency issues if called from multiple threads during device refresh, showing some similarity in resource management patterns, but the specific context differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a race condition leading to buffer overflow in TTY handling. The target code has simpler memory management and no buffer operations, though both involve resource management that could potentially have concurrency issues.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2021-3559_after_exclude_100:f8fc56e6:vulspec": {
    "timestamp": "2026-01-17T00:26:04.404083",
    "cve_id": "CVE-2021-3559",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f8fc56e6",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a local device management function with no integer arithmetic, network input, or dynamic memory allocation based on user-controlled sizes. The vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code performs simple file system path operations and memory cleanup. There is no pattern parsing, string processing with embedded NULs, or buffer over-read risks.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a NULL pointer dereference in a USB/IP driver due to insufficient validation of URB fields. The target code also involves pointer handling (mdev_types) and could theoretically dereference a NULL pointer if passed incorrectly, but the context (device capability enumeration vs. network packet processing) and root cause (missing validation of complex structures vs. simple pointer assignment) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a memory buffer issue in a cryptographic module related to scatterlist and VMAP stack. The target code does not perform cryptographic operations, use scatterlists, or have stack memory constraints relevant to the vulnerability. The memory management is simple allocation/deallocation.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow in a FUSE ioctl handler due to insufficient iovec length validation. The target code has no iovec structures, user-controlled length fields, or buffer copying logic. The function's purpose is to refresh a list of device types, not process variable-length user data.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 is a race condition leading to a NULL pointer dereference during keyring initialization. The target code is not explicitly thread-safe and modifies pointer arguments (*mdev_types, *nmdev_types). If called concurrently, similar double-free or use-after-free issues could occur during the cleanup loop. However, the target code lacks the complex state initialization race of the case.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is an unbounded memory allocation/integer overflow in a USB/IP driver. The target code calls `virMediatedDeviceGetMdevTypes` which may allocate memory internally, but there is no visible integer arithmetic or validation of user-controlled sizes like `transfer_buffer_length`. The attack surface (local sysfs path vs. network packet) is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a NULL pointer dereference due to insufficient validation of USB descriptors. The target code dereferences the `mdev_types` pointer argument. If a caller passes a NULL pointer for `nmdev_types` but a non-NULL `mdev_types` (or vice-versa in an inconsistent state), similar insufficient validation could lead to issues. However, the context (driver probe vs. library function) is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a race condition in a filesystem's resource (nid) manager. The target code manages a list of device types (`mdev_types`). If this function is called concurrently (a \"refresh\"), the cleanup loop that frees the old list and the assignment of the new list (`g_steal_pointer`) is not atomic, potentially leading to double-free, use-after-free, or memory leaks. This mirrors the concurrency issue with shared resource management.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a race condition in the TTY subsystem leading to buffer overflow from concurrent writers. The target code has no buffering, echo, or concurrent write mechanisms. While both may involve concurrency, the data structures (array of pointers vs. character buffer) and corruption mechanisms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2022-28805_before_exclude_100:3a60e78e:vulspec": {
    "timestamp": "2026-01-17T00:26:46.360612",
    "cve_id": "CVE-2022-28805",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3a60e78e",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a Lua variable resolution function, handling symbol table lookups and environment access. The CVE pertains to Perl's regex engine with an out-of-bounds read vulnerability due to NUL byte handling. The domain (language interpreter vs. regex compiler), vulnerability type (logic flaw vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs lexical analysis and variable resolution in a Lua compiler. The CVE is a use-after-free in a network daemon (MiniSSDPd) related to socket message handling and resource cleanup. The functional domains, memory management patterns, and error conditions are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is part of a language compiler's front-end. The CVE is an input validation flaw in a network packet parser (tcpdump). While both involve parsing, the context (compiler symbol resolution vs. network protocol decoding), data sources (source code vs. untrusted network packets), and vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The CVE describes an out-of-bounds read in tcpdump's LDP protocol parser due to insufficient length validation. The target code performs controlled lookups in compiler data structures (symbol tables, environment). There is no similarity in the attack surface (network packets vs. source code) or the core flaw (bounds checking vs. lookup logic).",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The CVE is an out-of-bounds read in libxml2's XML end tag parser. The target code handles variable name resolution in Lua, involving no low-level buffer manipulation or direct parsing of untrusted byte streams. The domains (XML parsing vs. compiler semantics) and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The CVE is another libxml2 out-of-bounds read related to character encoding and buffer management. The target Lua code operates on abstract syntax trees and string objects within a controlled compiler environment, with no evident buffer or encoding handling flaws.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The CVE is a use-after-free in libxml2's SAX2 attribute parser. The target code is a static function in a compiler, performing lookups and generating instructions. There is no dynamic memory allocation/deallocation or object lifecycle management visible in the provided snippet that would relate to a use-after-free pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The CVE is a state handling error in glibc's regex compiler. While both the target code and the CVE involve parsing/compilation phases, the target code's logic is about variable scoping (local vs. global/environment), not about parsing complex patterns with stateful backreferences. The flaw nature is different.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The CVE is a buffer overflow in a network daemon's IPv6 option parser. The target code is a compiler function with no network input, buffer copying, or arithmetic on untrusted length fields. The contexts and vulnerability patterns are completely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The CVE is an integer overflow leading to an out-of-bounds write in a VNC file transfer feature. The target code performs string-based lookups and instruction generation. There are no integer calculations on user-controlled data, memory allocations, or write operations that could correlate with this vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      }
    ]
  },
  "CVE-2021-37665_before_exclude_100:c1a59000:vulspec": {
    "timestamp": "2026-01-17T00:26:46.898305",
    "cve_id": "CVE-2021-37665",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c1a59000",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel timing attack in cryptographic operations (CWE-385). The target code performs tensor quantization/requantization using MKL-DNN, with no cryptographic operations or secret-dependent branching that could leak information. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7970 is a buffer overflow in subtitle blur effect calculations (CWE-119). The target code performs numerical scaling and memory reordering but uses safe memory allocation via TensorFlow's `ctx->allocate_output` and does not perform raw pointer arithmetic or array indexing that could lead to a buffer overflow. The context and flaw pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack-based buffer overflow in a string parsing function (CWE-119). The target code processes tensor data with fixed, validated dimensions and uses high-level MKL-DNN memory primitives, not raw stack buffers or string parsing. The attack surface and code patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1178 involves an integer overflow leading to a heap buffer overflow during image size calculation (CWE-190 -> CWE-122). The target code calculates a scaling factor `(min_max_from_vec / requested_min_max / static_cast<float>(1L << 31))` which uses floating-point division, not integer arithmetic that could wrap around. While both involve processing external input (tensors/images), the specific vulnerability mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control (CWE-284) vulnerability in a database query planner. The target code is a numerical kernel with no authentication, authorization, or privilege checks. The domains (database security vs. numerical computing) and vulnerability classes are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error (CWE-399) due to inconsistent memory tracking. The target code uses RAII-style unique_ptr and shared_ptr for MKL-DNN objects and TensorFlow's memory management for outputs. There is no manual memory allocation or tracking that could become inconsistent. The flaw pattern does not match.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7163 is an integer overflow in memory allocation size calculation leading to out-of-bounds read (CWE-190 -> CWE-125). The target code allocates memory based on the input tensor's shape, which is validated via `OP_REQUIRES`. The calculation `depth = input_min_vec.NumElements()` uses a size_t, but there is no subsequent multiplication or addition that could overflow. The similarity is limited to both processing structured input data.",
        "case_metadata": {
          "cve_id": "CVE-2016-7163"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow in file position calculation (CWE-190). The target code performs calculations like `factor * (min_max_from_vec / requested_min_max / static_cast<float>(1L << 31))` in floating point, not integer arithmetic. The risk of integer wrap-around is not present in the shown code. Both parse structured input, but the vulnerability mechanism differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-12973 is an uncontrolled resource consumption issue (CWE-400) due to a mismatch between advertised data size and actual processing. The target code's loop `for (int i = 0; i < depth; ++i)` is bounded by `depth`, which is derived from a validated tensor dimension. However, a potential similarity exists if `depth` is extremely large (though validated), it could cause high CPU usage. The reference value is limited as the code lacks the specific \"no progress tracking\" flaw.",
        "case_metadata": {
          "cve_id": "CVE-2019-12973"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7515 is an out-of-bounds read due to integer overflow in pixel calculations (CWE-125). The target code uses MKL-DNN's `memory::desc` with dimensions derived from `input.shape()`. While integer overflows in dimension calculations are a classic vulnerability in media processing, the target code delegates this to MKL-DNN and TensorFlow's shape handling. The direct code pattern is not present, but the domain of processing numerical array data has some overlap.",
        "case_metadata": {
          "cve_id": "CVE-2016-7515"
        }
      }
    ]
  },
  "CVE-2021-37665_after_exclude_100:b45c4ecd:vulspec": {
    "timestamp": "2026-01-17T00:27:00.697244",
    "cve_id": "CVE-2021-37665",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b45c4ecd",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a side-channel timing attack in a cryptographic library (libgcrypt). The target code is a quantization operator in a machine learning framework (TensorFlow) performing numerical scaling and format conversion using Intel MKL. There is no cryptographic operation, secret-dependent branching, or timing-sensitive logic. The vulnerability types (CWE-200/385 vs. potential numerical/validation issues) and domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a buffer overflow in a subtitle rendering library (libass) due to flawed mathematical calculations on untrusted parameters. The target code performs tensor operations with input validation (OP_REQUIRES) and uses standard library containers (std::vector). While both involve calculations, the attack surface (malicious subtitle file vs. ML model/tensor input), context (multimedia vs. ML framework), and flaw nature (buffer overflow vs. potential integer or logic errors) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a stack-based buffer overflow in a Bluetooth configuration parser (BlueZ) due to improper input validation of hexadecimal strings. The target code processes tensor data within a controlled framework environment, uses safe memory allocation via `ctx->allocate_output`, and does not manually parse untrusted byte streams. The vulnerability patterns (string parsing overflow vs. tensor operation logic) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an integer overflow leading to a heap buffer overflow in an image decoder (GIMP). The target code involves numerical calculations for scaling factors (`factor * (min_max_from_vec / requested_min_max / static_cast<float>(1L << 31))`). There is a tangential similarity: both perform arithmetic on user/attacker-influenced values (image dimensions vs. min/max vectors). However, the target code uses floating-point arithmetic, not integer arithmetic for memory allocation. The risk of an overflow leading to a buffer overflow in the target code is low, as the `scales` vector size is fixed by `depth`. The context and specific flaw mechanism differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an access control vulnerability (CWE-284) in a database (PostgreSQL) query planner. The target code performs a deterministic computation on tensor data with no privilege checks, authentication, or multi-user context. The domains (database security vs. numerical computation) and vulnerability classes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a resource management error (CWE-399) in a subtitle library due to inconsistent memory tracking. The target code uses RAII-style unique pointers and shared pointers for MKL resources, and its memory allocation for the output tensor is managed by the framework. There is no manual memory tracking that could become inconsistent. The flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is an integer overflow leading to an out-of-bounds read in an image codec (OpenJPEG). Similar to Case 4, the connection is the potential for arithmetic issues. The target code calculates `depth` from `input_min_vec.NumElements()`, which is a signed integer type (`int64` in TensorFlow). If an attacker could control `depth` to be very large, the loop `for (int i = 0; i < depth; ++i)` and `std::vector<float> scales(depth)` could cause resource exhaustion or an integer overflow in the vector allocation. However, `depth` is derived from a tensor dimension, which is typically constrained by memory limits. The relevance is weak because the primary flaw in the target code is not necessarily an integer overflow but could be related to invalid arithmetic in the scale calculation itself.",
        "case_metadata": {
          "cve_id": "CVE-2016-7163"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is an integer overflow in an archive parser (libarchive) during file position calculation. The relevance is similar to Cases 4 and 7: the target code performs arithmetic that could potentially overflow or produce invalid values if inputs are malicious. For example, `requested_min_max` could be zero, leading to a division-by-zero in the scale calculation (`min_max_from_vec / requested_min_max`). While not an integer overflow, it is an arithmetic flaw stemming from lack of validation. The check `input_requested_min_float < 0.0f` for `DT_QINT8` exists, but there is no check that `requested_min_max > 0`. The vulnerability patterns are somewhat related (arithmetic validation), but the specific integer overflow context is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is an uncontrolled resource consumption (CWE-400) in a BMP decoder due to a mismatch between advertised dimensions and actual data. The target code's loop is bounded by `depth`, which is derived from a tensor. If `depth` is extremely large, it could cause high CPU/memory consumption, similar to a resource exhaustion attack. However, the tensor size is inherently limited by available memory. The connection is weak, as the target code does not have a progress-tracking flaw like the BMP decoder; its loop is straightforward and bounded.",
        "case_metadata": {
          "cve_id": "CVE-2019-12973"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an out-of-bounds read in an image decoder (ImageMagick) due to integer overflow in pixel calculations. The most relevant aspect is the pattern of performing arithmetic on user-controlled values (image dimensions, min/max vectors) without sufficient validation for edge cases (like division by zero or overflow). The target code's scale calculation is a potential spot for similar logic errors (e.g., division by zero if `requested_min_max` is zero, or invalid results if `input_min_vec_data[i]` and `input_max_vec_data[i]` are extreme). However, the code uses floating-point arithmetic, not integer arithmetic for buffer sizing, making an out-of-bounds read less likely. The relevance is weak but present in the theme of arithmetic validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7515"
        }
      }
    ]
  },
  "CVE-2022-28805_after_exclude_100:6e2350b8:vulspec": {
    "timestamp": "2026-01-17T00:27:29.280771",
    "cve_id": "CVE-2022-28805",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6e2350b8",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code is Lua variable resolution logic with no regex parsing, buffer operations, or similar vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon (MiniSSDPd) related to socket message handling and inconsistent state management. The target code performs static variable resolution in a compiler/interpreter with no dynamic memory management or network input.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an improper input validation issue in tcpdump's LMP packet parser, leading to potential memory corruption. The target code is part of a language front-end (lexical analysis/variable resolution), not a network packet parser.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in tcpdump's LDP protocol parser due to insufficient TLV length validation. The target code deals with symbol table lookups and expression descriptor manipulation, not network packet parsing or bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in libxml2's XML end tag parser. The target code is from a Lua compiler's variable resolution phase, involving no XML parsing, tag processing, or similar buffer boundary issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in libxml2 related to multi-byte character encoding processing. The target code handles variable name strings in a controlled manner (str_checkname) and performs semantic analysis, not low-level character buffer manipulation.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a use-after-free in libxml2's SAX2 attribute parser. The target code's singlevar function performs lookups in compile-time symbol tables; it does not dynamically allocate/free memory for parsed data in a way that could lead to a use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a data processing error (state inconsistency) in glibc's regex compiler. While both involve parsing/compilation phases, the target code's variable resolution is a simpler, deterministic lookup process without the complex state machine and backreference tracking of a regex engine.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow in radvd's DNSSL option parser due to negative length handling. The target code performs string manipulation for variable names but within a compiler's internal structures, not parsing untrusted network packets with length fields.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds write in LibVNC due to integer overflow in a file transfer size calculation. The target code involves no arithmetic on user-controlled integers, no memory allocation based on such values, and operates at a much higher abstraction level (language semantics).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      }
    ]
  },
  "CVE-2020-14361_before_exclude_100:eee3f3f9:vulspec": {
    "timestamp": "2026-01-17T00:28:28.234993",
    "cve_id": "CVE-2020-14361",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "eee3f3f9",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves integer overflow leading to out-of-bounds write during memory allocation. The target code performs arithmetic on `size` and `dataLeft` but uses fixed sizes (1, 2, 4) and checks `dataLeft < (size * 2)`. While both involve length validation, the vulnerability patterns differ significantly: Case 1 is a complex integer overflow in allocation, while the target code's risk is more about insufficient validation of `dataLeft` against `size` calculations.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read due to improper NUL byte handling in regex parsing. The target code processes structured protocol data with length fields and performs swaps. There's no string parsing or NUL byte handling. The code patterns and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves use-after-free due to improper cleanup during error handling. The target code has no dynamic memory allocation or pointer management. It performs validation and returns error codes directly. The vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves privilege separation failure leading to unnecessary privilege retention. The target code is a protocol processing function with no privilege management or process control. The domains and vulnerability types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves out-of-bounds write due to incorrect parenthesis counting in a token parser. The target code has a loop that processes bits and validates data lengths. Both involve parsing structured input with length validation, but the target code's validation appears more robust with explicit size checks. The vulnerability patterns are somewhat similar in concept (input validation) but differ in implementation.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 involves integer overflow in domain length calculation leading to buffer overflow. The target code performs arithmetic with `size * 2` and checks against `dataLeft`. While the sizes are small fixed values (1, 2, 4), making overflow unlikely, the pattern of calculating required data size and validating against available data is conceptually similar. However, the target code's arithmetic is simpler and less prone to overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 involves out-of-bounds read due to insufficient validation of length fields in protocol parsing. The target code validates `dataLeft` against calculated size requirements and returns BadLength if insufficient. Both involve protocol parsing with length validation. The target code's validation pattern of checking `dataLeft < (size * 2)` is similar to the missing validation in Case 7. However, the target code appears to have proper validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves information disclosure through residual pointers in HTTP connection reuse. The target code has no connection state management or pointer reuse between calls. It processes a single request independently. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 involves integer overflow in alignment calculations for memory allocation. The target code performs simple arithmetic `size * 2` with small fixed values. While both involve arithmetic operations, the target code's operations are much simpler and less prone to overflow. The vulnerability patterns are only superficially similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-25033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 involves infinite loop due to unchecked compression pointer recursion in DNS parsing. The target code has a loop controlled by `maskLeft` that decrements with `maskLeft &= ~bit`, ensuring termination. The loop patterns are different, and the target code has no recursive pointer following.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      }
    ]
  },
  "CVE-2020-14361_after_exclude_100:0e2d8117:vulspec": {
    "timestamp": "2026-01-17T00:28:42.586141",
    "cve_id": "CVE-2020-14361",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0e2d8117",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves an integer overflow leading to out-of-bounds write during memory allocation. The target code performs arithmetic on `dataLeft` and `size` but with careful bounds checking (`if (dataLeft < (size * 2))`). The primary vulnerability pattern (OOB write via integer overflow) is not strongly present, though both involve parsing variable-length data from a network/client request.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read due to improper NUL byte handling in a string parser. The target code processes structured binary data with length fields and swaps operations. The code patterns and vulnerability type (OOB read vs. potential OOB write/read from miscalculation) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free vulnerability related to memory management and error handling. The target code has no dynamic memory allocation or pointer management in the shown path; it operates on a request buffer from the client. The flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is about improper privilege separation and continuing execution with unnecessary privileges after an initialization failure. The target code is a protocol handling function with no privilege management. The vulnerability domain is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves an out-of-bounds write due to incorrect parenthesis counting and buffer boundary calculation in a token parser. The target code also parses variable-length data based on a bitmask (`affectWhich`) and has to track `dataLeft`. Both involve parsing a data stream with variable-sized elements and maintaining a remaining data counter, but the specific trigger (parenthesis nesting vs. bitmask iteration) and code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an integer overflow in a length calculation leading to an OOB write. The target code performs multiplication (`size * 2`) and subtraction on `dataLeft`, but `size` is small (1, 2, or 4) and `dataLeft` is derived from `client->req_len * 4`. While an integer overflow in `client->req_len * 4` is theoretically possible, it's not the focus of the code's checks. The relevance is limited to the general theme of arithmetic on attacker-influenced values.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 is an out-of-bounds read due to insufficient validation of a length field in a network protocol TLV parser. The target code is also a network protocol parser (X11 extension) that validates `dataLeft` against a calculated `size` for each event type. Both involve iterating through structured protocol data, validating lengths, and avoiding reads past the buffer end. The key similarity is the pattern of processing variable-length data attached to a request based on a preceding header. However, the target code's validation appears more robust with explicit checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an information disclosure via improper clearing of sensitive data (residual pointers) between requests on a persistent connection. The target code processes a single request and does not show evidence of carrying over state from previous requests or failing to clear pointers. The vulnerability class is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is an integer overflow in an alignment calculation within a memory allocator. The target code has integer arithmetic (`size * 2`, `dataLeft -= (size * 2)`), but it's not for allocation size calculation. The potential for arithmetic overflow exists but is less direct. The common thread is performing arithmetic on user-influenced values.",
        "case_metadata": {
          "cve_id": "CVE-2019-25033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an infinite loop due to unchecked compression pointer recursion in DNS parsing. The target code has a loop (`for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1)`) but its termination condition `maskLeft != 0` is modified within the loop (`maskLeft &= ~bit`) and `ndx` is bounded. No recursion or pointer chasing is involved. The loop pattern is simple and not analogous to the complex stateful parsing in Case 10.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      }
    ]
  },
  "CVE-2008-4933_before_exclude_100:beca84f8:vulspec": {
    "timestamp": "2026-01-17T00:28:47.180043",
    "cve_id": "CVE-2008-4933",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "beca84f8",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve HFS+ filesystem catalog traversal and B-tree operations. The target code reads a catalog entry and validates a thread type, which is part of the B-tree validation logic. CVE-2019-1010065 also deals with HFS catalog traversal and validation flaws (integer overflow in key length). The domain is identical, and the functional context (parsing filesystem metadata) is very similar. However, the specific vulnerability type (integer overflow vs. potential validation bypass/memory corruption in the target) and the exact code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a kernel filesystem function for HFS+, while CVE-2018-18313 is in Perl's regular expression compiler. The domains (filesystem vs. language interpreter), functionality, and vulnerability types (out-of-bounds read due to NUL byte handling) are completely different. No meaningful reference value for the target code analysis.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code is a synchronous kernel filesystem lookup function. CVE-2016-3179 is a use-after-free in a user-space network daemon's local socket error handling. The domains, attack surfaces (local socket vs. filesystem image), and core flaw patterns (race condition/state management vs. data validation) are fundamentally dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The connection is very indirect. Both involve parsing data from an external source (filesystem image / network protocol). The vulnerability chain in CVE-2018-20750 starts with an integer overflow (CWE-190) leading to an out-of-bounds write. The target code performs arithmetic (be16_to_cpu, be32_to_cpu) but on fixed-size fields from a just-read record. The risk profile and code patterns are not similar. The only faint similarity is the need to validate data read from an untrusted source.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code is a simple, synchronous catalog lookup. CVE-2017-18249 is a complex race condition in a separate filesystem's (F2FS) node ID allocator. The domains are both Linux kernel filesystems, but the subsystems (HFS+ catalog vs. F2FS node management), functionalities, and vulnerability types (concurrency bug vs. data validation) are entirely different. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code is kernel filesystem logic. CVE-2011-1003 is a double-free in a user-space antivirus file parser. The domains, memory management models (kernel vs. user-space allocator), and typical attack vectors (malicious document vs. filesystem image) are unrelated. The flaw pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in the Linux kernel and involve data transfer/copying. However, CVE-2010-4650 is in the FUSE subsystem concerning iovec validation for a userspace server, leading to a buffer overflow. The target code reads a fixed-size structure (`hfsplus_cat_entry`) and uses its fields to build a key. The potential issues in the target would relate to validating the contents of `tmp` (e.g., the `parentID` or `nodeName` length), not iovec aggregation. The similarity is only in the broad concept of validating untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code is kernel-space. CVE-2013-2124 is a double-free in a user-space library for inspecting disk images. While both *could* be processing data from a filesystem image, the environments, memory management, and specific flaw patterns (error path cleanup vs. in-line data parsing) are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. The strongest point of relevance is the vulnerability type: CWE-125 (Out-of-bounds Read). The target code reads a structure (`tmp`) of fixed size (`sizeof(hfsplus_cat_entry)`) from disk via `hfs_brec_read`. If the on-disk record is shorter than expected, this could lead to an out-of-bounds read. Similarly, CVE-2017-12898 involves reading network packets without sufficient length validation. The domains differ (filesystem vs. network protocol), but the core flaw patterninsufficient validation of external data size before accessing itis conceptually similar and provides a valuable reference for auditing the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve reading/processing external data. CVE-2017-14151 is a buffer overflow due to incorrect size calculation in an image codec. The target code uses a fixed-size read. The potential link is that if `hfs_brec_read` does not guarantee the read size matches the buffer (e.g., due to disk corruption), it could lead to a buffer overflow. However, this is a more general problem. The specific flaw pattern (arithmetic error in padding calculation) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2008-4933_after_exclude_100:0835b058:vulspec": {
    "timestamp": "2026-01-17T00:29:11.854244",
    "cve_id": "CVE-2008-4933",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0835b058",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve HFS+ filesystem catalog traversal and B-tree operations. The target code reads catalog entries and validates thread record types and name lengths, which is directly related to the HFS catalog traversal functionality in CVE-2019-1010065. The vulnerability type (CWE-190 Integer Overflow) is plausible in the target code's length validation (checking if length > 255) if the length field is read from disk without proper bounds checking against the buffer size. The attack surface (malicious filesystem image) and domain (filesystem parsing) are identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a kernel filesystem function, while CVE-2018-18313 is in Perl's regular expression engine. The functionality (parsing vs. filesystem operations), vulnerability type (out-of-bounds read due to NUL bytes vs. potential integer/validation issues), and attack surface are completely different. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a synchronous kernel filesystem lookup function, while CVE-2016-3179 is a use-after-free in a userspace network daemon's state management. The functionality, vulnerability patterns (memory management errors in network service vs. filesystem validation), and context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing data from external sources (filesystem image vs. network protocol), but the domains differ significantly. The vulnerability type (CWE-787 Out-of-bounds Write due to integer overflow in allocation) is less directly applicable to the target code, which performs reads and validation but no dynamic memory allocation. The target code's `be16_to_cpu(tmp.thread.nodeName.length) > 255` check is a form of integer validation, but not against buffer sizes.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code performs a simple catalog lookup with no apparent concurrency or resource management complexities. CVE-2017-18249 is a race condition in F2FS node ID management, involving atomicity and state transitions. The functionality (lookup vs. allocation), vulnerability type (race condition vs. validation error), and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both parse structured data from external sources, but the domains (antivirus parsing Office documents vs. kernel filesystem) and vulnerability type (double free) are different. The target code does not show dynamic memory allocation or freeing that could lead to a double free. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code is a simple filesystem catalog reader, while CVE-2010-4650 is a buffer overflow in a kernel FUSE ioctl handler involving complex iovec management. The functionality, vulnerability pattern (buffer overflow due to missing length aggregation checks), and attack surface (malicious userspace server vs. malicious filesystem image) are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both read files or metadata, but CVE-2013-2124 is a double free in a userspace library's file reading utility, while the target code is a kernel function reading from a disk buffer. The memory management models and error handling paths are entirely different. Little reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate/Weak relevance. Both involve parsing structured data from untrusted sources (filesystem metadata vs. network packets) and include length validation. The vulnerability type (CWE-125 Out-of-bounds Read) is relevant because the target code reads a `hfsplus_cat_entry` from disk via `hfs_brec_read` and then accesses fields like `tmp.thread.nodeName.length`. If the on-disk data is malformed, an out-of-bounds read could occur before the length check. However, the domains (network protocol vs. filesystem) and specific code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both process data from external sources, but CVE-2017-14151 is a buffer overflow in an image codec's memory allocation, while the target code reads and validates a fixed-size structure. The vulnerability pattern (insufficient buffer allocation with padding) is not directly applicable, though the general principle of validating untrusted data is similar. The reference value is limited.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-0481_before_exclude_100:695296a1:vulspec": {
    "timestamp": "2026-01-17T00:29:16.451376",
    "cve_id": "CVE-2022-0481",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "695296a1",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code is a hash generation function in a compiler/interpreter (likely mruby), dealing with AST traversal and opcode generation. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to NUL byte handling. The domain (compiler codegen vs. regex parsing), vulnerability type (logic/state management vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code performs stack manipulation and opcode generation. CVE-2016-3179 is a use-after-free in a network daemon's resource management. The contexts (memory-safe code generation vs. network service state handling) and flaw types (potential logic errors vs. memory lifecycle errors) share no meaningful similarities.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code is part of a compiler's code generator. CVE-2019-15166 is an input validation flaw in a network packet parser (tcpdump). The domains (internal code generation vs. external untrusted data parsing) and primary concerns (correct stack management vs. bounds checking) are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code generates hash construction opcodes from an AST. CVE-2017-9226 is an out-of-bounds write in a regex library's character class compiler. While both involve \"compilation,\" the target code does not parse or validate raw input patterns; it operates on a pre-processed tree. The vulnerability mechanisms (invalid octal escapes causing OOB write vs. potential logic errors in stack depth calculation) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code manages an operand stack and emits opcodes. CVE-2017-14151 is a buffer overflow in an image codec due to incorrect allocation size calculation. The code patterns (stack pointer checks, pop/push operations vs. image block data buffer allocation) and vulnerability root causes are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code is an internal compiler function. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The attack surface (untrusted network data vs. internal AST) and code's purpose (generation vs. parsing) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code performs stack-based operations with fixed limits (GEN_VAL_STACK_MAX, INT16_MAX). CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code uses `int` for lengths and stack pointers, and while integer overflows are a general concern, the specific context (file transfer request parsing vs. compiler codegen) and data sources are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The primary connection is the concept of managing a bounded resource (stack in target code, heap buffer in glibc's glob). Both involve checks against limits (`cursp() >= slimit`, allocation size calculations). However, the vulnerability type differs significantly: CVE-2017-15670 is a precise off-by-one heap overflow, while the target code's risk is more about incorrect stack depth calculation or state management (`update`, `len`) leading to wrong opcode generation or stack corruption, not a classic buffer overflow. The domain (pathname expansion vs. compiler backend) also limits relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code traverses a linked tree structure. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking on internal buffers. The data structures (AST node pointers vs. raw character buffers), operations (tree traversal & codegen vs. string parsing), and associated risks are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code uses `int` for lengths and stack pointers. CVE-2019-25034 is an integer overflow in domain name length calculation leading to a buffer overflow. Although both involve integer variables, the target code's operations (pop_n, genop) are not typically susceptible to the same wrap-around-then-buffer-overflow chain because the lengths are derived from the AST structure, not from untrusted input directly. The context (DNS query parsing vs. compiler internals) is vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2022-0481_after_exclude_100:5e57a054:vulspec": {
    "timestamp": "2026-01-17T00:30:23.686948",
    "cve_id": "CVE-2022-0481",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5e57a054",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regex engine due to improper NUL byte handling. The target code is a hash generation function in a compiler/interpreter codegen module, dealing with stack operations and opcode generation. The vulnerability type, domain (regex vs. code generation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon's service registration. The target code performs compile-time code generation with stack management and has no dynamic memory allocation or network input processing. The flaw patterns (memory management errors vs. stack limit checks) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves improper input validation in a network packet parser leading to memory corruption. The target code also performs operations based on input (a syntax tree), but the context is entirely different: a trusted internal compiler structure vs. untrusted network data. Both require careful bounds/limit checking (slimit, GEN_LIT_ARY_MAX), but the vulnerability patterns (parsing external data vs. managing internal compiler state) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 4 is an out-of-bounds write in a regex library's character class processing due to invalid octal escapes. The target code generates hash construction opcodes and manages a value stack. The domains (regex compilation vs. language VM codegen) and the specific flaw (integer overflow in escape sequence -> OOB write) are not analogous to the stack and limit checks in the target.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 5 is a buffer overflow in an image codec due to incorrect padding calculation. The target code's primary safety mechanism is checking `cursp()` against `slimit` to prevent stack overflow. While both involve bounds checking, the context (image encoding vs. compiler stack management) and flaw root cause (arithmetic error in padding vs. logic error in stack limit update) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is an out-of-bounds read in a packet parser due to insufficient TLV length validation. The target code validates stack limits (`cursp() >= slimit`) to prevent overflow during code generation. The similarity is the need for proactive bounds checking. However, the attack surface (network packet vs. internal AST) and consequence (read vs. write) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is an out-of-bounds write due to integer overflow/truncation in a file transfer size calculation. The target code uses `int` types and compares against `INT16_MAX` and `GEN_LIT_ARY_MAX`. There is a potential similarity: if `len*2` or similar calculations could overflow an `int`, it could corrupt the `pop_n` call. The code's reliance on `int` for `len` and the `len*2` operations without explicit overflow checks is a concerning pattern shared with the vulnerability case, though the context is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 is a heap buffer overflow due to an off-by-one error in allocation size calculation. The target code is not about memory allocation but stack pointer management. However, the core similarity is in meticulous bounds calculation and checking. The target code's logic for determining `slimit` (conditional assignment) and the subsequent check `cursp() >= slimit` is a critical safety mechanism analogous to the bounds checking missing in Case 8. A logic error in these conditions could lead to a stack overflow/write.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 9 is an out-of-bounds read in an XML parser during end tag processing. The target code iterates over a linked list (`tree`) and generates operations. While both involve parsing a tree-like structure, the vulnerability mechanism (OOB read due to parser state error) is not present in the target code, which does not read from external buffers.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is an integer overflow leading to a buffer overflow during domain name length calculation. The most relevant aspect is the integer handling. The target code performs arithmetic (`len*2`, `len*2+1`) on an `int len` and uses the result as an argument to `pop_n`. If `len` becomes large enough, this multiplication could overflow, causing `pop_n` to operate on a negative or incorrect small number, potentially corrupting the stack. This mirrors the integer overflow -> buffer overflow pattern, though the target code's `len` is likely controlled by the AST size, not external input.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2022-21740_after_exclude_100:6fa5933f:vulspec": {
    "timestamp": "2026-01-17T00:30:34.135692",
    "cve_id": "CVE-2022-21740",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6fa5933f",
    "scores": [
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel timing attack in a cryptographic library. The target code is a TensorFlow operation for sparse tensor counting with no cryptographic operations, secret-dependent branches, or constant-time requirements. The vulnerability types and domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve integer operations and potential overflow, but the context is different. CVE-2011-1178 is an integer overflow in an image file parser leading to heap corruption. The target code performs arithmetic on indices and counts but includes bounds checks (OP_REQUIRES). The primary risk in the target code is more about index validation than size calculation overflow.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow in a string parsing utility. The target code processes tensor data with structured loops and does not involve string parsing or unbounded copy operations. The vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability in a database query planner. The target code performs a computational kernel operation with no privilege checks, user authentication, or access control logic. The domains and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-13219 involves integer overflow in codebook calculations. The target code uses integer indices and counts (num_values, num_batches) which could theoretically overflow if inputs are malicious, but the code uses TensorFlow's tensor abstractions which may provide some bounds. The similarity is limited to the general category of integer handling.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-8692 is a divide-by-zero vulnerability in an image decoder. The target code contains no division operations. The only faint similarity is input validation, but the specific flaw mechanism is absent.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow in archive file position calculation. The target code performs arithmetic with loop indices and batch counts (e.g., `batch_idx++`, `per_batch_counts[batch_idx - 1][value]++`). If `splits_values` is malformed, `batch_idx` could become out-of-bounds, but this is more of an index validation issue than a pure integer overflow. Some conceptual similarity in arithmetic safety.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14152 is a use-after-free in an image codec. The target code uses stack/local variables and a custom map (`BatchedMap`), with no dynamic memory management (new/delete, malloc/free) visible in the snippet. The memory models and flaw types are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow due to insufficient allocation. The target code's primary memory operations are via the `BatchedMap` and tensor outputs. While improper indexing could lead to out-of-bounds writes in the map, the pattern is not a direct buffer size miscalculation.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2009-3909 is an integer overflow in image dimension calculation leading to heap overflow. The target code uses integer values from tensors (`splits_values`, `values_values`) as indices. If these values are extremely large or negative, they could cause index overflow or out-of-bounds access in `per_batch_counts`. However, the code has validation (`OP_REQUIRES`) and the context is tensor computation, not file parsing. Limited similarity in integer input validation concerns.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      }
    ]
  },
  "CVE-2022-21740_before_exclude_100:505dfc01:vulspec": {
    "timestamp": "2026-01-17T00:30:38.237286",
    "cve_id": "CVE-2022-21740",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "505dfc01",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a TensorFlow kernel performing sparse tensor operations with no cryptographic functionality. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library (libgcrypt). The vulnerability type (information exposure via side channels), domain (cryptography), and code patterns (constant-time operations) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve processing structured input (image dimensions vs. tensor shape/indices) and performing validation. The core vulnerability in CVE-2011-1178 is an integer overflow leading to a buffer overflow. The target code performs bounds checking (e.g., `batch >= num_batches`) and uses `int64_t` for indices, which mitigates overflow, but the pattern of validating user-controlled dimensions is similar. The reference value lies in the need to validate all arithmetic on user-provided shape/indices to prevent overflows/wraparound.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2016-7837 is a stack buffer overflow in a parsing function. The target code also parses structured input (indices, values) but uses safe Tensor abstractions and OP_REQUIRES for validation. There is no direct evidence of raw buffer operations or stack-based arrays in the target code. The similarity is limited to the general concept of input validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability in a database query planner. The target code is a computational kernel with no privilege checks or multi-user context. The domains and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2019-13219 involves integer overflow in computations based on user-controlled parameters (codebook entries). The target code performs arithmetic based on user-provided `indices` and `shape` (e.g., calculating `batch`, `num_values`). While the target uses `int64_t` and has some bounds checks, the pattern of using user input in loop bounds and array indexing is similar. The case highlights the importance of validating that all derived values (like `batch`) are within allocated ranges, which the target code does check.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-8692 is a divide-by-zero vulnerability. The target code does not contain division operations. The only similarity is the validation of user-provided parameters (`shape_vector(b) >= 0`), but the specific flaw and trigger conditions are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-5844 involves integer overflow when calculating file positions from user-controlled archive headers. The target code calculates array indices and loop bounds from user-controlled `indices` and `shape` tensors. The pattern of deriving offsets/counts from untrusted input is similar. The target code uses `int64_t` and includes checks like `batch >= num_batches`, but the historical case is a valuable reference for ensuring all such calculations are safe from overflow and within bounds.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-14152 is a use-after-free vulnerability triggered by improper parameter validation. The target code manages memory via Tensor objects (likely RAII) and does not show explicit allocation/free patterns. The similarity is limited to the presence of input validation (`OP_REQUIRES`), but the core memory corruption mechanism is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-14151 is a buffer overflow due to insufficient allocation size. The target code uses map-like structures (`BatchedMap`) and outputs sparse tensors, so direct buffer overflows are less likely. However, the pattern of writing data (`per_batch_counts[batch][value]++`) based on user-controlled indices (`batch`, `value`) requires careful bounds checking, which the code performs for `batch` and implicitly for `value` via `maxlength_`. The case serves as a reminder to ensure all container accesses are bounded.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2009-3909 is an integer overflow in image dimension processing leading to a buffer overflow. The target code processes tensor dimensions (`shape`) and indices, performing similar validation (e.g., `shape_vector(b) >= 0`). While the target uses signed 64-bit integers and checks for negativity, the historical case underscores the critical need to validate all user-provided size/offset calculations before memory allocation or indexing, which is a relevant concern for the tensor kernel.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      }
    ]
  },
  "CVE-2021-3416_before_exclude_100:730a018e:vulspec": {
    "timestamp": "2026-01-17T00:31:56.702893",
    "cve_id": "CVE-2021-3416",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "730a018e",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a simple network packet forwarding function in a network device emulator. Case 1 involves complex regex parsing with buffer over-reads due to improper NUL byte handling. The domains (network emulation vs. string parsing), vulnerability types (logic flaw vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is about integer overflow leading to heap corruption in a VNC file transfer protocol. The target code performs a straightforward conditional packet send/receive with no complex arithmetic, memory allocation, or protocol parsing that could lead to integer overflows or out-of-bounds writes.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves a network protocol parser (IPv6 RA) with a buffer overflow due to negative length values. The target code does not parse any protocol headers or copy data based on untrusted length fields. It simply passes a buffer pointer to a send or receive function.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a NULL pointer dereference in a USB/IP kernel module due to insufficient validation of URB fields. The target code shows a potential for a similar flaw if `nc->info` or `nc->info->receive` could be NULL when the loopback condition is true. However, the context (QEMU network device emulation vs. kernel USB driver) and the specific trigger conditions (state inconsistency vs. a simple flag check) are very different. The similarity is superficial (potential NULL pointer access).",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow in the Linux kernel FUSE subsystem due to improper iovec length validation. The target code does not perform any buffer copies or length validations; it passes a buffer and size to a networking function.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a NULL pointer dereference in a USB driver due to missing validation of endpoint descriptors. Similar to Case 4, the target code has a potential NULL pointer dereference if `nc->info->receive` is NULL. However, the attack surface (physical USB device vs. emulated network device state), context (kernel driver initialization vs. packet transmission path), and root cause (missing hardware descriptor check vs. potential incorrect software state) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in a packet dissector (tcpdump) due to missing length validation. The target code is not a parser/dissector; it is a packet forwarding function that does not inspect the contents of the `buf`.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow in an NFC kernel protocol parser due to lack of bounds checking on a length field. The target code does not parse any data from `buf` and does not perform any buffer copies based on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 9 is a race condition in a filesystem's node ID management. The target code is a simple, synchronous packet sending function with no concurrency mechanisms (locks, shared state) evident, and it deals with network I/O, not resource allocation metadata.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a double-free in a disk image inspection library due to error handling issues. The target code has no dynamic memory allocation or deallocation; it only operates on provided buffers and function pointers.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2021-3416_after_exclude_100:bee3fb8a:vulspec": {
    "timestamp": "2026-01-17T00:31:59.303095",
    "cve_id": "CVE-2021-3416",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bee3fb8a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a simple network packet forwarding function in a QEMU network device model, while CVE-2018-18313 is a complex regex parsing vulnerability involving out-of-bounds reads due to NUL byte handling. The domains (network emulation vs. string parsing), vulnerability types (logic flaw vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to heap corruption in a VNC file transfer protocol. The target code performs basic packet send/receive based on a loopback flag. There are no integer operations, memory allocations, or complex protocol parsing similarities.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3601 is a network protocol parsing vulnerability with buffer overflow in an IPv6 router advertisement daemon. The target code does not parse packet contents; it merely forwards entire buffers. The attack surfaces (malicious protocol data vs. emulated device register state) and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-16914 is a NULL pointer dereference in a USB/IP kernel module due to insufficient validation of URB fields. The target code has no pointer dereferences of user/guest-controlled data and performs no complex validation. Both involve device emulation/virtualization, but the vulnerability mechanism and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in the Linux kernel FUSE subsystem due to insufficient iovec length validation. The target code does not handle iovecs, perform length calculations, or manage user-supplied buffers with complex structures. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3137 is a NULL pointer dereference in a USB serial driver due to missing validation of USB descriptors. The target code is also part of a device emulation model (network card) and could theoretically suffer from missing state validation (e.g., if `s->nic` were NULL), but the code pattern and specific trigger (USB descriptors vs. register configuration) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13054 is an out-of-bounds read in a packet dissector (tcpdump) due to missing length validation. The target code does not dissect or inspect packet contents; it forwards opaque buffers. The domains (packet analysis vs. packet forwarding) and vulnerability patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2012-3364 is a buffer overflow in an NFC kernel driver due to copying frame data without length checks. The target code does not copy or parse any data from the `buf` parameter; it passes it directly to send/receive functions. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a filesystem's node ID management. The target code is a simple, synchronous function with no concurrency, locks, or resource management beyond a basic conditional branch. The domains and flaw types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a disk image inspection library due to error handling issues. The target code has no dynamic memory allocation or deallocation. The only tangential similarity is both are part of virtualization tools, but the flaw patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2020-16302_before_exclude_100:875b9f0b:vulspec": {
    "timestamp": "2026-01-17T00:32:33.857197",
    "cve_id": "CVE-2020-16302",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "875b9f0b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free (CWE-416) in a network daemon's memory management. The target code is a printer driver function performing data transformation and output with static buffers, showing no dynamic memory allocation or pointer management vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 involves integer overflow leading to heap corruption (CWE-787) in a network protocol handler. The target code performs arithmetic on line sizes but uses fixed-size arrays (DATA_SIZE) with bounds checking. No dynamic allocation or integer overflow to buffer overflow chain is evident.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves out-of-bounds read (CWE-125) in a regex parser due to NUL byte handling. The target code processes image scan lines with explicit bounds checking (line_size > DATA_SIZE) and no string parsing or NUL-related issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length validation. The target code processes internal image data with calculated sizes, not parsing external protocol packets with TLV structures.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves out-of-bounds read (CWE-125) in an XML parser during end tag processing. The target code is a printer driver with no XML parsing, tag processing, or similar string/buffer navigation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 involves improper input validation (CWE-20) in a network protocol parser. The target code validates line_size against DATA_SIZE but processes internal device data rather than untrusted network packets.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 involves buffer overflow (CWE-119) in an image codec due to insufficient padding allocation. The target code uses fixed-size arrays with bounds checking and performs data transformation within those bounds, though both handle image/print data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 9,
        "reasoning": "High relevance. Both are Ghostscript printer driver functions (jetp3852_print_page vs dot24_print_page). Both process scan lines, handle printer commands, and have similar structure. Case 8 involves divide-by-zero (CWE-369) from unvalidated device parameters. The target code validates line_size but has similar potential for arithmetic issues with device-derived values (pdev->height, line_size calculations).",
        "case_metadata": {
          "cve_id": "CVE-2020-16310"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are Ghostscript printer driver functions. Case 9 involves out-of-bounds write (CWE-787) in buffer access. The target code has similar buffer operations (data, plane_data) with calculations using LINE_SIZE and line_size. While it has bounds checking (line_size > DATA_SIZE), similar offset calculation patterns exist.",
        "case_metadata": {
          "cve_id": "CVE-2020-16287"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves out-of-bounds write (CWE-787) in text encoding conversion. The target code performs binary image data transformation with no character encoding, string processing, or error return code handling vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2022-29194_before_exclude_100:abf0bbec:vulspec": {
    "timestamp": "2026-01-17T00:33:04.502992",
    "cve_id": "CVE-2022-29194",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "abf0bbec",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an improper access control (CWE-284) vulnerability in a database query planner. The target code is a simple tensor deletion operation in a machine learning framework, with no privilege checks or complex query logic. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a memory buffer vulnerability (CWE-119) in a network buffer management module. The target code performs a string lookup and deletion in a session state map. There is no low-level memory manipulation, buffer management, or string parsing that could lead to buffer overreads/writes.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is a side-channel information leak (CWE-200/385) in a cryptographic library's elliptic curve implementation. The target code is a straightforward deletion operation with no cryptographic computations, secret-dependent branches, or timing-sensitive operations.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds write (CWE-787) in an image codec due to missing buffer size validation. The target code does not involve writing to buffers, image parsing, or any operations where buffer size calculations could be incorrect. The functional domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds write (CWE-787) in a DNS parser due to incorrect parenthesis counting. The target code does not parse complex input with nested structures, delimiters, or token boundaries. The vulnerability mechanism (parenthesis state tracking) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 involves improper input validation (CWE-20) leading to unnecessary privilege execution (CWE-250) during daemon initialization. There is a tangential similarity: both codes handle a \"state\" (session state, privilege separation state) and could have error paths if that state is invalid (null session_state). However, the target code explicitly checks for null and returns an error, mitigating the flaw. The privilege escalation aspect is absent.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free (CWE-416) in an image library due to inconsistent state management. The target code does not involve dynamic memory allocation/deallocation of the tensor object itself (likely managed by a container), nor does it have complex parameter validation leading to inconsistent internal state.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a stack buffer overflow (CWE-119) in a configuration parser. The target code does not parse hexadecimal strings, copy data into fixed-size buffers, or perform any unsafe string operations. The `name` variable is a `tstring` object, likely providing safe bounds management.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a double free (CWE-415) in an image tool due to improper pointer ownership management. The target code deletes a tensor from a session state map. While both involve \"deletion,\" the target operation is a map erase/cleanup at a higher abstraction level, not manual memory deallocation with global pointer aliasing risks.",
        "case_metadata": {
          "cve_id": "CVE-2017-18120"
        }
      }
    ]
  },
  "CVE-2020-16302_after_exclude_100:f780a580:vulspec": {
    "timestamp": "2026-01-17T00:33:05.198849",
    "cve_id": "CVE-2020-16302",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f780a580",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network daemon's memory management. The target code is a printer driver function performing image data processing and serialization with static buffers and no dynamic memory allocation. The vulnerability types, attack surfaces, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 involves an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs arithmetic on line sizes and counts but uses fixed-size stack buffers (`DATA_SIZE`) and checks `line_size > DATA_SIZE`. While integer handling is present, the context (printer command generation vs. network packet parsing) and the specific flaw pattern (allocation overflow vs. bounded buffer manipulation) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code processes binary image data, not string parsing. There is no similarity in functionality, data structures, or vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code generates printer commands from internal image buffers with calculated sizes. It does not parse untrusted length fields from an external source. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves an out-of-bounds read in an XML parser. The target code is a printer driver with no XML or complex text parsing logic. The systems and vulnerability mechanisms are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 involves improper input validation in a network protocol parser. The target code's primary input is the internal device buffer filled by `gdev_prn_copy_scan_lines`, not direct network packet parsing. The attack surface and validation contexts are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 involves a buffer overflow in an image codec due to incorrect allocation size calculation. The target code also processes image data and uses fixed-size buffers. There is a superficial similarity in the image processing domain. However, the specific flaw (allocation miscalculation vs. using a pre-defined buffer with a size check) and the code structure are different. The target code's buffer size is compile-time constant (`DATA_SIZE`), not dynamically calculated from untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Both the target code and Case 8 are Ghostscript printer driver functions (`jetp3852_print_page` vs `dot24_print_page`). Both process scan lines, handle blank line optimization, and generate printer-specific command sequences. The vulnerability in Case 8 is a Divide-by-Zero (CWE-369) due to unvalidated device parameters. The target code performs arithmetic using `line_size` (derived from device properties like width/height/resolution) to calculate `count`, `line_size_color_plane`, and `cnt_2prn`. While no direct division is shown, the pattern of using device parameters in calculations without extensive validation is very similar. The context, code structure, and potential for arithmetic flaws are highly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2020-16310"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both the target code and Case 9 are Ghostscript printer device drivers. Both manipulate image data buffers (`data[]`, `plane_data[]`) and calculate offsets/indices for writing. Case 9's flaw is an out-of-bounds write due to insufficient bounds checking on calculated offsets. The target code contains complex index calculations (e.g., `odp[LINE_SIZE]`, `odp[LINE_SIZE*2]`, loop bounds `jj < line_size_color_plane`). The variable `line_size_color_plane` is derived from `line_size` (device-dependent). If `line_size` or related calculations were incorrect, it could lead to out-of-bounds accesses similar to Case 9. The domain and code patterns are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2020-16287"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves an out-of-bounds write in a text encoding conversion utility due to improper error handling. The target code performs binary data transposition and output with no text encoding logic. The functionality and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2022-29194_after_exclude_100:b4e9ea0b:vulspec": {
    "timestamp": "2026-01-17T00:33:38.536267",
    "cve_id": "CVE-2022-29194",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b4e9ea0b",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs a simple delete operation with access control delegated to a session state object. CVE-2019-10128 involves a complex SQL privilege escalation flaw due to inconsistent access checks in a query planner. The vulnerability types (CWE-284 vs. potential use-after-free or null pointer in target), domain (database vs. tensor runtime), and attack patterns are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-8860 is a classic memory buffer handling flaw (CWE-119) in a network stack's low-level data structures. The target code is high-level resource management in a framework (likely TensorFlow), performing validation and deletion. While both involve software defects, the nature of the flaw (memory corruption vs. logic/state error), abstraction level, and code patterns are vastly dissimilar. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2018-5745 involves a cryptographic algorithm failure leading to a NULL pointer dereference. The target code's primary risk is also a potential NULL pointer dereference (if `session_state->DeleteTensor(name)` internally mishandles a missing `name`). However, the contexts differ greatly: DNS security vs. session tensor management. The similarity is only in the generic consequence (crash), not the vulnerability cause or pattern. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 1,
        "reasoning": "CVE-2015-7511 is a side-channel information leak (CWE-200/385) in a cryptographic primitive. The target code has no cryptographic operations and is not performance-sensitive in a way that would leak secrets. The domains and vulnerability classes are completely unrelated. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-14164 is an out-of-bounds write (CWE-787) during image file encoding. The target code does not manipulate memory buffers directly; it calls an API. The flaw patterns are different: one is a low-level memory safety error in parsing, the other is a higher-level API usage/logic error. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2019-25035 is an out-of-bounds write in a parser due to incorrect parenthesis counting. Similar to case 5, this is a low-level parsing bug. The target code does not parse complex syntax; it validates a scalar and passes a string. The code structures and defect types are not similar. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2011-3603 involves improper handling of a failed initialization (privilege separation), leading to execution with unnecessary privileges (CWE-250). The target code pattern of checking a state (`session_state != nullptr`) and proceeding could be analogous: if the `OP_REQUIRES` macro did not halt execution, it could lead to a null pointer dereference. The similarity is in the \"check-then-potentially-proceed\" pattern on a critical resource, though the consequences differ (privilege vs. crash). Weak to moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 6,
        "reasoning": "CVE-2017-14152 is a use-after-free (CWE-416) caused by improper validation and inconsistent state management. The target code's potential vulnerability lies within the `session_state->DeleteTensor(name)` call. If the `session_state` or its internal structures have lifecycle/ownership issues (e.g., a tensor is deleted but references remain), it could lead to a use-after-free. The pattern of delegating to a complex subsystem where the real flaw may exist is similar. The target code itself is not vulnerable, but it's the interface to a potentially vulnerable component. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-7837 is a stack buffer overflow in a parsing function. The target code does not parse input; it extracts a string from a tensor. There is no similarity in code structure or vulnerability mechanism. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 7,
        "reasoning": "CVE-2017-18120 is a double-free (CWE-415) due to improper management of a global/shared resource (`last_name` pointer). The target code manages a shared resource (a tensor in a session state) via a name. If the `session_state->DeleteTensor` implementation has bugs in managing internal pointers or reference counts for the same `name` across concurrent operations, it could lead to a double-free or use-after-free. The conceptual similarity is managing named resources in a global state, where cleanup logic flaws can cause memory corruption. The abstraction level is different, but the core vulnerability pattern in the subsystem being called is relevant. Moderate to strong relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-18120"
        }
      }
    ]
  },
  "CVE-2022-36879_before_exclude_100:acde4279:vulspec": {
    "timestamp": "2026-01-17T00:33:52.044571",
    "cve_id": "CVE-2022-36879",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "acde4279",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-10154 involves improper memory handling with scatterlists and crypto operations in the SMB client. The target code is XFRM policy lookup and expansion in the Linux kernel networking subsystem, with no cryptographic operations, scatterlist usage, or similar memory corruption patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to improper NUL byte handling. The target code performs policy validation and pointer checks in the kernel. The domains (user-space interpreter vs. kernel networking), vulnerability types (CWE-125 vs. potential logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2010-4650 is a buffer overflow in FUSE ioctl handling due to insufficient iovec length validation. The target code also performs validation (checking policy action, type, error pointers) but in a different subsystem (XFRM vs. FUSE) and with a different primary flaw pattern (missing validation leading to overflow vs. incorrect state management). Both involve kernel code paths with user/network input, but the specific vulnerability mechanics are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a VNC server's file transfer. The target code performs simple integer arithmetic for counting policies (`*num_pols` and `*num_xfrms`) but with no complex calculations, memory allocations, or length validations that could lead to overflow/wrap-around. The context (user-space library vs. kernel) and flaw pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-16914 is a NULL pointer dereference in the USB/IP subsystem due to insufficient validation of URB fields. The target code also contains pointer validation (checks for `IS_ERR(pols[0])` and `IS_ERR(pols[1])`). The relevance is moderate because both are in the Linux kernel, involve validating pointers derived from external inputs (network/USB packets for CVE-2017-16914, likely network/flowi for target), and share the pattern of checking for error pointers. However, the specific subsystems and the consequence of missing validation (dereference vs. use-after-error) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2013-1792 is a race condition leading to a NULL pointer dereference in the kernel keyring subsystem. The target code involves policy lookup (`xfrm_policy_lookup_bytype`) and subsequent use of the returned pointer. While no explicit concurrency issue is shown, the pattern of fetching a resource (policy) and using it without proper locking in a multi-threaded/CPU kernel context is similar. Both are in the kernel security/subsystem space. The relevance is elevated due to the shared environment and the critical pattern of resource retrieval and usage, though the target code's specific vulnerability potential (e.g., use-after-free if policy is freed concurrently) is not as directly illustrated as the clear race in CVE-2013-1792.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read in tcpdump's LDP parser due to insufficient length validation. The target code has length-related variables (`xfrm_nr`) but does not use them to index into buffers. Both involve parsing structured data (policy TLVs vs. network TLVs), but the target code's operations are on kernel objects (policy structs) not raw packet buffers, making the memory corruption pattern dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-10675 is a use-after-free due to a race condition and improper locking in the kernel memory policy subsystem. The target code also manipulates kernel objects (xfrm_policy) which are reference-counted (note `xfrm_pols_put`). The relevance stems from being in the same kernel environment where shared objects must be properly managed to avoid use-after-free. The pattern of getting a pointer (`xfrm_policy_lookup_bytype`) and later putting it is analogous to the lifecycle management issues in CVE-2018-10675. However, the target code shows proper error-path cleanup, and the specific locking/race flaw is not evident.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2014-0131 is a use-after-free of sk_buff fragments in the network stack during segmentation. The target code is also in the kernel networking stack (XFRM) and deals with kernel objects that likely have complex lifecycles. The weak relevance comes from the shared domain and the general risk of improper resource management. However, the specific mechanism (orphaning fragments during copy) and data structures (sk_buff vs. xfrm_policy) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-13715 is an improper initialization leading to information disclosure in the network flow dissector. The target code initializes output parameters (`*num_pols`, `*num_xfrms`). The weak link is that both are in the kernel network stack and involve initializing/updating state based on input. However, the flaw pattern (leaving stack memory uninitialized on an error path) is not present in the target code, which explicitly sets outputs to zero on its early return path.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-36879_after_exclude_100:99a7709f:vulspec": {
    "timestamp": "2026-01-17T00:34:26.628817",
    "cve_id": "CVE-2022-36879",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "99a7709f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-10154 involves improper memory handling with scatterlists and crypto operations in the SMB subsystem. The target code is in the XFRM/IPsec policy subsystem and deals with policy lookup and counting, with no cryptographic operations or similar memory buffer manipulation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to improper NUL byte handling. The target code performs policy validation and reference counting in the Linux kernel networking layer. The domains (user-space application vs. kernel networking) and flaw patterns (string parsing vs. policy state management) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2010-4650 is a buffer overflow in FUSE ioctl handling due to insufficient iovec length validation. The target code also performs validation (policy action checks) and manages object references (xfrm_pols_put). However, the vulnerability type (buffer overflow vs. potential use-after-free or NULL pointer issues) and context (filesystem vs. networking) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a VNC server's file transfer. The target code performs simple integer arithmetic for counting policies and transforms (`*num_pols`, `*num_xfrms`) but does not involve size calculations for memory allocation or similar wraparound risks.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-16914 is a NULL pointer dereference in the USB/IP subsystem due to insufficient validation of URB fields. The target code contains similar patterns: it checks if `pols[0]` is an error pointer using `IS_ERR()` and later checks `pols[1]` after a lookup. A key similarity is the pattern of checking for error pointers after a function call (`xfrm_policy_lookup_bytype` could return `ERR_PTR`). However, the context (USB virtualization vs. IPsec policy) and specific trigger conditions differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2013-1792 is a race condition leading to a NULL pointer dereference in the keyring subsystem. The target code does not show obvious concurrency issues (no locking shown) but does involve managing pointers to shared policy objects (`pols` array). The potential for a similar flaw (e.g., a policy being freed concurrently after lookup) exists in a broader sense, but the code pattern and synchronization mechanisms are not directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in tcpdump's LDP parser due to insufficient length validation. The target code does not parse untrusted packet data; it operates on kernel-internal policy objects already fetched via lookup. The attack surface and data validation patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-10675 is a use-after-free due to a race condition and improper locking in the memory policy subsystem. The target code also manages kernel object references (policies) and calls `xfrm_pols_put` on error, which suggests reference counting. A similar use-after-free could occur if a policy is freed while being referenced, but the provided code snippet does not show the locking or lifecycle management details needed for a strong comparison.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2014-0131 is a use-after-free in skbuff fragmentation during TCP segmentation. The target code's `xfrm_pols_put` suggests it manages references to policy objects, sharing a high-level concept of managing object lifecycles to prevent use-after-free. However, the mechanisms (skb fragments vs. policy pointers), subsystems (core networking vs. IPsec), and specific patterns are quite different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-13715 is an improper initialization issue in the network flow dissector leading to uninitialized memory exposure. The target code initializes output parameters (`*num_pols`, `*num_xfrms`) on all code paths, showing careful initialization. The similarity is only in the general good practice of variable initialization, not in vulnerability type or code pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-36043_before_exclude_100:f96fb87c:vulspec": {
    "timestamp": "2026-01-17T00:34:37.671182",
    "cve_id": "CVE-2022-36043",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f96fb87c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a complex regex parsing engine vulnerability (CWE-125) due to improper NUL byte handling. The target code is a simple accessor function returning a cloned list. There is no similarity in vulnerability type, code pattern, or functional domain.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to out-of-bounds write in a network protocol handler. The target code performs no arithmetic, no network input processing, and no memory allocation. The functional contexts and flaw patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a buffer overflow in an image codec due to incorrect padding calculation. The target code does not perform any calculations on buffer sizes, does not handle image data, and simply returns a pointer to an existing list structure.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an input validation flaw in a decompression algorithm leading to memory corruption. The target code takes no input, performs no decompression or complex parsing, and has no validation logic that could be bypassed.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is a Use-After-Free vulnerability related to error handling and state management. The target code is too simple to have a comparable error path. However, both involve C-level memory management (pointers, lists), providing a minimal conceptual link in the domain of resource handling, but the flaw mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a Double Free vulnerability during error handling in a file parser. The target code has no free operations and no complex error paths. The only weak similarity is that both involve C structures and pointers, but the specific vulnerability pattern is absent.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an integer overflow in domain name parsing leading to a buffer overflow. The target code performs no arithmetic, string parsing, or buffer size calculations. The domains (DNS resolver vs. binary analysis) and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in an XML parser due to insufficient bounds checking. The target code does not parse structured input or perform bounds checking on any buffers. The functionality and vulnerability type are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is a resource management error involving inconsistent memory tracking. The target code uses `rz_list_clone`, which implies internal memory allocation and copying. If `qo->fixups` were in an inconsistent state (e.g., NULL or corrupted), this function could potentially crash, relating to broader resource management (CWE-399). However, the specific flaw pattern (size tracking mismatch) is not evident here.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse protocol data, does not read from network buffers, and does not validate any length fields. The contexts are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-36043_after_exclude_100:647ae4ea:vulspec": {
    "timestamp": "2026-01-17T00:34:48.139815",
    "cve_id": "CVE-2022-36043",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "647ae4ea",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a complex regex parsing vulnerability (CWE-125) due to improper NUL byte handling. The target code is a simple list cloning function with no input parsing, bounds checking, or memory access patterns similar to the regex engine.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to out-of-bounds write (CWE-787) in a network protocol handler. The target code performs no arithmetic, network input handling, or memory allocation that could lead to similar corruption.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a buffer overflow (CWE-119) in an image codec due to incorrect padding calculation. The target code has no buffer operations, size calculations, or data encoding logic that could mirror this flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is an input validation flaw (CWE-20) in a decompression algorithm leading to buffer overflow. The target code does not parse or validate complex input formats, nor does it perform decompression or sliding window operations.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is a use-after-free (CWE-416) due to inconsistent state management. The target code's `rz_list_clone` could potentially involve memory management, but the provided snippet shows no error paths, pointer management, or cleanup logic that could lead to a similar inconsistent state. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a double free (CWE-415) during error handling in a file parser. The target code has a simple success path with no visible error handling or free operations. The only tangential link is the potential for memory management issues within `rz_list_clone`, but the context is vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an integer overflow (CWE-190) in domain name parsing leading to an out-of-bounds write. The target code performs no arithmetic, string parsing, or length calculations that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read (CWE-125) in an XML parser due to insufficient bounds checking. The target code does not parse structured data or perform bounds-checked buffer reads.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 involves resource management errors (CWE-399) due to inconsistent tracking of allocated memory size. The target function returns a cloned list. If `rz_list_clone` fails to properly clone all elements or track the cloned list's state, it could lead to similar resource management issues (e.g., incomplete copy leading to later use-after-free or double free). The pattern is not identical but shares a conceptual link with improper object state duplication.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length validation. The target code does not parse TLVs, validate length fields, or read from network packet buffers.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2016-9810_before_exclude_100:5a14ec73:vulspec": {
    "timestamp": "2026-01-17T00:35:19.155583",
    "cve_id": "CVE-2016-9810",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5a14ec73",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2016-3179) involves a Use-After-Free vulnerability in a network service daemon due to uninitialized pointers and inconsistent state management. The target code is a GStreamer plugin for FLIC video decoding, which performs memory allocation and data parsing but does not exhibit similar pointer lifecycle or complex state cleanup issues. The domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 (CVE-2018-20750) involves an integer overflow leading to an out-of-bounds write in a file transfer protocol handler. The target code performs arithmetic operations (e.g., `flxdec->size * 4`) for buffer allocation. While no direct overflow is shown, similar patterns of using untrusted file header values (width, height) to calculate allocation sizes exist. The relevance is moderate because both involve parsing file formats and calculating buffer sizes based on input data.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 3 (CVE-2017-14151) involves a heap buffer overflow due to insufficient padding in buffer allocation for a codec. The target code allocates buffers (`g_malloc (flxdec->size)`, `gst_buffer_new_and_alloc (flxdec->size * 4)`) based on values (`width`, `height`) read from a file header. If these values are maliciously large, the multiplication could overflow or lead to excessive allocation/failure, though the code uses `guint`. The pattern of allocating buffers based on untrusted file metadata is very similar and presents a classic attack vector for media parsers.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 (CVE-2019-13219) involves an integer overflow in codebook calculations within an audio decoder. The target code performs integer arithmetic with file-supplied values (e.g., `flxdec->size = ((guint) flxh->width * (guint) flxh->height)`, `flxdec->size * 4`). While the specific overflow checks are not visible, the pattern of using untrusted integers in multiplications and allocations is shared. The relevance is moderate as both are media decoders processing untrusted file headers.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 (CVE-2019-20840) involves an out-of-bounds write due to unaligned memory access in a WebSocket unmasking operation. The target code performs memory copies (`memcpy`) and endianness fixes on data mapped from an adapter, but there is no indication of alignment-sensitive operations or word-sized writes to unaligned pointers. The domains (network protocol vs. video decoding) and flaw mechanisms are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 (CVE-2010-1311) involves improper input validation leading to out-of-bounds writes during decompression of a CAB archive. The target code decodes FLIC video chunks (`flx_decode_chunks`) and copies data into allocated buffers. While the specific compression algorithm differs, both involve parsing a complex file format with chunks/frames and writing decoded data into buffers. Insufficient validation of chunk sizes or offsets within `flx_decode_chunks` could lead to similar buffer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CVE-2018-18313) involves an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code does not compile regex patterns or process strings in a way that would be susceptible to embedded NUL bytes. The data flow involves binary video data, not text parsing. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 (CVE-2017-9226) involves an out-of-bounds write in a regex library due to invalid octal escape sequences. The target code does not process escape sequences or character classes. The only faint similarity is that both process input data (regex pattern vs. video chunk) to index into data structures, but the mechanisms and data types are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 (CVE-2018-20760) involves an out-of-bounds write in a text encoding converter due to unhandled error returns. The target code uses `gst_adapter_take` and `g_free`, but error handling for these functions is not shown to be missing. Both process external data, but the flaw pattern (ignoring function error codes) is not clearly present in the provided code snippet. The domain difference (text vs. video) also reduces relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 (CVE-2016-1838) involves an out-of-bounds read in an XML parser due to insufficient bounds checking during end tag processing. The target code reads binary structures with fixed sizes (`FlxHeaderSize`, `FlxFrameChunkSize`) using `memcpy` after checking `avail >=` size. This provides basic bounds checking. The parsing models (structured text vs. binary frames) and vulnerability patterns (OOB read vs. potential OOB write) are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2016-9810_after_exclude_100:406a0451:vulspec": {
    "timestamp": "2026-01-17T00:35:49.557746",
    "cve_id": "CVE-2016-9810",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "406a0451",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 involves use-after-free and double-free vulnerabilities in a network service's state management. The target code is a media decoder handling frame data with no apparent dynamic pointer management or similar error handling patterns that would lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a file transfer component. The target code performs memory allocation based on `flxdec->size * 4` where `flxdec->size` is derived from `width * height`. If these values are attacker-controlled from the file header, an integer overflow could occur, leading to undersized buffer allocation similar to the vulnerability chain in this case.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-14151 involves insufficient buffer allocation leading to heap overflow during image encoding. The target code allocates buffers based on `width * height` calculations and later writes decoded frame data. If the allocation size doesn't match the actual data processed in `flx_decode_chunks`, a buffer overflow could occur, though the pattern is not identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2019-13219 involves integer overflow in codebook calculations for audio decoding. The target code performs integer multiplications (`flxdec->size * 4` and `width * height`) using values from file headers. If these values are large and unchecked, integer overflow could lead to undersized allocations, similar to the vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2019-20840 involves out-of-bounds write due to unaligned memory access in WebSocket decoding. The target code performs memory operations with proper alignment through `memcpy` and structured access. While both handle binary data parsing, the specific vulnerability mechanism (alignment issues) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2010-1311 involves improper input validation in a decompression module leading to out-of-bounds writes. The target code's `flx_decode_chunks` function (not shown but referenced) likely processes compressed chunk data. If it fails to validate offsets/lengths against allocated buffers, similar boundary violation could occur, though the specific compression algorithm differs.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in regex processing due to NUL byte handling. The target code processes binary FLX format data with explicit size checks (`avail >= flxfh.size`) and doesn't involve string processing with embedded NULs or regex compilation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-9226 involves out-of-bounds write in regex character class processing due to invalid octal escapes. The target code processes binary animation format data, not text patterns. Both involve parsing structured input, but the vulnerability mechanism (octal escape validation) is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2018-20760 involves out-of-bounds write in text encoding conversion due to improper error handling. The target code handles binary media format with different error handling patterns. Both process external input, but the vulnerability pattern (error code mishandling in text conversion) doesn't align with the media decoding logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 involves out-of-bounds read in XML end tag parsing. The target code processes binary frame chunks with explicit size checking and doesn't involve hierarchical markup language parsing or the specific boundary checking issues present in XML parsing.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2019-18218_after_exclude_100:d8e939a3:vulspec": {
    "timestamp": "2026-01-17T00:36:15.000106",
    "cve_id": "CVE-2019-18218",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d8e939a3",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a Use-After-Free vulnerability in a network daemon's state management. The target code is a file format parser with careful bounds checking and error handling that frees resources on failure, showing a different pattern and vulnerability class.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves an integer overflow leading to an out-of-bounds write. The target code performs multiple bounds checks (e.g., `sh.sh_len > CDF_SHLEN_LIMIT`, `nelements > CDF_ELEMENT_LIMIT`) and size validations to prevent similar issues, but the core theme of validating sizes before allocation is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an out-of-bounds read due to improper NUL byte handling in a regex engine. The target code reads structured binary data with explicit length checks (`left < sizeof(uint32_t)`, `o4 + l > left`), making the vulnerability pattern different, though both involve bounds validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds write in a text encoding converter due to unhandled error codes. The target code performs direct buffer operations with explicit bounds checks and has a centralized error path (`goto out`), showing a more defensive pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 5 is a buffer overflow due to insufficient padding allocation in an image codec. The target code has similar arithmetic for buffer offsets (`o4 = slen * sizeof(uint32_t)`) and checks them against `left`, demonstrating a comparable need for precise size calculation and validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Case 6 is an out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code is also a parser (for CDF files) that meticulously validates lengths (`sh.sh_len`, `left`), reads structured fields, and has a similar pattern of checking `o4 + l > left`. The defensive coding style is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in an XML parser due to improper buffer management during multi-byte character processing. The target code handles binary data, not text encodings, and its bounds checks are more straightforward and arithmetic-based, reducing similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a buffer overflow due to an unchecked header value leading to a huge allocation. The target code validates limits early (`CDF_SHLEN_LIMIT`, `CDF_PROP_LIMIT`) and uses `cdf_grow_info` for controlled allocation, showing a different approach to preventing allocation issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 9 is an integer overflow in domain name length calculation leading to an out-of-bounds write. The target code performs arithmetic for buffer offsets and element counts (`nelements`, `slen * sizeof(uint32_t)`) and guards them with checks against `CDF_ELEMENT_LIMIT` and `left`, addressing a similar class of vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 10 is an integer overflow in a filesystem parser's key length validation. The target code also parses a structured format (CDF) and validates sizes/limits to prevent overflow or excessive allocation, though the specific trigger (B-tree key) is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      }
    ]
  },
  "CVE-2019-18218_before_exclude_100:0ec1dbb2:vulspec": {
    "timestamp": "2026-01-17T00:36:16.998225",
    "cve_id": "CVE-2019-18218",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0ec1dbb2",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network daemon's state management. The target code is a file format parser (CDF) performing bounds checks and memory growth operations. The vulnerability types (UAF vs. bounds/overflow), domains (network service vs. file parsing), and code patterns (pointer management vs. structured data traversal) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves an integer overflow leading to an out-of-bounds write in a file transfer parser. The target code performs numerous bounds checks (e.g., `offs > UINT32_MAX / 4`, `sh.sh_len > CDF_SHLEN_LIMIT`, `left < sizeof(uint32_t)`) and size calculations (e.g., `o4 = slen * sizeof(uint32_t)`) which are similar vulnerability patterns. Both handle structured, untrusted input. However, the specific trigger (integer overflow in allocation size) is not directly mirrored in the target code's arithmetic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code reads structured binary data with explicit length fields and performs bounds checks (e.g., `p >= e`, `cdf_check_stream_offset`). While both involve parsing untrusted data, the vulnerability mechanism (embedded NULs breaking string logic) and domain (text regex vs. binary property lists) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds write in a text encoding converter due to missing error code checks. The target code has extensive error handling (`goto out` on failures) and bounds checking. The similarity is in parsing untrusted data with potential for length miscalculation. However, the core flaw (unchecked return value) and data type (text encodings vs. binary property lists) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 is a buffer overflow due to insufficient padding allocation in an image codec. The target code has similar patterns: it calculates buffer sizes and offsets (e.g., `o4`, `slen`, `left`) and checks them against limits (`o4 + l > left`). Both parse complex binary formats where integer calculations on attacker-controlled fields could lead to overflows. The relevance is in the arithmetic and bounds validation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 6 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. This is highly analogous to the target code, which parses a CDF file's property list, reading `sh.sh_len` and `sh.sh_properties` from untrusted input and using them in subsequent offset calculations and loops. Both must validate TLV-like structures. The target code's checks (`sh.sh_len > CDF_SHLEN_LIMIT`, `sh.sh_properties > CDF_PROP_LIMIT`, `cdf_check_stream_offset`) directly address this class of vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is an out-of-bounds read in an XML parser due to inadequate bounds checking during multi-byte character processing. The target code also performs bounds checking but on binary data with explicit lengths, not character sequences. The similarity is in the high-level pattern: parsing untrusted input with complex structure requires maintaining consistent bounds state. The specific mechanisms differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 is a memory allocation failure/DoS due to an unchecked header value in an image converter. The target code validates header fields (`sh.sh_len`, `sh.sh_properties`) against limits. The similarity ends there. Case 8's flaw leads to a huge allocation attempt, while the target code's validation aims to prevent overflows and out-of-bounds reads/writes.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is an integer overflow in domain name length calculation leading to an out-of-bounds write. The target code contains multiple integer arithmetic operations on untrusted data (e.g., `offs`, `i << 1`, `slen * sizeof(uint32_t)`, `o4 + l`) and checks for overflow (`offs > UINT32_MAX / 4`). The pattern of calculating offsets and sizes from input fields is very similar, making this a relevant reference for potential integer overflow flaws.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is an integer overflow in a filesystem parser's key length calculation bypassing bounds checks. Like the target code, it parses a structured binary format (HFS B-tree vs. CDF property list) and performs calculations on untrusted integers (key length vs. `sh_len`, `nelements`, `l`). The target code's checks (`left < sizeof(uint32_t) * 2`, `o4 + l > left`) are analogous to the bounds checks that could be bypassed by an upstream integer overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      }
    ]
  },
  "CVE-2022-24763_before_exclude_100:a999a87b:vulspec": {
    "timestamp": "2026-01-17T00:36:25.167964",
    "cve_id": "CVE-2022-24763",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a999a87b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is an XML parser, while Case 1 involves a Perl regex engine vulnerability (CWE-125 from NUL bytes). The domain, functionality, and attack patterns are fundamentally different. The target code does not process regular expressions or named character sequences.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to heap corruption (CWE-787) in a VNC file transfer protocol. The target code is a recursive-descent XML parser with no complex integer arithmetic for memory allocation. The vulnerability class and context are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Both the target code and Case 3 (CVE-2016-1833) are XML parsers. The core vulnerability in Case 3 is CWE-125 (Out-of-bounds Read) due to improper bounds checking during character encoding processing. The target code shows similar patterns: it uses scanner functions (pj_scan_get_until_ch, pj_scan_get_until_chr) that could potentially read past buffer boundaries if input is malformed or not properly terminated, especially in loops (e.g., for comments, PI, CDATA). The parsing logic and attack surface (malformed XML input) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a Use-After-Free (CWE-416) in a network daemon's error handling path. The target XML parser uses pool-based allocation (pj_pool_t) and does not exhibit obvious pointer invalidation or double-free patterns. The memory management models and error paths are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 5 (CVE-2016-1838) is an out-of-bounds read (CWE-125) in libxml2's end tag parsing. The target code has a dedicated section for parsing the enclosing node (end tag), including reading the end name and comparing it. The pattern of scanning until a delimiter (\" \\t>\") and the subsequent logic for validation mirrors the vulnerable pattern. Insufficient validation of the scanner's state or buffer bounds in this section could lead to a similar OOB read.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 (CVE-2016-1834) is a buffer overflow (CWE-119) in libxml2's string handling. The target code performs string operations (e.g., adjusting attr->value.ptr/slen, node->content handling) without explicit bounds checks on the underlying buffer. While the specific mechanism (negative length) differs, the pattern of manipulating string pointers and lengths derived from untrusted input without rigorous validation is similar and presents a comparable risk.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in a graphics file format parser due to improper string termination validation. While both involve parsing external data, the domains (XML vs. PSP image) and specific parsing logic are very different. The relevance is limited to the general concept of parsing untrusted input without robust bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 is an out-of-bounds read in a network protocol parser due to insufficient length field validation. The target code parses a text-based protocol (XML) rather than a binary TLV format. The similarity is abstract: both parse structured input and must validate lengths/delimiters to prevent OOB reads. However, the concrete code patterns and validation mechanisms are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 (CVE-2016-1835) is a Use-After-Free in libxml2's attribute processing. The target code also processes XML attributes, allocating them via alloc_attr(pool) and storing them in a list. While the primary vulnerability type (UAF) is different, the code section handling attributes is a point of similarity. However, the pool-based allocation in the target code likely mitigates traditional UAF risks, reducing direct relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 (CVE-2016-1836) is a Use-After-Free related to buffer reallocation and dictionary handling in libxml2's name parsing. The target code uses a scanner and pool allocator, with no evident dynamic buffer reallocation or dictionary for names. The similarity is limited to both being XML parsers that process element/attribute names. The specific vulnerability mechanism is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      }
    ]
  },
  "CVE-2022-24763_after_exclude_100:df331759:vulspec": {
    "timestamp": "2026-01-17T00:37:30.673835",
    "cve_id": "CVE-2022-24763",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "df331759",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. The target code is an XML parser, while CVE-2018-18313 is a vulnerability in a Perl regular expression engine. The vulnerability type (CWE-125) is similar (out-of-bounds read), but the domain (regex vs. XML), trigger conditions (NUL bytes in regex vs. malformed XML tags/attributes), and code patterns (character class parsing vs. recursive descent XML parsing) are fundamentally different. The reference value for analyzing the target code is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write (CWE-787) in a VNC file transfer protocol handler. The target code is an XML parser with no complex integer arithmetic for memory allocation. The attack surfaces (network protocol vs. data format parsing), vulnerability types (write vs. read), and code logic are completely dissimilar. Provides almost no reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 9,
        "reasoning": "High relevance. CVE-2016-1833 is an out-of-bounds read (CWE-125) in libxml2, a widely-used XML parsing library, which is the same domain as the target code (a custom XML parser). The vulnerability root cause involves inadequate bounds checking during character/encoding processing and violation of parser state invariants. The target code performs similar operations: scanning input buffers (`scanner->curptr`), advancing pointers without rigorous bounds checks (e.g., `*(scanner->curptr+1)`), and processing special sequences (CDATA, comments). The patterns of pointer manipulation and the potential for missing checks are highly analogous, providing excellent reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free (CWE-416) in a network service discovery daemon related to error handling and memory management of service structures. The target code is a purely functional XML parser that allocates nodes/attributes from a pool (`pj_pool_t`) and does not exhibit explicit `free` operations or complex error state cleanup that could lead to a use-after-free in the same manner. The domains and memory models are too different to be relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "High relevance. CVE-2016-1838 is an out-of-bounds read (CWE-125) in libxml2's end tag parsing function (`xmlParseEndTag2`). This is directly comparable to the target code's section handling the enclosing node (lines starting with \"/* Enclosing node. */\"). Both functions parse the sequence `</tagname>`, compare the retrieved end name with the start name, and must carefully manage the scanner/parser state and buffer bounds during this operation. The target code uses `pj_scan_get_until_chr` and pointer arithmetic which could be susceptible to similar bounds checking flaws if the input is malformed. The vulnerability type, domain (XML parsing), and specific functionality are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1834 is a heap buffer overflow (CWE-119) in libxml2's string handling module due to improper length validation. The target code does perform string operations (via `pj_str_t` and scanner functions) and adjusts `slen` (e.g., `attr->value.slen -= 2`). There is a superficial similarity in manipulating string lengths. However, the specific flaw (negative length from `xmlStrlen`) and the attack surface (crafted XML content for string ops) are not directly mirrored in the shown code, which relies on higher-level scanner abstractions. Some reference value for general string handling caution exists but is limited.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-17787 is an out-of-bounds read (CWE-125) in an image file (PSP) metadata parser due to improper string termination validation. While the vulnerability type matches potential issues in the target code, the domain (binary image format vs. text-based XML) and the specific flaw (lack of null-terminator checking in external data) are not directly analogous. The target code's scanner may have different guarantees about buffer boundaries. The reference value is minor, primarily as a generic example of input validation failure.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14461 is an out-of-bounds read (CWE-125) in a network protocol (LDP) parser in tcpdump due to insufficient validation of a length field. The high-level concept of parsing a TLV-like structure without validating length against the remaining buffer is a relevant pattern. The target XML parser implicitly deals with lengths via delimiters (`>`, `'`, `\"`) rather than explicit length fields. The domains differ significantly (network protocol vs. markup language), reducing the direct applicability, though the principle of \"trust but verify\" lengths/delimiters is a weak parallel.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2016-1835 is a use-after-free (CWE-416) in libxml2's attribute parsing during namespace processing. The target code also parses XML attributes (see `/* Get attributes. */` section), allocating `pj_xml_attr` structures and managing a list. While the target code uses a memory pool which may mitigate classic use-after-free, the pattern of attribute processing and the potential for complex state interactions (especially if the pool could reallocate or if there are error paths not shown) shares conceptual similarity. The domain is identical, but the manifestation of the vulnerability type is less likely in the pool-based allocator. Provides moderate reference value for attribute handling complexity.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2016-1836 is a use-after-free (CWE-416) in libxml2 related to buffer reallocation and stale pointer references during complex name parsing. The target code uses a scanner abstraction and a memory pool; it does not show explicit reallocation of its input buffer. However, the core concept of the parser holding references into a buffer that may become invalid if the buffer moves/changes is a fundamental parser design issue. The `scanner->curptr` and references within `pj_str_t` (like `attr->value.ptr`) are similar to the stale pointers in the CVE. The domain is the same, but the trigger condition (buffer growth) is not evident in the provided snippet. Offers moderate reference value for pointer/buffer lifecycle management.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      }
    ]
  },
  "CVE-2021-37641_before_exclude_100:6a818a38:vulspec": {
    "timestamp": "2026-01-17T00:37:49.130937",
    "cve_id": "CVE-2021-37641",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6a818a38",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a TensorFlow kernel performing tensor operations (likely RaggedGather or similar). Case 1 is a cryptographic side-channel vulnerability (CWE-200/385) in libgcrypt. The domains (machine learning framework vs. cryptography library), vulnerability types (logic/validation vs. side-channel), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a stack buffer overflow (CWE-119) in a Bluetooth configuration parser due to improper input validation of hex strings. The target code performs input validation (OP_REQUIRES, ValidateIndices) and manages memory via TensorFlow's abstractions. While both involve input parsing, the context, data structures, and specific flaw (buffer overflow vs. potential logic/validation errors) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a privilege management flaw (CWE-20/250) in a network daemon's initialization path. The target code is a computational kernel with no privilege separation or daemon lifecycle concerns. The vulnerability patterns (state validation failure leading to elevated privileges) do not apply to the tensor manipulation logic shown.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is an access control flaw (CWE-284) in a database query planner related to privilege checks on statistical data. The target code operates on user-provided tensors within a single kernel execution context with no apparent privilege or ownership checks. The domains (database security vs. tensor computation) and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a cryptographic signature verification flaw (CWE-347) due to improper ASN.1 parsing in a TLS library. The target code deals with tensor indices and splits, not cryptographic data or signature validation. The code patterns and vulnerability triggers are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is an integer overflow (CWE-190) in a file parser leading to miscalculated positions. The target code performs arithmetic on split indices and dimensions (e.g., `dim_size(0) - 1`, calculating `num_values`). There is a potential similarity: improper validation of tensor dimensions or indices could lead to integer overflows/wraparounds in subsequent calculations or memory allocations (though not shown in this snippet). However, the specific context (archive parsing vs. tensor ops) and the visible code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a cryptographic algorithm handling flaw (CWE-327) leading to a NULL pointer dereference (CWE-476) in a DNS server. The target code contains no cryptographic operations or complex error handling that could lead to similar NULL pointer states from unsupported algorithms. The domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an out-of-bounds read (CWE-125) due to improper NUL byte handling in a regex parser. The target code reads tensors via `context->input()` and could be vulnerable to out-of-bounds reads if index validation (`ValidateIndices`, `MakeSplits`) fails or contains an off-by-one error. The similarity is the general concept of input validation preventing boundary violations. However, the specific trigger (embedded NUL bytes) and data structures (strings vs. tensors) are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an integer overflow (CWE-190) leading to a heap buffer overflow (CWE-122) in an image file parser. Similar to Case 6, the target code's calculations on tensor dimensions and indices (e.g., in `MakeSplits` or `WriteValues`, not fully shown) could be susceptible to integer overflows if inputs are maliciously large, potentially leading to incorrect memory allocation or access later. The connection is indirect, as the provided snippet shows validation but not the full arithmetic. The domains (image parsing vs. tensor ops) differ.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an insufficient validation of cryptographic data (CWE-345) in an authentication protocol. The target code validates indices (`ValidateIndices`) and tensor ranks, which is a form of input validation. However, the nature of the validation (cryptographic scalar/point checks vs. array bound and shape checks) and the consequent risks (authentication bypass vs. memory corruption/logic errors) are distinct. The similarity is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      }
    ]
  },
  "CVE-2022-1441_before_exclude_100:99dfb093:vulspec": {
    "timestamp": "2026-01-17T00:38:10.721448",
    "cve_id": "CVE-2022-1441",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "99dfb093",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free (CWE-416) due to uninitialized pointers and inconsistent state management. The target code performs a simple string read into a fixed-size buffer with no dynamic memory management errors of this type. The core flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow (CWE-119) due to unchecked input values leading to allocation failure. The target code has a classic stack-based buffer overflow vulnerability (reading into `str[1024]` without checking `i` against the buffer size), but the mechanism (unbounded `while` loop vs. integer calculation for allocation) and context (image parsing vs. box reading) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 3 is an Out-of-bounds Write (CWE-787) due to insufficient bounds checking in a parsing loop. The target code exhibits an almost identical flaw pattern: a `while(1)` loop reads bytes from a stream into a fixed buffer (`str[1024]`) without checking the index `i` against the buffer size (1024). Both involve unbounded input copying until a terminator is found, leading to a straightforward buffer overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves an Integer Overflow (CWE-190) leading to an OOB write. The target code's primary flaw is a lack of bounds checking, not an integer overflow. The index `i` could overflow if it exceeds 1024, but this is a consequence of the missing check, not the root cause. The vulnerability patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves an Integer Overflow (CWE-190) used to bypass a security check. The target code does not contain any arithmetic operations or validation checks that could wrap around. The core issue is a simple missing bounds check in a copy loop.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 is Improper Input Validation (CWE-20) leading to potential memory corruption. The target code's flaw is a quintessential example of CWE-20: it fails to validate that the input string length is less than the buffer size before copying. The context (network protocol parsing) is also similar, though the specific lack-of-check pattern is simpler in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 7 is an Out-of-bounds Write (CWE-787) due to buffer copy without checking size (CWE-120). The target code is a textbook case of CWE-120: it copies data from a stream into a fixed-size buffer in a loop with no size validation. The vulnerability mechanism is highly similar, though the target code lacks the alignment complication present in Case 7.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 is an Out-of-bounds Read (CWE-125). The target code's vulnerability is an out-of-bounds write, which is a more severe memory safety violation with a different exploitation primitive. While both involve bounds violations, the direction (read vs. write) and the code pattern (parsing state vs. simple copy loop) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is a heap buffer overflow (CWE-119) due to insufficient allocation size. The target code's overflow is on the stack, and the cause is not a miscalculation but a complete absence of length checking during a sequential read. The memory region and the flaw's root cause are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an OOB write caused by an integer overflow in an allocation size calculation. The target code does not involve any memory allocation or size calculations; it writes directly into a stack buffer. The \"out-of-bounds\" outcome is similar, but the path to get there (integer wrap vs. missing loop guard) is not.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      }
    ]
  },
  "CVE-2021-37641_after_exclude_100:e43270b3:vulspec": {
    "timestamp": "2026-01-17T00:38:11.777933",
    "cve_id": "CVE-2021-37641",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e43270b3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 is a cryptographic side-channel vulnerability (CWE-200/385) in libgcrypt. The target code is a TensorFlow operation performing data structure manipulation (splits and values copying) with no cryptographic operations or timing-sensitive secret-dependent branches.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a stack-based buffer overflow (CWE-119) in BlueZ due to improper input parsing. The target code performs bounds checking via OP_REQUIRES and uses standard TensorFlow APIs for memory management, showing no direct pattern of manual buffer handling vulnerable to overflow.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a privilege management flaw (CWE-20/250) in radvd where a failed privilege separation leads to continued execution as root. The target code is a computational kernel with no privilege separation or user identity management logic.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is an access control flaw (CWE-284) in PostgreSQL's query planner. The target code performs data transformation on tensors with no authentication, authorization, or privilege checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a cryptographic signature verification flaw (CWE-347) in axTLS due to improper ASN.1 parsing. The target code does not handle cryptographic signatures, certificates, or ASN.1 structures.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 is an integer overflow (CWE-190) in libarchive's ISO9660 parser. The target code involves calculations with SPLITS_TYPE (likely integer types) for indices and sizes (e.g., num_params_dense_values, num_values). While it uses TensorFlow's dimension accessors (dim_size), improper validation in helper functions like MakeSplits or WriteValues could theoretically lead to integer overflows when calculating buffer sizes or offsets, similar to the libarchive flaw. However, the direct code shown uses guarded OP_REQUIRES checks.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a cryptographic algorithm handling flaw (CWE-327) leading to a NULL pointer dereference (CWE-476) in BIND9. The target code contains no cryptographic logic or complex error state cleanup that could lead to a NULL dereference in the shown path.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an out-of-bounds read (CWE-125) in Perl's regex engine due to improper NUL byte handling. The target code reads tensor data, but the primary risk would be if the input tensors (params_dense_values_in, indices_in) contained maliciously crafted data that could cause out-of-bounds access within the WriteValues or MakeSplits functions. The relevance is weak because the shown code relies on TensorFlow's internal data access methods which should provide bounds safety, unlike the manual string parsing in the Perl case.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. Case 9 is an integer overflow (CWE-190) leading to a heap buffer overflow (CWE-122) in GIMP's PSD parser. This has stronger relevance than Case 6 because it explicitly chains integer overflow to buffer overflow. The target code's WriteValues function likely allocates output buffers based on calculated num_values and value_slices. If an integer overflow occurs in MakeSplits when calculating num_values or slice ranges, it could lead to an undersized allocation and a subsequent buffer overflow during the copy operation. The pattern is similar, but the target code's use of a high-level framework (TensorFlow) abstracts direct memory management, reducing direct similarity.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an insufficient input validation flaw (CWE-345) in FreeRADIUS's EAP-pwd protocol, specifically for cryptographic scalars and points. The target code validates indices and dimensions but does not perform validation of cryptographic data or complex mathematical properties.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      }
    ]
  },
  "CVE-2022-1441_after_exclude_100:9c97c7ac:vulspec": {
    "timestamp": "2026-01-17T00:38:19.009316",
    "cve_id": "CVE-2022-1441",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9c97c7ac",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free due to uninitialized pointers and inconsistent state management. The target code is a simple memory allocation and read operation with no pointer aliasing, complex state, or error paths that could lead to UAF. The core flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve memory allocation based on an input size (s->size / header values). The key similarity is the potential for an allocation failure or incorrect size calculation if the input size is maliciously large or invalid. However, Case 2's flaw is specifically about an unchecked integer from a file header leading to allocation failure, while the target code's size comes from a box structure which may have been parsed earlier. The vulnerability pattern (CWE-119 via allocation issue) has some reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an Out-of-bounds Write due to incorrect bounds checking during parsing. The target code uses `gf_bs_read_data` with `s->size` as the length, which could be an OOB read if `s->size` is larger than the available data in the bitstream, but the case describes a write vulnerability in a token parser. The connection is indirect: both involve trusting an unchecked size leading to potential buffer operations, but the vulnerability type and code patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 involves an Integer Overflow leading to an OOB Write. The target code allocates `s->size + 1` bytes. If `s->size` is `UINT32_MAX`, the addition could wrap to 0, causing `gf_malloc(0)` and a subsequent OOB write when `p->content_script_types[s->size] = 0` is executed (writing at index UINT32_MAX). This is a plausible integer overflow-to-OOB-write chain similar to the case, though the context (DNS parsing vs. box reading) differs.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 involves an Integer Overflow that bypasses a bounds check. The target code does not have an explicit bounds check to bypass, but the integer overflow risk in `s->size + 1` is similar. The arithmetic operation on an untrusted size field is the common link. The reference value lies in demonstrating how an overflow in a size calculation can lead to memory safety issues.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is about Improper Input Validation leading to memory corruption. The target code lacks validation of `s->size` before using it for allocation and reading, which is a form of improper input validation. However, the context (network packet parsing vs. structured box reading) and the specific manifestation (missing checks before data access) are only superficially similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is an OOB Write due to alignment issues during word-sized operations. The target code performs byte-wise reading and a single byte assignment. There are no alignment assumptions or multi-byte operations. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is an Out-of-bounds Read. The target code's `gf_bs_read_data` could read OOB if `s->size` exceeds the bitstream's remaining data, potentially leading to an OOB read. This is a conceptual similarity. However, the cause in Case 8 is parser state manipulation, while here it would be a size mismatch. The reference value is limited.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is a Buffer Overflow due to insufficient memory allocation (padding). The target code allocates `s->size + 1` bytes and writes `s->size` bytes from the stream, then writes a null terminator at offset `s->size`. If `gf_bs_read_data` reads exactly `s->size` bytes, this is safe. However, if the allocation size calculation overflows (as in Case 4/5 analysis) or if `s->size` does not reflect the true needed size, a buffer overflow can occur. The pattern of allocating based on a size and then performing contiguous writes is very similar, providing good reference value for heap overflow scenarios.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 10 involves an Integer Overflow in a size calculation (`s->size + 1`) leading to an undersized allocation, followed by an OOB Write. This is the most direct parallel to the target code. The vulnerability chain (CWE-190 -> CWE-787) is identical to what could happen in the target: if `s->size` is `0xFFFFFFFF`, `size+1` wraps to `0`, causing a minimal allocation. The subsequent `gf_bs_read_data` would overflow the buffer, and the null terminator assignment `p->content_script_types[s->size] = 0` would be a massive OOB write. The code patterns and vulnerability mechanics are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      }
    ]
  },
  "CVE-2021-41201_before_exclude_100:7fee5302:vulspec": {
    "timestamp": "2026-01-17T00:39:14.636065",
    "cve_id": "CVE-2021-41201",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7fee5302",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves cryptographic side-channel vulnerabilities in libgcrypt. The target code is a string parsing/equation processing function in a tensor/math library with no cryptographic operations, timing sensitivity, or secret-dependent branching.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read in Perl's regex engine due to NUL byte handling. The target code processes equation strings for tensor operations using standard C++ containers (vector, InlinedVector) with bounds-checked access via .at(), making similar memory safety issues unlikely.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves integer overflow in libarchive's ISO parsing. The target code performs integer arithmetic for label counting and array indexing, but uses standard container sizes (size_t) and doesn't process untrusted binary data. Potential for overflow exists but pattern differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves cryptographic algorithm handling and NULL pointer dereference in BIND9. The target code performs non-cryptographic string parsing and label mapping with no algorithm selection, key processing, or complex error cleanup that could lead to NULL dereference.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves cryptographic signature verification flaws in axTLS. The target code is a parsing utility for mathematical equation notation with no cryptographic operations, ASN.1 parsing, or signature validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves privilege escalation through inconsistent access control in PostgreSQL. The target code is a pure parsing function with no authentication, authorization, or database privilege checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves buffer overflow in file utility's Pascal string handling. The target code processes strings and uses containers that could potentially have similar bounds checking issues, but uses modern C++ containers rather than raw buffers. Some similarity in parsing untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 involves heap buffer overflow due to negative integer validation in FFmpeg's HTTP parsing. The target code processes string labels and could potentially have integer validation issues in label counts, but doesn't parse network protocols or have direct memory allocation based on untrusted integers.",
        "case_metadata": {
          "cve_id": "CVE-2016-10190"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 involves buffer overflow/underflow in Ghostscript's font processing. The target code has array indexing (label_mapping, vectors) that could potentially have bounds issues, but the code patterns differ significantly - no font parsing or complex arithmetic on indices.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 involves buffer overflow in jq's JSON parser due to incorrect buffer size calculation. The target code processes string equations and uses containers that resize dynamically. While using safer C++ containers, similar logic errors in resizing or index calculation could occur, especially in the label counting and mapping logic.",
        "case_metadata": {
          "cve_id": "CVE-2015-8863"
        }
      }
    ]
  },
  "CVE-2021-41201_after_exclude_100:ed1dec54:vulspec": {
    "timestamp": "2026-01-17T00:39:32.843296",
    "cve_id": "CVE-2021-41201",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ed1dec54",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a side-channel timing attack in cryptographic operations (CWE-385). The target code is a string parsing function for equation labels with no cryptographic operations, constant-time requirements, or secret-dependent branches.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read (CWE-125) in a regex parser due to improper NUL byte handling. The target code parses equation strings using standard string operations and maps characters to integers. There is no regex parsing, character class handling, or similar complex pattern matching that could lead to analogous buffer over-reads.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an integer overflow (CWE-190) in archive parsing. The target code performs arithmetic (resizing vectors, incrementing counts) but uses standard container operations (e.g., `resize`, `at`) which typically perform bounds checking. The risk of integer overflow leading to memory corruption is lower, though not impossible if `num_labels` becomes very large. The core functionality (parsing vs. file format parsing) is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 involves a broken cryptographic algorithm leading to a NULL pointer dereference (CWE-327, CWE-476). The target code performs non-cryptographic label mapping and counting. There is no algorithm negotiation, cryptographic processing, or complex error cleanup that could lead to a similar NULL dereference chain.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an improper cryptographic signature verification (CWE-347) due to ASN.1 parsing flaws. The target code does not handle cryptographic signatures, certificates, or complex binary encoding formats like ASN.1. The parsing is simple character-to-integer mapping.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an access control flaw (CWE-284) in a database query planner. The target code is a pure parsing and computation function with no privilege checks, user/role concepts, or database interactions.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is an out-of-bounds read (CWE-119) due to incorrect length validation in string processing. The target code also processes input strings (`input_str`, `output_str`) and maps them to integer labels. While the target code uses safer abstractions (C++ vectors, `at()` for bounds-checked access), a similarity exists in parsing untrusted input strings and performing operations based on their content. However, the specific flaw pattern (off-by-one in length check for Pascal strings) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is a heap buffer overflow (CWE-122) due to improper validation of a numeric field (negative chunk size). The target code reads string input and performs integer operations (counting labels, indexing into vectors). While it validates indices via `at()` and `resize`, a theoretical risk exists if `label_mapping` produces an extremely large `num_labels`, leading to excessive memory allocation or integer overflow in subsequent loops. The connection is indirect.",
        "case_metadata": {
          "cve_id": "CVE-2016-10190"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is a buffer overflow (CWE-119) via integer handling issues in font glyph indexing. The target code uses integers as labels and indexes into vectors. A potential similarity lies in using untrusted input (equation string) to derive indices (`label`) for array access (`output_label_counts->at(label)`). If `label` could be a large negative number or exceed the vector bounds, and if `at()` was not used (or bypassed), a similar out-of-bounds access could occur. However, the target code uses `at()` and appears to map characters to consecutive non-negative integers, reducing risk.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a buffer overflow (CWE-119) due to an off-by-one error in buffer size calculation during JSON parsing. The target code uses C++ containers (`gtl::InlinedVector`, `std::vector`) which manage their own buffer growth, making a manual off-by-one error less likely. However, both involve parsing structured text input and managing internal data structures based on that input. The core vulnerability pattern (manual buffer management flaw) is not present in the target code's use of standard containers.",
        "case_metadata": {
          "cve_id": "CVE-2015-8863"
        }
      }
    ]
  },
  "CVE-2018-8905_before_exclude_100:324c9804:vulspec": {
    "timestamp": "2026-01-17T00:39:52.239023",
    "cve_id": "CVE-2018-8905",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "324c9804",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network service daemon related to inconsistent state management. The target code is a LZW decompression routine in an image library (likely libtiff). The domain (image parsing vs. network service), vulnerability type (memory corruption vs. UAF), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 is an Out-of-bounds Read in a regex parser due to improper NUL byte handling. The target code is a decompression algorithm. While both involve parsing complex input, the vulnerability mechanism (OOB read from NUL bytes in strings) and the data structures (regex parse trees vs. LZW code tables) are not similar. The core flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a buffer overflow in an image codec (OpenJPEG) due to incorrect buffer size calculation. The target code is also in an image library and involves careful buffer management (`occ` checks, length validation). There is a thematic similarity in image parsing and bounds checking. However, the specific flaw (padding calculation error) and code structure (allocation vs. stream decoding) are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is an Out-of-bounds Read in a network protocol parser (tcpdump) due to insufficient length validation. The target code performs length validation (`codep->length > occ`). The similarity ends at the concept of validating input lengths. The domains (network packet vs. compressed image data), data sources, and specific validation patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 is an Out-of-bounds Write due to integer overflow in a file transfer protocol. The target code uses `long` and `tmsize_t` types and has checks for overflow (`(tmsize_t) occ != occ0`). The relevance comes from the shared theme of preventing integer-related issues when calculating buffer sizes and positions during data processing. However, the vulnerability trigger (malicious length field causing wrap-around) is not directly mirrored in the LZW code, which focuses more on table integrity.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is an Improper Input Validation in a network protocol parser. The target code also validates input (e.g., checking `code > CODE_CLEAR`, `codep->length == 0`). This is a generic similarity. The specific context (LMP protocol subobjects vs. LZW code stream) and the nature of the missing checks are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 7 is a buffer overflow in a decompression module (ClamAV's Quantum decompression) due to improper validation of match operations against window boundaries. This is highly relevant to the target code, which is also a decompression algorithm (LZW). Both must manage a dictionary/code table, validate codes and lengths against output buffer boundaries (`occ`), and prevent writes beyond the buffer. The key flaw pattern--failing to properly validate that a decompression operation stays within limits--is conceptually similar. The main difference is the specific algorithm (LZ77/Quantum vs. LZW).",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 8 is a buffer overflow due to an unchecked header value leading to a huge memory allocation in an image converter. The target code performs runtime bounds checks but does not involve parsing file headers or allocating memory based on untrusted header fields. The vulnerability patterns are different (allocation size miscalculation vs. stream decoding logic error).",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is an Out-of-bounds Read in an XML parser due to improper buffer management during multi-byte character processing. The target code reads a stream of codes, not variable-byte characters. While both involve sequential input processing, the mechanisms for bounds checking and the causes of OOB access (character encoding errors vs. code table corruption) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is an Out-of-bounds Write in a text encoding converter due to unhandled error returns. The target code has error paths that return 0, but does not involve complex encoding conversion or ignoring function return values in a way that leads to buffer corruption. The flaw patterns are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2018-8905_after_exclude_100:22de8fb5:vulspec": {
    "timestamp": "2026-01-17T00:39:55.614040",
    "cve_id": "CVE-2018-8905",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "22de8fb5",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network service daemon due to uninitialized pointers and inconsistent state management. The target code is a LZW decompression routine in an image library (likely libtiff). The vulnerability types (memory corruption vs. decompression logic), domains (network service vs. image parsing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 is an Out-of-bounds Read in a regex compiler due to improper NUL byte handling. The target code is a decompression algorithm. While both involve parsing complex input, the vulnerability mechanism (buffer over-read from embedded NULs) and the context (string pattern compilation vs. stream decompression) are not similar. The only weak link is that both process external, potentially malicious input.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2021-43860_before_exclude_100:3cc7359b:vulspec": {
    "timestamp": "2026-01-17T00:40:06.504924",
    "cve_id": "CVE-2021-43860",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3cc7359b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a Flatpak bundle installation function that manages file metadata, remote configuration, and GPG keys. There is no similarity in vulnerability type (memory corruption vs. potential logic/state errors), trigger conditions (network packet vs. local file), or code patterns (low-level buffer manipulation vs. high-level application logic).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code parses bundle metadata using structured functions (flatpak_bundle_load) and does not involve low-level string parsing or regex compilation. The domains (language interpreter vs. software installation) and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in an image file parser. The target code processes Flatpak bundle files, but uses high-level library functions for metadata extraction. There is no indication of similar low-level buffer manipulation or file format parsing vulnerabilities. The attack surface (malformed image data vs. software bundle) and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a NULL pointer dereference in a kernel USB driver due to insufficient validation of URB fields. The target code performs higher-level application logic with extensive use of GLib abstractions (GError, GVariant). While both involve some level of state validation (e.g., checking deploy_data), the context (kernel driver vs. userspace package manager) and flaw nature (direct pointer dereference vs. potential logic errors) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in an XML parser. The target code does not parse XML directly; it uses structured data types (GVariant) returned from flatpak_bundle_load. The vulnerability patterns (parser state corruption vs. application logic flow) and code structures are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a double-free vulnerability related to improper resource cleanup during error handling. The target code uses GLib's automatic memory management (g_autoptr, g_steal_pointer) which significantly reduces the risk of manual memory management errors like double-free. However, both codes involve file/archive processing and have complex error paths. The similarity is limited to the high-level domain of processing external data sources, but the specific flaw mechanism is not present in the target code's patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is a NULL pointer dereference in a USB driver due to missing validation of hardware descriptors. The target code validates function returns (e.g., checking if metadata == NULL) but operates in a completely different context (userspace application logic vs. kernel hardware interaction). The trigger conditions (malicious hardware vs. malformed file) and code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves unbounded memory allocation and integer overflow in a network protocol handler. The target code does not perform any dynamic memory allocation based on untrusted sizes; it uses GLib functions for string operations and passes around already-loaded metadata. The vulnerability class and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow in a decompression algorithm due to improper input validation. The target code does not implement low-level decompression or parsing of compressed data; it relies on library functions. The domains (antivirus file scanning vs. software installation) and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in a network packet parser. The target code processes local bundle files, not network packets. The code structure (packet dissection loops vs. sequential file processing) and vulnerability type are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      }
    ]
  },
  "CVE-2021-43860_after_exclude_100:7b338a1f:vulspec": {
    "timestamp": "2026-01-17T00:40:53.799007",
    "cve_id": "CVE-2021-43860",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7b338a1f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a Flatpak bundle installation function that manages file metadata, remote configuration, and GPG keys. The domains (desktop application bundling vs. remote desktop protocol), vulnerability types (memory corruption vs. potential logic/validation errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code performs file parsing and system configuration. There is no regex compilation, complex string parsing with embedded NULs, or similar memory safety patterns in the provided Flatpak function.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 3 involves an out-of-bounds read in an image file parser due to improper string termination validation. The target code also parses a file format (Flatpak bundle) via `flatpak_bundle_load`, but the vulnerability pattern is different. The Flatpak code checks for missing metadata (`fp_metadata == NULL`) and returns an error, showing validation. The similarity is limited to \"parsing external files.\"",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 4 is a NULL pointer dereference in a USB kernel driver due to insufficient validation of URB fields. The target code is user-space application management code. While both involve checking for NULL (e.g., `gpg_data != NULL`), the context, attack surface (network packets vs. local file installation), and consequence severity are vastly different. The target code uses GLib's safe pointer patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in an XML parser due to insufficient bounds checking during end tag processing. The target code does not parse XML; it uses GLib/OSTree APIs to handle bundles and repository metadata. The code patterns and potential flaw locations are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a double-free vulnerability in a disk inspection library due to inconsistent state management during error handling. The target code uses GLib's automatic cleanup macros (`g_autoptr`, `g_autofree`), which greatly reduce the risk of double-free. However, both functions involve processing external data (disk images/bundles) and have multiple error return paths. The reference value is limited to the general principle of careful resource cleanup on error paths.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 7 is a NULL pointer dereference in a USB serial driver due to missing validation of USB descriptors. The target code is high-level application management. The only faint similarity is the validation of optional data (`gpg_data != NULL`), but the underlying vulnerability mechanism and context are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 involves improper bounds checking leading to unbounded memory allocation in a network protocol handler. The target code allocates memory via GLib/OSTree functions but does not process network packets or perform arithmetic on untrusted sizes from the network. The attack surfaces and vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 9 is an input validation flaw in a decompression module leading to memory corruption. The target code parses a bundle file which may involve decompression, but that logic is hidden inside `flatpak_bundle_load`. The provided code snippet focuses on higher-level bundle registration and remote configuration, not low-level parsing of compressed data. The similarity is only in the broad category of \"parsing external files.\"",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in a network packet dissector due to incorrect bounds checking after processing padding. The target code does not parse network protocols. The domains and the specific code patterns that could lead to the vulnerability are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      }
    ]
  },
  "CVE-2012-2370_before_exclude_100:2226e343:vulspec": {
    "timestamp": "2026-01-17T00:41:52.521735",
    "cve_id": "CVE-2012-2370",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2226e343",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code is a bitmap file parser with manual memory management (g_malloc/g_free). CVE-2016-3179 involves a Use-After-Free in a network daemon's state management. The vulnerability types (UAF vs. potential buffer overflows/integer issues), domains (file parsing vs. network protocol), and code patterns (linear file reading vs. asynchronous request handling) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve parsing formatted input (bitmap defines vs. numeric templates) and converting data. CVE-2015-0241 is a buffer overflow due to unchecked size. The target code has similar risks: it uses fixed-size buffers (line[MAX_SIZE]) with fgets and sscanf, and calculates `size` based on user-controlled `ww` and `hh` for g_malloc. The pattern of deriving allocation size from parsed input is similar, though the specific flaw (buffer overflow vs. integer overflow/wrap in size calculation) is not identical.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are image file parsers (BMP vs. XBM/XPM bitmap) that read header values and allocate memory based on those values. CVE-2017-12982 involves an allocation failure due to unchecked header values (biBitCount=0). The target code similarly reads `ww` and `hh` from the file and uses them to calculate `size` and allocate memory. A key similarity is the lack of robust validation on `ww` and `hh` before using them in arithmetic (e.g., for `bytes_per_line` and `size`), which could lead to integer overflows or excessive allocations.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8925 is a resource leak (reference counting) in a kernel USB driver. The target code is a user-space file parser with straightforward allocation/free patterns (g_malloc/g_free in a macro). The domains (kernel driver vs. library utility), vulnerability types (resource leak vs. memory corruption), and code patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve parsing data from a stream (file vs. network) and allocating memory based on values derived from that data. CVE-2018-20750 features an integer overflow leading to an out-of-bounds write. The target code calculates `size = bytes_per_line * hh` where `bytes_per_line` is based on `ww`. If `ww` and `hh` are large, this multiplication could overflow a 32-bit integer, leading to a smaller allocation than expected and subsequent heap buffer overflow during the `next_int` reading loop. This is a similar vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-10675 is a race condition leading to Use-After-Free in a kernel memory subsystem. The target code is a single-threaded, sequential file parser with no concurrency, locks, or complex resource sharing. The vulnerability types and code patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read due to improper NUL byte handling in a string parser. The target code uses `fgets` and `sscanf` on a `line` buffer, which are generally NUL-terminated. A tangential similarity exists in parsing input strings (`name_and_type`) and using string functions (`strrchr`, `strcmp`), but the specific trigger (embedded NUL) and consequence (OOB read) are not directly mirrored in the target code's logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-8924 is an integer underflow in a kernel USB driver. The target code performs integer arithmetic (`bytes_per_line = (ww+7)/8 + padding`, `size = bytes_per_line * hh`). If `ww` is very large (close to `GUINT_MAX`), the addition `ww+7` could wrap, leading to an incorrectly small `bytes_per_line` and `size`. This is an integer overflow/wrap concern, somewhat related to the integer underflow flaw, but the context and specific operations are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8924"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in a kernel key management subsystem. The target code performs no authentication, authorization, or permission checks; it's a pure data format parser. The domains and vulnerability classes are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve parsing binary/hexadecimal data from an input. CVE-2019-11222 is an out-of-bounds write due to insufficient bounds checking during hex parsing. The target code has a `next_int(fstream)` function (not shown here, but typical in XBM parsers) that likely reads hexadecimal numbers from the file. If `next_int` lacks proper validation or if the loop reading `value` into the `bits` buffer is incorrect (e.g., off-by-one due to padding logic), it could lead to an out-of-bounds write. The pattern of reading a sequence of formatted values into a calculated buffer is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      }
    ]
  },
  "CVE-2012-2370_after_exclude_100:142011d4:vulspec": {
    "timestamp": "2026-01-17T00:42:02.706034",
    "cve_id": "CVE-2012-2370",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "142011d4",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network daemon's state management. The target code is a bitmap file parser with straightforward memory allocation and error handling using g_malloc/g_free. There are no complex state machines, pointer aliasing, or error paths that leave dangling pointers, which are central to CVE-2016-3179.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in a string formatting function. The target code does involve parsing and buffer allocation (g_malloc) based on calculated sizes (bytes_per_line * hh). There is a similarity in performing calculations (size = bytes_per_line * hh) and checking for overflow, which is a defensive measure against the type of flaw in CVE-2015-0241. However, the target code's data source is a controlled file format and it uses safe allocation, making the core vulnerability pattern different.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 involves a memory allocation failure/issue due to unchecked header values in an image file parser (OpenJPEG/BMP). The target code is also an image file parser (bitmap/XBM) that reads header values (width, height) from a file, performs calculations, and allocates memory. The pattern is very similar: parse file header -> validate/calculate parameters -> allocate buffer. The key similarity is the trust in file input to guide memory allocation size. The target code does check for `value <= 0` and overflow, but flaws could lurk in the `bytes_per_line` calculation or `next_int` function.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a resource leak (reference count) in a kernel driver. The target code is a user-space file parser with simple allocate/free semantics (g_malloc/g_free). There are no reference counts, complex resource lifecycles, or persistent objects across function calls that could lead to CWE-404 issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 5 involves an integer overflow leading to an out-of-bounds write, triggered by malicious file transfer data. The target code contains a critical similar pattern: it calculates a buffer size (`size = bytes_per_line * hh`) and explicitly checks for integer overflow (`if (size / bytes_per_line != hh)`). This is a direct parallel to the vulnerability chain in CVE-2018-20750 (CWE-190 -> CWE-787). The context (file parsing vs. network protocol) differs, but the core flaw pattern of calculating an allocation size from untrusted input is identical and highly relevant for analysis.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a race condition leading to Use-After-Free in a kernel system call. The target code is a single-threaded, synchronous file parsing function with no concurrency, locks, or shared state. The memory management patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read due to improper NUL byte handling in a string parser. The target code reads lines with `fgets` and parses them with `sscanf`. While both parse input strings, the target code's vulnerability surface is different. A more relevant risk might be in the `next_int` function (not shown) or the line reading logic, but the direct pattern of CVE-2018-18313 (embedded NULs in regex) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an integer underflow in a USB driver's URB handling. The target code performs arithmetic but uses unsigned integers (guint, int for size) and checks for overflow. The operations (`(ww+7)/8`, `bytes_per_line * hh`) are not typical underflow candidates. The code patterns and domain (kernel driver vs. file parser) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8924"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 9 is a missing authorization flaw in a kernel key management subsystem. The target code performs no authorization checks, access control, or permission validation. It is a pure data processing function. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is an out-of-bounds write during binary data parsing. The target code parses a hex-encoded data array from a file (`next_int` likely reads hex values) into an allocated buffer. The pattern of parsing external binary/hex data into a fixed-size buffer is similar. The risk in the target code depends heavily on the implementation of `next_int` and whether the loop correctly enforces the `size` limit. The similarity lies in the \"parse untrusted formatted data into a buffer\" pattern, though the specific flaw mechanics may differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      }
    ]
  },
  "CVE-2022-27382_before_exclude_100:922e32b0:vulspec": {
    "timestamp": "2026-01-17T00:42:42.950587",
    "cve_id": "CVE-2022-27382",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "922e32b0",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a database query optimizer function dealing with equality propagation and memory allocation for cloned items. The domain (database internals vs. regex parsing), vulnerability type (logic/alloc errors vs. buffer over-read), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's resource cleanup path. The target code performs memory allocation and list management within a database. While both involve C/C++ and potential memory management errors, the context (network service error handling vs. query optimization), flaw trigger, and specific patterns (uninitialized pointers vs. clone/build failures) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow in an image codec due to incorrect size calculation. The target code allocates Item objects and manages a list. Both involve C/C++ and allocation, but the vulnerability mechanism (integer miscalculation leading to heap overflow vs. missing NULL checks or push_back failures) and domain (image processing vs. database) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-15166 is an improper input validation leading to potential memory corruption in a network packet parser. The target code is an internal database function that processes its own internal data structures (Item_equal). There is no parsing of untrusted external data streams in the target code, and the flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper buffer management during multi-byte character processing. The target code does not parse external data formats or perform low-level buffer reads. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1835 is a use-after-free in an XML parser related to attribute memory management. The target code also involves C++ object management (Item clones) and could theoretically have similar issues if object references were mishandled. However, the specific trigger (XML namespace/attribute processing) and code patterns are very different. The weak link is the general concept of managing object lifecycles and references.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML end-tag parser. Similar to case 5, this involves parsing untrusted data with insufficient bounds checks, which is not the activity performed by the target database optimization code.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to missing validation of a length field. The target code does not parse TLV structures or network packets. The domains and vulnerability causes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 involves an integer overflow/wraparound leading to an out-of-bounds write. The target code performs memory allocation (`new`) and could be susceptible to similar issues if size calculations were present. While the current code shows no obvious integer arithmetic, the context of C++ memory management and the potential for allocation-related vulnerabilities provides a faint conceptual link. The primary difference is the absence of visible size calculations in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2010-1311 is an improper input validation leading to a buffer overflow in a decompression module. The target code does not decompress or parse complex file formats. The attack surface and code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-27382_after_exclude_100:850c669c:vulspec": {
    "timestamp": "2026-01-17T00:43:11.428630",
    "cve_id": "CVE-2022-27382",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "850c669c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code is a MySQL/ MariaDB query optimizer function dealing with equality propagation and item cloning. The domains (database internals vs. regex parsing), vulnerability types (logic/state management vs. memory corruption), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management during error handling. The target code performs memory allocation and object cloning but within a controlled SQL item context using a provided memory root (`thd->mem_root`). The error paths return booleans and do not involve complex, inconsistent state cleanup of network resources. The attack surfaces and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow in an image codec due to incorrect size calculation for padding. The target code deals with SQL item trees and creates equality objects. While both allocate memory, the target code uses `new` with a memory root and checks for allocation success, lacking the arithmetic miscalculation flaw central to the OpenJPEG case. The domains and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-15166 stems from improper input validation (CWE-20) in a network packet parser, leading to missing bounds checks. The target code also involves processing input (items in an equality group) and has validation (`checker` function pointer). However, the context is utterly different: SQL query optimization vs. binary protocol parsing. The \"validation\" in the target code is a caller-supplied predicate, not direct bounds checking on untrusted data. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper multi-byte character buffer management. The target code performs iteration over a list of `Item` objects and clones them. There is no parsing of external byte streams, character encoding, or buffer boundary checks involved. The code patterns and vulnerability root causes are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-1835 is a use-after-free in libxml2 during attribute processing. The target code also manipulates object trees (SQL items) and calls `set_item_equal(NULL)` on clones, which could be analogous to breaking references. However, the target code's primary operations are cloning and list insertion, with memory managed by `thd->mem_root`, making a classic use-after-free less likely. The similarity is superficial; the reference value is limited to the concept of managing object relationships.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML end tag parser. The target code iterates using an `Item_equal_fields_iterator`. While both involve iteration, the target code's iterator operates on a controlled collection of objects, not a raw character buffer where bounds can be miscalculated. The vulnerability patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read due to insufficient validation of a length field in a network protocol. The target code validates items using a `checker` callback, which is a form of input validation. However, the \"length\" and \"buffer\" concepts are absent in the target code's domain of SQL item trees. The similarity is only at the abstract level of having a validation step.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves an integer overflow/wraparound (CWE-190) leading to an undersized allocation and subsequent out-of-bounds write. The target code performs memory allocation (`new`) and has error paths. While no obvious integer overflow is present in the shown code, the pattern of allocating based on derived data (cloned items) and the potential for memory corruption if internal invariants are broken shares a conceptual similarity with memory safety issues in object management. The reference value is notable but not strong.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2010-1311 involves improper input validation in a decompression algorithm leading to out-of-bounds writes. The target code has a validation mechanism (`checker`). The core flawfailing to validate operations against buffer boundariesis not present in the target code's logic of iterating and cloning items. The domains (compression vs. SQL optimization) are too different for meaningful comparison.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2013-4166_before_exclude_100:365db432:vulspec": {
    "timestamp": "2026-01-17T00:43:59.154910",
    "cve_id": "CVE-2013-4166",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "365db432",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves complex integer overflow leading to out-of-bounds write in a network protocol parser. The target code is a simple helper function adding a string to an array with no arithmetic, memory allocation size calculations, or protocol parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code performs a straightforward string duplication and array addition with no input parsing or buffer boundary checks involved.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in a network packet parser due to insufficient length validation. The target code has no length fields to validate, no network data processing, and no buffer reading operations.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a NULL pointer dereference in a USB driver due to missing validation of hardware descriptors. The target code does have a potential NULL pointer issue (gpg could be NULL, but not checked), but the context (driver vs. application library) and trigger conditions (hardware vs. API call) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is a NULL pointer dereference in a network virtualization driver due to insufficient validation of URB fields. The target code shares the superficial characteristic of missing a NULL check for the 'gpg' parameter, but the domain (kernel USB/IP vs. user-space GPG context), data sources, and consequences are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a race condition leading to a NULL pointer dereference in a kernel keyring subsystem. The target code is not thread-safe (missing locks on `gpg->recipients` access) and could have a concurrency issue, but the code pattern (simple add operation) and severity context (kernel vs. library) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves unbounded memory allocation and integer overflow in a network protocol handler. The target code uses `g_ptr_array_add` which internally manages memory, but there is no calculation of allocation size from untrusted input, which is the core of the vulnerability in Case 7.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in an image file parser due to improper string termination validation. The target code does not read from or parse any external data buffers; it only duplicates a provided string.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a race condition in a filesystem's resource management. The target code's `gpg->recipients` array could be subject to a race condition if called concurrently without synchronization (similar to the non-atomic check-and-use flaw), providing a minor conceptual similarity in concurrency flaws.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a race condition leading to buffer overflow in a kernel TTY subsystem. The target code shares the broad category of a potential concurrency issue (multiple threads calling this function could corrupt the `gpg->recipients` array state), but the specific mechanism (buffer overflow vs. array/list corruption) and environment differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2013-4166_after_exclude_100:a3837e47:vulspec": {
    "timestamp": "2026-01-17T00:44:11.583534",
    "cve_id": "CVE-2013-4166",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a3837e47",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol parser. The target code performs simple string formatting and array management with no arithmetic, memory allocation, or protocol parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read due to improper NUL byte handling in a regex compiler. The target code uses standard C string functions (`strchr`, `g_strdup`) but does not involve complex parsing, character class handling, or buffer over-reads.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 involves a NULL pointer dereference due to missing validation of USB descriptors. The target code has a `g_return_if_fail (keyid != NULL)` check, which is a defensive check for NULL input, but the vulnerability patterns (driver initialization, hardware descriptors) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 involves a NULL pointer dereference in a USB/IP driver due to inconsistent state validation. The target code has a NULL check for an input parameter, but the context (network protocol handling, URB processing) and the root cause (state inconsistency) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 involves a race condition leading to a NULL pointer dereference in a kernel keyring subsystem. The target code shows no concurrency control mechanisms (locks, atomic operations) and operates on a simple array. The shared resource and synchronization context are absent.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves unbounded memory allocation and integer overflow in a network driver. The target code uses `g_strdup` and `g_ptr_array_add`, which internally manage memory, but there is no arithmetic on user-controlled sizes or risk of integer overflow in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves an out-of-bounds read in an image file parser due to improper string termination validation. The target code reads a string and adds angle brackets, but does not parse binary file formats or read beyond allocated buffers.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 involves a race condition in a filesystem's node ID management. The target code modifies a `GPtrArray` but shows no locking or atomic operations. While both manage data structures, the concurrency vulnerability pattern is not present in the simple, presumably single-threaded utility function.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 involves a race condition leading to buffer overflow in a kernel TTY subsystem. The target code has no buffers subject to concurrent modification, no shared state between threads, and no low-level buffer management. The synchronization flaw pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2022-27383_after_exclude_100:521b53e3:vulspec": {
    "timestamp": "2026-01-17T00:45:05.647913",
    "cve_id": "CVE-2022-27383",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "521b53e3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex engine due to improper NUL byte handling. The target code performs string manipulation and memory allocation with fixed extension length, with no regex parsing or character class processing. The vulnerability patterns and code contexts are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon related to inconsistent state management during error handling. The target code is a simple string fixup function with straightforward memory allocation and copying, lacking complex state management or error paths that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves an out-of-bounds read in a network protocol parser due to insufficient validation of length fields. The target code does not parse network protocols, has no TLV structures, and performs simple string operations with known lengths. The attack surfaces and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves an out-of-bounds write due to integer overflow in memory allocation. The target code uses `alloc_root` with `dl->length + so_ext_len + 1`, which could theoretically overflow if `dl->length` is very large. However, the target code lacks the specific integer conversion/wraparound context (uint32_t to int) and file transfer protocol context of Case 4. The similarity is limited to the potential for arithmetic overflow in allocation size calculation.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a double free vulnerability in an antivirus VBA parser during error conditions. The target code allocates memory but does not free it within the function, and has no error paths that could lead to double free. The memory management patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 involves integer overflow leading to out-of-bounds write in DNS domain name parsing. Similar to Case 4, the target code's `dl->length + so_ext_len + 1` calculation could overflow, but the context is different (string extension vs. domain name wire format conversion). The integer overflow potential exists but the triggering conditions and code patterns are not identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 involves buffer overflow in IPv6 RA message processing due to negative length values. The target code uses unsigned `size_t` for length calculations and doesn't process network protocol messages with signed length fields. While both involve buffer operations, the vulnerability mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves improper input validation in a decompression module leading to buffer overflow. The target code performs simple string copying without complex decompression algorithms or sliding window management. The code domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves out-of-bounds read in XML parsing due to inadequate bounds checking during multi-byte character processing. The target code uses standard C string functions (memcpy, strcpy) with calculated lengths, not character-by-character parsing of encoded data. The vulnerability contexts are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves out-of-bounds read in XML end tag parsing. The target code doesn't parse structured markup languages and has no equivalent to XML document hierarchy processing. The code functionality and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-27383_before_exclude_100:1656af0e:vulspec": {
    "timestamp": "2026-01-17T00:45:06.099537",
    "cve_id": "CVE-2022-27383",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1656af0e",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex engine due to improper NUL byte handling. The target code performs string manipulation and memory allocation with fixed extension length. The vulnerability type (CWE-125 vs. potential buffer overflow), domain (parsing vs. path fixing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon related to inconsistent state management. The target code is a simple string fixup function using a memory root allocator, with no complex state or pointer management that could lead to a use-after-free. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse network data and uses a fixed, known extension length (`SO_EXT`). While both involve bounds considerations, the context, data source, and vulnerability mechanism are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 involves an out-of-bounds write due to integer overflow in a size calculation. The target code calculates `dl->length + so_ext_len + 1`. If `dl->length` is very large (near `SIZE_MAX`), this addition could wrap, leading to undersized allocation and subsequent buffer overflow via `memcpy`/`strcpy`. The pattern of integer wrap leading to buffer overflow is conceptually similar, but the trigger (malicious network data vs. internal string) and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a double-free during error handling in a file parser. The target code has no explicit free operations and uses a memory root allocator which typically manages deallocation differently. The flaw patterns and memory management models are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves an integer overflow in a length calculation leading to an out-of-bounds write, similar to the reasoning for Case 4. The target code's `dl->length + so_ext_len + 1` calculation is a potential integer overflow point. However, the domain (DNS parsing vs. library path fixing) and data source are different, reducing direct relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 involves buffer overflow due to improper bounds checking (CWE-119/120). The target code uses `memcpy` and `strcpy` on a newly allocated buffer without explicitly checking if the source `dl->str` is null-terminated or if `dl->length` is valid before the copy. If `dl->length` does not account for a null terminator in the source, `memcpy` could read out-of-bounds, and `strcpy` could write out-of-bounds. The pattern of copying data without sufficient validation is similar, but the context (network protocol vs. string manipulation) differs.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an improper input validation leading to buffer overflow in a decompression module. The target code performs simple string concatenation, not complex parsing or decompression. The attack surface and code complexity are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in an XML parser due to multi-byte character handling issues. The target code uses single-byte character operations (`memcpy`, `strcpy`) and does not process complex encodings. The vulnerability patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in an XML parser during end tag processing. The target code does not parse a structured language and has no analogous tag or hierarchy processing. The domains and flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-2980_before_exclude_100:7cc390cd:vulspec": {
    "timestamp": "2026-01-17T00:45:37.407497",
    "cve_id": "CVE-2022-2980",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7cc390cd",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a complex mouse event handler in a text editor (likely Vim). Case 1 involves a regex engine vulnerability (CWE-125) due to improper NUL byte handling. The domains (UI event handling vs. string parsing), vulnerability types (logic/state errors vs. memory corruption), and code patterns are fundamentally different. There is almost no reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 2 is a Use-After-Free in a network daemon's memory management. The target code is a synchronous UI handler with static variables and no dynamic memory allocation/deallocation in the shown path. The attack surfaces (local socket vs. user mouse events) and flaw patterns (memory lifecycle errors vs. state machine logic) are completely dissimilar. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 3 is an Out-of-bounds Read in an XML parser due to multi-byte character processing errors. The target code processes mouse coordinates and editor state, performing array indexing only on fixed structures like `TabPageIdxs`. The code patterns (character encoding loops vs. event-driven conditionals) and vulnerability root causes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 4 is an Integer Overflow leading to Out-of-bounds Write in a network file transfer protocol. The target code performs arithmetic on counts and coordinates but within small, controlled ranges (e.g., `mouse_col < Columns`). There is no dynamic buffer allocation based on user-controlled integers. The contexts and exploit primitives are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 5 is another XML parser Out-of-bounds Read. Similar reasoning to Case 3. The target code's parsing is limited to simple mouse event codes and modifier masks, not complex document structures. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 6 is an Out-of-bounds Read in a network packet parser due to insufficient TLV length validation. The target code validates mouse coordinates against window boundaries (e.g., `mouse_row < curwin->w_winrow`). While both involve validating external input, the nature of the input (network packet bytes vs. screen coordinates) and the consequences of failure (memory read vs. incorrect UI action) are too distinct for reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 7 is a NULL Pointer Dereference due to an unbalanced stack (push/pop mismatch). The target code manages visual mode state and has complex conditional paths that could theoretically lead to an inconsistent state (e.g., `VIsual_active` flag mismatches). However, the code shows extensive state checks and the flaw pattern (graphics state stack vs. editor mode flags) is only superficially similar. Very weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 8 is Improper Input Validation in a network protocol parser. The target code does perform input validation (e.g., checking `mouse_has()` settings, `mod_mask` checks). However, the context is utterly different: validating protocol fields for memory safety vs. validating UI events for correct application behavior. The security impact and exploitation models are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 9 is an Out-of-bounds Write in an image renderer due to incorrect position tracking. The target code tracks cursor position (`curwin->w_cursor`) and mouse coordinates. A logic error in tracking could lead to an out-of-bounds array access (e.g., on `TabPageIdxs`), but the code shows careful bounds checking. The domain (image pixel buffer vs. editor line/column) and typical flaw patterns are too different for useful reference.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 4,
        "reasoning": "Case 10 is a Heap Buffer Overflow in an IRC client due to incorrect buffer size calculation during formatted text decoding. The target code uses `stuffReadbuff` and `stuffcharReadbuff` functions, which write to an input buffer. If these functions have insufficient bounds checking, a similar issue could arise from chaining many mouse actions. The pattern of accumulating data into a buffer based on external input has some parallel. However, the target code's stuffing is limited and controlled by `count`, and the primary vulnerability class in the mouse handler is more likely to be state confusion or logic errors. Weak relevance, but slightly higher than others due to the buffer manipulation concept.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      }
    ]
  },
  "CVE-2022-2980_after_exclude_100:5b7c0477:vulspec": {
    "timestamp": "2026-01-17T00:45:43.104864",
    "cve_id": "CVE-2022-2980",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5b7c0477",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a complex mouse event handler in a text editor (likely Vim), dealing with UI state, visual mode, and buffer operations. CVE-2018-18313 is a regex parsing vulnerability in Perl involving out-of-bounds reads from NUL bytes. The domains (UI interaction vs. string parsing), vulnerability types (logic/state errors vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code handles mouse clicks, drags, and visual mode selection within a single process. CVE-2016-3179 is a use-after-free in a network daemon (MiniSSDPd) related to socket message processing and resource cleanup. The attack surfaces (local GUI events vs. network packets), memory management patterns, and core flaw types are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is UI logic with extensive state machine handling for mouse actions. CVE-2016-1833 is an out-of-bounds read in libxml2's low-level character encoding parser. The code deals with abstract syntax trees and byte buffer boundaries, which is unrelated to the high-level control flow and window management seen in the target.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs mouse coordinate processing, mode transitions, and editor command simulation. CVE-2018-20750 is an integer overflow leading to heap corruption in a network file transfer protocol (VNC). The vulnerability root cause (integer math on untrusted network data) and context are absent from the provided GUI interaction code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code manipulates editor cursors, visual ranges, and inserts text. CVE-2016-1838 is another libxml2 parser out-of-bounds read during end-tag processing. The structured document parsing vulnerability has no parallel in the interactive, event-driven mouse handling logic.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code validates mouse positions within window boundaries and tab lines. CVE-2018-14461 is an out-of-bounds read in tcpdump's network protocol parser due to insufficient TLV length validation. While both involve checking bounds (screen coordinates vs. packet data), the domains, data sources, and consequences are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The primary connection is the potential for state management errors. The target code manages complex UI state (VIsual_active, mod_mask, drag states) and could theoretically have logic flaws leading to unexpected states (e.g., NULL pointer dereference if a state variable is incorrectly assumed). CVE-2016-10218 is a NULL pointer dereference in Ghostscript due to an unbalanced transparency stack (push/pop). Both involve maintaining a state stack/context, but the target code's state is more about user interaction mode than a resource stack. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does parse some input (mouse event codes via get_mouse_button), but this is simple decoding, not complex, untrusted protocol parsing. CVE-2019-15166 is an input validation flaw in tcpdump's LMP parser. The scale and risk of input validation are not comparable; mouse events are typically trusted input from the local system.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs positional calculations (mouse_row, mouse_col, cursor positions) but does not involve writing to image buffers or complex raster graphics processing. CVE-2020-16304 is an out-of-bounds write in Ghostscript's image rendering pipeline due to incorrect coordinate tracking. The underlying flaw pattern (miscalculated write index) is generic, but the specific context of image pixel buffers is absent from the target.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. This is the most relevant case due to a shared pattern of dynamic buffer growth for user-generated content. The target code uses `stuffReadbuff`, `stuffcharReadbuff`, and `AppendCharToRedobuff` functions to build command sequences based on mouse actions. While not shown in the snippet, these functions likely manage a buffer. A flaw could exist if mouse actions (e.g., rapid drags generating many commands) cause this buffer to overflow if its growth is incorrectly managed. CVE-2012-5854 is a heap buffer overflow in WeeChat's IRC color decoder due to insufficient buffer growth calculation. The similarity is in the pattern of building a string output from input events. However, the target's buffer is for internal command replay, not directly parsing untrusted network data, making the attack surface and risk profile significantly lower. Provides some reference for auditing buffer management in the `stuff*` functions.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      }
    ]
  },
  "CVE-2022-30592_before_exclude_100:9d4f4a5b:vulspec": {
    "timestamp": "2026-01-17T00:45:52.214673",
    "cve_id": "CVE-2022-30592",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9d4f4a5b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to an out-of-bounds write in a file transfer protocol. The target code is a QUIC/QPACK settings initialization function with no complex integer arithmetic, dynamic memory allocation, or file/data stream parsing. The vulnerability patterns and code contexts are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a buffer overflow in an image codec due to insufficient padding allocation. The target code performs library initialization (`lsqpack_enc_init`) with passed parameters but does not itself perform any buffer calculations or allocations that could lead to similar padding-related overflows. The functional domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a Use-After-Free due to uninitialized pointers and error handling. The target code is a straightforward initialization function with clear state flags (`QEH_HAVE_SETTINGS`). It has simple error returns but no complex resource allocation, cleanup, or pointer management that could lead to a UAF. The code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code does not parse or compile complex input strings (like regex patterns). It validates internal state flags and calls an external library initializer. The attack surface and data processing nature are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an input validation flaw in a decompression algorithm leading to buffer overflow. The target code does not parse or decompress any external data formats. It sets up encoder parameters. The core vulnerability mechanism (failing to validate match operations against a sliding window) has no parallel in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code is not a packet parser; it is an internal state initialization function. There is no parsing of TLV structures or similar untrusted network data where length fields must be validated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is another network protocol parsing vulnerability (LMP) due to lack of bounds checking. Similar to Case 6, the target code's purpose (library component initialization) is fundamentally different from parsing untrusted network packets. The code patterns and potential flaws are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves missing sentinel values in buffer management leading to overreads. The target code manages no data buffers directly; it passes a static buffer (`qeh_tsu_buf`) and its size to an external library. There is no manipulation of chunked data or string termination issues present.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is an integer overflow in domain name length calculation leading to a buffer overflow. The target code passes several unsigned integer parameters (`max_table_size`, `dyn_table_size`, `max_risked_streams`) to `lsqpack_enc_init`. There is a *potential* similarity if these parameters originate from an untrusted source (e.g., network peer) and could cause an integer issue within the external library. However, the target code itself performs no arithmetic, making the relevance indirect and weak.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in an XML parser during end tag processing. The target code does not parse any structured markup language. It is a simple control function with state checking. The vulnerability patterns (parser state manipulation) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-30592_after_exclude_100:2e7490ac:vulspec": {
    "timestamp": "2026-01-17T00:46:42.435095",
    "cve_id": "CVE-2022-30592",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2e7490ac",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to an out-of-bounds write in a file transfer protocol. The target code performs QPACK encoder initialization with parameter validation and bounds checking (e.g., `QENC_MIN_DYN_TABLE_SIZE > dyn_table_size`). No arithmetic operations on user-controlled sizes that could overflow are present. The domains (HTTP/3 QPACK vs. VNC file transfer) and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a heap buffer overflow due to insufficient padding allocation in an image codec. The target code initializes an external encoder (`lsqpack_enc_init`) with size parameters but does not perform low-level buffer allocation or padding calculations itself. The risk of miscalculation leading to overflow is delegated to the `lsqpack_enc_init` implementation, which is not shown. The code patterns and functionality are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a Use-After-Free due to inconsistent state management during error handling. The target code has a simple error path returning -1, but it does not involve complex resource allocation, cleanup, or pointer management that could lead to a UAF. The flag `QEH_HAVE_SETTINGS` is only set after successful initialization, preventing double initialization. The patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read due to improper NUL byte handling in a regex parser. The target code does not parse string/data inputs from untrusted sources; it processes numeric parameters for encoder configuration. There is no string/buffer parsing logic that could be confused by embedded NULs. The domains and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is improper input validation in a decompression module leading to memory corruption. The target code validates a size parameter against a minimum constant and calls an external initialization function. It does not implement a complex stateful parsing/decompression algorithm where match operations or window boundaries need validation. The functionality is not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code is not a parser; it is a setup/configuration function. It receives numeric parameters, performs a basic comparison, and passes them to an encoder init function. There is no parsing of TLV-like structures or length-field validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is improper input validation in a network protocol parser leading to potential memory corruption. Similar to Case 6, the target code does not parse packet data. Its input validation is limited to checking a flag and a size against a constant. The attack surface and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves improper buffer management and missing sentinel values in a network data buffer subsystem. The target code manages encoder state and flags but does not handle raw data buffers or string termination. The `qeh_tsu_buf` is passed to `lsqpack_enc_init`, but its management is external. No similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is an integer overflow in domain length calculation leading to an out-of-bounds write. The target code performs arithmetic operations on unsigned integer parameters (`max_table_size`, `dyn_table_size`, `max_risked_streams`). While there is a check `QENC_MIN_DYN_TABLE_SIZE > dyn_table_size`, there is no validation for overflow in calculations (e.g., if these parameters are derived from untrusted input and used in subsequent allocations within `lsqpack_enc_init`). The potential similarity is the passing of unchecked size parameters to a downstream allocator, but the target code itself does not perform the vulnerable arithmetic. The relevance is weak.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in an XML parser due to insufficient bounds checking during end tag processing. The target code does not parse a hierarchical document format or maintain a complex parser state stack. It performs configuration based on function arguments. No similarity in code patterns or vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-23588_before_exclude_100:4d379eee:vulspec": {
    "timestamp": "2026-01-17T00:46:44.218314",
    "cve_id": "CVE-2022-23588",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4d379eee",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression parser due to improper NUL byte handling. The target code is a constant folding evaluator in a computational graph framework (likely TensorFlow) that deals with tensor data and node evaluation. The domains (regex parsing vs. graph optimization), vulnerability types (memory read vs. potential logic/validation errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library's elliptic curve multiplication. The target code performs constant folding evaluation without any cryptographic operations or secret-dependent branching that could leak timing information. The core flaw (non-constant-time execution) and context are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-7972 involves resource management errors (inconsistent memory tracking) in a subtitle renderer. The target code also manages resources (Tensor objects, cleanup via RAII) but in a very different context. There is a superficial similarity in managing allocated objects and cleanup, but the specific flaw pattern (inconsistent size tracking) is not evident in the provided code, which uses explicit cleanup scopes.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control vulnerability in a database query planner related to privilege checks. The target code performs mathematical evaluation of constant nodes in a computational graph and has no authentication, authorization, or privilege checking mechanisms. The domains and vulnerability classes are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2013-0211 involves a numeric conversion error (signed/unsigned) leading to potential buffer overflow in an archive library. The target code handles tensor sizes (`total_inputs_size` is a `size_t`) and checks for result size limits (`result_too_large`). There is a tangential similarity in the need to validate sizes/numeric conversions to prevent overflow or excessive resource consumption, but the specific conversion flaw and context (archive writing vs. graph evaluation) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow during file position calculation in an archive parser. The target code sums tensor sizes (`total_inputs_size += value->TotalBytes()`) which could theoretically overflow if inputs are maliciously large, though it's a `size_t`. The `CreateNodeDef` function (not shown) likely checks size. There is a conceptual similarity in calculating aggregate sizes, but the code pattern (parsing file structures vs. summing known tensor sizes) and the specific trigger (crafted ISO descriptors) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a broken cryptographic algorithm leading to a NULL pointer dereference in a DNS server. The target code does not perform cryptographic operations or algorithm validation. The error handling in the target code uses `Status` objects and early returns, making a similar NULL dereference chain unlikely.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2014-9652 is an out-of-bounds read due to incorrect length validation in a file type detector. The target code validates tensor shapes and data types when creating `Tensor` objects from protobufs (`value->FromProto`). There is a broad similarity in validating input data (protobuf vs. file bytes) to ensure memory safety, but the specific flaw (off-by-one in Pascal string length check) and domain are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-12858 is a double-free caused by inconsistent buffer management on error paths in a ZIP parser. The target code uses a cleanup lambda (`inputs_cleanup`) to delete `Tensor` objects in both the `inputs` and `output_tensors` vectors, ensuring cleanup on both success and failure paths (due to early returns). This is a robust RAII pattern designed to *prevent* double-free and leak issues. The relevance is in the domain of resource management and error path cleanup, but the target code's pattern appears to be a correct implementation of the safety pattern that CVE-2017-12858 violated.",
        "case_metadata": {
          "cve_id": "CVE-2017-12858"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser due to unbounded string copying. The target code does not parse untrusted string formats directly; it processes serialized tensor protobufs and node definitions within a controlled framework. The vulnerability pattern and attack surface are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      }
    ]
  },
  "CVE-2022-23588_after_exclude_100:7bc52655:vulspec": {
    "timestamp": "2026-01-17T00:47:21.032835",
    "cve_id": "CVE-2022-23588",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7bc52655",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a constant folding evaluator in a computational graph framework (likely TensorFlow). The domains (regex compilation vs. graph optimization), vulnerability types (memory read vs. potential logic/DoS), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library's elliptic curve implementation. The target code performs deterministic graph node evaluation with no cryptographic operations or secret-dependent branches. The attack surfaces (physical emanations vs. graph input) and flaw nature (timing leak vs. potential resource exhaustion) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7972 involves resource management errors (CWE-399) in a subtitle renderer. The target code also manages resources (Tensor memory allocation/deallocation via `inputs_cleanup`). There is a superficial similarity in managing allocated objects and cleanup on error paths. However, the specific flaw (inconsistent memory tracking) and domain (multimedia vs. ML framework) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control (CWE-284) vulnerability in a database query planner. The target code performs constant folding within a single process/context with no privilege checks or multi-user access control mechanisms. The domains and vulnerability classes are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2013-0211 involves a numeric conversion error (CWE-189) leading to potential buffer overflow in libarchive. The target code performs size calculations (`total_inputs_size += value->TotalBytes()`) and has checks for result size being \"too large\" (`result_too_large`). While both handle size tracking, the target code's primary vulnerability pattern is not a signed/unsigned conversion flaw but rather resource exhaustion or integer overflow during size accumulation. The context (archive writing vs. graph optimization) differs.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-5844 is an integer overflow (CWE-190) in an archive parser. The target code sums tensor sizes (`total_inputs_size += value->TotalBytes()`) which could theoretically overflow if inputs are large/malicious, though it's protected by a later check (`CreateNodeDef` may check size). The similarity is in integer accumulation for size tracking. However, the target code's overflow would likely lead to DoS (allocation failure) rather than memory corruption, and the domain is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a broken crypto algorithm leading to a NULL pointer dereference in a DNS server. The target code has no cryptographic operations, algorithm negotiation, or complex error state cleanup that could leave dangling pointers. The vulnerability patterns and domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2014-9652 is a buffer over-read in a file type detection utility due to improper length validation. The target code reads serialized tensor protobufs (`Tensor* value = new Tensor(...); if (!value->FromProto(raw_val)) {...}`), which involves parsing untrusted data. There is a distant similarity in parsing external data formats, but the vulnerability mechanism (length field validation vs. protobuf deserialization) and code patterns are different. The target code relies on the protobuf library's validation.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-12858 is a double-free in a ZIP library due to inconsistent state management on error paths. The target code uses a cleanup lambda (`inputs_cleanup`) to delete tensors, ensuring cleanup even if an error occurs later. This is a robust pattern that *prevents* double-free/resource leaks. The relevance is inverse: the target code demonstrates good practice against the flaw type seen in the CVE. The domain (archive parsing vs. graph eval) is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12858"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser. The target code does not parse raw string input into fixed-size stack buffers. It uses heap allocation for tensors and standard library/data structure operations. The vulnerability pattern and domain are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      }
    ]
  },
  "CVE-2021-37640_before_exclude_100:9d3d92f0:vulspec": {
    "timestamp": "2026-01-17T00:47:34.443584",
    "cve_id": "CVE-2021-37640",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9d3d92f0",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel timing attack in a cryptographic library. The target code is a tensor reshaping utility with no cryptographic operations, secret-dependent branches, or timing-sensitive logic. The vulnerability types (CWE-200/385 vs. potential integer/bounds issues) and domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7972 involves resource management errors and memory tracking inconsistencies in a subtitle renderer. The target code performs shape validation and tensor allocation with explicit checks (OP_REQUIRES). While both handle some form of data reshaping/parsing, the core flaw (inconsistent internal state tracking) and context (multimedia vs. tensor computation) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-17787 is an out-of-bounds read due to improper string termination validation in an image parser. The target code validates tensor shapes and dimensions but does not parse strings or external file data. The similarity is limited to the general theme of input validation, but the specific vulnerability pattern (buffer over-read) and data types are not present in the target.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2009-3909 is an integer overflow leading to a heap buffer overflow in an image parser. The target code performs arithmetic operations (product *= size, dense_size / product) on user-influenced values (target_shape, dense_size). While the target has checks (product * missing == dense_size), the pattern of dimension calculation and validation is conceptually similar. However, the target's context (sparse tensor reshaping) and specific overflow risks differ from PSD file parsing.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control vulnerability in a database query planner involving privilege checks. The target code performs no authentication, authorization, or privilege checks. The domains (database security vs. tensor manipulation) and vulnerability types (CWE-284 vs. potential integer/bounds issues) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to insufficient memory allocation padding in an image codec. The target code allocates output tensors based on calculated dimensions (nnz, output_rank). There is a similarity in ensuring allocation sizes are sufficient for computed shapes. However, the target's allocation is straightforward (context->allocate_output) without complex padding logic, and the overflow vector (padding miscalculation) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser due to unsafe hex string conversion. The target code does not parse strings, convert hex, or use fixed-size stack buffers. The vulnerability pattern (unbounded copy into fixed buffer) and domain (Bluetooth config vs. tensor math) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2015-8956 is a NULL pointer dereference in a kernel Bluetooth socket binding function due to insufficient parameter validation. The target code validates input tensors early (OP_REQUIRES) and does not deeply dereference complex pointer structures from user input. The flaw pattern (missing NULL check before struct access) is not evident in the target, which works on tensor objects, not socket addresses.",
        "case_metadata": {
          "cve_id": "CVE-2015-8956"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2012-2119 is a buffer overflow due to missing bounds checks on vector counts and size calculations in a kernel network driver. The target code calculates sizes (product, dense_size) and validates them, which shares a conceptual similarity with bounds checking. However, the target does not process iovec structures or have a zero-copy path. The risk of integer overflow in size calculations (e.g., product *= size) is a minor point of similarity.",
        "case_metadata": {
          "cve_id": "CVE-2012-2119"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-5844 is an integer overflow when calculating file positions in an archive parser. The target code has similar integer arithmetic (product *= size, dense_size / product) on user-controlled or derived values (target_shape elements, dense_size). The validation (product * missing == dense_size) aims to prevent mismatches, but like the CVE, there is a risk of overflow/wraparound if inputs are large (e.g., product overflow before the check). The context differs (archive vs. tensor), but the integer operation and validation pattern is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      }
    ]
  },
  "CVE-2021-37640_after_exclude_100:94edc9da:vulspec": {
    "timestamp": "2026-01-17T00:47:39.026031",
    "cve_id": "CVE-2021-37640",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "94edc9da",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a tensor reshaping utility in a machine learning framework, performing shape validation and index transformation. CVE-2015-7511 is a cryptographic side-channel vulnerability (CWE-200/385) in libgcrypt. The domains (ML vs. crypto), vulnerability types (logic/validation vs. timing side-channel), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error (CWE-399) in a subtitle renderer due to inconsistent memory tracking. The target code performs arithmetic validation and memory allocation but with explicit checks (OP_REQUIRES). The core flaw patterns (inconsistent state vs. integer logic/validation) and domains are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read (CWE-125) in an image file parser due to improper string termination validation. The target code validates tensor shapes and performs arithmetic checks but does not involve parsing external file formats or string manipulation. The attack surfaces and vulnerability patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2009-3909 is an integer overflow (CWE-190) leading to a buffer overflow in an image parser. The target code involves integer arithmetic (product *= size, dense_size / product) and validation to prevent issues like division by zero or shape mismatch. While the domain differs (image parsing vs. tensor ops), the pattern of performing arithmetic on user/input-controlled integers (dimensions) and the need for validation to prevent logic errors or overflows is similar. The target code has checks (product > 0, product * missing == dense_size) but a reviewer should ensure no overflow occurs in `product *= size` or `dense_size / product`.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability (CWE-284) in a database query planner. The target code performs no privilege checks; it is a pure data transformation function. The vulnerability types and code patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14151 is a buffer overflow (CWE-119) due to insufficient padding allocation in an image codec. The target code allocates output tensors based on calculated sizes (nnz, output_rank) but does not involve low-level buffer padding or compressed data writing. The allocation is managed by the framework's `allocate_output`.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7837 is a stack buffer overflow (CWE-119) in a Bluetooth config parser due to lack of input bounds checking. The target code parses tensor data structures already within the framework's memory model and does not parse raw strings or use fixed-size stack buffers. The vulnerability mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2015-8956 is a NULL pointer dereference (CWE-476) in a kernel socket binding function due to insufficient parameter validation. The target code receives Tensor objects by reference, which are likely validated by the framework's kernel dispatch mechanism before this function is called. The pattern of missing validation for complex pointer structures is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2015-8956"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2012-2119 is a buffer overflow (CWE-119) in a kernel network driver due to missing bounds checks on vector counts. The target code operates on well-defined tensor dimensions and does not process variable-length iovec structures from userspace. The domains and low-level memory manipulation patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2012-2119"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-5844 is an integer overflow (CWE-190) in an archive parser during file position calculation. The target code performs integer multiplication (`product *= size`) and division (`dense_size / product`) on user-influenced values (target_shape). Similar to case 4, this creates a pattern where improper validation could lead to integer overflow (in product) or other arithmetic issues (division by zero if product==0). The code has a check `product > 0` when `unknown_index != -1`, but the multiplication loop occurs before this check. If all sizes are positive but `product` overflows to a negative or zero value, the subsequent logic could fail. This similarity in arithmetic hazard patterns provides reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      }
    ]
  },
  "CVE-2021-37666_after_exclude_100:4314d287:vulspec": {
    "timestamp": "2026-01-17T00:48:19.969461",
    "cve_id": "CVE-2021-37666",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4314d287",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a TensorFlow operation for handling ragged tensors, involving input validation and memory allocation. Case 1 is a cryptographic side-channel vulnerability (CWE-200/385) in libgcrypt's ECC implementation. The domains (machine learning tensor ops vs. cryptography), vulnerability types (logic/validation vs. side-channel), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an improper access control vulnerability (CWE-284) in PostgreSQL's query planner related to privilege checks on views. The target code performs tensor data processing and allocation with no authentication or authorization logic. The functional contexts and flaw nature are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an integer overflow leading to heap buffer overflow (CWE-190 -> CWE-122) in an image file parser. The target code also processes external input (tensor splits/values) and performs allocations. There is a superficial similarity in parsing/validating structured input, but the specific vulnerability mechanism (integer overflow in dimension calculations) is not evident in the provided code snippet, which uses size_t/int operations without complex arithmetic.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow (CWE-119) due to insufficient padding allocation in an image codec. The target code allocates output tensors based on calculated sizes (e.g., `output_size`). There is a general similarity in ensuring output buffers are correctly sized for input data, but the target code uses safe allocation APIs (`context->allocate_output`) and the flaw pattern (padding miscalculation) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a divide-by-zero vulnerability (CWE-369) in an image codec due to missing validation of sampling factors. The target code validates input length (`ragged_nested_splits_len > 0`) but does not perform division operations on user-controlled data. The contexts and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an improper cryptographic signature verification (CWE-347) in a TLS library due to ASN.1 parsing issues. The target code has no cryptographic functionality, signature verification, or complex parsing of binary encodings.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves a broken cryptographic algorithm leading to a NULL pointer dereference (CWE-327 -> CWE-476) in a DNS server. The target code does not use cryptography and has different error handling patterns (uses `OP_REQUIRES` for validation).",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a NULL pointer dereference (CWE-476) in an authentication daemon due to missing check on `crypt()` output. The target code does not perform authentication or have similar patterns of checking system call returns that could be NULL.",
        "case_metadata": {
          "cve_id": "CVE-2019-15163"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an insufficient verification of data authenticity (CWE-345) in a cryptographic authentication protocol. The target code validates tensor structure but does not verify cryptographic material or defend against protocol-level attacks.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an integer overflow (CWE-190) in an audio codec due to insufficient validation of codebook parameters. The target code handles variable-sized input (ragged splits) and calculates an output size. There is a distant similarity in processing variable/complex input structures where miscalculations could lead to allocation issues. However, the target code's calculations (`output_size = unbatched_ragged_input.size()`) are based on container sizes, not arithmetic on user-provided integers, making integer overflow less likely.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2021-37666_before_exclude_100:0714d6ff:vulspec": {
    "timestamp": "2026-01-17T00:48:21.920022",
    "cve_id": "CVE-2021-37666",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0714d6ff",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a TensorFlow operation for handling ragged tensors, involving memory allocation and data structure manipulation. Case 1 is a cryptographic side-channel vulnerability (CWE-200/385) in libgcrypt. The domains (machine learning framework vs. crypto library), vulnerability types (potential memory/validation issues vs. timing attack), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an improper access control vulnerability (CWE-284) in PostgreSQL's query planner related to privilege checks on database views. The target code performs tensor data processing and memory allocation with no authentication, authorization, or SQL query logic. The functional contexts and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing/processing structured input data (tensor metadata vs. PSD file headers). The potential vulnerability in the target code could stem from integer issues in `ragged_nested_splits_len` or `num_components` leading to incorrect memory operations (like the integer overflow CWE-190 in Case 3). However, the specific domain (image processing vs. tensor computation) and the explicit flaw (missing overflow check) are not directly mirrored in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 is a buffer overflow (CWE-119) in OpenJPEG due to incorrect memory allocation size calculation. The target code involves memory allocation via `context->allocate_output` and manipulation of data structures (`RaggedTensorVariant`). A similar flaw could occur if `output_size` (derived from `unbatched_ragged_input.size()`) is incorrectly calculated, leading to an undersized output tensor allocation and subsequent buffer overflow when writing to `encoded_vector_t`. The pattern of allocating based on a calculated size is similar, though the specific trigger (padding calculation) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a divide-by-zero error (CWE-369) in an image decoder. The target code performs arithmetic and loops but does not contain explicit division operations. A tangential similarity exists in the need to validate input parameters (like `num_components`), but the core flaw mechanism is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a cryptographic signature verification flaw (CWE-347) in a TLS library due to ASN.1 parsing errors. The target code deals with numerical tensor data, not cryptographic structures, certificates, or signature validation. The domains and vulnerability classes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves a broken cryptographic algorithm leading to a NULL pointer dereference (CWE-327/476) in a DNS server. The target code has no cryptographic operations. While both systems perform complex data processing, the root cause (unsupported algorithm) and secondary effect (NULL dereference) are not relevant to the tensor manipulation shown.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a NULL pointer dereference (CWE-476) in an authentication daemon due to missing check on `crypt()` output. The target code uses `OP_REQUIRES_OK` for error checking but does not explicitly show pointer dereferencing of potentially NULL results from function calls. The context (network auth vs. data processing) is very different, though the general principle of validating function outputs is a weak commonality.",
        "case_metadata": {
          "cve_id": "CVE-2019-15163"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an insufficient data validation flaw (CWE-345) in a cryptographic authentication protocol, specifically for elliptic curve points and scalars. The target code validates tensor dimensions (`OP_REQUIRES`) but does not involve cryptographic material or protocol state validation. The nature of the data being validated is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an integer overflow (CWE-190) in an audio codec during mathematical computations on codebook parameters. The target code involves integer variables like `ragged_nested_splits_len`, `num_components`, and `output_size` used for loop bounds and memory allocation. An integer overflow in the calculation of these values (e.g., from malicious input tensors) could lead to similar downstream memory corruption issues. The domains differ, but the integer handling risk pattern is somewhat analogous.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2021-37683_before_exclude_100:ede52c55:vulspec": {
    "timestamp": "2026-01-17T00:48:56.994708",
    "cve_id": "CVE-2021-37683",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ede52c55",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a TensorFlow Lite kernel for arithmetic division, performing type checking and dispatching. The historical case is a buffer over-read in a Perl regex compiler due to improper NUL byte handling. The domains (ML inference vs. regex compilation), vulnerability types (type validation vs. out-of-bounds read), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs straightforward tensor operations with safe input retrieval. The historical case involves complex memory tracking errors in a text shaping library for subtitles. The core issues (resource management errors in font processing vs. type-safe dispatch in ML) and code contexts are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a self-contained ML operator implementation. The historical case is an improper access control vulnerability in a database query planner's statistics module. The security model (privilege checks in an RDBMS vs. no privilege model in a tensor operation) and flaw nature are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs a basic division operation, likely not constant-time but not handling cryptographic secrets. The historical case is a side-channel vulnerability in a cryptographic library's elliptic curve multiplication. The threat model (physical side-channel attacks vs. functional correctness) and code criticality are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The primary connection is the potential for integer issues in low-level operations. However, the target code is high-level tensor dispatch with no visible arithmetic on buffer sizes or allocations. The historical case is a direct integer overflow in a memory allocator's size calculation. The attack surface (DNS query vs. ML model input) and code complexity differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-25032"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code handles data types for a division operation. The historical case involves cryptographic algorithm validation and error handling leading to a NULL pointer dereference in a DNS server. The domains (ML arithmetic vs. DNSSEC validation) and failure modes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. There is a thematic link: both codes involve arithmetic operations (division in the target, division/coordinate calculations in libcaca). The vulnerability in the historical case stems from integer overflow leading to divide-by-zero. The target code's `EvalDiv` function could potentially contain a division operation that might be vulnerable to similar issues (e.g., divide by zero if input2 tensor contains zero). However, the target code shown is only the dispatch layer; the actual division logic is hidden. The relevance is weak but non-zero due to the arithmetic domain.",
        "case_metadata": {
          "cve_id": "CVE-2018-20544"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs safe tensor access and type checking. The historical case is an integer overflow in file position calculations while parsing archive formats. The data sources (structured tensors vs. untrusted file bytes) and the likelihood of integer manipulation are very different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a simple function in a user-space ML framework. The historical case is a use-after-free in a hypervisor's x86 instruction emulator, involving complex state management and memory access patterns. The levels of abstraction and vulnerability classes are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-2584"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code uses safe accessor functions (`GetInputSafe`, `GetOutputSafe`) to obtain tensor pointers. The historical case is an out-of-bounds read in a network protocol parser due to incorrect bounds checking after parsing variable-length fields. The input trust boundaries (internal framework data vs. raw network packets) and validation paradigms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      }
    ]
  },
  "CVE-2021-37683_after_exclude_100:6aa5b49c:vulspec": {
    "timestamp": "2026-01-17T00:49:15.484446",
    "cve_id": "CVE-2021-37683",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6aa5b49c",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code performs arithmetic division with input validation. The vulnerability type (CWE-125 vs. potential CWE-369), domain (parsing vs. arithmetic), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error (CWE-399) in a subtitle renderer related to inconsistent memory tracking. The target code performs a division operation with explicit checks for division by zero. The core flaw and context are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control (CWE-284) issue in a database query planner. The target code is a mathematical operation kernel in a machine learning framework. There is no overlap in vulnerability type, functionality, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel information leak (CWE-200/385) in a cryptographic library. The target code's primary concern is functional correctness (avoiding division by zero), not constant-time execution to protect secrets. The domains and attack models are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-25032 is an integer overflow (CWE-190) during memory size calculation. The target code involves integer arithmetic (division) and could theoretically be related if the divisor calculation overflowed, but the direct flaw pattern (size calculation for allocation vs. operand validation) is different. The check for zero divisor is a related but distinct safety measure.",
        "case_metadata": {
          "cve_id": "CVE-2019-25032"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a broken cryptographic algorithm leading to a NULL pointer dereference. The target code performs a basic arithmetic operation with input validation. The vulnerability chains and domains (cryptography vs. tensor math) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2018-20544 is a Divide By Zero (CWE-369) vulnerability. The target code's core purpose is to perform division and it explicitly includes checks (`TF_LITE_CHECK_DIV_NON_ZERO`) to prevent division by zero for integer types (Int32, UInt8). The vulnerability type is identical, and the code pattern (conditional checks on divisor values before the operation) is directly comparable. The key difference is the target code attempts to mitigate the flaw, while the historical case exhibits it.",
        "case_metadata": {
          "cve_id": "CVE-2018-20544"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-5844 is an integer overflow (CWE-190) in a file parser leading to incorrect position calculations. The target code deals with division and operand validation. While both involve integer arithmetic, the specific flaw (overflow in a size/offset calc vs. zero divisor) and context are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-2584 is a Use After Free (CWE-416) in a kernel emulator. The target code has no dynamic memory management or pointer lifecycle issues within the shown function. The vulnerability types and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-2584"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-12899 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient bounds checking. The target code performs arithmetic with explicit bounds on the loop (input2_elements) and value checks. The flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      }
    ]
  },
  "CVE-2022-2923_before_exclude_100:3cdb12a7:vulspec": {
    "timestamp": "2026-01-17T00:49:25.724492",
    "cve_id": "CVE-2022-2923",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3cdb12a7",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve processing of structured data (regex patterns vs. word trees) and have potential for out-of-bounds reads. However, the target code's primary operations are on controlled, internal data structures (slang->sl_fbyts, slang->sl_fidxs) with explicit length checks (`n + 1 < slang->sl_fbyts_len`). The vulnerability in CVE-2018-18313 stems from improper handling of user-supplied NUL bytes in regex patterns, a different context and attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing structured data (XML vs. a word tree) and have bounds checking concerns. The target code uses array indexing (`arridx`, `curi`) within loops and has a length check for `byts` array. However, the vulnerability pattern is different: CVE-2016-1833 is a classic out-of-bounds read during multi-byte character processing in a parser, while the target code's data flow is more controlled and the checks present reduce immediate similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Similar to case 2, both involve parsing (XML vs. word tree) and potential for out-of-bounds reads if indices become invalid. The target code uses `arridx[depth]` to index into `idxs` and `byts`, but the loop logic and termination condition (`depth >= 0`) coupled with the source arrays being internal, validated structures makes a direct out-of-bounds read less likely compared to the XML tag parsing flaw.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability related to error handling and pointer management in a network daemon. The target code performs memory allocation (`wordtree_alloc`) but does not exhibit complex error path cleanup, pointer aliasing, or the kind of state inconsistency that leads to UAF. The memory management pattern is simple and local.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write during network data handling. The target code performs no arithmetic on user-controllable sizes that could overflow. The only increments are of loop counters and `words_done`, which are bounded by the size of the input word tree. The contexts (network protocol vs. offline dictionary processing) and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1835 is a Use-After-Free in an XML parser due to complex state management during attribute processing. The target code has no analogous dynamic object lifecycle or reference holding that could lead to a UAF. Memory is allocated for the trie root and words are added, but there's no freeing and reusing of objects within this function.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing a structure with length fields (TLV in packets, tree structure in bytes/indices). The target code implicitly trusts the structure of `sl_fbyts` and `sl_fidxs` but includes a specific bounds check (`n + 1 < slang->sl_fbyts_len`). CVE-2018-14461's flaw is a missing validation of a length field from untrusted network data, which is a higher-risk scenario than the target's use of internal dictionary data.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-10675 is a race condition leading to Use-After-Free in the Linux kernel's memory policy subsystem. The target code is a single-threaded dictionary processing function with no concurrency, locks, or shared resource management. The domains and vulnerability patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1836 is a Use-After-Free caused by buffer reallocation invalidating stored pointers. The target code uses fixed-size stack arrays (`tword`, `tsalword`, `arridx`, etc.) and does not perform reallocation or maintain persistent references to heap data that could become stale. The memory models are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a filesystem's node ID management. The target code shows no evidence of multi-threading, shared state, or the check-then-use pattern that defines the race. It is a straightforward, sequential algorithm processing a dictionary.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2021-4192_before_exclude_100:5166a6db:vulspec": {
    "timestamp": "2026-01-17T00:50:01.966444",
    "cve_id": "CVE-2021-4192",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5166a6db",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve regular expression processing, but the target code is a visual mode matching function in an editor (likely Vim), not a regex compilation engine. The vulnerability type (CWE-125 Out-of-bounds Read) and trigger condition (embedded NUL bytes in regex patterns) are not applicable to the target code, which performs bounds checks on line/column positions within a buffer.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code is a visual selection matching function in an editor, not an XML parser. The vulnerability type (CWE-125 Out-of-bounds Read) and attack surface (malformed XML end tags) are completely unrelated. The code patterns and functional domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-2923_after_exclude_100:ba985900:vulspec": {
    "timestamp": "2026-01-17T00:50:10.469094",
    "cve_id": "CVE-2022-2923",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ba985900",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve processing of input data (regex patterns vs. dictionary words) and have potential for out-of-bounds reads. However, the core vulnerability in CVE-2018-18313 is improper NUL byte handling leading to buffer over-reads in a regex compiler, while the target code uses NUL as a legitimate terminator within controlled loops and array bounds. The code patterns and attack surfaces (external regex vs. internal dictionary building) are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing structured data (XML vs. a word tree) and have bounds checking concerns. However, CVE-2016-1833 is a classic out-of-bounds read in a multi-byte character parser due to inadequate validation of external input. The target code uses fixed-size arrays (MAXWLEN) and loops with explicit checks (`n + 1 < slang->sl_fbyts_len`), showing more defensive structure. The vulnerability type and trigger conditions are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing (XML end tags vs. a trie structure) and the potential for out-of-bounds reads. The key flaw in CVE-2016-1838 is insufficient bounds checking on external data during end tag processing. The target code's parsing is over internal, trusted `slang` data structures (`sl_fbyts`, `sl_fidxs`), and its loops are bounded by array indices and explicit length checks. The attack surface and code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability in a network daemon related to error handling and pointer management. The target code performs a purely computational tree traversal with no dynamic memory allocation/deallocation in the shown path (it calls `tree_add_word`). The vulnerability type, trigger conditions (error paths vs. normal traversal), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs arithmetic on `words_done` (a 32-bit counter) and array indices, but these are bounded by the loop depth (`MAXWLEN`) and tree structure. There is no dynamic allocation based on user-controlled integers, and the primary operation is inserting into a tree, not writing to a linear buffer. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1835 is a Use-After-Free in an XML parser due to complex state management during attribute processing. The target code has no analogous dynamic memory lifecycle issues within the `sug_filltree` function itself; it operates on pre-existing `slang` data and a newly allocated `si_foldroot`. The code patterns (SAX parsing vs. iterative tree walk) and flaw nature are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. The strongest point of similarity is the core CWE-125: Out-of-bounds Read. Both involve parsing a structure with length fields (TLV in packets, a byte/idx array for a trie). The target code has explicit bounds checks (`n + 1 < slang->sl_fbyts_len`), which is the fix for the type of flaw seen in CVE-2018-14461. The relevance is limited because the target code's data is internal and structured as a tree, not a linear packet buffer, making the attack surface and specific trigger conditions different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-10675 is a race condition leading to Use-After-Free in the Linux kernel's memory management. The target code is a single-threaded, sequential function for building a suggestion tree. There are no locks, shared resources, or concurrency concerns. The vulnerability domains (kernel syscall vs. application-level dictionary processing) are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1836 is a Use-After-Free related to buffer reallocation and dictionary management in an XML parser. The target code uses fixed-size stack arrays (`tword[MAXWLEN]`, `arridx[MAXWLEN]`) and does not perform reallocation. The `slang` data buffers are read-only. The memory management patterns and potential flaw mechanisms are not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a filesystem's metadata management. The target code shows no evidence of concurrency (no locks, no shared state besides `spin` and `slang` which are presumably not accessed concurrently here). It is a straightforward, deterministic algorithm. The vulnerability class and code patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2021-4192_after_exclude_100:30952c97:vulspec": {
    "timestamp": "2026-01-17T00:50:26.712849",
    "cve_id": "CVE-2021-4192",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "30952c97",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve regular expression processing, but the vulnerability types differ significantly. CVE-2018-18313 is an out-of-bounds read in Perl's regex compiler due to NUL byte handling. The target code is a visual mode matching function in an editor (likely Vim) that performs bounds checking on line/column positions. The core flaw patterns (OOB read vs. logical validation) and attack surfaces (regex pattern input vs. editor state) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in libxml2's XML end tag parser. The target code performs visual selection validation in an editor. Both involve parsing/validation but in completely different domains (XML vs. editor visual mode), with different data structures, vulnerability types (OOB read vs. potential logic errors), and no shared code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-1978 is an out-of-bounds write in GIMP's XWD image file parser due to color map validation. The target code is a visual mode matching function with no file parsing, no color processing, and no heap operations. The vulnerability mechanisms and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write in LibVNC's file transfer due to integer overflow in allocation. The target code performs position validation with no memory allocation, no integer overflow risks, and completely different functionality (editor UI vs. network protocol).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2's character encoding processing. The target code validates line/column positions in visual mode. Both involve bounds checking but in entirely different contexts (character encoding buffers vs. editor coordinates), with different vulnerability patterns and no shared code constructs.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2009-5155 involves state handling errors in glibc's regex compiler. The target code also maintains state (visual mode, cursor positions) and performs validation. However, the vulnerability types differ (data processing errors vs. potential bounds/logic errors), and the domains are different (regex compilation vs. editor visual selection). Some similarity in state validation patterns exists but is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2020-16304 is an out-of-bounds write in Ghostscript's image rendering due to position tracking errors. The target code tracks positions for visual selection but doesn't write to buffers or render images. The core vulnerability mechanism (OOB write vs. logical validation) and application domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-15166 involves improper input validation in tcpdump's LMP parser. The target code performs validation of visual mode coordinates and conditions. Both involve input/state validation with bounds checking, though in different domains (network packets vs. editor state). The code pattern of checking conditions before proceeding has some similarity, but the vulnerability specifics differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in MiniSSDPd due to memory management errors. The target code has no dynamic memory allocation or freeing operations. The vulnerability types, code patterns, and domains are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-14461 involves insufficient validation of length fields leading to out-of-bounds read in tcpdump. The target code validates line/column positions against visual selection bounds. Both perform bounds validation, but the target code works with editor coordinates rather than network packet lengths. The validation pattern similarity is present but applied to different data types and contexts.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-0392_after_exclude_100:359324be:vulspec": {
    "timestamp": "2026-01-17T00:51:41.337464",
    "cve_id": "CVE-2022-0392",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "359324be",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves out-of-bounds read in a regex parser due to NUL byte handling. The target code processes bracketed paste input with explicit NUL checks and string comparisons, but the core vulnerability pattern (regex parsing with embedded NULs) is fundamentally different from terminal input processing.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free vulnerability in a network daemon's memory management. The target code performs local terminal input processing with stack buffers and no dynamic memory allocation/free operations, making the vulnerability patterns completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1833 involves out-of-bounds read in XML parsing due to multi-byte character handling issues. The target code also handles multi-byte characters (has_mbyte condition) but uses proper mb_char2bytes/mb_ptr2char functions with buffer bounds checking via idx < NUMBUFLEN. Similar domain (character encoding) but different vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a network file transfer protocol. The target code uses fixed-size stack buffers (NUMBUFLEN) with index checking and no arithmetic operations that could overflow, making the vulnerability patterns unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1838 involves out-of-bounds read in XML end tag parsing. The target code processes terminal input sequences with explicit bounds checking (idx variable, NUMBUFLEN limit). Both involve parsing but different domains (XML vs terminal escape sequences) and different vulnerability mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 involves out-of-bounds read in network protocol parsing due to insufficient length validation. The target code validates input against a termination sequence (end) with STRNCMP and has buffer size limits. Similar pattern of parsing structured input with termination conditions, but different domains (network packets vs terminal input).",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-15166 involves improper input validation in network protocol parsing. The target code validates paste termination sequences and checks buffer bounds. Both involve parsing external input with validation logic, though the target code appears more robust with explicit size checking.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-8860 involves buffer management issues in Tor's network buffers. The target code uses simple stack buffers with fixed limits and explicit NUL termination. Both handle data buffers but with completely different memory models and vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow in image encoding due to insufficient padding. The target code uses stack buffers with fixed size and no dynamic allocation or padding calculations, making the vulnerability patterns unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2015-0241 involves buffer overflow in numeric formatting. The target code uses bounded buffer operations with idx < NUMBUFLEN. Both involve string/buffer manipulation but different domains (numeric formatting vs terminal input processing) and different overflow potentials.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      }
    ]
  },
  "CVE-2022-0392_before_exclude_100:85b55fe3:vulspec": {
    "timestamp": "2026-01-17T00:51:43.212986",
    "cve_id": "CVE-2022-0392",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "85b55fe3",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves out-of-bounds read in a regex parser due to NUL byte handling. The target code is a bracketed paste handler that reads input into a fixed-size buffer (`buf[NUMBUFLEN + MB_MAXBYTES]`) with careful length checking (`idx` against `NUMBUFLEN`). The vulnerability type (OOB read), domain (parsing vs. input handling), and trigger conditions (embedded NULs vs. terminal sequence detection) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management. The target code performs local terminal input processing with stack buffers and no dynamic memory allocation/free operations. The vulnerability class (memory corruption vs. safe buffer handling) and context (network service vs. local UI) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1833 involves out-of-bounds read in an XML parser during multi-byte character processing. The target code also handles multi-byte characters (`has_mbyte`, `mb_char2bytes`), but it uses bounded operations with `idx` and `NUMBUFLEN`. While both process encoded input, the vulnerability pattern (parser state error leading to OOB read) is not present in the careful buffer management of `bracketed_paste`.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to heap buffer overflow in a network file transfer. The target code uses fixed-size stack buffers with no arithmetic on buffer sizes or dynamic allocation. The vulnerability mechanism (integer wrap in allocation) and attack surface (network protocol) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2016-1838 is an out-of-bounds read in an XML end-tag parser. The target code reads input sequentially into a buffer and compares it against a termination sequence. Both involve parsing, but the vulnerability (missing bounds check in tag processing) does not align with the target's loop that checks `idx` and uses `STRNCMP` with controlled lengths.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code validates input against a fixed buffer (`NUMBUFLEN`) and a termination sequence. While both parse structured data (TLVs vs. paste sequences), the vulnerability root cause (missing length check) is not present in the target's bounded buffer handling.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-15166 involves improper input validation in a network protocol parser. The target code validates input by checking for the terminator sequence `PE` and buffer limits. Both perform input validation, but the vulnerability context (network packet parsing vs. local terminal input) and flaw specifics (missing bounds check on subobjects) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-8860 involves improper buffer management and missing sentinel values in Tor's buffer system. The target code uses a fixed buffer and ensures null-termination (`buf[idx] = NUL`). Both deal with buffer management, but the vulnerability (missing termination for string functions) is not directly applicable as the target's buffer is local and carefully null-terminated.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-14151 is a heap buffer overflow due to insufficient padding allocation in an image encoder. The target code uses a fixed stack buffer with no dynamic size calculations or padding. The vulnerability type (heap overflow from arithmetic error) and domain (image encoding vs. input handling) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2015-0241 is a buffer overflow/over-read in a numeric formatting function. The target code copies characters into a fixed buffer with index checking. Both involve writing data to buffers, but the vulnerability (unchecked copy from large numeric input) does not match the target's controlled, sequential input reading with explicit size limit (`NUMBUFLEN`).",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      }
    ]
  },
  "CVE-2008-4618_before_exclude_100:57747098:vulspec": {
    "timestamp": "2026-01-17T00:51:59.345560",
    "cve_id": "CVE-2008-4618",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "57747098",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a simple error handling wrapper that calls an abort function for parameter length violations in the SCTP protocol. Case 1 (CVE-2016-3179) involves a complex Use-After-Free vulnerability in a service discovery daemon, related to memory management and inconsistent state during error handling. The core vulnerability type (CWE-416), attack surface (local socket), and functional domain (SSDP vs. SCTP) are fundamentally different. The target code shows no memory management or pointer manipulation flaws.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 2 (CVE-2018-14461) is an Out-of-bounds Read in a network protocol parser (tcpdump's LDP) due to insufficient validation of a length field. The target code is also in a network protocol stack (SCTP) and involves a \"parameter length\" error path. However, the target function `sctp_sf_violation_paramlen` is a *reaction* to an invalid length (it's the error handler), not the vulnerable parsing code itself. It does not contain the insufficient validation flaw. The vulnerability pattern (missing bounds check leading to OOB read) is not present in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 3 (CVE-2017-1000381) is an Out-of-bounds Read in a DNS record parser due to insufficient validation before processing. Similar to Case 2, the domain is network protocol parsing, and the trigger is related to length/validation. However, the target code is the error reporting function invoked *after* a length violation has been detected. It represents the secure, error-handling path, not the vulnerable parsing path that lacks validation. The code patterns are opposites: one is missing checks, the other is the consequence of a check failing.",
        "case_metadata": {
          "cve_id": "CVE-2017-1000381"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 4 (CVE-2019-25034) involves an Integer Overflow leading to an Out-of-bounds Write in a DNS domain name parser. The target code performs no arithmetic operations, length calculations, or buffer writes. It simply passes a static error string to an abort function. The vulnerability mechanisms (CWE-190, CWE-787) are completely absent from the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 5 (CVE-2018-20750) is an Integer Overflow leading to an Out-of-bounds Write in a VNC file transfer module. Similar to Case 4, the core flaw involves arithmetic on attacker-controlled integers leading to memory corruption. The target code contains no integer operations, memory allocations, or writes based on user input. Its function is purely to signal an error.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 6 (CVE-2019-17498) is an Integer Overflow in an SSH message handler that bypasses a bounds check. While both are in network protocol implementations, the target code contains no bounds checks, integer operations, or message length validation logic to be bypassed. It is a terminal error handler.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 7 (CVE-2019-15166) is Improper Input Validation (CWE-20) in a network protocol parser (tcpdump's LMP). The target code exists in the SCTP protocol stack, and the function's name suggests it deals with \"invalid length\" parameters, which is a validation failure. This is the strongest conceptual link so far: both relate to protocol field validation. However, the target code is the *result* of validation failing, not the missing validation itself. The vulnerable code pattern (missing check) is not shown here.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 1,
        "reasoning": "Case 8 (CVE-2011-3603) is an Improper Input Validation of privilege state leading to unnecessary privilege execution. The domain (privilege separation in a daemon) and vulnerability type (CWE-250) are entirely unrelated to the target code, which is a protocol state error handler with no privilege management aspects.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 9 (CVE-2016-1834) is a Buffer Overflow in an XML string library due to improper length validation. While both involve length issues, the target code is a network protocol error handler, not a string manipulation function. It does not perform any buffer operations that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 10 (CVE-2019-25035) is an Out-of-bounds Write in a DNS token parser due to incorrect parenthesis counting and buffer management. The target code performs no parsing, tokenization, or buffer writing. It is a simple function call with static arguments.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      }
    ]
  },
  "CVE-2022-27007_before_exclude_100:e2b27a57:vulspec": {
    "timestamp": "2026-01-17T00:52:14.601455",
    "cve_id": "CVE-2022-27007",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e2b27a57",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a function frame management routine in a VM, dealing with stack pointer arithmetic and value copying. The vulnerability type (CWE-125), domain (parsing vs. VM internals), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves an out-of-bounds write due to integer overflow in memory allocation. The target code performs pointer arithmetic and memory copying within a pre-allocated frame structure. While both involve careful bounds management, the target code's operations are on fixed, internal structures rather than user-controlled allocation sizes. The core flaw (integer overflow leading to heap corruption) is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 3 is a use-after-free due to improper state cleanup. The target code saves a VM frame, which involves careful management of pointers and references within a stack-like structure. There is a conceptual similarity in managing pointer lifecycles and ensuring internal consistency during state transitions (saving/restoring frames). However, the specific vulnerability mechanism (double-free) is not directly analogous to the copying operations shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in an XML parser due to insufficient bounds checking on end tags. The target code performs controlled copying within a calculated frame layout. Both require bounds awareness, but the domain (parsing untrusted data vs. internal VM stack management) and the nature of the bounds checks (string/stream parsing vs. arithmetic on internal counts) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code operates on internal VM structures with sizes derived from internal counts (e.g., `value_count`, `function->args_count`). The attack surface (network packet vs. internal function call) and validation requirements are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves improper input validation in a network protocol parser. The target code's inputs are internal VM state and bytecode (`pc`), not untrusted network data. While both pieces of code must be correct, the threat model and validation needs are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in an image file parser due to improper string termination handling. The target code copies `njs_value_t` objects within a VM frame. The data structures, operations, and sources of bounds information are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a buffer overflow due to insufficient padding allocation. The target code performs pointer arithmetic (`new + value_count + function->u.lambda->temp`) to calculate buffer locations within a frame. There is a similarity in the need for precise calculation of offsets and sizes within a memory buffer. An error in these calculations in the target code could lead to similar boundary violations, though the context (image encoding vs. VM stack) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in an XML/HTML parser during multi-byte character processing. The target code copies structured values, not parsing a byte stream with complex encoding. The mechanisms for determining copy boundaries are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves a buffer overflow due to improper validation of a negative length. The target code uses various counts (`value_count`, `function->args_count`) for pointer arithmetic. If any of these counts were miscalculated or corrupted, it could lead to similar out-of-bounds writes within the frame buffer. The connection is conceptual (arithmetic on counts leading to pointer errors) rather than direct.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      }
    ]
  },
  "CVE-2008-4618_after_exclude_100:0ec448a3:vulspec": {
    "timestamp": "2026-01-17T00:52:16.998586",
    "cve_id": "CVE-2008-4618",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0ec448a3",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a simple error handling wrapper that calls an abort function when a chunk length violation is detected. Case 1 (CVE-2016-3179) involves a complex Use-After-Free vulnerability in a service discovery daemon due to uninitialized pointers and inconsistent state management. The code patterns, vulnerability type (CWE-416 vs. length validation), and functional domain (SCTP protocol vs. SSDP) are fundamentally different. There is very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Case 2 (CVE-2018-14461) involves an Out-of-bounds Read due to insufficient validation of a TLV length field in a network protocol parser. The target code is specifically a function (`sctp_sf_violation_chunklen`) designed to handle invalid chunk lengths in the SCTP protocol. Both deal with protocol parsing and length validation errors. The relevance is moderate because the target code shows the *defensive* path for handling length violations, while the CVE shows the *offensive* consequence of missing such handling. The core concept of length validation connects them.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 7,
        "reasoning": "Case 3 (CVE-2017-1000381) involves an Out-of-bounds Read in a DNS record parser due to insufficient validation of structure length before processing. Similar to Case 2, this relates to the critical theme of validating length fields in network protocol data units before further processing. The target code represents the security check for invalid chunk length. The vulnerability type (CWE-125) and the domain (protocol parsing) show moderate relevance, though the specific protocols differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-1000381"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 4 (CVE-2019-25034) involves an Integer Overflow leading to an Out-of-bounds Write during domain name parsing. The target code performs a simple error check and calls an abort function. There is no arithmetic operation, length calculation, or buffer write in the target code. The vulnerability mechanisms (CWE-190/787) and code patterns are dissimilar. The weak relevance lies only in the broader context of input validation for network protocols.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 5 (CVE-2018-20750) involves an Integer Overflow leading to an Out-of-bounds Write in a file transfer protocol handler. Similar to Case 4, the core flaw is an arithmetic error in size calculation. The target code contains no arithmetic, memory allocation, or write operations. It is a pure validation error handler. The relevance is weak, limited to the general domain of protocol implementation security.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 6 (CVE-2019-17498) involves an Integer Overflow that bypasses a length check (`message_len < datalen-13`) in an SSH protocol parser. The target code is the function invoked when a chunk length violation is *detected*. While both involve length checks, the CVE exploits a flaw *in* the check (integer wrap), whereas the target code is the correct *result* of a check failing. The patterns are opposite sides of the same coin, showing some conceptual relevance but very different code structures and specific vulnerabilities (CWE-190 vs. a validation handler).",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 7,
        "reasoning": "Case 7 (CVE-2019-15166) involves Improper Input Validation (CWE-20) leading to potential memory corruption in an LMP protocol parser, specifically due to missing bounds checking. This is highly relevant to the purpose of the target function `sctp_sf_violation_chunklen`, which exists precisely to enforce proper input validation (chunk length) in the SCTP protocol. The target code exemplifies the defensive code that should be present to prevent vulnerabilities like this CVE. The domain (network protocol parsing) and security theme are strongly aligned.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 8 (CVE-2011-3603) involves Improper Input Validation of privilege separation state, leading to unnecessary privilege execution. The target code is a protocol-level chunk length validator. The vulnerability types (CWE-250 vs. length check), attack surfaces (privilege management vs. network packet), and code functionalities are completely different. There is very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 9 (CVE-2016-1834) involves a Buffer Overflow in an XML string library due to insufficient length validation. The target code validates length but does not perform any buffer operations itself. The connection is the general principle of validating sizes/lengths before operations. However, the specific vulnerability mechanism (heap buffer overflow in string manipulation) and domain (XML parsing vs. SCTP protocol) are distinct, leading to weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 10 (CVE-2019-25035) involves an Out-of-bounds Write in a DNS token parser due to incorrect parenthesis counting and buffer boundary calculation. The target code is a simple error handler for a detected length violation. While both are in parsers, the target code does not contain the complex parsing logic, state management, or write operations that led to the CVE. The relevance is weak, based only on the overarching theme of parser security.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      }
    ]
  },
  "CVE-2022-27007_after_exclude_100:980ab81e:vulspec": {
    "timestamp": "2026-01-17T00:53:20.476881",
    "cve_id": "CVE-2022-27007",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "980ab81e",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a function frame management routine in a VM, dealing with stack pointer arithmetic and value copying. The vulnerability type (CWE-125), domain (parsing vs. VM internals), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 involves an out-of-bounds write due to integer overflow in memory allocation. The target code performs pointer arithmetic and memory copying within a pre-allocated frame structure. While both involve careful bounds management, the target code's operations are based on computed counts (`value_count`, `temp`) without explicit validation, which could lead to similar issues if those inputs are miscalculated. However, the context (file transfer protocol vs. VM stack management) and specific flaw pattern differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a use-after-free vulnerability related to error handling and resource cleanup. The target code appears to be a well-defined save operation without complex error paths or dynamic resource deallocation in the shown snippet. The primary concern in the target code is correct pointer arithmetic and bounds, not lifetime management.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is an out-of-bounds read in an XML parser due to insufficient bounds checking on end tags. The target code manipulates internal VM stack frames. While both require careful bounds checking, the domain (parsing untrusted data vs. managing internal execution state) and the nature of the bounds violation (parsing logic error vs. arithmetic error on internal counts) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code operates on internal VM structures where lengths/counts are derived from internal function metadata (`active->function`). The attack surface (network packet vs. internal bytecode) and the trust model are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is improper input validation in a network protocol parser. The target code validates data indirectly through `njs_is_valid(p)` but primarily performs memory operations based on internal counts. The context is dissimilar: parsing external protocol data versus managing an internal call frame.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is an out-of-bounds read in an image file parser. Similar to other parser cases, the domain and data source (external file format vs. internal VM state) are not comparable to the target code's functionality.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is a buffer overflow due to incorrect calculation of buffer size/padding. The target code performs intricate pointer arithmetic to lay out a stack frame (`new`, `value`, `arguments`, `local`, `temp` pointers). A miscalculation in `value_count` or `function->u.lambda->temp` could lead to pointers pointing outside the allocated `native` memory region, causing out-of-bounds writes in the copy loops. The pattern of computing offsets within a buffer based on multiple counts is conceptually similar, though the domain (image encoding vs. VM) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is an out-of-bounds read in an XML/HTML parser during character encoding processing. The target code does not process multi-byte character streams or manage input buffers in a similar way. The vulnerability patterns are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 involves a buffer overflow due to improper validation of a length value (negative `label_len`). The target code uses various counts (`value_count`, `function->args_count`, `function->args_offset`) to compute pointers and loop bounds. If any of these values were corrupted or incorrectly calculated, it could lead to similar out-of-bounds memory access. The connection is the general principle of validating counts/offsets used in memory operations, but the specific context and data source are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      }
    ]
  },
  "CVE-2015-1345_before_exclude_100:d38f01a1:vulspec": {
    "timestamp": "2026-01-17T00:53:44.513325",
    "cve_id": "CVE-2015-1345",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d38f01a1",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a string search algorithm (Boyer-Moore variant) that performs bounds-checked pointer arithmetic. The vulnerability type (CWE-125), domain (parsing vs. searching), and code patterns (complex pattern compilation vs. linear text scanning) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds write due to integer overflow in a network protocol file transfer handler. The target code performs read-only string matching with careful bounds checks (e.g., `tp <= ep`, `d <= ep - tp`). There are no integer overflow or write operations in the target code's logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves improper input validation (CWE-20) leading to potential memory corruption in a network packet parser. The target code also processes external input (`text`, `size`) and has validation (e.g., `len > size` check). However, the core flaw pattern differs: packet parsing with complex structure vs. a self-contained search algorithm with internal pointer safeguards. The target code's validation appears more robust within its loop invariants.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a use-after-free vulnerability in a service daemon related to error handling and memory management. The target code has no dynamic memory allocation/deallocation, operates on provided buffers, and uses only stack/local variables. The vulnerability classes are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds read in an XML parser due to improper buffer management during multi-byte character processing. The target code also reads from a buffer (`text`) and uses pointer arithmetic, but it does so with explicit bounds checks (`tp <= ep`, `d <= ep - tp`) and does not involve character encoding complexities. The similarity is limited to both reading from input buffers.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an out-of-bounds read in an XML end-tag parser due to insufficient bounds checking. The target code also reads from memory using array indexing (`U(tp[-1])`) and pointer advancement, but it embeds bounds checks in its loop conditions and delta calculations. The common theme is avoiding out-of-bounds reads, but the mechanisms and context (structured parsing vs. linear search) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code validates the input `size` against `len` initially and uses `ep` to limit pointer advancement. Both involve preventing reads past buffer ends, but the trigger (malicious length field vs. algorithmically computed `delta` jumps) and code structure are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free vulnerability related to buffer reallocation and stale pointers in an XML parser. The target code has no dynamic memory management, reallocation, or dictionary usage. It works solely with provided pointers and sizes. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is an integer overflow leading to an out-of-bounds write in a DNS domain name parser. The target code uses integer arithmetic for pointer offsets (e.g., `tp - tp0`, `ep - tp`) but these are differences between pointers or comparisons with `size`, which is bounded by the original input. There is no complex length calculation that could overflow. The vulnerability pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is a heap buffer overflow due to an off-by-one error in memory allocation in a pathname expansion function. The target code is also a string utility function and performs critical bounds calculations (`ep = text + size - 11 * len`, `d <= ep - tp`). While the target code does not perform allocation, it shares the theme of meticulous bounds management in a utility function operating on user-controlled data. An off-by-one error in its pointer arithmetic could lead to an out-of-bounds read. This provides some reference value for safe pointer and bound calculation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2015-1345_after_exclude_100:1bab76cc:vulspec": {
    "timestamp": "2026-01-17T00:53:57.696464",
    "cve_id": "CVE-2015-1345",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1bab76cc",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a string search (Boyer-Moore) function. While both process strings, the vulnerability type (CWE-125 vs. potential logic/overflow), domain (regex compilation vs. raw string matching), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs local string matching with pointer arithmetic and bounds checks. The vulnerability class (CWE-787/CWE-190), attack surface (network vs. local buffer), and functionality are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is improper input validation (CWE-20) in a network packet parser leading to potential memory corruption. The target code also parses input (text buffer) and has bounds checks. There is a superficial similarity in validating input sizes/lengths, but the domain (network protocol vs. string search), data structures, and specific flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a use-after-free (CWE-416) in a service discovery daemon related to memory management during error handling. The target code has no dynamic memory allocation or freeing in the shown function; it operates on provided buffers. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds read (CWE-125) in an XML parser due to improper buffer management during multi-byte character processing. The target code reads from a buffer using array indexing (U(tp[-1])) and could theoretically have similar issues if `d1` or `tp` are miscalculated. However, the domain (character encoding vs. byte matching) and the specific code patterns are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an out-of-bounds read (CWE-125) in an XML parser due to insufficient bounds checking during end tag processing. The target code has explicit bounds checks (e.g., `tp <= ep`, `d <= ep - tp`). The similarity is limited to the general concept of preventing buffer over-reads, but the implementation context and flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read (CWE-125) in a packet parser due to insufficient validation of a length field. The target code validates the initial `len` against `size` and uses calculated limits (`ep`). The common theme is validating external input sizes to prevent over-reads, but the protocols and data structures are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free (CWE-416) in an XML parser related to buffer reallocation and stale pointers. The target code shows no dynamic memory reallocation or pointer invalidation issues. The vulnerability types are incompatible.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is an integer overflow (CWE-190) leading to an out-of-bounds write in a DNS domain name parser. The target code uses integer arithmetic for pointer offsets (e.g., `tp += d`) and loop bounds. A potential similarity exists if `d` from the `d1` table could be excessively large, causing `tp` to overflow or bypass checks. However, the `d1` table is internal and typically contains small offsets, making this a different class of flaw. The domains are also distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is a heap-based buffer overflow (CWE-122) due to an off-by-one error in memory allocation in a pathname pattern matcher. The target code is also a pattern matching function (string search). The most relevant aspect is that both functions process input patterns/text and must carefully manage bounds. The target code's manual pointer advancement (`tp += d`) and checks against `ep` are critical for safety, analogous to the bounds checking missing in Case 10. However, the vulnerability specifics (off-by-one allocation vs. incorrect delta table jumps) and memory model (heap vs. stack/buffer pointers) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-3235_before_exclude_100:698b769b:vulspec": {
    "timestamp": "2026-01-17T00:54:21.802657",
    "cve_id": "CVE-2022-3235",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "698b769b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves a regex engine buffer over-read due to NUL byte handling. The target code is a command-line input handler for an editor (likely Vim) with no regex compilation logic. The vulnerability type (CWE-125), domain, and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free in a network daemon's service registration. The target code is a local, synchronous command-line input function with complex state management but different memory patterns. Both involve error handling, but the attack surface (network vs. local UI), vulnerability type (CWE-416), and functional domain are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to multi-byte character encoding issues. The target code handles command-line input with its own buffer (ccline.cmdbuff) and character processing, but the context (text editor UI vs. document parsing), vulnerability root cause, and data structures are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 is an integer overflow leading to heap corruption in a network file transfer protocol. The target code performs buffer management for a command line, with operations like `put_on_cmdline`. While both involve buffer writes, the target code's operations are character/string-based within a controlled UI context, not network-data-driven with unchecked integer arithmetic for allocations. The vulnerability pattern is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML end-tag parser. The target code is not parsing structured markup language tags. The code patterns and vulnerability triggers are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code does not parse network protocol TLVs. The domain and vulnerability mechanism are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-16161 is a NULL pointer dereference in a regex library due to inconsistent error state handling. The target code has extensive error handling (e.g., `got_int`, `did_emsg`) and state management (e.g., `ccline`). There is a superficial similarity in the need to manage complex state and avoid NULL dereferences after errors. However, the domain (regex compilation vs. interactive command-line editing) and specific flaw pattern are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1834 is a heap buffer overflow in an XML string library due to negative length handling. The target code manipulates strings (`ccline.cmdbuff`) and uses functions like `put_on_cmdline`. It must manage buffer indices (`cmdpos`, `cmdlen`) correctly. There is a general similarity in string/buffer manipulation, but the specific flaw (negative length from `xmlStrlen`) and context (XML vs. editor command line) are not analogous in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. CVE-2016-1835 is a Use-After-Free in an XML attribute parser due to inconsistent state and memory management during parsing. The target code has complex, recursive state management (`depth` static variable, saving/restoring `ccline` via `save_cmdline`/`restore_cmdline`). It manages a global structure (`ccline`) that can be saved/restored, which introduces a risk of state confusion similar to the parser state issue in the CVE. The relevance is higher than other cases because both involve careful management of a central data structure across operations and error paths, though the specific vulnerability pattern (UaF on attribute values) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2009-5155 is a data processing error (state corruption) in a regex compiler related to backreferences and alternatives. The target code manages state for command-line editing but does not involve parsing a language with backreferences or alternative branches. The flaw pattern is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      }
    ]
  },
  "CVE-2022-3235_after_exclude_100:f9181bd3:vulspec": {
    "timestamp": "2026-01-17T00:54:29.225872",
    "cve_id": "CVE-2022-3235",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f9181bd3",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a regex engine vulnerability (CWE-125) due to improper NUL byte handling in pattern parsing. The target code is a command-line input handler in Vim with no regex compilation logic. The domain (input processing vs. regex compilation) and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a Use-After-Free (CWE-416) in a network daemon due to uninitialized pointers and inconsistent state management. The target code involves complex state management for command-line editing but primarily uses static/stack variables and careful cleanup. While both handle state, the memory management patterns and attack surfaces (network vs. local TUI) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is an out-of-bounds read (CWE-125) in an XML parser due to improper multi-byte character buffer handling. The target code processes user keystrokes in a line buffer with explicit length checks (cmdlen/cmdpos). The data domains (structured text parsing vs. interactive editing) and vulnerability mechanisms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 is an integer overflow leading to out-of-bounds write (CWE-787) in a network file transfer protocol. The target code performs buffer operations (put_on_cmdline, cmdline_erase_chars) that could theoretically involve integer issues with buffer indices, but the code shows careful use of `int` types and length checks. The context (network protocol parsing vs. local editing) reduces direct relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is an out-of-bounds read (CWE-125) in XML end tag parsing. The target code does not parse structured markup languages. Both involve processing user input, but the syntactic complexity and memory safety issues specific to XML are absent from the command-line editor.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length validation. The target code validates buffer positions against cmdlen. While both validate lengths, the attack vector (malicious network packet vs. local keystrokes) and data structure complexity are very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a NULL pointer dereference (CWE-476) in a regex library due to inconsistent error state handling. The target code has extensive error handling (goto theend, cleanup) and uses pointers like `ccline.cmdbuff` that are checked. Both involve error paths, but the target code's error handling appears more consistent, and the domain mismatch reduces relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is a buffer overflow (CWE-119) in a string library due to improper length validation. The target code performs string operations (put_on_cmdline) and uses functions like `cmdline_charsize()` which must handle multi-byte characters carefully. There is a conceptual similarity in ensuring buffer bounds during string manipulation, but the implementation context differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a Use-After-Free (CWE-416) in an XML parser due to inconsistent memory management during attribute processing. The target code saves/restores state (`save_cmdline`/`restore_cmdline`) and cleans up resources (`ExpandCleanup`). Both manage complex state, but the target code's state is primarily stack-based or carefully refcounted, unlike the dynamic object lifecycle issues in libxml2.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is a data processing error (CWE-19) in a regex compiler due to improper state tracking for backreferences. The target code maintains state (depth, gotesc, lookfor, etc.) for command-line editing but does not involve parsing complex grammars with backreferences. The state management is for UI/editing, not language compilation.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      }
    ]
  },
  "CVE-2022-0351_before_exclude_100:fff3c14e:vulspec": {
    "timestamp": "2026-01-17T00:54:57.414794",
    "cve_id": "CVE-2022-0351",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "fff3c14e",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a buffer over-read (CWE-125) in a regular expression engine due to improper NUL byte handling. The target code is a Vim expression evaluator (eval7) that parses Vimscript syntax. While both are parsers, the vulnerability type (out-of-bounds read vs. potential logic/type confusion), language domain (regex vs. scripting language), and attack surface (embedded NUL bytes vs. crafted Vimscript expressions) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a Use-After-Free (CWE-416) in a network daemon's memory management during error handling. The target code is a pure parsing and evaluation function with no dynamic memory allocation or deallocation visible in this snippet. The functional domains (network service vs. language interpreter) and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds write (CWE-787) due to integer overflow in a network file transfer protocol. The target code performs arithmetic and string operations but does not show similar buffer allocation or integer size calculations that could wrap. The context (remote protocol vs. local expression evaluation) and flaw mechanism differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is an out-of-bounds read (CWE-125) in an XML parser due to improper multi-byte character buffer management. The target code parses a different language (Vimscript) and while both are parsers, the specific vulnerability trigger (encoding sequence handling) and data structures are not analogous to the character-by-character parsing and variable name handling seen in eval7.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length field validation. The target code parses a scripting language, not a binary network protocol. Although both involve parsing, the structure (TLV vs. expression syntax) and validation requirements are dissimilar. The target code's length checks (e.g., get_name_len) operate differently.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is another out-of-bounds read (CWE-125) in an XML parser during end tag processing. The target code handles different syntactic constructs (parentheses, brackets, braces) but the underlying cause in libxml2 relates to parser state and buffer bounds, which is not directly mirrored in the Vimscript evaluator's stack-based recursion and token skipping.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a buffer over-read/overflow (CWE-120) in a numeric-to-string formatting function. The target code includes numeric evaluation (eval_number) and string handling, which could theoretically have similar issues if buffer sizes are not checked. However, the target code's primary role is parsing and dispatching, not low-level string formatting with fixed buffers. The similarity is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 8 is improper input validation (CWE-20) in a network protocol parser leading to potential memory issues. The target code does perform input validation (e.g., checking for valid characters, matching parentheses) but within a completely different domain (language syntax vs. binary packets). The consequences and exploitation paths would not align.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a Use-After-Free (CWE-416) due to a race condition in kernel memory policy code. The target user-space expression evaluator is single-threaded in context and shows no evidence of concurrency or complex resource lifetime management involving locks. The vulnerability classes are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves a data processing error (CWE-19) due to improper state handling in a regular expression compiler. The target code also manages parser state (e.g., tracking leaders, handling nested expressions via recursion) and could potentially suffer from state confusion bugs (e.g., mishandling evalarg flags, incorrect type tracking in rettv). However, the specific pattern of backreference state corruption in regex alternatives does not map directly to Vimscript constructs.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      }
    ]
  },
  "CVE-2022-0351_after_exclude_100:faf60c84:vulspec": {
    "timestamp": "2026-01-17T00:55:30.179316",
    "cve_id": "CVE-2022-0351",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "faf60c84",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code is an expression evaluator for a scripting language (Vim), dealing with syntax parsing, variable evaluation, and function calls. The vulnerability type (CWE-125), domain (regex vs. script eval), and code patterns (string/pattern parsing vs. recursive AST evaluation) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management during error handling. The target code is a recursive expression evaluator with no dynamic memory allocation or complex resource cleanup shown in this snippet. The vulnerability class (CWE-416) and context (network service vs. interpreter core) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write in a network protocol file transfer handler. The target code performs expression parsing and evaluation. While both handle input data, the vulnerability mechanism (integer overflow in allocation) is not evident in the provided code, which focuses on syntax-driven recursion and variable lookup rather than binary data processing.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper buffer management during multi-byte character processing. The target code also parses input (script expressions) and could theoretically have similar issues if it mishandles string buffers. However, the specific context (XML encoding vs. script tokenization) and the visible code patterns (recursive descent parsing with length checks) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code parses a scripting language, not binary network protocols. While both involve parsing, the attack surface (malicious packets vs. script strings), data formats (TLV vs. language syntax), and validation challenges are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser during end tag processing. The target code is also a parser/evaluator and contains recursive calls (e.g., `eval1`). Both involve navigating a structured input. The relevance is limited because the XML parser deals with hierarchical tags, while the script evaluator handles expressions, variables, and function calls. The core flaw (bounds checking on tag names) is not directly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2015-0241 is a buffer overflow in a formatting function (`to_char`) due to insufficient input size checking. The target code contains multiple string evaluation paths (`eval_string`, `eval_lit_string`, `get_reg_contents`) and passes strings around. The general risk of buffer overflows in string processing functions is a shared concern. However, the specific vulnerability pattern (format string template processing) is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-15166 is an improper input validation (CWE-20) in a network protocol parser, leading to potential memory corruption. The target code does perform input validation (e.g., checking for valid characters, recursion depth) but in a completely different domain (script language syntax vs. binary protocol). The code patterns and exploitation vectors are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition in kernel memory policy system calls. The target code is a user-space, single-threaded expression evaluator. The vulnerability class (concurrency bug, CWE-416) and environment (kernel vs. interpreter) are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2009-5155 involves a data processing error (state inconsistency) in a regular expression compiler. The target code also manages state during parsing (e.g., `recurse` counter, `evalarg` flags) and could be susceptible to state management bugs. However, the domain (regex compilation with backreferences vs. script evaluation) and the specific flaw (backreference validation across alternatives) are not analogous to the shown code's functionality.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      }
    ]
  },
  "CVE-2019-19525_before_exclude_100:aeef0137:vulspec": {
    "timestamp": "2026-01-17T00:55:38.398398",
    "cve_id": "CVE-2019-19525",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "aeef0137",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a USB device driver disconnect routine handling resource cleanup and deregistration. The vulnerability type, context (userspace library vs. kernel driver), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a buffer overflow in a FUSE ioctl handler due to insufficient validation of iovec lengths. The target code performs orderly shutdown and cleanup. Both are in the kernel, but the functional domain (filesystem vs. USB comms) and flaw pattern (input validation vs. resource lifecycle) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is a NULL pointer dereference in a USB serial driver (cypress_m8) due to insufficient validation of USB endpoint descriptors. The target code is also a USB driver (atusb) disconnect handler. Both involve USB driver error handling paths. The relevance is moderate because the specific flaw (probe-time validation vs. disconnect-time cleanup) and trigger (malicious device vs. normal removal) differ, but the domain and potential for improper resource handling are similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a race condition in a filesystem's node ID management. The target code is a synchronous disconnect routine. Both are in the kernel, but the vulnerability type (concurrency bug vs. sequential cleanup) and subsystem are completely different. The only weak similarity is managing shared kernel resources.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 5 is a NULL pointer dereference in the USB/IP subsystem due to insufficient validation of URB fields (specifically a null `transfer_buffer` with a positive `actual_length`). The target code is a USB driver that heavily interacts with URBs (`usb_kill_anchored_urbs`, `usb_kill_urb`). The vulnerability domain (USB, URB handling) is identical. The flaw pattern (improper URB state validation) is highly relevant to auditing the target's URB usage, though the target code does not directly parse incoming URB data.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a race condition in the TTY subsystem leading to buffer overflow. The target code is a USB driver disconnect function. Both are kernel drivers, but the subsystems (serial terminal vs. USB wireless) and flaw patterns (concurrent writers causing overflow vs. synchronous cleanup) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 is a NULL pointer dereference in a USB serial driver (mct_u232) due to missing endpoint validation, identical in nature to CVE-2016-3137 (Case 3). The same reasoning applies: same USB driver domain, similar potential for improper condition checking, though the target's disconnect path is less likely to have the exact same probe-time validation flaw.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a race condition leading to a NULL pointer dereference in the keyring subsystem during initialization. The target code is a USB driver disconnect handler. Both are in the kernel and involve shared resource management, but the subsystems and specific concurrency patterns (user keyring setup vs. device removal) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow in an NFC protocol parser due to lack of input validation. The target code is a USB driver cleanup routine with no apparent protocol parsing. The domains (wireless NFC vs. USB IEEE 802.15.4) and flaw types are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. Case 10 is a Use-After-Free in a userspace daemon due to improper cleanup and uninitialized state during error handling. The target code is a kernel driver disconnect routine whose primary purpose is cleanup. The relevance is weak because the environments differ (userspace vs. kernel), but the thematic similarity of \"proper cleanup of resources during shutdown/error\" provides some reference value for checking order of operations and state flags (like `shutdown`).",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      }
    ]
  },
  "CVE-2019-19525_after_exclude_100:65256516:vulspec": {
    "timestamp": "2026-01-17T00:56:10.402762",
    "cve_id": "CVE-2019-19525",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "65256516",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a USB device driver disconnect routine focused on resource cleanup and deregistration, with no complex integer calculations or memory allocation based on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 is a buffer overflow in FUSE ioctl handling due to insufficient validation of iovec lengths. The target code performs orderly shutdown and cleanup. While both involve kernel subsystems, the vulnerability patterns (buffer overflow vs. cleanup logic) and attack surfaces (malicious userspace server vs. physical USB disconnect) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is a NULL pointer dereference in a USB serial driver (cypress_m8) due to insufficient validation of USB endpoint descriptors. The target code is also a USB driver (atusb) disconnect handler. Both are in the Linux kernel USB subsystem. The relevance is elevated because they share the domain (USB drivers) and potential error conditions during device initialization/teardown, though the specific flaw pattern (NULL dereference vs. use-after-free/race during cleanup) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a race condition in filesystem node ID management. The target code is a synchronous disconnect routine using `cancel_delayed_work_sync` and appears to run in a single-threaded context (driver removal). While both are kernel code, the concurrency model and vulnerability type (race condition vs. potential resource cleanup issues) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 5 is a NULL pointer dereference in the USB/IP subsystem related to URB handling and cleanup. The target code is a USB driver disconnect function that heavily interacts with URBs (`usb_kill_anchored_urbs`, `usb_kill_urb`, `usb_free_urb`). Both involve the Linux kernel USB subsystem and the proper teardown of USB request blocks. The key similarity is the focus on URB lifecycle management during shutdown, a common source of use-after-free and NULL pointer issues. The attack surface differs (network vs. physical), but the core code patterns and potential pitfalls are closely related.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a race condition in the TTY subsystem leading to buffer overflow. The target code is a USB driver disconnect routine. Both are kernel code, but the subsystems (TTY vs. USB), functionality (character I/O buffering vs. device cleanup), and vulnerability patterns (concurrent write race vs. ordered teardown) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 is a NULL pointer dereference in a USB serial driver (mct_u232) due to missing endpoint validation, very similar to Case 3 (CVE-2016-3137). The same reasoning applies: shared domain (Linux kernel USB serial drivers), similar context (driver probe/initialization vs. disconnect), and common flaw category (improper validation leading to crash). The target's disconnect path is less likely to have the exact same probe-time NULL dereference, but the driver patterns are analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a race condition leading to NULL pointer dereference in the keyring subsystem during initialization. The target code is a USB driver disconnect function. Both are in the kernel, but the subsystems (security vs. USB) and the nature of the concurrency issue (global user state initialization race vs. per-device cleanup) are not closely related.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow in an NFC protocol parser due to lack of input validation. The target code performs resource cleanup with no parsing of incoming data. The domains (wireless NFC vs. USB) and vulnerability patterns (memory corruption on input vs. cleanup logic) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is a use-after-free in a daemon due to error handling and inconsistent state management. The target code is a kernel driver disconnect handler that must also manage state and resource cleanup. The relevance comes from the shared theme of proper resource deallocation and avoiding use-after-free during teardown/error paths. However, the environments (userspace daemon vs. kernel driver) and specific mechanisms differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      }
    ]
  },
  "CVE-2022-1244_before_exclude_100:7670ee9b:vulspec": {
    "timestamp": "2026-01-17T00:56:26.539053",
    "cve_id": "CVE-2022-1244",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7670ee9b",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 (CWE-416 Use After Free) involves complex state management leading to pointer misuse. The target code has multiple memory allocations and frees (depArray, extras, img) with goto-based error handling, which could theoretically lead to similar issues if cleanup logic is flawed. However, the patterns are not identical; the target code's primary risk appears to be memory leaks or double frees from repeated R_FREE calls in loops, not a classic use-after-free scenario.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 (CWE-787 Out-of-bounds Write) is about unaligned memory access in network data parsing. The target code performs buffer reads (r_buf_fread_at, r_buf_read_at) but with explicit size calculations and checks (e.g., comparing read bytes to expected count). There is no evidence of alignment-sensitive operations or unchecked buffer writes that mirror the vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 (CWE-415 Double Free) is highly pertinent. The target code has a complex cleanup structure with multiple allocations (depArray, extras, img, deps) freed in loops and error paths (goto next). The `R_FREE` macro sets pointers to NULL after freeing, which mitigates double-free risks. However, the pattern of allocating/freeing within loops (e.g., depArray, extras freed inside and after the loop) and the potential for early returns or jumps create a similar error-handling context where inconsistent state could lead to double-free or memory leak issues, providing valuable reference.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 (CWE-125 Out-of-bounds Read) involves reading past buffer boundaries due to improper NUL byte handling. The target code reads buffers with explicit size limits (e.g., reading 4 magic bytes, reading up to 256 bytes for file path). While `strrchr` and string operations on `file` buffer could be risky if not null-terminated, the code ensures null-termination (`file[255] = 0`). The core vulnerability pattern (embedded NULs causing over-reads) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 (CWE-787 from integer overflow) involves miscalculated allocation sizes. The target code uses `R_NEWS0` and `R_NEW0` for allocations, but sizes are based on counts from headers (e.g., `cache->hdr->imagesCount`). While integer overflows are possible if these counts are maliciously large, the code does not show explicit size calculations that could wrap. The vulnerability pattern differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 (CWE-119 buffer overflow from insufficient padding) is about allocation size miscalculation for compressed data. The target code allocates buffers for metadata and reads fixed-size structures. There is no analogous padding calculation or compressed data buffer that could be under-allocated relative to write operations.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 (CWE-787 from hex string parsing) involves out-of-bounds write during binary data parsing. The target code parses binary structures but uses safe buffer read functions with explicit offsets and sizes. No hex string parsing or unchecked array writes are present.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 (CWE-125 out-of-bounds read in XML parsing) involves reading past buffer ends due to missing bounds checks. The target code reads buffers with bounds checks (e.g., `r_buf_read_at` with size). While `strrchr` operates on a buffer that might not contain the expected character, it's bounded by prior null-termination. The pattern is dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 (CWE-787 from text encoding conversion) involves unsafe buffer copies during UTF conversion. The target code deals with binary data and file paths but does not perform text encoding conversions or string copies into unchecked buffers. The `strdup` usage is safe.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 (CWE-20 Improper Input Validation leading to buffer overflow) involves failing to validate match offsets during decompression. The target code validates reads (e.g., checking `r_buf_fread_at` return value) and uses `va2pa` for address translation, which includes validation. However, the dependency parsing loop using `depArray` assumes `depArray[k] != 0xffff` as a terminator; if missing, it could read out-of-bounds. This mirrors a pattern of input validation flaw, but the context (decompression vs. dependency array) is different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-1244_after_exclude_100:a656ee43:vulspec": {
    "timestamp": "2026-01-17T00:56:40.684943",
    "cve_id": "CVE-2022-1244",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a656ee43",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 (CVE-2016-3179) involves Use-After-Free due to uninitialized pointers and inconsistent state management. The target code has multiple dynamic allocations and error paths with `goto next;` that free resources, but the pattern is not identical. The target code shows careful cleanup (R_FREE on multiple variables) in the error path, reducing similarity to the chaotic cleanup in the vulnerability case.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 (CVE-2019-20840) is an out-of-bounds write due to unaligned memory access in network data parsing. The target code performs binary parsing of a cache structure and reads data via `r_buf_fread_at` and `r_buf_read_at`, but it does not involve alignment assumptions or word-sized operations on unaligned network data. The vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 (CVE-2011-1003) is a Double Free due to inconsistent state management during error conditions. The target code has multiple allocation and free points (`depArray`, `extras`, `img`) which are freed in a `goto next` error path and also at the end of the loop. There is a potential for double-free if the error jump is taken after some variables have already been freed, but the code structure shows explicit nulling after free (via R_FREE macro likely sets to NULL), reducing the risk. The similarity is limited.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 (CVE-2018-18313) is an out-of-bounds read due to improper NUL byte handling in regex parsing. The target code reads strings from a buffer but uses safe operations like `r_buf_read_at` with fixed size and null-terminates manually (`file[255] = 0`). No evidence of NUL byte injection leading to over-reads. Different domain and flaw pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 (CVE-2018-20750) is an out-of-bounds write due to integer overflow in allocation size calculation. The target code uses `R_NEWS0` for allocations based on counts from the cache header, but there is no obvious integer overflow in size calculation visible. The code does not perform arithmetic on allocation sizes. Different vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 (CVE-2017-14151) is a heap buffer overflow due to insufficient padding allocation. The target code allocates memory for arrays (e.g., `deps = R_NEWS0 (int, cache->hdr->imagesCount)`) but does not show complex size calculations with padding. The vulnerability pattern of underestimating buffer size for compressed data is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 (CVE-2019-11222) is an out-of-bounds write in hex string parsing. The target code parses binary structures, not hex strings. Functions like `get_lib_name` read strings but likely use bounded operations. Different data format and parsing logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 (CVE-2016-1838) is an out-of-bounds read in XML end tag parsing. The target code is not parsing text markup languages; it reads dyld cache binary structures. No similarity in code patterns or vulnerability triggers.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 (CVE-2018-20760) is an out-of-bounds write in text encoding conversion. The target code handles binary data and file paths, not UTF-8/UTF-16 conversion. The error handling pattern (missing validation of return codes) is not evident in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 (CVE-2010-1311) is improper input validation leading to out-of-bounds write in a decompression algorithm. The target code does not implement a decompression algorithm. It reads pre-defined structures from a dyld cache. The vulnerability domain (compression) is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-23581_after_exclude_100:1847dee9:vulspec": {
    "timestamp": "2026-01-17T00:57:07.648944",
    "cve_id": "CVE-2022-23581",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1847dee9",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves memory management errors (CWE-399) in a subtitle rendering library due to inconsistent state tracking. The target code is a TensorFlow constant folding function performing shape validation and tensor evaluation with no dynamic memory allocation patterns similar to the vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read (CWE-125) in a Perl regex engine due to improper NUL byte handling. The target code performs controlled tensor element access with bounds checking via NumElements() and does not process string data or have similar parsing vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 3 involves side-channel information exposure (CWE-200/385) in cryptographic operations. The target code performs shape validation and tensor evaluation without cryptographic operations, secret-dependent branches, or timing-sensitive operations.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves improper access control (CWE-284) in a database query planner. The target code performs mathematical shape compatibility checks without any privilege or access control mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves integer overflow (CWE-190) in archive parsing. The target code has some similarity in processing integer dimensions from tensors, but it uses safe iteration via NumElements() and vector push_back operations without arithmetic that could overflow. The vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves buffer overflow (CWE-119) in Bluetooth configuration parsing. The target code uses std::vector for dimension storage with safe push_back operations and does not parse untrusted string input or have fixed-size buffer vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 involves out-of-bounds read (CWE-119) in file type detection due to incorrect length validation. The target code validates tensor properties and uses safe element access patterns, with no similar length validation flaws.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 involves buffer overflow (CWE-119) in network packet processing due to insufficient bounds checking during unescaping. The target code performs shape validation and tensor evaluation without any byte sequence processing or escape mechanism vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2014-9140"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves incorrect buffer size calculation (CWE-17) leading to invalid free in file type detection. The target code has no dynamic memory deallocation, directory traversal, or similar memory management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2014-9426"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves double-free (CWE-415) due to improper reference counting in a Python library. The target code is C++ with manual cleanup via MakeCleanup but no reference counting, object sharing, or similar memory management patterns that could cause double-free.",
        "case_metadata": {
          "cve_id": "CVE-2019-18874"
        }
      }
    ]
  },
  "CVE-2022-23581_before_exclude_100:daadf916:vulspec": {
    "timestamp": "2026-01-17T00:57:09.211324",
    "cve_id": "CVE-2022-23581",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "daadf916",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves memory management errors (CWE-399) in a subtitle rendering library due to inconsistent state tracking. The target code is a TensorFlow constant folding utility performing shape validation and tensor evaluation. The domains (multimedia vs. ML framework), vulnerability types (memory tracking vs. logic validation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read (CWE-125) in a Perl regex engine due to improper NUL byte handling. The target code performs shape compatibility checks and tensor evaluation in a controlled environment with no direct parsing of untrusted byte streams. The attack surfaces and flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is a side-channel vulnerability (CWE-200/385) in a cryptographic library. The target code is a graph optimization function with no cryptographic operations, secret data, or timing-sensitive branches. The vulnerability categories and code contexts are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an improper access control issue (CWE-284) in a database query planner. The target code involves shape validation and could potentially have logic flaws if shape properties are incorrectly trusted, but the core vulnerability type (privilege escalation vs. potential integer/logic error) and domain (database vs. ML compiler) are different. Some reference value exists in the theme of \"planner/optimizer logic flaws\".",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 5 is an integer overflow (CWE-190) in an archive parser. The target code reads tensor dimensions (int32/int64) from a constant node and uses them to build a shape. While no obvious overflow is present in the shown code, the pattern of reading external numeric data (from `outputs[0]`) and using it for memory/calculation (shape construction) is similar. The vulnerability type is plausible in this context if dimensions are maliciously large or negative, though the code uses `TensorShapeUtils::MakeShape` which may have checks.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a stack buffer overflow (CWE-119) in a Bluetooth configuration parser. The target code does not parse raw strings or have fixed-size buffers; it operates on pre-evaluated tensor data. The memory safety concerns and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read (CWE-119) in a file utility due to incorrect length calculation. The target code reads from a tensor's flat array using `NumElements()` as a bound, which is safer. The domains (file parsing vs. tensor shape checking) and vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow (CWE-119) in a network packet unescaping routine. The target code does not process escape sequences or network data. The vulnerability mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2014-9140"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a buffer size miscalculation leading to invalid free (CWE-17/590) in a magic file loader. The target code does not perform manual memory allocation/deallocation; it uses TensorFlow's tensor management. The memory management models are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2014-9426"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a double-free (CWE-415) in a Python system library due to reference counting errors. The target code is C++ and uses RAII (`outputs_cleanup`) for resource management, with no manual reference counting. The vulnerability patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2019-18874"
        }
      }
    ]
  },
  "CVE-2022-2285_before_exclude_100:a7d01948:vulspec": {
    "timestamp": "2026-01-17T00:57:53.455280",
    "cve_id": "CVE-2022-2285",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a7d01948",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a terminal input parser in Vim, dealing with escape sequences and key codes. The vulnerability type (OOB read vs. complex input parsing), domain (regex vs. terminal I/O), and code patterns are fundamentally different. Only a very general similarity exists in processing untrusted input streams.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management during error handling. The target code performs deterministic parsing of terminal input within a single function, with no dynamic memory allocation or complex resource lifecycle management shown. The flaw patterns (UAF vs. parsing logic errors) and attack surfaces (local socket vs. terminal input) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2015-0241 is a buffer overflow in a database formatting function due to insufficient size checking. The target code also performs string/buffer operations (e.g., `STRNCMP`, `get_bytes_from_buf`) and has length checks (`len < slen`). There is a superficial similarity in the need to validate buffer boundaries during data processing. However, the context (database formatting vs. terminal code translation) and specific flaw mechanics differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code contains integer arithmetic and length calculations (e.g., `slen`, `j`, `len` comparisons) when processing terminal sequences. A key similarity is the need to safely handle attacker-controlled length fields and offsets to prevent buffer overflows. The domain difference (VNC file transfer vs. terminal input) limits the relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in the Linux kernel's key management subsystem. The target code has no permission checks or authorization logic; it is purely a parser/translator for input data. The vulnerability classes (logic/privilege vs. memory/safety) and code patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to inadequate bounds checking during multi-byte character processing. The target code similarly processes a sequence of bytes (terminal escape sequences), performs bounds checks (`len < slen`), and has complex state transitions to interpret multi-byte codes. The pattern of iterating through an input buffer with careful length validation is shared. The specific vulnerability (OOB read) could theoretically occur if length checks are missed, though the code shown appears robust.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8925 is a resource leak (reference count) in a USB serial driver. The target code shows no resource management, reference counting, or driver-like operations. It is a user-space parsing function with no persistent resource lifecycle issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition in kernel memory policy code. The target code is a single-threaded parser with no concurrency, dynamic memory deallocation, or shared resource locking. The flaw patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-8924 is an integer underflow in a USB driver leading to information disclosure. The target code performs arithmetic on lengths and offsets (e.g., `slen = j`, `offset++`, `len - offset`). While no obvious underflow is present, the pattern of manipulating attacker-controlled integers (like sequence lengths) without rigorous validation is a shared concern. The function guards against negative lengths via comparisons, but integer handling flaws are a relevant category for this input parsing code.",
        "case_metadata": {
          "cve_id": "CVE-2017-8924"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a TLV length field. The target code is also a protocol parser (for terminal codes) that must validate lengths (`slen`, `modslen`) against available input (`len`). Both involve parsing structured data with length fields from an untrusted source. The code shows multiple checks (`len < slen`), mirroring the need for bounds validation present in the tcpdump flaw. The domain difference (network packet vs. terminal stream) is notable but the core vulnerability pattern is similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-2285_after_exclude_100:9fddf57c:vulspec": {
    "timestamp": "2026-01-17T00:58:05.757318",
    "cve_id": "CVE-2022-2285",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9fddf57c",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a terminal input parser that handles escape sequences and mouse events. While both involve parsing complex input, the vulnerability type (OOB read vs. potential buffer overflows/integer issues), domain (regex vs. terminal I/O), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management. The target code is a terminal input parser with no dynamic memory allocation/free operations shown. The vulnerability patterns (UAF vs. buffer/parsing logic flaws) and system domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2015-0241 involves buffer overflow in string formatting. The target code has buffer operations (e.g., `tp[len] = NUL`) and string comparisons, sharing the theme of input validation. However, the specific flaw (format string buffer calc) and context (database vs. terminal) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 involves integer overflow leading to OOB write in a network protocol handler. The target code parses terminal sequences with length checks (e.g., `if (len < slen)`), but also has potential for integer issues in index calculations (e.g., `offset`, `slen` arithmetic). Both handle structured input, but the vulnerability manifestation (heap corruption vs. terminal state corruption) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in a kernel keyring subsystem. The target code has no permission/authorization logic. Domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-1833 involves out-of-bounds read in an XML parser due to inadequate bounds checking during multi-byte processing. The target code extensively parses terminal sequences with length checks (`len < slen`), but has complex logic with early returns (`return -1`) that could be bypassed or mishandled. Both are parsers of structured input where length validation is critical. The vulnerability type (OOB read) could potentially apply if terminal sequence length miscalculations occur.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8925 is a resource leak (reference counting) in a USB driver. The target code shows no similar resource management patterns (no dynamic allocation, reference counts, or cleanup logic shown). Domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free due to race condition in kernel memory policy. The target code is a synchronous terminal input parser with no concurrency, memory allocation, or free operations shown.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2017-8924 involves integer underflow in a USB driver leading to information disclosure. The target code has several integer arithmetic operations on lengths and offsets (e.g., `slen`, `offset`, `len` calculations, `--urb->actual_length` equivalent patterns). The function handles variable-length terminal sequences where improper length decrements or comparisons could lead to similar underflow/overflow issues. Both process structured data streams with length fields.",
        "case_metadata": {
          "cve_id": "CVE-2017-8924"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-14461 involves out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code parses terminal codes with length fields and has checks like `if (len < slen)`. Both involve parsing Type-Length-Value like structures (terminal codes have length prefixes). The pattern of validating input length before processing is central to both, though the specific context differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-27448_before_exclude_100:9eefa01e:vulspec": {
    "timestamp": "2026-01-17T00:58:21.248195",
    "cve_id": "CVE-2022-27448",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9eefa01e",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a use-after-free vulnerability in a network daemon (MiniSSDPd) related to socket message handling and memory management errors. The target code is a MySQL/MariaDB multi-update table initialization function focused on SQL query execution, temporary table creation, and field management. The domains (network protocol vs. database engine), vulnerability types (memory corruption vs. potential logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in Perl's regex compilation engine due to improper NUL byte handling. The target code is a database function managing SQL update operations, temporary tables, and field lists. There is no regex parsing, character sequence processing, or similar buffer manipulation patterns. The functional contexts and potential flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a heap buffer overflow in an image codec (OpenJPEG) due to insufficient padding allocation. The target code involves database operations and uses `create_tmp_table` which performs memory allocation. While both involve allocation logic, the specific vulnerability mechanism (padding calculation for compressed data) and domain (image processing vs. database query execution) are vastly different. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds write in a VNC server due to integer overflow in file transfer size calculation. The target code performs database operations and uses `create_tmp_table` which could involve size calculations. There is a superficial similarity in performing allocations based on input (field counts). However, the specific integer overflow/truncation vector in network protocol parsing is not present in the shown code, and the domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is improper input validation in a network packet parser (tcpdump) leading to missing bounds checks. The target code is a database internal function that processes internal structures (TABLE_LIST, JOIN) rather than untrusted network data. While both involve parsing structures, the attack surface (external packet data vs. internal query representation) and validation requirements are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a double-free vulnerability in an antivirus file parser (ClamAV) during error handling. The target code has multiple error paths with `DBUG_RETURN(1)` that could lead to inconsistent state if cleanup is not handled correctly elsewhere. This provides a minor conceptual reference for error path resource management. However, the specific double-free mechanism in VBA parsing and the domain (file parsing vs. database query initialization) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds write in an image library (OpenJPEG) due to missing buffer size validation, related to an incomplete fix. The target code uses `create_tmp_table` which must validate parameters. There is a vague similarity in the need to validate sizes/limits when creating structures. However, the specific context of writing image marker segments vs. initializing SQL update temporary tables offers little direct reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is improper validation of privilege separation state in a network daemon (radvd), leading to unnecessary privilege retention. The target code is a non-privileged database query execution function with no privilege management or security boundary aspects. The vulnerability categories and code patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is improper input validation in a decompression module (ClamAV) leading to out-of-bounds write. The target code processes field lists and table references which require validation (e.g., bounds checks on array accesses like `join->map2table[tbl->tablenr]`). This provides a minor conceptual reference for validating indices derived from input/data structures. However, the specific compression algorithm context and memory corruption vector are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a race condition in a filesystem's node ID management (Linux F2FS). The target code is a database function that appears to run in a single thread context for a specific query execution, with no evident concurrency or atomicity concerns in the shown snippet. The vulnerability type (concurrency bug) and domain (kernel filesystem vs. user-space database engine) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2022-27448_after_exclude_100:28b1d3f4:vulspec": {
    "timestamp": "2026-01-17T00:58:34.331038",
    "cve_id": "CVE-2022-27448",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "28b1d3f4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2016-3179) involves a Use-After-Free in a network daemon's memory management. The target code is a MySQL multi-update table initialization function focused on SQL query processing, temporary table creation, and field management. There is no similarity in vulnerability type (no pointer manipulation or dynamic memory deallocation), domain, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 (CVE-2018-18313) is an Out-of-bounds Read in a Perl regex compiler due to improper NUL byte handling. The target code performs database operations, list iterations, and temporary table setup. There are no string parsing, character class processing, or buffer read operations that could lead to similar memory disclosure issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 (CVE-2017-14151) is a heap buffer overflow in an image codec due to insufficient padding allocation. The target code also involves memory allocation (via `create_tmp_table`), but the context, trigger conditions, and flaw patterns are vastly different. The target's potential issues would relate to SQL logic or resource exhaustion, not precise buffer size miscalculations for compressed data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 (CVE-2018-20750) is an Out-of-bounds Write from an integer overflow in a network protocol handler. The target code has integer use (counters, table indices) but no obvious arithmetic operations that could overflow/wrap and lead to undersized allocations. The domains (database engine vs. VNC file transfer) and attack surfaces are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 (CVE-2019-15166) is an Improper Input Validation leading to potential memory corruption in a network packet parser. The target code does parse internal SQL structures (fields, tables) but within a trusted context. It lacks the network-facing, untrusted data parsing and bounds-checking omissions that characterize this CVE.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 (CVE-2011-1003) is a Double Free in a file parser during error handling. The target code has multiple error paths with `DBUG_RETURN(1)`, but there is no visible pattern of manual memory management (`free`/`delete`) that could lead to a double free. Memory is likely managed via allocator contexts (`thd->mem_root`). The flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 (CVE-2017-14164) is an Out-of-bounds Write due to missing buffer size validation when writing image markers. The target code writes to temporary tables via `create_tmp_table` and `extra(HA_EXTRA_WRITE_CACHE)`. While both involve writing data, the target's operations are abstracted through storage engine interfaces, making direct buffer overflow from size miscalculation less likely in this specific function.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CVE-2011-3603) is a privilege management flaw where a daemon fails to drop privileges after an initialization error. The target code is a database function with no privilege separation logic. Error handling exists, but it does not involve process privileges or setuid/setgid operations.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 (CVE-2010-1311) is an Improper Input Validation in a decompression algorithm leading to buffer overflow. The target code does not parse compressed or untrusted file formats. Its input validation concerns SQL semantics (e.g., `error_if_full_join`, `implicit_grouping`), not binary data boundaries.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 (CVE-2017-18249) is a Race Condition in a filesystem's node ID management. The target code is part of a single SQL query execution in a likely single-threaded context (per THD). There is no evidence of concurrent data structure manipulation (like lock-free lists) that could lead to similar state corruption races.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2022-27666_before_exclude_100:78a697ce:vulspec": {
    "timestamp": "2026-01-17T00:58:34.858283",
    "cve_id": "CVE-2022-27666",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "78a697ce",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a user-space network protocol parser (tcpdump) due to insufficient length validation. The target code is kernel-space IPSec ESP packet processing, focusing on memory allocation, buffer management, and sk_buff manipulation, with no direct protocol parsing of untrusted data fields.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a user-space regular expression engine due to improper NUL byte handling. The target code is kernel networking code dealing with sk_buff data structures, page fragments, and cryptographic trailer appending. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves an integer overflow leading to an out-of-bounds write in a VNC file transfer component. The target code performs careful size calculations (ALIGN, skb_tailroom checks) and uses skb_cow_data for safe expansion. While both involve buffer management, the specific flaw pattern (integer overflow in allocation) is not evident in the target code's arithmetic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a use-after-free in a daemon's service registration due to inconsistent state cleanup. The target code manages kernel memory (page fragments, sk_buff) with spinlocks and reference counting (get_page, sk_wmem_alloc). The memory management models (kernel vs. user-space, resource cleanup paths) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a heap buffer overflow in an image codec due to insufficient padding allocation. The target code also deals with buffer sizing and appending data, but its logic is centered on network sk_buff expansion and page fragment allocation, with explicit size alignment and room checks. The overflow mechanism is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is an integer overflow in DNS domain name length calculation leading to an out-of-bounds write. The target code performs arithmetic (ALIGN, addition) on sizes (tailen, allocsize) but uses safe patterns (ALIGN with constant, checked refill). The potential for similar integer wrap-around exists but is mitigated by the context (allocsize from tailen).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 is a kernel buffer overflow in FUSE ioctl due to insufficient validation of iovec lengths. The target code is also in the Linux kernel and involves careful validation of buffer sizes (skb_tailroom, nr_frags checks) before operations. Both are kernel subsystems validating user/network-controlled data sizes to prevent overflows, though the specific data structures and APIs differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 8 is an out-of-bounds read in a packet dissector due to missing bounds checks on parsed fields. The target code processes ESP packets but does not parse variable-length headers from untrusted data; it manages buffers for a known trailer size. The vulnerability pattern (parsing untrusted protocol fields without validation) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-16227"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in an XML library due to improper buffer management during multi-byte character processing. The target code handles raw packet buffers but does not perform character encoding or complex stateful parsing. The domains (text parsing vs. packet encryption) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is a buffer overflow in an IPv6 RA daemon due to negative length value handling. The target code deals with positive sizes (tailen) and uses unsigned operations. While both are network-related, the attack vector (crafted network packet with malicious length) and the specific flaw (signedness error) are not mirrored in the target code's logic.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      }
    ]
  },
  "CVE-2022-27666_after_exclude_100:21ec494b:vulspec": {
    "timestamp": "2026-01-17T00:59:40.531138",
    "cve_id": "CVE-2022-27666",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "21ec494b",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a user-space network protocol parser (tcpdump). The target code is kernel-space IPsec packet processing, focusing on memory allocation, buffer management, and sk_buff manipulation. The vulnerability type (CWE-125 vs. potential allocation/write issues), domain, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves an out-of-bounds read in a user-space regular expression engine due to improper NUL byte handling. The target code is kernel networking code dealing with sk_buff fragmentation and trailer addition. The contexts (string parsing vs. network buffer management) and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves an integer overflow (CWE-190) leading to an out-of-bounds write (CWE-787) in a network protocol handler. The target code performs arithmetic (allocsz, allocsize calculations using ALIGN) which could theoretically overflow, but it uses unsigned ints and operates in the kernel context with different constraints. The core flaw pattern (integer overflow in allocation) has some conceptual similarity, but the implementation domain (VNC file transfer vs. IPsec output) and specific triggers are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a use-after-free (CWE-416) in a daemon's resource management. The target code manages page fragments and sk_buff references (get_page, skb operations) but does not show obvious patterns of freeing and later using the same resource within this function. The memory management models (kernel page frag cache vs. daemon structures) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 5 is a buffer overflow (CWE-119) due to insufficient buffer allocation/padding in an image codec. The target code carefully calculates allocation sizes (allocsz, allocsize) and has a fallback path (cow) if conditions aren't met. The relevance lies in the pattern of calculating buffer sizes and ensuring they are sufficient before writing data (esp_output_fill_trailer, pskb_put). However, the domain (image encoding vs. network crypto) and specific overflow mechanisms differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves an integer overflow (CWE-190) in domain name length calculation leading to an out-of-bounds write. The target code has integer calculations (allocsz, allocsize) but uses ALIGN macros and operates on sizes derived from packet data (tailen). While integer overflows are a general concern, the code does not show the same pattern of user-controlled length leading to a miscalculated buffer size. The context (DNS parsing vs. IPsec output) is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 7 is a buffer overflow (CWE-119) in kernel FUSE due to insufficient validation of iovec lengths. The target code is also in the kernel and performs buffer operations (skb data/tail manipulation) based on calculated sizes. The key similarity is the need to validate that data written (trailer, tailen) fits within the allocated/available space. The `pskb_put` and buffer expansion logic must be correct to avoid overflows. The domains differ (filesystem vs. networking), but the core issue of bounds-checking kernel buffer operations is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read (CWE-125) in a packet dissector due to missing bounds checks on packet data. The target code does parse packet structures (esp->esph pointer adjustment) but primarily focuses on constructing/expanding output buffers, not reading untrusted packet fields beyond initial validation. The vulnerability pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-16227"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in an XML parser due to improper buffer management during character encoding. The target code's buffer management is for kernel network packets (sk_buff), not string/character parsing. The contexts and flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 10 is a buffer overflow (CWE-119) in a network daemon due to improper validation of a length field (negative value) from a network packet. The target code handles `tailen` (likely derived from packet or crypto parameters) and uses it for buffer allocation and writing. While the target code uses unsigned lengths, the pattern of trusting and using a network-derived value for memory operations is similar. The `esp_output_fill_trailer` and `pskb_put` must not overflow the allocated space. The context (IPv6 RA vs. IPsec ESP) is different but both are network protocol implementations.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      }
    ]
  },
  "CVE-2020-7046_before_exclude_100:e491ddc3:vulspec": {
    "timestamp": "2026-01-17T00:59:43.161522",
    "cve_id": "CVE-2020-7046",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e491ddc3",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code is an SMTP command parser performing UTF-8 validation and length checking. Both parse input, but the vulnerability type (CWE-125 vs. potential CWE-20/128), domain (regex vs. SMTP), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is an integer overflow leading to out-of-bounds write in a VNC file transfer. The target code performs bounds checking using uoff_t comparisons and UTF-8 character iteration. Both handle network protocol data, but the vulnerability mechanism (CWE-190/787 vs. defensive checks) and critical operations (memory allocation vs. parsing) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an integer underflow in an IMAP client during string quoting. The target code also processes protocol strings with length checks. Both involve protocol parsing and length validation, but the specific flaw (underflow during transformation vs. overflow/UTF-8 validation) and context (IMAP client vs. SMTP server/library) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 is an out-of-bounds read in a packet parser due to insufficient length validation. The target code also parses network protocol data (SMTP) with length checks (max_size). Both involve validating input lengths against a buffer, but the vulnerability type (CWE-125 from missing check vs. defensive code that has checks) and protocol layer differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a use-after-free in a service daemon due to error handling issues. The target code is a parsing function with no dynamic memory allocation or complex state cleanup. The vulnerability classes (CWE-416 vs. potential CWE-20/128) and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 6 is an out-of-bounds read in libxml2 during multi-byte UTF-8 character processing. The target code also processes UTF-8 characters (uni_utf8_get_char_n) and validates them against buffer bounds. Both involve careful bounds checking during multi-byte character decoding in a parser, making the code patterns and potential pitfalls similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is improper input validation leading to improper exception handling in an NNTP client. The target code validates UTF-8 and length, but does not show complex error recovery or memory allocation failure handling. Both are protocol parsers, but the flaw nature (CWE-20/703 vs. defensive validation) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-14361"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an information disclosure via residual pointers in an HTTP cache. The target code is a stateless parsing function with no persistent connection state or sensitive data retention. The vulnerability domain (state management between requests vs. single-buffer parsing) is unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a NULL pointer dereference in a kernel CIPSO module. The target code does not dereference complex structures or have similar parameter validation issues. The contexts (kernel networking vs. user-space SMTP parsing) and flaw patterns are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an integer overflow in an SSH library during packet length validation. The target code also performs length checks (max_size) but uses uoff_t and seems to avoid overflow via safe comparisons. Both involve network protocol length validation, but the specific risk (overflow/wraparound vs. straightforward comparison) and mitigation differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      }
    ]
  },
  "CVE-2020-7046_after_exclude_100:6e310f5b:vulspec": {
    "timestamp": "2026-01-17T00:59:49.134394",
    "cve_id": "CVE-2020-7046",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6e310f5b",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in a regex engine due to NUL byte handling. The target code is an SMTP parameter parser that processes UTF-8 and ASCII text with explicit bounds checking (p < parser->end) and size limits. The vulnerability type, domain (regex vs. protocol parsing), and trigger conditions are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer. The target code performs bounds-checked parsing with size_t/uoff_t and has no dynamic memory allocation or integer overflow in the shown path. Both parse network input, but the vulnerability mechanism (integer overflow/write vs. bounds-checked read) and domain differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-14353 involves integer underflow in IMAP string quoting. The target code also processes protocol strings with length calculations (p - parser->cur) but uses unsigned offsets with explicit max_size checks, making underflow unlikely. Both are email-related protocol parsers, but the specific flaw (underflow from escaping) is not present in the target's linear character iteration.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-14461 involves out-of-bounds read due to insufficient length validation in a network protocol parser. The target code is also a network protocol (SMTP) parser that validates bounds (p < parser->end) and maximum sizes. The similarity is in protocol parsing and bounds checking, but the target code's checks appear robust, and the specific flaw (missing RFC check) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a service discovery daemon. The target code has no dynamic memory allocation/deallocation in the shown function (uses i_strdup_until). The vulnerability class (memory corruption vs. parsing logic) and domain are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2016-1833 involves out-of-bounds read during multi-byte UTF-8 processing in libxml2. The target code also processes UTF-8 (via uni_utf8_get_char_n) with bounds checking. Both handle variable-width encoding and validate buffer limits. The key similarity is in safe UTF-8 parsing; however, the target code checks nch and buffer bounds explicitly, reducing risk.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14361 involves improper input validation and failure handling in NNTP. The target code validates input (UTF-8, textstr chars) and handles errors via smtp_command_parser_error. Both are email protocol parsers, but the flaw (memory allocation failure mishandling) is not present in the target's string duplication (i_strdup_until).",
        "case_metadata": {
          "cve_id": "CVE-2018-14361"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-20637 involves information disclosure via residual pointers in an HTTP cache. The target code parses SMTP commands without persistent connection state or sensitive data retention across calls. The vulnerability type (state leakage vs. parsing) and domain differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-0310 is a NULL pointer dereference in a kernel CIPSO module. The target code is user-space SMTP parsing with no pointer dereferences on external inputs (works on buffer pointers). The domain (kernel networking vs. application protocol) and flaw type are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-17498 involves integer overflow in SSH packet validation leading to out-of-bounds read. The target code uses uoff_t for size comparisons and checks (uoff_t)(p - parser->cur) > max_size, which could theoretically overflow if p - parser->cur wraps, but uoff_t is unsigned and the pointer difference is bounded by buffer size. Both are network protocol parsers with integer bounds checks, but the target's arithmetic is less complex.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      }
    ]
  },
  "CVE-2022-32323_before_exclude_100:67321b7f:vulspec": {
    "timestamp": "2026-01-17T01:00:04.537410",
    "cve_id": "CVE-2022-32323",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "67321b7f",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve BMP file parsing with insufficient validation of header fields (biBitCnt, biWidth, biHeight) leading to potential memory allocation issues (CWE-119). The target code performs multiple sanity checks (e.g., integer overflow checks for width/height), but shares the core vulnerability pattern of parsing untrusted BMP headers. The flaw pattern (malformed header  allocation failure/corruption) is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case involves a network daemon (MiniSSDPd) with a Use-After-Free (CWE-416) vulnerability in service registration error handling. The target code is a local BMP file parser with no network components, no dynamic service management, and a different error handling pattern (goto cleanup). No meaningful similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve integer overflow/truncation vulnerabilities (CWE-190) during size calculations for memory operations. The target code has explicit overflow checks (e.g., `overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt` and comparisons against 0x7fffffff), showing awareness of this issue pattern. The core flaw (malicious input causing miscalculated buffer size) is similar, though the target code appears to have mitigations.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case involves WebSocket frame decoding with unaligned memory access (CWE-787 due to CWE-188). The target code reads BMP files with byte-aligned reads via `ReadOK` and properly aligned buffer accesses. While both parse binary formats, the specific vulnerability mechanism (alignment assumptions) and domain (network protocol vs. image file) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing binary data from untrusted sources, but the vulnerability specifics differ. Case 5 is about hex string parsing without bounds checking leading to OOB write. The target code reads structured BMP headers with size checks, though it uses fixed-size buffers (e.g., `buffer[64]`) for variable-length reads which could be a similar surface if `ReadOK` doesn't validate length.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Both involve integer overflow vulnerabilities (CWE-190) during calculations based on untrusted input (key length in HFS, width/height/bits in BMP). The target code explicitly checks for overflows in `rowbytes` calculation and width/height multiplication, directly addressing this vulnerability pattern. The attack vector (crafted file with large dimensions) is conceptually similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case involves Double Free (CWE-415) in VBA parsing during error handling. The target code uses a single cleanup path with `goto cleanup` and doesn't show complex resource management that could lead to double-free. Both parse file formats, but the memory management error pattern and specific vulnerability type are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve image format parsing with potential buffer overflow (CWE-119) due to insufficient validation. Case 8 is about JPEG2000 code block allocation; target code is BMP parsing with size calculations. The target code performs several overflow checks, but the pattern of calculating buffer sizes from untrusted header values is similar. The mitigation awareness in target code reduces direct equivalence.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing untrusted file formats with potential out-of-bounds read/write issues. Case 9 is about XML character encoding parsing leading to OOB read (CWE-125); target code reads binary BMP data. The target code uses `ReadOK` wrapper which may provide bounds checking, but the fundamental pattern of reading variable-length data based on file headers shares some similarity in attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve image format parsers, but the vulnerability type differs significantly. Case 10 is a resource leak (CWE-772) during error handling when `SetImageExtent` fails. The target code uses centralized `cleanup` label with `fclose(fd)` but doesn't show complex resource allocation that could leak. Both handle image dimensions, but the error handling and resource management patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15032"
        }
      }
    ]
  },
  "CVE-2022-32323_after_exclude_100:d357ba72:vulspec": {
    "timestamp": "2026-01-17T01:00:23.040528",
    "cve_id": "CVE-2022-32323",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d357ba72",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve parsing BMP file headers and performing validation checks. The target code has extensive validation for header fields (biWidth, biHeight, biBitCnt, etc.) and includes integer overflow checks (e.g., `overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt`), which is the core issue in CVE-2017-12982 (unchecked header values leading to memory allocation issues). The vulnerability type (CWE-119 via improper validation) and attack surface (malicious BMP file) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network service daemon (MiniSSDPd) related to socket message handling and inconsistent state management. The target code is a local BMP file parser with no network components, dynamic service registration, or complex pointer state management. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2018-20750 involves an integer overflow (CWE-190) in a memory allocation calculation leading to an out-of-bounds write. The target code performs several integer overflow checks (e.g., on `Bitmap_Head.biWidth * Bitmap_Head.biBitCnt` and comparisons with `0x7fffffff`). While the specific context (VNC file transfer vs. BMP parsing) differs, the core flaw pattern of integer overflow in size calculations for buffer operations is similar and highly relevant for secure coding reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2019-20840 is an out-of-bounds write caused by unaligned memory access during WebSocket frame unmasking. The target code reads BMP data into a buffer and performs byte-order conversions (`ToL`, `ToS`), but there is no indication of similar word-sized operations on potentially unaligned network data. The vulnerability patterns (alignment issues) and domains (network protocol vs. file format) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-11222 is an out-of-bounds write during hex string parsing. The target code parses binary BMP headers but does not involve parsing hex strings or similar cryptographic/data format boundaries. Both involve parsing binary data, but the specific vulnerability mechanism (lack of bounds checking during string conversion) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2019-1010065 involves an integer overflow (CWE-190) during filesystem B-tree key length calculation. The target code explicitly checks for integer overflows in multiple calculations (width * bit count, width * height). The core vulnerability type (integer overflow leading to insufficient validation/buffer corruption) is identical, even though the application domains (filesystem forensics vs. image parsing) differ. The defensive patterns are directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double-free in an antivirus VBA parser during error handling. The target code uses `goto cleanup` for error handling and frees resources (closes file) in a single place, showing a simpler resource management pattern. There is no complex nested allocation or state that could lead to a double-free in the shown code. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-14151 is a buffer overflow (CWE-119) due to insufficient padding allocation in an image codec. The target code calculates `rowbytes` for BMP row alignment and passes dimensions to `ReadImage`. While it doesn't show the internal allocation of `ReadImage`, the context of calculating buffer sizes for image data based on file headers is similar. The relevance is moderate because the specific padding calculation flaw is not visible, but the domain (image parsing) and vulnerability class are aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper buffer state validation during multi-byte character processing. The target code reads data into a fixed-size `buffer[128]` and uses `ReadOK` to check read operations. It lacks complex character encoding handling. The relevance is limited to the general concept of parsing untrusted input and checking read operations, but the specific vulnerability mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-15032 is a memory leak (CWE-772) in an ImageMagick coder during error handling. The target code has a `cleanup` label that closes the file (`fclose`), but does not show dynamic allocation of resources like `quantum_info` that could be leaked. The `image_storage` from `ReadImage` is passed to `at_bitmap_init`, but its cleanup is not shown. The error handling pattern (`goto cleanup`) is sound in the shown snippet. The relevance is low as the specific resource leak pattern is not evident.",
        "case_metadata": {
          "cve_id": "CVE-2017-15032"
        }
      }
    ]
  },
  "CVE-2018-18820_after_exclude_100:2e8ef557:vulspec": {
    "timestamp": "2026-01-17T01:01:14.756010",
    "cve_id": "CVE-2018-18820",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2e8ef557",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a file transfer protocol. The target code performs string comparisons and numeric parsing from network headers but does not contain complex integer arithmetic or dynamic memory allocation that could lead to similar overflow/write vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves out-of-bounds read due to improper NUL byte handling in regex parsing. The target code processes HTTP-style headers with explicit length checks and strncasecmp, which are generally safer. Both handle string data, but the vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 3 involves out-of-bounds read due to insufficient validation of length fields in network protocol parsing. The target code also parses network headers with length fields (url->auth_header_len, url->timelimit_header_len) and could potentially suffer from similar issues if length values are miscalculated or untrusted, though the code shows more validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves out-of-bounds read during multi-byte character processing in XML parsing. The target code handles ASCII/UTF-8 headers but doesn't perform complex character encoding transformations. Both process external input, but the vulnerability mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves use-after-free due to inconsistent state management during error handling. The target code doesn't show dynamic memory allocation/deallocation patterns or pointer management that could lead to similar issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 involves out-of-bounds read in XML end tag parsing. The target code processes headers with length checks but could have similar issues if length calculations are incorrect. Both parse structured text data, but the specific vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 involves heap buffer overflow due to insufficient buffer growth strategy and unsafe string operations. The target code uses memcpy with length calculations (copy_len) and has a bounds check against sizeof(url->errormsg). Similar issues could occur if copy_len calculations are incorrect or if input validation fails.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 8 involves missing resource release in authentication abort scenarios. The target code handles authentication headers but doesn't show complex resource management or cleanup patterns that could lead to similar memory exhaustion issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-15132"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 involves integer overflow leading to out-of-bounds write in DNS parsing. The target code performs arithmetic (size * nmemb, len - 24 + 1) but with size_t which is unsigned and less prone to overflow issues. Both parse network data, but the vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves resource management errors due to repeated message processing. The target code is a callback function for header processing and doesn't show stateful message handling or resource accumulation patterns that could lead to similar exhaustion issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-8858"
        }
      }
    ]
  },
  "CVE-2022-1286_before_exclude_100:20fe80b3:vulspec": {
    "timestamp": "2026-01-17T01:01:19.680302",
    "cve_id": "CVE-2022-1286",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "20fe80b3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs a simple hash table deletion and error handling, while CVE-2018-18313 involves complex regex parsing with NUL byte handling leading to out-of-bounds reads. The vulnerability type, trigger conditions, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow/wraparound leading to out-of-bounds write during memory allocation. The target code performs a straightforward method removal from a class's method table with no arithmetic operations or dynamic memory allocation, making the vulnerability patterns unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. While both involve resource management, CVE-2016-3179 is a use-after-free vulnerability in a network daemon due to uninitialized pointers and inconsistent state. The target code's `mt_del` operation could potentially have memory safety issues if the hash table is corrupted, but the patterns are not directly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2011-1003 is a double-free vulnerability in a file parsing subsystem during error conditions. The target code's `mt_del` function could theoretically have double-free issues if the hash table implementation is flawed, but the code pattern shown is simple deletion with error reporting, not complex parsing with multiple cleanup paths.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 involves out-of-bounds read in a network protocol parser due to insufficient length validation. The target code performs a hash table lookup and deletion with no buffer or length operations, making the vulnerability patterns fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 involves out-of-bounds read in an XML parser during end tag processing. The target code is a simple method removal function with hash table operations, not a complex parser with buffer boundary issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-1311 involves improper input validation in a decompression module leading to memory corruption. The target code performs method table management with no compression/decompression logic or complex input validation requirements.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-15166 involves improper input validation in a network protocol parser. The target code handles method removal in a programming language runtime with no network protocol parsing or packet data validation.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3601 involves buffer overflow in a network daemon's DNSSL parser. The target code performs hash table operations with no buffer copying, network protocol handling, or length validation issues apparent in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2013-2124 involves double-free vulnerability during error handling in a file reading function. The target code has error handling (`mrb_name_error`) but doesn't show complex resource cleanup or ownership transfer patterns that could lead to double-free. The `mt_del` function could potentially have memory management issues, but the patterns aren't directly similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2018-18820_before_exclude_100:b66cb773:vulspec": {
    "timestamp": "2026-01-17T01:01:20.357756",
    "cve_id": "CVE-2018-18820",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b66cb773",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code is an HTTP header handler for an authentication client. The vulnerability types (CWE-787 vs. string parsing/bounds checking), domains (remote desktop vs. web/auth), and code patterns (integer arithmetic vs. string comparison and sscanf) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a Perl regex engine due to NUL byte handling. The target code processes HTTP response headers. The vulnerability types (CWE-125 vs. string parsing), domains (regex compilation vs. network protocol handling), and attack surfaces (regex patterns vs. network data) are unrelated. No similar code patterns exist.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an out-of-bounds read in a network protocol parser (tcpdump/LDP) due to insufficient length validation. The target code also parses network data (HTTP headers) and uses `strncasecmp` and `sscanf`, which could be prone to similar issues if length fields are miscalculated. However, the specific vulnerability (CWE-125) and protocol context are different. The target code shows length-aware comparisons (`url->auth_header_len`), suggesting some awareness of bounds, but the `sscanf` on `ptr+offset` without checking if the offset is within the `bytes` boundary is a potential weak point.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in an XML parser due to multi-byte character encoding issues. The target code handles plain text HTTP headers. The vulnerability types (CWE-125 related to complex encoding states) and domains (XML parsing vs. simple string parsing) are not comparable. The code patterns and attack surfaces are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a Use-After-Free in a daemon related to error handling and memory management. The target code is a callback function that reads data but does not perform dynamic memory allocation or freeing. The vulnerability type (CWE-416) and the code's operational context are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is another out-of-bounds read in libxml2 during end tag parsing. Similar to Case 4, it deals with the complexities of structured document parsing. The target code's simple linear scanning of header lines does not share the same vulnerability patterns or context.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a memory leak (CWE-772) in an authentication subsystem during abort scenarios. While the target code is also part of an authentication client (`auth_client`), its function is to parse headers, not manage session lifecycle or resources. The vulnerability types and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15132"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an integer overflow leading to out-of-bounds write in a DNS domain name parser. The target code performs no complex arithmetic that could overflow. The vulnerability types (CWE-190/CWE-787) and the domains (DNS wire format parsing vs. HTTP header string comparison) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a resource exhaustion issue in SSH key exchange due to repeated message processing. The target code is a stateless callback for a single chunk of data. It does not manage session state or resources in a way that could be exhausted by repeated calls in the manner described. The vulnerability type (CWE-399) and context are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8858"
        }
      }
    ]
  },
  "CVE-2022-1286_after_exclude_100:a9525670:vulspec": {
    "timestamp": "2026-01-17T01:01:40.320620",
    "cve_id": "CVE-2022-1286",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a9525670",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a method removal function in an interpreter's class system, dealing with symbol table management. The CVE case involves a regex engine's buffer over-read due to improper NUL byte handling. The vulnerability type (CWE-125), domain (parsing vs. runtime method management), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs a simple hash table deletion and error handling. The CVE case involves an integer overflow leading to an out-of-bounds write in a network protocol file transfer component. The vulnerability mechanisms (CWE-787/CWE-190 vs. potential logic/state error) and contexts are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The primary CWE (416 - Use After Free) is not directly applicable to the target code, which does not involve dynamic memory deallocation. However, there is a tangential similarity in the theme of managing internal state (clearing a method cache `mrb_mc_clear_by_class`) after a state change, which relates to the CVE's issue of inconsistent state management during errors. The core flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The CWE (415 - Double Free) is not directly present in the target code. The relevance lies in the error handling path: both functions can reach an error condition (`mrb_name_error`) after performing an operation (deletion attempt, memory allocation). The target code's logic is simpler and does not involve the complex, inconsistent cleanup state that leads to a double-free. The reference value is limited to general error path safety considerations.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code involves symbolic lookup and removal from a hash table. The CVE case is an out-of-bounds read in a network protocol parser due to insufficient length validation. The domains (interpreter runtime vs. packet parsing) and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code performs a controlled hash table operation with no apparent buffer access. The CVE case is an out-of-bounds read in an XML parser due to insufficient bounds checking during tag processing. The mechanisms and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code is a straightforward method removal routine. The CVE case involves improper input validation leading to buffer overflow in a decompression algorithm. The functionality and potential flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code validates input via a hash table lookup (`mt_del`). The CVE case involves missing bounds checking in a network protocol decoder. While both involve input (a method symbol vs. a network packet), the nature of the validation and the consequent vulnerabilities (logic error vs. memory corruption) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve buffer copies or arithmetic on user-controlled lengths. The CVE case is a classic buffer overflow in a network daemon due to a negative length value. The code patterns and vulnerability classes are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Similar to Case 4, the primary CWE (415 - Double Free) is not directly applicable. The relevance is in the error handling pattern: both functions have a success path and a failure path that raises an error. The target code's `mrb_mc_clear_by_class` is called only on the success path, suggesting proper state separation, unlike the CVE's flawed cleanup logic. The reference value is in contrasting correct vs. incorrect error state management.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2021-37635_before_exclude_100:8467130e:vulspec": {
    "timestamp": "2026-01-17T01:02:48.151796",
    "cve_id": "CVE-2021-37635",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8467130e",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a sparse tensor reduction operation in a machine learning framework (likely TensorFlow). It involves arithmetic and memory operations but does not implement cryptographic primitives, constant-time logic, or handle secret data. The vulnerability type (side-channel information leak) and domain (cryptography) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs a numerical computation on tensor data. It does not involve database query planning, privilege checks, access control, or SQL/view semantics. The vulnerability type (improper access control) and system context are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Both involve processing structured input (image parameters vs. tensor indices/shapes). However, the core flaw (Use After Free due to improper state management in an image codec) is not present in the target code, which manages its own temporary Tensor objects with clear allocation/deallocation scopes. The code patterns and error paths differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The target code performs arithmetic operations (multiplications in `CoordinatesToFlatIndex`, stride calculations) on user-provided `shape_vec` and `reduction_axes`. There is a potential similarity in the need to validate integer inputs to prevent overflows in index calculations or memory allocations (e.g., `out_values` allocation). However, the code shows defensive copying and uses library functions for allocation. The specific flaw (integer overflow in image dimension parsing) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The target code involves division in stride calculation (`output_strides[d] = output_strides[d + 1] * shape_vec(...)`). While a divide-by-zero is theoretically possible if a shape dimension is zero, the `SparseTensor::Create` and `ValidateInputs` likely perform validation. The vulnerability context (image codec parsing) and the specific trigger (malicious sampling factors) are not analogous to the tensor shape handling here.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Similar to Case 4, the relevance stems from the potential for integer overflow in size calculations. The target code allocates memory based on `reduction.reduced_shape` and performs index calculations using user-controlled `shape_vec`. An integer overflow in these calculations could lead to out-of-bounds writes in `out_flat(idx)`. However, the code uses TensorFlow's allocation APIs which may have their own checks, and the pattern is less direct than the PCX plugin's explicit buffer size calculation.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The target code parses and processes structured data (tensor indices and groups) but does so using safe iterators (`sp.group`) and lambda functions. It does not manually parse tokens from a byte stream with complex delimiter and nesting logic, which is where the out-of-bounds write occurred in the DNS parser. The code patterns and risk profiles are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse raw string/hexadecimal input from untrusted sources. It receives data as Tensor objects, which are already structured. There is no evident stack buffer manipulation or direct parsing of configuration lines. The vulnerability type (stack buffer overflow) and attack surface are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The target code handles indices and coordinates, which are forms of vector data. A very abstract similarity exists in the need to validate that calculated indices (like `idx` from `CoordinatesToFlatIndex`) are within the bounds of the allocated `out_flat` buffer. However, the kernel driver's flaw involved direct iovec manipulation and missing bounds checks on aggregated sizes, a much lower-level and more complex scenario than the index arithmetic shown here.",
        "case_metadata": {
          "cve_id": "CVE-2012-2119"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs numerical reduction (sum, mean, etc.) on tensor data. It does not involve cryptographic algorithms, DNSSEC, key validation, or complex error state cleanup that could lead to NULL pointer dereference. The domain and failure modes are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      }
    ]
  },
  "CVE-2021-37635_after_exclude_100:08839409:vulspec": {
    "timestamp": "2026-01-17T01:02:52.081681",
    "cve_id": "CVE-2021-37635",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "08839409",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a sparse tensor reduction operation in a machine learning framework (likely TensorFlow), with no cryptographic operations or side-channel considerations. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library's elliptic curve implementation. The domains, functionality, and vulnerability patterns (information exposure via timing) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs numerical computations on tensor data with no database query planning, privilege checks, or access control logic. CVE-2019-10128 is an improper access control vulnerability in PostgreSQL's query planner. The systems, domains (database vs. numerical computing), and flaw nature (logic bug vs. potential memory/arithmetic bug) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The target code involves index calculations and memory allocation for tensors, but there is no direct evidence of use-after-free or the specific pattern of inconsistent state management leading to it as seen in CVE-2017-14152 (JPEG 2000 parameter validation). The core flaw patterns are different, though both involve processing structured input data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The target code performs arithmetic operations (multiplication, addition) on indices and dimensions (e.g., `shape_vec(reduction.group_by_dims[d + 1])`). There is a potential for integer overflow if input `shape_vec` values are very large, which could lead to incorrect index calculation and out-of-bounds access, similar to the integer overflow leading to buffer overflow in CVE-2009-3909. However, the target code includes bounds checks (`OP_REQUIRES` on `idx`), which mitigates the risk. The similarity is in the arithmetic operation on untrusted input, but the manifestation and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The target code has a division operation (`output_strides[d + 1] * shape_vec(...)` is multiplication, not division). CVE-2016-8692 is a divide-by-zero flaw due to lack of input validation on sampling factors. The target code's vulnerability profile is more focused on integer overflow and bounds checking, not division by zero.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Similar to Case 4, the relevance stems from integer arithmetic on user-influenced values (`shape_vec`) which could overflow, especially in the `CoordinatesToFlatIndex` function where `coords[i] * strides[i]` is summed. If `shape_vec` values are maliciously large, the stride calculation and subsequent index calculation could overflow, potentially bypassing the `idx >= 0 && idx < out_flat.size()` check if the overflow wraps to a valid in-bounds value. This mirrors the integer overflow->buffer overflow pattern in CVE-2011-1178, though the target code's context (tensor indices) and specific checks are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The primary flaw in CVE-2019-25035 is an out-of-bounds write due to incorrect parenthesis counting and buffer management in a parser. The target code writes to a buffer (`out_flat(idx) = reduced_val()`) after calculating an index. The relevance is limited to the general concept of writing to a calculated index, which must be rigorously bounds-checked. The target code does have bounds checks, and the parsing/state machine complexity leading to the OOB write in the CVE is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-7837 is a stack buffer overflow in a string parsing function. The target code does not parse strings or use stack buffers in a similar way. It operates on pre-parsed tensor data structures. The memory safety concerns are different (heap-allocated tensors vs. stack buffers).",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2012-2119 involves insufficient validation of vector counts and sizes leading to a buffer overflow. The target code validates indices against the allocated output size (`out_flat.size()`). The similarity is in the need to validate calculated offsets/indices against buffer boundaries. However, the target code's validation appears more straightforward, and the attack vector (malicious tensor shape vs. malicious iovec) is different.",
        "case_metadata": {
          "cve_id": "CVE-2012-2119"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a cryptographic algorithm failure leading to a NULL pointer dereference. The target code performs numerical aggregation (reduce) and has no cryptographic components or complex error state cleanup that could lead to a NULL dereference. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      }
    ]
  },
  "CVE-2015-5745_before_exclude_100:baf6c1e3:vulspec": {
    "timestamp": "2026-01-17T01:02:53.936732",
    "cve_id": "CVE-2015-5745",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "baf6c1e3",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves an integer overflow leading to an out-of-bounds write during memory allocation. The target code performs a direct memcpy without explicit length validation against the destination buffer size, which is a potential buffer overflow. However, the mechanisms (integer overflow in allocation vs. missing bounds check on a fixed buffer) and domains (network protocol vs. virtio serial) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 2 involves a buffer overflow due to insufficient validation of iovec lengths in a data transfer operation. The target code's `memcpy` into `elem.in_sg[0].iov_base` is analogous: it assumes the provided buffer (`elem.in_sg[0]`) is large enough for `len` bytes. If the guest-provided buffer is smaller than `len`, this is a buffer overflow. The core flaw pattern (missing bounds check on a guest-supplied buffer during a copy operation) is similar, though the subsystems (FUSE vs. VirtIO) differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code performs a write operation (`memcpy`) and is in a completely different domain (device emulation vs. string parsing). The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a NULL pointer dereference due to insufficient validation of URB fields. The target code dereferences `elem.in_sg[0].iov_base` without checking if it is NULL. If a malicious guest can cause `virtqueue_pop` to return an element where `in_sg[0].iov_base` is NULL, the `memcpy` will dereference it, leading to a crash. The flaw pattern (missing NULL check on a pointer used for data access) is similar, but the manifestation (dereference in memcpy vs. direct pointer access) and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a race condition leading to concurrent buffer access and overflow in the TTY subsystem. The target code shows no evidence of concurrent execution or shared resource synchronization issues within this function. The vulnerability classes are different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code involves a write operation (`memcpy`) in a device emulation context. While both involve missing bounds checks, the direction (read vs. write) and the higher-level context are too dissimilar for strong relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a NULL pointer dereference due to missing validation of USB endpoint descriptors. As with Case 4, the relevance stems from the pattern of missing validation on a data structure (the `elem` and its `in_sg` array) provided by an external entity (the guest). If `elem.in_sg` is empty or `in_sg[0]` is invalid, the code could crash. The connection is indirect.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a race condition in filesystem metadata management. The target function `send_control_msg` shows no signs of concurrent access or complex state management that could lead to a race. The vulnerability patterns are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a use-after-free due to error handling and inconsistent state management. The target code is a simple, linear function with no apparent dynamic memory management or error paths that could leave dangling pointers. The flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a buffer overflow due to incorrect calculation of required buffer size (padding). The target code's potential overflow is more straightforward: copying `len` bytes into a buffer of unknown/unspecified size. The similarity is the \"buffer overflow\" outcome, but the root causes (calculation error vs. missing check) and domains are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2015-5745_after_exclude_100:faf5d439:vulspec": {
    "timestamp": "2026-01-17T01:03:07.184681",
    "cve_id": "CVE-2015-5745",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "faf5d439",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves an integer overflow leading to an out-of-bounds write during complex protocol parsing. The target code is a simple control message sender in a virtio-serial driver. Both handle data transfer, but the vulnerability patterns (integer overflow/wraparound vs. potential buffer length mismatch) and context (network protocol vs. virtual device queue) are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 2 involves a buffer overflow due to insufficient validation of iovec lengths in a FUSE ioctl handler. The target code uses `iov_from_buf` to copy data into an I/O vector from a virtqueue, which shares the concept of scatter-gather I/O. The relevance is limited because the target code's flaw (the commented \"TODO\" about detecting a too-short buffer) is a missing check, but the specific mechanism (iovec length summation) and subsystem (filesystem vs. virtualization) differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code performs a controlled copy into an I/O vector. The domains (string parsing vs. device I/O) and vulnerability types (read vs. write, complex parsing logic vs. simple copy) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 4 is a NULL pointer dereference in a USB/IP driver due to insufficient validation of URB fields (transfer_buffer vs. actual_length). The target code has a similar pattern: it copies data from `buf` into `elem.in_sg` without validating that the `elem.in_sg` I/O vector is large enough to hold `len` bytes (as noted by the TODO). Both involve data transfer in virtualization subsystems and missing validation of buffer/descriptor fields provided by an untrusted source (network/guest). The vulnerability type differs (NULL deref vs. potential buffer overflow), but the flaw pattern (insufficient input validation) is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a race condition leading to a buffer overflow in the TTY subsystem. The target code shows no evidence of concurrency issues (it operates on a per-call basis) and is not in a similar domain (terminal I/O vs. virtio-serial control messages). The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code's \"TODO\" comment indicates a potential missing check for a buffer that's too short, which could lead to an out-of-bounds write. Both involve missing bounds checks, but the contexts (packet parsing vs. virtqueue data transfer) and the direction of the violation (read vs. write) reduce the relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a NULL pointer dereference due to missing validation of USB endpoint descriptors. The target code does not dereference pointers from untrusted sources in a similar way. Both are in device driver contexts, but the specific flaw (missing check for existence of a required structure vs. missing check for buffer size) is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a race condition in a filesystem's node ID management. The target code shows no concurrency or state management patterns that would be similar. The domains and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a use-after-free due to improper resource cleanup in a network daemon. The target code performs simple, linear operations with no dynamic memory management shown. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is a buffer overflow due to insufficient buffer allocation (padding) in an image codec. The target code's \"TODO\" indicates a potential buffer overflow if the provided I/O vector is too short for the data length. Both involve a miscalculation or missing validation of buffer capacity vs. data size. The contexts are different (image encoding vs. virtio data transfer), but the core flaw of missing a bounds check is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2021-43057_before_exclude_100:60af4d04:vulspec": {
    "timestamp": "2026-01-17T01:04:16.710750",
    "cve_id": "CVE-2021-43057",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "60af4d04",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a privilege separation failure (CWE-20, CWE-250) in a userspace daemon. The target code is a Linux kernel SELinux security hook performing a simple permission check. The domain (kernel vs. userspace), vulnerability type, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to heap corruption (CWE-787) in a VNC server's file transfer. The target code is a straightforward kernel security hook with no complex arithmetic, memory allocation, or client data parsing. The attack surfaces and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a buffer overflow (CWE-119) in a network protocol parser due to improper bounds checking. The target code performs a single, well-defined permission check with no array or buffer operations. The functional domains and vulnerability mechanisms are completely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a use-after-free (CWE-416) in a userspace daemon's memory management. The target kernel code has no dynamic memory allocation or deallocation in its shown path. The code complexity and resource management patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a double free (CWE-415) in a library's file content processing. The target SELinux hook is a simple function call wrapper with no ownership or cleanup logic for dynamically allocated resources. The flaw patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 6 is a race condition (CWE-362) in the Linux kernel's F2FS filesystem. While both are in the Linux kernel, the domains differ (SELinux vs. filesystem). The target code shows no concurrency or shared state manipulation. However, both involve kernel-level access control/management, providing a minimal conceptual link.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow (CWE-119) in the kernel FUSE subsystem due to insufficient validation of user-controlled iovec lengths. The target SELinux code validates nothing itself; it delegates to `avc_has_perm`. The attack surface (malicious userspace server vs. kernel internal hook) and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read (CWE-125) in Perl's regex engine due to improper NUL byte handling. This is a userspace library vulnerability in a parsing component. The target is a kernel security module with no string parsing or memory scanning logic. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a use-after-free via a race condition (CWE-416, CWE-362) in the Linux kernel's memory policy subsystem. The primary relevance is that both are Linux kernel subsystems implementing security/policy logic. The target code is much simpler and shows no locking or resource lifecycle issues. The shared \"kernel policy enforcement\" domain offers some weak reference value for understanding kernel context.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is a race condition (CWE-362) in the Linux kernel TTY subsystem leading to buffer overflow. Both are in the Linux kernel. The target SELinux hook, while potentially called in concurrent contexts, is a single atomic function call to an Access Vector Cache (AVC) that likely has its own internal locking. The code structure is simple and does not exhibit the complex shared buffer state management of the TTY case. The kernel context provides a minor point of connection.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2021-43057_after_exclude_100:1e146b4b:vulspec": {
    "timestamp": "2026-01-17T01:04:19.093794",
    "cve_id": "CVE-2021-43057",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1e146b4b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a privilege separation failure (CWE-250) in a network daemon's initialization path. The target code is a simple permission check function in the Linux kernel's SELinux subsystem. The domains (userspace daemon vs. kernel security module), vulnerability types (logic flaw vs. potential access control bypass), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2020-15890_before_exclude_100:2b0014b6:vulspec": {
    "timestamp": "2026-01-17T01:04:23.338529",
    "cve_id": "CVE-2020-15890",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2b0014b6",
    "scores": [
      {
        "score": 3,
        "reasoning": "The target code is a LuaJIT stack frame traversal function for error handling, while Case 1 involves Perl's regex engine buffer over-read due to NUL byte handling. Both involve low-level memory operations, but the vulnerability type (CWE-125 vs. stack frame navigation), domain (parsing vs. runtime error handling), and attack patterns are fundamentally different. Only weak similarity in \"pointer/bounds checking\" concept.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 2 is an XML parser out-of-bounds read in libxml2. The target code navigates LuaJIT's internal call frames and C frames using pointer arithmetic and bounds checks (frame > bot). While both involve bounds checking, the context is entirely different: one is parsing untrusted external data (XML), the other is internal runtime state traversal. The vulnerability patterns and triggers are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Case 3 is a use-after-free in MiniSSDPd. The target code carefully walks linked structures (cframe chain) and could potentially encounter use-after-free if those structures were freed concurrently, but the code shows no memory management. The similarity is weak: both involve traversing linked data structures, but the vulnerability type (CWE-416) is not evident in the target code's pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 4 is an integer overflow leading to out-of-bounds write in LibVNC. The target code performs pointer arithmetic and bounds checks but does not involve integer overflows, memory allocation, or writes. The code only reads from frames. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 5 is another libxml2 out-of-bounds read during character encoding. The target code's bounds checks (frame > bot) and pointer dereferences could lead to out-of-bounds reads if invariants are broken, but the context is completely different: one is parsing multi-byte characters from external input, the other is internal stack navigation. Only superficial similarity in bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 6 is a tcpdump out-of-bounds read due to insufficient TLV length validation. The target code validates frame pointers against stack bounds but doesn't parse length fields from untrusted data. Both involve bounds checking failures, but the attack surface (network packet parsing vs. internal VM state) and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 7 is an integer overflow in DNS domain parsing leading to buffer overflow. The target code uses pointer arithmetic and comparisons but no integer computations that could overflow. The vulnerability patterns are fundamentally different (arithmetic overflow vs. pointer traversal).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 8 is improper input validation in tcpdump's LMP parser. The target code validates frame types and bounds but operates on trusted internal VM state, not untrusted network data. Both have validation logic, but the context and vulnerability potential differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 9 involves buffer management in Tor where missing sentinel values could lead to overreads. The target code traverses a stack with explicit bounds (bot) and type checks, similar to buffer boundary validation. Both involve careful bounds maintenance in low-level data structures. Moderate relevance due to similar \"bounds safety through invariants\" pattern, though vulnerability types differ (CWE-119 vs. potential stack corruption).",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 10 is a PHP GD library buffer overflow due to integer underflow/overflow. The target code has no arithmetic operations that could underflow/overflow; it uses pointer comparisons and type switches. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2020-15890_after_exclude_100:1d293a72:vulspec": {
    "timestamp": "2026-01-17T01:04:37.716065",
    "cve_id": "CVE-2020-15890",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1d293a72",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a LuaJIT stack-walking function for error handling, focusing on frame pointer traversal and validation. The vulnerability types (CWE-125 vs. stack/pointer logic), domains (parsing vs. runtime), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 is an out-of-bounds read in an XML parser due to insufficient bounds checking on end tags. The target code performs controlled pointer arithmetic and stack frame navigation within a Lua state. Both involve pointer manipulation, but the context (parsing untrusted data vs. internal stack management) and flaw nature (missing bounds check vs. logical traversal) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a use-after-free in a network daemon due to uninitialized pointers and inconsistent state cleanup. The target code meticulously tracks linked structures (cframe chain) and frame pointers, which shares a conceptual similarity with managing pointer chains and state. However, the vulnerability type (memory corruption vs. logic error) and domain differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds write due to integer overflow in a network protocol handler. The target code performs pointer arithmetic and comparisons but does not involve integer calculations for sizes or allocations. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is an out-of-bounds read in a parser due to inadequate bounds checking during multi-byte character processing. The target code walks a well-defined stack structure with frame type checks. Both require careful bounds awareness, but the target code's bounds are defined by the stack (`bot`) and frame sizes, not external input parsing.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is an out-of-bounds read in a packet parser due to insufficient TLV length validation. The target code validates frame types and navigates a linked structure but does not parse variable-length fields from untrusted data. The attack surfaces and validation patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an integer overflow leading to out-of-bounds write in a DNS domain name parser. The target code uses pointer arithmetic and comparisons but does not perform arithmetic on length fields or allocate buffers. The core vulnerability mechanism is absent.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 8 is improper input validation in a packet parser. The target code validates internal frame types (`frame_typep`) but this is for structured control flow, not sanitizing untrusted input. The context (internal state machine vs. network data parsing) is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 involves improper buffer bounds management in a network library, leading to potential overreads. The target code is fundamentally about safely navigating bounded memory regions (stack from `bot` to `L->base`). Both require precise pointer management to stay within valid regions. However, the target code's \"bounds\" are the stack limits and frame sizes, not generic buffers, and the flaw patterns differ (missing sentinel vs. frame logic errors).",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a buffer bounds issue in an image library due to incorrect validation of a calculated size. The target code does not perform similar arithmetic or size validations; its safety relies on correct frame pointer relationships and type checks, not buffer length calculations.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2020-16305_before_exclude_100:cc9176e7:vulspec": {
    "timestamp": "2026-01-17T01:06:03.069719",
    "cve_id": "CVE-2020-16305",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cc9176e7",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve RLE (Run-Length Encoding) processing in image libraries. The target code is an RLE *encoder* (pcx_write_rle), while CVE-2016-10050 is in an RLE *decoder*. The vulnerability type differs (target code's potential flaw is logic/overflow in encoding, historical case is buffer overflow in decoding), but the domain (image RLE handling) and the core data structure (run-length counts) are similar, providing reference for understanding RLE boundary issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-10050"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2014-9652 is about file type identification and Pascal string parsing with length validation flaws. The target code is a specific image format (PCX) RLE encoder. The functionality, data structures, and vulnerability patterns (out-of-bounds read vs. potential write/overflow in a compression loop) are fundamentally different. Little reference value.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are in image processing libraries. CVE-2017-12982 is about BMP header validation leading to allocation issues in a JPEG2000 codec. The target code is a PCX RLE encoder. The connection is tenuous: both handle binary image formats, but the specific operations (header parsing/validation vs. run-length encoding loop) and potential flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in image manipulation programs (GIMP) and involve file format plugins. CVE-2013-1978 is an out-of-bounds write in an XWD file reader due to color map validation. The target code is a PCX RLE writer. The similarity is the context (image plugin), but the specific functionality and flaw pattern (validation of counts vs. loop control in encoding) are only loosely related.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve RLE format handling in ImageMagick. CVE-2017-9144 is about improper EOF validation in an RLE *decoder*. The target code is an RLE *encoder*. The vulnerability type differs (input validation vs. output generation logic), but the shared context (RLE opcode/run processing, same library domain) makes it relevant for understanding how RLE streams can be malformed or mishandled.",
        "case_metadata": {
          "cve_id": "CVE-2017-9144"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2015-7511 is a cryptographic side-channel vulnerability in libgcrypt. The target code is a non-cryptographic image encoding routine. The domains (cryptography vs. image compression), purpose, and vulnerability classes (timing attack vs. memory corruption/logic error) are completely different. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network service daemon (MiniSSDPd) related to state management. The target code is a simple, stateless image encoding function with no dynamic memory allocation or complex state. The systems and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-1000085 is an out-of-bounds read in a file parser (ClamAV's XAR) due to size validation mismatch. The target code is an image encoder. The weak link is the pattern of processing variable-length data (compressed runs vs. decompressed XML) where calculated sizes could mismatch actual data, but the contexts are very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Highly relevant. Both involve the PCX image format in GIMP. CVE-2011-1178 is an integer overflow leading to heap overflow in the PCX *loader* (decoder). The target code is a PCX RLE *writer* (encoder). They are complementary components within the same format plugin. While the vulnerability type differs (integer overflow in size calc vs. potential logic/overflow in the encoding loop), the code patterns, data structures, and the broader context of PCX handling are nearly identical. This case provides extremely valuable reference for understanding the attack surface and potential pitfalls in the target's domain.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-1000222 is a double-free in libgd's BMP handling during error cleanup. The target code is a PCX RLE writer in what appears to be a different codebase (Ghostscript/pcl?); it performs simple file writes with no apparent dynamic memory allocation or complex error paths that would lead to double-free. The flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      }
    ]
  },
  "CVE-2020-16305_after_exclude_100:cb3879ce:vulspec": {
    "timestamp": "2026-01-17T01:06:18.449222",
    "cve_id": "CVE-2020-16305",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cb3879ce",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve RLE (Run-Length Encoding) decoding/encoding logic in image processing libraries. The target code is an RLE encoder (pcx_write_rle), while CVE-2016-10050 is in an RLE decoder. The vulnerability type differs (target is potential logic/overflow in encoder, CVE is heap overflow in decoder), but the core domain (RLE image format handling) and the need for careful bounds/run-length management are similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-10050"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2014-9652 is about improper bounds checking when parsing Pascal strings in a file identification utility. The target code is an RLE encoder for an image format. The functionality (string parsing vs. image compression), data structures, and vulnerability patterns (out-of-bounds read vs. potential overflow in loop logic) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in image processing libraries. CVE-2017-12982 involves a memory allocation failure due to unchecked header values in a BMP-to-JPEG2000 converter. The target code is a low-level RLE encoding routine. The similarity is limited to the broader domain of image format processing and the general need for input validation. The specific flaw patterns (allocation size calculation vs. run-length loop control) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in image file format handlers (GIMP plugin vs. a graphics library encoder). CVE-2013-1978 is an out-of-bounds write due to mismatched color map counts. The target code performs RLE compression. The connection is only at the high level of image format processing. The vulnerability mechanisms (header validation vs. byte stream encoding logic) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Strong domain relevance: both involve RLE format handling in ImageMagick (CVE) and a similar graphics library encoder (target). CVE-2017-9144 is about improper EOF checks before processing opcodes in an RLE decoder, leading to out-of-bounds reads. The target code is an encoder, but the core concern is similar: correctly managing the bounds of the input buffer (`from < end` checks) and the output stream during RLE operations. The vulnerability type differs (input validation vs. potential logic error in the encoder's loop), but the context is closely related.",
        "case_metadata": {
          "cve_id": "CVE-2017-9144"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library's elliptic curve implementation. The target code is a non-cryptographic, deterministic RLE encoder for an image format. The domains (cryptography vs. image compression), attack surfaces (physical measurement vs. file processing), and flaw types (timing leak vs. memory/buffer logic) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network service daemon related to state management during error handling. The target code is a simple, self-contained image encoding function with no dynamic memory allocation or complex state. There is no meaningful similarity in functionality or vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-1000085 is an out-of-bounds read in an antivirus file parser due to mismatched decompressed size. The target code is an image encoder that writes data. The only faint similarity is the need to validate sizes/bounds when processing compressed/encoded data, but the contexts (archive parsing vs. image encoding) and flaw specifics are very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. High domain relevance: both involve the PCX image file format in the GIMP/graphics library ecosystem. CVE-2011-1178 is an integer overflow leading to a heap buffer overflow in the PCX *loader*. The target code `pcx_write_rle` is likely part of the PCX *saver* or encoder. While the vulnerability direction is opposite (load vs. save), the code patterns, data structures, and the need for careful arithmetic (e.g., `(from - start) / step + 0xc1`) around image dimensions and run lengths are highly similar. Understanding flaws in one part of a format's implementation is valuable for auditing the other.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-1000222 is a double-free in libgd's BMP handling during error cleanup. The target code is a stateless RLE encoding routine that writes to a file stream and does not perform any dynamic memory allocation or freeing. The vulnerability patterns (memory ownership vs. stream writing) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      }
    ]
  },
  "CVE-2022-0382_before_exclude_100:c56f925f:vulspec": {
    "timestamp": "2026-01-17T01:06:29.606609",
    "cve_id": "CVE-2022-0382",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c56f925f",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a user-space VNC file transfer protocol. The target code is a kernel-space socket send function performing message construction and transmission with size validation (TIPC_MAX_USER_MSG_SIZE). The vulnerability types (CWE-787 vs. network message handling), domains, and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a user-space regular expression compiler due to improper NUL byte handling. The target code is a kernel networking function with no regex parsing, no character sequence processing, and a different memory model. No meaningful similarity in vulnerability patterns or code constructs.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves an out-of-bounds read in a network protocol parser (tcpdump) due to insufficient length validation. The target code also parses network message structures (tipc_uaddr) and validates lengths (tipc_uaddr_valid). Both involve protocol field validation, but the vulnerability type (CWE-125 read vs. general send path), context (user-space analyzer vs. kernel transport), and specific flaws are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow in kernel FUSE ioctl due to insufficient iovec length validation. The target code performs message size validation and uses sk_buff for data handling. Both are kernel subsystems dealing with data transfer and size checks, but the vulnerability mechanism (ioctl retry path buffer overflow vs. socket send message building) and attack surfaces (malicious FUSE server vs. network/socket input) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 5 is a NULL pointer dereference in kernel USB/IP due to insufficient validation of URB fields. The target code performs multiple validity checks (tipc_uaddr_valid, state checks) and could potentially have similar issues if `ua`, `sk`, or other pointers were NULL. Both are kernel networking subsystems where missing NULL checks on input structures could lead to crashes (CWE-476). However, the specific context (USB virtualization vs. intra-cluster messaging) and data structures differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a use-after-free in a user-space daemon due to error handling and double-free issues. The target code is a kernel function with straightforward error returns and no complex resource cleanup shown. The memory management models and vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 7 is a NULL pointer dereference in kernel CIPSO via setsockopt() due to missing NULL check on skb. The target code is also a kernel networking function (socket sendmsg) that dereferences multiple pointers (sock->sk, m->msg_name). Both involve kernel socket operations where improper validation of user-supplied or internal pointers could lead to dereference issues. The pattern of checking pointer validity before use is directly relevant, though the specific attack vector (syscall parameter vs. message data) differs.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a buffer boundary issue in kernel CIFS crypto due to scatterlist on VMAP stack. The target code uses sk_buff and message building but doesn't involve cryptographic operations or scatterlists. Both are kernel filesystem/networking code, but the specific vulnerability mechanism is not present in the target.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a race condition in kernel TTY leading to buffer overflow. The target code shows no concurrent access patterns or shared buffer writes between multiple threads. The vulnerability class (concurrency) and subsystem (character device vs. networking) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a race condition leading to NULL dereference in kernel keyring initialization. The target code is a synchronous socket send operation with no apparent shared resource initialization races. The concurrency vulnerability pattern and security subsystem context are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      }
    ]
  },
  "CVE-2022-0382_after_exclude_100:28dc77bf:vulspec": {
    "timestamp": "2026-01-17T01:06:37.834547",
    "cve_id": "CVE-2022-0382",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "28dc77bf",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol handler. The target code is a TIPC socket send function in the Linux kernel, focusing on message construction, routing, and congestion control. The domain (networking vs. remote desktop), vulnerability type (integer overflow/write vs. potential logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a user-space Perl regex compiler due to improper NUL byte handling. The target code is a kernel-space network socket send path with no regex parsing, no character sequence processing, and a completely different memory and error model. No meaningful similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a user-space packet analyzer (tcpdump) due to insufficient validation of a TLV length field from untrusted network data. While the target code also processes network data, it is within the trusted kernel path for a specific protocol (TIPC). The vulnerability class (OOB read in parser vs. potential state/logic flaws in sender) and context are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2010-4650 is a buffer overflow in the Linux kernel FUSE subsystem due to insufficient validation of iovec lengths from a userspace server. The target code is also in the Linux kernel and involves message construction, but for an inter-process communication protocol (TIPC). Both deal with data copying and size validation (`dlen > TIPC_MAX_USER_MSG_SIZE`), but the attack surface (local FUSE server vs. local/remote TIPC socket), vulnerability mechanism (iovec overflow vs. potential message handling flaws), and subsystem are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. CVE-2017-16914 is a NULL pointer dereference in the Linux kernel USB/IP subsystem due to insufficient validation of URB fields from network data. The target code is also a Linux kernel networking subsystem (TIPC) function that validates input (`tipc_uaddr_valid`) and handles various error paths. Both involve kernel modules processing protocol data where missing validation of internal state or fields could lead to crashes. However, the specific vulnerability pattern (NULL deref from network data) is not immediately evident in the target code's structure.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-10154 is a use-after-free in a user-space SSDP daemon related to error handling and memory management. The target code is a kernel function with straightforward resource management (sk_buff queues). The memory models, error paths, and likelihood of UAF are vastly different. No significant similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2013-0310 is a NULL pointer dereference in the Linux kernel CIPSO/IPv4 subsystem triggered via the `setsockopt()` syscall path due to missing validation of a `skb` parameter. The target code is also a Linux kernel socket operation (`sendmsg` syscall path) that performs several validation checks (e.g., `tipc_uaddr_valid`, state checks). Both are in the kernel networking stack and highlight the importance of validating all parameters and internal state in syscall contexts to avoid kernel crashes. The relevance is moderate because the specific flaw pattern (NULL skb) isn't present, but the domain and defensive programming mindset are aligned.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-10154 is a buffer access issue in the Linux kernel CIFS subsystem related to improper scatterlist use with VMAP stack. The target code uses `msg_build` and sk_buff queues but does not involve direct crypto scatterlist operations. Both are in the kernel, but the vulnerability mechanism is not similar. The weak relevance comes from both being kernel network-related modules where data copying occurs.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2014-0196 is a race condition in the kernel TTY subsystem leading to buffer overflow. The target code shows no evidence of shared resource concurrency issues (like lock-free manipulation of shared buffers between a workqueue and process context). The function appears to run in process context for a single socket operation. Vulnerability type and patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-1792 is a race condition leading to a NULL pointer dereference during keyring initialization in the kernel security subsystem. The target code is a synchronous socket send operation with no apparent shared global state subject to a similar initialization race. The subsystems and concurrency patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      }
    ]
  },
  "CVE-2019-3813_before_exclude_100:4c97e0ce:vulspec": {
    "timestamp": "2026-01-17T01:06:50.492787",
    "cve_id": "CVE-2019-3813",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4c97e0ce",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code performs memory slot validation and address translation in a virtualization component. The domains (regex parsing vs. virtual memory management), vulnerability types (CWE-125 vs. potential bounds/validation issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves an out-of-bounds write due to integer overflow in a VNC file transfer component. The target code also performs bounds checking (e.g., checking group_id and slot_id) and could be susceptible to similar integer handling flaws if the validation logic is flawed. Both involve input validation for memory access, but the specific vulnerability pattern (integer overflow leading to heap corruption) is not directly evident in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a disk image inspection library triggered by error handling paths. The target code is a memory mapping function that returns pointers and has multiple error return paths (NULL). While both have error paths, the core flaw (double free) and the domain (file parsing vs. address translation) are not similar. The target code does not show explicit memory deallocation.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon related to error handling and state management. The target code performs lookups in a slot table and returns a calculated virtual address. There is no apparent dynamic memory allocation/free cycle in the snippet that could lead to a use-after-free. The domains and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double-free in an antivirus VBA parser. Similar to case 3, the flaw relates to memory ownership and error handling in a file parsing context. The target code's functionality (memory slot translation) and structure (straight-line validation and calculation) do not mirror the complex state management typical of parser error paths where double-frees occur.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2010-1311 involves improper input validation (CWE-20) leading to out-of-bounds write during archive decompression. The target code is heavily focused on input validation (checking group_id, slot_id, generation) to prevent invalid memory access. The core security theme is similar: validating derived indices/offsets before using them to access memory/data structures. However, the specific context (compression window vs. memory slot table) and flaw consequence differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a kernel filesystem's ID management. The target code shows no evidence of concurrency (no locks, atomic operations). It is a simple function that reads from a table. The vulnerability types (CWE-362 vs. potential bounds/validation issues) and code patterns (sequential lookup vs. concurrent list management) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2011-3601 involves improper bounds checking (CWE-119) where a negative length leads to out-of-bounds access. The target code performs multiple bounds checks (e.g., `group_id > info->num_memslots_groups`, `slot_id > info->num_memslots`). The security pattern is directly comparable: validating user/input-controlled indices against array sizes. A key similarity is the use of `>` instead of `>=` for bounds checking, which is correct in the target code but is a common flaw. The context differs (network protocol vs. internal VM interface), but the validation logic is highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read in an image file parser due to missing string termination checks. The target code does not parse external file data or strings. It works with internal numerical addresses and indices. The vulnerability root cause (trusting external data structure fields) and domain are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-16914 is a NULL pointer dereference due to insufficient validation of packet fields. The target code also performs validation (checking pointers in `info`, checking array bounds) and could potentially dereference a NULL pointer if `info` or `info->mem_slots` were NULL, but the code assumes these are valid. The common theme is validating input/structure fields before use. However, the specific flaw pattern (dereferencing a field that should have been validated) is more indirect here, and the domains (USB/IP vs. VM memory) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      }
    ]
  },
  "CVE-2019-3813_after_exclude_100:30ecb4a2:vulspec": {
    "timestamp": "2026-01-17T01:07:41.886502",
    "cve_id": "CVE-2019-3813",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "30ecb4a2",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a memory slot virtualization function performing bounds and generation checks. The domain (regex parsing vs. virtual device memory management), vulnerability type (OOB read vs. potential OOB access/validation flaws), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves integer overflow/wraparound leading to OOB write in a VNC file transfer. The target code performs array index and size validation (group_id, slot_id, add_size via memslot_validate_virt). There is a tangential similarity in the need for careful integer/bounds validation when calculating offsets (h_virt += slot->address_delta) and checking sizes, but the context (network protocol vs. internal memory mapping) and specific flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double free in a file reading function. The target code allocates no memory and returns a calculated pointer; it manages no dynamic resources that could be double-freed. The flaw patterns (memory ownership, cleanup paths) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free due to uninitialized pointers and error handling in a network daemon. The target code operates on pre-initialized slot structures within a RedMemSlotInfo. There is no dynamic allocation/free of the primary objects being accessed within this function, making use-after-free patterns irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double free in an antivirus file parser. Similar to case 3, the target code's functionality is pointer calculation and validation, not resource allocation and deallocation. The error paths return NULL but do not free any resources owned by the function.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2010-1311 involves improper input validation leading to memory corruption (OOB write) in a decompression module. The target code's core purpose is input validation (indices, generation, virtual address range). The pattern of validating attacker-controlled or untrusted inputs (addr, add_size, group_id) against internal state (info arrays, slot->generation) is conceptually similar. However, the specific vulnerability mechanism (window buffer overflow vs. index/generation mismatch) and domain differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition in a kernel filesystem's ID management. The target code shows no explicit concurrency control (no locks, atomics). While the data structures (info->mem_slots) could theoretically be subject to races if accessed concurrently, the code pattern itself does not exhibit the classic non-atomic check-then-use flaw. The relevance is limited to the shared concept of managing indexed resources (slots vs. node IDs).",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2011-3601 is a buffer overflow due to improper bounds checking of network data. The target code performs multiple bounds checks (group_id, slot_id, and memslot_validate_virt for h_virt+add_size). The code pattern of validating indices before array access and checking a calculated offset against size limits is directly analogous to preventing buffer overflows/OOB accesses. The main differences are the context (network parser vs. internal memory mapper) and the fact the target code's checks appear robust, whereas the CVE had a missing check for negative values.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read in an image file parser due to missing string termination checks. The target code does not parse string data from external sources. Its validation is on numerical indices and offsets. The flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-16914 is a NULL pointer dereference due to insufficient validation of packet fields. The target code validates several inputs and could return NULL if checks fail, but it does not dereference a pointer that has been passed in and could be NULL (it accesses array elements based on validated indices). A vague similarity exists in the defensive programming pattern of validating inputs before use, but the specific NULL-deref flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      }
    ]
  },
  "CVE-2022-1507_before_exclude_100:6bcc844a:vulspec": {
    "timestamp": "2026-01-17T01:07:58.326593",
    "cve_id": "CVE-2022-1507",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6bcc844a",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve GIF parsing libraries (PHP's GD vs. target GIF decoder). The core vulnerability in CVE-2018-5711 is integer signedness confusion in color map processing, which is a pattern that could be relevant to the target code's handling of `colour_table_size` (derived from flags) and array indexing. The attack surface (malformed GIF files) and domain are identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network service discovery daemon (MiniSSDPd). The target code is a GIF image decoder with no network parsing, different memory management patterns, and a completely different functional domain. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. The target code is a binary GIF decoder that does not process NUL-terminated strings in a similar way. The vulnerability patterns and data types are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow in OpenJPEG due to insufficient padding allocation. The target code allocates frame buffers via callback (`bitmap_get_buffer`) and performs writes within calculated bounds. The similarity is in image codec memory management, but the specific flaw (padding calculation) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance, approaching high relevance. CVE-2011-2896 is an out-of-bounds write in GIMP's GIF loader during LZW decompression, specifically due to insufficient bounds checking when pushing values onto the decompression stack. The target code contains an almost identical LZW decompression loop with a `stack_pos` and `stack_base`. It uses `burst_bytes` to control writes but relies on `lzw_decode` to manage the stack safely. The vulnerability type, trigger conditions (malformed LZW stream), and code patterns are highly similar, making this a very valuable reference for auditing the target's LZW logic.",
        "case_metadata": {
          "cve_id": "CVE-2011-2896"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2 due to improper buffer management during multi-byte character processing. The target code processes binary GIF data, not text/XML with character encodings. The flaw patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-17784 is an out-of-bounds read in GIMP's GBR brush loader due to invalid UTF-8 processing. The target code does not process UTF-8 strings. The only tangential similarity is that both are image/brush file parsers within GIMP-related codebases, but the vulnerability mechanism is not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-17784"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2013-1978 is an out-of-bounds write in GIMP's XWD loader due to insufficient validation between color count and color map entries. The target code also processes color tables (local and global) with a size derived from user data (`colour_table_size`). It validates `gif_bytes` against `3 * colour_table_size` before reading, which is a similar validation pattern. The domain (image color map handling) and potential flaw type (insufficient validation leading to OOB write) are similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2012-5854 is a heap buffer overflow in an IRC client's color code decoder due to unsafe string concatenation and buffer growth. The target code is a binary image decoder with no string processing or dynamic buffer growth of that nature. The vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      }
    ]
  },
  "CVE-2022-1507_after_exclude_100:efc03026:vulspec": {
    "timestamp": "2026-01-17T01:08:17.390867",
    "cve_id": "CVE-2022-1507",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "efc03026",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. Both involve GIF parsing vulnerabilities in image processing libraries. The target code is a GIF decoder with LZW decompression, similar to PHP's GD library in CVE-2018-5711. Both handle color tables, frame data, and LZW decoding. The vulnerability patterns (integer handling, bounds checking during decompression) are nearly identical. The attack surface (malformed GIF files) and functional domain are the same.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is in a network service discovery daemon (MiniSSDPd) involving use-after-free and memory management errors. The target code is a GIF image decoder with no network functionality and different memory patterns (no dynamic allocation/free of structures in the shown path). Different domain, attack surface, and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve potential integer overflows in parsing external data (CVE-2018-20750 in VNC file transfer, target in GIF dimensions/offsets). However, the domains differ significantly (remote desktop protocol vs. image format). The target code has bounds checks on width/height (offset_x + width > gif->width), reducing similarity. Different primary vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is in a Perl regex engine involving NUL byte handling and out-of-bounds reads. The target code is a binary GIF parser that doesn't process string patterns or Unicode. Different data types, parsing models, and vulnerability mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in image codecs (OpenJPEG vs. GIF decoder) and involve buffer management. CVE-2017-14151 is a buffer overflow due to insufficient padding calculation. The target code has buffer operations (memory, memset) but the vulnerability pattern (padding calculation error) is not evident. Some reference value for image parser memory safety.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 10,
        "reasoning": "Highly relevant, almost identical. Both are GIF decoders in image manipulation software (GIMP's file-gif-load.c vs. this GIF decoder). Both implement LZW decompression with stack operations. CVE-2011-2896 involves out-of-bounds write during LZW stack pushing - the target code has similar \"stack_pos\" and \"stack_base\" pointers with burst operations. The vulnerability type, trigger conditions (malformed LZW stream), and code patterns are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2011-2896"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1833 is in an XML parser (libxml2) involving character encoding and out-of-bounds reads. The target code is a binary GIF format parser with different parsing model (structured binary vs. text/encoding). Different attack surfaces and vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are in image file parsers (GIMP brush vs. GIF). CVE-2017-17784 involves UTF-8 validation leading to out-of-bounds read. The target code doesn't process UTF-8 strings. Some similarity in file format parsing domain but different vulnerability mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2017-17784"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are image file parsers (XWD vs. GIF) in GIMP-related code. CVE-2013-1978 involves out-of-bounds write due to color map validation issues. The target code also processes color tables (local/global) with size validation. Similar patterns in color table handling and bounds checking, though specific vulnerability differs.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2012-5854 is in an IRC client's text formatting decoder involving heap buffer overflow during string concatenation. The target code is a binary image decoder with different data processing patterns (pixel buffers vs. text strings). Different domains and vulnerability mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      }
    ]
  },
  "CVE-2021-3416_before_exclude_100:7997e511:vulspec": {
    "timestamp": "2026-01-17T01:08:33.016580",
    "cve_id": "CVE-2021-3416",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7997e511",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression parser due to improper NUL byte handling. The target code is a network packet transmission function in an emulated Ethernet controller, dealing with DMA descriptors and packet assembly. The domains (parsing vs. network I/O), vulnerability types (string parsing OOB read vs. potential buffer overflow/validation issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 involves an integer overflow leading to an out-of-bounds write in a network protocol handler (VNC file transfer). The target code also handles network data and performs size calculations (e.g., checking `tx_desc_get_length(desc)` against available buffer space). There is a conceptual similarity in validating lengths from untrusted descriptors/clients to prevent buffer overflows. However, the specific vulnerability mechanism (integer overflow in allocation) and context (user-space library vs. kernel/QEMU emulation) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves a buffer overflow in a network protocol parser (IPv6 RA) due to insufficient validation of a length field (negative value). The target code validates descriptor lengths (`tx_desc_get_length(desc)`) against a maximum buffer size. Both involve parsing untrusted network/descriptor data and checking bounds. The key difference is the source of the malicious data (external network packet vs. guest-controlled DMA memory) and the specific flaw (negative length bypassing check vs. missing or incorrect validation).",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a NULL pointer dereference in a USB/IP driver due to inconsistent state (null buffer with positive length). The target code checks for zero buffer address and zero length in descriptors. Both perform some validation on data fields from an external source (USB request vs. DMA descriptor). However, the core vulnerability pattern (dereferencing a null pointer) is not present in the target code, which uses `address_space_read/write` functions that likely handle address translation safely.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves a buffer overflow due to insufficient validation of aggregated iovec lengths in a FUSE driver. The target code aggregates packet data from multiple descriptors into a single buffer (`s->tx_packet`) and checks the total length against `gem_get_max_buf_len`. Both involve combining multiple data chunks into a contiguous buffer with a total size check. The relevance is limited because the target code's check appears robust (subtraction for remaining space), and the attack vector (malicious guest driver vs. malicious userspace server) differs.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference during USB driver initialization due to missing endpoint validation. The target code does not initialize hardware or parse USB descriptors. Both involve device driver code, but the functionality and vulnerability patterns (missing validation of hardware descriptors vs. validation of software DMA descriptors) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in a network protocol dissector (tcpdump) due to missing length validation before reading a field. The target code reads fields from DMA descriptors (like length) and uses them in calculations and memory operations. Both involve parsing untrusted data structures and relying on length fields. The relevance is weak because the target code validates the length before use (in the `if (tx_desc_get_length(desc) > gem_get_max_buf_len(...))` check), whereas the vulnerability case lacks such validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 involves a buffer overflow in an NFC driver due to copying frame data without validating a length field. The target code reads packet data from a guest-controlled DMA address (`tx_desc_get_buffer(s, desc)`) using a guest-controlled length (`tx_desc_get_length(desc)`). This is a very similar pattern: an external entity (guest) supplies a base pointer and length, and the host/emulator performs a memory read. The target code has a crucial length check against `gem_get_max_buf_len`, which, if incorrect or missing, could lead to a similar buffer overflow. The context (kernel NFC vs. QEMU emulation) differs, but the core pattern of trusting guest-supplied pointer/length pairs is highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a race condition in a filesystem's node ID management. The target function `gem_transmit` is not obviously re-entrant and operates on per-queue state, but there is no indication of concurrent access or the complex state management issues leading to a race condition. The domains (concurrency in FS metadata vs. network packet transmission) and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a double-free in a file content reading function due to error path issues. The target code does not dynamically allocate or free memory within the shown function; it uses a pre-allocated buffer (`s->tx_packet`). The vulnerability patterns (memory management bugs vs. buffer boundary validation) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2021-3416_after_exclude_100:19e24b34:vulspec": {
    "timestamp": "2026-01-17T01:08:38.885021",
    "cve_id": "CVE-2021-3416",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "19e24b34",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression parser due to improper NUL byte handling. The target code is a network device emulator handling DMA descriptors and packet transmission. The domain (regex parsing vs. network driver), vulnerability type (string parsing flaw vs. potential memory/bounds issues in descriptor handling), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write in a network protocol handler (VNC file transfer). The target code also handles network data and performs length checks (e.g., checking `tx_desc_get_length(desc)` against buffer space). There is a conceptual similarity in validating lengths from untrusted descriptors/clients to prevent buffer overflows, but the specific vulnerability pattern (integer overflow in allocation) is not directly evident in the target code's arithmetic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-3601 involves a buffer overflow in a network protocol parser (IPv6 RA) due to insufficient validation of a length field (negative value). The target code validates descriptor lengths against a maximum buffer size (`gem_get_max_buf_len`). The similarity lies in the need to validate attacker-controlled length fields from an external source (network packet vs. DMA descriptor). However, the target code's validation appears more robust, and the specific flaw (negative length) is prevented by using unsigned types.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-16914 is a NULL pointer dereference in a USB/IP driver due to inconsistent state validation. The target code checks for NULL or zero buffer addresses (`tx_desc_get_buffer(s, desc) == 0`) and lengths, which shows a similar defensive pattern. However, the core vulnerability type (NULL deref from protocol state mismatch) and domain (USB virtualization vs. Ethernet MAC emulation) are different. The target code's checks mitigate a similar class of issue but are not the central flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2010-4650 is a buffer overflow in a kernel FUSE driver due to insufficient validation of iovec lengths aggregated from userspace. The target code aggregates packet data from multiple DMA descriptors into a single buffer (`s->tx_packet`) with a total length check. The pattern of aggregating multiple data chunks with a total size limit is similar. However, the attack vector (malicious userspace server vs. malicious guest DMA descriptors) and subsystem (filesystem vs. device emulation) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3137 is a NULL pointer dereference during USB driver initialization due to missing endpoint validation. The target code does not involve USB or hardware descriptor probing. The only faint similarity is the general principle of validating hardware/descriptor fields before use, which the target code does for buffer addresses and lengths.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13054 is an out-of-bounds read in a packet dissector (tcpdump) due to missing length validation before reading a field. The target code reads data from DMA memory based on descriptor fields but includes length validation against a maximum. The domains (packet analysis vs. device emulation) and code patterns are dissimilar, though both involve parsing untrusted binary data.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2012-3364 is a buffer overflow in an NFC kernel driver due to copying frame data without proper length validation. The target code reads packet data from a guest-controlled DMA address (`tx_desc_get_buffer(s, desc)`) with a length (`tx_desc_get_length(desc)`) into a fixed-size host buffer (`s->tx_packet`), but it performs a critical length check against remaining space. The pattern is very similar: copy operation from untrusted source with length validation. The target code's check appears correct, making this a valuable reference for what could go wrong if such checks were missing or flawed.",
        "case_metadata": {
          "cve_id": "CVE-2012-3364"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a filesystem's node ID management. The target function `gem_transmit` is a synchronous packet processing loop without obvious concurrency or resource management races within the function itself. The domains and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free in a library for inspecting disk images, related to error handling and memory ownership. The target code performs simple DMA reads/writes and packet transmission with linear control flow and no dynamic memory allocation/freeing in the shown path. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2022-24950_before_exclude_100:9d93cf84:vulspec": {
    "timestamp": "2026-01-17T01:09:16.149717",
    "cve_id": "CVE-2022-24950",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9d93cf84",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a simple Unix domain socket setup with no complex integer arithmetic, memory allocation, or protocol parsing that could lead to similar issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds write in an image processing library due to insufficient buffer validation. The target code performs basic socket operations and file permission setting with no buffer manipulation or image format parsing.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 involves improper permission handling and privilege escalation in Exim. The target code uses `chmod` to set permissions on a Unix socket path. While the vulnerability mechanisms differ (file descriptor inheritance vs. socket file permissions), both involve security-critical permission management on Unix filesystem objects. The target code's `chmod` call with fixed permissions (0700) is safer but shares the domain of filesystem permission security.",
        "case_metadata": {
          "cve_id": "CVE-2010-4345"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a use-after-free vulnerability in a network daemon's state management. The target code uses simple STL containers (set, map) and RAII patterns (lock_guard) with no dynamic memory management of pointers that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 involves improper error handling in privilege separation leading to unnecessary privilege retention. The target code uses `FATAL_FAIL` macros which likely terminate on failure, reducing similar risks. However, both involve security-sensitive initialization (socket binding vs. privilege dropping) where error handling is critical. The pattern of checking for existing state (`pipeServerSockets.find()`) before proceeding is a defensive practice relevant to both.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a double-free vulnerability in a Python C extension due to improper reference counting. The target code is C++ with RAII and no manual memory management or reference counting that could lead to similar issues.",
        "case_metadata": {
          "cve_id": "CVE-2019-18874"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in an image file parser. The target code uses `strcpy` on a fixed-size stack buffer (`local.sun_path`), which could be a buffer overflow if `pipePath` is too long, but this is different from file format parsing vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an integer overflow in a filesystem parser. The target code performs simple arithmetic only in `sizeof()` operations with no user-controlled integer calculations that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a numeric conversion error in an archive library. The target code uses standard system calls with fixed parameters and no numeric type conversions of user-controlled data.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a memory corruption vulnerability due to improper error handling when malloc fails. The target code uses STL containers which handle allocation internally, and system calls where failure is checked by `FATAL_FAIL`.",
        "case_metadata": {
          "cve_id": "CVE-2017-6435"
        }
      }
    ]
  },
  "CVE-2022-24950_after_exclude_100:fe35bf74:vulspec": {
    "timestamp": "2026-01-17T01:09:43.471948",
    "cve_id": "CVE-2022-24950",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "fe35bf74",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a simple Unix domain socket setup with no complex integer calculations, memory allocations, or protocol parsing that could lead to similar issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves buffer overflow in image format processing. The target code performs basic socket operations with fixed-size structures (sockaddr_un) and uses strncpy with proper bounds checking via sizeof(). No image parsing or dynamic buffer handling exists.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 involves privilege/permission issues in Exim. The target code includes chmod() call to set permissions on the Unix socket path. While not identical (Exim's issue involves file descriptor inheritance), both deal with file system permissions and security of created resources. The pattern of setting permissions on a created resource is similar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4345"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 involves use-after-free in a service discovery daemon. The target code uses RAII patterns (lock_guard) and simple container operations. No dynamic memory allocation or pointer management that could lead to use-after-free is present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves improper privilege handling during daemon initialization. The target code doesn't show privilege dropping but does involve creating system resources (Unix sockets) that require proper permissions. Both touch on security of daemon/service resources, but the specific vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves double-free in Python reference counting. The target code is C++ with RAII patterns and standard containers. No manual memory management, reference counting, or similar error-prone patterns are present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2019-18874"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves out-of-bounds read in image file parsing. The target code performs basic string copying with bounds checking and socket operations. No file format parsing or complex data structure processing exists.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves integer overflow in filesystem image parsing. The target code uses fixed-size buffers and simple arithmetic. No complex calculations or parsing of untrusted binary structures that could trigger integer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves numeric conversion errors in archive writing. The target code uses size_t and fixed buffer sizes with no complex numeric conversions. The strncpy uses sizeof() which provides compile-time bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves improper error handling after malloc failure in a parser. The target code uses FATAL_FAIL macro (likely terminating on errors) and doesn't perform dynamic memory allocation in the shown code path. Error handling patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-6435"
        }
      }
    ]
  },
  "CVE-2012-3517_after_exclude_100:5d32c165:vulspec": {
    "timestamp": "2026-01-17T01:10:08.033327",
    "cve_id": "CVE-2012-3517",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5d32c165",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves integer overflow leading to heap corruption in a file transfer protocol. The target code performs extensive integer parsing with bounds checking (tor_parse_long with min/max bounds) and does not have similar arithmetic operations that could overflow. Both handle network protocols, but the vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 2 involves out-of-bounds read in DNS record parsing due to insufficient validation. The target code also parses network protocol data (Tor networkstatus) and performs bounds checking (e.g., HEX_DIGEST_LEN validation, base16_decode length checks). However, the target code appears more robust with explicit length validation, making the vulnerability pattern less similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-1000381"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves out-of-bounds read in regex processing due to NUL byte handling. The target code parses structured text but uses tokenization with explicit length tracking and doesn't process regex patterns. Both involve parsing, but the mechanisms and vulnerability patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 involves double free in VBA parsing during error conditions. The target code has extensive error handling with goto err patterns that free resources, but uses a centralized cleanup approach. No evidence of double free patterns in the shown code section.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 involves out-of-bounds read in protocol TLV parsing due to insufficient length validation. The target code parses Tor networkstatus with similar token-based parsing and includes length validation (e.g., object_size checks). However, the target code's validation appears more comprehensive with explicit bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves use-after-free due to uninitialized pointers and inconsistent state management. The target code initializes structures with tor_malloc_zero and has structured cleanup. The error handling patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 involves out-of-bounds read in XML end tag parsing. The target code parses structured text with tokenization and includes bounds checking. Both involve parsing hierarchical structures, but the vulnerability patterns in XML vs. Tor protocol parsing differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves heap buffer overflow due to insufficient buffer growth strategy in IRC color decoding. The target code uses smartlists for dynamic arrays and doesn't show similar string concatenation patterns. The memory management approaches are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 involves integer overflow in SSH packet validation leading to out-of-bounds read. The target code performs integer parsing with bounds checking (tor_parse_long) and has similar protocol validation logic. Both handle network protocol messages with length fields, though the specific overflow pattern isn't evident in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 involves out-of-bounds read in XML character encoding processing. The target code handles base16 decoding with length validation and parses structured text. Both involve careful buffer management during parsing operations, but the encoding processing differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2012-3517_before_exclude_100:298c3182:vulspec": {
    "timestamp": "2026-01-17T01:10:10.737378",
    "cve_id": "CVE-2012-3517",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "298c3182",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to heap corruption in a VNC file transfer protocol. The target code is a Tor network status parser that performs extensive string parsing, tokenization, and signature validation. The vulnerability types (CWE-787 vs. parsing logic errors), attack surfaces (binary file transfer vs. text-based directory protocol), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is an out-of-bounds read in a DNS NAPTR record parser due to insufficient validation of record structure. The target code also parses structured text (network status votes) and validates fields (digests, lengths, times). Both involve parsing untrusted network data with validation, but the specific vulnerability pattern (buffer bounds check bypass in binary DNS vs. comprehensive text tokenization in Tor) and domain are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-1000381"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is an out-of-bounds read in a Perl regex compiler due to improper NUL byte handling. The target code uses `strcmpstart`, `strstr`, and other string functions that are NUL-terminated, but its primary logic is structured token parsing with explicit length checks (e.g., `HEX_DIGEST_LEN`, `tok->object_size`). Both process string input, but the vulnerability mechanism (embedded NULs breaking string logic) is not a prominent pattern in the target code's validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a double-free in a ClamAV VBA extractor during error handling. The target code has extensive error handling with `goto err` and cleanup of allocated structures (`networkstatus_vote_free`, `memarea_drop_all`). While both manage memory, the target code's cleanup appears consistent (freeing on error paths), and the vulnerability pattern (double-free due to inconsistent state) is not directly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 is an out-of-bounds read in tcpdump's LDP parser due to insufficient TLV length validation. The target code validates lengths (e.g., `HEX_DIGEST_LEN`, `tok->object_size` checks) and performs bounds checks (e.g., `tok->object_size >= INT_MAX`). Both parse protocol data with length fields, but the target code's validation is more extensive and the context (passive analyzer vs. active protocol participant) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a use-after-free in a service daemon due to uninitialized pointers and error path issues. The target code allocates structures (`tor_malloc_zero`) and has clean error paths. While both involve resource management, the specific flaw pattern (uninitialized struct members leading to UAF) is not evident in the target code, which zero-initializes and carefully frees resources.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in libxml2's end-tag parser due to insufficient bounds checking. The target code parses a text-based protocol and validates buffer accesses via tokenization and length checks. Both are parsers, but the target code uses a tokenization layer that abstracts raw buffer access, making direct buffer over-reads less likely compared to the raw pointer arithmetic in libxml2.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a heap buffer overflow in an IRC client due to unsafe string concatenation and insufficient buffer growth calculation. The target code primarily uses fixed-size buffers for digests and dynamic allocation via `tor_strdup`/`smartlist_add`. It does not exhibit the same pattern of incremental string building in a fixed buffer that leads to overflow.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is an integer overflow in an SSH library leading to an out-of-bounds read. The target code uses `tor_parse_long` with bounds checking (e.g., `0, INT_MAX`, `0, 65535`) and validates digest lengths. Both involve parsing network data with integer fields, but the target code's use of safe parsing functions and explicit bounds reduces integer overflow risk. The similarity is in the domain of protocol parsing with numeric validation.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an out-of-bounds read in libxml2 due to inadequate bounds checking during multi-byte character processing. The target code handles hex decoding (`base16_decode`) and string operations, but does not involve complex character encoding transformations. Both parse text data, but the vulnerability mechanism (encoding-specific buffer misalignment) is not applicable to the target code's ASCII/hex-focused processing.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2021-43804_before_exclude_100:32a4bcbb:vulspec": {
    "timestamp": "2026-01-17T01:10:25.164080",
    "cve_id": "CVE-2021-43804",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "32a4bcbb",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 1 involves an integer overflow leading to out-of-bounds write during memory allocation. The target code performs a bounds check using PJ_MIN and a direct memory copy, but does not involve dynamic memory allocation or integer overflow/wraparound in the same way. The core vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is an out-of-bounds read due to improper NUL byte handling in a regex engine. The target code involves copying a length-specified string from a network packet. While both involve bounds checking, the domain (regex parsing vs. network protocol parsing), data source, and specific flaw (NUL byte vs. length field validation) are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a race condition in the Linux kernel TTY subsystem leading to concurrent buffer overflow. The target code is a simple, synchronous RTCP packet parsing function with no concurrency, shared resources, or complex state management. The vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a NULL pointer dereference in a USB/IP kernel module due to insufficient validation of URB fields. The target code does not dereference pointers from the packet data itself; it uses the packet as a byte buffer. The code patterns and attack surfaces (network protocol vs. kernel driver) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 5 is an out-of-bounds read in a network protocol parser (tcpdump's LDP) due to insufficient validation of a length field. The target code is also a network protocol parser (RTCP) that reads a length field from a packet (`*((pj_uint8_t*)pkt+8)`) and uses it in a memory copy operation. Both involve the core pattern of trusting an attacker-controlled length from a packet. However, the target code uses PJ_MIN to bound the copy, which mitigates the risk, making it less directly vulnerable than the historical case.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference in a USB driver due to missing validation of hardware descriptors. The target code operates on network data, not hardware structures, and does not exhibit the same pattern of missing checks for essential data structures before access.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a use-after-free caused by complex error handling and state management in a daemon. The target code is a simple, straight-line parsing function with no dynamic memory allocation or deallocation, and thus no possibility of use-after-free in its current form.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 involves improper state management and exceptional condition handling in a complex network protocol state machine (SCTP). The target code has no state machine, no temporary resource management, and a very simple operational flow, making the vulnerability patterns irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-2206"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a NULL pointer dereference in a kernel socket option handler due to a missing NULL check for a parameter. The target code receives a non-NULL packet buffer (`pkt`) and does not perform function calls that could return NULL in a dangerous context. The code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a race condition in a filesystem's metadata management. The target code is a single-threaded packet parsing routine with no shared data structures, locks, or atomicity concerns. The concurrency flaw category does not apply.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2021-43804_after_exclude_100:ce32e76d:vulspec": {
    "timestamp": "2026-01-17T01:10:48.893224",
    "cve_id": "CVE-2021-43804",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ce32e76d",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 1 involves an integer overflow/wraparound leading to out-of-bounds write during memory allocation. The target code performs bounds checking using PJ_MIN to prevent overflow, but both involve careful validation of size fields from network packets. The vulnerability patterns (CWE-190/787 vs. potential CWE-125/126) and trigger conditions differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 2 involves an out-of-bounds read due to improper handling of embedded NUL bytes. The target code reads a length field from a network packet and uses it for a memory copy operation, which is a similar pattern of trusting external input. However, the target code performs bounds checking, making it more robust than the vulnerable case.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is a race condition in the Linux kernel TTY subsystem leading to buffer overflow. The target code is a simple RTCP packet parser without concurrency concerns. The vulnerability types (CWE-362 vs. potential buffer issues) and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 involves a NULL pointer dereference due to insufficient validation of URB fields. The target code dereferences the `pkt` pointer without explicit NULL checks, which is a minor similarity. However, the context (network packet parsing vs. USB request processing) and vulnerability patterns differ substantially.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 5 involves an out-of-bounds read in a network protocol parser (tcpdump's LDP parser) due to insufficient validation of a length field. The target code is also a network protocol parser (RTCP) that reads a length field from a packet and performs bounds checking. The code patterns are similar, though the target code appears to have better validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 involves a NULL pointer dereference in a USB driver due to missing endpoint validation. The target code deals with network packet parsing, not USB device drivers. The vulnerability patterns and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 involves a use-after-free vulnerability in a service discovery daemon due to memory management errors. The target code performs simple packet parsing with stack/local buffer operations, not dynamic memory management. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 involves improper state management and exceptional condition handling in SCTP protocol processing. The target code is a simpler packet parser with less complex state. Both involve network protocol processing, but the vulnerability patterns (CWE-703 vs. potential buffer issues) differ.",
        "case_metadata": {
          "cve_id": "CVE-2013-2206"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 involves a NULL pointer dereference in kernel CIPSO validation due to missing parameter checks. The target code dereferences the `pkt` pointer without explicit NULL checks, which is a minor similarity. However, the contexts (kernel vs. user-space library) and attack surfaces differ.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 involves a race condition in a filesystem's node ID management. The target code is a simple packet parser without concurrency or complex state management. The vulnerability patterns and code structures are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2021-46784_before_exclude_100:3e2a008b:vulspec": {
    "timestamp": "2026-01-17T01:11:32.972004",
    "cve_id": "CVE-2021-46784",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3e2a008b",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1833 involves an out-of-bounds read in an XML parser due to improper multi-byte character handling. The target code is a Gopher-to-HTML converter that processes line-based text with explicit bounds checks (e.g., `gopherState->len + llen >= TEMP_BUF_SIZE`). The vulnerability type (CWE-125), domain (parsing), and attack patterns (character encoding) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to embedded NUL bytes. The target code uses `memchr` and string operations (`strchr`, `strtok`) on input buffers but does not compile or execute regex patterns. The core flaw (CWE-125 via NUL byte mishandling) and functional domain are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in memory allocation. The target code uses fixed-size buffers (`TEMP_BUF_SIZE`) and `snprintf` with size limits, avoiding dynamic allocation for the vulnerable paths. While both involve buffer management, the vulnerability mechanism (CWE-787 via CWE-190) and context (network protocol parsing vs. text conversion) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1838 is an out-of-bounds read in an XML end-tag parser. The target code processes Gopher menu lines, not hierarchical XML tags. Both parse structured text, but the vulnerability type (CWE-125), data format (XML vs. tab-separated Gopher lines), and parsing logic are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code parses Gopher lines but does not use Type-Length-Value structures. Both parse network-derived data, but the vulnerability pattern (CWE-125 from missing length checks) does not align with the target's line-based, delimiter-driven parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1835 is a use-after-free in an XML attribute parser. The target code uses stack-allocated buffers (`LOCAL_ARRAY`) and careful copying; it does not dynamically allocate and free the sensitive data structures (like `escaped_selector` is freed immediately). The vulnerability class (CWE-416) and domain (XML SAX parsing) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a daemon due to uninitialized pointers and error handling. The target code is a conversion function with straightforward control flow and no complex resource management or error paths that could leave pointers dangling. The vulnerability pattern (CWE-416) and system context (daemon vs. library function) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20760 is an out-of-bounds write due to improper error handling in a text encoding converter. The target code also performs text processing and uses `snprintf` into fixed buffers. While the vulnerability type (CWE-787) differs, both involve converting/formatting text from one protocol to another. The target's explicit size checks reduce similarity, but the functional domain (text conversion) provides some reference value for safe buffer usage.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1836 is a use-after-free in an XML name parser due to buffer reallocation. The target code uses fixed-size local arrays and does not reallocate buffers during parsing. The vulnerability mechanism (CWE-416 from reallocation) and data complexity (XML names vs. simple Gopher lines) are not present in the target.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to insufficient padding allocation in an image codec. The target code has explicit buffer size checks (`TEMP_BUF_SIZE`) and uses bounded functions (`snprintf`). Both involve writing formatted output to buffers, but the vulnerability root cause (CWE-119 via calculation error vs. target's careful size limiting) and domain (image encoding vs. text conversion) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2021-46784_after_exclude_100:2f6dc6bc:vulspec": {
    "timestamp": "2026-01-17T01:12:04.163800",
    "cve_id": "CVE-2021-46784",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2f6dc6bc",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing and buffer management, but the vulnerability types differ significantly. CVE-2016-1833 is an out-of-bounds read in an XML parser due to multi-byte character handling. The target code processes Gopher protocol lines with explicit bounds checks (`llen = TEMP_BUF_SIZE - gopherState->len - 1`) and does not involve complex character encoding parsing. The core flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex compiler due to improper NUL byte handling. The target code uses `memchr` and `strchr` for line/field parsing but does not compile patterns or process embedded NULs in a way that would cause a similar buffer over-read. The functional domains (regex vs. protocol conversion) and flaw mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in memory allocation. The target code performs buffer copies (`memcpy`) with calculated lengths (`llen`). While there is a potential for miscalculation (e.g., `llen` derived from pointer arithmetic), the code has explicit overflow protection (`if (gopherState->len + llen >= TEMP_BUF_SIZE)`). The vulnerability type (OOB-write via integer overflow) is similar in concept but the implementation context (network protocol parsing vs. file transfer) and specific trigger conditions differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1838 is an out-of-bounds read in an XML end-tag parser. The target code reads lines and parses tab-separated fields, but uses string operations (`strchr`) that rely on null-terminated strings created by the code itself (`line[llen + 1] = '\\0'`). It does not parse a nested document structure like XML. The OOB-read flaw pattern is not directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code parses the Gopher protocol, which has an implicit structure but no explicit length fields in the data being processed in this function. The parsing is delimiter-based (tabs, newlines). The similarity is limited to both being network protocol parsers, but the flaw mechanism is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1835 is a use-after-free in an XML attribute parser. The target code does not dynamically allocate and free complex structures during its parsing loop; it uses stack/local arrays and appends to an output buffer. There is no apparent pattern of holding references to freed memory. The vulnerability type is not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a daemon related to error handling and resource cleanup. The target function `gopherToHTML` is a conversion routine with straightforward control flow and no complex resource allocation/cleanup that could lead to a similar state management error. The contexts are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20760 is an out-of-bounds write due to improper error handling in a text encoding conversion function. The target code also performs string processing and buffer copies. A relevant similarity is the potential for miscalculating buffer sizes or copy lengths, especially in the line assembly logic (`gopherState->len + llen`). However, the target code has explicit bounds checking, and the flaw in CVE-2018-20760 is more specific to UTF conversion error codes.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1836 is a use-after-free caused by buffer reallocation invalidating pointers in an XML name dictionary. The target code uses fixed-size buffers (`LOCAL_ARRAY`, `TEMP_BUF_SIZE`) and does not perform reallocations during the parsing of a single line. The memory management model is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-14151 is a buffer overflow due to incorrect size calculation for a padded buffer. The most relevant part of the target code is the buffer size check `if (gopherState->len + llen >= TEMP_BUF_SIZE)`. The calculation uses `>=` and then `llen = TEMP_BUF_SIZE - gopherState->len - 1`. This is correct, but the pattern of calculating a copy length relative to a fixed buffer size is a common source of errors (off-by-one, integer underflow). The similarity is in the *pattern of defensive coding* around fixed buffers, not in the specific vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2021-40567_before_exclude_100:d297b14e:vulspec": {
    "timestamp": "2026-01-17T01:12:59.952843",
    "cve_id": "CVE-2021-40567",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d297b14e",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network service daemon (MiniSSDPd) related to socket communication and memory management errors. The target code is a multimedia file hinting function in GPAC that processes ISO file structures and generates SDP lines. The domains, functionality, and vulnerability patterns (memory corruption vs. format string/buffer handling) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 2 is an integer overflow leading to heap corruption in a VNC file transfer component. The target code performs arithmetic and memory allocations but does not show the same pattern of unchecked integer operations on user-controlled data that could wrap and cause undersized allocations. The primary operations are base64 encoding and string formatting with known sizes.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a buffer overflow in an image codec due to insufficient padding allocation. The target code uses fixed-size stack buffers (buf64[5000], sdpLine[5100]) for base64 encoding and sprintf operations, which could be similar if the encoded data exceeds buffer sizes. However, the vulnerability pattern (calculation error vs. fixed buffer with variable input) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code parses multimedia file structures but does not show similar parsing of untrusted network packets with TLV fields. The primary risks are buffer overflows from string operations, not protocol field validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a race condition in a filesystem's node ID management. The target code is a single-threaded file processing function with no concurrency or shared resource management patterns. The vulnerability domains (concurrent filesystem ops vs. media file hinting) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a memory allocation failure due to unchecked header values in an image converter. The target code does check sample counts and uses gf_hinter_can_embbed_data for size validation, but shares the theme of processing external file/data structures. The specific flaw (unchecked biBitCount=0) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 7 is an out-of-bounds write in GPAC's binary data parser (gf_bin128_parse). The target code is from the same GPAC framework and shares similar risk patterns: string/buffer operations (sprintf into fixed buffers), memory allocations (gf_malloc), and lack of explicit bounds checking for the base64-encoded data size relative to buf64[5000]/sdpLine[5100]. The code patterns and domain are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 is an out-of-bounds read in a regex engine due to NUL byte handling. The target code does not parse complex patterns or handle embedded NULs. Both involve string processing, but the vulnerability mechanisms are different (delimiter confusion vs. buffer size miscalculation).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is a buffer overflow in OpenJPEG due to missing buffer size validation when writing marker segments. The target code uses sprintf into fixed-size buffers without explicit length checks, which is a similar pattern. However, the context (image codec vs. multimedia hinting) and specific APIs differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 10 is an out-of-bounds write in GPAC's text import utility (gf_text_get_utf8_line). This is in the same GPAC framework as the target code. Both involve unsafe string/buffer operations: target code uses sprintf into fixed buffers (buf64, sdpLine) with data from gf_base64_encode, and strcpy into allocated memory without checking if the allocated size matches the string length. The vulnerability patterns (buffer overflow via string operations) and codebase are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2021-40567_after_exclude_100:9fdcdd99:vulspec": {
    "timestamp": "2026-01-17T01:13:14.996922",
    "cve_id": "CVE-2021-40567",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9fdcdd99",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network service discovery daemon. The target code is a multimedia file hinting function in GPAC, dealing with SDP generation, base64 encoding, and memory allocation. The vulnerability type, context, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 2 is an integer overflow leading to an out-of-bounds write in a VNC file transfer component. The target code performs arithmetic and string operations with fixed-size buffers (e.g., `buf64[5000]`). While both involve data processing, the core flaw (integer overflow vs. potential buffer overflow via `sprintf`), attack surface, and domain are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is a heap buffer overflow in an image codec due to insufficient padding calculation. The target code uses `sprintf` into fixed-size stack buffers (`buf64[5000]`, `sdpLine[5100]`). Both involve buffer size risks, but the trigger (malicious image data vs. controlled string formatting) and the underlying cause (allocation math error vs. unbounded string copy) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse untrusted network packets; it constructs SDP lines from internal file data. The vulnerability class and operational context are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is a race condition in a filesystem's node ID management. The target function `gf_hinter_finalize` is a single-threaded, sequential processing function with no concurrency or resource sharing patterns. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a memory allocation failure/DoS due to unchecked header values in an image converter. The target code has potential for buffer overflows via `sprintf` but does not involve parsing malicious file headers or unchecked allocations in the same way. The similarity is only in the broad category of input validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 7 is an out-of-bounds write in GPAC itself (the same system as the target code) within a binary data parsing utility (`gf_bin128_parse`). The target code is also from GPAC and shares the same codebase, libraries (e.g., `gf_malloc`, `gf_free`), and potential for memory safety issues. While the specific function differs, the environment, common utilities, and vulnerability patterns (e.g., buffer handling) are highly similar and provide valuable reference for auditing this code.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in a Perl regex engine due to NUL byte handling. The target code does not involve regular expression compilation or complex string parsing with embedded NULs. The domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is an out-of-bounds write in an image codec due to missing buffer size validation. The target code uses fixed-size stack buffers with `sprintf`, which poses a risk of overflow if the formatted string exceeds buffer size, a different mechanism than the image marker writing flaw. The similarity is only in the general concept of buffer bounds violations.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 10 is an out-of-bounds write in GPAC (the same system) within a text import function (`gf_text_get_utf8_line`). This is highly relevant because it shares the exact codebase, common APIs, and memory management patterns with the target code. The vulnerability pattern (unsafe buffer copy, error handling) is directly applicable for reviewing the target function's use of `sprintf`, `strcpy`, and buffer allocation (`gf_malloc`). The context and potential flaw patterns are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      }
    ]
  },
  "CVE-2022-23567_before_exclude_100:17fc5fb0:vulspec": {
    "timestamp": "2026-01-17T01:13:20.530453",
    "cve_id": "CVE-2022-23567",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "17fc5fb0",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel timing attack in cryptographic operations. The target code performs sparse tensor operations with bounds checking and error handling, with no cryptographic context or secret-dependent branching that could leak information.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14164 involves out-of-bounds write due to insufficient buffer validation. The target code has bounds checking (FastBoundsCheck) and validation (OP_REQUIRES), but both deal with input validation and bounds. However, the domain (image processing vs. tensor computation) and specific flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-13219 involves integer overflow in codebook calculations. The target code uses int64_t indices and performs bounds checking, but does involve dimension calculations and indexing that could theoretically have integer issues. The relevance is limited as the target code's validation appears more robust.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14152 is a use-after-free vulnerability in image parameter handling. The target code manages Tensor objects with RAII-style management in TensorFlow, with no apparent manual memory management or pointer handling that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 involves use-after-free in a network daemon's memory management. The target code is a tensor computation kernel with different memory management patterns and no network or error path exploitation scenarios.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-20840 involves out-of-bounds write due to alignment assumptions in WebSocket decoding. The target code has bounds checking and uses Eigen tensor operations with proper indexing. Both involve bounds validation, but the alignment issue and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 involves buffer overflow in image compression due to insufficient padding. The target code allocates tensors based on computed sizes (nnz) and performs bounds checking. Both involve buffer sizing and validation, but the specific overflow mechanism differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3603 involves privilege management failure in a network daemon. The target code is a computational kernel with no privilege separation or security context management concerns.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-19333 involves buffer overflow due to insufficient length validation in string operations. The target code performs bounds checking on tensor indices and dimensions, showing similar validation patterns. Both involve validating input sizes against allocated buffers, though the data types (strings vs. tensors) differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2010-1311 involves improper input validation leading to memory corruption in decompression. The target code extensively validates tensor shapes, dimensions, and indices before operations. Both emphasize the importance of input validation to prevent memory safety issues, though the domains differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-23567_after_exclude_100:90260a88:vulspec": {
    "timestamp": "2026-01-17T01:13:39.805658",
    "cve_id": "CVE-2022-23567",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "90260a88",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a cryptographic side-channel vulnerability (timing attack) in libgcrypt. The target code is a TensorFlow sparse tensor operation with no cryptographic functionality, constant-time considerations, or secret-dependent branching.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is an out-of-bounds write in an image codec due to insufficient buffer validation. The target code performs bounds checking via `FastBoundsCheck` and validates indices, making it more robust. Both involve input validation but in different domains (image parsing vs. tensor indexing).",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 3 is an integer overflow in audio codec calculations. The target code uses `int64_t` for indices and dimensions and performs bounds checking, reducing overflow risk. However, both involve processing structured input data (tensor indices vs. codebook parameters) and require validation of numerical values to prevent incorrect computations.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a use-after-free in image parameter handling. The target code manages Tensor objects with RAII-style ownership (via OpKernelContext) and doesn't exhibit manual memory management or pointer lifecycle issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a use-after-free in a network daemon's resource cleanup. The target code is a mathematical tensor operation with no network I/O, dynamic resource allocation with error paths, or similar state management vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an out-of-bounds write due to alignment assumptions in network data parsing. The target code copies data using Eigen tensor operations with bounds checking. Both involve data copying from structured input, but the alignment issue is specific to network packet handling.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a buffer overflow due to incorrect size calculation in image compression. The target code allocates output buffers based on validated input (`nnz`). Both involve buffer allocation based on input parameters, but the vulnerability patterns differ (padding calculation vs. index validation).",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a privilege management issue in a network daemon. The target code is a pure computation kernel with no privilege separation, process control, or system-level security considerations.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a buffer overflow in string concatenation due to missing length validation. The target code performs bounds checking on tensor indices (`FastBoundsCheck`) to prevent out-of-bounds access. Both involve validating input sizes/indices against container boundaries, though the data types (strings vs. numeric tensors) and operations differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is improper input validation leading to out-of-bounds writes in a decompression algorithm. The target code validates tensor indices and dimensions extensively before use. Both emphasize the importance of validating input parameters against operational boundaries, though the specific validation patterns and domains differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-32546_before_exclude_100:ca7f2f65:vulspec": {
    "timestamp": "2026-01-17T01:14:09.124277",
    "cve_id": "CVE-2022-32546",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ca7f2f65",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free (CWE-416) in a network service daemon (MiniSSDPd) related to socket communication and service registration. The target code is an ImageMagick PCL image reader that parses a file format and delegates processing to an external tool (GhostPCL). The domains (network service vs. image processing), vulnerability types (memory corruption vs. potential command injection/delegate issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is an Out-of-bounds Write (CWE-787) in GIMP's XWD file parser due to insufficient validation of header fields (color count vs. color map entries). The target code also parses a file format (PCL) and performs sscanf operations on parsed strings. While both involve file format parsing, the vulnerability mechanism is different. The target code's primary risk is not OOB write from header parsing but potential issues in string handling (buffer overflows in command/geometry arrays) or delegate command injection. The similarity is limited to the broader category of \"file parser\".",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a memory allocation failure/DoS (CWE-119) in OpenJPEG's BMP converter due to unchecked header values. The target code performs calculations for width/height and page size based on parsed values, but does not show the same pattern of allocating memory based directly on unchecked user input. The relevance lies in the general principle of validating parsed file metadata before use in calculations or resource allocation, but the specific flaw pattern is not strongly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an Out-of-bounds Read (CWE-125) in Perl's regex engine due to improper NUL byte handling. The target code reads a binary blob and processes it as a character stream, but there is no indication of similar NUL byte misinterpretation leading to OOB reads. The domains (regex compilation vs. image file reading) and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a Resource Management Error/memory leak (CWE-399) in PHP's GD library during image scaling error handling. The target code also involves resource management (creating/deleting images, unique files, strings), but the specific pattern of inconsistent cleanup on an error path is not clearly evident in the provided snippet. Both are image processing libraries, but the vulnerability type and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Write (CWE-787) due to Integer Overflow (CWE-190) in a VNC server's file transfer protocol. The target code performs size calculations (e.g., page.width * resolution), but these use `size_t` and `double` and are not obviously vulnerable to integer overflow leading to OOB write. The domains (remote desktop protocol vs. image file parsing) and attack surfaces are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 7 is an Out-of-bounds Read (CWE-125) in ImageMagick's PSD parser (`coders/psd.c`). The target code is from the same library (ImageMagick), specifically the PCL reader (`coders/pcl.c` likely). Both are \"coders\" (format handlers) within ImageMagick, following similar patterns: reading a blob, parsing format-specific structures, and delegating processing. The vulnerability type (OOB read) is highly relevant, as the target code uses `sscanf` on a bounded buffer `command` after reading an unbounded stream into it, which could lead to similar issues if the buffer `MaxTextExtent` is exceeded or if parsed values are used unsafely later. The code patterns and context are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-7532"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a Double Free (CWE-415) in libgd's BMP handling during error cleanup. The target code uses `DestroyImage` and `DestroyString` for cleanup. While resource management is a common theme, the provided snippet shows a linear flow without complex error paths that could cause double-free. The relevance is limited to the general concept of proper resource deallocation.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an Out-of-bounds Write due to alignment issues in a VNC WebSocket decoder. The target code does not involve low-level memory operations on network data with alignment concerns. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a Buffer Overflow (CWE-119) in OpenJPEG due to insufficient padding allocation during encoding. The target code allocates strings with fixed sizes (`MaxTextExtent`) and formats data into them, which could theoretically overflow if format strings are not controlled, but this is a different pattern from the arithmetic miscalculation in OpenJPEG. Both involve image processing, but the specific flaw mechanism is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-32546_after_exclude_100:f3001301:vulspec": {
    "timestamp": "2026-01-17T01:15:00.838235",
    "cve_id": "CVE-2022-32546",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f3001301",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free (CWE-416) in a network service daemon (MiniSSDPd) related to socket communication and service registration. The target code is an image file parser (PCL) in ImageMagick that reads a file, parses metadata, and delegates processing to an external tool (GhostPCL). The domains (network service vs. image parsing), vulnerability types (memory corruption vs. potential command injection or file handling), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is an Out-of-bounds Write (CWE-787) in GIMP's XWD file parser due to insufficient validation of header fields (color count vs. color map entries). The target code also parses a file format (PCL) and uses `sscanf` on data read from the file. While both involve parsing untrusted file headers, the specific vulnerability mechanism (OOB write from a miscalculated array size) is not directly evident in the target code. The target code's primary risk may lie elsewhere (e.g., command injection via `command` buffer or path traversal).",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a memory allocation failure/DoS (CWE-119) in OpenJPEG's BMP converter due to unchecked integer values in a header. The target code reads PCL headers and performs calculations (e.g., `page.width=(size_t) floor(...)`). Both involve processing untrusted file metadata and performing arithmetic. However, the target code does not show obvious integer overflow checks on `page.width/height` or `width/height` calculations before use in memory allocation or `FormatLocaleString`. The vulnerability class (integer overflow leading to allocation issues) is somewhat relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an Out-of-bounds Read (CWE-125) in Perl's regex compiler due to improper NUL byte handling. The target code reads a byte stream in a loop and builds a string buffer (`command`). While both process input strings, the target code's `command` buffer is bounded by `MaxTextExtent` and null-terminated carefully. The vulnerability pattern (embedded NUL causing logic confusion) is not apparent here. The domains (regex compilation vs. image metadata parsing) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a resource management error/memory leak (CWE-399) in PHP's GD library during image scaling error handling. The target code has extensive resource management (creating/deleting images, strings, unique files). A potential similarity is in error paths: if `ExternalDelegateCommand` fails, resources like `read_info` and unique files are cleaned up, but the code flow should be examined for leaks. However, the core flaw (inconsistent deallocation in a specific algorithm) is not directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Write (CWE-787) due to integer overflow in LibVNC's file transfer protocol. The target code performs integer arithmetic on `page.width/height` and `image->x_resolution`, but these are of type `size_t` and `double`. The risk of integer overflow/wraparound leading to buffer overflow is less direct here, as the calculations are primarily for formatting strings and geometry. The attack surface (network protocol vs. file parsing) and vulnerability pattern differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 7 is an Out-of-bounds Read (CWE-125) in ImageMagick's PSD coder due to lack of bounds checking on resource blocks. The target code is *also from ImageMagick* (same system) and reads a file format (PCL). It shares the same codebase patterns, error handling (`ThrowReaderException`), and potential for file parsing vulnerabilities. The specific flaw (OOB read) is not immediately evident in this snippet, but the context is highly relevant: both are ImageMagick coders processing complex binary/structured formats, where similar parsing bugs (e.g., in `sscanf` on untrusted data) could exist.",
        "case_metadata": {
          "cve_id": "CVE-2016-7532"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a Double Free (CWE-415) in libgd's BMP handling during error cleanup. The target code uses `DestroyString` and `DestroyImage` which likely have safe semantics. However, both libraries are image processing utilities. The relevance is low because the specific error handling pattern leading to double-free (missing checks on function return values) is not clearly visible here. The target code's `ExternalDelegateCommand` status is checked, but other function calls' error states might be overlooked.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an Out-of-bounds Write due to alignment issues in LibVNCServer's WebSocket decoding. The target code does not perform low-level byte manipulation or assume alignment. It reads bytes into a character buffer. The domains (remote desktop protocol vs. local file parsing) and vulnerability patterns (unaligned memory access vs. string parsing) are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a Buffer Overflow (CWE-119) in OpenJPEG due to insufficient padding allocation. The target code allocates strings (`AcquireString`) and formats data into fixed-size buffers (`command[MaxTextExtent]`, `geometry[MaxTextExtent]`). There is a potential for buffer overflow if `FormatLocaleString` writes exceed `MaxTextExtent`, especially when using `%.20g` with large numbers. This is a tangential similarity: both involve writing calculated data into buffers, but the target code uses fixed-size buffers with a reasonably large constant, making overflow less likely than in the dynamic allocation case of CVE-2017-14151.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2021-41216_before_exclude_100:04f04d4a:vulspec": {
    "timestamp": "2026-01-17T01:15:04.634640",
    "cve_id": "CVE-2021-41216",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "04f04d4a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 involves an access control flaw (CWE-284) in a database query planner. The target code is a shape inference function in a tensor manipulation library with no privilege checks or SQL-like functionality. The domains and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-7972 is a resource management error (CWE-399) in a subtitle renderer related to inconsistent memory tracking. The target code performs shape validation and dimension calculation without dynamic memory allocation or complex resource state management. The core flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) in a regex parser due to improper NUL byte handling. The target code does involve reading from a tensor (`perm`), but it performs bounds checking (`if (in_idx >= rank)`) and uses safe element access patterns. The similarity is limited to the general concept of validating input indices.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability (CWE-200/385) in a cryptographic library. The target code performs deterministic shape inference with no secret-dependent branches or cryptographic operations. The attack models (physical side channels vs. API input validation) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-16149 is a cryptographic signature verification flaw (CWE-347) due to improper ASN.1 parsing. The target code validates array indices and tensor shapes, not cryptographic structures. Both involve input validation, but the data formats, security contexts, and failure consequences are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-10218 is a NULL pointer dereference (CWE-476) caused by invalid state transitions in a graphics stack. The target code checks for a null `perm` tensor pointer and handles it safely (`if (perm != nullptr)`). Both involve guarding against invalid object states, but the target code's defense is more straightforward and the context (graphics rendering vs. tensor shape inference) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-5844 is an integer overflow (CWE-190) in an archive parser. The target code uses `int64_t` for rank and indices and performs a bounds check (`if (in_idx >= rank)`), which helps prevent overflow-related logic errors. Both involve parsing structured input and calculating positions/sizes. The relevance is in the defensive pattern of validating calculated indices against known bounds, though the specific overflow trigger is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-5745 involves a broken crypto algorithm (CWE-327) leading to a NULL pointer dereference. The target code has no cryptographic elements. The only tangential similarity is the presence of a null check for the `perm` tensor, but this is a standard safe programming practice, not a response to a cryptographic error.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-16161 is a NULL pointer dereference (CWE-476) in a regex library due to inconsistent error state handling. The target code returns error statuses (`errors::InvalidArgument`) but does not manage complex error state objects that could be null. The dereference flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-11235 involves insufficient input validation (CWE-345) of cryptographic scalars and points. The target code demonstrates strong input validation: it checks the rank is known, validates the permutation tensor's rank and element count, and performs a critical bounds check on the permutation indices (`if (in_idx >= rank)`). The relevance lies in the pattern of rigorously validating all indices derived from user-controlled input before using them for memory/object access, which is a key lesson from many input validation vulnerabilities. However, the specific context (network authentication vs. tensor shape calculation) is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      }
    ]
  },
  "CVE-2021-41216_after_exclude_100:9d14bbe4:vulspec": {
    "timestamp": "2026-01-17T01:15:06.366307",
    "cve_id": "CVE-2021-41216",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9d14bbe4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control (CWE-284) issue in PostgreSQL's privilege checking logic. The target code is a shape inference function in a tensor manipulation library (likely TensorFlow) performing bounds checking and dimension validation. The vulnerability type, domain, and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error (CWE-399) in a subtitle renderer related to inconsistent memory tracking. The target code performs shape and index validation with no dynamic memory allocation or resource management patterns. The core flaw is unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) in a regex parser due to improper NUL byte handling. The target code also performs bounds checking (e.g., `if (in_idx >= rank || in_idx <= -rank)`), which is a defensive measure against out-of-bounds access. However, the vulnerability type (OOB read vs. potential OOB access prevention), domain, and trigger conditions are different. The similarity is limited to the general concept of input validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel information exposure (CWE-200/385) in a cryptographic library. The target code is a purely functional shape calculation with no cryptographic operations, secret data, or timing-sensitive logic. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-16149 is an improper cryptographic signature verification (CWE-347) due to insufficient ASN.1 validation. The target code validates array indices and tensor ranks. Both involve input validation, but the domain (cryptography vs. tensor shape), data structures, and specific flaw patterns are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-10218 is a NULL pointer dereference (CWE-476) in a PDF renderer due to invalid stack operations. The target code checks for a null `perm` pointer but uses it safely (`if (perm != nullptr)`). The code pattern of pointer checking is similar, but the root cause (state corruption vs. missing input tensor) and context are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-5844 is an integer overflow (CWE-190) in an archive parser. The target code uses `int64_t` for rank and indices and performs a bounds check (`in_idx >= rank || in_idx <= -rank`). While no obvious integer overflow is present in the shown code, the context of parsing external data (tensor permutation) and validating integer ranges against a derived rank has conceptual parallels. The reference value lies in ensuring index calculations do not wrap.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a broken cryptographic algorithm (CWE-327) leading to a NULL pointer dereference. The target code has no cryptographic elements and handles null pointers defensively. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-16161 is a NULL pointer dereference (CWE-476) in a regex library due to inconsistent error state handling. The target code returns `Status` objects and errors consistently (e.g., `errors::InvalidArgument`). The error handling patterns are different and robust in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-11235 is insufficient verification of cryptographic data (CWE-345) in an authentication protocol. The target code verifies that permutation indices are within bounds, which is a form of input validation. However, the scale, domain (network auth vs. data shape), and consequences are completely different. Only a superficial similarity in validating numeric ranges exists.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      }
    ]
  },
  "CVE-2021-40153_before_exclude_100:153036c0:vulspec": {
    "timestamp": "2026-01-17T01:15:15.072367",
    "cve_id": "CVE-2021-40153",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "153036c0",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve filesystem parsing where integer overflow could lead to memory corruption. Target code has bounds checks (dir_count > SQUASHFS_DIR_COUNT, dire->size >= SQUASHFS_NAME_LEN) but potential exists for integer overflows in calculations like `bytes += dire->size + 1` if `dire->size` is manipulated. Similar domain (filesystem image parsing) and vulnerability class (CWE-190).",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case involves use-after-free in a network daemon's error handling. Target code is a filesystem directory parser with straightforward memory allocation (malloc/realloc) and cleanup on error paths (free). No complex state management or pointer reuse patterns similar to the vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve potential buffer overflows, but mechanisms differ. Target code uses memcpy with size check (dire->size >= SQUASHFS_NAME_LEN) and null-termination. Case 3 involves alignment issues in network protocol decoding. Different domains (filesystem vs. network protocol) and trigger conditions.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve parsing untrusted data (filesystem image vs. VNC file transfer) with integer handling risks. Target code has calculations like `size = (*i)->data + bytes - 3` and `bytes += dire->size + 1` that could overflow if input is malicious. Similar vulnerability pattern (CWE-190 leading to out-of-bounds write) though specific context differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case involves out-of-bounds read due to NUL byte handling in regex parsing. Target code uses string operations (strcpy) but ensures null-termination. Different domains (regex compilation vs. filesystem parsing) and vulnerability types (over-read vs. potential overflow).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both parse structured formats (filesystem metadata vs. Office documents). However, Case 6's double-free due to error state inconsistency is not present in target code, which has simple error jumps to 'corrupted' label with cleanup. Different memory management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case involves race condition in kernel filesystem node management. Target code is user-space, single-threaded directory parsing with no concurrency. Completely different vulnerability class (CWE-362 vs. memory safety issues).",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve buffer size calculations for parsing structured data. Target code has explicit checks on size fields, but similar risks exist if calculations overflow (e.g., `bytes += dire->size + 1`). Different domains (image codec vs. filesystem) but similar underlying integer handling concerns.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve writing parsed data to buffers with size validation concerns. Target code uses realloc for dynamic growth, while Case 9 is about fixed buffer overflow. Some similarity in \"parsing untrusted data and writing to buffer\" pattern, but implementation details differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve processing untrusted data with length validation. Target code validates `dire->size` before memcpy, similar to iovec length validation in Case 10. However, different contexts (kernel FUSE ioctl vs. user-space filesystem parser) and vulnerability specifics (direct overflow vs. calculated overflow).",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      }
    ]
  },
  "CVE-2021-40153_after_exclude_100:667fbade:vulspec": {
    "timestamp": "2026-01-17T01:16:09.953296",
    "cve_id": "CVE-2021-40153",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "667fbade",
    "scores": [
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve filesystem parsing where integer overflows or validation issues could lead to memory corruption. The target code has checks for `dir_count > SQUASHFS_DIR_COUNT` and `dire->size >= SQUASHFS_NAME_LEN`, which are similar to the bounds validation missing in CVE-2019-1010065. However, the target code's vulnerability pattern is more about direct buffer overflows from unchecked `memcpy` using `dire->size` (though it has a check) rather than an integer overflow bypassing checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free in a network daemon's state management. The target code is a filesystem directory parser with straightforward memory allocation (`malloc`/`realloc`) and cleanup on error paths. There are no complex state machines or pointer management patterns that would lead to a use-after-free scenario similar to the case.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve potential out-of-bounds writes, but the root causes differ significantly. CVE-2019-20840 is about unaligned memory access in network protocol decoding. The target code performs aligned buffer operations (`memcpy`) on data read from a filesystem image. The similarity is only in the general memory safety concern, not in the specific trigger or code pattern.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2018-20750 involves an integer overflow leading to an undersized buffer allocation and subsequent out-of-bounds write. The target code has similar elements: it processes external data (directory entries) with size fields (`dir_count`, `dire->size`), performs arithmetic (`bytes += dire->size + 1`), and uses `memcpy`. A missing or incorrect check on `dire->size` before the `memcpy` could lead to a buffer overflow, analogous to the integer handling flaw in the case. The pattern of validating size fields from untrusted data is directly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read due to improper NUL byte handling in string parsing. The target code uses `memcpy` and explicitly null-terminates strings (`dire->name[dire->size + 1] = '\\0'`). While both process variable-length names, the target code's structure (explicit size field) and the flaw pattern (buffer overflow vs. over-read) are different. The relevance is in the general theme of validating string lengths from untrusted sources.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double-free during error handling in a document parser. The target code has simple error handling that frees memory (`free(dir->dirs); free(dir);`) and returns NULL, with no complex cleanup or reallocation of the same pointer within the function. The memory management patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a kernel filesystem's concurrent resource management. The target code is a user-space, single-threaded directory parsing function with no concurrency or shared state. The vulnerability domains are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-14151 is a buffer overflow due to insufficient buffer allocation/padding calculation. The target code uses a fixed-size stack buffer (`buffer`) to hold a directory entry, which includes the name. The check `if(dire->size >= SQUASHFS_NAME_LEN)` is critical to prevent overflowing this buffer during the `memcpy`. This is conceptually similar to ensuring an allocation is large enough for the data to be written. The code pattern of checking a size against a maximum before a copy is directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-14164 is an out-of-bounds write due to missing validation of output buffer size. The target code writes into the heap-allocated `dir->dirs` array after a `realloc`. While it grows the array in chunks (`DIR_ENT_SIZE`), ensuring capacity, the relevance lies in the pattern of writing data (directory names via `strcpy`) into dynamically managed buffers based on parsed input sizes. An error in the size calculations or checks could lead to a similar overflow.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2010-4650 is a buffer overflow due to insufficient validation of aggregated data length (iovecs). The target code also aggregates data (`bytes += dire->size + 1`) while looping, but it validates each individual component's size (`dire->size`). The similarity is in processing a sequence of variable-length data items and needing to ensure total or per-item bounds are respected. However, the target code's structure is simpler and lacks the multi-layer aggregation flaw of the case.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      }
    ]
  },
  "CVE-2021-24045_before_exclude_100:e1c91f37:vulspec": {
    "timestamp": "2026-01-17T01:16:31.280086",
    "cve_id": "CVE-2021-24045",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e1c91f37",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a JavaScript/IR unary operator evaluator performing constant folding, while CVE-2018-18313 is a buffer over-read in a Perl regex engine due to NUL byte mishandling. The vulnerability type (CWE-125), domain (parsing vs. constant evaluation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code performs simple arithmetic and type operations, while CVE-2015-7511 is a side-channel vulnerability in a cryptographic library. The vulnerability type (CWE-385), domain (cryptography vs. compiler IR), and attack surface (physical measurement vs. code generation) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a deterministic, pure function for constant folding with no dynamic memory management. CVE-2016-7972 is a resource management error (CWE-399) in a subtitle renderer involving inconsistent memory tracking. The core flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs safe literal value transformations with no input parsing or buffer operations. CVE-2014-9140 is a buffer overflow (CWE-119) in a network packet decoder due to insufficient bounds checking during unescaping. The domains and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2014-9140"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The only tangential similarity is that both involve numeric operations. However, the target code performs simple arithmetic on already-validated numeric literals, while CVE-2013-0211 is a numeric conversion error (CWE-189) leading to buffer overflow in an archive library. The vulnerability context and severity are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The target code performs arithmetic negation which could theoretically involve numeric edge cases (like -0), but it operates on fixed literal values, not parsed input. CVE-2016-5844 is an integer overflow (CWE-190) during file position calculation in an archive parser. The attack surface (malicious files vs. compiler IR) and flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code has no packet parsing or network protocol logic. CVE-2017-13031 is an out-of-bounds read (CWE-125) in a packet analyzer due to insufficient validation of packet structure. The domains and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13031"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not perform any string copying, concatenation, or buffer management; it returns pre-allocated literal objects. CVE-2019-19333 is a buffer overflow in a YANG parser due to unsafe string operations and incorrect size calculations. The vulnerability mechanisms are not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not process network messages or external input buffers. CVE-2011-3601 is a buffer overflow (CWE-119) in a network daemon due to lack of bounds checking on parsed options. The domains (network security vs. compiler optimization) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Similar to case 8, the target code contains no string concatenation or buffer size miscalculation logic. CVE-2019-19334 is an out-of-bounds write (CWE-787) due to unsafe string operations in a data model parser. The code patterns and vulnerability types are not applicable to the constant folding function.",
        "case_metadata": {
          "cve_id": "CVE-2019-19334"
        }
      }
    ]
  },
  "CVE-2021-24045_after_exclude_100:df16f281:vulspec": {
    "timestamp": "2026-01-17T01:16:38.201848",
    "cve_id": "CVE-2021-24045",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "df16f281",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a JavaScript/IR unary operator evaluator performing constant folding, while Case 1 involves a regex engine buffer over-read due to NUL byte handling. The domains (language runtime vs. regex parsing), vulnerability types (none apparent in target vs. CWE-125), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a side-channel vulnerability in a cryptographic library. The target code performs deterministic, non-cryptographic constant folding with no secret-dependent branches or timing variations. The domains and security concerns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 involves resource management errors in a subtitle renderer. The target code is a simple switch-based evaluator with no dynamic memory allocation, resource tracking, or complex state management that could lead to similar inconsistencies.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow in a network packet parser due to insufficient bounds checking during unescaping. The target code operates on typed literals within a compiler IR, with no buffer operations, network input, or similar parsing logic.",
        "case_metadata": {
          "cve_id": "CVE-2014-9140"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 involves a numeric conversion error in an archive library. The target code performs arithmetic negation (-literalNum->getValue()) which could theoretically involve type conversions, but the code context (constant folding) and the lack of buffer operations based on the result make the vulnerability pattern dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an integer overflow in an archive parser. The target code performs arithmetic negation which, if the numeric type and value range are not carefully considered, could theoretically lead to an overflow/wraparound (e.g., negating INT_MIN). However, the context (constant folding vs. file parsing) and the lack of subsequent buffer usage based on the result limit the relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in a network packet dissector. The target code operates on in-memory IR objects with known kinds, using safe casts (dyn_cast). There is no parsing of untrusted byte streams or similar boundary validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-13031"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow in a YANG parser due to unsafe string operations. The target code uses no string buffers, strcpy, or sprintf. It returns literal strings from a builder, implying managed string handling.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow in a network daemon parsing untrusted packets. The target code is an internal compiler function processing already-validated IR instructions, not raw network data. The attack surfaces and data flows are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds write in a YANG parser due to string concatenation errors. The target code contains no string concatenation logic or buffer size calculations. It returns pre-defined literal strings based on operand kind.",
        "case_metadata": {
          "cve_id": "CVE-2019-19334"
        }
      }
    ]
  },
  "CVE-2022-38150_before_exclude_100:e9d4ec47:vulspec": {
    "timestamp": "2026-01-17T01:16:52.654925",
    "cve_id": "CVE-2022-38150",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e9d4ec47",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs simple string and flag checking for HTTP headers. Case 1 involves complex regex parsing with NUL byte handling leading to out-of-bounds reads. The functionality, vulnerability type (CWE-125), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is about integer overflow leading to heap corruption in a VNC file transfer protocol. The target code is a simple HTTP header filter function with no arithmetic, memory allocation, or complex protocol parsing. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves complex XML/HTML parsing with multi-byte character encoding leading to out-of-bounds reads. The target code performs a straightforward search for a colon and flag lookup. The domains (HTTP header vs. XML parsing) and vulnerability mechanisms are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Both involve parsing network protocol data (HTTP vs. LDP) and checking fields. However, Case 4's core flaw is insufficient validation of a length field leading to an out-of-bounds read. The target code validates a header flag but does not parse variable-length data based on an untrusted field, making the vulnerability pattern different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a use-after-free vulnerability in a service discovery daemon related to error handling and memory management. The target code has no dynamic memory allocation or deallocation, operating only on provided struct pointers and strings. No relevance in vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve HTTP protocol processing. Case 6's flaw is improper validation of a numeric field (chunk size) leading to a heap overflow. The target code also parses an HTTP header (looking for ':') but does not interpret numeric values. The similarity is the domain (HTTP), but the vulnerability type (CWE-122 vs. simple logic) and code patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-10190"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a race condition leading to use-after-free in the Linux kernel's memory policy subsystem. The target code is a simple, synchronous user-space function for HTTP filtering with no concurrency, locking, or complex resource management. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both systems are HTTP intermediaries (Varnish Cache vs. the target code's context, likely Varnish or similar). Both process HTTP headers. Case 8's flaw is improper state clearance between requests leading to information disclosure. The target code checks if a header is filtered, which relates to header processing state. The vulnerability types differ (CWE-212 vs. logic flaw), but the domain and component purpose (HTTP header analysis) are similar, providing some reference value for header handling pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an integer overflow in DNS domain name parsing leading to a buffer overflow. The target code performs bounded string search (strchr) and flag checking with no arithmetic operations on user-controlled data. The vulnerability mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Both involve parsing network protocol messages (HTTP vs. IPv6 RA). Case 10's flaw is copying data without proper bounds checking. The target code uses `strchr` which is bounds-safe as it operates on a null-terminated string, but it assumes `fm->hd[u].b` is valid. A superficial similarity exists in parsing \"label\" or field delimiters (':' in HTTP, labels in DNS), but the risk level and vulnerability pattern (buffer copy without checking size) are not present in the simple target code.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      }
    ]
  },
  "CVE-2022-38150_after_exclude_100:e69db6cc:vulspec": {
    "timestamp": "2026-01-17T01:17:07.504372",
    "cve_id": "CVE-2022-38150",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e69db6cc",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex engine due to improper NUL byte handling. The target code is a simple HTTP header filter function performing string search and flag checks, with no regex parsing, complex input processing, or similar memory safety concerns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to an out-of-bounds write in a VNC file transfer protocol. The target code performs no arithmetic, memory allocation, or complex length calculations. It operates on pre-existing header structures with simple pointer and flag operations.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in an XML parser due to improper bounds checking during multi-byte character processing. The target code uses `strchr` on a known header string and performs a table lookup. It does not parse complex encodings or iterate over buffers with manual bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code parses HTTP headers but does not read TLV-like structures or validate numeric length fields from untrusted data. Its primary operation is searching for a colon and checking flags.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a use-after-free vulnerability in a daemon's resource cleanup path. The target code is a pure function that examines a const struct; it performs no dynamic memory management, allocation, or cleanup that could lead to a use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a heap buffer overflow due to improper validation of a negative chunk size in an HTTP protocol handler. The target code also processes HTTP data (headers) and could theoretically be part of a larger HTTP parsing context where similar numeric validation flaws might exist. However, the specific function shown does not parse numeric fields or perform buffer writes.",
        "case_metadata": {
          "cve_id": "CVE-2016-10190"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a use-after-free caused by a race condition in kernel memory policy locking. The target code is a simple, likely single-threaded, user-space function with no concurrency, locking, or complex resource lifecycle management.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is an information disclosure in Varnish Cache due to improper cleanup of sensitive data between HTTP requests. The target code is from an HTTP processing context (likely Varnish or similar) and is responsible for checking if a header is filtered. If the surrounding system fails to properly initialize or clear the `struct http` or its header arrays between requests, similar information leakage could occur (e.g., reading stale pointer `fm->hd[u].b`). The vulnerability patterns are different (logic flaw vs. memory safety), but the domain is identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-20637"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an integer overflow leading to an out-of-bounds write in DNS domain name parsing. The target code performs no arithmetic operations, string length calculations, or buffer writes that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a buffer overflow in an IPv6 RA parser due to lack of input size checking. The target code reads from a header string but does not copy data to another buffer. It uses `strchr` which is safe as long as the input string is properly terminated. The similarity is limited to both being network protocol parsers.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      }
    ]
  },
  "CVE-2022-25139_before_exclude_100:4a0c2f43:vulspec": {
    "timestamp": "2026-01-17T01:18:03.294469",
    "cve_id": "CVE-2022-25139",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4a0c2f43",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is an async/await fulfillment handler in a VM, dealing with stack frame and context switching, with no regex parsing or similar buffer boundary checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to out-of-bounds write in a network file transfer protocol. The target code performs VM state management and function calls without any integer arithmetic, memory allocation, or network data processing that could lead to similar flaws.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a use-after-free due to inconsistent state management during error handling. The target code also manages resources (async context) and has multiple error paths (failed/goto failed). There is a conceptual similarity in ensuring proper cleanup (njs_async_context_free) across all exit paths, but the mechanisms (pointer management vs. VM frame switching) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in an image file parser due to improper string termination validation. The target code does not parse external file formats or perform string operations on untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves improper buffer management and missing sentinel values in a network buffer system. The target code manipulates VM stack frames and scope values but does not implement low-level buffer management or string handling prone to similar boundary issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in an XML parser due to inadequate bounds checking during multi-byte character processing. The target code is an interpreter runtime function with no character encoding or stream parsing logic.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a double free due to inconsistent memory state management during error conditions. The target code frees a context (`njs_async_context_free`) in multiple branches (success and error). There is a similarity in ensuring a resource is freed exactly once across complex control flow, but the target code's structure (single free call per path) appears safer, and the resource is not a simple pointer but a VM context.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a resource management error involving inconsistent tracking of allocated memory size. The target code swaps VM level pointers but does not perform its own memory allocation or size tracking; it manages pre-allocated frame structures.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a race condition in a filesystem's ID allocator due to non-atomic check-and-use operations. The target code is a single-threaded VM callback function (`njs_await_fulfilled`) that operates on the current VM state. There is no concurrency or shared resource contention evident in the code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a heap buffer overflow due to insufficient padding allocation in an image encoder. The target code does not perform any memory allocation or buffer size calculations; it only manipulates existing VM structures and calls functions.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-1198_before_exclude_100:492c4252:vulspec": {
    "timestamp": "2026-01-17T01:18:09.856364",
    "cve_id": "CVE-2022-1198",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "492c4252",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 is a buffer overflow in FUSE ioctl handling due to insufficient validation of iovec lengths (CWE-119). The target code is a TTY line discipline close function focusing on resource cleanup, synchronization, and timer deletion. The vulnerability type, domain (filesystem vs. network/TTY), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a NULL pointer dereference (CWE-476) in the USB/IP subsystem due to insufficient validation of URB fields. The target code performs cleanup and could potentially encounter a NULL pointer if `sp->dev` were NULL, but the context is different (network protocol attack vs. internal cleanup). The primary similarity is the potential for a NULL pointer issue, but the trigger conditions and subsystems are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 is a race condition (CWE-362) leading to a NULL pointer dereference in the keyring subsystem during concurrent initialization. The target code uses `refcount_dec_and_test` and `wait_for_completion` to manage concurrency during close, which is a synchronization mechanism to *prevent* a race condition on the `sp` object. Both deal with concurrency and resource lifecycle, but the target code shows a correct pattern (using refcounts/completion), whereas the case shows a flawed one.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 4 is a race condition (CWE-362) in the TTY subsystem's n_tty line discipline, leading to memory corruption. The target code is also in the TTY subsystem (`sixpack_close` for a line discipline). Both involve TTY line discipline operations, resource management, and the need for proper synchronization. The target code's use of refcounting and completion is a defense against race conditions during close, which is directly relevant to the concurrency flaws seen in historical TTY vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow (CWE-119) in the CIFS crypto code related to scatterlist handling on VMAP stacks. The target code performs simple `kfree` operations and network device cleanup. The vulnerability type, domain (crypto/filesystem vs. TTY/network), and memory operations are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a use-after-free (CWE-416) in the network skbuff fragmentation handling. The target code frees buffers (`sp->rbuff`, `sp->xbuff`) but only after ensuring no users remain (via refcount) and stopping the queue. The relevance is in the general theme of careful resource freeing to avoid UAF, but the specific context (skbuff segmentation vs. TTY line discipline close) and flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a NULL pointer dereference (CWE-476) in a USB serial driver due to missing validation of USB descriptors. The target code is also a driver (TTY line discipline) and could crash if `sp->dev` were NULL when passed to `netif_stop_queue` or `unregister_netdev`. The similarity is the potential for NULL pointer issues during device/driver teardown. However, the attack surface differs (malicious USB device vs. internal state management).",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a buffer overflow/integer overflow (CWE-119/190) in USB/IP due to missing validation of network-provided length fields. The target code does not parse any untrusted data; it performs cleanup. The only faint similarity is that both are in kernel networking-related subsystems, but the vulnerability patterns are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is a race condition (CWE-362) in F2FS nid management due to non-atomic check-and-use operations. The target code explicitly uses atomic refcount decrement and a completion wait to manage a race between closing and other operations on the `sixpack` struct. Both involve concurrency control over shared kernel objects. The target code demonstrates a correct synchronization pattern relevant to preventing the type of flaw seen in Case 10.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2022-1198_after_exclude_100:0b994407:vulspec": {
    "timestamp": "2026-01-17T01:18:10.155008",
    "cve_id": "CVE-2022-1198",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0b994407",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in FUSE ioctl handling due to insufficient iovec length validation. The target code is a TTY line discipline close function managing resource cleanup, timers, and network device deregistration. No buffer operations, no user-controlled input validation, different subsystem (TTY vs FUSE).",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-16914 is a NULL pointer dereference in USB/IP due to insufficient URB validation. The target code has NULL checks (if (!sp) return;) and manages timers/netdev cleanup. While both involve driver cleanup, the vulnerability pattern (missing validation of external data vs orderly shutdown) and subsystems are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2013-1792 is a race condition leading to NULL pointer dereference in keyring initialization. The target code uses refcount and completion to synchronize cleanup, attempting to prevent race conditions during close. Both involve concurrency management, but the target code's pattern (refcount+wait_for_completion) is a defense mechanism, not the vulnerable pattern itself. The subsystem and specific flaw are different.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2014-0196 is a race condition in the TTY subsystem (n_tty line discipline) leading to memory corruption. The target code is also in the TTY subsystem (sixpack line discipline close function). Both deal with TTY line disciplines, concurrency, and resource management. The target code's refcount and completion are synchronization mechanisms relevant to preventing TTY-related race conditions. However, the specific vulnerability pattern (concurrent writers causing buffer overflow) is not present in the target close path.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-10154 is a buffer overflow in CIFS crypto due to scatterlist pointing to VMAP stack. The target code performs simple kfree of allocated buffers (sp->rbuff, sp->xbuff). No cryptographic operations, no complex memory mappings, different subsystem (network filesystem vs TTY).",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2014-0131 is a use-after-free in skbuff fragmentation during TCP segmentation. The target code frees buffers (kfree) but only after stopping queues, deleting timers, and unregistering the netdev, aiming to prevent use-after-free. Both involve careful memory lifecycle management in networking contexts, but the vulnerability mechanism (orphaned fragments) and subsystem (core networking vs TTY-over-IP) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code has no integer arithmetic, no protocol parsing, and performs only destruction, not allocation or writing. Different domain (remote desktop protocol vs kernel driver cleanup).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-3137 is a NULL pointer dereference in a USB serial driver due to missing endpoint validation. The target code is also a driver close function and includes a NULL check. Both are peripheral drivers, but the vulnerability occurs during device initialization/validation, not during shutdown. The target code's NULL check is a safe practice, not the site of a similar flaw.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-16913 is a buffer overflow/integer overflow in USB/IP due to missing validation of network-provided length fields. The target code does not parse any external input; it operates on internal state during close. Both involve network-capable subsystems, but one is an input validation flaw and the other is a cleanup routine.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-18249 is a race condition in F2FS nid management between check and use. The target code uses refcount_dec_and_test and wait_for_completion to manage concurrency during close, which is a pattern to *avoid* race conditions during resource release. Both address concurrency issues in kernel subsystems, but one is the vulnerable pattern (non-atomic check-and-use) and the other is a defensive synchronization pattern. The subsystems are different (filesystem vs TTY).",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2022-25139_after_exclude_100:af4cfa76:vulspec": {
    "timestamp": "2026-01-17T01:18:20.850648",
    "cve_id": "CVE-2022-25139",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "af4cfa76",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is an async/await fulfillment handler in a JavaScript VM, managing stack frames and context switching. CVE-2018-18313 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. The domains (VM internals vs. regex parsing), vulnerability types (logic/state management vs. memory corruption), and code patterns are fundamentally different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code performs controlled context switching and value passing. CVE-2018-20750 is an integer overflow leading to heap corruption in a VNC file transfer. The flaw involves arithmetic on attacker-controlled sizes, which is absent in the target code. The mechanisms and attack surfaces are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The target code manages async context (`ctx`) and frees it in multiple paths (`njs_async_context_free`). CVE-2016-3179 is a Use-After-Free due to inconsistent state cleanup. While both involve resource management and cleanup, the target code's logic appears to guard against double-free by checking error states and calling free once per path. The similarity is in the general category of careful resource lifecycle management, but the specific flaw pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not parse external file formats or untrusted strings. CVE-2017-17787 is an out-of-bounds read in a PSP image parser due to lack of string termination checks. The domains and vulnerability patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code manipulates internal VM stack levels and frame pointers but does not implement a general-purpose buffer or string handling mechanism. CVE-2016-8860 is a missing sentinel in a network buffer abstraction. No relevant similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code is not a parser and does not process byte streams or character encodings. CVE-2016-1833 is an out-of-bounds read in an XML/HTML parser. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Similar to Case 3, CVE-2011-1003 is a Double Free during error handling in a file parser. The target code also frees an async context (`ctx`) in both success and error paths (`failed` label). The pattern of ensuring a resource is freed exactly once across multiple exit paths is a common concern. However, the target code's structure seems designed to avoid this flaw, making it a defensive reference rather than a direct match.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7972 is a resource management error due to inconsistent tracking of allocated size. The target code manages VM execution context pointers but does not involve dynamic memory allocation or size tracking in a comparable way. The general concept of state inconsistency is loosely related but not specific.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The target code saves and restores VM global state (`vm->levels`, `vm->top_frame`, `vm->active_frame`) around a call to `njs_vmcode_interpreter`. This is a form of context switching. CVE-2017-18249 is a race condition due to non-atomic check-and-use operations on shared state (node ID lists). While the target code is likely single-threaded, the pattern of saving state, performing an operation, and restoring state must be correct and complete. If the saved state variables (`cur_local`, etc.) were not properly restored on all error paths, it could lead to VM state corruption, analogous to the race-induced inconsistency. The reference value is in ensuring all code paths correctly maintain/restore invariant state.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not perform arithmetic on buffer sizes or allocate memory based on untrusted input. CVE-2017-14151 is a buffer overflow due to incorrect size calculation. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      }
    ]
  },
  "CVE-2022-1382_before_exclude_100:612eefe8:vulspec": {
    "timestamp": "2026-01-17T01:18:48.197416",
    "cve_id": "CVE-2022-1382",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "612eefe8",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex parsing engine due to improper NUL byte handling. The target code is a segment loader for a binary file format (NE) that performs arithmetic operations and list construction. The domains (parsing vs. binary structure loading), vulnerability types (OOB read vs. potential integer overflow), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves an integer overflow (CWE-190) leading to an out-of-bounds write during a memory allocation calculation. The target code performs an arithmetic operation `(ut64)se->offset * bin->alignment` which could potentially overflow if `se->offset` is large, though the cast to `ut64` mitigates this. The core similarity is the pattern of performing arithmetic on untrusted input (from a binary file) to calculate a memory offset/size. However, the target code does not perform allocation based on this calculation; it's used for a field assignment. The vulnerability type and context are similar, but the exploit consequence (OOB write vs. incorrect field value) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double free caused by inconsistent state management during error handling. The target code has a simple error path (`if (!bs) { return segments; }`) that could leak the `segments` list if `R_NEW0` fails, but this is a memory leak, not a use-after-free. The code patterns and flaw mechanisms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a race condition in a kernel filesystem's node ID management. The target code is a single-threaded function parsing static data from a file. There is no concurrency, shared state, or lock management. The domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code reads from a structured array `bin->segment_entries` based on a header field `SegCount`. While both parse untrusted input, the target code's primary risk is an out-of-bounds array access if `SegCount` is larger than the allocated `segment_entries`, not a miscalculated length leading to a buffer over-read. The code patterns (array indexing vs. pointer arithmetic) and typical flaw locations differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 involves improper bounds checking leading to buffer overflow (CWE-119). The target code iterates over an array `bin->segment_entries` using `bin->ne_header->SegCount` as the limit. If `SegCount` is maliciously large and exceeds the actual size of the `segment_entries` array, it would lead to an out-of-bounds read when accessing `&bin->segment_entries[i]` and subsequent use of that data. This is a classic \"trusting a header field without validating against actual data size\" pattern, similar to the DNSSL parser trusting a length field. The vulnerability type (OOB access) and trigger condition (unvalidated count/length) are similar, though the target code's context is binary parsing, not network protocol parsing.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a use-after-free caused by a race condition and improper locking in a kernel system call. The target code has no dynamic resource management that could lead to a use-after-free in the shown snippet (the list owns the segment objects). The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a heap buffer overflow due to incorrect size calculation for a memory allocation. The target code does not perform any memory allocations based on calculated sizes from the parsed data; it only assigns values to structure fields. The arithmetic operation `(ut64)se->offset * bin->alignment` is for a field (`paddr`), not an allocation size. The flaw pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a double free due to inconsistent state management during error handling. The target code's error path (`if (!bs) { return segments; }`) could lead to a memory leak of the already-allocated `segments` list, but not a double free. The function also assigns `bin->segments = segments` at the end, which could potentially cause a use-after-free if `bin->segments` was already pointing to a freed list, but this is not shown in the provided context. The primary flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 involves improper input validation (CWE-20) leading to memory corruption, specifically failing to check operations against buffer boundaries. The target code implicitly trusts the values in `bin->segment_entries[i]` (like `offset`, `length`) and `bin->ne_header->SegCount`. Missing validation could lead to out-of-bounds array access (if `SegCount` is wrong) or integer overflow in the `paddr` calculation. The core similarity is the pattern of processing untrusted binary data (file format) without sufficient sanity checks on the values used for arithmetic or array indexing. The context (file format parsing) is also similar, though the specific vulnerability manifestation may differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-1382_after_exclude_100:e17fa7c7:vulspec": {
    "timestamp": "2026-01-17T01:19:43.053517",
    "cve_id": "CVE-2022-1382",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e17fa7c7",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression parser due to improper NUL byte handling. The target code is a segment loader for a binary file format (NE), performing memory mapping and structure population without complex input parsing or character sequence processing. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs arithmetic (multiplication) on user-controlled data (`se->offset * bin->alignment`), which could theoretically overflow, but the context is different (file parsing vs. network protocol). The primary flaw patterns (integer overflow/wraparound) are not strongly mirrored in the target's simple multiplication.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a use-after-free caused by uninitialized pointers and error handling. The target code allocates memory (`R_NEW0`) and manages a list, but does not show complex error paths that could leave dangling pointers or double-free scenarios. The memory management pattern is simpler and more linear.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a race condition in a kernel filesystem's ID management. The target code is a single-threaded user-space function parsing static file data. There is no concurrency, shared state, or atomicity concerns present in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a network packet parser due to insufficient length validation. The target code reads from a structured array (`bin->segment_entries`) based on a header count (`SegCount`). While both parse data, the target lacks the complex TLV parsing and length field validation that is the core of the vulnerability in Case 5.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves a buffer overflow due to improper bounds checking on a negative value in a network parser. The target code copies no data; it populates a structure from another structure. The only potential similarity is the population of size fields from untrusted data (`se->length`, `se->minAllocSz`), but without subsequent buffer operations, the flaw pattern is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a use-after-free due to a race condition in kernel memory policy. The target code has no resource sharing, locking, or complex lifecycle management that could lead to a use-after-free in the manner described.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow due to incorrect size calculation in an image codec. The target code performs a size calculation (`se->offset * bin->alignment`) which could overflow, but this is not the central operation leading to a buffer write. The context and data flow (image encoding vs. binary metadata extraction) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a double-free in a file parser during error handling. The target code has an error path (`if (!bs) { return segments; }`) that could potentially leak the `segments` list if it has already been populated, but it does not free `bs`. The pattern of inconsistent state cleanup during errors is a weak similarity, but the specific double-free mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 involves improper input validation leading to memory corruption in a decompression module. The target code validates inputs (`if (!bin || !bin->segment_entries)`) and uses user-controlled values (`se->offset`, `bin->alignment`) in a multiplication for a memory address (`paddr`). This is a point where insufficient validation (e.g., ensuring the offset/alignment product doesn't overflow or point outside the file) could lead to issues later. The pattern of using untrusted data for critical calculations is a point of similarity, though the specific context differs.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2021-44512_after_exclude_100:5d54dcda:vulspec": {
    "timestamp": "2026-01-17T01:19:46.704508",
    "cve_id": "CVE-2021-44512",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5d54dcda",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a complex regex parsing engine vulnerability (CWE-125) due to improper NUL byte handling. The target code is a simple command-line argument parser with no regex processing, complex string parsing, or similar memory safety concerns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a protocol parsing vulnerability (CWE-787) involving integer overflows in network data handling (file transfer). The target code parses local command-line arguments using `getopt` and performs simple `atoi` conversions without any complex network protocol parsing or dynamic memory allocation based on user-controlled integers.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a Use-After-Free (CWE-416) in a network daemon's internal state management. The target code shows straightforward initialization and directory setup with no dynamic memory management, pointer manipulation, or complex error paths that could leave resources in an inconsistent state.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an Out-of-bounds Read (CWE-125) in a network packet decoder (tcpdump) due to insufficient validation of a TLV length field. The target code does not parse any binary network protocols or perform bounds-checked buffer reads from untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves improper error handling in privilege separation (CWE-20, CWE-250), where a failed initialization leads to continued execution with unnecessary privileges. The target code also performs initialization (directory creation, permission checks) and calls `tmate_fatal` on failure, which may exit. There is a superficial similarity in the pattern of checking initialization steps and handling errors, but the target code does not involve privilege dropping or separation.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Read (CWE-125) in an XML parser due to insufficient bounds checking. The target code contains no complex parsing logic, no processing of structured document formats, and no similar buffer manipulation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a Double Free (CWE-415) in a file parsing subsystem triggered by error conditions. The target code has no dynamic memory allocation/deallocation visible in the snippet, and its error handling calls a fatal function rather than performing complex cleanup.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an Out-of-bounds Read (CWE-125) in a character encoding parser. The target code does not process multi-byte character encodings, manage input buffers for text parsing, or have similar state transition logic.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an Improper Input Validation (CWE-20) issue in a network protocol parser, leading to potential memory corruption. The target code validates command-line arguments via `getopt` but does not parse binary network data or have analogous length-field validation bugs.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an Out-of-bounds Read (CWE-125) in an NFS protocol decoder due to insufficient bounds checking when copying data. The target code performs no similar operations of copying variable-length data from an untrusted source without proper bounds validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      }
    ]
  },
  "CVE-2021-44512_before_exclude_100:d39935c0:vulspec": {
    "timestamp": "2026-01-17T01:19:48.601752",
    "cve_id": "CVE-2021-44512",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d39935c0",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a complex regex parsing engine vulnerability (CWE-125) due to improper NUL byte handling. The target code is a simple command-line argument parser and directory setup routine with no regex processing, complex string parsing, or similar memory safety concerns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a protocol parsing vulnerability (CWE-787) involving integer overflows in network data handling (VNC file transfer). The target code parses local command-line arguments with `getopt` and performs basic system setup (mkdir, chmod). There is no network data parsing or complex integer arithmetic that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is a Use-After-Free (CWE-416) in a network daemon's internal state management. The target code initializes a program and calls into a server main function. While both involve daemon/service setup, the flaw patterns are dissimilar. The target code's simple, linear initialization lacks the complex state and error path cleanup that could lead to a UAF.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an Out-of-bounds Read (CWE-125) in a network protocol parser (tcpdump's LDP). The target code does not parse any network protocols or untrusted binary data. It handles trusted, string-based command-line arguments and performs filesystem operations.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 involves improper handling of privilege separation failure (CWE-20, CWE-250), causing the daemon to run with unnecessary privileges. The target code is also a daemon/service (tmate SSH server) that performs privileged operations like creating directories with specific modes. While the target code doesn't show explicit privilege dropping logic, the context (a server) and the consequence of running with elevated privileges on error paths are conceptually similar. The reference value lies in the error handling and security state management of daemons.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Read (CWE-125) in an XML parser due to incorrect bounds checking on tag processing. The target code contains no parsing of structured document formats and performs no operations that require similar bounds checking on complex input data.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a Double Free (CWE-415) in a file format parser (ClamAV's VBA extractor) triggered during error handling. The target code has simple, linear control flow for initialization and lacks dynamic memory management patterns (like `xstrdup` allocations are not freed in this snippet) that could lead to double-free vulnerabilities in error paths.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an Out-of-bounds Read (CWE-125) in a text/encoding parser (libxml2). Similar to other parser cases, the target code does not process multi-byte character encodings or manage input buffers in a way that could lead to similar bounds checking failures.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an Improper Input Validation (CWE-20) leading to potential memory issues in a network protocol parser (tcpdump's LMP). The target code validates command-line arguments via `getopt` switch but does not parse untrusted binary network data, which is the core context of the vulnerability case.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an Out-of-bounds Read (CWE-125) in a network protocol decoder (tcpdump's NFS) due to copying data without proper bounds checks. The target code performs no copying or processing of variable-length, untrusted binary data from network sources.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      }
    ]
  },
  "CVE-2022-0419_before_exclude_100:4bd4b3af:vulspec": {
    "timestamp": "2026-01-17T01:19:56.002148",
    "cve_id": "CVE-2022-0419",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4bd4b3af",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a file loader for Mach-O kernel caches, focusing on parsing and memory management without complex integer arithmetic or network data handling. The vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regex parser due to NUL byte mishandling. The target code parses structured binary data (Mach-O, prelink info) using dedicated parsers. The data sources, parsing logic, and potential flaw patterns (string vs. structured binary) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is a Use-After-Free due to inconsistent state management and cleanup during error handling. The target code has multiple error paths (`beach:` label) where resources (`fbuf`, `main_mach0`, `obj`, `prelink_range`, `prelink_info`) must be freed correctly. The pattern of allocating several resources and needing to clean them up on partial failure is similar, though the specific context differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow due to insufficient allocation size calculation. The target code uses buffer abstractions (`RBuffer`) and parses data at specified offsets/sizes. While there is a risk of miscalculating sizes or offsets when calling `r_cf_value_dict_parse`, the code pattern of direct buffer overflow in a low-level allocator is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is an out-of-bounds read in an XML parser due to incorrect bounds checking during tag processing. The target code parses binary formats with presumably validated offsets/sizes from the Mach-O header. The parsing models (text/grammar-based vs. binary/offset-based) and typical flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Similar to Case 5, this is an out-of-bounds read in a text parser (libxml2) related to character encoding. The target code handles binary data, not text encoding. The attack surface and underlying code patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds write in a binary data parser due to insufficient input validation. The target code parses binary data (`prelink_info`) from a buffer. There is a similarity in parsing untrusted binary data, but the specific vulnerability mechanism (hex string parsing overflow) and the code structure are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 8 is a Double Free due to inconsistent state management during error handling. This is highly relevant to the target code's structure. The function has multiple allocation points (`main_mach0`, `obj`, `prelink_info`, `pending_bin_files`) and a single error-handling block (`beach:`). If the cleanup logic is incorrect (e.g., freeing a pointer that was already freed or not set to NULL), a double-free or use-after-free could occur, similar to the ClamAV case.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 concerns improper buffer management and missing sentinel values. The target code uses `RBuffer` objects which abstract the underlying data. There is a potential relevance if the `r_cf_value_dict_parse` function or the `swizzle_io_read` function mishandles buffer boundaries, but the core issue of missing null terminators in string buffers is not directly visible in this code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a race condition in a kernel filesystem. The target code is a user-space file loading function with no evident concurrency or shared state manipulation. The vulnerability class is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2022-0419_after_exclude_100:4512c917:vulspec": {
    "timestamp": "2026-01-17T01:20:33.460535",
    "cve_id": "CVE-2022-0419",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4512c917",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code is a file loader for Mach-O kernel caches, focusing on parsing structured binary data and managing internal objects. The vulnerability types (CWE-787 vs. potential memory management errors), attack surfaces (network vs. local file), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 is an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code parses binary Mach-O and kernel cache structures, not text patterns. The functional domains (string parsing vs. binary format parsing) and the nature of the expected flaws (buffer over-read on text vs. logic/state errors on binary data) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 is a Use-After-Free (CWE-416) due to inconsistent state management during error handling. The target code has multiple error paths (`goto beach;`) where resources like `fbuf`, `main_mach0`, `obj`, and `prelink_range` must be freed correctly. The pattern of allocating several objects and needing to clean them up on failure is similar. However, the specific trigger (race condition vs. parsing error) and context (daemon vs. loader) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow (CWE-119) due to incorrect size calculation in an image codec. The target code allocates objects but does not show obvious buffer arithmetic. The relevance is limited to the general concept of parsing untrusted input (a kernel cache file) which could contain malformed data causing similar allocation/logic errors, but the specific flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds read (CWE-125) in an XML parser. The target code parses binary structures using functions like `r_cf_value_dict_parse`, which could theoretically have similar parsing bugs if the input buffer is malformed. However, the code abstraction level is higher, and the specific pattern of parsing nested tags/text is not analogous to parsing CF dictionaries or Mach-O headers.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Similar to Case 5, this is an out-of-bounds read in a text parser (libxml2). The target code deals with binary parsing. The connection is tangential: both involve parsing untrusted data. The lack of low-level byte-by-byte buffer manipulation in the shown target code reduces relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds write during hex string parsing. The target code parses binary data and CF (likely CoreFoundation) serialized data. While `r_cf_value_dict_parse` could contain similar parsing vulnerabilities if the `offset` and `size` from `prelink_range` are attacker-controlled, the shown code does not exhibit the direct buffer writing flaw. The relevance is speculative.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is a Double Free (CWE-415) due to inconsistent state management during error handling in a file parser. This is highly relevant to the target code's structure, which has a complex error handling block (`beach:`) that must correctly free multiple interconnected objects (`fbuf`, `main_mach0`, `obj`, `prelink_info`). A mistake in setting `obj->cache_buf = NULL` or in the order of freeing could lead to a double-free or use-after-free, mirroring the ClamAV case's error path flaw.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. Case 9 concerns improper buffer management and missing sentinels. The target code uses `RBuffer` objects, which abstract buffer handling. The relevance lies in the potential for the underlying buffer mechanisms or the parsed data (`prelink_info`) to be passed to functions expecting proper termination. However, this is not directly visible in the provided snippet. The primary similarity is the domain of low-level data parsing.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is a race condition (CWE-362) in a kernel filesystem. The target code is a user-space file loading function, unlikely to have concurrency issues at this level. The vulnerability patterns (atomicity vs. memory management) and context are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2021-37848_before_exclude_100:27abcad5:vulspec": {
    "timestamp": "2026-01-17T01:21:35.829466",
    "cve_id": "CVE-2021-37848",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "27abcad5",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a buffer overflow in a kernel FUSE ioctl handler due to insufficient validation of iovec lengths. The target code is a password checking function in user-space or possibly a kernel module, dealing with cryptographic operations and memory allocation. The vulnerability type (CWE-119), domain (filesystem vs. authentication), and code patterns (network buffer handling vs. hash comparison) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 involves an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs password hashing and comparison, using `calloc` for allocation. While both involve memory allocation and length calculations, the core flaw (integer wrap in allocation size vs. potential misuse of `strncmp` with binary data) and context (remote attack vs. local credential check) differ significantly. The target code's use of `hash_len * 2` is a simple multiplication, not a complex integer overflow source.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code processes binary password hashes, not string patterns. The vulnerability type (CWE-125), functionality (parsing vs. cryptography), and attack surface (malicious regex vs. password input) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a race condition in a filesystem's node ID management. The target function `check_passwd` appears to be a single-threaded, sequential operation with no evident concurrency or shared resource access. The vulnerability class (CWE-362) and code patterns (lock-free list operations vs. linear hash calculation) are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a NULL pointer dereference in a USB driver due to missing validation of device descriptors. The target code validates allocations (`calloc` check) and digest handles, but its primary logic is password verification, not hardware device interaction. The flaw pattern and domain are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference in a USB/IP network protocol handler due to insufficient validation of packet fields. The target code does validate function returns and allocations. The contexts (network packet processing vs. local password hashing) and specific flaw triggers are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a race condition leading to buffer overflow in the kernel TTY subsystem. The target code shows no evidence of concurrent writers or shared buffer manipulation between threads/processes. The vulnerability mechanism and subsystem are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to a NULL pointer dereference during keyring initialization. The target function `check_passwd` is a self-contained operation without shared global state that could be raced by concurrent callers in the same manner. The synchronization flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a double free caused by inconsistent memory ownership and error handling. The target code has a single `free(passwd1_sum)` in an error path, which is correct. However, both cases involve careful resource management (memory, digest handles) in functions with multiple error paths. The similarity is in the pattern of needing to clean up resources (`free`, `digest_free`) before returning, but the specific double-free flaw is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a NULL pointer dereference due to a race condition in a cluster filesystem's node management. The target code checks for NULL (`if (!d)`), frees resources, and has no evident concurrency or shared pointer access patterns like the `ci_parent` in the case. The flaw mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      }
    ]
  },
  "CVE-2021-37848_after_exclude_100:3e487a76:vulspec": {
    "timestamp": "2026-01-17T01:21:43.175415",
    "cve_id": "CVE-2021-37848",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3e487a76",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a buffer overflow in a kernel FUSE ioctl handler due to insufficient validation of iovec lengths. The target code is a password checking function in user-space or a simpler kernel module, dealing with cryptographic operations and memory allocation. The vulnerability type (CWE-119), context (filesystem), and attack surface (malicious server) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs password hashing and comparison. While both involve memory operations, the core flaw (integer overflow in allocation vs. potential misuse of crypto functions), domain (network protocol vs. authentication), and typical attack vectors are dissimilar. The only weak link is the generic concept of buffer handling.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code performs deterministic password hashing and comparison. The vulnerability class (CWE-125 vs. potential logic/ crypto errors), the data processing nature (parsing complex patterns vs. processing a byte buffer), and the resulting impact (info leak vs. authentication bypass) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a race condition in a filesystem's node ID management. The target code's `check_passwd` function appears to be a single-threaded authentication check. There is no indication of concurrent access to shared state (like the `passwd1_sum` buffer is local). The vulnerability paradigm (concurrency vs. sequential logic) and subsystem (filesystem metadata vs. security/ crypto) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a NULL pointer dereference in a USB driver due to missing validation of device descriptors. The target code validates its inputs (e.g., `digest_alloc` failure is checked) and uses `calloc`. The flaw type (CWE-476 from missing hardware descriptor checks vs. potential cryptographic side-channel or logic flaw), context (device driver vs. auth function), and attack surface (physical USB vs. password input) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference in a network USB virtualization subsystem due to insufficient validation of packet fields. Similar to Case 5, the target code does not exhibit obvious NULL dereference patterns from unvalidated external protocol data. The domains (network device virtualization vs. password verification) and the root cause (protocol validation failure) are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a race condition in the TTY subsystem leading to buffer overflow. The target code shows no evidence of concurrent writers to shared buffers or asynchronous workqueues. The `passwd1_sum` buffer is local to the function call. The vulnerability mechanism (concurrent write race) and subsystem (kernel terminal) are not applicable to the sequential password checking logic.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to a NULL pointer dereference during keyring initialization. Again, the target code shows no signs of shared global state that could be accessed concurrently without synchronization. The function uses local variables and allocated memory. The context (kernel security subsystem data structures) and flaw pattern (concurrent initialization race) are not present.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is a double-free due to confused ownership and error handling. The target code has a single `free(passwd1_sum)` in an error path (`err:` label). While not a double-free, the pattern of `goto err` for cleanup after multiple failure points is similar. The risk of incorrect cleanup (e.g., freeing `d` if `digest_alloc` fails but `passwd1_sum` allocation succeeds) exists but is mitigated by the current code flow. The core flaw (double-free) is not identical, but the error handling pattern is a common source of bugs, providing some reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a NULL pointer dereference caused by a race condition in a cluster filesystem configuration manager. Similar to other concurrency cases, the target code's `check_passwd` function does not operate on shared global structures like `ci_parent` without locks. The context (cluster node management) and the specific flaw pattern (TOCTOU on a pointer within a config item) are irrelevant to the password verification routine.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      }
    ]
  },
  "CVE-2022-1968_before_exclude_100:27578fbc:vulspec": {
    "timestamp": "2026-01-17T01:22:07.504292",
    "cve_id": "CVE-2022-1968",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "27578fbc",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve regular expression compilation (vim_regcomp) and pattern matching (vim_regexec). The target code uses regex for include patterns and search patterns, similar to Perl's regex engine. However, the specific vulnerability (CWE-125 from NUL bytes) is not directly mirrored, as Vim's regex engine may handle NUL differently. The pattern handling and compilation phases are analogous.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code is a file search/pattern matching function in an editor, not a network daemon. The vulnerability (CWE-416 Use After Free) in MiniSSDPd relates to socket message handling and inconsistent state cleanup. The target code manages a stack of file pointers and names with manual allocation/free, but the error paths and cleanup logic are different, with no clear use-after-free pattern evident.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing structured text (XML vs. C source code includes). The target code parses lines for include directives and definitions using regex, but does not have a nested tag structure like XML. The CWE-125 (Out-of-bounds Read) in libxml2 arises from end tag parsing without bounds checks. The target code uses string functions with length checks (e.g., STRLEN), but similar bounds issues could occur if line buffers are mishandled.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Similar to case 3, both involve parsing text with encoding considerations. The target code reads file lines into a fixed-size buffer (LSIZE) and processes them, which could lead to CWE-125 if buffer boundaries are not respected. However, the specific issue in libxml2 (multi-byte character processing) is not present here, as Vim handles character encoding differently. The reference value is limited.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The vulnerability (CWE-787 Out-of-bounds Write due to integer overflow) in LibVNC is related to network protocol handling and memory allocation for file transfers. The target code performs file search and pattern matching, with allocations for paths and regex patterns, but no complex integer calculations for buffer sizes. The attack surface and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing structured data (LDP TLVs vs. include patterns) and validating length fields. The target code extracts file names from lines using regex matches and pointer arithmetic, which could lead to CWE-125 if start/end pointers are incorrect (e.g., incl_regmatch.startp[0] and endp[0] used without validation). However, the context (network protocol vs. source code parsing) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve regular expression compilation and state handling (glibc's regcomp vs. Vim's vim_regcomp). The vulnerability (CWE-19 Data Processing Errors) in glibc relates to backreference state across alternatives. The target code compiles patterns for include/define matching, and while it doesn't handle backreferences, similar regex engine flaws could exist in pattern compilation or matching (regmatch.regprog).",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The vulnerability (CWE-416 Use After Free) in libxml2's SAX2 parser involves attribute memory management during parser state changes. The target code manages a stack of file structures (SearchedFile) with manual allocation/free, but there is no complex parser state with attributes or entities. The cleanup in fpip_end frees resources consistently, reducing similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve pathname processing (glob expansion vs. file search in include paths). The vulnerability (CWE-122 Heap Buffer Overflow due to off-by-one) in glibc's glob relates to home directory expansion. The target code constructs file paths (new_fname) and uses alloc/mch_fopen, but no obvious off-by-one allocation is present. However, path handling errors could lead to similar memory issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The vulnerability (CWE-415 Double Free) in ClamAV's VBA extractor occurs during error cleanup of project strings. The target code has cleanup paths (fpip_end) that free regex programs and buffers, but uses vim_free consistently without double-free patterns. The error handling in the target code uses goto for cleanup, which generally prevents double-free, unlike the inconsistent state in ClamAV.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2022-1968_after_exclude_100:3d64fc56:vulspec": {
    "timestamp": "2026-01-17T01:22:18.068958",
    "cve_id": "CVE-2022-1968",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3d64fc56",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve regular expression compilation (vim_regcomp vs regcomp.c) and potential issues with pattern parsing. Target code uses vim_regcomp for include/define patterns, similar to Perl's regex engine. However, the specific vulnerability (CWE-125 from NUL bytes) is not directly mirrored in Vim's regex handling shown here, though regex compilation is a shared attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case involves Use-After-Free in a network daemon's memory management. Target code is a file search function in an editor with careful stack-based file management and cleanup (fclose, vim_free). No dynamic memory reallocation errors or similar state corruption patterns are evident.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing structured text (XML vs source code for includes). Target code parses lines for include/define patterns using regex matches and pointer arithmetic (e.g., p[i] accesses). There's some similarity in bounds checking concerns when isolating filenames (save_char = p[i]; p[i] = NUL), but the domain and specific flaw (OOB read in end tags) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Similar to case 3, involves parsing and buffer management. Target code reads lines into fixed-size buffer (LSIZE) via vim_fgets and processes them. Potential for OOB read exists if lines exceed LSIZE, but the code uses vim_fgets which limits input. The character encoding complexity of libxml2 is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case involves integer overflow leading to OOB write in network protocol handling. Target code performs file search with count parameter (long type) but no dangerous arithmetic or dynamic allocations based on user-controlled integers. Memory allocations use fixed sizes or lalloc_clear.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing structured data with length fields. Target code extracts filenames from lines using pointer arithmetic and length calculations (i = (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0])). It does bounds checking (p > line) and uses save_char to safely truncate. Similar pattern of validating bounds before access, but the protocol context is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve regular expression parsing state issues. Target code compiles multiple regexes (for pattern, include, define) and uses them with vim_regexec. The flaw in glibc's regcomp about state handling (backreferences) isn't directly applicable, but improper regex compilation/execution could lead to similar memory safety issues if vim_regcomp has vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case involves Use-After-Free in XML attribute parsing. Target code manages a stack of SearchedFile structs with explicit fopen/fclose and vim_free. No complex object lifecycle or reference issues similar to libxml2's SAX parser. Memory is freed only after fclose in cleanup loops.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve pathname processing. Target code finds files in path (find_file_name_in_path, file_name_in_line) and opens them. However, it doesn't do wildcard expansion or tilde expansion like glob. Buffer allocations are for fixed-size patterns or line buffers, not dynamically calculated path lengths that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case involves Double Free in document parser error handling. Target code has clean-up sections (fpip_end) that free resources using vim_free and vim_regfree, but all freeing happens once at the end or in error goto. No reallocation or freeing of the same pointer in different error paths is evident.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2021-37639_before_exclude_100:bb8824b9:vulspec": {
    "timestamp": "2026-01-17T01:22:22.876202",
    "cve_id": "CVE-2021-37639",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bb8824b9",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a stack buffer overflow in a Bluetooth configuration parser (CWE-119). The target code is a TensorFlow checkpoint restoration function that reads from files and copies slice data. The core vulnerability type (buffer overflow vs. potential file/input validation issues), domain (system utility vs. ML framework), and code patterns (string parsing vs. tensor operations) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is an integer overflow in a file parser (CWE-190). The target code performs tensor shape calculations and memory allocation based on file input. There is a tangential similarity: both process external file data which could contain maliciously large values leading to issues during size calculations or memory allocation (e.g., in `output_shape.num_elements()` or `context->allocate_output`). However, the specific vulnerability pattern and domain differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a type confusion vulnerability (CWE-704) in a document renderer. The target code uses strongly typed TensorFlow data types (via `DataType` enum) and performs type checks (`OP_REQUIRES` on `type`). The code patterns and vulnerability root cause (lack of type verification vs. explicit type checking) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-19477"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a resource management error (CWE-399) in a subtitle renderer related to inconsistent memory tracking. The target code manages resources (file readers, tensor memory) but uses RAII patterns (`std::unique_ptr`) and explicit allocation checks. The flaw pattern (inconsistent internal state tracking) does not align with the target code's structure.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer management flaw (CWE-119) in a network library related to missing sentinel values. The target code copies data into a pre-allocated tensor buffer via `reader->CopySliceData`. While both involve copying data, the vulnerability mechanism (missing null termination) and context (network buffers vs. structured tensor data) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference (CWE-476) in a regex library due to inconsistent error state handling. The target code uses `OP_REQUIRES` and `OP_REQUIRES_OK` for error checking, which propagates statuses. The `CHECK_NOTNULL` macro also guards against NULL readers. The error handling patterns are different and robust in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a use-after-free (CWE-416) in a database library during asynchronous I/O. The target code uses synchronous operations and local variables (`allocated_reader`, `tensor_name`). The `tensor_name` is a reference to data within a Tensor input, which is managed by the OpKernelContext lifecycle, reducing UAF risk in this snippet.",
        "case_metadata": {
          "cve_id": "CVE-2019-25085"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is an out-of-bounds write (CWE-787) in an image codec due to insufficient buffer size validation. The target code calls `reader->CopySliceData` into the tensor's flat data buffer. If `CopySliceData` does not properly validate the slice against the destination tensor's allocated size, a similar buffer overflow could occur. The pattern of copying external data into a fixed-size buffer is analogous, though the specific context differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is an out-of-bounds read (CWE-119) due to incorrect length validation when processing Pascal strings from a file. The target code reads a tensor name and shape spec from input tensors, which are ultimately derived from checkpoint files. If the `reader->CopySliceData` implementation or the parsing of `shape_spec` (via `checkpoint::ParseShapeAndSlice`) contains similar insufficient bounds checking when interpreting file data, it could lead to analogous memory safety issues. The pattern of parsing untrusted file content with complex structure is shared.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an improper input validation (CWE-20) leading to unnecessary privilege execution in a network daemon. The target code runs within a TensorFlow op kernel, which has no concept of privilege separation. The vulnerability pattern (state validation failure leading to escalated privileges) does not apply to the resource restoration functionality shown.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2021-37639_after_exclude_100:647fe65c:vulspec": {
    "timestamp": "2026-01-17T01:23:12.612598",
    "cve_id": "CVE-2021-37639",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "647fe65c",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 is a classic stack-based buffer overflow in a parsing function for Bluetooth configuration. The target code is a TensorFlow checkpoint restoration function that performs input validation (OP_REQUIRES) and uses managed data structures. The vulnerability patterns (raw buffer overflow vs. library-managed tensor operations) and domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves an integer overflow in archive file parsing leading to miscalculated positions. The target code performs bounds checks on tensor indices and element counts, but does involve calculations with tensor shapes and slices. There is a superficial similarity in processing external data (checkpoint files), but the specific flaw (integer overflow in position calculation) is not evident in the provided code, which uses TensorFlow's safe shape and slice abstractions.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a type confusion vulnerability in a document rendering engine. The target code uses strongly typed C++ classes and templates (Tensor, tstring) with explicit type checks (OP_REQUIRES on DataType). The code patterns (type casting vs. template specialization) and domains (image decoding vs. tensor serialization) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-19477"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a resource management error in a subtitle renderer involving inconsistent memory tracking. The target code uses RAII (std::unique_ptr) for the allocated_reader and relies on TensorFlow's memory management for outputs. The flaw pattern (manual size tracking errors) does not match the resource patterns in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer management issue in a network library involving missing sentinel values. The target code works with string objects and tensor buffers managed by the TensorFlow runtime, not raw C buffers. The vulnerability mechanism (string function expectations on raw buffers) is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference due to inconsistent error state handling in a regex library. The target code uses OP_REQUIRES_OK and CHECK_NOTNULL for error propagation and null checks. While both involve error handling, the specific flaw pattern (returning an error code without setting error info) is not present in the linear, validation-heavy target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a use-after-free in an asynchronous file writer. The target code performs synchronous file operations via the TensorSliceReader and has clear ownership (allocated_reader unique_ptr). The concurrency and lifecycle flaw pattern does not match.",
        "case_metadata": {
          "cve_id": "CVE-2019-25085"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an out-of-bounds write due to insufficient buffer size validation when writing image data. The target code writes tensor data via reader->CopySliceData, where buffer sizes are determined by previously validated output_shape. There is a conceptual similarity in writing data from a parsed format into an allocated buffer, but the target code's buffer allocation (context->allocate_output) is tightly coupled with the calculated shape, reducing the risk surface. The specific missing validation flaw is not apparent.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is an out-of-bounds read due to incorrect length validation when processing Pascal strings from file data. The target code reads tensor data from checkpoint files based on shapes and slices parsed from the file. While both involve parsing untrusted file formats, the target code uses higher-level abstractions (TensorShape, TensorSlice) and validates that parsed_shape matches saved_shape. The core flaw pattern (off-by-one or miscalculated buffer space) is not directly visible, but the act of parsing shape specifications (shape_spec) from input and using them to calculate memory ranges presents a similar trust boundary.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a privilege management error where a daemon continues with elevated privileges after a failure. The target code is a kernel operation within a larger framework with no privilege separation logic. The domains (system security vs. data loading) and flaw patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2020-35981_before_exclude_100:6e04d51e:vulspec": {
    "timestamp": "2026-01-17T01:23:29.484482",
    "cve_id": "CVE-2020-35981",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6e04d51e",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves Use-After-Free due to uninitialized pointers and inconsistent state management during error handling. The target code has error handling (`goto exit`) and memory allocation (`GF_SAFEALLOC`), but the primary patterns (pointer lifecycle management, complex error state cleanup) are not strongly similar. The target code's main risks are different (memory exhaustion, null pointer dereference on allocation failure).",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 2 is a heap buffer overflow due to insufficient padding allocation in an image codec. The target code deals with multimedia container (MP4) writing and has memory allocations (`gf_isom_box_new`), but the vulnerability pattern (incorrect size calculation for a specialized buffer) is not present. Both handle media data, but the flaw mechanisms differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 involves an out-of-bounds write due to integer overflow in memory allocation. The target code performs multiple allocations and tracks counts (`trackCount`, `sampleCount`). While no obvious integer overflow is seen, the pattern of allocating based on file/stream metadata is similar. The risk of corrupted/malicious `movie` input leading to oversized allocations or loops exists, providing some reference value for input validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 4 is an out-of-bounds write in the GPAC framework itself, specifically in text processing. The target code is from the same GPAC framework (SetupWriters function). The coding style, error handling patterns (`GF_Err`, `GF_SAFEALLOC`, `goto exit`), and memory management conventions are identical. This provides high reference value for understanding the framework's common vulnerability patterns, though the specific subsystem (text import vs. MP4 writer) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a regex engine due to NUL byte handling. The target code does not parse complex strings or regular expressions. The data structures and operations (box-based media container writing vs. character pattern compilation) are fundamentally different, offering little reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a memory allocation failure due to unchecked header values in an image parser. The target code reads from a potentially parsed `movie` structure. The similarity lies in processing untrusted file metadata (`trackCount`, `sampleCount`) without explicit validation shown. However, the context (image decoding vs. container writing) and specific flaw (header value causing massive allocation) are not directly analogous.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds write in a JPEG 2000 encoder due to insufficient buffer validation. The target code writes MP4 box data and allocates structures (`stsc`, `stco`). The pattern of writing formatted data based on input parameters is similar, but the target code's writes are into newly allocated heap objects, not into pre-existing buffers of limited size, making the overflow mechanism less relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a buffer overflow in an image library due to integer underflow/overflow in bounds checking. The target code performs arithmetic (`writer->constant_dur>1`) and tracks sizes, but the complex integer flaw pattern is not evident. Both handle media data, but the vulnerability root cause (arithmetic error in loop/size calculation) is not prominently mirrored in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a buffer overread in a network library due to missing sentinel values. The target code manages lists and writes data but does not use null-terminated strings or sentinel values in a similar way. The memory management patterns (allocating structures, adding to lists) are generic and not specific to the sentinel-related flaw.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an out-of-bounds read in an XML parser due to improper bounds checking during multi-byte character processing. The target code does not parse character encodings or perform byte-by-byte buffer reads. The operations are at a higher level (box structures, track metadata). The reference value is low.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2020-35981_after_exclude_100:b15f3320:vulspec": {
    "timestamp": "2026-01-17T01:23:55.827564",
    "cve_id": "CVE-2020-35981",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b15f3320",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves Use-After-Free due to uninitialized pointers and inconsistent state management during error handling. The target code has error handling (`goto exit` on allocation failure) and uses `GF_SAFEALLOC` which likely zeroes memory, reducing UAF risk. The primary similarity is error path resource cleanup, but the vulnerability patterns differ significantly (network protocol vs. media file parsing).",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is a heap buffer overflow due to insufficient padding allocation in an image codec. The target code performs media structure validation and memory allocation but does not involve complex buffer size calculations or padding. Both handle multimedia data, but the flaw patterns differ (allocation math error vs. missing null checks and pointer validation).",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves an integer overflow leading to out-of-bounds write in a network protocol handler. The target code uses 32-bit counters for track and sample counts but does not perform arithmetic that could overflow before allocation. Both process structured input (media vs. network packets), but the vulnerability mechanism (integer wrap in allocation) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 4 is an out-of-bounds write in GPAC's text processing due to missing error return validation. The target code is from the same GPAC project and shares error handling patterns (returning error codes like `GF_OUT_OF_MEM`). Both involve parsing structured data (media boxes vs. text). However, the specific flaw (unsafe buffer copy on error) is not directly visible in this function.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a regex engine due to improper NUL byte handling. The target code parses media container structures, not text patterns, and does not involve string processing or character encoding issues. No meaningful similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 involves a memory allocation failure due to unchecked header values in an image parser. The target code validates media structures (`if (!stbl || !stbl->SampleSize ...)`), which is conceptually similar to header validation. Both are file format parsers that must validate input structures before use. However, the flaw (unchecked integer leading to huge allocation) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 7 is an out-of-bounds write in a JPEG 2000 encoder due to missing buffer size validation. The target code writes media structures (STSC, STCO boxes) but uses safe allocation via `gf_isom_box_new`. Both involve writing format-specific data structures. The similarity is in multimedia output generation, but the target code does not show buffer size calculations that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2017-14164"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a buffer overflow due to arithmetic underflow in image processing. The target code performs arithmetic (`writer->constant_dur>1`) but with simple comparisons, not complex size calculations. Both are multimedia-related, but the vulnerability pattern (integer underflow in buffer size check) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 involves missing sentinel values leading to buffer overreads in a network buffer system. The target code manages track writer structures in a list but does not involve string handling or sentinel termination. Both manage data structures in memory, but the flaw (missing null termination) is not applicable to this code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an out-of-bounds read in an XML parser due to improper bounds checking during multi-byte character processing. The target code parses binary media structures, not text/character data. Both are parsers for structured formats, but the vulnerability mechanism (encoding-specific buffer over-read) is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      }
    ]
  },
  "CVE-2015-1791_before_exclude_100:fda9a67c:vulspec": {
    "timestamp": "2026-01-17T01:24:03.156014",
    "cve_id": "CVE-2015-1791",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "fda9a67c",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing network messages and length validation, but the vulnerability types differ significantly. Case 1 is an integer overflow leading to out-of-bounds write during memory allocation. The target code performs length checks (ticklen + 6 != n) and uses OPENSSL_malloc, which is safer against integer overflows in allocation size. The core flaw patterns are not identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve parsing protocol messages (LDP TLV vs. SSL Ticket) and validating length fields against the total message size. The vulnerability in Case 2 is an out-of-bounds read due to insufficient length validation. The target code has explicit length checks (ticklen + 6 != n), making it more robust, but the pattern of parsing a length field and then using it is similar. The reference value is in the importance of rigorous length validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 involves buffer over-reads in a regex engine due to improper NUL byte handling. The target code is a network protocol parser that uses explicit length fields and memcpy with a validated size. The domains (string parsing vs. binary protocol parsing) and vulnerability triggers are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing data from a network source (DNS vs. SSL). Case 4's flaw is an integer overflow in a length calculation leading to an out-of-bounds write. The target code's length calculations (ticklen + 6) are simple additions checked against a 16-bit `n` (from `n2s`), making an integer overflow less likely but not impossible if `ticklen` is maliciously large. The similarity is in the general risk of arithmetic on untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are network protocol parsers (SSH vs. SSL/TLS). Case 5's flaw is an integer overflow in a bounds check (`datalen-13`). The target code has a similar pattern of checking `ticklen + 6 != n`, where if `ticklen` is very large (e.g., near UINT16_MAX), the addition could wrap, causing the check to pass incorrectly. This is a potential, though less direct, similarity in vulnerability logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in an XML parser due to complex character encoding state issues. The target code performs straightforward binary copying with explicit, validated lengths. The code patterns and vulnerability mechanisms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve parsing options/TLVs in network protocols (IPv6 RA vs. SSL Ticket). Case 7's flaw is a buffer copy without checking size of input, specifically with a negative length. The target code validates `ticklen` against the total message length `n` before the memcpy, which is the correct mitigation for such issues. The pattern of parsing a length and then copying is directly comparable, making it a good positive reference for secure coding.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a state management flaw (improper cleanup) in a complex network protocol state machine. The target code is a simpler, single-message handler with linear error paths (`goto f_err`, `goto err`). The vulnerability classes are different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2206"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a use-after-free due to error handling and inconsistent state management. The target code's error handling frees memory (`OPENSSL_free`) only if it was previously allocated, and otherwise uses goto for cleanup. The patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an infinite loop due to circular compression pointers in DNS. The target code has no loops or recursion in its parsing logic; it linearly processes a fixed-format ticket. The vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      }
    ]
  },
  "CVE-2015-1791_after_exclude_100:5dd7052e:vulspec": {
    "timestamp": "2026-01-17T01:24:08.627680",
    "cve_id": "CVE-2015-1791",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5dd7052e",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing network messages and integer handling, but the core flaw differs. Case 1 is an integer overflow leading to an out-of-bounds write during memory allocation. The target code performs length checks (`ticklen + 6 != n`) and uses safe memory allocation (`OPENSSL_malloc`), making a direct integer overflow/wraparound vulnerability less likely in the same pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing protocol messages (LDP vs. TLS) and validating length fields. The target code has explicit length validation (`if (ticklen + 6 != n)`). However, the core CWE-125 (Out-of-bounds Read) from Case 2 is not directly mirrored, as the target code uses `memcpy` with a validated length. The similarity lies in the pattern of parsing a TLV-like structure (lifetime_hint + length + ticket).",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves parsing regex patterns with embedded NUL bytes leading to an out-of-bounds read. The target code processes binary TLS tickets where NUL bytes are valid data. The code patterns (string parsing vs. binary buffer handling) and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing network protocol data (DNS vs. TLS) and performing length calculations. The integer overflow (CWE-190) leading to out-of-bounds write in Case 4 is a critical flaw. The target code's calculation `ticklen + 6 != n` is checked with `n` being a signed long derived from the message length, which could theoretically overflow if `n` is very large, but the pattern is not identical to the domain name length calculation flaw.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing messages in a security protocol (SSH vs. TLS) and integer arithmetic in validation. Case 5's flaw is an integer overflow in a bounds check (`message_len < datalen-13`). The target code's check `ticklen + 6 != n` could be vulnerable if `ticklen` is very large (near INT_MAX), causing an integer overflow in the addition, but `n` is limited by `ssl_get_message` (max 16384). The pattern of validating a length field against a total message size is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in an XML parser due to improper buffer management during character encoding. The target code handles binary data with explicit length fields and uses `memcpy`. The domains (text parsing vs. binary protocol parsing) and flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve parsing network protocol options/messages (IPv6 RA vs. TLS Ticket) and copying data based on a length field. Case 7's flaw is a negative length leading to a large copy. The target code uses an unsigned `ticklen` (from `n2s`), so a negative value would become a large positive value, but it is validated against `n`. The pattern of copying a variable-length field is similar, but the specific trigger (signedness issue) is not directly present.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a state management flaw (CWE-703) in a network protocol (SCTP) leading to improper cleanup. The target code is a straightforward TLS message handler with linear error paths (`goto f_err/err`). The complexity of state machines and association management in SCTP is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2013-2206"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a Use-After-Free (CWE-416) due to error path inconsistencies. The target code has error paths that free memory (`OPENSSL_free`) and set pointers to NULL or zero length before allocation, and uses `goto` for cleanup. While both have error handling, the specific pattern of double-free or use-after-free from inconsistent state is not evident in the provided target function.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an infinite loop (CWE-835) due to circular compression pointers in DNS. The target code has no loops or recursion in its parsing logic; it performs linear reads and copies. The vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      }
    ]
  },
  "CVE-2014-0142_before_exclude_100:10274b2d:vulspec": {
    "timestamp": "2026-01-17T01:25:00.438473",
    "cve_id": "CVE-2014-0142",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "10274b2d",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve integer handling issues (CWE-190) in memory allocation size calculations. The target code checks `s->catalog_size > INT_MAX / 4` to prevent overflow, which is a defensive pattern against the type of vulnerability (integer overflow leading to undersized allocation) seen in CVE-2018-20750. The context (file format parsing) and the flaw pattern (size validation before allocation) are similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is about out-of-bounds read due to improper NUL byte handling in a string parsing context (regex). The target code performs binary reads of a header and a catalog, with no apparent string parsing or similar boundary confusion issues. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free vulnerability related to inconsistent state management during error handling. The target code has a simple error path (`fail:` label) that frees `s->catalog_bitmap` and returns. While both involve cleanup on error, the target code's pattern is straightforward and does not exhibit the complex state inconsistency or double-free flaw present in the case.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in a kernel FUSE component due to insufficient validation of iovec lengths. The target code performs bounded reads (`bdrv_pread`) based on a previously validated size (`s->catalog_size * 4`). The domains (kernel vs. block driver), vulnerability patterns (complex iovec manipulation vs. simple size check), and attack surfaces are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in a kernel filesystem's resource management. The target code is part of a block driver's open function, which is not inherently concurrent (typically called during setup). There is no evidence of shared state or check-then-use patterns that could lead to a race condition. The vulnerability categories are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve parsing a file/disk image format (CAB vs. Parallels disk image) and include bounds checking to prevent memory corruption. CVE-2010-1311's root cause is improper input validation (CWE-20) during decompression, leading to out-of-bounds write. The target code shows input validation (magic, version, catalog size check) to prevent malformed images from causing issues, sharing the defensive theme, though the specific flaw mechanics differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1003 is a double-free in an error path. The target code has a single error path that frees `s->catalog_bitmap` only if it was allocated (note: `g_free` on NULL is safe). The pattern is simple and avoids the double-free flaw. The connection is only at the abstract level of having error cleanup paths.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. Both CVE-2013-2124 and the target code are in the domain of virtual machine/disk image processing (libguestfs vs. QEMU block driver). Both involve reading structures from files. The vulnerability in the case is a double-free due to complex ownership issues, while the target code's error handling is simpler. The domain similarity provides some reference value for safe file parsing patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking during tag parsing. The target code reads binary structures with explicit size calculations and uses `bdrv_pread` which should handle bounds. The data formats (structured text vs. binary) and vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. While the target code also validates a length field (`ph.catalog_entries`), it does so against a fixed limit (`INT_MAX / 4`) before using it, which is the correct mitigation for the type of flaw in the case. The contexts (network packet vs. disk image) are different, but the high-level principle of validating externally controlled sizes is shared.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2014-0142_after_exclude_100:a2f73e08:vulspec": {
    "timestamp": "2026-01-17T01:25:19.075147",
    "cve_id": "CVE-2014-0142",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a2f73e08",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve integer overflow/truncation in size calculations leading to memory allocation issues. Target code has `s->catalog_size > INT_MAX / 4` check to prevent overflow, similar to CVE-2018-20750's integer handling flaw. However, the target code's overflow check is correct, while the CVE case had a missing check. Both are in file format parsers (disk image vs. VNC file transfer).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read due to NUL byte handling in regex parsing. Target code deals with disk image header validation and catalog reading with explicit bounds checking via `bdrv_pread`. No regex parsing or NUL byte issues present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve error handling and resource cleanup. Target code has `goto fail` pattern with `g_free` cleanup, similar to use-after-free/double-free scenarios. However, CVE-2016-3179's specific use-after-free due to uninitialized pointers and inconsistent state management is not present in the simpler target error path.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2010-4650 involves buffer overflow in kernel FUSE ioctl due to insufficient iovec length validation. Target code reads fixed-size header and catalog with explicit size calculations and checks. No iovec or similar complex buffer management.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in filesystem metadata management. Target code is a synchronous open function with no concurrency (uses `qemu_co_mutex_init` but only initializes it). No race condition patterns or concurrent operations.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve file format parsing with bounds checking. CVE-2010-1311 is about decompression window boundary validation, while target code validates catalog size against INT_MAX/4 and reads with `bdrv_pread`. Both have input validation themes, but compression vs. simple catalog reading differs.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve error handling and memory management. CVE-2011-1003 is a double-free during error conditions in document parsing. Target code has `goto fail` with `g_free` but only frees once. Similar error path patterns but different vulnerability types.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are in virtual disk image processing libraries (libguestfs vs. QEMU's parallels driver). Both involve file reading and error handling. CVE-2013-2124 is a double-free in file content processing, while target code has careful `g_free` in fail path. Similar domain increases relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 involves out-of-bounds read in XML tag parsing. Target code reads binary structures with explicit size validation (`memcmp`, `le32_to_cpu`). No string parsing or similar boundary issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-14461 involves out-of-bounds read in network protocol TLV parsing due to insufficient length validation. Target code validates header magic/version and catalog size, then reads with `bdrv_pread`. Different domains (network vs. disk image) and parsing patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-21723_before_exclude_100:b484ad34:vulspec": {
    "timestamp": "2026-01-17T01:25:58.994199",
    "cve_id": "CVE-2022-21723",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b484ad34",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve input parsing and potential issues with NUL bytes. CVE-2018-18313 is an out-of-bounds read triggered by embedded NUL bytes in regex patterns. The target code checks for a NUL byte (`if (!chr)`) and calls an error function, which might be a defensive measure against similar issues. However, the vulnerability types differ (OOB read vs. potential logic error/DoS from syntax error), and the code patterns are not identical. The target code's primary function is character scanning, not complex pattern compilation.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write. The target code performs simple pointer arithmetic (`++scanner->curptr`) but does not involve any complex size calculations, memory allocation, or integer operations that could overflow. The functionality and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free/double-free related to complex state and memory management during error handling. The target code is a simple, synchronous function that does not perform dynamic memory allocation, freeing, or maintain complex state that could lead to such issues. No meaningful similarity in vulnerability type or code pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-1833 is an out-of-bounds read in a parser due to inadequate bounds checking during character processing. The target code is a character scanner for a parser. It reads a character from `scanner->curptr` without explicitly checking if it's within a defined buffer limit before dereferencing. It relies on a NUL terminator to signal an error. This pattern of sequential character reading without explicit bounds checking is a common root cause for OOB reads. The relevance is significant, though the specific encoding complexity of libxml2 is absent here.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Similar to Case 5, CVE-2016-1838 is an out-of-bounds read in a parser (libxml2) due to insufficient bounds checking. The target code performs a core parsing operation (get next char) and shares the conceptual risk of advancing a pointer (`curptr`) without verifying it hasn't exceeded a buffer boundary. The function assumes the caller or surrounding context manages the buffer limit, which is a similar architectural assumption that can lead to vulnerabilities if violated. The scoring is similar to Case 5.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-18249 is a concurrency-based race condition in a kernel filesystem module. The target code is a simple, non-reentrant function with no thread-safety mechanisms (no locks, no atomic operations) and operates on a local scanner structure. There is no similarity in vulnerability type (race condition vs. memory safety/input validation), domain, or code pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-1003 is a double-free during error handling in a file parser. The target code does not involve any dynamic memory allocation or freeing. Its error handling (`pj_scan_syntax_err`) is not shown to manipulate memory in a way that could cause a double-free. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-16161 is a NULL pointer dereference due to inconsistent error state handling. The target code could theoretically have a NULL pointer dereference if `scanner` or `scanner->curptr` were NULL, but the function does not validate these inputs. This is a tangential similarity (missing null checks on input parameters), but the core flaw and trigger conditions (complex regex error state vs. simple pointer access) are very different. The primary vulnerability pattern in the target is more related to bounds checking than null pointer dereference.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free during error handling in a file reading utility. Similar to Case 8, the target code contains no memory deallocation logic. The function `pj_scan_syntax_err` might log or set an error, but without its implementation, linking it to a double-free is speculative and not supported by the code pattern shown.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2022-1734_before_exclude_100:460c66d9:vulspec": {
    "timestamp": "2026-01-17T01:26:34.280231",
    "cve_id": "CVE-2022-1734",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "460c66d9",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 is a buffer overflow (CWE-119) in FUSE ioctl handling due to insufficient validation of iovec lengths. The target code is a device cleanup function with no buffer operations, length validations, or similar patterns.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is about improper input validation (CWE-20) leading to unnecessary privilege execution (CWE-250) during daemon initialization. The target code performs resource cleanup and de-registration with no privilege management or input validation logic.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read (CWE-125) in a network protocol parser due to missing length validation. The target code has no packet parsing, length checks, or buffer access patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-13687"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 (duplicate of Case 2) involves improper validation of security state during daemon initialization. The target code is a cleanup function with no state validation or security transition logic.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an integer overflow (CWE-190) leading to out-of-bounds write in DNS name parsing. The target code performs simple pointer assignments and function calls with no arithmetic operations or length calculations.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a use-after-free (CWE-416) enabled by uninitialized pointers and improper cleanup. The target code involves resource cleanup (freeing memory, unregistering devices) which shares the domain of resource management. However, the specific flaw pattern (use-after-free vs. proper cleanup) and context (error handling vs. normal teardown) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read (CWE-125) in a wireless protocol parser due to missing bounds checks. The target code has no protocol parsing, bounds checking, or similar memory access patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-16227"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a reachable assertion (CWE-617) due to improper input validation in DNS parsing. The target code has no assertions, input validation, or protocol parsing logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-25037"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an infinite loop (CWE-835) in DNS compression pointer handling. The target code has no loops, recursion, or compression logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read (CWE-125) in a network protocol decoder due to missing length validation. The target code performs device cleanup with no protocol decoding or length validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-13052"
        }
      }
    ]
  },
  "CVE-2022-21723_after_exclude_100:5f922726:vulspec": {
    "timestamp": "2026-01-17T01:26:40.597618",
    "cve_id": "CVE-2022-21723",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5f922726",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing/scanning and potential out-of-bounds reads, but the vulnerability contexts differ significantly. Case 1 is about regex parsing with embedded NUL bytes leading to over-reads, while the target code is a generic character scanner. The core flaw (improper NUL handling in regex) is not present in the simple, linear scanner code.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to out-of-bounds write during file transfer. The target code performs simple character reading and whitespace skipping with no complex arithmetic, memory allocation, or write operations. The vulnerability types (CWE-787 vs. potential CWE-125) and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing external data (file vs. generic input) and share CWE-125 (Out-of-bounds Read) as a potential concern. However, the trigger is different: Case 3 exploits improper string termination validation in a complex file format parser, while the target scanner has simpler bounds checks (`s >= scanner->end`). The reference value is limited.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a Use-After-Free vulnerability involving complex state and memory management during error handling. The target code is a simple, synchronous function with no dynamic memory allocation, pointer aliasing, or error paths that could leave dangling references. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are parsers/scanners processing input streams and share CWE-125 (Out-of-bounds Read) as the primary concern. The target code's check `s >= scanner->end` is a basic bounds guard similar to principles needed in libxml2. However, the complexity differs vastly: libxml2 handles multi-byte encodings and complex state, while the scanner is linear and byte-oriented. Provides reference for the importance of rigorous bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Similar to Case 5, both involve parsing and the risk of CWE-125. The target code's bounds check (`s >= scanner->end`) is analogous to the missing checks in libxml2's end tag processing. The reference value lies in reinforcing the need to validate the read position before dereferencing (`*s`), though the parsing contexts (XML vs. generic scanner) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a concurrency-based race condition (CWE-362) in a filesystem's resource management. The target code is a simple, non-reentrant character scanner with no shared state, locks, or concurrent access patterns. The vulnerability domains are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a Double Free (CWE-415) during error handling in a document parser. The target code performs no dynamic memory allocation or freeing within its scope. It manipulates a scanner's cursor pointer but does not manage the lifetime of the underlying buffer. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a NULL pointer dereference (CWE-476) due to inconsistent error state setup in a regex library. The target code does not manipulate complex error states or global error information. It calls `pj_scan_syntax_err` on error but does not return or use a NULL pointer. The flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is another Double Free (CWE-415) during error cleanup in a file reading utility. Similar to Case 8, the target code contains no memory deallocation logic. Its operation is self-contained within the provided scanner structure and buffer.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      }
    ]
  },
  "CVE-2022-1734_after_exclude_100:54191ceb:vulspec": {
    "timestamp": "2026-01-17T01:26:49.360762",
    "cve_id": "CVE-2022-1734",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "54191ceb",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 is a buffer overflow in a FUSE ioctl handler due to improper validation of iovec lengths. The target code is a device cleanup function in an NFC driver, dealing with resource deallocation and state checks. The vulnerability type (CWE-119), attack surface (malicious server), and code patterns (buffer manipulation) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 involves improper input validation leading to unnecessary privilege execution during daemon initialization failure. The target code performs post-use cleanup and resource freeing. While both involve error/cleanup paths, the core flaw (CWE-20/CWE-250 vs. potential use-after-free/double-free in cleanup), context (privilege separation vs. driver unregister), and attack surface are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in a packet parser due to missing length validation. The target code does not parse any external input; it manages internal driver state and resources. The vulnerability type (CWE-125), functionality (parsing vs. cleanup), and trigger conditions (malicious packet vs. driver unload) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13687"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is a duplicate of Case 2 (CVE-2011-3603). The reasoning is identical: the flaw concerns privilege state validation during initialization failure, which is not relevant to the target code's resource deallocation sequence.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an integer overflow leading to an out-of-bounds write during domain name parsing. The target code performs arithmetic-free cleanup operations. The vulnerability type (CWE-190/CWE-787), domain (DNS parsing), and code patterns (length calculations) are not present in the target.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 is a Use-After-Free (CWE-416) enabled by improper cleanup of partially allocated resources during error handling. The target code is a cleanup function that frees multiple interconnected data structures (`priv`, `ndev`, potentially `nfc_dev`). There is a similar pattern of sequential resource release where order matters and accessing fields after an object is freed (e.g., `priv->ndev->nfc_dev->fw_download_in_progress` after `nci_unregister_device` or `nci_free_device`) could lead to a UAF. The context is different (local socket error vs. driver unload), but the core vulnerability class and the pattern of complex cleanup are relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in a packet parser due to incorrect validation order. The target code does not parse packet data or perform bounds checking on external inputs. The vulnerability type (CWE-125) and code patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-16227"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a reachable assertion due to improper input validation in DNS parsing. The target code has no assertions and does not validate complex external inputs. The vulnerability type (CWE-617) and trigger conditions are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-25037"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an infinite loop due to unchecked compression pointer recursion in DNS. The target code contains no loops and does not process recursive data structures. The vulnerability type (CWE-835) is not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in a protocol decoder due to missing length validation. Similar to Cases 3 and 7, this involves parsing untrusted network data, which is not the function of the target cleanup code. The vulnerability type (CWE-125) is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-13052"
        }
      }
    ]
  },
  "CVE-2021-37687_before_exclude_100:3bcf798b:vulspec": {
    "timestamp": "2026-01-17T01:28:27.382401",
    "cve_id": "CVE-2021-37687",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3bcf798b",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a type dispatcher for a tensor operation (GatherNd) in a machine learning framework. The domains (regex parsing vs. ML tensor ops), vulnerability patterns (buffer over-read vs. potential type confusion/missing case), and trigger conditions (malicious regex string vs. malformed tensor) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a side-channel vulnerability in a cryptographic library's elliptic curve implementation. The target code performs a straightforward data gathering operation with no cryptographic elements or secret-dependent control flow. The flaw categories (CWE-200/385 vs. potential CWE-20/125) and attack surfaces (physical measurement vs. API input) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is an access control flaw in a database query planner related to privilege checks on system catalogs. The target code is a low-level tensor operation function with no access control, authentication, or privilege management logic. The vulnerability types (CWE-284 vs. potential type-safety issues) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 involves a resource management error (memory tracking inconsistency) in a subtitle renderer. The target code's primary concern is type dispatch, not dynamic memory management. While both handle structured data input, the specific flaw pattern (allocation size mismatch) is not present in the shown switch statement, which is more susceptible to logic errors like missing type handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves a chain from a broken crypto algorithm to a NULL pointer dereference in a DNS server. The target code also has error handling (ReportError) but is in a different domain. A slight similarity exists in the pattern of handling unsupported cases (default case reporting error vs. unsupported algorithm), but the vulnerability mechanisms (crypto failure leading to NULL deref vs. potential incomplete error handling) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an integer overflow in an archive parser during file position calculation. The target code performs no arithmetic on untrusted data; it's a type dispatcher. The vulnerability patterns (CWE-190 integer overflow vs. potential CWE-20 input validation) and data types processed (archive metadata vs. tensor data types) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is a bounds check issue in a font glyph processor. The target code's `GatherNd` function (not shown in detail) likely performs indexing operations on tensor data. If the `indices` tensor contains out-of-bounds values, it could lead to similar out-of-bounds memory access (CWE-125). The relevance is limited because the shown code is only the dispatcher, not the vulnerable indexing logic itself.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is a NULL pointer dereference due to inconsistent error state handling in a regex library. The target code also has an error path (the `context->ReportError` call). If `context` were NULL or if `ReportError` internally dereferences a NULL pointer due to an earlier error state, a similar flaw could occur. However, the trigger (invalid regex group vs. unsupported tensor type) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a stack buffer overflow in a Bluetooth config parser. The target code shows no buffer operations, parsing of untrusted strings, or use of fixed-size stacks. It operates on structured tensor objects. The vulnerability patterns (CWE-119 buffer overflow vs. type confusion) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an input validation flaw leading to unnecessary privilege execution in a network daemon. The target code validates the `params->type` against a list of supported types. If an unsupported type is not caught (it is caught in the default case), it could lead to undefined behavior, analogous to improper input validation (CWE-20). The privilege escalation aspect is not relevant here.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2021-37687_after_exclude_100:75e79344:vulspec": {
    "timestamp": "2026-01-17T01:28:27.592823",
    "cve_id": "CVE-2021-37687",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "75e79344",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex engine due to improper NUL byte handling. The target code performs input validation (checking for negative indices) and dispatches to a safe operation. The vulnerability type (CWE-125), domain (parsing vs. tensor indexing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a side-channel vulnerability (CWE-385) in a cryptographic library's elliptic curve multiplication. The target code is a simple validation and dispatch function for a tensor operation with no cryptographic or constant-time considerations. The domains and flaw nature are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an improper access control (CWE-284) flaw in a database query planner related to privilege checks on statistics. The target code performs a basic index sign check in a tensor library with no privilege or access control logic. The contexts are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a resource management error (CWE-399) in a subtitle renderer related to inconsistent memory tracking. The target code validates input and calls another function; it does not perform its own memory allocation or complex resource management that could lead to similar state inconsistency.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 involves a NULL pointer dereference (CWE-476) triggered by an unsupported cryptographic algorithm in a DNS server. The target code validates input and uses a switch statement for supported types, reporting an error for unsupported ones. While both have error paths, the vulnerability root cause (crypto algorithm handling vs. type dispatch) and context are very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is an integer overflow (CWE-190) in an archive library during file position calculation. The target code calculates `num_indices = indices->bytes / sizeof(IndicesT)`. While this division is generally safe, if `sizeof(IndicesT)` were not a power of two or if `bytes` could be manipulated, integer issues could theoretically arise, but the context and specific flaw pattern (overflow vs. validation) are only superficially similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a buffer bounds violation (CWE-119) in a font glyph index processing due to unsafe arithmetic. The target code validates that indices are non-negative but does not check if they are within the bounds of the `params` tensor. This missing upper-bound check is a potential vulnerability (out-of-bounds read/write in the `GatherNd` function). However, the specific flaw pattern (glyph index underflow vs. tensor index overflow) and domain differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a NULL pointer dereference (CWE-476) in a regex library due to inconsistent error state handling. The target code uses `context->ReportError` on an error path, which is a standard pattern. There is no obvious similar inconsistency in error state management that would lead to a NULL dereference in this snippet.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a buffer overflow (CWE-119) due to improper input validation in a Bluetooth configuration parser. The target code validates input (checking for negative values) but does not perform bounds checking, which could lead to an out-of-bounds access in the subsequent `GatherNd` function. The similarity is in missing comprehensive input validation, but the specific vulnerability mechanism (stack overflow vs. heap/array OOB) and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an improper input validation (CWE-20) leading to unnecessary privilege execution in a network daemon's privilege separation. The target code validates a specific property of its input (index sign). While both involve validation, the consequence (continued privileged operation vs. potential out-of-bounds access) and system context are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2022-1587_before_exclude_100:3bd5372d:vulspec": {
    "timestamp": "2026-01-17T01:28:38.001217",
    "cve_id": "CVE-2022-1587",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3bd5372d",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve regular expression engine compilation logic. The target code calculates private data length for recursion handling in a regex JIT compiler (likely PCRE2), while CVE-2018-18313 involves Perl's regex compilation with NUL byte handling. The vulnerability type differs (CWE-125 vs. target's potential logic/calculation errors), but both operate in the regex compilation domain, making patterns of state management and opcode traversal somewhat similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-14461 is a network protocol parser (tcpdump LDP) vulnerability involving out-of-bounds read due to insufficient length validation. The target code is a regex JIT compiler helper function performing static analysis on opcode sequences with no network/data parsing, no external input validation in the same sense, and a completely different domain and code pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code performs arithmetic addition (`length += ...`) but on small, controlled counts based on opcode types, with no dynamic input influencing allocation size. The domains (network protocol vs. regex compilation) and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a service daemon related to error handling and resource cleanup. The target code has no dynamic memory allocation/deallocation, no error paths that free resources, and is a pure calculation function. The code patterns and vulnerability types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2 due to improper buffer management during multi-byte character processing. The target code traverses a static opcode sequence with pointer arithmetic (`cc += ...`) but uses compile-time constants (LINK_SIZE, IMM2_SIZE) or safe functions (`next_opcode`). It does not parse variable-length, untrusted character data in the same way, making the vulnerability pattern dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-15166 is an input validation issue in a network protocol parser (tcpdump LMP). The target code validates opcodes via switch statement but operates on a pre-compiled regex bytecode structure, not directly on raw, untrusted network packets. The attack surfaces and code patterns for validation are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to insufficient padding calculation in an image codec. The target code also performs a calculation (`length`) that could influence subsequent memory allocation (for JIT data). If the length calculation were incorrect (e.g., off-by-one due to logic error), it could lead to a buffer overflow in the caller. The domains differ, but the pattern of a pre-allocation size calculation has some similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to insufficient bounds checking during end tag processing. The target code moves a pointer (`cc`) through a buffer but uses assertions (`SLJIT_ASSERT`) and seems to rely on correct internal bytecode structure. While both involve parsing a structured format, the vulnerability mechanism (raw buffer over-read vs. potential logic error in a controlled traversal) is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1834 is a heap buffer overflow in libxml2 string handling due to negative length. The target code does not manipulate strings or have length calculations from untrusted data that could become negative. The code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2017-9226 is an out-of-bounds write in the Oniguruma regex library during compilation, specifically in character class processing. The target code is part of a regex JIT compiler (PCRE2) performing analysis during compilation. Both are in the regex engine compilation subsystem, both involve traversing and interpreting regex opcodes/structures, and both have the potential for miscalculations (e.g., in `length` or state array indices) leading to memory corruption. The vulnerability type (CWE-787) is more severe, but the domain, functionality, and code patterns (switch over opcodes, pointer advancement, state tracking) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      }
    ]
  },
  "CVE-2022-1587_after_exclude_100:0e13ffdb:vulspec": {
    "timestamp": "2026-01-17T01:28:43.014961",
    "cve_id": "CVE-2022-1587",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0e13ffdb",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve regular expression engine compilation phases. The target code is from PCRE2's JIT compiler, calculating private data lengths for recursion, while CVE-2018-18313 is from Perl's regex compiler handling NUL bytes. Both are in regex compilation subsystems, but the vulnerability types differ (OOB read vs. potential logic/calculation errors in the target code's length computation). The code patterns (parsing opcodes in a loop) are structurally similar, providing reference for input validation and state management.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-14461 is a network protocol parser (tcpdump/LDP) with OOB read due to insufficient length validation. The target code is a regex JIT compiler helper function performing internal calculations on a pre-validated opcode stream. Different domains, attack surfaces, and vulnerability patterns. Little reference value beyond generic bounds checking concepts.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20750 involves integer overflow leading to OOB write in a file transfer protocol. The target code performs arithmetic (length increments) but on small counts within a controlled loop. Both involve calculations that could theoretically overflow, but the context and scale differ significantly. The target's length variable is an int, and overflow is less likely but still a consideration.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free in a network daemon's resource management. The target code is a pure calculation function with no dynamic memory allocation or freeing. Different vulnerability class and code patterns. Almost no reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1833 is an OOB read in an XML parser due to encoding issues. The target code parses a bytecode stream (regex opcodes) with explicit length (ccend). While both parse structured input, the target code uses bounded iteration (cc < ccend) and the vulnerability patterns (character encoding vs. opcode interpretation) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-15166 is another network protocol parser (tcpdump/LMP) with improper input validation. The target code operates on internal compiler structures, not raw untrusted network data. Different domain, trust boundaries, and vulnerability triggers.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-14151 is a buffer overflow due to incorrect size calculation in an image codec. The target code also calculates a size (length) based on input opcodes. The similarity is in the \"calculation based on input\" pattern. However, the target's calculation is for a count of items, not a direct memory allocation size, and the complexity and potential for miscalculation are lower.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 is an OOB read in an XML end-tag parser. The target code reads from a controlled opcode array. Both involve parsing, but the XML parser deals with raw text and complex state, while the target parses a compiled bytecode sequence. Little overlap in vulnerability mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1834 is a heap buffer overflow in string handling due to negative length. The target code performs length accumulation. The weak link is that incorrect logic in `recurse_check_bit` or the switch cases could lead to an incorrect final `length` value, which might later cause a buffer overflow when used for allocation elsewhere. However, this is indirect.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2017-9226 is an OOB write in the Oniguruma regex library during compilation, specifically in character class processing. The target code is from PCRE2's JIT compiler, a similar regex engine component. Both are in the regex compilation domain, processing pattern elements into internal structures. The vulnerability pattern (incorrect state or value calculation during compilation leading to memory corruption) is highly relevant. The target code's complex state tracking (setsom_found, control_head_found) and length calculation based on opcode parsing mirrors the kind of logic where similar flaws could exist.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      }
    ]
  },
  "CVE-2022-31783_before_exclude_100:2a41e03d:vulspec": {
    "timestamp": "2026-01-17T01:29:04.804499",
    "cve_id": "CVE-2022-31783",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2a41e03d",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-5767 involves integer overflow in image dimension calculations leading to heap overflow. The target code is a compiler for translation tables with extensive string/character processing, but does not contain similar arithmetic on untrusted dimensions that could overflow. Both involve parsing, but the vulnerability patterns (integer overflow in size calculations vs. parsing logic errors) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5767"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-9227 is an out-of-bounds read in a regex library due to invalid pointer arithmetic. The target code processes tokens and characters with functions like `getToken`, `parseChars`, and array accesses (e.g., `token.chars[0]`). While both involve parsing and could have boundary issues, the target code's pattern is more about controlled table compilation with error checking, not complex pattern matching with backtracking. Some reference value for input validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-9227"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-9423 is a heap buffer overflow in an HTML form processor due to incorrect position calculations. The target code has multiple fixed-size arrays (e.g., `tmpFile.line[MAXSTRING]`) and checks lengths (e.g., `tmpFile.linelen >= MAXSTRING`). Both involve processing structured input and managing buffers. The target code shows more bounds checking, but similar patterns of writing to buffers based on parsed input exist (e.g., in macro expansion). Reference value for buffer management.",
        "case_metadata": {
          "cve_id": "CVE-2016-9423"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-6800 is an integer overflow/type confusion leading to buffer over-read in a TNEF decoder. The target code uses `malloc` and `memcpy` (e.g., for patterns) with size calculations, but these are based on fixed constants (27720) or checked lengths. No obvious type confusion or unsafe casts. Different domain (data format parsing vs. compiler).",
        "case_metadata": {
          "cve_id": "CVE-2017-6800"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-10506 is a divide-by-zero in an image decoder due to invalid resolution parameters. The target code performs arithmetic only in limited places (e.g., `compileNumber`), but no division operations on untrusted input. Different vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-10506"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-9229 is a NULL pointer dereference in regex library due to invalid state. The target code has pointer dereferences (e.g., `*table`, `*inScopeMacros`) and could potentially have NULL issues if callers pass invalid pointers. However, the code includes many error checks and returns early on failures. Some reference for pointer safety but different context.",
        "case_metadata": {
          "cve_id": "CVE-2017-9229"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20217 is a reachable assertion in a Kerberos KDC due to protocol state violation. The target code has no assertions and is not a network protocol handler. Different domain and flaw type.",
        "case_metadata": {
          "cve_id": "CVE-2018-20217"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-9727 is an out-of-bounds read in a font parser due to insufficient bounds checking. The target code reads tokens and characters, and has functions like `getChar` which could potentially access out-of-bounds if table state is corrupted. Both parse structured data. Reference for input validation and bounds checking in parsers.",
        "case_metadata": {
          "cve_id": "CVE-2017-9727"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2011-4623 is an integer overflow leading to heap buffer overflow in a syslog string buffer. The target code has dynamic memory allocation (`malloc` for `arguments`, `patterns`) with size calculations (e.g., `m->argument_count * sizeof(CharsString)`). If `m->argument_count` is attacker-controlled (from a malicious table file), it could overflow. Similar pattern of allocating based on untrusted input. The code lacks explicit overflow checks on these multiplications. Valuable reference for integer overflow in memory allocations.",
        "case_metadata": {
          "cve_id": "CVE-2011-4623"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-9425 is a buffer overflow in form rendering due to missing bounds checks. The target code has fixed-size arrays (`tmpFile.line[MAXSTRING]`) and checks (`tmpFile.linelen >= MAXSTRING`), but also has other arrays like `(*table)->seqPatterns[SEQPATTERNSIZE]` with length checks. Both involve writing data to buffers based on parsed input. Similar pattern of ensuring buffer limits. Reference for buffer management and overflow prevention.",
        "case_metadata": {
          "cve_id": "CVE-2016-9425"
        }
      }
    ]
  },
  "CVE-2022-1720_before_exclude_100:da32cf28:vulspec": {
    "timestamp": "2026-01-17T01:30:01.717683",
    "cve_id": "CVE-2022-1720",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "da32cf28",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network daemon's memory management. The target code is a text selection function in an editor (likely Vim) with no dynamic memory allocation, pointer lifecycle issues, or similar error handling patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is an Out-of-bounds Read in a regex compiler due to improper NUL byte handling. The target code does process multi-byte characters and performs length calculations, but its logic is straightforward array indexing within a line buffer, not complex parsing with embedded control characters. The vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is an Out-of-bounds Write due to integer overflow in a network protocol's memory allocation. The target code performs simple arithmetic on column positions and character lengths but does not involve any memory allocation, size calculations prone to overflow, or network/data parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an Out-of-bounds Read in an XML parser during multi-byte character processing. The target code also handles multi-byte characters (`has_mbyte` check) and adjusts a length to include all bytes of a character. There is a superficial similarity in ensuring correct byte counts for multi-byte sequences, but the context (parser state management vs. simple line buffer operation) and risk level are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an Out-of-bounds Read in an XML parser during end tag processing due to insufficient bounds checking. The target code operates on known line buffers obtained via `ml_get_curline()`/`ml_get_pos()`, and its length calculations, while needing care, are based on column positions within a single line. The complex parser state and tag matching context are absent.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a Buffer Overflow/Over-read in a numeric formatting function due to unchecked input size. The target code copies no data; it calculates a length and returns a pointer to an existing buffer. The only parallel is the manipulation of a length variable, but without the copy operation that defines the vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an Improper Input Validation leading to potential memory issues in a network packet parser. The target code validates visual mode and cursor/visual position alignment, but this is simple state validation, not parsing untrusted network data with complex TLV structures. The attack surfaces are incomparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a Use-After-Free caused by a race condition in kernel memory policy locking. The target code is a simple, synchronous function in a user-space application with no concurrency, resource locking, or dynamic memory management.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an Out-of-bounds Read in a packet parser due to insufficient validation of a length field. The target code's length calculation (`curwin->w_cursor.col - VIsual.col + 1`) depends on internal cursor state, not an untrusted external input field. The code patterns and trust boundaries are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a Missing Authorization vulnerability in a kernel keyring subsystem. The target code performs no authorization checks; it is a pure utility function for retrieving visual text. The domains (security/access control vs. UI/text manipulation) and flaw types are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      }
    ]
  },
  "CVE-2022-31783_after_exclude_100:a5fb14e7:vulspec": {
    "timestamp": "2026-01-17T01:30:11.776823",
    "cve_id": "CVE-2022-31783",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a5fb14e7",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-5767 involves integer overflow in image dimension calculations leading to heap corruption. The target code is a compiler for translation tables, not an image processor. While both involve parsing untrusted input and memory allocation (e.g., `malloc` for patterns), the vulnerability patterns (integer overflow in size calculations vs. parsing logic errors) and domains are fundamentally different. The target code's primary risks are more related to buffer overflows in string handling and macro expansion, not arithmetic overflows in dimension fields.",
        "case_metadata": {
          "cve_id": "CVE-2016-5767"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-9227 is an out-of-bounds read in a regex library due to invalid pointer arithmetic. The target code involves parsing tokens and expanding macros, which also requires careful bounds checking (e.g., `tmpFile.linelen >= MAXSTRING` checks). Both process structured, potentially untrusted input. However, the specific flaw (miscalculation of character positions in multi-byte sequences) is not directly mirrored. The target code's risk is more about fixed-size buffers (`line[MAXSTRING]`) and unchecked array writes during macro substitution, not complex string search algorithms.",
        "case_metadata": {
          "cve_id": "CVE-2017-9227"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2016-9423 is a heap buffer overflow in an HTML form processor due to incorrect position calculations. The target code similarly handles variable-length data (tokens, macro arguments, rule strings) and uses fixed-size buffers (e.g., `tmpFile.line[MAXSTRING]`). Both involve writing user-controlled data into buffers with potential for overflow if length checks are insufficient or incorrect. The pattern of writing to a line buffer (`tmpFile.line[tmpFile.linelen++] = c`) is analogous. However, the target code's context (table compiler) and specific data structures differ from HTML form rendering.",
        "case_metadata": {
          "cve_id": "CVE-2016-9423"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-6800 involves an integer overflow/type confusion leading to a buffer over-read in a TNEF decoder. The target code performs type-safe operations on its internal structures (CharsString, TranslationTableRule). While both parse structured formats, the target code does not exhibit the same pattern of unsafe type casting and direct memory reads from untrusted data. Its memory safety relies more on length fields and allocation functions. The vulnerability mechanism is dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-6800"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-10506 is a divide-by-zero in an image decoder due to unvalidated resolution parameters. The target code performs arithmetic (e.g., in `_lou_pattern_compile`, not shown) but is primarily a compiler/parser, not a numerical image processor. There is no evident division by zero risk from untrusted parameters in the shown code. The domains and flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-10506"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-9229 is a NULL pointer dereference in a regex library due to invalid state. The target code has many pointer usages (e.g., `table`, `displayTable`, `inScopeMacros`) and could potentially dereference NULL if callers pass invalid pointers. However, the shown code does not contain complex state machines like a regex engine. The risk is more indirect (e.g., `*table` could be NULL if caller passes a pointer to NULL). The specific trigger condition (corrupted regex_t state) is not analogous to the table compilation logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-9229"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20217 is a reachable assertion in a network authentication protocol. The target code uses `compileError` for error handling, not assertions. The domains (cryptographic protocol state machine vs. table file compiler) are entirely different. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20217"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-9727 is an out-of-bounds read in a font parser. The target code reads tokens and characters from a file, which could lead to OOB reads if buffer lengths are not properly respected (e.g., accessing `token.chars` beyond `token.length`). Functions like `getToken` and `parseChars` (not shown) would need careful implementation. However, the font parsing context and specific data structures (glyph tables) are not present. The similarity is generic (parsing untrusted data).",
        "case_metadata": {
          "cve_id": "CVE-2017-9727"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2011-4623 is an integer overflow leading to heap buffer overflow in a syslog string buffer. The target code allocates memory based on calculated sizes (e.g., `malloc(m->argument_count * sizeof(CharsString))` and `malloc(sizeof(char) * (emphClass.length + 1))`). If `argument_count` or `emphClass.length` are attacker-controlled and large, they could cause integer overflow or excessive allocation. The pattern of allocating based on input length is similar. However, the target code's length fields likely come from parsed file content, not directly from network/log input, making exploitation context different.",
        "case_metadata": {
          "cve_id": "CVE-2011-4623"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2016-9425 is a buffer overflow in an HTML form renderer due to insufficient bounds checking when writing to a line buffer. The target code has a very similar pattern in the macro expansion loop: it writes characters into `tmpFile.line[tmpFile.linelen++]` after checking `tmpFile.linelen >= MAXSTRING`. If the check were missing or incorrect, a buffer overflow would occur. The code structure (writing user-controlled data into a fixed-size buffer within a loop) is highly analogous. The main difference is the context (macro expansion vs. form rendering), but the vulnerability pattern is nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-9425"
        }
      }
    ]
  },
  "CVE-2022-1720_after_exclude_100:eff0974f:vulspec": {
    "timestamp": "2026-01-17T01:30:21.989208",
    "cve_id": "CVE-2022-1720",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "eff0974f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network daemon's memory management. The target code is a text selection function in an editor (likely Vim) with no dynamic memory allocation, pointer lifecycle issues, or network/system call handling. The domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves an Out-of-bounds Read due to improper NUL byte handling in a regex parser. The target code also handles strings and includes checks for NUL characters (`**pp == NUL`), showing some thematic similarity in input validation. However, the vulnerability type (OOB read vs. potential OOB access in selection logic), context (parser vs. UI), and attack surface are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 involves an Out-of-bounds Read during multi-byte character processing in an XML parser. The target code also handles multi-byte characters (`has_mbyte` check) and performs pointer arithmetic, which is a superficial similarity. However, the context is completely different (document parsing vs. visual mode text selection), and the target code's length adjustment logic is defensive, not obviously vulnerable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 involves a Buffer Overflow in a numeric-to-string formatter. The target code copies no data and only calculates lengths and pointers within an existing line buffer. While both deal with string lengths, the target code lacks the copy operation that is the core of the vulnerability in Case 6.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      }
    ]
  },
  "CVE-2022-2982_before_exclude_100:f1fa44d6:vulspec": {
    "timestamp": "2026-01-17T01:31:52.897144",
    "cve_id": "CVE-2022-2982",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f1fa44d6",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free in a network daemon's state management. The target code is a callback handler with careful reference counting (e.g., `dv_refcount++`, `lv_refcount++`) and cleanup (`dict_unref`, `clear_tv`). The patterns and vulnerability type (UAF vs. potential logic/refcounting bugs) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an Out-of-bounds Read in a regex parser due to improper NUL byte handling. The target code deals with calling a user-defined callback and managing Vim script typval_T structures. There is no parsing of untrusted byte streams or similar bounds-checking logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an Out-of-bounds Write due to integer overflow in a network protocol's memory allocation. The target code performs no arithmetic on user-controlled integers for allocation sizes. Its operations are bounded by list indices and fixed dictionary creation.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an Out-of-bounds Read in a network protocol parser due to insufficient length validation. The target code does not parse binary protocol data; it constructs a dictionary with fixed keys and calls a user callback. The code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is Improper Input Validation leading to memory issues in a packet parser. The target code's input validation (if any) would be on the callback's return value (`rettv`), but the primary flaw pattern (missing bounds checks on network data) is absent.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Read in an XML parser during end tag processing. The target code is not a parser and does not process hierarchical text data. The vulnerability mechanisms and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an Out-of-bounds Read in a text parser due to improper buffer management during multi-byte character processing. The target code handles Vim script objects and callbacks, not low-level character encoding or buffer state management.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is Improper Input Validation leading to a buffer overflow in a decompression algorithm. The target code performs no decompression or similar complex data transformation. The attack surface and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow due to incorrect size calculation in an image codec. The target code allocates a fixed dictionary and handles callback results. There are no arithmetic calculations for buffer sizes based on image data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a Double Free due to inconsistent state management during error conditions. The target code shows patterns of reference counting (`dv_refcount++`, `lv_refcount++`) and cleanup (`dict_unref`, `clear_tv`). While not identical, both involve careful management of reference-counted objects to prevent memory management errors (double free, use-after-free). The target code's complexity around callback results and reference increments could harbor similar logic flaws if error paths are not handled correctly, providing a weak conceptual reference.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2022-2982_after_exclude_100:ace8a404:vulspec": {
    "timestamp": "2026-01-17T01:32:03.085309",
    "cve_id": "CVE-2022-2982",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ace8a404",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free in a network daemon due to uninitialized pointers and inconsistent state management. The target code is a callback handler with a static recursion guard and careful reference counting. The memory management patterns (explicit refcount increments/decrements, cleanup on error paths) are fundamentally different from the flawed error handling in MiniSSDPd.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an Out-of-bounds Read in a regex parser due to improper NUL byte handling. The target code performs no string parsing or buffer manipulation. It deals with calling a user-supplied callback and managing reference counts for a list object, with no similarity to the input validation flaws in Perl's regex engine.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an Out-of-bounds Write due to integer overflow in a network protocol's file transfer module. The target code performs arithmetic only for dictionary value assignment (simple casts) and has no dynamic memory allocation based on user-controlled integers. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an Improper Input Validation leading to potential memory corruption in a packet parser. The target code validates nothing from external inputs; its primary logic is callback invocation and reference counting. While both involve processing external data indirectly (callback result vs. network packet), the mechanisms and flaw locations are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Read in an XML parser during end tag processing. The target code is not a parser and does not read sequential data from a buffer. The static recursion guard and reference counting pattern bear no resemblance to the state management issues in libxml2.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an Out-of-bounds Read in a character encoding handler due to inadequate buffer state checks. The target code performs no character encoding or multi-byte processing. The similarity is negligible.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an Improper Input Validation leading to a buffer overflow in a decompression algorithm. The target code does not implement a compression/decompression algorithm or perform complex arithmetic on window buffers. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow due to insufficient padding allocation in an image codec. The target code has no analogous buffer size calculations or padding logic. Its memory management is via standard alloc/free and reference counting.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. This is the most relevant case. Case 10 is a Double Free due to inconsistent state management during error conditions. The target code also manages resource lifetimes (dictionary, list) using reference counts (`dv_refcount`, `lv_refcount`) and has cleanup paths (`dict_unref`, `clear_tv`). A similar flaw could exist if the callback manipulation or error paths lead to an inconsistent reference count state (e.g., missing increment/decrement), potentially causing a double free or use-after-free. However, the specific trigger (VBA parsing errors) and context are very different, and the target code appears more careful with its refcount operations.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2022-1899_before_exclude_100:c1d3b404:vulspec": {
    "timestamp": "2026-01-17T01:33:41.496969",
    "cve_id": "CVE-2022-1899",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c1d3b404",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing/scanning binary data (regex patterns vs. string extraction), but the vulnerability types differ significantly. CVE-2018-18313 is an out-of-bounds read due to improper NUL byte handling in a regex engine. The target code performs string scanning with bounds checks and handles NUL bytes as string terminators. The core flaw patterns (OOB read vs. potential OOB read/write in buffer operations) and attack surfaces are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-20750 involves integer overflow leading to OOB write in a memory allocation. The target code has integer arithmetic (e.g., `len = to - from`) and uses `calloc`. However, it validates `len` against `ST32_MAX` and checks for `len < 1`, mitigating overflow/wraparound risks. The primary vulnerability mechanism (integer overflow in allocation size) is not directly mirrored in the target's controlled buffer allocation based on a validated range.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free due to uninitialized pointers and inconsistent state management. The target code manages dynamic memory (`buf`, `out`, `bs`) but shows careful allocation/free patterns and NULL checks. There is no evidence of pointer aliasing or complex state cleanup that could lead to UAF. The vulnerability class and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2018-20760 is an OOB write in a text encoding conversion function (`gf_text_get_utf8_line`). The target code performs similar functionality: character encoding conversion via `r_charset_encode_str`, handles UTF-8/UTF-16/UTF-32 decoding, and writes to buffers (`tmp`, `out`). Both involve multi-byte character processing and buffer management. The target code has bounds checks (e.g., `i < sizeof(tmp) - 4`), but the similarity in domain (encoding conversion) and potential for OOB write if decode functions misbehave provides valuable reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-9226 is an OOB write in a regex library due to invalid octal escape values. The target code processes escape sequences (e.g., `\\b`, `\\n`) in the string scanning loop, but it uses a hardcoded lookup table and restricts `r < 93`. The vulnerability pattern (invalid input leading to out-of-bounds array index) is superficially similar to the target's escape table access, but the context (regex compilation vs. string printing) and risk level differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-19333 is a buffer overflow via `strcpy`/`sprintf` without length validation. The target code uses `r_str_ndup` for safe copying and has bounded writes to `tmp` buffer. However, it does use `strchr` on a string literal (safe) and string operations in `r_utf_block_list`/`r_utf8_encode` which are library calls. The relevance lies in the general pattern of string buffer management without explicit size arguments in some functions, though the target appears more cautious.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-16161 (first instance) is a NULL pointer dereference in a regex tokenizer due to error state mishandling. The target code has multiple pointer dereferences (`bf->buf`, `bin->iob.io`, etc.) but guards them with checks (`if (bin && bin->consb.is_breaked)`). The flaw pattern (missing validation on error path) is not evident in the target's flow, which checks `pj` and `io` before use. Different domain and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-16161 (second instance) is a NULL pointer dereference in an error reporting function. The target code has minimal error reporting (eprintf) and no complex error code conversion. The vulnerability pattern (dereferencing unvalidated pointers in error handling) does not align with the target's structure, which uses direct string output or PJ JSON functions with creation checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-1003 is a Double Free in an antivirus VBA extractor. The target code allocates/frees `buf`, `out`, `bs`, `block_list`, `freq_list` but shows disciplined ownership: `buf` is freed once at end, `out` replaces `buf` and is freed similarly, `bs` is either appended to list or freed immediately. No double-free pattern is evident. Different memory management context.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-1834 is a heap buffer overflow due to negative length calculation bypassing checks. The target code has similar length calculations (`to - from`, `needle - from`) and uses them as offsets into `buf`. It validates `from > to` and `len` range, preventing negative values. However, the pattern of using arithmetic results as buffer indices without sufficient validation is conceptually similar. The target adds checks, but the underlying risk pattern (OOB access via offset miscalculation) is relevant for reference.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2021-41133_before_exclude_100:79bf04ee:vulspec": {
    "timestamp": "2026-01-17T01:33:42.472955",
    "cve_id": "CVE-2021-41133",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "79bf04ee",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2011-3603 involves privilege separation failure and improper input validation in a network daemon. The target code is a seccomp filter setup function for a container runtime, focusing on syscall restriction. The vulnerability types (CWE-20, CWE-250), domain (network daemon vs. sandboxing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code configures a seccomp policy with no regex parsing, string processing, or similar memory access patterns. The vulnerability domains and code patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a file content processing function within a VM inspection library. The target code sets up a seccomp filter and manages temporary file descriptors, but does not involve dynamic memory management (malloc/free) or the error handling patterns that lead to a double-free.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-12899 is an out-of-bounds read in a network packet parser (tcpdump) due to insufficient bounds checking. The target code is a security policy configuration function that does not parse untrusted network data or perform bounds-checked buffer reads. The domains and attack surfaces are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13001 is another out-of-bounds read in a network protocol decoder (tcpdump NFS). Similar to case 5, the target code does not parse or decode untrusted input streams. Its primary function is to define and apply a syscall filter, not to process variable-length data from an external source.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-16914 is a NULL pointer dereference in a Linux kernel USB/IP driver due to insufficient validation of URB fields. The target code also runs in a security-sensitive context (container sandboxing) and performs validation (e.g., checking syscall arguments). However, the vulnerability type (CWE-476), domain (kernel driver vs. userspace sandbox), and specific trigger conditions (network packet vs. syscall policy) are very different. The only similarity is the theme of validating untrusted inputs in a security control.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3601 is a buffer overflow in a network daemon's DNSSL option parser. The target code does not parse network packets or copy variable-length data without bounds checking. Its data structures are fixed arrays of syscall rules. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3137 is a NULL pointer dereference in a kernel USB driver due to missing validation of hardware descriptors. The target code also performs validation (e.g., checking seccomp architecture support) and handles error conditions. Both involve ensuring system state is valid before proceeding. However, the context (kernel hardware driver initialization vs. userspace sandbox policy setup) and the nature of the untrusted input (hardware descriptors vs. configuration flags) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2010-4650 is a buffer overflow in the Linux kernel FUSE subsystem due to insufficient validation of iovec lengths from a userspace server. The target code is a userspace library function configuring seccomp and does not handle complex data structures like iovecs from untrusted sources. The vulnerability mechanism is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      }
    ]
  },
  "CVE-2021-41133_after_exclude_100:3f3bca8a:vulspec": {
    "timestamp": "2026-01-17T01:33:51.959143",
    "cve_id": "CVE-2021-41133",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3f3bca8a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a privilege separation failure in a network daemon (CWE-20, CWE-250). The target code is a seccomp filter setup function for a container runtime. The domains (network daemon vs. container security), vulnerability types (privilege management flaw vs. syscall filtering), and code patterns are fundamentally different. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a Perl regex engine due to improper NUL byte handling. The target code constructs a static seccomp policy with no dynamic input parsing or regex processing. The vulnerability types (CWE-125 vs. syscall filtering) and code contexts are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 3 is an integer overflow leading to out-of-bounds write in a VNC file transfer component. The target code performs seccomp rule addition with fixed, small data structures. There is no dynamic memory allocation based on user input, no integer overflow risk, and the functional domains are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is a double-free vulnerability in a file reading utility. The target code manages seccomp filter context cleanup via `__attribute__((cleanup))`, which is a deterministic, scope-based cleanup pattern. There is no manual memory management or error path that could lead to double-free. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a network packet parser due to insufficient bounds checking. The target code does not parse network packets or any untrusted data streams. It configures a kernel security mechanism based on predefined rules. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 6 is another out-of-bounds read in a network protocol decoder (NFS). Similar to case 5, the target code's domain is container sandboxing via syscall filtering, not network protocol parsing. The vulnerability types and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 is a NULL pointer dereference in a Linux kernel USB driver due to insufficient validation of URB fields. The target code also runs in a security-sensitive context (container setup) and performs validation (e.g., checking syscall arguments). However, the specific flaw type (NULL deref vs. missing syscall filter), trigger conditions (malicious hardware data vs. container escape), and code patterns (kernel driver vs. userspace library) are very different. Only a vague similarity in the theme of \"insufficient validation in a security component\".",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow in a network daemon's DNSSL option parser. The target code contains no array or buffer operations on untrusted data that could overflow. It uses fixed-size, stack-allocated arrays for its blocklists. The domains and vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is a NULL pointer dereference in a kernel USB driver due to missing validation of USB descriptors. The target code validates syscall arguments (e.g., using `SCMP_A0` comparisons) and checks for error returns from `seccomp_*` functions. Both involve adding guards in a system-level software layer. However, the context (kernel driver initialization vs. userspace sandbox policy), the source of untrusted data (hardware vs. container configuration), and the specific failure mode are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 10 is a buffer overflow in the kernel FUSE subsystem due to improper iovec length validation. The target code does not handle iovecs, perform complex buffer management, or interface with a FUSE-like protocol. The code patterns and vulnerability mechanisms are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      }
    ]
  },
  "CVE-2021-41225_before_exclude_100:41ddb217:vulspec": {
    "timestamp": "2026-01-17T01:33:53.139120",
    "cve_id": "CVE-2021-41225",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "41ddb217",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2011-3603 involves privilege separation failure leading to unnecessary root execution (CWE-250). The target code is a TensorFlow graph optimizer for auto-parallelism with no privilege management, daemon control flow, or similar error handling paths. The functional domains (network daemon vs. ML graph compilation) and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-10128 is about improper access control (CWE-284) in a database query planner during statistics examination. The target code performs graph transformation and node replication for parallel training; it does not handle user privileges, SQL queries, or view-based access checks. The code patterns and security contexts are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-7972 involves resource management errors (CWE-399) and inconsistent memory tracking in a multimedia library. The target code manipulates graph node collections but uses standard C++ containers (std::map, std::set) with clear ownership. While both involve internal state management, the target code shows no signs of manual memory allocation errors, double-counting, or similar low-level resource tracking flaws.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability (CWE-200/385) in cryptographic point multiplication. The target code is a graph initialization routine for machine learning, performing no cryptographic operations, secret-dependent branching, or constant-time algorithms. The vulnerability class and code patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) due to improper NUL byte handling in a regex parser. The target code processes TensorFlow graph protobufs, with no evident string parsing of untrusted data, character sequence handling, or buffer manipulation that could lead to similar memory safety issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3179 is a use-after-free (CWE-416) caused by uninitialized pointers and inconsistent state during error handling. The target code uses RAII-style containers and has simple error returns (Status objects). However, both involve managing collections of objects and conditional logic for resource inclusion/exclusion (`dont_replicate_nodes`). There is a superficial similarity in state management, but the memory safety risks are much lower in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-16149 involves improper cryptographic signature verification (CWE-347) due to ASN.1 parsing flaws. The target code performs graph analysis and transformation for parallel training; it does not parse cryptographic structures, verify signatures, or handle untrusted binary data formats. No relevance in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read (CWE-125) in an image file parser due to improper string termination validation. The target code processes internal graph structures from a trusted item input; it does not parse external file formats, read untrusted string data from buffers, or perform low-level byte operations that could lead to buffer over-reads.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-18874 is a double-free (CWE-415) due to incorrect reference counting during error conditions in a Python C extension. The target code is C++ and uses stack/heap objects with clear ownership, but it does involve inserting nodes into multiple collections (`all_nodes_`, `replica_nodes_`, `shared_nodes_`). There is a conceptual similarity in managing object references across multiple data structures, though the target code uses value semantics and does not exhibit the same reference counting or cleanup hazards.",
        "case_metadata": {
          "cve_id": "CVE-2019-18874"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2009-3909 is an integer overflow (CWE-190) leading to a heap buffer overflow in an image file parser. The target code performs graph node iteration and set insertion, with no arithmetic on untrusted dimensions, buffer size calculations, or heap allocations based on user input. The vulnerability patterns are not present.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      }
    ]
  },
  "CVE-2022-1899_after_exclude_100:48398ba7:vulspec": {
    "timestamp": "2026-01-17T01:33:53.252585",
    "cve_id": "CVE-2022-1899",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "48398ba7",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing/scanning binary data (regex patterns vs. string extraction), and both have potential for out-of-bounds reads due to improper boundary checks. However, the target code's primary vulnerability pattern is more about integer overflows and buffer overflows in its own allocation and indexing, while CVE-2018-18313 is specifically about NUL bytes in regex patterns causing OOB reads in a different context. The core flaw patterns are not identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Strong similarity in the vulnerability chain: an integer overflow/wraparound (CWE-190) during a size calculation leads to an undersized buffer allocation, which then causes an out-of-bounds write (CWE-787). The target code has a similar pattern with `st64 len = (st64)(to - from);` which could wrap if `to` is less than `from`, and the subsequent `calloc(len, 1)` could allocate a buffer that is too small for the following `r_buf_read_at` operation. The context (file transfer vs. binary string scanning) differs, but the flaw mechanism is comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free vulnerability related to error handling and inconsistent state management. The target code does not show obvious patterns of double-free or use-after-free in its error paths. Its memory management for `buf` and `bs` appears straightforward with clear allocation and a single free. The relevance is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve text/string processing with character encoding (UTF-8, UTF-16/32) and have potential for out-of-bounds writes due to incorrect buffer size management or missing validation. The target code performs UTF-8/16/32 decoding and writes to a fixed-size stack buffer `tmp[R_STRING_SCAN_BUFFER_SIZE]` within a loop that could potentially overflow if not carefully bounded (though the loop condition `i < sizeof (tmp) - 4` provides some protection). CVE-2018-20760's flaw is in a text import function with unsafe buffer copies. The similarity lies in encoding conversion and buffer boundary risks.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both process textual/byte patterns (regex vs. string extraction) and involve out-of-bounds write risks. However, CVE-2017-9226's flaw is very specific to octal escape sequence validation in a regex character class bitset, leading to an OOB write as an array index. The target code's potential OOB write is more related to buffer overflows from incorrect loop control or size calculations, not from misinterpreting escape sequences as indices. The underlying pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-19333 is a classic buffer overflow due to unsafe `strcpy`/`sprintf` without length checks. The target code uses `r_str_ndup` which is safer, and the primary buffer operations are on `buf` (heap) and `tmp` (stack) with loop guards. However, there is a similarity in the risk of concatenating or building strings without perfect length validation (e.g., the escape sequence handling in the `else if` block writes to `tmp[i+0]` and `tmp[i+1]` after a check `(i + 32) < sizeof(tmp)`, which is non-standard and could be flawed). The connection is weak but present in the theme of string buffer management.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-16161 (first instance) is a NULL pointer dereference in a regex tokenizer's error state. The target code does not show similar patterns of complex state machine error handling that could lead to dereferencing NULL. Its error paths typically use `eprintf` and return `-1`. No strong similarity.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-16161 (second instance) is a NULL pointer dereference in an error message function. The target code's error handling is simpler and does not involve converting error codes to strings in a vulnerable way. The `eprintf` calls use literal strings. Minimal relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-1003 is a Double Free vulnerability during error cleanup in a document parser. The target code allocates `RBinString *bs = R_NEW0 (RBinString)` and frees it in only one branch (the non-list branch via `r_bin_string_free`). The list branch appends it to a list, suggesting ownership transfer. No double-free pattern is evident. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-1834 is a buffer overflow due to improper length validation (a negative length bypassing checks). The target code has several similar risks: 1) The `len` calculation `(st64)(to - from)` could be negative if `to < from`, though checked later, 2) The loop condition `needle < to` and index calculation `buf + (needle - from)` rely on `needle` and `from` being in a valid relationship, 3) The use of `rc` from decoding functions to advance `needle` and index into `buf` could potentially lead to OOB access if `rc` is miscalculated. The theme of arithmetic and boundary validation leading to buffer overflow is strongly shared, though the specific trigger (negative length) is not directly replicated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2021-41225_after_exclude_100:ce69d021:vulspec": {
    "timestamp": "2026-01-17T01:35:25.531174",
    "cve_id": "CVE-2021-41225",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ce69d021",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2011-3603 involves privilege separation failure leading to unnecessary root execution (CWE-20, CWE-250). The target code is a graph optimization routine in a machine learning framework (TensorFlow AutoParallel) with no privilege management, daemon initialization, or similar control flow. The functional domains are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-10128 is an improper access control (CWE-284) flaw in a database query planner related to privilege checks on views. The target code performs graph node analysis and transformation for parallelization, with no access control, SQL, or user privilege mechanisms. The code patterns and vulnerability class are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-7972 is a resource management error (CWE-399) in a multimedia library involving inconsistent memory tracking. The target code manipulates graph node collections but does not show direct memory allocation, deallocation, or size tracking flaws. While both handle internal data structures, the specific vulnerability pattern (inconsistent state leading to allocation failure) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel information leak (CWE-200, CWE-385) in a cryptographic library's elliptic curve operations. The target code is non-cryptographic graph processing logic with no secret-dependent branches, constant-time requirements, or low-level arithmetic operations. The domains and vulnerability types are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) due to improper NUL byte handling in a regex parser. The target code processes graph node names and operations but does not parse untrusted string patterns, handle embedded NULs, or perform buffer reads that could lead to memory disclosure. The attack surface and code patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3179 is a use-after-free (CWE-416) enabled by uninitialized state and error handling in a network daemon. The target code uses standard containers (std::map, std::set) and does not perform manual memory management, pointer manipulation, or have complex error paths that could leave objects in inconsistent states. The memory management models are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-16149 is an improper cryptographic signature verification (CWE-347) due to ASN.1 parsing flaws in a TLS library. The target code has no cryptographic operations, certificate parsing, or ASN.1 handling. The functional domains and vulnerability classes are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read (CWE-125) in an image file parser due to improper string termination validation. The target code does not parse external file formats, read untrusted binary data, or perform low-level buffer operations. The code deals with internal graph structures, not external input parsing vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-18874 is a double-free (CWE-415) due to incorrect reference counting in a Python C extension. The target code is C++ but uses RAII patterns with standard containers, showing no manual reference counting, PyObject manipulation, or explicit free operations. While both involve C/C++ code, the memory management patterns and error conditions are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-18874"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2009-3909 is an integer overflow (CWE-190) leading to a heap buffer overflow (CWE-122) in an image file header parser. The target code performs graph node counting and set operations but does not parse untrusted numerical dimensions, perform arithmetic that could overflow, or allocate buffers based on user-controlled calculations. The vulnerability pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      }
    ]
  },
  "CVE-2021-32037_before_exclude_100:c8c14734:vulspec": {
    "timestamp": "2026-01-17T01:35:33.849948",
    "cve_id": "CVE-2021-32037",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c8c14734",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves weak random number generation leading to information exposure in an authentication module. The target code uses random cursors for sampling but does not involve cryptographic randomness or session security. The core vulnerability patterns (CWE-200, CWE-338) are not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2014-8566"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read due to improper NUL byte handling in a regex parser. The target code is a query executor for database sampling with no string parsing or buffer manipulation vulnerabilities. Different domains and vulnerability types.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves heap buffer overflow in image encoding due to insufficient padding allocation. The target code performs query planning and execution with no low-level memory buffer operations or arithmetic calculations that could lead to buffer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 involves side-channel attacks in cryptographic operations. The target code implements database query optimization with no cryptographic operations or secret-dependent branching that could create timing side channels. Different security concerns.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves privilege escalation due to improper error handling in daemon initialization. The target code has some error handling (returning nullptr pairs) but no privilege management or process control vulnerabilities. Some similarity in error path handling but different contexts.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 involves use-after-free due to inconsistent state management in image processing. The target code manages query execution plans with clear ownership transfers (std::move) and no dynamic memory management that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves out-of-bounds read in file format parsing. The target code processes database queries with no file parsing or string manipulation that could lead to buffer over-reads. Completely different domains.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves integer overflow in archive file parsing. The target code performs arithmetic calculations (sampleSize comparisons) but with double precision floating point, not integer operations that could overflow. Different vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves NULL pointer dereference in cryptographic key processing. The target code has null checks (invariant, if checks) and proper error handling. No cryptographic algorithm handling or similar failure modes.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves integer overflow in audio codec mathematical computations. The target code uses floating point arithmetic for ratios and comparisons, not integer operations that could overflow. Different computation patterns and domains.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2020-15900_after_exclude_100:08bdebeb:vulspec": {
    "timestamp": "2026-01-17T01:35:39.132277",
    "cve_id": "CVE-2020-15900",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "08bdebeb",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network daemon's memory management during error handling. The target code is a string search function with no dynamic memory allocation, pointer lifecycle issues, or similar error handling paths.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves an Out-of-bounds Read in a regex compiler due to improper NUL byte handling. The target code performs simple byte-by-byte string matching with `memcmp` and has explicit length checks (`r_size`). It does not process complex patterns or embedded control characters.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 involves an Out-of-bounds Write in a regex library's character class compiler due to invalid octal escapes. The target code does not compile patterns, interpret escape sequences, or write to arrays based on user-controlled indices.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 involves a heap buffer overflow in an image codec due to incorrect allocation size calculation. The target code performs read-only operations on existing string objects, does no dynamic allocation, and uses sizes directly from trusted object metadata.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 involves an Out-of-bounds Write due to integer overflow in a network protocol's memory allocation. The target code has no network input parsing, integer overflow risks in size calculations (uses `uint`), or dynamic writes to allocated buffers.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 involves an Out-of-bounds Read in a regex library's `search_in_range` function due to integer overflow. The target code is also a search function (`search_impl`) that operates on strings with forward/backward direction. Both involve calculating offsets and bounds during a search. However, the target code uses simple byte matching, not complex regex semantics, and its `count` variable is a `uint` that decrements to zero, making overflow less likely than in the 32-bit pointer arithmetic of the case.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 7 involves an Out-of-bounds Read in a regex forward search due to integer overflow in pointer arithmetic. The target code's `search_impl` also implements forward/backward search, uses pointer arithmetic (`ptr += incr`), and has loop conditions based on a count. The pattern of moving a pointer within a buffer and checking bounds is similar. However, the target code's bounds are validated upfront (`size > r_size(op1)`), and the loop uses a decrementing counter, reducing the risk of the specific integer overflow seen in the case.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 involves an Out-of-bounds Read in a regex backward search due to integer overflow. The target code explicitly supports backward search (`incr = -1`) and adjusts the starting pointer (`if (!forward) ptr += count`). The structure of handling bidirectional search with potential pointer arithmetic near buffer boundaries is conceptually similar. The key difference is the lack of complex regex state management and the simpler bounds checking in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 involves an Out-of-bounds Read in an XML parser due to improper multi-byte character encoding handling and buffer state validation. The target code treats data as raw bytes (`byte *`), performs no character encoding interpretation, and has straightforward bounds checks based on object sizes.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 involves Improper Input Validation in a network protocol parser, leading to potential memory corruption. The target code validates its input types (`check_read_type`) and sizes before operations. It does not parse complex, untrusted network packet structures with variable-length fields.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2020-15900_before_exclude_100:f3e15106:vulspec": {
    "timestamp": "2026-01-17T01:35:40.067931",
    "cve_id": "CVE-2020-15900",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f3e15106",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free (CWE-416) in a network service daemon due to uninitialized pointers and inconsistent state management. The target code is a string search function with no dynamic memory allocation, pointer lifecycle issues, or similar error handling patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves an Out-of-bounds Read (CWE-125) in a regex engine due to improper NUL byte handling. The target code performs string search operations with `memcmp` and pointer arithmetic. While the vulnerability type differs (OOB read vs. potential OOB access in pointer arithmetic), both involve careful parsing of input data (strings/regex patterns) and bounds management, offering some reference for input validation and boundary checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves an Out-of-bounds Write (CWE-787) in a regex library due to insufficient validation of octal escape sequences leading to array index overflow. The target code does not process escape sequences or use user input as array indices. The similarity is limited to both being parsing/processing functions that handle user-controlled data, but the flaw mechanism is very different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a heap buffer overflow (CWE-119) in an image codec due to incorrect padding calculation during memory allocation. The target code performs in-bounds string search with no dynamic memory allocation or complex size calculations, making this case largely irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 involves an Out-of-bounds Write (CWE-787) enabled by integer overflow (CWE-190) in a file transfer protocol. The target code uses unsigned integers for sizes and counts with simple arithmetic (subtraction). While both handle size calculations, the risk of integer wrap-around in the target's `count = r_size(op1) - size` is mitigated by the preceding `if (size > r_size(op1))` check, and the context (network protocol vs. core string op) is very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 6 involves an Out-of-bounds Read (CWE-125) caused by integer overflow (CWE-190) in a regex library's `search_in_range` function. This is highly analogous to the target `search_impl` function: both implement forward/backward search over a buffer, use pointer arithmetic with an increment (`incr`), and loop based on a count. The target code's loop `while (count--)` and pointer updates `ptr += incr` must ensure `ptr` stays within the bounds of `op1->value.bytes`. An integer overflow in calculating `count` or an error in the `incr` direction could lead to similar OOB access. The pattern is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 7 again involves an Out-of-bounds Read (CWE-125) from integer overflow in pointer arithmetic within a regex search function (`forward_search`). The parallel to the target `search_impl` is direct: both are search functions that move a pointer (`ptr`) through a buffer based on a calculated distance or count. The target's `ptr += incr` within the `do-while` loop must be carefully validated to prevent `ptr` from going outside the source string bounds, especially when `incr` is -1 (backward search). The code patterns and potential vulnerability patterns are closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 8 is another instance of OOB Read from integer overflow in Oniguruma's backward search. The target code explicitly supports backward search (`forward ? 1 : -1`). The vulnerability patternincorrect bounds calculation during backward iteration leading to pointer arithmetic errorsis directly applicable for auditing the target code's handling of `ptr` when `incr = -1` and `count` is derived from user-controlled string sizes.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 involves an Out-of-bounds Read (CWE-125) in an XML parser due to inadequate bounds checking during multi-byte character processing. The target code handles single-byte characters (`byte *ptr`, `byte ch`) and uses `memcmp`. The connection is only generic: both process input data and require bounds checks. The specific mechanisms (character encoding vs. simple byte search) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves Improper Input Validation (CWE-20) in a network protocol parser, leading to missing bounds checks. The target code does perform basic validation (`if (size > r_size(op1))`). The relevance is limited to the general principle of validating input sizes and ensuring pointer operations remain within bounds, but the context and specific flaw patterns are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2021-32037_after_exclude_100:926d3652:vulspec": {
    "timestamp": "2026-01-17T01:35:45.919157",
    "cve_id": "CVE-2021-32037",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "926d3652",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves weak random number generation leading to information exposure in an authentication module. The target code uses random cursors for sampling but does not involve cryptographic randomness or session security. The core vulnerability patterns (CWE-200, CWE-338) are not present.",
        "case_metadata": {
          "cve_id": "CVE-2014-8566"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code performs database query planning and sampling logic with no string parsing or buffer manipulation. Different domain and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a heap buffer overflow in an image codec due to incorrect memory allocation. The target code manages query executors and iterators without low-level buffer operations. Different memory management patterns and attack surfaces.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is a side-channel vulnerability in cryptographic operations. The target code performs database sampling optimizations with no cryptographic operations or constant-time requirements. Different security domain (crypto vs query optimization).",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves privilege separation failure leading to unnecessary privilege retention. The target code runs within a database query executor with no privilege management or process isolation logic. Different security mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a use-after-free in an image processing library due to inconsistent state management. The target code uses smart pointers and RAII patterns with no manual memory management that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in a file parser due to improper string termination validation. The target code processes database collections and query plans, not file format parsing. Different data processing patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an integer overflow in an archive parser during position calculation. The target code performs ratio calculations with floating-point arithmetic and sample size comparisons, not integer position arithmetic that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves cryptographic algorithm handling leading to NULL pointer dereference. The target code has no cryptographic operations, DNSSEC validation, or similar error handling paths that could cause NULL dereference.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an integer overflow in an audio codec during mathematical computations. The target code uses floating-point ratios and sample size comparisons, not integer arithmetic vulnerable to overflow in codebook calculations.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2021-32037_before_exclude_100:89306182:vulspec": {
    "timestamp": "2026-01-17T01:37:17.045322",
    "cve_id": "CVE-2021-32037",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "89306182",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves weak random number generation leading to information exposure in an authentication module. The target code uses random cursors for sampling but does not involve cryptographic randomness for security purposes. The functional domains (authentication vs. database query optimization) and vulnerability patterns (CWE-200/CWE-338 vs. potential logic/validation issues) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2014-8566"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a database query executor dealing with sampling algorithms, locks, and plan stages. There is no string parsing, buffer manipulation, or similar memory safety operations in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a heap buffer overflow in an image codec due to incorrect memory allocation calculations. The target code performs query planning and execution logic with no direct memory allocation, buffer sizing, or raw data writing operations that could lead to buffer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is a side-channel vulnerability in a cryptographic library due to non-constant-time operations. The target code deals with database sampling efficiency and query optimization. While both involve algorithmic decisions, the target code's logic (e.g., ratio calculations, trial stages) does not handle secret data or have timing side-channel implications relevant to cryptography.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves improper input validation leading to unnecessary privilege execution. The target code includes invariant checks (e.g., lock state verification) and conditional logic based on input parameters (sampleSize, numRecords). There is a tangential similarity in validating preconditions (lock state) and input ratios, but the context (privilege separation vs. query optimization) and consequences are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a use-after-free vulnerability in an image library due to inconsistent state management. The target code manages plan executor stages and working sets with smart pointers (std::unique_ptr) and does not exhibit manual memory management or pointer invalidation patterns that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in an image file parser due to improper string termination validation. The target code does not parse external file formats or handle untrusted string data from external sources; it operates on internal database structures and query parameters.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is an integer overflow in an archive library during file position calculation. The target code performs arithmetic operations (e.g., `sampleSize > numRecords * kMaxSampleRatioForRandCursor`) that involve multiplication of potentially large numbers. While the target code uses `long long` and `double` which mitigate overflow risk, the pattern of comparing ratios and performing arithmetic on user-influenced values (sampleSize, numRecords) shares conceptual similarity with integer handling vulnerabilities, though the immediate risk is lower.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 involves a broken cryptographic algorithm leading to a NULL pointer dereference. The target code has error handling (execStatus check) and uses pointers, but does not implement cryptographic algorithms or have similar error cleanup paths that could lead to NULL dereference from algorithm failures.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is an integer overflow in an audio decoder during mathematical computations. The target code contains arithmetic computations for determining sampling ratios and thresholds (e.g., `sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount`). Similar to Case 8, it involves multiplication of potentially large integers, though it uses double-precision comparisons which reduce but do not eliminate numeric precision/overflow concerns. The pattern of calculating thresholds based on user-controlled inputs is conceptually similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2021-32037_after_exclude_100:7ecfc28c:vulspec": {
    "timestamp": "2026-01-17T01:37:21.939402",
    "cve_id": "CVE-2021-32037",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7ecfc28c",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves weak random number generation (CWE-338) leading to information exposure in an authentication module. The target code uses `getRandomCursor()` but the context is for database sampling optimization, not security-critical random number generation for secrets or session IDs. The vulnerability patterns and domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2014-8566"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regular expression parser due to improper NUL byte handling. The target code is a database query executor for random sampling with no string parsing or buffer manipulation of external inputs in a similar manner. No meaningful similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a heap buffer overflow in an image codec due to incorrect memory allocation calculations. The target code performs logical flow control and query plan selection; it does not perform low-level memory allocation or buffer operations based on untrusted size calculations. Different vulnerability class and domain.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is a side-channel vulnerability (timing/EM) in a cryptographic library. The target code's primary concern is performance optimization and correctness of query execution plans, not constant-time execution or protection against physical side-channel attacks. Both involve mathematical computations, but the security context and threat models are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a privilege management flaw where a daemon fails to drop privileges. The target code is a database function that assumes it is already under a lock; it does not handle privilege states or process-level security contexts. No similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a use-after-free vulnerability in an image library due to inconsistent state management. The target code manages C++ objects and plan executors with clear ownership (using `std::unique_ptr`), and there is no indication of manual memory management or state corruption leading to use-after-free. Different vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in an image file parser. The target code does not parse file formats or external data structures; it operates on internal database collections and query parameters. No similarity in the attack surface or data validation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an integer overflow in an archive library during file position calculation. The target code performs arithmetic calculations (e.g., `sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount`) which could theoretically involve integer overflows if inputs are large and unchecked. However, the target code uses `long long` and `double` types, and the context is threshold comparison for algorithm selection, not memory allocation or array indexing. The similarity is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves a NULL pointer dereference triggered by unsupported cryptographic algorithm handling in a DNS server. The target code checks for null cursors (`if (!rsRandCursor)`) and handles them safely by returning early. There is no chain of improper error handling leading to a crash. Different domain and flaw pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an integer overflow in an audio decoder during mathematical computation for codebook setup. Similar to Case 8, the target code contains arithmetic operations (`sampleSize / (kCoefficient * numRecords * gTimeseriesBucketMaxCount)`) that could be susceptible to overflow or division-by-zero if inputs are malicious or extreme. However, the target code's purpose is performance decision-making, not decoding untrusted file formats. The potential for arithmetic issues exists but is not the primary focus or apparent vulnerability in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      }
    ]
  },
  "CVE-2022-21654_before_exclude_100:9ca1d454:vulspec": {
    "timestamp": "2026-01-17T01:37:40.173999",
    "cve_id": "CVE-2022-21654",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9ca1d454",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve X.509 certificate handling, but the vulnerability types are fundamentally different. CVE-2018-16149 is about improper ASN.1 parsing leading to signature verification bypass (CWE-347). The target code performs certificate digest calculation for session ID generation and does not parse or verify signatures. The attack surface (malformed certificate) is similar, but the core flaw and code pattern (digest update vs. ASN.1 parsing) are not.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both involve cryptographic operations, but the domains are entirely different (TLS session ID vs. DNSSEC key tag). The vulnerability in CVE-2018-5745 stems from using a broken/unsupported algorithm leading to a NULL pointer dereference (CWE-327/476). The target code uses standard, supported hash functions (SHA256) in a straightforward digest update pattern. There is no algorithm negotiation or error handling that could lead to a similar crash.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both involve cryptographic material in an authentication context, but the protocols and flaw types are dissimilar. CVE-2019-11235 is about insufficient validation of peer-supplied cryptographic scalars/points (CWE-345) in a handshake. The target code hashes locally configured trust material (CA cert, hash lists) for session binding. It does not process or validate untrusted peer data in a similar way; it only digests trusted, internal configuration.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve the generation of session identifiers. CVE-2014-8566's flaw is weak randomness leading to predictable session IDs (CWE-200/338). The target code contributes to a session ID by hashing configuration, which is a deterministic process. While both relate to session ID strength, the target code's role is to bind the session to specific config, not to generate entropy. The vulnerability pattern (weak RNG) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2014-8566"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. No meaningful similarity. CVE-2017-17787 is an out-of-bounds read (CWE-125) in an image file parser due to improper string termination checks. The target code performs in-memory cryptographic hash updates on controlled data structures (certificates, vectors). There is no parsing of external file formats, no string handling, and no risk of buffer over-read from untrusted data in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. No meaningful similarity. CVE-2019-25037 is a reachable assertion (CWE-617) due to improper input validation of DNS label lengths. The target code does not parse network packets, validate variable-length fields from untrusted sources, or use assertions for runtime input validation (it uses RELEASE_ASSERT, but on internal crypto API return values, not on parsed input).",
        "case_metadata": {
          "cve_id": "CVE-2019-25037"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. No meaningful similarity. CVE-2017-13035 is an out-of-bounds read (CWE-125) in a network protocol dissector due to insufficient length validation. The target code does not parse network protocols or have length fields from untrusted data. It operates on internal objects (X509, vectors) with known sizes.",
        "case_metadata": {
          "cve_id": "CVE-2017-13035"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Both involve kernel/user-space or system-level security, but the flaw types are unrelated. CVE-2013-2237 is an information leak (CWE-200) due to uninitialized memory being sent to user-space. The target code is user-space library code hashing data; it does not handle kernel memory or have interfaces that could expose uninitialized memory. The \"information exposure\" aspect is not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2013-2237"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. No meaningful similarity. CVE-2018-14461 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient TLV length validation. The target code is not a protocol parser, does not process TLVs, and does not read from packet buffers. The code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. No meaningful similarity. CVE-2018-18313 is an out-of-bounds read (CWE-125) in a regex compiler due to improper handling of NUL bytes in strings. The target code does not compile patterns, process strings with embedded NULs, or read from character buffers in a way that could be confused by termination characters.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      }
    ]
  },
  "CVE-2021-40576_before_exclude_100:c055b948:vulspec": {
    "timestamp": "2026-01-17T01:38:16.772804",
    "cve_id": "CVE-2021-40576",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c055b948",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free (CWE-416) in a network daemon due to uninitialized pointers and inconsistent state management. The target code is a media file parser function that performs pointer checks and list operations. The vulnerability types, domains (network service vs. media parsing), and code patterns (memory lifecycle errors vs. null pointer dereference potential) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an Out-of-bounds Read (CWE-125) in a regex compiler due to improper NUL byte handling. The target code performs pointer validation and list access but does not involve string/buffer parsing, character encoding, or the specific pattern of buffer over-read. The functional domains and flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is an Out-of-bounds Write (CWE-787) due to integer overflow in a network protocol handler. The target code performs simple pointer dereferencing and list access with no arithmetic operations, memory allocation, or network data parsing. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves improper memory buffer restriction (CWE-119) due to unchecked header values in an image parser. There is a superficial similarity in parsing file format structures (media box vs. image header). However, the target code's primary flaw potential is null pointer dereference or improper type casting, not a buffer overflow from unchecked arithmetic. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an Out-of-bounds Read (CWE-125) in a network protocol parser due to insufficient length validation. The target code does not parse TLV structures or validate length fields from untrusted data. The code patterns and attack surfaces (network packet vs. media file structure) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a heap buffer overflow (CWE-119) during image encoding due to insufficient padding allocation. The target code performs no memory allocation or buffer size calculations. The domains and specific flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a Race Condition (CWE-362) in a filesystem's node ID management. The target code is a simple, synchronous function for reading a media header with no concurrency, locking, or resource state transitions. The vulnerability categories are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an Out-of-bounds Read (CWE-125) in an XML parser due to inadequate bounds checking during multi-byte character processing. The target code does not process character encodings or perform byte-by-byte buffer traversal. The patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a Use-After-Free (CWE-416) due to a race condition in kernel memory policy management. The target code has no dynamic resource deallocation, locking, or concurrency aspects. The system level and flaw patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an Out-of-bounds Read (CWE-125) in an XML end tag parser. Similar to Case 8, it involves bounds checking during structured document parsing, which is not present in the target code's simple pointer and list operations on a media track structure.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-21654_after_exclude_100:3c5382e4:vulspec": {
    "timestamp": "2026-01-17T01:38:19.344092",
    "cve_id": "CVE-2022-21654",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3c5382e4",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve X.509 certificate handling, but the core flaw differs significantly. CVE-2018-16149 is about improper ASN.1 parsing leading to signature verification bypass (CWE-347). The target code focuses on hashing configuration for session IDs and does not parse or verify certificate signatures. The similarity is only at the domain level (certificates).",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-5745 involves DNSSEC key tag computation and unsupported algorithm handling leading to a NULL pointer dereference (CWE-327, CWE-476). The target code performs digest updates for session ID generation and does not involve DNS, key computation, or algorithm negotiation. The only tangential link is the use of cryptographic hashing.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-11235 is about insufficient validation of cryptographic material (scalars, points) in an EAP-pwd handshake (CWE-345). The target code hashes pre-validated configuration data and does not perform any validation of incoming cryptographic data from a peer. The contexts (authentication protocol vs. session state hashing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2014-8566 involves weak session ID generation due to poor randomness (CWE-200, CWE-338). The target code is part of a session ID generation process (updating a digest), but its role is to incorporate configuration state into the hash, not to generate the random component. The vulnerability pattern (cryptographic weakness) is different from the target code's functional pattern (deterministic hashing of state).",
        "case_metadata": {
          "cve_id": "CVE-2014-8566"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read (CWE-125) in a graphics file parser due to improper string termination checks. The target code performs controlled digest updates on internal data structures with fixed-size or checked lengths (e.g., hash.size()). There is no parsing of external, untrusted data in a way that could lead to buffer over-reads.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-25037 is a reachable assertion (CWE-617) triggered by improper input validation of DNS label lengths. The target code does not parse network packets, validate input lengths, or use assertions for runtime checks (it uses RELEASE_ASSERT, which is typically for invariant violations). The domains and flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-25037"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13035 is an out-of-bounds read (CWE-125) in a network protocol dissector due to insufficient length validation of packet fields. The target code does not parse network packets or external protocol data. It operates on internal configuration objects, making the attack surface and vulnerability pattern irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-13035"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2237 is an information leak (CWE-200) due to uninitialized kernel memory being copied to user-space. The target code hashes data but does not copy uninitialized memory anywhere. While both involve data structures, the target code's data sources (pointers, booleans, strings) are all explicitly defined and initialized.",
        "case_metadata": {
          "cve_id": "CVE-2013-2237"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient TLV length validation. Similar to case 7, the target code does not parse TLVs or any length-prefixed data from untrusted sources. The code patterns and vulnerability triggers are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) in a regex compiler due to improper handling of embedded NUL bytes in input strings. The target code uses string data (`crl`) but accesses it via `.data()` and `.length()`, which should correctly handle embedded nulls. The target code is not a parser/compiler for complex untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      }
    ]
  },
  "CVE-2021-40576_after_exclude_100:32f1717d:vulspec": {
    "timestamp": "2026-01-17T01:38:53.944490",
    "cve_id": "CVE-2021-40576",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "32f1717d",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves Use-After-Free (CWE-416) due to uninitialized pointers and inconsistent state management in a network daemon. The target code performs pointer checks and list operations in a media parsing context. The core vulnerability patterns (memory lifecycle errors vs. null pointer/type confusion) and domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is an Out-of-bounds Read (CWE-125) in a regex parser due to improper NUL byte handling. The target code involves pointer dereferencing and type checks but does not parse untrusted byte sequences or perform buffer reads. The flaw patterns (buffer boundary violation vs. potential null dereference/type confusion) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is an Out-of-bounds Write (CWE-787) from integer overflow in a network protocol handler. The target code performs simple pointer operations and assignments with no arithmetic, memory allocation, or network data processing. The vulnerability mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 involves improper memory buffer restriction (CWE-119) due to unchecked header values in an image parser. The target code also parses media structures (hint tracks) and has conditional checks, but the flaw pattern (untrusted input validation vs. internal state inconsistency) and severity differ. Both deal with media format handling, providing some conceptual overlap.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an Out-of-bounds Read (CWE-125) in a network protocol parser due to insufficient length validation. The target code parses media box structures but does not process variable-length TLV data from untrusted sources. The core flaw (missing bounds check on external input vs. potential null pointer access) is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a heap buffer overflow (CWE-119) during image encoding due to insufficient padding allocation. The target code performs no memory allocation or buffer writes; it only reads and assigns pointers and types. The vulnerability mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a Race Condition (CWE-362) in a filesystem's node ID management. The target code is a simple, synchronous function for retrieving a media subtype with no concurrency, locking, or resource lifecycle management. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is an Out-of-bounds Read (CWE-125) in an XML parser due to inadequate bounds checking during character encoding. The target code involves pointer dereferencing but no multi-byte character processing or buffer boundary checks. Both parse structured data, but the specific vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a Use-After-Free (CWE-416) due to a race condition and improper locking in a kernel memory subsystem. The target code has no dynamic memory deallocation, locking, or concurrency. The vulnerability class and context are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an Out-of-bounds Read (CWE-125) in an XML parser during end tag processing. The target code also parses structured data (media boxes) and performs conditional checks, but it does not process tag sequences or read beyond buffer boundaries. The similarity is limited to both being parsers.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2016-6295_before_exclude_100:4ca91b0b:vulspec": {
    "timestamp": "2026-01-17T01:39:08.210296",
    "cve_id": "CVE-2016-6295",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4ca91b0b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use After Free (CWE-416) in a network daemon's state management. The target code is PHP SNMP module initialization, which performs static setup, constant registration, and class definition. There is no dynamic memory management, error handling paths, or resource lifecycle code similar to the vulnerability case.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves an infinite loop (CWE-835) due to improper offset validation in an image file parser. The target code is a static initialization routine with no file parsing, loop constructs, or offset calculations. The functional domains and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5813"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 3 involves an Out-of-bounds Read (CWE-125) in a regex compiler due to improper NUL byte handling. The target code performs module initialization and constant registration. While both involve string/constant handling, the target code does not parse untrusted input or perform bounds-sensitive operations during this initialization phase. The vulnerability mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 involves an Out-of-bounds Write (CWE-787) due to integer overflow in a network protocol file transfer handler. The target code contains no network data processing, integer arithmetic on untrusted data, or dynamic memory allocation based on user input during initialization.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 involves an Out-of-bounds Read (CWE-125) in a network packet parser due to insufficient TLV length validation. The target code is a module initializer with no packet parsing, length field validation, or buffer reading logic. The attack surfaces and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 involves an Integer Overflow (CWE-190) leading to Out-of-bounds Write in a DNS domain name parser. The target code performs arithmetic-free constant definitions and class registration. There is no domain name parsing, length calculation, or buffer writing involved in this initialization code.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 involves a Double Free (CWE-415) in a document parser during error handling. The target code has no dynamic memory deallocation, error cleanup paths for parsed data, or file parsing logic. The memory management patterns are absent from this static initialization routine.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 8 involves a Use After Free (CWE-416) in a regex library due to improper memory management during encoding conversion. The target code registers a PHP class and constants. While both involve library initialization, the target code does not handle regex patterns, encoding conversions, or the complex memory state management that leads to the vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2019-13224"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 involves an Integer Overflow (CWE-190) leading to an Out-of-bounds Read in an SSH packet parser. The target code contains no network message processing, integer arithmetic for bounds checking, or validation of untrusted length fields. The code domains and vulnerability triggers are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 involves Improper Input Validation (CWE-20) leading to buffer overflow in a decompression module. The target code performs no decompression, input validation, or buffer manipulation. It is purely a setup routine for the SNMP extension with no processing of untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2016-6295_after_exclude_100:29800a11:vulspec": {
    "timestamp": "2026-01-17T01:39:19.284485",
    "cve_id": "CVE-2016-6295",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "29800a11",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use After Free in a network daemon's state management. The target code is PHP SNMP module initialization, which performs static setup, constant registration, and class definition. There are no dynamic resource allocations, error paths, or complex state management that could lead to a Use After Free in this initialization routine.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves an infinite loop due to improper offset validation in an image file parser. The target code is a straightforward module initialization function with no loops, file I/O, or parsing of untrusted data. The functionality and potential flaw patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-5813"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 3 involves an Out-of-bounds Read in a regex compiler due to improper NUL byte handling. The target code performs initialization and constant registration. While both involve string/constant handling, the target code does not parse complex patterns or untrusted input, making the vulnerability pattern not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 involves an Out-of-bounds Write due to integer overflow in a network protocol's file transfer handling. The target code performs static initialization with no network data processing, dynamic memory allocation based on user input, or integer arithmetic that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 involves an Out-of-bounds Read in a network packet parser due to insufficient length validation. The target code is a module initializer, not a packet/data parser. It does not process variable-length untrusted data where bounds checking is required.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 involves an Integer Overflow leading to Out-of-bounds Write in a DNS domain name parser. The target code performs arithmetic-free constant registration and class setup. There is no parsing of untrusted strings or length calculations that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 involves a Double Free in a file parsing module during error handling. The target code's initialization path has simple, linear resource registration (e.g., `zend_hash_init`) with no complex error paths that could leave resources in an inconsistent state leading to a double free.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 8 involves a Use After Free in a regex library due to improper memory management during encoding conversion. The target code initializes object handlers and registers classes. While both involve setting up handlers/objects, the target code's operations are static and do not involve the dynamic memory lifecycle or encoding mismatches that could cause a Use After Free.",
        "case_metadata": {
          "cve_id": "CVE-2019-13224"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 involves an Integer Overflow in a network protocol message handler leading to an out-of-bounds read. The target code does not process network messages, perform bounds checks, or handle variable-length data from untrusted sources. The code patterns and vulnerability triggers are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 involves Improper Input Validation leading to memory corruption in a decompression module. The target code is an initialization routine that validates no external input and performs no decompression or complex data transformation. The attack surface and flaw patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-2175_before_exclude_100:24b0fcd1:vulspec": {
    "timestamp": "2026-01-17T01:39:51.915148",
    "cve_id": "CVE-2022-2175",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "24b0fcd1",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code is a command-line insertion function in an editor (likely Vim) handling register pasting and expression evaluation. The domains (regex parsing vs. UI command handling), vulnerability types (memory corruption vs. potential logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon's memory management. The target code manages command-line state, user input, and register operations. While both involve state management, the target code shows no dynamic memory allocation/deallocation patterns that could lead to a use-after-free in the presented snippet. The attack surfaces (local socket vs. user keystrokes) and flaw nature are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs character input handling and simple integer comparisons/indexing (e.g., `new_cmdpos`, `ccline.cmdlen`). There is no complex arithmetic or memory allocation based on user-controlled integers that could lead to similar overflow/write conditions.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a missing authorization flaw in a kernel keyring subsystem. The target code is a user-space editor function with no apparent permission checks or security policy enforcement. The domains (kernel security vs. editor UI) and vulnerability class (authorization bypass vs. potential input validation) are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a use-after-free caused by a race condition in kernel memory policy due to improper locking. The target code is a synchronous, single-threaded command-line processing function. There is no evidence of concurrency, shared resource locking, or dynamic memory management that could lead to a similar race or use-after-free scenario.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow/over-read in a string formatting function. The target code uses `cmdline_paste` which may involve copying register contents into a command-line buffer. There is a tangential similarity in processing user-controlled data into a buffer. However, the target code abstracts the buffer management, and the primary flaw pattern (direct buffer size miscalculation) is not visible in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in an XML parser due to improper multi-byte character handling. The target code handles single-byte keystrokes (`plain_vgetc()`) and calls `cmdline_paste`. There is no complex encoding parsing or buffer state management that could lead to a similar bounds-checking failure.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a resource leak (reference count imbalance) in a kernel USB driver. The target code uses simple increment/decrement (`++no_mapping; --no_mapping;`) for flags, not reference counts for kernel objects. The resource management contexts (kernel driver lifecycle vs. editor command state) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in an XML end-tag parser. Similar to case 7, the target code does not parse structured markup language syntax. The code patterns (tag name matching, stack manipulation) and vulnerability trigger (malformed document structure) have no parallel in the simple input and paste logic shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in a network protocol parser due to insufficient length field validation. The target code does not parse network packets or any TLV-like structures. The function processes discrete keystrokes and calls other functions (`cmdline_paste`, `get_expr_register`) where buffer management is abstracted away.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-2175_after_exclude_100:0a9cd4ff:vulspec": {
    "timestamp": "2026-01-17T01:39:59.258903",
    "cve_id": "CVE-2022-2175",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0a9cd4ff",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code is a command-line insertion function in an editor (likely Vim) handling user input and register pasting. The domains (regex parsing vs. UI command handling), vulnerability types (memory corruption vs. potential logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management. The target code performs synchronous command-line input processing with no dynamic memory allocation or complex resource lifecycle management evident in the snippet. The attack surfaces (local socket vs. interactive user input) and flaw nature are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in a network file transfer protocol. The target code handles single character input and pastes register content. There is no arithmetic on user-controlled sizes, network data parsing, or buffer writing operations shown. The contexts are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in the Linux kernel's key management subsystem. The target code is user-space application code for command-line editing with no permission checks or security context operations. The domains (kernel security vs. editor UI) and vulnerability classes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-10675 is a use-after-free caused by a race condition in kernel memory policy code. The target code is a linear, non-concurrent function processing local input. There is no evidence of shared resource management, locking, or parallel execution that could lead to a similar race condition.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2015-0241 is a buffer overflow/over-read in string formatting. The target code's `cmdline_paste` function (not fully shown) could potentially involve buffer operations when inserting register content. There is a tangential similarity in processing user-provided data that may need bounds checking, but the specific mechanisms (numeric formatting vs. register pasting) and code patterns are very different.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper multi-byte character handling. The target code reads single characters via `plain_vgetc()` and handles command-line state. There is no complex encoding parsing or multi-byte buffer navigation. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-8925 is a resource leak (reference count imbalance) in a kernel USB driver. The target code uses simple increment/decrement (`++`/`--`) on flags (`no_mapping`, `allow_keys`) for control flow, not for resource reference counting. The scope and consequence of the counting errors are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2017-8925"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML end-tag parser. Similar to case 7, the target code does not parse structured markup language tags. The input model (single keystrokes vs. document parsing) and the resulting memory safety issue are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse network packets or TLVs. While both handle external input, the data structures, parsing logic, and validation requirements are completely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2013-2020_after_exclude_100:c379cc8a:vulspec": {
    "timestamp": "2026-01-17T01:40:38.520405",
    "cve_id": "CVE-2013-2020",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c379cc8a",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free due to uninitialized pointers and inconsistent state management. The target code performs simple file reading and string processing with clear allocation and deallocation paths. No pointer aliasing or complex state management that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves an out-of-bounds read due to improper NUL byte handling. The target code reads a specified length from a file and processes it. While both involve reading data, the target code's vulnerability pattern would be different (e.g., integer issues with `len` or file reading errors) rather than embedded NULs causing misinterpretation of length.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a Double Free in ClamAV, which is the same system as the target code (ClamAV's SIS file parsing). This provides contextual relevance. However, the vulnerability patterns differ: CVE-2011-1003 is a double free during error handling in VBA extraction, while the target code's potential flaws would relate to integer handling, bounds checking, or null termination.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 involves an out-of-bounds write during text encoding conversion. The target code performs a buffer transformation (collapsing a 2-byte sequence to 1-byte). Similarities exist in buffer manipulation and the need for careful length calculation. The target code's `for (i = 0 ; i < len; i+=2) name[i/2] = name[i];` could be problematic if `len` is odd or if the source buffer isn't as expected.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 5 involves an out-of-bounds write due to integer overflow in allocation size calculation. The target code has a similar pattern: it takes an input `len` (uint32_t), bounds it (`if (len>400) len=400;`), then allocates `len+1`. If `len` is close to UINT32_MAX, `len+1` could wrap to 0, causing a small allocation followed by a large read/write. This is a direct parallel.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 involves buffer overflow due to incorrect length calculation during string concatenation. The target code performs a length transformation: it reads `len` bytes but the output string will be roughly `len/2` bytes. The calculation `name[i/2] = name[i];` and null termination `name[i/2]='\\0';` assumes even `len` and correct indexing. Off-by-one or integer truncation issues could occur.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves a heap buffer overflow due to improper length validation. The target code validates `len` against a maximum (400) but does not validate that `ptr` is within the file bounds or that `len` is even. While both involve memory operations based on length values, the specific trigger (negative length bypass) is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 8 involves integer overflow leading to out-of-bounds write during domain name parsing. Similar to case 5, the target code's `len+1` allocation is vulnerable to integer wrap if `len` is UINT32_MAX. Additionally, the `for` loop uses `i < len` with `i+=2`, which could behave unexpectedly if `len` is odd or very large after wrap.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 involves integer overflow bypassing bounds checks. The target code's check `if (len>400) len=400;` prevents large values, but if `len` is between 400 and UINT32_MAX, `len+1` could still overflow to a small value. This is a similar pattern: an initial bounds check that doesn't prevent integer overflow in a subsequent operation.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves an out-of-bounds read during XML tag parsing. The target code reads data from a file into a buffer and processes it. Both involve reading operations, but the target code's vulnerability would stem from file I/O errors, integer issues with `len`, or buffer index miscalculation, rather than parser state corruption.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2013-2020_before_exclude_100:939e9692:vulspec": {
    "timestamp": "2026-01-17T01:40:39.147711",
    "cve_id": "CVE-2013-2020",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "939e9692",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free due to uninitialized pointers and inconsistent state management. The target code performs simple file reading and string processing with clear allocation and deallocation paths. No pointer aliasing or complex state management that could lead to use-after-free is present.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is an Out-of-bounds Read due to improper NUL byte handling. The target code reads a specified length from a file and processes it. While it does involve reading data, the vulnerability pattern is different. The target code's primary risk is not an over-read from improper NUL handling but could be related to integer handling with `len`.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 3 is a Double Free in ClamAV, which is the same system domain as the target code (ClamAV's SIS file parsing). The functional domain is similar (file parsing in antivirus engine), and both involve memory management. However, the specific flaw pattern (double free vs. potential buffer overflow/underflow) and code constructs differ.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 is an Out-of-bounds Write due to missing validation of error codes and unsafe buffer copies during text encoding conversion. The target code performs a buffer write (`fread`) and an in-buffer transformation. The relevance comes from the pattern of reading external data into a buffer and manipulating it without full validation of the source data's integrity, though the specific vulnerability mechanism differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 5 is an Out-of-bounds Write enabled by an Integer Overflow in a size calculation (CWE-190). The target code has a similar pattern: it takes an external `len` parameter, performs a conditional clamp (`if (len>400) len=400;`), and uses it for allocation and `fread`. The integer overflow risk is present if `len` is very large (close to UINT32_MAX), causing the clamp to not trigger, and `len` could wrap in operations like `i+=2` or `i/2`. The pattern of external size control leading to allocation and buffer operations is similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 involves buffer overflow due to missing length validation and incorrect size calculation during string concatenation. The target code does have a length check and allocation, but its transformation loop (`for (i = 0 ; i < len; i+=2) name[i/2] = name[i];`) writes to `name[i/2]` assuming the destination buffer is half the size, which is correct due to the allocation. The relevance is low as the flaw pattern (classic `strcpy`/`sprintf` overflow) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a heap buffer overflow due to insufficient validation of string lengths. The target code validates `len` against a maximum (400) but does not validate the relationship between `len` and `ptr` or the file size. If `ptr + len` exceeds the file size, `fread` may read less data, but the loop still processes up to the original `len`, potentially reading uninitialized heap data. This is a different pattern from xmlStrlen returning a negative value.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 8 is an Out-of-bounds Write enabled by an Integer Overflow in a length calculation. The target code's vulnerability is similar: the `len` parameter is a `uint32_t`. If `len` is, for example, 0xFFFFFFFF, the check `if (len>400)` passes, `len` remains 0xFFFFFFFF. Allocation of 0xFFFFFFFF may fail or cause integer wrap in `malloc`. If allocation succeeds, `fread` of that size likely fails, but the loop `for (i = 0 ; i < len; i+=2)` will wrap due to `i+=2` overflow, causing infinite loop or out-of-bounds write. The pattern of external integer input leading to arithmetic issues is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is an Integer Overflow (CWE-190) leading to insufficient validation and memory corruption. The target code's handling of the `len` parameter has similar integer overflow risks, especially in the loop condition and index calculation (`i/2`). The context (filesystem/image parsing vs. file parsing) is analogous. Both involve parsing structured data from an untrusted source with size fields.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an Out-of-bounds Read during XML end tag parsing due to insufficient bounds checking. The target code reads data into a buffer and then processes it with a loop. The potential out-of-bounds read could occur if `fread` reads fewer bytes than `len` (e.g., due to EOF), but the loop still uses the original `len`. This is a different pattern from parser state manipulation, but shares the theme of improper bounds checking during sequential data processing.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-27950_before_exclude_100:174364e6:vulspec": {
    "timestamp": "2026-01-17T01:40:49.109262",
    "cve_id": "CVE-2022-27950",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "174364e6",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a USB HID probe function with no complex integer arithmetic, memory allocation size calculations, or network protocol parsing. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in FUSE ioctl handling due to insufficient iovec length validation. The target code performs basic device initialization and workqueue scheduling. While both are in the Linux kernel, the functionality (USB HID vs. FUSE filesystem), attack surface (physical USB device vs. malicious userspace server), and flaw pattern (validation vs. buffer overflow) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a race condition in F2FS nid management. The target code has a single execution path in a probe function with no concurrent operations or shared resource synchronization shown. The only slight similarity is both being in kernel drivers, but the concurrency flaw pattern is not present in the target.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is a TTY race condition leading to buffer overflow. The target code has no shared buffers, concurrent writers, or workqueue race patterns (the delayed work is queued but not raced against). Both are kernel drivers, but the synchronization flaw is not applicable to the linear probe flow.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 5 is a NULL pointer dereference in USB/IP due to insufficient validation of URB fields. The target code is also a USB-related kernel driver (HID over USB). Both involve USB device initialization and potential lack of validation (though target code validates `hid_is_usb`). The flaw pattern (insufficient validation leading to crash) and domain (USB kernel drivers) are similar, but the specific trigger (URB fields vs. device state) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in Perl's regex compiler due to improper NUL byte handling. The target code is a kernel USB driver with no string parsing, regex compilation, or buffer read operations. The domains (userspace library vs. kernel driver) and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 7 is a NULL pointer dereference in a USB serial driver (cypress_m8) due to insufficient validation of USB endpoint descriptors during probe. The target code is also a USB HID driver probe function. Both follow similar patterns: USB driver initialization, potential missing validation of device descriptors or state, and similar error handling paths. The vulnerability type (CWE-703/476) and context (USB driver probe) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 is a race condition leading to NULL pointer dereference in the keyring subsystem. The target code has no apparent concurrency or shared keyring state. Both are in the kernel, but the synchronization flaw pattern is not present in the linear probe function.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 9 is almost identical to Case 7: a NULL pointer dereference in a USB serial driver (mct_u232) due to missing endpoint validation in the probe function. The target code (elo_probe) is structurally similar - a USB HID driver probe with potential for insufficient validation of the USB device or its descriptors before accessing them. The domain, vulnerability pattern, and code structure are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 is a double free in ClamAV's document parser during error handling. The target code has simple error cleanup (`kfree`) with no double-free pattern. Both have error paths, but the memory management flaw (double free vs. single free) and domain (antivirus file parsing vs. kernel USB driver) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2022-27950_after_exclude_100:4f63d3d6:vulspec": {
    "timestamp": "2026-01-17T01:41:30.872042",
    "cve_id": "CVE-2022-27950",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4f63d3d6",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a USB HID probe function with no complex integer calculations or network data parsing. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in FUSE ioctl handling due to insufficient validation of iovec lengths. The target code performs basic USB device initialization. Both involve kernel subsystems but the vulnerability mechanism (buffer overflow vs. potential resource management errors) and attack surfaces (userspace server vs. physical USB device) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a race condition in filesystem node ID management. The target code has a delayed workqueue but no apparent concurrent access to shared data structures during probe. Both are in the kernel, but the concurrency patterns and resource types (nid lists vs. USB device handles) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a TTY race condition leading to buffer overflow. The target code uses a delayed workqueue but doesn't show the same concurrent writer pattern. Both involve kernel workqueues, but the synchronization requirements and data structures are different (TTY buffers vs. USB device context).",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 5 is a NULL pointer dereference in USB/IP due to insufficient validation of URB fields. The target code is a USB HID probe function that could potentially have similar issues with USB device descriptor validation. Both involve USB subsystem error handling, though the specific context (USB/IP protocol vs. HID driver) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in Perl's regex engine due to NUL byte handling. The target code is a kernel USB driver probe function with no string parsing or regex processing. The domains and vulnerability patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 7 is a NULL pointer dereference in a USB serial driver (cypress_m8) due to insufficient validation of USB endpoint descriptors during probe. The target code is similarly a USB HID driver probe function that accesses USB device structures (udev, interface_to_usbdev). Both follow similar patterns: USB driver initialization, potential missing endpoint/descriptor validation, and similar error handling paths. The vulnerability type and code patterns are highly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a race condition leading to NULL pointer dereference in kernel keyring initialization. The target code has initialization logic but no apparent concurrent initialization race. Both involve kernel resource initialization, but the synchronization requirements and subsystem contexts differ substantially.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 9 is almost identical to Case 7 - a NULL pointer dereference in a USB serial driver (mct_u232) due to missing endpoint validation during probe. The target code shares the exact same context: USB driver probe function, similar USB device structure access patterns, and comparable error handling. This provides direct reference value for potential missing validation in the target's USB device handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a double free in ClamAV's document parser during error conditions. The target code has error paths with resource cleanup (kfree, usb_put_dev) but no complex parsing or double-free pattern. Both involve error path resource management, but the mechanisms and contexts (userspace antivirus vs. kernel driver) are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2008-3526_before_exclude_100:e972aa77:vulspec": {
    "timestamp": "2026-01-17T01:41:55.694243",
    "cve_id": "CVE-2008-3526",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e972aa77",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve kernel code and user-space data copying, but the vulnerability types differ. CVE-2010-4650 is a buffer overflow due to insufficient validation of iovec lengths in FUSE. The target code performs length checks (`authkey->sca_keylength > optlen`) and uses `kmalloc` with the user-provided `optlen`, which is a similar pattern of trusting and validating user input. However, the core flaw (buffer overflow vs. potential integer overflow/underflow in allocation) and subsystem (FUSE vs. SCTP) are different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves an integer overflow in a size calculation leading to an undersized buffer allocation and subsequent OOB write. The target code uses a user-controlled `optlen` for a `kmalloc` allocation. If `optlen` is very large, it could cause an integer overflow in the `kmalloc` wrapper or exhaust memory, but the code checks it's greater than `sizeof(struct sctp_authkey)`. The similarity lies in user-controlled allocation size, but the specific integer overflow-to-corruption chain is not directly mirrored here.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-16914 is a NULL pointer dereference due to insufficient validation of URB fields. The target code validates the `authkey` structure fetched from user space and checks association ID. It does not have a similar pattern of dereferencing a pointer that could be NULL due to missing validation of a structure field from an untrusted source. The domains (USB/IP vs. SCTP) and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3137 is a NULL pointer dereference due to missing validation of USB endpoint descriptors during device initialization. The target code operates on socket options, not hardware descriptor parsing. There is no analogous pattern of traversing and dereferencing nested structures from an external device without validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-1792 is a race condition leading to a NULL pointer dereference during keyring initialization. The target code is a synchronous socket option setter function (`sctp_setsockopt_auth_key`) with no apparent shared resource concurrency issues or similar race condition patterns. The domains and synchronization contexts are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read due to insufficient validation of a TLV length field. The target code validates that `authkey->sca_keylength` is not larger than the overall `optlen`. This is a similar pattern of validating an inner length field against an outer container size to prevent OOB access. However, the vulnerability type (OOB read in a parser vs. potential OOB write/info leak in kernel memory) and context (user-space packet analyzer vs. kernel socket option) reduce relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2014-0196 is a race condition in the TTY layer leading to buffer overflow. The target code shows no evidence of concurrent access to shared buffers without proper locking. It is a straightforward, synchronous system call handler.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-18249 is a filesystem-specific race condition in node ID management. The target code is a network protocol socket option handler with no analogous resource allocation state machine vulnerable to TOCTOU races.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-10154 involves improper use of stack memory with scatterlists for crypto operations when VMAP_STACK is enabled. The target code uses `kmalloc` for the `authkey` buffer, not stack memory. However, the broader context is similar: both are in the kernel, both handle security-sensitive data (crypto keys / authentication keys), and both involve copying user data into kernel memory for processing. The specific flaw pattern (stack memory assumption) is different, but the security domain and data flow are comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This is the most relevant case. CVE-2013-2206 is in the same subsystem: the Linux kernel SCTP implementation. The target code is `sctp_setsockopt_auth_key`. Both involve SCTP association handling and processing user-provided data. The vulnerability type for CVE-2013-2206 is improper handling of exceptional conditions (state management). While the target code's primary concern is input validation (lengths, association ID), flaws in such SCTP option handlers could lead to similar state management issues (e.g., using the `asoc` pointer after error conditions). The code patterns, context, and potential for state-related bugs are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2206"
        }
      }
    ]
  },
  "CVE-2021-37647_before_exclude_100:a1540d10:vulspec": {
    "timestamp": "2026-01-17T01:42:21.627440",
    "cve_id": "CVE-2021-37647",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a1540d10",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code involves sparse tensor validation in a machine learning framework, while CVE-2015-7511 is a cryptographic side-channel vulnerability in libgcrypt. The vulnerability type (information exposure via side channels), domain (cryptography), and code patterns (constant-time operations) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves DNSSEC key processing and cryptographic algorithm handling in BIND9, leading to a NULL pointer dereference. The target code performs input validation and tensor construction with no cryptographic operations or similar error handling patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Both involve input parsing and validation, but CVE-2016-7837 is a stack-based buffer overflow in BlueZ configuration parsing. The target code validates tensor shapes and indices but uses safe OP_REQUIRES checks and does not involve raw buffer operations or string parsing that could lead to buffer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is a privilege escalation vulnerability in PostgreSQL's query planner due to improper access control. The target code performs data validation and tensor construction with no privilege checks, user authentication, or database query planning involved.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve input validation, but CVE-2016-8692 is a divide-by-zero vulnerability in JasPer image dimension processing. The target code validates tensor shapes and indices but does not perform division operations. The similarity is limited to general input validation concepts.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 involves integer overflow in libarchive's ISO9660 parser during position calculation. The target code uses int64_t for index comparisons and loop bounds, which could theoretically have integer overflow issues, but the code patterns and validation approaches differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-15900 is a privilege escalation vulnerability in doas due to improper input validation of user/group IDs. The target code validates tensor data structures with no user authentication, privilege management, or command-line argument parsing involved.",
        "case_metadata": {
          "cve_id": "CVE-2019-15900"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1178 involves integer overflow leading to heap buffer overflow in GIMP's PCX plugin. The target code validates tensor dimensions and could potentially have integer overflow issues in index calculations (e.g., indices->dim_size(0)), but the memory allocation patterns and file parsing context are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3603 is a privilege separation failure in radvd leading to unnecessary privilege execution. The target code has no privilege management, daemon initialization, or process control mechanisms. The vulnerability domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2009-3909 involves integer overflow in dimension calculations leading to heap buffer overflow in GIMP's PSD plugin. Similar to case 8, the target code validates tensor dimensions and could have integer overflow concerns, but the specific context (image file parsing vs. tensor construction) and memory allocation patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      }
    ]
  },
  "CVE-2008-3526_after_exclude_100:d5ff394f:vulspec": {
    "timestamp": "2026-01-17T01:42:35.331349",
    "cve_id": "CVE-2008-3526",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d5ff394f",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve kernel code and user-space data copying, but the vulnerability types differ. CVE-2010-4650 is a buffer overflow due to insufficient validation of iovec lengths in FUSE. The target code performs bounds checking (`authkey->sca_keylength > optlen - sizeof(struct sctp_authkey)`) and uses `kmalloc` with the user-provided `optlen`. The primary similarity is the pattern of copying user data into a kernel buffer, but the specific flaw (overflow vs. integer handling/validation) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The core similarity is improper validation of a length field leading to potential out-of-bounds access. CVE-2018-20750 involves integer overflow/wraparound in a size calculation. The target code has a direct check comparing `sca_keylength` against `optlen - sizeof(struct sctp_authkey)`. While it prevents the overflow, the pattern of validating a user-controlled sub-field against a parent container's total size is conceptually similar. However, the target code's check appears correct, making the relevance about the defensive pattern rather than an identical flaw.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-16914 is a NULL pointer dereference due to insufficient validation of URB fields. The target code validates the `sca_assoc_id` via `sctp_id2assoc` and checks for a NULL `asoc` under specific conditions. While both involve validating user-provided IDs to retrieve kernel objects, the target code's logic is more about association lookup failure than dereferencing a potentially NULL pointer obtained from an unchecked structure field. The vulnerability class and context are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3137 is a NULL pointer dereference during USB driver initialization due to missing endpoint validation. The target code operates in a socket options context, validating user input and performing memory allocation. There is no analogous pattern of traversing hardware descriptor structures or missing checks on device-provided data. The domains (USB serial vs. network protocol) and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-1792 is a race condition leading to a NULL pointer dereference during concurrent keyring initialization. The target code is a socket option setter (`sctp_setsockopt_auth_key`) which is likely called in a process context for a specific socket. There is no indication of shared resource manipulation or concurrency issues in the provided code snippet. The vulnerability classes (race condition vs. input validation) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-14461 is an out-of-bounds read due to insufficient validation of a TLV length field. This is conceptually similar to the validation in the target code, which checks if `authkey->sca_keylength` exceeds the remaining buffer size (`optlen - sizeof(struct sctp_authkey)`). Both involve ensuring a sub-component's length does not exceed its containing structure's bounds. The key difference is the target code performs this check explicitly, while the vulnerability case lacked it. The code pattern and defensive concern are relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2014-0196 is a race condition in the TTY subsystem leading to buffer overflow. The target code shows no evidence of concurrent access to shared buffers, race conditions, or lock-free manipulation of complex state. It performs a linear sequence of operations: allocate, copy, validate, lookup, act. The vulnerability domains (terminal I/O vs. socket options) and flaw types (concurrency vs. input validation) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition in filesystem metadata management (nid allocation). The target code is a straightforward system call handler for setting a socket option. It does not manage shared caches or perform non-atomic check-then-act sequences on global resources. The context and the nature of the potential flaw (concurrency bug vs. logic/validation bug) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-10154 involves improper memory assumptions (stack memory used as scatterlist) leading to buffer access issues. The target code also deals with kernel memory allocation (`kmalloc`) based on a user-controlled size (`optlen`). The common theme is careful handling of user-controlled sizes for kernel allocations. However, the specific vulnerability (VMAP_STACK interaction with crypto API) is highly specific and not mirrored in the SCTP code, which uses a simple `kmalloc`/`copy_from_user`/`kfree` pattern.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This is the most relevant case. Both vulnerabilities are in the Linux kernel's SCTP implementation. CVE-2013-2206 is an improper handling of exceptional conditions (state management) in the SCTP state machine. The target code is another SCTP socket option handler (`sctp_setsockopt_auth_key`). They share the exact same subsystem, similar patterns of association lookup (`sctp_id2assoc`), and error handling (`goto out`). While the specific flaw differs (state machine vs. parameter validation), the code patterns, context, and defensive programming concerns (validating user input within the SCTP subsystem) are nearly identical, providing high reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2206"
        }
      }
    ]
  },
  "CVE-2021-37647_after_exclude_100:ca4249ec:vulspec": {
    "timestamp": "2026-01-17T01:42:38.601823",
    "cve_id": "CVE-2021-37647",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ca4249ec",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs input validation and tensor construction for a machine learning dataset. CVE-2015-7511 is a cryptographic side-channel vulnerability (CWE-200/385) in a low-level math library. The domain (ML vs. crypto), vulnerability type (logic/validation vs. side-channel), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves broken cryptography (CWE-327) and NULL pointer dereference (CWE-476) in a DNS server during DNSSEC key processing. The target code validates tensor shapes and indices for a sparse tensor dataset. The functionalities (cryptographic validation vs. data structure validation) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2016-7837 is a classic stack buffer overflow (CWE-119) from parsing untrusted input in a Bluetooth utility. The target code also parses input (tensors) but performs extensive validation (OP_REQUIRES) and uses safe container types (Tensor, InlinedVector). The attack surface (file/CLI input vs. API input) and memory safety context are different, though both involve input parsing.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2019-10128 is an access control flaw (CWE-284) in a database query planner involving privilege checks. The target code validates tensor properties and order but does not involve any authorization, user privileges, or multi-user context. The core issue (security boundary violation vs. data integrity validation) is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-8692 is an integer divide-by-zero (CWE-369) in an image parser due to missing validation of sampling factors. The target code performs validation (e.g., shape checks, index ordering) which could prevent similar arithmetic issues, but it does not contain division operations or direct arithmetic on untrusted values that could lead to divide-by-zero. The validation pattern is conceptually similar but the specific flaw is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-5844 is an integer overflow (CWE-190) during file position calculation in an archive parser. The target code uses `int64_t` for indices and performs loop bounds checks (`i < indices->dim_size(0)`). While integer overflows are a general concern, the code does not perform arithmetic on untrusted sizes (like multiplying dimensions) that could overflow. The relevance is in the general theme of validating numeric inputs from untrusted sources.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2019-15900 involves improper input validation (CWE-754) of user/group IDs leading to privilege escalation in a security tool. The target code validates tensor shapes and values but in a completely different domain (data processing vs. security enforcement). The flaw pattern (checking return values) is a generic good practice, but the context and consequences are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15900"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2011-1178 is an integer overflow (CWE-190) leading to a heap buffer overflow (CWE-122) in an image parser. The target code validates tensor dimensions and could prevent similar issues if those dimensions were used for memory allocation later. However, the shown code does not perform memory allocation based on the validated dimensions; it constructs a `SparseTensor` object. The relevance is in validating integer inputs that could later be used unsafely, but the direct vulnerability pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2011-3603 is an input validation flaw (CWE-20) in a daemon's privilege separation initialization, leading to unnecessary privileges (CWE-250). The target code validates data input shapes and values but does not involve any privilege management, process state, or security boundaries. The concept of validating state is similar at a very high level, but the specifics are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2009-3909 is an integer overflow (CWE-190) in an image header parser leading to a heap overflow. Similar to case 8, the target code's validation of tensor dimensions (like `dense_shape`) could prevent analogous issues if those dimensions were used in unsafe arithmetic for memory allocation. The code ensures `dense_shape` is a vector and uses it to construct a `TensorShape`, but does not show the subsequent allocation. The pattern of validating numeric inputs from untrusted sources is the point of similarity.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      }
    ]
  },
  "CVE-2021-4166_before_exclude_100:529be57c:vulspec": {
    "timestamp": "2026-01-17T01:43:12.430188",
    "cve_id": "CVE-2021-4166",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "529be57c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a window/buffer management function in an editor (likely Vim) with no regex parsing or similar memory boundary checks for string data. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's resource management. The target code manages window and buffer lifecycles, but its primary operations involve list traversal, window closing (`win_close`), and buffer state checks (`buf_hide`, `bufIsChanged`). While it has dynamic resource management, the pattern of uninitialized pointers and error path cleanup leading to UAF in a network service is not similar to the editor's UI state management.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs arithmetic for array indexing (`opened[i]`) and loop bounds but uses `alloc_clear` and checks `opened_len` against `ARGCOUNT` and `alist->al_ga.ga_len`. There is no complex integer arithmetic for buffer sizes that could wrap, and the domain (GUI window management vs. network protocol parsing) is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-10675 is a use-after-free due to a race condition from improper locking in the Linux kernel. The target code has no explicit locking. However, it does manage shared resources (windows, buffers, argument lists) and has to re-validate pointers (`win_valid`, `bufref_valid`, `valid_tabpage`) after calls that may trigger autocommands, indicating awareness of asynchronous state changes. This is a defensive pattern, not a vulnerability pattern. The similarity is only in the broad concept of resource lifecycle validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2015-0241 is a buffer over-read/overflow in a numeric-to-string formatter. The target code does string comparison via `fullpathcmp` and uses `alist_name` to get strings, but there is no evidence of manual buffer copying or size calculation errors. The functions used are likely safe library routines. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking during tag parsing. The target code is not a parser and its array accesses (`opened[i]`, `AARGLIST(alist)[i]`) are guarded by loop conditions comparing `i` against `opened_len` and `alist->al_ga.ga_len`. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in a text parser due to improper buffer management during multi-byte character processing. The target code does not process character encodings or manage input buffers in a similar way. It deals with high-level editor objects, not low-level byte streams.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in a kernel keyring subsystem. The target code performs no permission checks; it is purely about UI layout and buffer visibility. The security models and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code parses no network protocols. Its length field (`opened_len`) is derived from `ARGCOUNT` and used directly for allocation and loops, with no complex validation logic that could be bypassed.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2014-9512 is an improper link resolution/path traversal vulnerability in a file sync tool. The target code uses file paths (`buf->b_ffname`, `alist_name`) for comparison but does not resolve them for file system access. The function `do_ecmd` may eventually open files, but the provided code segment focuses on window arrangement, not path sanitization. The potential similarity is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2014-9512"
        }
      }
    ]
  },
  "CVE-2021-4166_after_exclude_100:e1cc4773:vulspec": {
    "timestamp": "2026-01-17T01:43:42.580658",
    "cve_id": "CVE-2021-4166",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e1cc4773",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a window/buffer management function in an editor (likely Vim) with no regex parsing, no character encoding issues, and a completely different domain (UI management vs. string parsing).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's memory management. The target code manages window and buffer lifecycles but does not show obvious patterns of use-after-free (it carefully manages alist reference counts and validates window/tabpage pointers after autocommands). The domains and error handling patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs arithmetic but does not have obvious integer overflow vulnerabilities in buffer allocations (it uses `alloc_clear`). The functionality (UI layout) and attack surface are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-10675 is a use-after-free due to a race condition in kernel memory policy. The target code has a complex state with autocommands that can asynchronously change the window/tab layout (e.g., `win_valid` checks after autocommands), introducing a form of concurrency concern. However, it's not a true multi-threading race, and the resource management (alist refcount) is more controlled than the kernel's lock release issue.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2015-0241 is a buffer overflow in numeric-to-string formatting. The target code does not perform complex string formatting or unchecked buffer copies. Its memory operations are primarily via `alloc_clear` and `vim_free`. The domains are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking during end tag processing. The target code does not parse structured markup languages and its array accesses (e.g., `opened[i]`) are bounded by `opened_len` and checked against `alist->al_ga.ga_len`.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML/HTML parser's character encoding handling. The target code does not process character encodings or multi-byte sequences. Its input is internal command arguments, not parsed document data.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization vulnerability in a kernel keyring subsystem. The target code has no authentication or authorization checks; it's purely a UI layout function. The security models are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code does not parse network protocols or TLVs. Its length checks are straightforward array bounds checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2014-9512 is an improper link resolution/path traversal in a file synchronization tool. The target code deals with file paths (e.g., `buf->b_ffname`, `alist_name`) and uses `fullpathcmp` for comparison, which could have path handling implications. However, the core vulnerability (symlink attacks via absolute paths) is not present here, and the function's primary purpose is window management, not file access security.",
        "case_metadata": {
          "cve_id": "CVE-2014-9512"
        }
      }
    ]
  },
  "CVE-2022-32545_before_exclude_100:d34c5448:vulspec": {
    "timestamp": "2026-01-17T01:44:26.059444",
    "cve_id": "CVE-2022-32545",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d34c5448",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free (CWE-416) in a network service daemon (MiniSSDPd). The target code is an image pixel reading function in ImageMagick with no dynamic memory management or pointer lifecycle issues evident in the provided snippet. Different domain, vulnerability type, and code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 involves an improper memory buffer restriction (CWE-119) in an image decoder (OpenJPEG) due to unchecked header values. The target code also parses image data (PSD) and performs pixel scaling. The relevance is weak because the specific flaw (allocation failure due to unchecked header) and the code structure (header parsing vs. pixel loop) are different, though both are in image processing domains.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 involves an Out-of-bounds Write (CWE-787) in an image file plugin (GIMP XWD) due to insufficient validation of color map entries. The target code reads PSD channel pixels and writes pixel data via `SetPSDPixel`. Both handle image data and write to pixel buffers. The relevance is moderate because the vulnerability type (OOB write) is a risk in the target's pixel writing logic, but the specific trigger (color map count vs. entries) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves an Out-of-bounds Read (CWE-125) in a regular expression engine (Perl) due to improper NUL byte handling. The target code is an image pixel reader with no regex parsing or string processing. Different domain, vulnerability type, and code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 involves a Double Free (CWE-415) in libgd's BMP handling during error cleanup. The target code shows no dynamic memory allocation/deallocation within the function; it operates on provided pixel buffers and uses `GetAuthenticPixels`/`SyncAuthenticPixels`. Different vulnerability type and memory management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 6 involves an Out-of-bounds Read (CWE-125) in ImageMagick's PSD decoder (`coders/psd.c`). The target code `ReadPSDChannelPixels` is from the same ImageMagick PSD decoder module. Both process PSD files, read data from buffers (`pixels` pointer), and must handle bounds checking. The vulnerability type (OOB read) is directly relevant as the target code reads `packet_size` bytes without explicit bounds checking on the `p` pointer against the input buffer size. Code patterns and domain are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-7532"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 involves an Out-of-bounds Write (CWE-787) due to integer overflow in a VNC file transfer module. The target code performs pixel writes and has integer variables (`x`, `image->columns`, `number_bits`). There is a weak similarity in the potential for integer handling issues (e.g., in the loop `x` is decremented), but the domain (network protocol vs. image parsing) and specific flaw (allocation overflow) are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves an incorrect numeric conversion (CWE-681) in a GIF decoder leading to an infinite loop. The target code uses various numeric types (`ssize_t`, `size_t`, `unsigned short`) and has loops. There is a weak similarity in the risk of numeric confusion in image parsing, but the specific flaw (signedness in palette index) and manifestation (infinite loop) are not directly mirrored in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 involves an Out-of-bounds Read (CWE-125) in ImageMagick's RLE decoder due to insufficient validation of pixel calculations. The target code is also within ImageMagick, reading pixel data from a channel. Both are image decoders in the same codebase, processing formatted image data. The vulnerability type (OOB read) is relevant, as the target code reads a variable `packet_size` (1, 2, or 4 bytes) per pixel without verifying the source buffer has enough data. The code patterns (loops over image columns, reading from a pointer `p`) are similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7515"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 involves a resource management error (CWE-399, memory leak) in PHP's GD library during image scaling error handling. The target code does not show resource allocation/deallocation; it uses pixel queues and returns a boolean. Different vulnerability type (leak vs. buffer read/write) and error handling patterns.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      }
    ]
  },
  "CVE-2022-32545_after_exclude_100:46c3d522:vulspec": {
    "timestamp": "2026-01-17T01:44:39.688540",
    "cve_id": "CVE-2022-32545",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "46c3d522",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use After Free (CWE-416) in a network service daemon (MiniSSDPd). The target code is an image parsing function in ImageMagick with no dynamic memory allocation or pointer lifecycle management errors evident. The domains and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image format parsing (OpenJPEG/BMP vs. ImageMagick/PSD). The vulnerability in Case 2 is an out-of-bounds memory allocation due to unchecked header values (CWE-119). The target code reads pixel data with bounds defined by `image->columns` and uses `GetAuthenticPixels`, which suggests some bounds management. The similarity is in the domain (image parsing) but the specific flaw pattern (unchecked header leading to allocation failure) is not directly visible in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve image file parsing (GIMP/XWD vs. ImageMagick/PSD) and potential for out-of-bounds write (CWE-787). The target code's `SetPSDPixel` function (not shown in detail) is a critical point where improper validation of `channels`, `type`, or calculated `pixel` values could lead to writing out of bounds. The domain similarity and the presence of a pixel-setting function make this case a relevant reference for potential validation flaws.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves an out-of-bounds read (CWE-125) in a regular expression engine (Perl) due to improper NUL byte handling. The target code is an image pixel reader that processes a byte stream (`p`) but does not involve string parsing or NUL termination issues. The vulnerability types and domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a Double Free (CWE-415) in libgd's BMP handling during error cleanup. The target code snippet shows a straightforward pixel reading loop with no apparent dynamic memory allocation or complex error paths that could lead to double-free. The domain (image processing) is similar, but the vulnerability mechanism is not present in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This case is highly relevant. It involves the same system (ImageMagick), the same file format (PSD), and the same vulnerability type (CWE-125 - Out-of-bounds Read). The target function `ReadPSDChannelPixels` is a core PSD parsing function. The vulnerability in CVE-2016-7532 was in `RemoveResolutionFromResourceBlock`, but it demonstrates that PSD parsing in ImageMagick has a history of bounds checking issues. The target code reads from the `p` pointer which advances based on `packet_size` and `image->columns`. If the input buffer (`pixels`) is insufficient for the calculated read, an out-of-bounds read can occur. The patterns are almost identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-7532"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 involves an out-of-bounds write (CWE-787) due to integer overflow in a network protocol library (LibVNC). The target code performs arithmetic (e.g., `image->columns-x`) and loops, but the scale is small and there's no visible memory allocation. The primary similarity is the potential for integer issues in loop counters or calculations, but the context and severity differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves a numeric conversion error (CWE-681) in libgd's GIF parser leading to an infinite loop. The target code uses various numeric types (`ssize_t`, `size_t`) and has loops. A subtle numeric issue in the bit-depth handling (`image->depth > 1`) or in the `number_bits` calculation could theoretically affect control flow. However, the specific flaw pattern (signedness confusion in color map) is not directly analogous.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. This case involves the same system (ImageMagick) and the same vulnerability type (CWE-125 - Out-of-bounds Read) in a different decoder (RLE). The root cause in CVE-2016-7515 was insufficient validation leading to integer overflow in pixel calculations. The target code performs calculations with `image->columns`, `packet_size`, and bit manipulation. If `image->columns` or `packet_size` is derived from untrusted file data without proper validation, similar integer overflows could occur before or during the loop, leading to an out-of-bounds read of the `pixels` buffer. The pattern is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7515"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 involves a resource management error (CWE-399/memory leak) in PHP's GD library during image scaling error handling. The target code is a pixel reading function that uses ImageMagick's internal pixel queue functions (`GetAuthenticPixels`, `SyncAuthenticPixels`). While these may manage resources, the snippet does not show complex error paths or resource cleanup that could lead to leaks. The vulnerability type is different.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      }
    ]
  },
  "CVE-2021-41864_after_exclude_100:4624827d:vulspec": {
    "timestamp": "2026-01-17T01:44:54.805341",
    "cve_id": "CVE-2021-41864",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4624827d",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 is a buffer overflow in FUSE ioctl handling due to insufficient validation of iovec lengths. The target code performs memory allocation and freelist initialization but does not involve user-controlled buffer length validation or iovec structures. The core vulnerability patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a race condition in F2FS nid management. The target code is a static initialization function (`prealloc_elems_and_freelist`) with no concurrency or shared state manipulation shown. While both involve kernel resource management, the specific flaw (race condition vs. potential allocation error) and context are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in Perl's regex engine due to improper NUL byte handling. The target code is a Linux kernel BPF map memory allocator with no string parsing, character processing, or input validation logic. The domains and vulnerability patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a NULL pointer dereference in USB/IP due to insufficient validation of URB fields. The target code checks for allocation failure (`!smap->elems`) and handles errors with `goto free_elems`. It does not dereference unvalidated pointers from external inputs. The context (USB/IP protocol vs. BPF map initialization) is unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a NULL pointer dereference in a USB serial driver due to missing endpoint descriptor validation. The target code validates its own allocation result and has a clean error path. It does not parse or validate complex external descriptors. The driver subsystem and flaw pattern are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is an integer overflow leading to out-of-bounds write in LibVNC's file transfer. The target code calculates `elem_size * smap->map.max_entries`. If `elem_size` and `max_entries` are user-controlled 64-bit values, an integer overflow could occur before the allocation, making the allocated buffer smaller than expected. This is a potential similarity, but the target code's context (kernel BPF) and the specific overflow-to-corruption chain are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a double free in libguestfs due to error path handling issues. The target code has a single error path (`goto free_elems`) that frees `smap->elems` only once. It shows no pattern of ambiguous ownership or double cleanup. The flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a buffer overflow due to using scatterlist on non-contiguous stack memory (with VMAP_STACK). The target code uses `bpf_map_area_alloc` for contiguous kernel memory. While both involve memory allocation for security-sensitive operations, the specific vulnerability mechanism (VMAP_STACK assumptions) does not apply to the target's allocation path.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is an unbounded/overflowing memory allocation in USB/IP due to missing validation of network-provided size fields. The target code multiplies `elem_size` by `max_entries`. If `max_entries` is a large, untrusted value (e.g., from user-space BPF map creation), a similar integer overflow could cause undersized allocation. The pattern of \"size calculation without overflow check before allocation\" is similar, though the subsystems differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      }
    ]
  },
  "CVE-2021-41864_before_exclude_100:54bb4956:vulspec": {
    "timestamp": "2026-01-17T01:44:58.199123",
    "cve_id": "CVE-2021-41864",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "54bb4956",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves a buffer overflow due to insufficient validation of iovec lengths in the FUSE subsystem. The target code performs memory allocation and initialization for a BPF stack map. Both involve kernel memory management, but the vulnerability type (CWE-119), trigger conditions (malicious userspace input vs. internal resource allocation), and code patterns (complex protocol handling vs. simple alloc-init-free pattern) are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a race condition (CWE-362) in F2FS's node ID management due to non-atomic check-and-use operations. The target code is a straightforward, synchronous initialization function for a BPF data structure with no concurrency or shared state manipulation. The vulnerability types and code patterns are fundamentally dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read (CWE-125) in Perl's regex engine due to improper NUL byte handling. The target code is a kernel memory allocation and freelist initialization routine. The domains (user-space language interpreter vs. kernel subsystem), vulnerability types, and code patterns have no meaningful overlap.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a NULL pointer dereference (CWE-476) in the USB/IP subsystem due to insufficient validation of URB fields from network input. The target code allocates memory and initializes a freelist; it checks for allocation failure (returns -ENOMEM) and has a cleanup path. The vulnerability type (missing validation of external input vs. internal resource handling) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a NULL pointer dereference (CWE-476/CWE-703) in a USB serial driver due to missing validation of USB endpoint descriptors from a physical device. The target code's potential failure is an allocation failure, which it handles. The attack surface (physical USB vs. internal kernel API) and flaw nature are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves an out-of-bounds write (CWE-787) due to an integer overflow (CWE-190) in a size calculation in a network protocol library. The target code has a multiplication `elem_size * smap->map.max_entries` which could theoretically overflow if not validated elsewhere. This provides a slight conceptual similarity in the risk of unchecked multiplication before allocation, but the context (user-space library vs. kernel, specific vulnerability chain) is different. The target code likely relies on prior validation of `max_entries`.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a double free (CWE-415) in a userspace library due to error handling issues. The target code has a single allocation with a single free in the error path (`free_elems`). It manages ownership cleanly and does not exhibit the double-free or ownership ambiguity pattern.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a buffer boundary issue (CWE-119) related to scatterlist pointing to stack memory under VMAP_STACK. The target code uses `bpf_map_area_alloc` for kernel memory. Both are in the kernel and involve memory allocation, but the specific vulnerability (incorrect memory type assumptions for crypto operations) is not present in the simple allocation and population done in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is an unbounded/overflowing memory allocation (CWE-119/770) in the USB/IP subsystem due to missing validation of network-provided `transfer_buffer_length` and `number_of_packets`. The target code performs `elem_size * smap->map.max_entries`. If `max_entries` is controlled by an unprivileged user (via BPF map creation syscall) and not properly validated upstream, a similar integer overflow leading to undersized allocation could occur. The pattern of \"multiplication of two sizes before allocation\" is similar, though the attack vector (network vs. syscall) and subsystem differ. This provides a valuable reference for validating inputs to such calculations.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a buffer overflow (CWE-119) in a network daemon due to a negative length value. The target code uses unsigned sizes (`u32 elem_size`, `max_entries`). The similarity is limited to both involving size calculations for memory operations, but the specific flaw (signedness error leading to negative size) is not applicable to the target's unsigned types.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      }
    ]
  },
  "CVE-2022-27650_before_exclude_100:603fdf83:vulspec": {
    "timestamp": "2026-01-17T01:45:39.670310",
    "cve_id": "CVE-2022-27650",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "603fdf83",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is a container exec function handling command-line arguments and environment setup for a container runtime. CVE-2018-18313 is a regex parsing vulnerability involving out-of-bounds reads from embedded NUL bytes. The domains (container runtime vs. regex engine), vulnerability types (memory corruption vs. argument/env processing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve privilege/security context management. CVE-2011-3603 is about improper privilege separation leading to unnecessary root execution. The target code sets security attributes (capabilities, SELinux/AppArmor labels, no_new_privileges) for a container process. The core similarity is managing process privileges, but the specific flaw (failure to drop privileges) and context (daemon init vs. container exec) differ.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2018-20750 is an integer overflow leading to out-of-bounds write in a network file transfer protocol. The target code parses command-line arguments and environment variables to configure a container process. Both handle external input, but the input sources (network data vs. CLI/env), vulnerability mechanisms (integer overflow/write vs. potential logic/validation errors), and domains are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2013-2124 is a double free during error handling in a file reading function. The target code has dynamic memory allocation (`xmalloc0`) and complex structure setup which could have error paths. The similarity is in potential for resource management errors during failure conditions. However, the specific double-free pattern and context (file reading vs. configuration building) are not directly analogous.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2011-1003 is a double free during error handling in a file parser. Similar to case 4, the target code allocates memory (`process`, `capabilities`) and could have error paths where cleanup might be inconsistent. The general theme of memory management during error handling is shared, but the specific vulnerability pattern and domain (antivirus parsing vs. container config) are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3179 is a use-after-free due to uninitialized state and error handling. The target code initializes structures (`memset`, `xmalloc0`) and has a cleanup attribute (`cleanup_process_schema`). The relevance lies in the importance of proper initialization and cleanup of complex data structures. However, the specific use-after-free flaw and context (network daemon vs. container exec) are not closely matched.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read in an image file parser due to improper string termination validation. The target code reads strings from `argv` and `getenv` but uses safe duplication (`xstrdup`). Both process external input, but the vulnerability type (buffer over-read), trigger (malformed file data), and domain (graphics vs. container runtime) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2018-20760 is an out-of-bounds write due to improper error handling in a text encoding converter. The target code handles string input from the environment (`getenv`) and arguments. The weak link is processing external string data. However, the specific flaw (missing error code check leading to buffer overflow) and the data type (text encoding vs. simple strings) are not similar to the target's logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2011-3601 is a buffer overflow in a network protocol parser due to missing bounds check on a negative length. The target code parses arguments and environment variables, but uses functions like `xstrdup` and calculates array sizes based on `argc`. The similarity is in parsing untrusted input. However, the input source (network packet vs. CLI), vulnerability (negative integer overflow), and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2010-1311 is an improper input validation in a decompression algorithm leading to memory corruption. The target code validates input indirectly via `argp_parse` and `crun_assert_n_args`. Both involve validating and processing external input. However, the vulnerability mechanism (bypassing bounds checks in a compression window) and the domain (file format parsing vs. command execution) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-27650_after_exclude_100:36eea24d:vulspec": {
    "timestamp": "2026-01-17T01:46:16.116957",
    "cve_id": "CVE-2022-27650",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "36eea24d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a container exec function handling process configuration and environment setup. The domains (regex parsing vs. container runtime), vulnerability types (CWE-125 vs. potential privilege/validation issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves CWE-20 (Improper Input Validation) leading to CWE-250 (Execution with Unnecessary Privileges) when privilege separation fails. The target code manages container execution with user, capabilities, and security context (SELinux, AppArmor). Both deal with privilege management and security context setup. However, the specific flaw (continuing as root after separation failure) is not directly mirrored in the provided code snippet, though the theme of privilege/security misconfiguration is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an integer overflow (CWE-190) leading to an out-of-bounds write (CWE-787) in a network file transfer protocol. The target code performs argument parsing and process structure setup for container execution. There is no evident integer arithmetic or buffer allocation based on untrusted sizes in the shown code. The domains and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a double-free (CWE-415) during error handling in a file reading function. The target code has dynamic memory allocation (`xmalloc0` for `process` and its members) and could potentially have error paths that lead to inconsistent cleanup. However, the provided snippet does not show the error handling or free logic for the allocated `process` structure, making direct comparison speculative. The domain (VM disk inspection vs. container exec) is also different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a double-free (CWE-415) during error handling in a document parser. Similar to Case 4, the relevance is based on the potential for memory management errors in the target code's allocation paths (`xmalloc0`, `xstrdup`). However, the specific trigger (parsing malicious document strings) and context are not present. The connection is generic to memory management pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a use-after-free (CWE-416) due to uninitialized pointers and error handling. The target code initializes its structures with `memset` and `xmalloc0` (which zeroes memory), reducing the risk of uninitialized pointers. The potential link is in the broader category of improper resource cleanup, but the specific flaw pattern is not strongly evidenced.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read (CWE-125) in an image file parser due to improper string termination validation. The target code deals with string arguments from command line and environment variables (`getenv`, `argv`), but does not show complex parsing of binary data or string fields where similar bounds checking issues would arise. The domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds write (CWE-787) due to missing validation of error codes in a text encoding conversion function. The target code performs string duplication and array copying with fixed sizes derived from `argc`. While improper validation of `argc` or environment variables could be a concern, the specific mechanism (encoding conversion errors) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow (CWE-119) in a network protocol parser due to negative length values. The target code copies `argv` strings with lengths determined by loop bounds (`argc - first_arg`). A negative value here is improbable. The domain (network packet parsing vs. local argument processing) and the specific flaw (signedness error leading to negative index) are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2021-36692_before_exclude_100:31483f89:vulspec": {
    "timestamp": "2026-01-17T01:46:28.975684",
    "cve_id": "CVE-2021-36692",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "31483f89",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image format parsing (PNG vs. BMP) and memory allocation, but the specific flaw (unchecked header values leading to allocation failure in OpenJPEG) differs from the target code's pattern of bounds checking (e.g., cMaxPNGSize checks) and pointer management. The vulnerability type (CWE-119) is similar but the trigger conditions and code patterns are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image processing and potential buffer overflows (CWE-119). However, the target code performs explicit size checks (w0 > cMaxPNGSize, etc.) and manages its own row buffers, while the historical case is about insufficient padding calculation during compression. The code patterns and trigger conditions (malformed PNG vs. crafted JPEG 2000) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are image decoders (PNG vs. GIF) handling animated formats. The target code has extensive validation (dop > 2, bop > 1, dimension checks) which mitigates the type of insufficient input validation (CWE-787) seen in the libsixel case. However, the domain (image decoding) and the need to parse complex, chunk-based formats with potential for out-of-bounds writes is similar, providing some reference value.",
        "case_metadata": {
          "cve_id": "CVE-2020-21050"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Stronger relevance due to shared domain (image library) and critical focus on error handling and memory management. The target code has multiple `delete[]` operations and early breaks on error conditions, which is a pattern where double-free (CWE-415) or use-after-free could occur if control flow is not meticulously managed. The historical case is a direct lesson in error path memory ownership.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both handle animated image formats (APNG vs. GIF), but the core flaw is different. The target code uses unsigned integers and checks for overflows (x0 + w0 > w), while the historical case involves a signedness confusion (CWE-681) leading to an infinite loop. The relevance is primarily in the domain of animated image parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The relevance comes from the shared context of image format parsing and parameter validation. The target code validates parameters like `dop` and `bop` against expected ranges, similar to the validation gap for `numresolution` in the OpenJPEG case. The use-after-free (CWE-416) aspect is less directly relevant, but the pattern of validating chunk data is comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are image decoders, but the vulnerability patterns differ. The target code's primary buffer operations are on pre-allocated `frameRaw.p` based on calculated `imagesize`, with bounds checks on coordinates. The RLE decoder vulnerability (CWE-119) stemmed from incorrect offset calculation during decoding, a pattern not evident in the linear row-by-row processing shown here.",
        "case_metadata": {
          "cve_id": "CVE-2016-10050"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The domains are completely different (image decoding vs. regular expression compilation). The vulnerability type (CWE-125 - Out-of-bounds Read) is not a primary concern in the target code, which focuses more on writes to allocated buffers and input validation. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Minimal relevance. The only tenuous connection is the handling of formatted/encoded data (PNG chunks vs. IRC color codes). The target code does not perform dynamic string concatenation or use `strcat`; it uses memory buffers with explicit sizes. The heap buffer overflow (CWE-122) pattern from unsafe string handling is not present.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Essentially no relevance. The target code is a PNG/APNG decoder with no cryptographic functionality. The vulnerability (CWE-200/385 - Side-channel attack) is specific to cryptographic implementations and constant-time algorithms, which are completely unrelated to the image processing logic in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      }
    ]
  },
  "CVE-2021-36692_after_exclude_100:16fe56d7:vulspec": {
    "timestamp": "2026-01-17T01:46:41.185236",
    "cve_id": "CVE-2021-36692",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "16fe56d7",
    "scores": [
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve image format parsing (PNG vs. BMP) and have bounds checking concerns (cMaxPNGSize checks). However, CVE-2017-12982 is primarily about memory allocation failure due to unchecked header values, while the target code performs size checks but has different potential vulnerability patterns (e.g., integer overflows in w*4, heap operations).",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both are in image processing libraries and involve buffer management. CVE-2017-14152 is a heap buffer overflow during encoding due to insufficient padding. The target code has raw buffer allocations (`new unsigned char[imagesize]`) and row pointers, which could be susceptible to similar allocation/logic errors if size calculations are wrong, but the context (decoding vs. encoding) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are decoders for animated image formats (APNG vs. GIF) and process frame data. CVE-2020-21050 is an out-of-bounds write due to insufficient LZW code size validation. The target code validates parameters (w0, h0, x0, y0 bounds) but has complex buffer operations (`frameRaw.rows`) that could have similar boundary issues if validations are insufficient or bypassed.",
        "case_metadata": {
          "cve_id": "CVE-2020-21050"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image library error handling. CVE-2018-1000222 is a double-free during BMP compression error handling. The target code has multiple `delete[]` operations in various error paths (e.g., after `break` in loops) and uses raw pointers, which could lead to similar memory management issues if error paths are not consistent, but the primary flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both handle animated image formats (APNG vs. GIF) and have frame processing logic. CVE-2018-5711 involves integer signedness confusion leading to an infinite loop. The target code uses unsigned integers and has loop conditions (`!r.Eof()`), but could have similar logic errors in frame count or delay calculations (e.g., `delay_den=0` check exists).",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in image codecs. CVE-2017-14152 is a use-after-free in JPEG2000 parameter handling. The target code uses raw pointers and `delete[]` operations, which could theoretically lead to use-after-free if there are state management errors, but the specific pattern (parameter validation leading to freed resource access) is not clearly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both are image decoders with buffer operations. CVE-2016-10050 is a heap buffer overflow in an RLE decoder due to insufficient bounds checking when calculating pixel offsets. The target code calculates `rowbytes = w * 4` and `imagesize = h * rowbytes` for allocation, then accesses `frameRaw.rows[y]` and `f[4 * x + 3]`. Integer overflows in these calculations or out-of-bounds writes during PNG data processing could be analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-10050"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read in a regex compiler due to NUL byte handling. The target code is an image decoder that reads binary chunks; while it does parse data from `chunk.p`, the patterns and vulnerability types are fundamentally different (string processing vs. binary format parsing).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve buffer growth/management. CVE-2012-5854 is a heap buffer overflow due to an unsafe buffer growth strategy in string concatenation. The target code uses fixed-size allocations based on image dimensions, not dynamic string growth. However, if dimension calculations are incorrect, it could lead to buffer overflows when writing pixel data.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library. The target code is a non-cryptographic image decoder with no constant-time requirements. The domains and vulnerability classes are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      }
    ]
  },
  "CVE-2022-0413_before_exclude_100:3b688cbd:vulspec": {
    "timestamp": "2026-01-17T01:46:49.751976",
    "cve_id": "CVE-2022-0413",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3b688cbd",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-10506 is a divide-by-zero vulnerability in an image codec (OpenJPEG) due to insufficient validation of resolution parameters. The target code is a text substitution function in Vim, dealing with regex matching, string manipulation, and buffer updates. The vulnerability types, domains, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-10506"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14353 involves an integer underflow in string quoting for an IMAP client (NeoMutt). The target code also performs complex string processing (regex substitution, line joining, buffer building). While both involve string manipulation and potential for miscalculation, the specific flaw (integer underflow during backslash escaping) and context (network protocol vs. editor command) are distinct. The target code shows careful length calculations (e.g., `needed_len`), reducing direct similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20217 is a reachable assertion in a Kerberos KDC due to incorrect state assumptions. The target Vim code has no assertions and operates in a completely different domain (text editing vs. network authentication). The code patterns and failure modes are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20217"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3120 is a NULL pointer dereference in Kerberos KDC request validation. The target code performs extensive pointer checks (e.g., checking `old_sub == NULL`) and error handling via `emsg()`. While both involve pointer usage, the context (authentication protocol state machine vs. interactive text substitution) and the nature of the flaw are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3120"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-4073 is an integer overflow in a PHP multibyte string function leading to buffer overflow. The target code performs significant string buffer management in `ex_substitute`, allocating memory with `alloc()` and calculating lengths (`needed_len`, `new_start_len`). There is a conceptual similarity in the risk of miscalculating buffer sizes during complex string transformations. However, the target code appears to use `unsigned` types for lengths and adds padding, showing some defensive design. The specific integer overflow pattern is not immediately evident.",
        "case_metadata": {
          "cve_id": "CVE-2016-4073"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2015-0241 is a buffer over-read/overflow in PostgreSQL's numeric formatting due to insufficient bounds checking. The target Vim code builds a new string buffer (`new_start`) by copying from an old line (`sub_firstline`) and a substitution result, with careful length tracking. The core similarity is in performing buffer operations based on calculated indices and lengths derived from parsed input (regex match positions). Both must guard against miscalculations that could lead to out-of-bounds memory access. The target code's use of `STRCAT` and pointer arithmetic requires vigilance similar to the PostgreSQL flaw.",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-19221 is an out-of-bounds read in libarchive during multibyte-to-wide string conversion due to incorrect length calculation. The target Vim code handles multibyte characters (`has_mbyte`, `mb_ptr2len`) within its string processing loop. When building the substitution result, it iterates through characters and handles backslashes and carriage returns, which requires correct pointer advancement. An error in multibyte character length calculation or buffer pointer adjustment could lead to similar out-of-bounds reads. The context is different (archive processing vs. editor substitution), but the underlying risk pattern of incorrect bounds during string iteration is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-19221"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-14361 is an improper input validation/handling of allocation failure in NeoMutt's NNTP client. The target code checks for allocation failures (e.g., `if ((new_start = alloc(new_start_len)) == NULL) goto outofmem;`). Both involve resource management, but the target code's primary vulnerability surface is not allocation failure handling but the complex logic of regex matching and buffer building. The similarity is generic (checking for NULL after alloc) rather than specific to the flaw.",
        "case_metadata": {
          "cve_id": "CVE-2018-14361"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2011-2161 is a resource management error in an audio demuxer (FFmpeg) due to parsing a file with zero frames. The target code parses a user's `:s` command and regex patterns, not a file format. While both involve parsing external input, the structure and risks are different. The target code's validation focuses on regex syntax and command flags, not media file structure completeness.",
        "case_metadata": {
          "cve_id": "CVE-2011-2161"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-6800 is an integer overflow/type confusion leading to a buffer over-read in a TNEF decoder. The target code involves type handling (e.g., `colnr_T` for columns) and performs arithmetic on positions (e.g., `matchcol`, `copycol`, `needed_len`). While not a direct type confusion flaw, the target code's safety depends on correct calculations between different representations of string indices and buffer lengths. An error analogous to assuming a size without verification could occur if, for example, the regex match positions were corrupted or miscalculated. The relevance is in the general risk of arithmetic errors during buffer construction.",
        "case_metadata": {
          "cve_id": "CVE-2017-6800"
        }
      }
    ]
  },
  "CVE-2022-0413_after_exclude_100:0a71d1ed:vulspec": {
    "timestamp": "2026-01-17T01:48:14.644062",
    "cve_id": "CVE-2022-0413",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0a71d1ed",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-10506 is a divide-by-zero vulnerability in an image codec (OpenJPEG) due to unvalidated resolution parameters. The target code is a text substitution function in an editor (Vim), dealing with regex matching and string manipulation. The vulnerability types, domains, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-10506"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-14353 is an integer underflow in an IMAP string quoting function in NeoMutt, leading to buffer overflow. The target code performs complex regex substitution with careful length calculations and memory management. While both involve string processing, the specific flaw (integer underflow during backslash escaping) and context (network protocol vs. editor command) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14353"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20217 is a reachable assertion in a Kerberos KDC due to incorrect state handling during S4U2Self request processing. The target code has no assertions and operates in a completely different domain (text editing vs. network authentication). The flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-20217"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3120 is a NULL pointer dereference in Kerberos KDC during policy validation for S4U2Self requests. The target code is a user-facing substitution command with extensive input parsing and buffer handling. The context (security protocol server vs. interactive editor) and flaw nature (policy state inconsistency) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3120"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-4073 is an integer overflow in PHP's mbstring extension during buffer size calculation for string conversion. The target code also performs string manipulation and buffer allocation (e.g., `new_start_len` calculation). There is a superficial similarity in the domain of string processing and potential for integer issues in size calculations. However, the specific trigger (crafted size parameters in an API) and the broader context (library function vs. interactive editor command) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-4073"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2015-0241 is a buffer over-read/overflow in PostgreSQL's numeric-to-string formatting due to insufficient bounds checking. The target code builds a new string (`new_start`) by concatenating parts of an old string and substitution results, managing an allocated buffer (`new_start_len`). Both involve constructing strings in buffers with calculated lengths. The relevance is higher than other cases because both deal with core string formatting/building logic and the risk of miscalculating buffer needs. However, the target code appears to have more robust growth checks (`needed_len` vs. `new_start_len`).",
        "case_metadata": {
          "cve_id": "CVE-2015-0241"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-19221 is an out-of-bounds read in libarchive due to incorrect buffer length passed during multibyte-to-wide character conversion. The target code handles multibyte characters (`has_mbyte`) and performs string copying. There is a tangential similarity in handling character encoding and buffer boundaries. However, the core flaw (wrong length parameter) and the specific operation (encoding conversion) are not present in the target code's primary substitution loop.",
        "case_metadata": {
          "cve_id": "CVE-2019-19221"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-14361 is an improper input validation/handling of allocation failure in NeoMutt's NNTP client. The target code checks for allocation failures (e.g., `if ((new_start = alloc(new_start_len)) == NULL) goto outofmem;`). There is a minimal similarity in the need to handle memory allocation errors. However, the vulnerability is about missing checks leading to NULL dereference, while the target code shows explicit checks. The contexts (network client vs. editor core command) are also very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14361"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2011-2161 is a resource management error in an FFmpeg audio demuxer due to parsing a file with zero frames. The target code processes text buffers in memory, not file streams with frame counts. The vulnerability patterns (header validation vs. data absence) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2011-2161"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-6800 is an integer overflow/type confusion leading to a buffer over-read in a TNEF/MAPI property decoder. The target code performs type-safe operations on its own buffers. While both involve parsing structured data (regex match results vs. MAPI properties), the flaw mechanism (incorrect type casting and size assumption) is not evident in the target code, which uses explicit structures like `regmatch_T`.",
        "case_metadata": {
          "cve_id": "CVE-2017-6800"
        }
      }
    ]
  },
  "CVE-2022-0572_before_exclude_100:365c8d6f:vulspec": {
    "timestamp": "2026-01-17T01:48:26.003772",
    "cve_id": "CVE-2022-0572",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "365c8d6f",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves out-of-bounds read in a regex engine due to improper NUL byte handling. The target code is a tab expansion/retabulation function in an editor, dealing with whitespace conversion and memory allocation. The vulnerability type (CWE-125), domain (parsing vs. text editing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon's service registration. The target code performs line-by-line text manipulation with careful undo saving and memory allocation. The contexts (network protocol state management vs. editor buffer operations) and flaw patterns (double-free/use-after-free vs. potential buffer overflows) share almost no similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to multi-byte character handling. The target code also processes multi-byte characters (via `mb_ptr2len`) and calculates column positions, which introduces similar risks of miscalculated lengths and buffer accesses. However, the domain (XML parsing vs. text retabbing) and specific vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1838 is another libxml2 out-of-bounds read during end tag parsing. While both involve parsing/processing structured input (XML tags vs. whitespace sequences), the target code's operations are arithmetic (tab/space calculations) and memory buffer management, not hierarchical tag parsing. The flaw mechanisms are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-15166 involves improper input validation (CWE-20) in a network protocol parser leading to missing bounds checks. The target code contains input validation (checking `new_ts` range, `alloc` result) and length calculations (`old_len`, `len`) that could be miscomputed, similar to protocol parsing flaws. The domain difference is large, but the underlying coding hazard (failing to validate derived lengths) is comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-14461 is an out-of-bounds read due to insufficient TLV length validation. The target code calculates `len`, `old_len`, and performs memory operations (`mch_memmove`) based on these calculated values. If `start_col`, `col`, or `len` are miscalculated (e.g., via `chartabsize` or multi-byte handling), similar buffer over-read/write could occur. The context differs but the pattern of using calculated lengths for memory operations is shared.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-20750 involves integer overflow/wraparound (CWE-190) leading to out-of-bounds write. The target code has several integer calculations: `old_len - col + start_col + len + 1` in `alloc`, `vcol - start_vcol`, and divisions/modulos for tab/space counts. If these integers are attacker-influenced (via line content), overflows could cause undersized allocation and subsequent buffer overflow. The pattern of integer math leading to allocation size errors is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2009-5155 is a state handling error in a regex compiler. The target code maintains some state (`got_tab`, `num_spaces`, `did_undo`) but in a simple, linear fashion. The complexity and vulnerability type (data processing errors in parsing alternatives) are not comparable to the target's straightforward text transformation logic.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1835 is a use-after-free in an XML attribute parser. The target code allocates `new_line` and may reassign it via `ml_replace`/`curbuf->b_ml.ml_line_ptr`. There is potential for confusion between allocated and managed buffer pointers, but the code carefully avoids double-frees. The use-after-free pattern is not strongly present.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-16161 is a NULL pointer dereference due to inconsistent error state in a regex library. The target code checks for `alloc` failure and `got_int` but doesn't have complex error state propagation. The flaw pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      }
    ]
  },
  "CVE-2022-0572_after_exclude_100:3a9d7420:vulspec": {
    "timestamp": "2026-01-17T01:49:16.630399",
    "cve_id": "CVE-2022-0572",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3a9d7420",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is a text retabbing function in an editor, dealing with whitespace conversion and memory allocation. The vulnerability type, domain (regex parsing vs. text editing), and attack patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-3179 is a use-after-free in a network daemon. The target code performs careful memory allocation and replacement (`alloc`, `ml_replace`) and manages undo states. While both involve memory management, the context (network service error handling vs. editor buffer manipulation) and the specific flaw pattern (uninitialized pointers in network structures vs. line buffer allocation) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to improper multi-byte character handling. The target code processes single-byte whitespace characters (' ', '\\t') and uses `chartabsize`/`mb_ptr2len` for column calculation, but its core logic is about reformatting, not parsing complex structured data. The vulnerability pattern (encoding-specific buffer over-read) does not align.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-1838 is another libxml2 out-of-bounds read during end tag parsing. The target code does not parse hierarchical tags or markup. Its operations are linear scans over buffer lines. The similarity is negligible.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-15166 involves improper input validation in a network protocol parser leading to potential memory issues. The target code validates its numeric arguments (`getdigits`, range checks for `new_ts`) and checks for memory allocation failure. Both stress the importance of input validation, but the domains (network packet dissection vs. editor command argument processing) and data sources are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read in a protocol parser due to insufficient TLV length validation. The target code calculates lengths (`len`, `old_len`, `vcol - start_vcol`) and performs bounds checks (e.g., `vcol >= MAXCOL`). The principle of validating calculated lengths before memory operations is similar, but the application context and data structures are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate-Weak relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in memory allocation. The target code has an integer-heavy calculation for buffer sizes (`old_len - col + start_col + len + 1`). If `old_len`, `col`, `start_col`, and `len` are manipulated incorrectly, an integer wrap could occur, leading to a similar undersized allocation and subsequent buffer overflow in the `mch_memmove` operations. This is the most relevant case so far, as it shares the vulnerability type (integer issues leading to memory corruption) and a similar code pattern (calculating allocation size from multiple variables). However, the trigger conditions (network packet vs. editor buffer line) differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2009-5155 involves state handling errors in a regex compiler. The target code maintains state (`got_tab`, `num_spaces`, `start_col`) during a line scan, but this is simple loop state, not the complex parsing state machine vulnerable in the regex engine. The flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2009-5155"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1835 is a use-after-free in an XML attribute parser. The target code allocates `new_line` and potentially replaces the line buffer via `ml_replace`, which may manage memory internally. There is a risk of mishandling the old vs. new buffer pointers, but the code is careful (`new_line = curbuf->b_ml.ml_line_ptr` after replace). The memory management context is simpler and more controlled than the XML parser's complex entity handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2019-16161 is a NULL pointer dereference due to inconsistent error state in a regex library. The target code checks for `new_line == NULL` after allocation and breaks. It does not have a pattern of returning error codes without setting state. The flaw mechanism is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      }
    ]
  },
  "CVE-2022-23589_after_exclude_100:e19e1ddd:vulspec": {
    "timestamp": "2026-01-17T01:50:02.162390",
    "cve_id": "CVE-2022-23589",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e19e1ddd",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression parser due to improper NUL byte handling. The target code is a graph node identity check function in a compiler/optimizer context, with no string parsing, buffer operations, or similar vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code performs graph node inspection and pointer checks, with no network data parsing, length validation, or buffer access patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-13035"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a stack-based buffer overflow in a configuration parser. The target code contains no array or buffer operations, no input parsing, and no memory allocation. It works with graph node structures and pointer validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is an improper access control vulnerability in a database query planner. The target code has a superficial similarity in performing checks within a larger system (graph optimizer vs query planner), but the vulnerability type (privilege escalation) and code patterns (access control checks) are fundamentally different from the target's structural validation logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is a side-channel vulnerability in cryptographic operations. The target code performs deterministic graph node checks with no cryptographic operations, secret data handling, or timing-sensitive branches that could leak information.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 involves resource management errors due to inconsistent state tracking in a text renderer. The target code shows some conceptual similarity in checking node relationships and states within a graph structure, but the specific vulnerability pattern (memory tracking inconsistency) and domain (multimedia rendering vs graph optimization) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow in a YANG parser due to missing length validation in string operations. The target code contains no string manipulation, buffer copying, or length calculations that could lead to similar vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in a network protocol parser. The target code performs graph node inspection with bounds checking via null pointer validation, but lacks the packet parsing, boundary validation, and sequential data processing patterns of the vulnerability case.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is a NULL pointer dereference due to invalid stack state management in a PDF interpreter. The target code has direct relevance as it also performs null pointer checks (`input_node == nullptr`) and validates graph node relationships. Both involve validating object states before dereferencing, though the specific trigger conditions (unbalanced stack operations vs graph node identity checks) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in a protocol parser due to insufficient length validation. The target code validates node existence but doesn't parse variable-length data structures or perform bounds checking on data buffers, making the vulnerability patterns dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-23589_before_exclude_100:c9737e0c:vulspec": {
    "timestamp": "2026-01-17T01:50:03.676080",
    "cve_id": "CVE-2022-23589",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c9737e0c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs graph node identity and switch checks with pointer dereferencing, but lacks the complex pattern parsing, Unicode handling, and buffer management that led to the out-of-bounds read in Perl's regex engine. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a graph analysis utility in a likely ML framework, performing conditional checks and pointer operations. It does not involve parsing network packets, protocol dissection, or length validation of untrusted data streams, which are central to the tcpdump out-of-bounds read vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2017-13035"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code contains no string parsing, hexadecimal conversion, or array/buffer operations. The BlueZ vulnerability stemmed from a stack buffer overflow in a parsing function, a context and flaw type absent from the provided graph traversal code.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The only weak similarity is that both codes involve checking properties of an object (graph node vs. database variable). However, the target code performs a structural check (IsSwitch), not a security-critical privilege check. The vulnerability type (Improper Access Control) and domain (database query planning) are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. No relevance. The target code is a simple predicate function with no cryptographic operations, secret data, or side channels. The libgcrypt vulnerability relates to constant-time execution in elliptic curve math, which shares no commonality with the graph inspection logic.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs logical checks and returns a boolean. It does not involve dynamic memory allocation, resource tracking, or processing of complex file formats (like subtitles) that could lead to the resource management errors seen in libass.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not perform any string copying, concatenation, or buffer manipulation. The libyang buffer overflow vulnerability arose from unsafe `strcpy`/`sprintf` usage without length checks, a pattern not present in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2019-19333"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Similar to case 2, this tcpdump vulnerability involves network packet parsing and bounds checking. The target code operates on an internal graph data structure, not sequential packet data. The risk of out-of-bounds read here would depend on the safety of `graph.GetNode()`, which is not the focus of the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. This is the most relevant case. The target code dereferences a pointer (`input_node`) returned by `graph.GetNode(tensor_id.node())`. If `GetNode` can return NULL (e.g., if the node doesn't exist) and this is not checked before `IsSwitch(*input_node)`, it could lead to a NULL pointer dereference (CWE-476), similar to the Ghostscript flaw. However, the vulnerability pattern is not identical, as the Ghostscript flaw involved a corrupted state stack, not a missing null check after a lookup.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse TLVs or any length-prefixed data from an untrusted source. The out-of-bounds read vulnerability in tcpdump's LDP parser is related to insufficient validation of a length field, a scenario not applicable to the internal graph node inspection logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-34494_before_exclude_100:9bd73982:vulspec": {
    "timestamp": "2026-01-17T01:50:06.649407",
    "cve_id": "CVE-2022-34494",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9bd73982",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves a buffer overflow in FUSE ioctl handling due to insufficient validation of iovec lengths. The target code is a device registration function in the rpmsg/virtio subsystem, focusing on memory allocation and device registration without any buffer manipulation or length validation logic. The vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code performs a simple kzalloc allocation with a fixed size (sizeof(*vch)) and has no arithmetic operations, network data parsing, or dynamic size calculations that could lead to integer issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a NULL pointer dereference in USB/IP due to insufficient validation of URB fields. The target code has a potential error path where `rpmsg_ctrldev_register_device` could fail, leading to kfree(vch) and returning an error pointer. However, the pattern is a controlled cleanup on failure, not a missing validation of external/network data that leads to a dereference. The context (device registration vs. network packet processing) is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a race condition leading to a NULL pointer dereference during keyring initialization. The target code is a straightforward device addition function likely called during probe/initialization. There is no indication of concurrent execution or shared resource access without synchronization. The patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an unbounded memory allocation/integer overflow in USB/IP network packet handling. The target code allocates a fixed-size structure (`sizeof(*vch)`) and does not process any variable-length or attacker-controlled data that influences allocation size. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a NULL pointer dereference due to missing validation of USB endpoint descriptors. The target code does validate the result of kzalloc (returns ERR_PTR on failure) and checks the return value of `rpmsg_ctrldev_register_device`. However, the flaw pattern is different: it's about handling allocation failure and API errors, not parsing and validating complex hardware descriptors.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a concurrency race leading to buffer overflow in the TTY subsystem. The target code shows no evidence of concurrent access, shared buffers, or complex state management. It is a simple initialization and registration routine.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an input validation flaw leading to NULL pointer dereference in the perf subsystem. The target code takes a `virtio_device` pointer as input but does not extensively validate its internal structure fields. The potential similarity is very generic (missing validation), but the context (performance events vs. virtio device registration) and specific flaw patterns are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2013-4254"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a NULL pointer dereference due to missing USB endpoint validation during driver probe. The target code is also a \"add device\" function. The slight similarity is that both handle device initialization and have error paths. However, the root cause in Case 9 is specific to USB descriptor parsing, which is absent in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a buffer access issue related to scatterlist on VMAP stack in SMB cryptography. The target code involves no cryptography, scatterlists, or stack buffer usage. It performs a heap allocation and function call.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2022-34494_after_exclude_100:5a30992a:vulspec": {
    "timestamp": "2026-01-17T01:50:09.748142",
    "cve_id": "CVE-2022-34494",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5a30992a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a buffer overflow in FUSE ioctl handling due to improper validation of iovec lengths. The target code is a device registration function in the rpmsg/virtio subsystem, performing memory allocation and device registration with no buffer manipulation or length validation logic.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves an integer overflow leading to out-of-bounds write in a network protocol (VNC) file transfer handler. The target code performs a simple kzalloc allocation and device registration with no arithmetic on user-controlled data, network parsing, or file transfer logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is a NULL pointer dereference in the USB/IP subsystem due to insufficient validation of URB fields. The target code has a potential error path (if rpmsg_ctrldev_register_device fails) that returns an error pointer, but the function carefully handles the cleanup via the release callback. The patterns are different: one is network packet validation, the other is internal driver registration.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 4 is a race condition leading to a NULL pointer dereference in the keyring subsystem during concurrent initialization. The target code is a single-threaded device addition function called during probe/initialization. There is no evident shared resource or concurrency pattern in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves unbounded memory allocation and integer overflow in USB/IP due to missing validation of network-provided length fields. The target code allocates a fixed-size structure (sizeof(*vch)) and does not process any external, untrusted size inputs.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 6 is a NULL pointer dereference in a USB serial driver due to missing validation of USB endpoint descriptors. The target code does not parse USB descriptors. Both involve device initialization, but the flaw pattern (missing check leading to NULL deref) is not present in the target code, which checks allocation failure and propagates errors.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a race condition leading to buffer overflow in the TTY subsystem. The target code has no buffers, no concurrent writers, and no line discipline logic. The domains and flaw patterns are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is improper input validation leading to NULL pointer dereference in the ARM perf subsystem. The target code validates only memory allocation failure and a function return code. It does not validate complex user-provided event configurations or access function pointers based on such input.",
        "case_metadata": {
          "cve_id": "CVE-2013-4254"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is a NULL pointer dereference in a USB serial driver probe due to missing endpoint validation. Similar to Case 6, the target code is also a device addition function, but it operates at a higher abstraction layer (virtio/rpmsg) and does not interact with low-level USB descriptors or endpoints. The error handling pattern is more robust.",
        "case_metadata": {
          "cve_id": "CVE-2016-3136"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a buffer misuse issue in the CIFS crypto code related to scatterlist and VMAP_STACK. The target code performs a single straightforward kernel allocation and has no cryptographic operations, scatterlists, or stack buffer usage.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2021-28950_before_exclude_100:b20b2f37:vulspec": {
    "timestamp": "2026-01-17T01:51:06.648352",
    "cve_id": "CVE-2021-28950",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b20b2f37",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve the Linux kernel FUSE subsystem, indicating a shared domain and potential for similar coding patterns and state management issues. However, the vulnerability types differ significantly: CVE-2010-4650 is a buffer overflow in ioctl handling, while the target code is a simple state-setting function. The relevance comes from the shared context (FUSE inode state management), but the flaw mechanics are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is in the Linux kernel FUSE subsystem (C), while CVE-2018-18313 is in the Perl regex engine. The domains (filesystem vs. language interpreter), functionality, and vulnerability type (out-of-bounds read) are completely unrelated to the simple bit-setting operation in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are in the Linux kernel filesystem layer, so they share a broad domain. The vulnerability type (race condition) is not applicable to the inline, atomic-looking bit-setting function `fuse_make_bad`. However, the concept of managing inode state flags (like `FUSE_I_BAD`) could theoretically be involved in race conditions elsewhere, but the provided code snippet itself shows no such flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is a kernel inline function for setting a state bit. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a userspace VNC library's file transfer protocol. The systems, domains, functionalities, and vulnerability types are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is a kernel filesystem state operation. CVE-2011-3601 is a buffer overflow in a userspace network daemon (radvd) processing IPv6 packets. There is no meaningful overlap in context, functionality, or vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The primary vulnerability type (Use After Free) is not present in the simple, self-contained target code. A very weak connection exists in the broad concept of \"state management\"  `fuse_make_bad` sets a state flag, and use-after-free often involves incorrect state tracking of freed objects. However, the domains (kernel vs. daemon) and specific flaw mechanisms are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code performs a trivial bit operation. CVE-2019-1010065 is an integer overflow in a filesystem forensic analysis tool when parsing malicious on-disk structures. There is no functional or vulnerability pattern similarity.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Both are in the Linux kernel, which is the only point of contact. The target code is in the FUSE subsystem, while CVE-2016-10154 is in the CIFS/SMB subsystem. The functionality (state flag vs. cryptography) and vulnerability type (buffer overflow/stack issue) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is a kernel function. CVE-2018-20760 is an out-of-bounds write in a multimedia framework's text import utility. No relevant similarities in domain, function, or flaw type.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The strongest point of relevance is that both are within the Linux kernel filesystem layer (ocfs2 vs. FUSE). The vulnerability chain for CVE-2017-18216 involves a race condition leading to a NULL pointer dereference, which is a concurrency flaw. While `fuse_make_bad` itself is a simple setter, it operates on inode state (`FUSE_I_BAD`). If this flag is not accessed atomically or checked correctly elsewhere in the FUSE codebase, it could potentially contribute to a race condition or TOCTOU issue, similar to the flawed state management in the ocfs2 case. The relevance is thematic (kernel filesystem state management) rather than direct.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      }
    ]
  },
  "CVE-2022-2553_before_exclude_100:4c396010:vulspec": {
    "timestamp": "2026-01-17T01:51:33.459544",
    "cve_id": "CVE-2022-2553",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4c396010",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression parser due to improper NUL byte handling. The target code is a configuration setup function with no regex parsing, character class processing, or similar complex input validation logic. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs file reading and configuration parsing but does not contain any complex integer arithmetic, dynamic memory allocation based on user-controlled sizes, or network protocol handling that could lead to similar overflow/write conditions.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 involves an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code reads configuration files and performs setup operations but does not parse complex, untrusted binary network packets with TLV structures. The attack surfaces and data validation contexts are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves improper memory buffer operations in a kernel cryptographic module, specifically related to scatterlists and VMAP stacks. The target code is user-space application code for daemon/client setup. It uses libgcrypt for cryptographic operations but in a high-level API manner (`gcry_control`), not low-level memory manipulation prone to the same physical/virtual memory mapping issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves a race condition in a kernel filesystem's resource management (node ID allocation). The target code is a setup function likely called during daemon/client initialization, not in a hot loop with concurrent access. While both manage resources (configuration, crypto context), the target code shows no evidence of concurrent execution paths or non-atomic check-and-use patterns that are central to the race condition flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves a NULL pointer dereference in a kernel networking module due to missing parameter validation. The target code also has potential for NULL pointer issues (e.g., `booth_conf->name` could be NULL if `read_config` failed, leading to a crash in `snprintf`). However, the context is different (user-space daemon vs. kernel). The pattern of missing validation for a structure pointer after a function call is a weak similarity.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 involves a use-after-free due to a race condition and improper locking in a kernel memory policy subsystem. The target code is a linear setup function with no dynamic resource allocation/free cycles, shared state between threads, or explicit locking mechanisms that could lead to a similar concurrency flaw.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 involves a race condition leading to a NULL pointer dereference during keyring initialization in the kernel. The target code initializes configuration and cryptographic contexts but shows no signs of being susceptible to a similar initialization race (e.g., concurrent calls to `setup_config` on shared global structures like `cl` or `local`). The resource initialization patterns are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves a missing authorization check in a kernel key management subsystem. The target code performs authentication key reading (`read_authkey`) but does not implement a complex permission model or access control decisions between different security contexts. The flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves a use-after-free due to uninitialized pointers and inconsistent state management during error handling in a network daemon. The target code uses `goto out` for error handling, which is a similar pattern for cleanup. However, there is no visible dynamic memory allocation or complex resource cleanup in the shown code path that could lead to a similar double-free or use-after-free scenario. The weak similarity is in the error handling control flow.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      }
    ]
  },
  "CVE-2021-28950_after_exclude_100:dc708239:vulspec": {
    "timestamp": "2026-01-17T01:51:35.013268",
    "cve_id": "CVE-2021-28950",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "dc708239",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve the Linux kernel FUSE subsystem, indicating a shared domain. However, the vulnerability types are fundamentally different: CVE-2010-4650 is a buffer overflow (CWE-119) in ioctl handling due to insufficient validation of user-supplied data lengths. The target code (`fuse_make_bad`) is a simple inode state management function that performs no complex validation, memory operations, or user input processing. The only connection is the FUSE context.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The target code is in the Linux kernel FUSE filesystem. CVE-2018-18313 is in the Perl regular expression engine (user-space). The vulnerability type (CWE-125, out-of-bounds read) and the domain (text parsing vs. inode state management) are completely unrelated. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are in the Linux kernel filesystem layer. The vulnerability type for CVE-2017-18249 is a race condition (CWE-362) in F2FS node ID management. The target code (`fuse_make_bad`) is a simple, inline function that modifies inode state. It does not involve concurrent access patterns, linked list manipulations, or the check-then-act sequences that are the core of the race condition. The similarity is limited to being kernel filesystem code.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write (CWE-787) due to integer overflow in a user-space VNC library's file transfer protocol. The target code is a simple state-setting function in the Linux kernel FUSE driver with no network input, integer calculations, or dynamic memory operations. Domains and vulnerability patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2011-3601 is a buffer overflow (CWE-119) in a user-space network daemon (radvd) due to improper validation of network packet data. The target code is a kernel inline function for marking a FUSE inode as bad, with no input parsing or buffer operations. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free (CWE-416) in a user-space daemon due to error handling and pointer management issues. The target code performs no dynamic memory allocation or deallocation (`remove_inode_hash` is a kernel list operation, not a free). While both involve state management, the mechanisms and vulnerability classes are distinct. Minimal reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2019-1010065 is an integer overflow (CWE-190) in a user-space digital forensics tool when parsing filesystem images. The target code performs simple bit operations and a hash list removal with no arithmetic, user input, or file parsing. Domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are in the Linux kernel. CVE-2016-10154 is a buffer access issue (CWE-119) related to improper use of stack memory for cryptographic operations in the CIFS module. The target code (`fuse_make_bad`) also runs in kernel context and manipulates kernel data structures (inode, state bits). However, it does not involve cryptography, scatterlists, or the specific VMAP_STACK complication. The connection is the shared kernel environment and potential for careful review of any kernel memory operations.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2018-20760 is an out-of-bounds write (CWE-787) in a user-space multimedia framework due to improper handling of text encoding conversion errors. The target code is a kernel function with no string processing, encoding, or error return code checks from called functions. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are in the Linux kernel filesystem layer (ocfs2 vs. FUSE). CVE-2017-18216 is a NULL pointer dereference (CWE-476) enabled by a race condition (CWE-362) in cluster node management. The target code (`fuse_make_bad`) accesses `get_fuse_inode(inode)->state`. If `fuse_make_bad` could be called on an inode where the fuse_inode data is not properly initialized or has been freed (e.g., due to a race during mount/umount or inode lifecycle), a similar NULL or invalid pointer dereference could occur. This suggests a need to audit the callers of `fuse_make_bad` for proper synchronization and lifecycle guarantees. The vulnerability pattern (concurrent access leading to invalid pointer access) has some similarity, though the specific context differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      }
    ]
  },
  "CVE-2022-2553_after_exclude_100:1c987b5b:vulspec": {
    "timestamp": "2026-01-17T01:51:41.698234",
    "cve_id": "CVE-2022-2553",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1c987b5b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a complex parser (regex) with out-of-bounds read due to improper NUL byte handling. The target code is a configuration setup function with simple file reading and string operations. No pattern parsing or complex input validation of that nature is present.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is about integer overflow leading to out-of-bounds write in a network protocol handler. The target code performs basic file I/O and configuration checks. While it uses `snprintf` with size calculation (`sizeof(cl.lockfile)-1`), this is a safe pattern to leave room for the null terminator, not a vulnerable integer wrap.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse complex network packets or TLVs. Its input is from local configuration files, and the primary risk is not buffer over-read from untrusted network data.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves improper memory buffer operations in a kernel cryptographic module, specifically with scatterlists and VMAP_STACK. The target code is user-space application code performing configuration setup. It uses a cryptographic library (libgcrypt) but only for initialization, not for operations on stack buffers that could be non-contiguous.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a race condition in a kernel filesystem's resource (node ID) management. The target code is a synchronous setup function called during daemon/client initialization. It lacks concurrent execution contexts, shared resource manipulation, or the non-atomic check-and-use patterns that define this vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a NULL pointer dereference due to missing parameter validation in a kernel subsystem. The target code has multiple error paths using `goto out` and checks return values (e.g., `rv < 0`), showing some defensive programming. However, it does not deeply validate all pointer parameters (e.g., `booth_conf` is assumed valid after `read_config`), which is a tangential similarity but in a completely different context (user-space vs. kernel, setup vs. network option processing).",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a use-after-free caused by a race condition and improper locking in kernel memory policy. The target code is a straightforward, linear setup function with no dynamic resource allocation/freeing within its scope and no locking mechanisms. The relevance is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to a NULL pointer dereference during concurrent keyring initialization. The target code is not a kernel subsystem, does not manage shared global resources like keyrings, and is not susceptible to the same initialization-time race from multiple threads.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a missing authorization vulnerability in a kernel keyring subsystem. The target code performs no authorization checks; it's a setup routine that reads files and validates configuration data. The domains (security/access control vs. application configuration) are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a use-after-free due to uninitialized pointers and inconsistent state cleanup in an error path. The target code uses `goto out` for error handling, which is a pattern that must ensure resources are properly cleaned up. While the code shows careful error handling with `rv` checks, a potential similarity exists in the need to manage state (like initialized libgcrypt) correctly across all exit paths. However, the specific flaw (UAF from uninitialized structs) is not evident here.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      }
    ]
  },
  "CVE-2021-3712_before_exclude_100:5f3bdf54:vulspec": {
    "timestamp": "2026-01-17T01:51:54.636011",
    "cve_id": "CVE-2021-3712",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5f3bdf54",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is an elliptic curve parameter parsing function in OpenSSL's cryptographic library. The domain (cryptography vs. regex parsing), vulnerability type (CWE-125 vs. potential CWE-20/190/787), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 2 is a side-channel vulnerability (CWE-385) in an elliptic curve cryptography (ECC) library (libgcrypt). The target code is also an ECC function in OpenSSL for constructing an EC_GROUP from parameters. Both operate in the same domain (ECC implementation), handle similar mathematical structures (curve parameters, points, orders), and share the critical context of processing untrusted external parameters. The vulnerability patterns differ (side-channel vs. memory corruption), but the cryptographic context and attack surface (parsing external curve data) are highly similar and provide valuable reference for validation logic.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 is an integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code parses ASN.1 encoded elliptic curve parameters. Both involve parsing untrusted data, but the domains (remote desktop protocol vs. cryptographic parameter serialization), data formats (binary VNC messages vs. ASN.1), and primary vulnerability mechanisms (CWE-190/787 vs. potential CWE-20/125) are distinct. The only similarity is the need for careful input validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read in a network protocol parser (tcpdump) due to insufficient length validation. The target code also parses structured data (ASN.1/DER encoded EC parameters) and must validate field lengths. The vulnerability type (CWE-125) and the root cause (insufficient validation of length fields) are conceptually similar. However, the application domains (network analysis vs. cryptography) and specific data structures (LDP TLVs vs. ASN.1 INTEGER/OCTET_STRING) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a NULL pointer dereference in a regex library due to inconsistent error state handling. The target code uses extensive `goto err` error handling with cleanup. While both have error paths, the vulnerability pattern (CWE-476 from missing error state vs. potential resource management errors in cleanup) and domain are not similar. The target code's error handling is more structured around freeing resources.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate/Weak relevance. Case 6 is an integer overflow in DNS domain name parsing leading to an out-of-bounds write. The target code performs arithmetic operations (e.g., field_bits comparisons, BN_num_bits) and could theoretically be susceptible to integer issues if large parameters are provided (though it checks against OPENSSL_ECC_MAX_FIELD_BITS). Both parse untrusted data and perform size calculations. The relevance is limited because the target code uses bignum libraries (BIGNUM) which mitigate typical integer overflows, and the data structure (ASN.1) is more constrained than arbitrary domain names.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds write in a text encoding converter due to improper error handling. The target code copies seed data using `memcpy` but validates source length and allocates destination buffer first. Both involve copying data from parsed structures. The vulnerability pattern (CWE-787 from unchecked error states) is less relevant to the target code's more direct buffer copy, though the need for careful buffer management is a shared concern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a double-free in an antivirus file parser. The target code has a complex error cleanup path (`err:` label) that frees many resources (BIGNUMs, EC_GROUP, EC_POINT, BN_CTX). If the cleanup logic were flawed (e.g., freeing a pointer twice or in the wrong order), it could lead to similar resource management errors (CWE-415/416). The pattern of centralized cleanup after multiple allocations is similar, but the domain and specific triggers differ.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a use-after-free due to inconsistent state management during error handling. The target code's `err:` cleanup path frees resources based on the state of variables (some may be NULL). If the function's state were incorrectly managed before a jump to `err:`, similar issues could arise. The pattern of cleaning up partially initialized structures is analogous, but the domain and specific APIs are very different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate/Weak relevance. Case 10 is improper input validation in a decompression module leading to out-of-bounds write. The target code extensively validates its ASN.1 input (checking for NULL pointers, validating field types, checking integer ranges and bit lengths). Both emphasize the critical need for rigorous validation of untrusted complex input to prevent memory corruption. The core principle is highly relevant, but the specific vulnerability mechanism (failing to validate match offsets in a sliding window) is not applicable to the ASN.1/bignum context.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2021-3712_after_exclude_100:5b29d6f4:vulspec": {
    "timestamp": "2026-01-17T01:52:34.175717",
    "cve_id": "CVE-2021-3712",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5b29d6f4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regular expression engine due to improper NUL byte handling. The target code is an elliptic curve parameter parser in OpenSSL's cryptographic library. The domain (cryptography vs. regex parsing), vulnerability type (CWE-125 vs. potential ASN.1 parsing/validation issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 2 is a side-channel vulnerability (CWE-385) in an Elliptic Curve Cryptography (ECC) library (libgcrypt). The target code is also from an ECC library (OpenSSL) and handles the parsing and construction of EC_GROUP objects from parameters. While the specific flaw (non-constant-time operations) is not directly visible in this parsing function, the code domain is identical (ECC implementation), and the function is a critical part of the ECC stack where validation errors could lead to related vulnerabilities (e.g., invalid curve attacks). The code patterns for handling curve parameters (a, b, p, order) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 is an integer overflow leading to an out-of-bounds write in a VNC file transfer protocol parser. The target code performs ASN.1/DER parsing of cryptographic parameters. Both involve parsing untrusted input, but the domains (remote desktop protocol vs. cryptographic parameter encoding), data formats (binary VNC messages vs. ASN.1), and primary vulnerability patterns (CWE-190/787 vs. potential validation/logic errors) are distinct. The only weak similarity is the need to validate integer fields from untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read in a network protocol parser (tcpdump) due to insufficient length validation. The target code also parses a structured format (ASN.1) and performs length checks (e.g., checking field_bits against OPENSSL_ECC_MAX_FIELD_BITS). This provides a moderate reference for the importance of validating length fields from untrusted data. However, the domain (network packet analysis vs. cryptographic parameter loading) and the specific vulnerability mechanism differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a NULL pointer dereference in a regex library due to inconsistent error state handling. The target code uses a goto-based error handling pattern that consistently sets error codes via ECerr() before jumping to cleanup. While both involve error handling, the specific flaw pattern (missing error state set) is not apparent in the well-structured target code, and the domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-16161"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate/Weak relevance. Case 6 is an integer overflow in a DNS domain name parser leading to an out-of-bounds write. The target code performs arithmetic and bounds checks (e.g., field_bits > OPENSSL_ECC_MAX_FIELD_BITS, BN_num_bits checks). The relevance lies in the general principle of rigorously validating numeric inputs from untrusted sources to prevent overflows or logic errors. However, the specific integer overflow pattern and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds write in a text encoding converter due to improper error handling. The target code has extensive error handling via goto err. The weak similarity is the need to handle all error paths correctly to avoid memory corruption. However, the specific flaw (ignoring a converter's error return) and domain (text processing vs. ASN.1/BIGNUM manipulation) are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 is a double-free in a file parser due to inconsistent state management during errors. The target code uses a unified cleanup block (`err:`) that frees resources only if they are non-NULL, which is a robust pattern against double-free. The relevance is only in the general category of careful resource management during error conditions, but the specific vulnerability pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is a use-after-free due to uninitialized pointers and inconsistent state management. The target code initializes pointers to NULL and checks them before freeing. The weak similarity is the importance of proper initialization and cleanup. The domains and specific flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an improper input validation leading to buffer overflow in a decompression module. The target code validates its inputs (checking for NULL pointers, validating field sizes, checking BN signs). The principle of rigorously validating all parameters from untrusted data is highly relevant. The domain difference (compression vs. cryptography) and the specific vulnerability (window boundary check) reduce the score.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-2963_before_exclude_100:d18e6f16:vulspec": {
    "timestamp": "2026-01-17T01:53:17.205279",
    "cve_id": "CVE-2022-2963",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d18e6f16",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a command-line option parser with no regex processing, complex string parsing, or similar memory safety issues. The functional domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon's service registration, involving complex state and error handling. The target code performs straightforward command-line parsing with static allocation and simple error paths (exit on failure). No dynamic resource management or similar concurrency/state issues are present.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is an integer overflow leading to out-of-bounds write in a network protocol handler. The target code uses `strtoull` for memory limit parsing, which could theoretically overflow, but the context (local command-line parsing vs. network data processing) and attack surface are vastly different. The code patterns and risk profiles do not align closely.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a double-free in a document parser during error handling. The target code has no dynamic memory deallocation in the shown function; it allocates once with `malloc` and does not free. The error paths call `badusage()` which likely exits. No similar resource management patterns exist.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in an XML parser due to insufficient bounds checking on end tags. The target code parses command-line arguments using a structured option table, with no complex hierarchical parsing or buffer boundary checks involved. The domains and flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code does not parse binary protocol data; it processes string arguments. While both handle external input, the parsing complexity, data structures, and validation requirements are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is an out-of-bounds write in a text encoding converter due to improper error handling. The target code uses `addopt` to concatenate option strings into fixed-size buffers (`inoptsbuf`/`outoptsbuf`). If `addopt` does not perform bounds checking, a buffer overflow is possible. This is a tangential similarity in the concept of unsafe buffer operations, but the context (encoding conversion vs. string concatenation) and typical root causes differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in an XML parser during multi-byte character processing. The target code performs simple string assignment from `jas_optarg` with no evident character encoding or complex buffer state management. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 9 is a race condition in a kernel filesystem's resource management. The target code is a single-threaded command-line parser run at program startup. There is no concurrency, shared state, or resource allocation beyond a one-time malloc. The vulnerability categories are orthogonal.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is improper input validation in a decompression module leading to memory corruption. The target code validates input indirectly via the option parser but does use `atoi` and `strtoull` on user-provided strings (`jas_optarg`). Improper validation of these numeric arguments could lead to unexpected behavior (e.g., negative values for `cmptno` or `debug`). This is a weak similarity in the theme of parsing untrusted input, but the scope (numeric conversion vs. complex binary format parsing) and potential impact are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-2963_after_exclude_100:e924ad77:vulspec": {
    "timestamp": "2026-01-17T01:53:49.427419",
    "cve_id": "CVE-2022-2963",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e924ad77",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a buffer over-read (CWE-125) in a regular expression parser due to improper NUL byte handling. The target code is a command-line argument parser with no regex processing, character class handling, or similar complex string parsing logic. The vulnerability patterns and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a Use-After-Free (CWE-416) in a network daemon related to inconsistent state management during error handling. The target code performs straightforward command-line parsing with simple memory allocation (one malloc) and no complex resource management or error recovery paths that could leave dangling pointers. The code patterns and flaw mechanisms are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is an Out-of-bounds Write (CWE-787) due to integer overflow in a file transfer protocol. The target code uses `strtoull` for parsing the `--memory-limit` argument, which could theoretically overflow if the result is stored in a smaller type, but the code shows `max_mem` is likely a 64-bit type (strtoull). However, the context (command-line parsing vs. network protocol handling) and the specific integer overflow/truncation pattern are different. The `addopt` function (not shown) could be a more relevant buffer handling point.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a Double Free (CWE-415) in a file parsing subsystem during error conditions. The target code has a single `malloc` and a corresponding `cmdopts_destroy` function (not shown), which likely performs a single `free`. There is no evidence of complex error state management or multiple allocation paths that could lead to double-free. The memory management model is simple and linear.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an Out-of-bounds Read (CWE-125) in an XML parser due to insufficient bounds checking during end tag processing. The target code does not parse structured document formats; it parses command-line arguments using a getopt-like function (`jas_getopt`). There is no complex hierarchical parsing or buffer navigation that could lead to similar bounds checking failures.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Read in a network protocol parser due to insufficient validation of a TLV length field. The target code parses command-line arguments, not network packets. While both involve parsing structured input, the mechanisms (getopt vs. binary TLV parsing) and the resulting vulnerability patterns (buffer over-read from network data vs. string handling) are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is an Out-of-bounds Write in a text encoding conversion function due to improper error handling. The target code performs no text encoding conversion. The `addopt` function, which concatenates option strings into a buffer, is a more plausible location for buffer overflows, but the specific flaw pattern (UTF conversion error path) is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an Out-of-bounds Read in an XML/HTML parser during multi-byte character processing. Similar to Case 5, the target code's functionality is command-line argument parsing, not document parsing with character encoding complexities. The vulnerability domain is unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 9 is a Race Condition (CWE-362) in a filesystem's node ID management. The target code is a command-line parser that runs once during program initialization; it is not concurrent, does not manage shared resources, and has no thread-safety concerns. The vulnerability categories are completely orthogonal.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an Improper Input Validation (CWE-20) leading to memory corruption in a decompression module. The target code validates command-line arguments in a basic way (e.g., checking for required `outfmt_str` or `outfile`). The most relevant parallel is the use of `atoi` and `strtoull` on user-provided strings (`jas_optarg`) without explicit error checking for invalid numeric formats or out-of-range values, which could lead to unexpected behavior. However, the scale and context (decompression algorithm vs. argument parsing) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      }
    ]
  },
  "CVE-2022-0361_before_exclude_100:6236ed62:vulspec": {
    "timestamp": "2026-01-17T01:54:09.218174",
    "cve_id": "CVE-2022-0361",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6236ed62",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a text buffer copy function in an editor (likely Vim), performing line-by-line operations with explicit bounds checks (line1 <= line2). CVE-2018-18313 is an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The domains (text editor buffer vs. regex parsing), vulnerability types (logic/state management vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a single-threaded user-space function performing sequential buffer operations. CVE-2018-10675 is a use-after-free caused by a race condition in the Linux kernel's NUMA memory policy subsystem. The concurrency model (none vs. kernel SMP), memory management scope (user-space buffer vs. kernel objects), and flaw nature (logic error vs. synchronization bug) are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code performs controlled line copying with no direct integer arithmetic on user-controlled sizes. CVE-2018-20750 is an integer overflow leading to an out-of-bounds write in a network protocol parser. While both involve copying data, the attack surface (local editor command vs. remote network input), vulnerability root cause (no evident integer overflow in target code), and criticality are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code manipulates an explicit line-number-based buffer. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect bounds checking during tag parsing. The data structures (array of lines vs. parsed tree), input complexity (simple line ranges vs. complex malformed XML), and memory safety mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code uses `ml_get()` and `ml_append()` which likely perform bounds-checked buffer accesses. CVE-2016-1833 is an out-of-bounds read in a multi-byte character encoding parser. The domains (text line management vs. character encoding decoding) and the specific flaw pattern (parser state error vs. buffer index logic) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code shows no evidence of pointer dereferencing without prior validation (e.g., `p` is checked after `vim_strsave`). CVE-2013-0310 is a NULL pointer dereference in a kernel networking subsystem due to missing parameter validation. The environment (user-space editor vs. kernel), error condition (allocation failure vs. syscall parameter), and consequence severity are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs a buffer operation with an undo save (`u_save`). CVE-2017-17807 is a missing authorization flaw in a Linux kernel key management subsystem. The security model (no apparent permission check in this function vs. explicit capability checks), subsystem (editor vs. OS security), and vulnerability class (logic vs. authorization) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code's memory management is simple (`vim_strsave`/`vim_free`). CVE-2016-3179 is a use-after-free in a network daemon due to complex error path state inconsistency. The resource management patterns (straightforward allocate/copy/free vs. linked list management with error cleanup) and context (local command vs. network service) share no meaningful similarities.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is not concurrent and does not manipulate shared pointer-based structures. CVE-2017-18216 is a NULL pointer dereference due to a race condition in a kernel filesystem's cluster node management. The absence of concurrency, shared state, and complex pointer lifecycles in the target code makes this case irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. This is the most relevant case, but still very low. Both the target code and CVE-2019-15166 involve parsing/processing structured data (lines in a buffer, LMP packets). However, the vulnerability type differs significantly: the target code's primary risk appears to be logical errors in line number adjustment (e.g., the complex `if` blocks modifying `line1`, `line2`, `curwin->w_cursor.lnum`), potentially leading to infinite loops or incorrect copies, whereas CVE-2019-15166 is a classic missing input validation (bounds check) leading to memory corruption. The pattern is \"data processing,\" but the flaw mechanics are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2022-0361_after_exclude_100:e7fc58db:vulspec": {
    "timestamp": "2026-01-17T01:54:09.390274",
    "cve_id": "CVE-2022-0361",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e7fc58db",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is a text buffer copy function in an editor (likely Vim), dealing with line numbers and memory allocation for strings. CVE-2018-18313 is an out-of-bounds read in a Perl regex engine due to NUL byte handling. The domain (text editor vs. regex compiler), vulnerability type (OOB read vs. potential logic/overflow in line counting), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is a user-space application function performing a copy operation. CVE-2018-10675 is a use-after-free due to a race condition in the Linux kernel's memory policy subsystem. The environments (user-space vs. kernel), concurrency models (no evident locking in target code vs. complex kernel locking), and vulnerability patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The only tangential similarity is that both involve copying/manipulating data. CVE-2018-20750 is an out-of-bounds write in a network server due to integer overflow in size calculation. The target code performs line-by-line copying using `vim_strsave` and `ml_append`, which internally handle allocation. While integer overflows in line count calculations (`line2 - line1 + 1`) are a theoretical concern, the context and typical data sizes (line numbers vs. network packet lengths) differ greatly. The primary flaw patterns (OOB write from integer wrap vs. potential off-by-one in line indexing) are not strongly aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Target code manipulates an editor's buffer lines. CVE-2016-1838 is an out-of-bounds read in an XML parser due to incorrect end-tag handling. The domains (text editor buffer management vs. XML document parsing), data structures, and vulnerability triggers are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Similar to case 4, this is an OOB read in an XML/HTML parser related to character encoding. The target code deals with copying whole lines of text, not parsing or validating multi-byte character streams. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-0310 is a NULL pointer dereference in the Linux kernel networking stack. The target code performs user-space buffer operations and includes NULL checks (e.g., `if (p != NULL)`). The context and flaw type are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-17807 is a missing authorization flaw in the Linux kernel key management subsystem. The target code performs a data copy operation with no apparent authorization checks. The security model and vulnerability class are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon related to error handling and uninitialized state. The target code's error handling is simple (returns on `u_save` failure), and memory is freed immediately after use (`vim_free(p)`). The patterns of resource management and concurrency are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-18216 is a NULL pointer dereference due to a race condition in a kernel filesystem module. The target code is a single-threaded user-space function with no evident concurrency or complex pointer lifecycle issues. The environments and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18216"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The highest similarity among the cases, but still low. Both involve parsing/processing structured data (lines in a buffer vs. network protocol objects). CVE-2019-15166 is an improper input validation (missing bounds check) in a packet parser. The target code also relies on input validation (line numbers `line1`, `line2`, `n`) being sane for correct buffer access via `ml_get` and `ml_append`. A vulnerability could exist if these line numbers are not properly validated before use, leading to out-of-bounds reads/writes. However, the domain (network security tool vs. text editor), data source, and specific validation challenges are distinct. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2021-24029_before_exclude_100:80d225e5:vulspec": {
    "timestamp": "2026-01-17T01:54:29.465838",
    "cve_id": "CVE-2021-24029",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "80d225e5",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves integer overflow in packet parsing (CWE-190) leading to out-of-bounds read. The target code is a QUIC handshake state update function managing cipher assignment and state transitions. While both handle network protocols, the vulnerability type (integer overflow vs. state/logic error), trigger conditions (malformed packet vs. incorrect state sequence), and code patterns (arithmetic validation vs. conditional checks and moves) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves improper initialization (CWE-665) in a network packet dissector leading to uninitialized memory exposure. The target code also handles network protocol state but focuses on cryptographic material management and state transitions. Both are in network stacks, but the flaw nature (uninitialized state on error path vs. conditional cipher assignment) and attack surface (packet parsing vs. handshake logic) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 3 involves cryptographic algorithm handling (CWE-327) leading to a NULL pointer dereference (CWE-476). The target code manages cryptographic ciphers during a QUIC handshake. Both involve cryptographic material, but the vulnerability pattern is different: Case 3 is about processing unsupported algorithms causing improper cleanup, while the target code's risk would more likely be state machine or validation errors. The reference value is limited to general caution around crypto state management.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 involves improper verification of cryptographic signatures (CWE-347) due to insufficient ASN.1 validation. The target code handles cryptographic ciphers and transport parameters during QUIC handshake. Both are in cryptographic protocol implementations. The relevance comes from the need to validate cryptographic material and parameters (e.g., `clientParams` check). However, the specific flaw (signature verification bypass vs. handshake state management) and code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a numeric conversion error (CWE-189) in an archive library leading to buffer overflow. The target code performs no arithmetic or size conversions; it moves cipher objects and checks state. The domains (archive writing vs. network protocol handshake), vulnerability types, and code patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 6 involves insufficient verification of data authenticity (CWE-345) in a cryptographic authentication handshake (EAP-pwd). The target code implements part of the QUIC cryptographic handshake, processing client transport parameters. Both involve cryptographic handshake state machines and parameter validation. The key similarity is the need to validate peer-supplied data (`clientParams`) in a security-sensitive context. The flaw pattern (missing validation) could be analogous, though the specific mechanisms differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a NULL pointer dereference (CWE-476) in a socket binding function due to insufficient parameter validation. The target code has pointer dereferences (e.g., `handshakeLayer`) and checks (e.g., `CHECK` macros), but they are preceded by indirect calls or assumptions of non-null state. Both involve network protocol code, but the vulnerability pattern (missing NULL check on user input vs. internal state management) is different. The reference value is limited to general pointer safety.",
        "case_metadata": {
          "cve_id": "CVE-2015-8956"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 8 is an out-of-bounds read (CWE-125) in a packet parser due to insufficient bounds checking. The target code does not parse raw packets or perform array indexing; it manages objects retrieved from a handshake layer. Both are network-related, but the vulnerability type (memory safety vs. logic/state) and code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13014"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 involves information exposure (CWE-200) due to weak random number generation in a session authentication module. The target code handles handshake state and ciphers but does not generate random values or session IDs. Both are security-sensitive, but the flaw domain (cryptographic randomness vs. state machine) is different.",
        "case_metadata": {
          "cve_id": "CVE-2014-8566"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is an out-of-bounds read (CWE-125) in a PPP protocol parser due to missing length validation. Similar to Case 8, this is a packet parsing vulnerability. The target code does not parse variable-length fields from raw data; it works with already-extracted objects. The relevance is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2017-13029"
        }
      }
    ]
  },
  "CVE-2021-24029_after_exclude_100:e27bf576:vulspec": {
    "timestamp": "2026-01-17T01:55:00.343861",
    "cve_id": "CVE-2021-24029",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e27bf576",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow (CWE-190) in SSH packet parsing leading to out-of-bounds read. The target code is a QUIC handshake state update function managing cipher assignment and state transitions. There is no integer arithmetic, packet length parsing, or similar memory corruption patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-17498"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves improper initialization (CWE-665) in a network packet dissector leading to uninitialized memory exposure. The target code performs deterministic state updates based on available cipher objects. It does not parse raw packets, manage complex protocol states with error paths that leave data uninitialized, or have similar information disclosure risks.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves a broken cryptographic algorithm (CWE-327) leading to a NULL pointer dereference (CWE-476). The target code handles cryptographic ciphers but does not implement cryptographic algorithms or compute key tags. The only weak similarity is the potential for NULL pointer issues if `handshakeLayer` or its returned pointers were NULL, but the code pattern (checking for cipher existence with `if (cipher)` before use) is fundamentally different from the case's flaw of improper error handling after a crypto failure.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves improper cryptographic signature verification (CWE-347) due to ASN.1 parsing flaws. The target code deals with cryptographic ciphers but is at a higher abstraction levelit receives cipher objects from a handshake layer and assigns them. It does not parse certificates, verify signatures, or handle low-level ASN.1 structures. Both are in the TLS/SSL protocol domain, but the vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-16149"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves a numeric conversion error (CWE-189) in an archive writing library leading to buffer overflow. The target code performs no numeric conversions, size calculations, or buffer operations. It moves smart pointers and updates state flags. The domains and flaw patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0211"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 involves insufficient verification of data authenticity (CWE-345) in a cryptographic handshake (EAP-pwd), specifically missing validation of peer-supplied scalars and points. The target code is also part of a cryptographic handshake (QUIC) and updates state based on data (cipher availability) from the handshake layer. The relevance is in the domain of cryptographic protocol state management. However, the target code does not validate the cryptographic material itself; it trusts the handshake layer. The flaw pattern (missing validation) is not directly mirrored, but the context of managing state during a key exchange is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a NULL pointer dereference (CWE-476) in a socket binding function due to insufficient parameter validation. The target code does dereference the `handshakeLayer` pointer (via `->` operator) without an explicit NULL check at the start, which is a potential similarity. However, the function likely requires a valid `conn` and `conn.serverHandshakeLayer`. The overall context (network protocol state update vs. socket API parameter validation) and the specific trigger conditions are very different.",
        "case_metadata": {
          "cve_id": "CVE-2015-8956"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves an out-of-bounds read (CWE-125) in a packet dissector due to insufficient bounds checking. The target code does not parse packet data or perform array indexing. It operates on already-extracted cipher objects. No similarity in vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-13014"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves information exposure (CWE-200) due to weak random number generation in a session management module. The target code updates connection state but does not generate session IDs, random numbers, or cryptographic keys. The domains (authentication vs. transport layer encryption) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2014-8566"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves an out-of-bounds read (CWE-125) in a PPP protocol parser due to insufficient length validation. Similar to Case 8, the target code does not parse variable-length protocol fields or perform bounds checking on packet data. No relevant similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-13029"
        }
      }
    ]
  },
  "CVE-2017-18926_before_exclude_100:f030234f:vulspec": {
    "timestamp": "2026-01-17T01:56:00.797215",
    "cve_id": "CVE-2017-18926",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f030234f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Target code is an XML writer function in a library like raptor, focusing on namespace and attribute serialization. Case 1 involves a Perl regex engine vulnerability (CWE-125) related to NUL byte handling in pattern compilation. The domain (XML vs. regex), vulnerability type (memory management vs. out-of-bounds read), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve XML processing libraries (target: raptor XML writer; case: libxml2 parser). Both deal with element/attribute handling and memory safety. However, the vulnerability types differ: target code's primary risk appears to be memory allocation/management errors (e.g., via `RAPTOR_CALLOC` failure handling, array indexing), while Case 2 is a specific out-of-bounds read (CWE-125) in end tag parsing. The code patterns (writer vs. parser) and exact flaw mechanisms are not identical but share the XML domain and potential for memory safety issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a Use After Free (CWE-416) in a network daemon (MiniSSDPd) related to socket message handling and service list management. The target code is an XML serialization function with static array allocation and cleanup. The domains (XML library vs. SSDP service), functionality, and vulnerability patterns (complex state management errors vs. potential allocation/indexing errors) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve XML library components (target: writer; case: libxml2 parser). Both handle complex data structures (namespaces, attributes/elements) and require careful memory and buffer management. Case 4 is an out-of-bounds read (CWE-125) during multi-byte character processing. The target code has buffer length calculations (`buf_length`) and string operations (`memcpy`, `raptor_xml_escape_string`) which, if flawed, could lead to similar bounds issues. The relevance is stronger than Case 2 due to the shared context of encoding/string handling within XML.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an integer overflow leading to out-of-bounds write (CWE-787) in a VNC file transfer protocol. The target code performs arithmetic for `nspace_max_count` and allocates memory based on it. If `element->attribute_count` or sequence sizes are attacker-controlled and large, an integer overflow in `nspace_max_count * sizeof(struct nsd)` could occur, leading to undersized allocation (similar root cause: CWE-190). However, the domains (XML serialization vs. network file transfer) and the specific manifestation (heap corruption vs. potential array overflow) are different, making the relevance limited.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are in XML libraries (raptor vs. libxml2) and involve processing XML attributes and namespaces. Case 6 is a Use After Free (CWE-416) in attribute processing. The target code manages an array of `nsd` structures (`nspace_declarations`), frees pointers within it in loops, and later accesses the array. The pattern of allocating an array of structures containing pointers, freeing them conditionally within a loop, and having complex control flow (multiple loops, `goto error`) is similar to patterns that can lead to use-after-free or double-free if indices or cleanup logic is flawed. The functional context is highly analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read (CWE-125) in a network protocol parser (tcpdump/LDP). The target code is an XML writer with no network parsing. The vulnerability patterns (missing length validation on network packets vs. calculated buffer sizes and string operations) and domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 is a buffer overflow (CWE-119) in libxml2 string handling. The target code performs string operations (`memcpy`, `raptor_xml_escape_string`) into a buffer of calculated size (`buf_length`). If the length calculations for `lang_len` or the escape function's output are incorrect, a buffer overflow could occur. The pattern of calculating a buffer size, allocating, and then writing data is similar. However, Case 8's specific flaw involves a negative length, while the target's risk is more about miscalculation or escape function behavior.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 9 is a Use After Free (CWE-416) in libxml2 related to buffer reallocation and dictionary handling during name parsing. The target code does not show explicit reallocation, but it manages a dynamically allocated array (`nspace_declarations`) and populates it across multiple loops. If the `nspace_declarations_count` were to exceed `nspace_max_count` due to a logic error (e.g., in the attribute loop where `element->attributes[j]->nspace` is incorrectly indexed with `j` instead of `i` on line ~58, which is a bug in the provided code), it could write out-of-bounds, potentially corrupting heap metadata leading to UAF-like consequences. This pattern of managing a counted array with a separate max limit is a shared risk factor.",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an input validation flaw (CWE-20) in a network protocol parser (tcpdump/LMP). The target code is an XML writer that assumes its input (raptor_xml_element) is already validated/internal. While lack of validation on `element->attribute_count` etc., could be an issue, the domains (network packet decoding vs. internal data structure serialization) and typical attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2017-18926_after_exclude_100:30d8d02f:vulspec": {
    "timestamp": "2026-01-17T01:56:01.605850",
    "cve_id": "CVE-2017-18926",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "30d8d02f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in a Perl regex engine due to NUL byte handling. The target code is an XML writer function in a C library (likely raptor) focusing on namespace and attribute serialization. The vulnerability type (CWE-125), domain (regex vs. XML), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-1838 is an out-of-bounds read in libxml2's end tag parser. Both involve XML processing libraries and memory safety issues (CWE-125). However, the target code is a writer/serializer function, not a parser, and the specific flaw (insufficient bounds checking during end tag processing) does not directly align with the allocation and array indexing patterns in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a use-after-free in a network daemon (MiniSSDPd) related to socket message handling and inconsistent state cleanup. The target code is an XML writer with structured error handling and cleanup (`goto error`). While both have cleanup paths, the vulnerability type (CWE-416), domain (SSDP vs. XML), and trigger conditions (network messages vs. API calls with element data) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2016-1833 is an out-of-bounds read in libxml2's character encoding processing. Both are in XML libraries and involve CWE-125. The target code performs string operations (e.g., `memcpy`, `raptor_xml_escape_string`) and manages buffers (`nspace_declarations` array). While not identical, the pattern of managing buffers based on calculated sizes (`nspace_max_count`) has some parallel to encoding buffer management flaws, though the specific trigger (multi-byte character processing) is absent.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in a VNC file transfer library. The target code uses `RAPTOR_CALLOC` for `nspace_declarations` based on `nspace_max_count`. If `nspace_max_count` could be manipulated to cause an integer overflow/wraparound during the multiplication with `sizeof(struct nsd)`, it could lead to undersized allocation and subsequent out-of-bounds writes when populating the array. This is a conceptual similarity (CWE-787 via CWE-190), but the domain (VNC vs. XML) and specific code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. CVE-2016-1835 is a use-after-free in libxml2's SAX2 attribute parser. Both are in XML libraries and involve CWE-416. The target code manages an array of `nsd` structs containing pointers (`declaration`) that are `RAPTOR_FREE`d in multiple places (in the success path and error path). If there were logic errors or state inconsistencies (e.g., double-free, accessing a freed pointer), it could lead to a use-after-free. The pattern of allocating, populating, and conditionally freeing an array of resource-holding structs is similar to the attribute handling in the libxml2 case.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in tcpdump's LDP protocol parser due to insufficient length validation. The target code is an XML writer, not a network protocol parser. The vulnerability type (CWE-125) is similar, but the domain, attack surface (network packets vs. API parameters), and code patterns (parsing TLVs vs. writing XML elements) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-1834 is a heap buffer overflow in libxml2's string handling due to negative length calculations. The target code uses `raptor_iostream_counted_string_write` which takes a length parameter. If any length calculation (e.g., `nspace_declarations[...].length`) could become negative or excessively large, it might cause a similar overflow in the IO function. However, the target code's length sources (`raptor_namespace_format_as_xml`, `raptor_qname_format_as_xml`) are less likely to produce negative values compared to the `xmlStrlen` issue in the CVE. The domain (XML libraries) is the same.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-1836 is a use-after-free in libxml2's name parser related to buffer reallocation and stale dictionary pointers. The target code does not show obvious reallocation patterns, but it does manage an array (`nspace_declarations`) whose indices (`nspace_declarations_count`) are carefully controlled. If there were an off-by-one error in indexing this array, it could lead to accessing freed memory (if the array itself was reallocated). The connection is somewhat indirect, but both involve careful management of indices and pointers in XML processing contexts (CWE-416).",
        "case_metadata": {
          "cve_id": "CVE-2016-1836"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-15166 is an improper input validation (CWE-20) in tcpdump's LMP parser leading to missing bounds checks. The target code performs some validation (e.g., checking `nstack`), but its primary vulnerability potential lies in memory corruption (overflow, UAF) rather than missing validation of external packet data. The domains (network protocol analysis vs. XML serialization) and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2021-38383_before_exclude_100:972962fe:vulspec": {
    "timestamp": "2026-01-17T01:57:35.617968",
    "cve_id": "CVE-2021-38383",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "972962fe",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a file transfer protocol. The target code is a network binding function with no complex integer calculations or dynamic memory allocations that could overflow. The vulnerability patterns and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read in a regex parser due to NUL byte handling. The target code performs network socket operations with no string parsing or regex processing. The code patterns and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves use-after-free in a network daemon. The target code also handles network sockets but manages resources differently (cleanup with freeaddrinfo, proper close on error). While both are network services, the specific memory management flaw pattern (use-after-free) is not present in the target code's straightforward resource handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 involves integer overflow in DNS domain name parsing leading to buffer overflow. The target code uses getaddrinfo for address resolution but doesn't perform manual string parsing or length calculations that could overflow. The vulnerability mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves improper privilege management when privilege separation fails. The target code doesn't implement privilege separation or drop privileges. However, both are network daemon components, and the general category of \"improper error handling leading to security issues\" has some conceptual similarity, though the specific flaw is absent.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves out-of-bounds read in a protocol parser due to insufficient length validation. The target code doesn't parse complex protocol data; it only sets up network sockets. The code patterns and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 involves reachable assertion in DNS message parsing. The target code has no assertions and doesn't parse complex protocol data. The vulnerability type and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-25037"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 involves heap buffer overflow in IRC message formatting. The target code uses fixed-size buffers (addr[INET6_ADDRSTRLEN], strport[8]) with safe snprintf, and doesn't perform dynamic string concatenation. The vulnerability mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 involves out-of-bounds read in NFS packet parsing. The target code doesn't parse network protocol payloads; it only establishes socket connections. The code functionality and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves double free in document parsing error handling. The target code has resource cleanup (freeaddrinfo, close) but in straightforward patterns without complex error paths that could cause double free. Both involve resource management, but the specific flaw pattern is not present in the target's simpler error handling.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2021-38383_after_exclude_100:95880ed4:vulspec": {
    "timestamp": "2026-01-17T01:57:46.331768",
    "cve_id": "CVE-2021-38383",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "95880ed4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a file transfer protocol handler. The target code is a network socket binding function with no complex integer arithmetic, memory allocation, or file/data parsing. The vulnerability patterns and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code performs network address resolution and socket operations with standard C library functions (getaddrinfo, socket, bind). There is no pattern parsing or string processing that could lead to similar buffer over-reads.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 involves use-after-free in a service discovery daemon. The target code has simpler resource management (single socket file descriptor) with clear cleanup paths. While both involve network services, the memory management complexity and error handling patterns differ significantly. The target code's error handling uses goto for cleanup, reducing risk of inconsistent state.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves integer overflow in DNS domain name parsing leading to buffer overflow. The target code performs basic string formatting for port numbers but uses safe functions like snprintf with fixed buffers. There are no complex length calculations or dynamic buffer operations that could lead to similar integer overflow vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves improper privilege management when privilege separation fails. The target code shows no privilege manipulation. However, both are network daemon components, and the target code's error handling (continuing after some setsockopt failures) shows a pattern of continuing operation despite partial failures, though with less severe consequences than privilege escalation.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 involves out-of-bounds read in a network protocol parser due to insufficient length validation. The target code uses getaddrinfo for address resolution and standard socket APIs with proper error checking. There is no protocol parsing of incoming data that could lead to similar bounds checking issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 involves reachable assertion in DNS message parsing. The target code has no assertions and performs simpler operations. Both handle network data, but the target code's processing is limited to system calls and standard library functions with robust error checking rather than complex protocol parsing.",
        "case_metadata": {
          "cve_id": "CVE-2019-25037"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves heap buffer overflow in IRC message formatting due to unsafe string concatenation. The target code uses snprintf for bounded string formatting and doesn't perform dynamic string building or concatenation. The code patterns and vulnerability mechanisms are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves out-of-bounds read in NFS packet parsing. The target code doesn't parse incoming network packets; it only sets up listening sockets. The vulnerability patterns (protocol field validation) don't apply to the socket creation and binding operations in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 involves double free in document parsing error handling. The target code has simpler resource management (single fd) with centralized cleanup. Both show error handling patterns, but the target code's resource management is much simpler (one file descriptor vs. complex parsed data structures), reducing risk of similar memory management errors.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2022-1297_before_exclude_100:b90fa7a0:vulspec": {
    "timestamp": "2026-01-17T01:57:54.836836",
    "cve_id": "CVE-2022-1297",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b90fa7a0",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free and double free vulnerabilities in a network service's error handling path. The target code is a binary parser for NE executables that performs list operations and memory allocations. While both involve memory management, the vulnerability types (UAF vs. potential OOB reads/writes), attack surfaces (network service vs. file parser), and code patterns (complex state cleanup vs. structured parsing loops) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 2 involves an out-of-bounds write due to integer overflow in a file parser (LibVNC). The target code parses NE executable entry tables with multiple bounds checks (e.g., `tableat + off >= r_buf_size`). Both handle binary formats with potential integer overflow risks when calculating offsets or accessing arrays (like `segment_entries[bundle_type - 1]`). The relevance is moderate because both are parsers validating external input, but the specific vulnerability patterns differ (allocation overflow vs. array index bounds).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code reads from `bin->entry_table` with bounds checks. Both involve parsing external data with potential OOB reads, but the vulnerability root cause differs significantly (NUL byte termination issues vs. missing or incorrect bounds validation on computed offsets). The code patterns and attack surfaces are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 4 involves a heap buffer overflow due to insufficient padding allocation in an image codec. The target code calculates physical addresses like `entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff`. Both perform arithmetic operations on external input to compute memory offsets, risking integer overflows or OOB accesses if `segnum` or `bundle_type` are not properly validated. The relevance is moderate as both are data parsers with similar risk patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 involves a double free in an antivirus file parser during error handling. The target code uses `r_list_newf(free)` and frees entries on error paths, but shows no evidence of double free patterns. Both parse file formats, but the vulnerability type (double free vs. potential OOB access) and error handling complexity are different. The target code's error frees lists but doesn't exhibit the inconsistent state management that leads to double frees.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 involves improper input validation leading to memory corruption in a decompression module. The target code validates bounds with `tableat + off + 4 >= r_buf_size(bin->buf)` and checks `bundle_length`. Both are parsers validating external input to prevent OOB accesses. The relevance is moderate because both implement bounds checking loops, but the specific vulnerability (window boundary bypass vs. table index validation) differs.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves out-of-bounds write due to alignment assumptions in a WebSocket decoder. The target code reads byte and word values (`ut16 segoff = *(ut16 *)(bin->entry_table + off)`) which could cause alignment issues on some architectures. Both process binary data with direct memory accesses. However, the primary vulnerability in Case 7 is specific to unaligned memory access patterns, while the target code's main risks are bounds validation.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 8 involves an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code parses a table with length fields (`bundle_length`, `EntryTableLength`) and performs bounds checks. Both parse structured binary data with TLV-like formats (type/length bundles) and must validate lengths against buffer sizes. The code patterns and vulnerability type (OOB read) are similar, though the domains differ (network vs. executable parsing).",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Case 9 involves integer overflow leading to out-of-bounds read in a binary file parser (libplist). The target code performs arithmetic operations like `entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + segoff`. Both parse binary files with offset tables, use external inputs in calculations, and risk integer overflows that bypass bounds checks. The vulnerability patterns (integer overflow in offset calculation) and code patterns (table parsing with computed offsets) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-7982"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 involves improper bounds restriction due to unchecked header values in an image parser. The target code checks `bundle_type < bin->ne_header->SegCount` but may have other missing validations. Both parse file headers and validate fields. However, Case 10 focuses on allocation size validation failures, while the target code's primary risks are array index bounds and offset calculations. The vulnerability mechanisms are somewhat related but not strongly aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      }
    ]
  },
  "CVE-2022-1297_after_exclude_100:741a06e5:vulspec": {
    "timestamp": "2026-01-17T01:58:09.460933",
    "cve_id": "CVE-2022-1297",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "741a06e5",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free (CWE-416) in a network daemon's state management. The target code is a file format parser (NE executable) with careful memory allocation and cleanup (r_list_newf/free). While both involve dynamic memory, the vulnerability type, trigger conditions (error handling vs. parsing logic), and code patterns (network service vs. binary parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 2 involves an Out-of-Bounds Write (CWE-787) due to integer overflow (CWE-190) in a file transfer parser. The target code performs bounds checks (e.g., `tableat + off >= r_buf_size`, `off > bin->ne_header->EntryTableLength`) to prevent similar issues while reading from `bin->entry_table`. The relevance lies in the shared domain of parsing untrusted binary data and the need for rigorous bounds validation, though the specific flaw patterns differ (allocation overflow vs. offset validation).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 3 involves an Out-of-Bounds Read (CWE-125) due to improper NUL byte handling in a regex parser. The target code reads from a buffer (`bin->entry_table`) with explicit bounds checks before dereferencing pointers (e.g., `tableat + off + 4 >= r_buf_size`). Both deal with preventing reads beyond buffer boundaries when processing structured input, but the vulnerability root cause (NUL byte vs. offset calculation) and code context (string parsing vs. table walking) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 involves a buffer overflow (CWE-119) due to insufficient padding allocation in an image codec. The target code calculates offsets and performs bounds checks but does not dynamically allocate buffers based on calculated sizes. Both involve arithmetic on offsets/addresses (`entry->paddr = ... * bin->alignment + ...`), but the vulnerability pattern (allocation size miscalculation vs. offset validation) and domain (image encoding vs. executable metadata parsing) have limited overlap.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves a Double Free (CWE-415) in an antivirus file parser during error handling. The target code uses `R_NEW0` for allocation and `r_list_newf(free)` for automatic cleanup, reducing double-free risk. Both parse complex file formats, but the memory management model is different (manual error cleanup with `r_list_free` in target vs. inconsistent state in Case 5). The shared context of parsing untrusted files provides some reference value.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 involves Improper Input Validation (CWE-20) leading to memory corruption in a decompression module. The target code validates offsets and lengths against buffer sizes and table limits (e.g., `segnum > 0 && segnum < bin->ne_header->SegCount`). Both are parsers of binary structures requiring rigorous validation of indices and offsets derived from untrusted input. The specific flaw (window boundary check vs. segment index check) is analogous, though the code patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 involves an Out-of-Bounds Write (CWE-787) due to alignment issues in a WebSocket decoder. The target code performs byte-aligned reads via `r_read_le16` and pointer arithmetic without assumptions about alignment. The vulnerability types and trigger conditions (unaligned memory access vs. bounds-checked offset arithmetic) are dissimilar, and the domains (network protocol decoding vs. executable entry point extraction) share little common ground.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 8 involves an Out-of-Bounds Read (CWE-125) due to insufficient TLV length validation in a network protocol parser. The target code similarly parses a structured table (NE entry table) with length fields (`bundle_length`, `EntryTableLength`) and performs multiple bounds checks (`off < bin->ne_header->EntryTableLength`, `tableat + off + 4 >= r_buf_size`). The code patterns (walking a TLV-like structure with length-controlled loops) and the need to validate each read against the buffer are highly comparable, providing valuable reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 9 involves an Integer Overflow (CWE-190) leading to an Out-of-Bounds Read in a file format parser. The target code uses `ut32`, `ut16`, and `ut8` types and performs arithmetic for offset calculations (e.g., `(ut64)bin->segment_entries[...].offset * bin->alignment + delta`). While no obvious overflow exists (due to bounds checks and 64-bit math), the context of parsing untrusted binary structures with offset arithmetic is similar. The reference value is high for reviewing integer handling in such calculations.",
        "case_metadata": {
          "cve_id": "CVE-2017-7982"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 involves a buffer overflow (CWE-119) due to unchecked header values in an image converter. The target code validates indices against counts (`segnum < bin->ne_header->SegCount`, `bundle_type < bin->ne_header->SegCount`) but does not validate the integrity of the `segment_entries` or `alignment` values themselves. Both involve parsing headers and using derived values for memory access, but the flaw pattern (unchecked header field vs. index validation) and domain (image vs. executable) are only superficially similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      }
    ]
  },
  "CVE-2022-0699_before_exclude_100:cead6673:vulspec": {
    "timestamp": "2026-01-17T01:58:23.510344",
    "cve_id": "CVE-2022-0699",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cead6673",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code uses `strtok` which handles delimiters, not embedded NULs, and focuses on memory allocation/deallocation, not buffer over-reads.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-3179 is a Use-After-Free enabled by inconsistent state management during error handling. The target code has careful error handling that frees all allocated memory (`result` array and strings) before returning NULL, which is the correct pattern to avoid UAF. The relevance is in the domain of robust error cleanup, though the flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2011-1003 is a Double Free vulnerability due to inconsistent memory state management during error conditions. The target code's error paths meticulously free both the `result` pointer array and its contained strings before freeing `copy` and returning NULL. This is a textbook example of the correct pattern to avoid double-free and memory leaks. The code structure is highly relevant for understanding safe deallocation.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML end tag parser. The target code performs string tokenization and dynamic array allocation with bounds-checked iteration via `strtok`. No similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1834 is a heap buffer overflow due to improper string length validation. The target code uses `strtok` and `dupstr` (assumed to allocate based on `strlen`), with no evident arithmetic or length validation flaws. Different vulnerability class.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-20750 is an out-of-bounds write due to integer overflow in allocation size calculation. The target code uses `realloc` with a straightforward `sizeof *result * (i + 1)` calculation. While integer overflow is theoretically possible if `i` is large, the pattern is not similar to the cited case which involves 32-bit conversions and file transfer lengths.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-1835 is a Use-After-Free due to inconsistent memory management during parser state transitions. The target code demonstrates careful, sequential freeing of resources in error paths to prevent UAF. While the context (XML parsing vs. string splitting) is different, the defensive programming pattern against UAF is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read during multi-byte character encoding processing. The target code performs simple string tokenization with `strtok` on a copied string, with no character encoding complexity or low-level buffer state management.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20760 is an out-of-bounds write in a text encoding conversion function due to missing error code checks. The target code does not perform encoding conversions or have analogous error code propagation issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2011-3603 is an improper input validation leading to unnecessary privilege execution. The target code is a utility function with no privilege management or system-level state. The only weak similarity is the concept of handling failure states, but the domain and impact are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2022-0699_after_exclude_100:a6c92b39:vulspec": {
    "timestamp": "2026-01-17T01:59:15.200956",
    "cve_id": "CVE-2022-0699",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a6c92b39",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a string splitting utility using strtok and realloc. The vulnerability type (CWE-125 vs. memory management), trigger conditions (embedded NUL vs. allocation failure), and code patterns (parsing vs. tokenization) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free in a network daemon related to inconsistent state management. The target code manages memory for a string array but carefully frees all resources on allocation failure. The context (network service vs. utility function), flaw pattern (UAF vs. potential double-free/leak), and attack surface are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2011-1003 is a Double Free (CWE-415) in a file parser. The target code's error handling paths involve freeing memory (`result` array and its elements) and could potentially lead to a double-free or memory leak if not carefully managed, especially in the nested free loops. The pattern of cleaning up partially allocated structures on failure is conceptually similar, though the specific trigger (document parsing error vs. realloc failure) differs.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML end-tag parser. The target code performs string tokenization and dynamic array management with no parsing of structured markup or bounds checking issues related to reading past buffer ends. The vulnerability types and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1834 is a buffer overflow due to improper length validation in string operations. The target code uses `strtok` and `dupstr` (assumed to allocate based on string length) and does not perform manual buffer copies or length calculations that could overflow. The flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write. The target code uses `realloc` with a size calculation `sizeof *result * (i + 1)`. While this calculation could theoretically overflow for extremely large values of `i`, it's less likely than the 32-bit integer conversion in the CVE. The memory corruption outcome is similar, but the trigger (malicious network data vs. massive input size) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1835 is a Use-After-Free in an XML attribute parser due to complex state management. The target code's memory management is linear and local to the function, with no persistent references that could become dangling. The flaw pattern and domain are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-1835"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in a character encoding parser. The target code does not process multi-byte encodings or perform low-level buffer reads. The vulnerability type and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20760 is an out-of-bounds write in a text encoding conversion function due to unchecked error returns. The target code does not perform encoding conversion or have analogous error code handling. The flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3603 is an input validation flaw leading to unnecessary privilege execution in a daemon. The target code is a non-privileged string utility with no privilege management or daemon control flow. The vulnerability types and contexts are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      }
    ]
  },
  "CVE-2022-3028_before_exclude_100:a253b8b7:vulspec": {
    "timestamp": "2026-01-17T01:59:32.134415",
    "cve_id": "CVE-2022-3028",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a253b8b7",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a user-space VNC server library. The target code is a kernel-space PF_KEY socket registration function with no complex integer calculations or dynamic memory allocation based on user input that could overflow. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in the FUSE subsystem due to insufficient validation of iovec lengths. The target code performs a bounds check (`sadb_msg_satype > SADB_SATYPE_MAX`) but does not involve copying variable-length data into buffers. Both are in the kernel, but the core flaw (buffer overflow vs. state management/error handling) and attack surface differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 3 is a race condition in F2FS nid management. The target code modifies a per-socket registration bitmask (`pfk->registered`). While both involve state updates, the target code lacks the concurrent, multi-threaded check-then-use pattern critical to the race condition. The locking context of `pfkey_register` is not shown, but it's a socket operation likely serialized per socket. The reference value is limited.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a NULL pointer dereference in USB/IP due to insufficient validation of URB fields. The target code validates an input field (`sadb_msg_satype`) and checks kernel allocation failure (`supp_skb`). It does not dereference complex structures from untrusted sources. The domains (networking crypto vs. USB virtualization) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a race condition leading to buffer overflow in the TTY subsystem between concurrent writers. The target code is a registration function for a PF_KEY socket, not a high-concurrency data path with shared buffers. The synchronization challenges and data structure patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a buffer misuse in CIFS crypto due to scatterlist pointing to stack memory with VMAP_STACK. The target code uses `compose_sadb_supported` for allocation and broadcasts the result. It does not involve direct crypto API calls or special stack memory considerations. The domains and technical root cause are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a NULL pointer dereference in a USB serial driver due to missing endpoint validation. The target code validates an enumeration value and handles allocation failure. It does not parse complex hardware descriptors. The flaw pattern and subsystem are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a race condition leading to a NULL pointer dereference during user keyring initialization. The target code also manages a resource state (`registered` bitmask) associated with a socket object. Both involve per-object state initialization. However, the keyring case involves global, shared user state with complex concurrency, while PF_KEY registration is likely per-socket state. The concurrency pattern is less similar, offering limited reference.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an unbounded/overflowing memory allocation in USB/IP due to missing validation of network-provided length fields. The target code's only allocation (`compose_sadb_supported`) uses a fixed format based on supported algorithms, not directly on attacker-controlled sizes. The input validation in the target code is on a type field, not a size field. The vulnerability class is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in tcpdump's LDP parser due to insufficient length validation. The target code is a kernel subsystem registration function, not a network protocol parser. While both check bounds (`sadb_msg_satype > SADB_SATYPE_MAX`), the context, data source (system call vs. raw packet), and consequence are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2022-3028_after_exclude_100:58ebbc91:vulspec": {
    "timestamp": "2026-01-17T01:59:33.940734",
    "cve_id": "CVE-2022-3028",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "58ebbc91",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a user-space VNC server library. The target code is a kernel-space PF_KEY socket registration function with no complex integer calculations or dynamic memory allocations that could overflow. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in the FUSE subsystem due to insufficient validation of iovec lengths. The target code performs basic bounds checking (sadb_msg_satype > SADB_SATYPE_MAX) and has no buffer manipulation. Both are in the kernel, but the vulnerability mechanisms (buffer overflow vs. potential state management issues) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 3 is a race condition in F2FS nid management. The target code uses a mutex (pfkey_mutex) to protect the xfrm_probe_algs() and compose_sadb_supported() calls, showing awareness of synchronization. However, the registration bit manipulation (pfk->registered) is performed outside the mutex, which could theoretically lead to a race condition if the function is called concurrently for the same satype, making the concurrency aspect somewhat relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a NULL pointer dereference in the USB/IP subsystem due to insufficient validation of URB fields. The target code validates the `hdr` pointer (via function parameter) and checks `satype` bounds. It allocates memory (compose_sadb_supported) and checks for NULL. The code patterns and potential flaw triggers are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a race condition in the TTY subsystem leading to buffer overflow. The target code's critical section is protected by a mutex, and it deals with socket registration, not concurrent buffer writing. The synchronization patterns and data structures involved are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow in the CIFS crypto code related to scatterlist and VMAP stack. The target code does not involve cryptographic operations, scatterlists, or stack memory issues. The functional domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a NULL pointer dereference in a USB serial driver due to missing endpoint validation. The target code does not parse complex device descriptors or have similar validation patterns. It is a protocol handling function for a netlink socket family.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is a race condition leading to a NULL pointer dereference in the keyring subsystem during user keyring installation. The relevance is higher than other cases because both involve kernel resource registration/initialization (keyrings vs. PF_KEY satypes). The target code's non-atomic check-and-set of `pfk->registered` outside the mutex (`if (pfk->registered&(1<<hdr->sadb_msg_satype))`) mirrors the pattern of a TOCTOU race, similar to the flawed check-then-act sequence in the keyring case. However, the consequences (duplicate registration vs. NULL dereference) and subsystems differ.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is an unbounded/overflowing memory allocation in USB/IP. The target code has one memory allocation via `compose_sadb_supported()`, but its size is not directly derived from user-controlled inputs like the USB/IP case. The `compose_sadb_supported` function's internal logic would need analysis to rule out similar issues, but superficially, the pattern of allocating a response SKB is common and not inherently vulnerable.",
        "case_metadata": {
          "cve_id": "CVE-2017-16913"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in a user-space network protocol parser (tcpdump). The target code is a kernel subsystem registration function that does not parse intricate network TLVs or have length-field validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      }
    ]
  },
  "CVE-2021-3489_before_exclude_100:356876e0:vulspec": {
    "timestamp": "2026-01-17T02:00:06.861368",
    "cve_id": "CVE-2021-3489",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "356876e0",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code performs arithmetic (new_prod_pos = prod_pos + len) and checks for overflow against a mask, which is a form of bounds checking. Both deal with size calculations and bounds, but the context (ring buffer vs. network file transfer), vulnerability type (properly checked arithmetic vs. unchecked overflow), and attack surface are very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow due to insufficient validation of iovec lengths in a FUSE ioctl handler. The target code also performs length validation (size check against RINGBUF_MAX_RECORD_SZ and space check using mask). Both involve ensuring data fits within a buffer, but the mechanisms (ring buffer producer/consumer positions vs. iovec summation) and the root cause (lack of validation vs. proper validation in target) differ significantly. The synchronization pattern (spinlocks, memory barriers) in the target is not present in the case.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a double-free in a userspace library handling file content. The target code is a kernel ring buffer allocation function with no dynamic memory deallocation. The functionality, memory management model (static ring buffer vs. heap allocation), and vulnerability class are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a NULL pointer dereference in a USB/IP driver due to insufficient validation of URB fields. The target code validates input size and ring buffer space, and all pointer arithmetic is based on the `rb` structure which is assumed valid. Both are in the kernel, but the domain (synchronization primitives and lock-free ring buffer vs. USB request processing) and flaw type are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a buffer overflow in a network daemon due to a negative length value. The target code uses unsigned integers (u64, u32) for sizes and positions, preventing negative values, and includes a bounds check (`new_prod_pos - cons_pos > rb->mask`). Both involve preventing buffer overflows through length checks, but the vulnerability trigger (signedness error vs. unsigned wrap-around check) and context are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code performs writes to a ring buffer header and data section, with careful bounds checking. There is no string processing or character-based parsing in the target code. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 is a use-after-free in the kernel networking subsystem due to improper handling of sk_buff fragments during segmentation. The target code manages a ring buffer using producer/consumer positions and spinlocks for synchronization. Both are in the Linux kernel and involve careful state management of shared data structures to prevent corruption. While the specific vulnerability type differs (UAF vs. potential for race conditions or incorrect bounds in the target), both require correct synchronization and lifecycle management. The target's use of `smp_load_acquire`/`smp_store_release` and spinlocks shows a similar concern for concurrency and memory ordering.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 8 is a race condition leading to a NULL pointer dereference in the kernel keyring subsystem during initialization. The target code uses spinlocks (`spin_lock_irqsave`) to protect the critical section where `prod_pos` and `cons_pos` are read/updated, and uses memory barriers (`smp_load_acquire`, `smp_store_release`) for lock-free synchronization on the positions. Both are kernel code addressing concurrency issues. The target code appears to correctly use locking, but the pattern of checking state (like space availability) after acquiring a lock is a common anti-pattern for TOCTOU races if not done carefully. The relevance is in the shared concern for proper synchronization in shared data structures.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 9 is a race condition in the F2FS filesystem due to non-atomic check-and-use operations in free node ID management. The target code performs a check for available space (`new_prod_pos - cons_pos > rb->mask`) *inside* a spinlock-protected critical section. This is the correct pattern to avoid the TOCTOU race present in Case 9. Both involve kernel resource management (ring buffer slots vs. filesystem node IDs) and the critical importance of atomic state checks and updates. The target code serves as a positive example of how to avoid the vulnerability pattern described in Case 9.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a NULL pointer dereference in a USB driver due to missing validation of endpoint descriptors. The target code does not dereference any potentially NULL pointers from external inputs; it operates on the `rb` structure and its `data` member. Both are kernel drivers, but the flaw type and the code's defensive posture (target has size validation and bounds checking) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      }
    ]
  },
  "CVE-2021-3489_after_exclude_100:e54de199:vulspec": {
    "timestamp": "2026-01-17T02:00:10.147309",
    "cve_id": "CVE-2021-3489",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e54de199",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code performs arithmetic (new_prod_pos = prod_pos + len) and checks for overflow (new_prod_pos - cons_pos > rb->mask), which is a similar defensive pattern. However, the context (ring buffer vs. network file transfer) and the specific vulnerability chain (integer overflow/wraparound) are only superficially similar. The target code's validation appears robust against the specific overflow that caused CVE-2018-20750.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a buffer overflow in a FUSE ioctl handler due to insufficient validation of iovec lengths. The target code manages a ring buffer with explicit bounds checking (new_prod_pos - cons_pos > rb->mask) and uses masking for wrapping (prod_pos & rb->mask). The core flaw types (buffer overflow vs. ring buffer management) and attack surfaces (malicious userspace server vs. kernel internal or BPF program data) are fundamentally different. The synchronization pattern (spinlocks) is a minor similarity but not relevant to the vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a double-free in a userspace library handling disk images. The target code is a kernel ring buffer allocation function with no dynamic memory deallocation. The functional domains (memory allocator vs. file content processor) and vulnerability class (memory corruption on free vs. reservation logic) are completely dissimilar. No meaningful reference value for the target code's safety evaluation.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a NULL pointer dereference in a USB/IP driver due to insufficient validation of URB fields. The target code does dereference pointers (e.g., `hdr`), but they are derived from `rb->data` and an offset calculation that is bounded by the ring buffer size and mask. The code pattern and validation context (network protocol structure vs. internal kernel data structure) are not similar. The potential for a NULL `rb->data` is not shown in this snippet and is a different class of flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves a buffer overflow due to a negative length value in a network protocol parser. The target code uses unsigned integers (`u64 size`, `u32 len`, `unsigned long` positions) and validates that `size` is not too large and that `len` does not exceed `rb->mask + 1`. This guards against the negative integer issue present in CVE-2011-3601. The similarity is in the defensive integer/bounds checking pattern, but the vulnerability root cause (signedness error) is not applicable to the target's unsigned types.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code performs pointer arithmetic and writes to memory (`hdr->len = ...`). The contexts (string parsing vs. ring buffer bookkeeping) and vulnerability patterns (buffer over-read vs. potential buffer over-write) are distinct. The target code's calculations are based on sizes and masks, not on parsing untrusted string data with embedded terminators.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is a use-after-free in the kernel networking stack due to improper orphan handling of sk_buff fragments. The target code manages concurrent access to a shared ring buffer using spinlocks and memory barriers (`smp_load_acquire`, `smp_store_release`). The relevance lies in the shared theme of concurrent access to shared kernel data structures and the need for proper synchronization to prevent corruption. However, the specific vulnerability mechanism (UAF vs. logic error/corruption) is different.",
        "case_metadata": {
          "cve_id": "CVE-2014-0131"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 8 is a race condition leading to a NULL pointer dereference during keyring initialization. The target code uses spinlocks (`spin_lock_irqsave`) to protect the critical section where `prod_pos` and `cons_pos` are read and `producer_pos` is updated. This is a direct defense against the type of concurrency issue seen in CVE-2013-1792. The synchronization pattern is highly relevant. The difference is that the target's race would likely cause data corruption or miscalculation rather than a NULL dereference, but the core concurrency concern is similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 9 is a race condition in F2FS nid management due to non-atomic check-and-use operations. The target code explicitly uses a spinlock to make the sequence of checking space (`new_prod_pos - cons_pos > rb->mask`) and updating state (`smp_store_release(&rb->producer_pos, new_prod_pos)`) atomic. This is precisely the defense against the type of flaw in CVE-2017-18249. The code patterns (lock, check, update) and the domain (kernel subsystem managing allocatable resources) are very similar, providing valuable reference for correct concurrency design.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a NULL pointer dereference in a USB driver due to missing validation of hardware descriptors. The target code performs validation on sizes and positions but does not appear to have a similar pattern of dereferencing a structure pointer that could be NULL from an external source. The attack surface (malicious hardware vs. BPF program input) and code context (device driver probe vs. memory allocator) are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-3137"
        }
      }
    ]
  },
  "CVE-2021-37847_before_exclude_100:b09ab173:vulspec": {
    "timestamp": "2026-01-17T02:01:50.601177",
    "cve_id": "CVE-2021-37847",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b09ab173",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a simple digest verification function performing a memory comparison. The vulnerability types (CWE-125 vs. potential timing side-channel or incorrect length handling), domains, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a buffer overflow in a kernel FUSE ioctl handler due to insufficient iovec length validation. The target code performs a fixed-length memory comparison and allocation. While both involve memory operations, the flaw nature (complex validation logic vs. simple comparison), context (kernel vs. likely userspace library), and attack surfaces are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves an out-of-bounds write due to integer overflow in memory allocation. The target code uses `xmalloc(len)` where `len` is derived from `digest_length(d)`. If `digest_length` can return an unexpected large or negative value (e.g., from an uninitialized or corrupted digest context), it could cause an integer wraparound or excessive allocation, leading to heap corruption. However, the code pattern (direct allocation vs. complex calculation) and typical context differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a use-after-free due to uninitialized pointers and inconsistent state management. The target code has a simple allocate-use-free pattern. A potential, though tenuous, link exists if `digest_final` fails (`ret != 0`) and somehow corrupts or frees `d`, making subsequent operations on `d` unsafe. However, this is speculative and not a direct pattern match.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code uses a pre-determined `len` for `memcmp`. Unless `len` is incorrect (e.g., larger than the actual allocated size of `md` or the output of `digest_final`), it's not a direct match. The domains and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a double-free due to violation of memory ownership semantics during error handling. The target code has a straightforward free-on-exit pattern. A potential similarity lies in the error path: if `digest_final` fails and somehow frees `tmp` internally, then the explicit `free(tmp)` at `end:` would cause a double-free. This requires a flawed implementation of `digest_final`, making it an indirect reference.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 involves an integer overflow leading to an out-of-bounds write during domain name parsing. As with Case 3, relevance hinges on `digest_length(d)` returning a problematic value that causes `xmalloc` to allocate a buffer of incorrect size, leading to the `memcmp` over-read. The connection is indirect and based on a precondition not shown in the snippet.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 8 is a race condition in a filesystem's node ID management. The target code is a simple, synchronous function with no concurrency or shared state manipulation. The vulnerability types and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in an XML parser due to inadequate bounds checking during multi-byte character processing. The target code uses `memcmp` with a fixed length. The domains (parsing vs. cryptography) and the nature of the bounds check flaw are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in an XML end-tag parser. Similar to Case 9, it involves complex parsing logic and state, which is absent in the straightforward, linear target code. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2021-37847_after_exclude_100:64568640:vulspec": {
    "timestamp": "2026-01-17T02:01:55.888435",
    "cve_id": "CVE-2021-37847",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "64568640",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code performs a cryptographic memory comparison and has no regex parsing, character class processing, or similar logic. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a buffer overflow in a kernel FUSE ioctl handler due to insufficient validation of iovec lengths. The target code is a simple digest verification function that uses fixed-length buffers based on a digest length. There is no complex input validation, iovec structures, or kernel-specific patterns.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves an out-of-bounds write due to integer overflow in a memory allocation calculation. The target code uses `xmalloc` with a fixed `len`, but there is no arithmetic on `len` that could overflow before allocation. The core flaw (integer overflow leading to undersized allocation) is not present. Both deal with memory buffers, but the vulnerability mechanism is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a use-after-free/double-free due to uninitialized pointers and inconsistent state management during error handling. The target code has a simple error path using `goto end` and a single `free(tmp)`. It does not have complex resource management or multiple cleanup paths that could lead to double-free. However, both involve dynamic memory (`malloc/free`), making some conceptual overlap.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code does not parse any network protocol TLVs. It compares two fixed-length buffers. The code patterns and vulnerability triggers are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a double-free during error handling in a file reading function. The target code has a single error path that frees `tmp` once. However, if `digest_final` could fail after partially initializing or altering `d`, and if subsequent calls to `digest_generic_verify` use the same `d`, there might be state issues, but it's not a direct double-free pattern. The shared theme is careful error handling with allocated memory.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an integer overflow leading to an out-of-bounds write in a domain name parser. The target code uses a digest length `len` which is returned from `digest_length(d)`. If `digest_length` could return an unexpected large or negative value (e.g., from corrupted state), it could cause issues in `xmalloc` or `crypto_memneq`. This is a tenuous link, as the primary integer overflow mechanism is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a race condition in a kernel filesystem's node ID management. The target code is a simple, synchronous digest verification function with no concurrency, shared state, or lock management. The vulnerability domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in an XML parser due to inadequate bounds checking during multi-byte character processing. The target code does no parsing of structured text or character encoding. It operates on raw byte buffers of a known length. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in an XML end tag parser. Similar to Case 9, the target code's functionality and code patterns are entirely unrelated to parsing structured markup languages and checking tag boundaries.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2022-3103_before_exclude_100:dc39a069:vulspec": {
    "timestamp": "2026-01-17T02:02:39.570742",
    "cve_id": "CVE-2022-3103",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "dc39a069",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a user-space network protocol library. The target code is a kernel function performing bounds checking and array index sanitization. The domain (kernel vs. user-space library), vulnerability type (OOB write vs. potential use-after-free/race), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 2 is a race condition (CWE-362) in the Linux kernel F2FS subsystem. The target code is also in the Linux kernel (io_uring) and involves concurrency-sensitive operations (file slot access). While the specific flaw (non-atomic check-and-use) differs, the broader context of kernel concurrency bugs and the need for careful synchronization provides some reference value for analyzing potential race windows in `__io_sync_cancel` or its callers.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a buffer overflow in the FUSE subsystem due to insufficient iovec length validation. The target code performs bounds checking (`fd > ctx->nr_user_files`) and uses `array_index_nospec` for sanitization. Both are in the kernel and involve user-provided index validation, but the vulnerability mechanism (buffer overflow vs. potential use-after-free/TOCTOU) and subsystem are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in Perl's regex engine due to improper NUL byte handling. This is a user-space application vulnerability unrelated to kernel memory safety, concurrency, or file descriptor management. No meaningful similarity in code patterns or vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow in a user-space network daemon (radvd) due to negative integer handling. The target code is a kernel function using `array_index_nospec` to prevent speculative execution attacks and bounds checking. The domains and vulnerability patterns (network protocol parsing vs. kernel file table access) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 6 is a race condition (CWE-362) in the Linux kernel keyring subsystem leading to a NULL pointer dereference. This is highly relevant as both are in the kernel and involve managing shared resources (keyring pointers vs. file table slots) accessed by multiple threads. The pattern of checking a resource (`cd->file`) after a bounds check, potentially in a concurrent context where `ctx->nr_user_files` or the file table could change, shares conceptual similarity with race condition vulnerabilities. The scoring is elevated due to the shared kernel environment and concurrency concerns.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a double-free in a user-space library (libguestfs) related to error handling and memory ownership. The target code shows no dynamic memory allocation or free operations. The vulnerability class and domain are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is a race condition (CWE-362) in the Linux kernel TTY subsystem leading to buffer overflow. Similar to Case 2 and 6, this shares the broader context of kernel concurrency bugs. The target code's operation on shared kernel data structures (file table) without explicit locking shown in the snippet suggests potential for race conditions if proper synchronization isn't enforced elsewhere, making this a relevant reference category.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is a buffer access issue in the kernel CIFS subsystem related to scatterlist and VMAP_STACK. While both are in the kernel, the vulnerability stems from a specific hardware/crypto interaction. The target code's primary concern is index validation and speculative execution hardening, not physical memory contiguity. Limited similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 10 is a use-after-free (CWE-416) due to a race condition and improper locking in the kernel memory policy subsystem. This is highly relevant to the target code. The target code dereferences `ctx` and accesses `ctx->nr_user_files` and `ctx->file_table` after initial pointer acquisition. If the `io_ring_ctx` object (`ctx`) could be freed concurrently (e.g., after the last reference is dropped in another thread) between the start of the function and the accesses, a use-after-free scenario akin to CVE-2018-10675 could occur. The pattern of accessing shared kernel object fields without clear lifetime guarantees is similar. The relevance is strong, though not a perfect match, as the specific locking scheme isn't visible in the snippet.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      }
    ]
  },
  "CVE-2022-3103_after_exclude_100:8835f192:vulspec": {
    "timestamp": "2026-01-17T02:02:55.885250",
    "cve_id": "CVE-2022-3103",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8835f192",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a user-space network protocol library. The target code is kernel-space, performs bounds checking with array_index_nospec, and deals with file descriptor validation, not memory allocation based on untrusted sizes.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a race condition in a filesystem's node ID management. The target code shows no evidence of concurrent access handling (no locking shown) and its primary concern is validating a file descriptor index. The core flaw patterns (race vs. bounds check) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a buffer overflow in FUSE ioctl handling due to insufficient iovec length validation. The target code performs an array bounds check and uses a mitigation primitive (array_index_nospec). The context (io_uring cancel vs. FUSE ioctl) and vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in a user-space regex compiler due to improper NUL byte handling. The target code is kernel-space, performs a bounds check to prevent an out-of-bounds access, and operates in a completely different domain (asynchronous I/O cancellation).",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow in a network daemon parser due to a negative length value. The target code guards against a negative `fd` implicitly via the `unlikely(fd >= ctx->nr_user_files)` check and uses `array_index_nospec`. The domains and specific flaw triggers are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a race condition leading to a NULL pointer dereference during keyring initialization. The target code fetches a pointer (`cd->file`) that could be NULL, which it checks. While both involve pointer validation, the core issue in Case 6 (concurrent initialization race) is not visible in the provided static code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a double-free in a user-space library's error path. The target code shows no dynamic memory allocation or freeing logic. The functional domains and defect classes are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a race condition in the TTY subsystem leading to buffer overflow. The target code snippet shows no concurrency primitives or buffer manipulation. The only tangential similarity is that both are in the Linux kernel and involve validation of inputs (fd vs. buffer state).",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a buffer access issue related to scatterlist and VMAP_STACK in a crypto module. The target code performs simple array indexing and pointer assignment. The vulnerability mechanisms (contiguous memory assumption) and subsystems are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a use-after-free due to a race condition and improper locking in memory policy. The target code does not show resource (like `cd->file`) acquisition or locking logic that would be susceptible to a similar race-after-free. The similarity is limited to both being in the kernel and involving resource validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      }
    ]
  },
  "CVE-2016-10317_before_exclude_100:579c64f7:vulspec": {
    "timestamp": "2026-01-17T02:03:46.733738",
    "cve_id": "CVE-2016-10317",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "579c64f7",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve memory buffer operations in a processing library (image/JPEG 2000 vs. unspecified). The core flaw in CVE-2017-14151 is a heap buffer overflow due to insufficient padding allocation, which is a different pattern from the target code's potential for out-of-bounds writes via incorrect pointer arithmetic or size calculations. The functional domains are similar, but the specific vulnerability mechanism differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve CWE-119 (Buffer Overflow) due to incorrect bounds checking during a copy operation (memcpy). The flaw in CVE-2014-9652 is an off-by-one/overflow in length validation for Pascal strings, similar to the risk in the target code if parameters like `left_width`, `src_width`, or `right_width` are incorrectly calculated or validated, leading to an out-of-bounds read/write. The pattern of copying based on externally influenced sizes is analogous.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-6823 involves an integer overflow (CWE-190) leading to an out-of-bounds write. The target code performs memcpy operations with sizes that are passed as arguments. If those sizes (e.g., `left_width`, `src_width`, `right_width`) are the result of an integer overflow elsewhere, the consequence could be similar. However, the target code itself does not show the arithmetic that could cause the overflow; the relevance is indirect.",
        "case_metadata": {
          "cve_id": "CVE-2016-6823"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve CWE-119 buffer overflows in functions that process data. CVE-2016-7837 is a stack-based buffer overflow in a parsing function. The target code's `fill_threshhold_buffer` is also a data processing function that performs sequential memory copies. If the `dest_strip` buffer is stack-allocated and the total copy size exceeds its allocation, a similar stack overflow could occur. The pattern of uncontrolled copying into a fixed buffer is comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-7970 is a buffer overflow in a subtitle rendering library during blur coefficient calculations. The target code is a straightforward buffer filling routine using memcpy. The vulnerability mechanisms (complex mathematical array index violation vs. linear buffer copying) and domains (graphics effects vs. generic buffer manipulation) are substantially different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are in the domain of image/data processing and involve CWE-119 heap buffer overflows. CVE-2016-10050 occurs due to insufficient bounds checking when calculating pixel offsets during RLE decoding. The target code's vulnerability would similarly stem from insufficient validation of the input parameters (`left_width`, `src_width`, `num_tiles`, `right_width`) against the actual sizes of the source and destination buffers, leading to an overflow during memcpy.",
        "case_metadata": {
          "cve_id": "CVE-2016-10050"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) in a regex compiler due to improper NUL byte handling. The target code performs writes (memcpy) and its primary risk is out-of-bounds write, not read. The code patterns (string parsing/compilation vs. block memory copying) and vulnerability classes are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free (CWE-416) vulnerability in a network daemon related to pointer management and error handling. The target code contains no dynamic memory allocation or pointer lifecycle management; it only operates on provided buffers. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. CVE-2016-8670 is a buffer overflow (CWE-119) in an image processing library (PHP's GD) due to incorrect bounds checking where an arithmetic underflow leads to a negative value being treated incorrectly. The target code's vulnerability hinges entirely on whether the size parameters passed to memcpy are correctly validated. If `left_width`, `src_width`, or `right_width` are negative or cause the total copy size to exceed the destination buffer, a nearly identical buffer overflow occurs. The pattern of unsafe memcpy use with unchecked sizes is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-25034 involves an integer overflow (CWE-190) during domain name length calculation leading to a buffer overflow. The relevance to the target code is indirect: if the sizes passed to `fill_threshhold_buffer` are the result of an integer overflow elsewhere, the memcpy operations could overflow. However, the target code itself does not perform the arithmetic that could overflow; it merely uses the sizes. The primary similarity is the end result (CWE-119 buffer overflow).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2016-10317_after_exclude_100:43c160f8:vulspec": {
    "timestamp": "2026-01-17T02:04:02.344409",
    "cve_id": "CVE-2016-10317",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "43c160f8",
    "scores": [
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve memory buffer operations (memcpy) in a data processing context (image/compression). The core vulnerability type (CWE-119) is the same. However, the trigger in the target code is more about incorrect size calculations for tiled data copying, while CVE-2017-14151 is about insufficient padding allocation for compressed data buffers. The pattern is similar but not identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Both involve CWE-119 (buffer overflow) due to incorrect bounds checking during a copy operation (memcpy vs. Pascal string copy). The key flaw in Case 2 is an off-by-one or miscalculation in length validation (`len >= sizeof(p->s)`). The target code's vulnerability potential lies in miscalculating `left_offset`, `left_width`, `num_tiles`, or `right_width` relative to `src_width` and `dest_strip` buffer size, leading to similar out-of-bounds reads/writes.",
        "case_metadata": {
          "cve_id": "CVE-2014-9652"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in image/data processing domains. The primary CWE for Case 3 is CWE-190 (Integer Overflow) leading to CWE-787. The target code uses `int` parameters but does not show explicit multiplication or addition that could overflow before being used in memcpy. The relevance is limited to the broader category of input validation failures in media processing.",
        "case_metadata": {
          "cve_id": "CVE-2016-6823"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve CWE-119 buffer overflows via direct memory copy operations (memcpy) using user/input-controlled parameters. Case 4 is a stack-based overflow from parsing untrusted input. The target code's memcpy operations are directly analogous, and a flaw would similarly arise from insufficient validation of the size/offset parameters against the actual source and destination buffer bounds.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve CWE-119, but the context and trigger are different. Case 5 is about mathematical calculations leading to array index violations. The target code's potential flaw is a straightforward buffer size miscalculation for linear memory copies, not an index calculation within a multi-dimensional or complex data structure.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. High relevance in domain (image data decoding/processing) and vulnerability type (CWE-119 heap buffer overflow). Case 6's flaw is insufficient bounds checking when calculating pixel offsets during decoding. The target code performs similar bounds-critical operations: calculating source pointers (`src_strip + left_offset`) and copy lengths (`left_width`, `src_width`, `right_width`). A miscalculation in any parameter could lead to an identical heap buffer overflow.",
        "case_metadata": {
          "cve_id": "CVE-2016-10050"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is CWE-125 (Out-of-bounds Read) in a regex parsing engine due to improper NUL byte handling. The target code performs raw memory copies and is not parsing complex syntax or dealing with string termination issues. The code patterns and vulnerability triggers are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is CWE-416 (Use After Free) in a network daemon related to pointer management. The target code performs simple, deterministic memory copies with no dynamic allocation, deallocation, or pointer aliasing shown. The vulnerability classes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are in image/data processing contexts. The CWE is identical (CWE-119). The key flaw in Case 9 is incorrect bounds checking due to arithmetic underflow (`remain == 0`). The target code is highly susceptible to a similar flaw: if `left_offset`, `left_width`, `num_tiles`, or `right_width` are derived from untrusted input and not properly validated, integer overflows/underflows in their calculations could lead to incorrect memcpy sizes or offsets, causing a buffer overflow. The code pattern of sequential memcpy operations based on calculated parameters is very similar to buffer handling in image libraries.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10's primary CWE is CWE-190 (Integer Overflow) leading to CWE-787, which is relevant to the target code if its `int` parameters are computed from untrusted data. However, the domain (DNS parsing vs. image/data strip processing) and specific code patterns are different. The connection is the general principle of integer overflow in size calculations preceding memory operations.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2021-29556_before_exclude_100:b2607ab7:vulspec": {
    "timestamp": "2026-01-17T02:04:15.807291",
    "cve_id": "CVE-2021-29556",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b2607ab7",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a tensor manipulation function with input validation and a switch-case dispatch. CVE-2015-7511 is a side-channel vulnerability in a cryptographic library. The domain (cryptography vs. tensor ops), vulnerability type (information exposure vs. potential logic/bounds issues), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control flaw in a database query planner. The target code performs numerical tensor operations with basic dimension checks. There is no similarity in functionality, vulnerability type (access control vs. potential memory/validation flaws), or attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The primary connection is that both involve input parsing/validation (dims tensor vs. DNS tokens). CVE-2019-25035 is an out-of-bounds write due to incorrect parenthesis counting. The target code validates tensor dimensions and rank but does not show complex parsing logic. The potential vulnerability pattern (insufficient validation leading to OOB access) is a generic similarity, but the specific mechanisms and domains differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-14152 is a use-after-free in an image codec due to inconsistent state management. The target code allocates an output tensor and performs an operation, with no apparent dynamic memory management or state tracking that could lead to a UAF. The code patterns and flaw types are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-25040 is an infinite loop in DNS name decompression. The target code has a simple switch statement and no loops that process untrusted data in a recursive or iterative manner. The vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The connection is the potential for state mismatch or invalid operations. CVE-2016-10218 is a NULL pointer dereference due to an unbalanced stack (push/pop). The target code validates input dimensions and dispatches to a handler. A tangential similarity exists if the `HandleReverseCase` function or the `dims.vec<bool>()` data could be in an invalid state leading to a crash, but this is not evident from the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-18120 is a double-free due to improper pointer management. The target code shows standard TensorFlow OP allocation patterns (`context->allocate_output`) with no manual memory management or global pointer manipulation, making the flaw type irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18120"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-10050 is a heap buffer overflow in an image decoder due to insufficient bounds checking during pixel offset calculation. The target code validates tensor rank and dimension counts but then dispatches to a handler (`HandleReverseCase`). The relevance lies in the pattern: input validation (dimensions) followed by operations on the data. If the validation is incomplete (e.g., the boolean vector `dims` contents are not checked for consistency with the actual tensor shape in each dimension), the handler could perform out-of-bounds memory accesses. This is a common pattern where high-level validation passes but low-level invariants are violated.",
        "case_metadata": {
          "cve_id": "CVE-2016-10050"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a cryptographic algorithm failure leading to a NULL pointer dereference. The target code performs no cryptography, has no complex error cleanup paths visible, and the flaw chain is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-18313 is an out-of-bounds read due to improper handling of NUL bytes in a string parser. The target code works with tensor dimensions and a boolean vector. A vague similarity exists in processing user-controlled input (`dims` tensor), but the data types (structured tensor vs. string), parsing mechanisms, and specific flaw (OOB read vs. potential OOB write or logic error) are different. The target code's vulnerability would more likely stem from incorrect indexing logic, not string parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      }
    ]
  },
  "CVE-2021-29556_after_exclude_100:be9c9fc3:vulspec": {
    "timestamp": "2026-01-17T02:04:21.695077",
    "cve_id": "CVE-2021-29556",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "be9c9fc3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a tensor manipulation function in a machine learning framework (likely TensorFlow), performing dimension validation and reverse operations. Case 1 is a cryptographic side-channel vulnerability (CWE-200/385) in libgcrypt. The domains (ML vs. crypto), vulnerability types (logic/validation vs. timing attack), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an improper access control vulnerability (CWE-284) in PostgreSQL's query planner. The target code performs input validation and tensor shape operations with no privilege checks or database context. The functional domains and flaw nature are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an out-of-bounds write (CWE-787) in a DNS parser due to improper input validation of nested structures. The target code also validates input (dimensions, shape) but operates on well-structured tensor metadata, not parsing complex, attacker-controlled byte streams. The validation logic is simpler and the risk of memory corruption is lower, though both involve checking input constraints.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a use-after-free (CWE-416) in an image codec due to inconsistent state management. The target code allocates an output tensor and performs operations without complex resource lifecycle management or pointer manipulation. The memory models and error conditions are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14152"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an infinite loop (CWE-835) in DNS name decompression due to missing recursion depth tracking. The target code has simple, bounded loops (switch statement over fixed dimensions 0-8). There is no recursion or complex pointer chasing.",
        "case_metadata": {
          "cve_id": "CVE-2019-25040"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference (CWE-476) in a PDF interpreter due to stack pairing violation. The target code uses OP_REQUIRES for validation which likely aborts on error, and does not manage a push/pop stack of complex objects. The context and failure mode are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a double free (CWE-415) in a GIF parser due to improper pointer ownership management. The target code uses RAII-style tensor objects (likely) and does not perform manual memory management of raw pointers in a way that could lead to double-free.",
        "case_metadata": {
          "cve_id": "CVE-2017-18120"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a heap buffer overflow (CWE-119) in an image decoder due to insufficient bounds checking during pixel offset calculation. The target code validates tensor dimensions and uses them to allocate output, which is a form of bounds checking. However, the target's validation is on metadata (dimension counts and sizes) before allocation, while Case 8's flaw is in calculating offsets into an already-allocated buffer during decoding. The similarity is limited to the general theme of validating sizes before use.",
        "case_metadata": {
          "cve_id": "CVE-2016-10050"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 involves a cryptographic algorithm issue (CWE-327) leading to a NULL pointer dereference in a DNS server. The target code has no cryptographic functionality and its error handling (OP_REQUIRES) is structured to avoid proceeding with invalid state.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read (CWE-125) in a regex compiler due to improper NUL byte handling. The target code processes tensor shapes, not string patterns, and does not parse raw byte data where embedded NULs would be relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      }
    ]
  },
  "CVE-2022-23571_before_exclude_100:dd146535:vulspec": {
    "timestamp": "2026-01-17T02:04:42.645000",
    "cve_id": "CVE-2022-23571",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "dd146535",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing untrusted input (configuration files vs. TensorProto), but the vulnerability types differ significantly. CVE-2016-7837 is a classic stack buffer overflow from unchecked hex string parsing. The target code uses helper functions (Decode, FromProtoField) for memory allocation, which could have internal overflows, but the pattern is not identical. The primary similarity is in processing serialized data.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both deal with buffer management. CVE-2016-8860 involves missing sentinel values and buffer overreads in a network buffer library. The target code's `Helper<T>::Decode` or `FromProtoField<T>` could potentially have similar issues if they miscalculate sizes or fail to properly terminate data. However, the code pattern (using type-switching macros for decoding) and context (deserialization vs. network buffering) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7972 is about inconsistent memory tracking (allocated vs. tracked size) leading to resource exhaustion. The target code allocates a TensorBuffer (`p`) but does not show obvious inconsistency in tracking. The vulnerability class (CWE-399) is different from the potential issues in the target code (more likely CWE-119 or CWE-125). The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2018-18313 involves an out-of-bounds read due to improper NUL byte handling in string parsing. The target code processes `proto.tensor_content()` or proto fields, which are not necessarily strings. However, if the `Decode` or `FromProtoField` functions incorrectly handle the length of `content` or field data (e.g., misinterpreting embedded NULs), a similar over-read could occur. The connection is indirect.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability in cryptographic operations. The target code is a tensor deserialization routine with no cryptographic operations or secret-dependent control flow. There is essentially no reference value for vulnerability analysis here.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-19477 involves type confusion (CWE-704) where an object is incorrectly cast/interpreted. The target code uses the `CASES_WITH_DEFAULT` macro to switch on `proto.dtype()` and call type-specific functions (`Decode<T>`, `FromProtoField<T>`). If the `dtype` field in the protobuf is corrupted or maliciously crafted, it could lead to calling the wrong template specialization, causing type confusion in how the `content` buffer is interpreted, potentially leading to memory corruption. This is a plausible and relevant pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-19477"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3603 is about privilege separation failure and continuing execution with elevated privileges. The target code is a pure data deserialization function with no privilege management or process state considerations. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a NULL pointer dereference following a cryptographic algorithm failure. The target code has error checks (`dtype_error`, `p == nullptr`) that return false, avoiding a direct NULL dereference. While a missing check on `buf_->data()` in the logging call could be a problem if `buf_` was non-null but pointed to a corrupted buffer, the chain of events (crypto error -> cleanup failure) is not present. Low reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2016-5844 is an integer overflow (CWE-190) during file position calculation. The target code calculates `N = shape.num_elements()`. If `shape` is built from untrusted `proto.tensor_shape()`, an attacker could create a shape with very large dimensions, causing `N` to overflow when multiplied. This overflowed `N` is then passed to `Decode` or `FromProtoField`, likely leading to buffer under-allocation and subsequent heap overflow when filling with `N` elements' worth of data from the proto. This is a highly relevant vulnerability pattern for deserialization code.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-12858 is a double-free due to inconsistent state management on error paths. The target code has a clear error path (`if (dtype_error || p == nullptr) return false;`). However, before that, it calls `UnrefIfNonNull(buf_);` and sets `buf_ = p;`. If there is a scenario where `buf_` is already `p` (or ownership is muddled), or if an error occurs *after* `UnrefIfNonNull` but before assignment, a double-free or use-after-free could occur. The pattern of cleaning up old state before fully validating new state is similar and carries risk.",
        "case_metadata": {
          "cve_id": "CVE-2017-12858"
        }
      }
    ]
  },
  "CVE-2022-23571_after_exclude_100:df128c09:vulspec": {
    "timestamp": "2026-01-17T02:05:36.175409",
    "cve_id": "CVE-2022-23571",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "df128c09",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 is a classic stack buffer overflow (CWE-119) in a parsing function for hexadecimal strings. The target code also parses data (TensorProto), but its primary vulnerability pattern would likely involve integer overflows in shape calculations, memory corruption in Decode/FromProtoField, or type confusion via `CASES_WITH_DEFAULT`. The parsing context and data format are different, and the target code uses higher-level abstractions (TensorBuffer, Allocator).",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 2 involves buffer management issues (CWE-119) in a network data buffer library, leading to overreads. The target code manages memory for tensor data via an Allocator and TensorBuffer. While both deal with buffer allocation and data deserialization, the Tor vulnerability is more about low-level buffer chunk management and sentinel values, whereas the Tensor code's risk is more in decoding logic, shape validation, and allocator interactions. Some parallel in deserializing untrusted content.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a resource management error (CWE-399) in a text shaping library, involving inconsistent tracking of allocated vs. used memory. The target code allocates memory via `Helper<T>::Decode` or `FromProtoField<T>` but does not show similar pattern of internal size tracking mismatch. The vulnerability patterns are different: one is internal state inconsistency in a complex renderer, the other is deserialization validation and allocation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read (CWE-125) due to improper NUL byte handling in a regex parser. The target code processes `tensor_content()` or proto fields, which are binary/data buffers. While both parse structured input, the Tensor code's vulnerability would more likely stem from incorrect `num_elements()` calculation or buffer size mismatch during decode, not from string termination issues. The NUL-byte specific trigger is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a side-channel vulnerability (CWE-200/385) in a cryptographic library's elliptic curve multiplication. The target code is a tensor deserialization routine with no cryptographic operations or secret-dependent branching. The vulnerability class and context are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 is a type confusion (CWE-704) leading to memory corruption in a document decoder. The target code uses the `CASES_WITH_DEFAULT` macro which dispatches based on `proto.dtype()`. If an attacker can control `proto.dtype()` to an unexpected value or if the macro's implementation has flaws, it could lead to incorrect type handling, similar to type confusion. The pattern of switching on a data type field and calling type-specific functions is conceptually similar, though the manifestation (object vs. template dispatch) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-19477"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an input validation flaw (CWE-20) leading to unnecessary privilege execution in a daemon's privilege separation. The target code performs some validation (shape validity, dtype) but is not related to privilege management or process state. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 involves a risky cryptographic algorithm leading to a NULL pointer dereference (CWE-476) in a DNS server. The target code checks for null (`p == nullptr`) and returns false, avoiding dereference. While both have error handling paths, the cryptographic context and specific chain (unsupported algorithm -> NULL dereference) are not relevant to tensor deserialization.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is an integer overflow (CWE-190) in an archive parser during file position calculation. The target code calculates `N = shape.num_elements()` which could potentially overflow if the shape dimensions are large and maliciously crafted. This overflow could then affect buffer allocation size in `Decode` or `FromProtoField`. The pattern of parsing untrusted serialized data, computing element counts, and allocating memory is very similar. The main difference is the data format (ISO9660 vs. TensorProto).",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a double free (CWE-415) due to inconsistent buffer management in error paths in a ZIP parser. The target code has error paths (`dtype_error`, `p == nullptr`) that free/cleanup resources (via `UnrefIfNonNull`). If there are multiple ownership or cleanup issues in `Decode`/`FromProtoField` or in the `CASES_WITH_DEFAULT` macro error handling, a similar double-free or memory leak could occur. However, the code shown manages a single `buf_` pointer with explicit unreferencing, reducing immediate double-free risk. The similarity is in the pattern of error handling during complex parsing.",
        "case_metadata": {
          "cve_id": "CVE-2017-12858"
        }
      }
    ]
  },
  "CVE-2021-37642_before_exclude_100:2c3286e4:vulspec": {
    "timestamp": "2026-01-17T02:05:47.267040",
    "cve_id": "CVE-2021-37642",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2c3286e4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel timing attack in a cryptographic library (libgcrypt). The target code performs tensor scatter operations with bounds checking and has no cryptographic operations or secret-dependent branching that could leak information.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-5844 involves an integer overflow (CWE-190) during file position calculation in a parser. The target code performs integer bounds checks (N_big <= limits<Index>::max(), params->dim_size(0) <= limits<Index>::max()) to prevent overflows when converting/casting indices. The pattern of validating integer sizes before operations is similar, though the context (file parsing vs. tensor indexing) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves a broken cryptographic algorithm leading to a NULL pointer dereference in a DNS server. The target code performs tensor data manipulation with explicit error checks (OP_REQUIRES) and has no cryptographic or DNSSEC functionality.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2011-1178 is an integer overflow (CWE-190) leading to a buffer overflow in an image parser. The target code contains explicit integer overflow prevention checks (comparing N_big and params->dim_size(0) against numeric_limits<Index>::max()). The defensive coding pattern against integer overflows before memory operations is relevant, though the consequence in the target code is an out-of-bounds index access rather than a direct buffer overflow.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2019-11235 involves insufficient input validation of cryptographic scalars and points. The target code validates tensor shape relationships and index bounds (indices_flat(bad_i) is not in [0, params->dim_size(0))). The general concept of input validation is similar, but the domain (cryptographic material vs. tensor indices) and specific flaws are very different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2016-7837 is a stack buffer overflow in a Bluetooth configuration parser. The target code manipulates tensor data with bounds checking. Both involve parsing/processing input data, but the vulnerability mechanism (unbounded string copy vs. indexed tensor access with validation) and context are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2009-3909 is an integer overflow (CWE-190) in an image header parser leading to a heap overflow. Similar to case 2 and 4, the target code's checks against numeric_limits<Index>::max() are designed to prevent integer overflows/wraparound when casting or using indices. The defensive pattern is relevant, though the overflow consequence in the target code relates to index validity rather than buffer allocation size.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3603 is a privilege management issue where a daemon fails to drop privileges after an initialization error. The target code is a computational kernel function with no privilege separation or process state management.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-7970 is a buffer overflow in a subtitle rendering library caused by miscalculated array indices. The target code also deals with index validation (checking indices are within [0, params->dim_size(0))) to prevent out-of-bounds access. The high-level concern of index safety is shared, but the cause (mathematical parameter manipulation vs. direct user-provided indices) and context differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2016-8692 is a divide-by-zero vulnerability in an image codec. The target code performs arithmetic operations (e.g., num_updates / N) but ensures N > 0 before the division (in the `if (N > 0)` block). The pattern of guarding against invalid divisors is a minor similarity, but the core vulnerability (division by zero vs. index overflow/validation) is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      }
    ]
  },
  "CVE-2021-37642_after_exclude_100:29e11f55:vulspec": {
    "timestamp": "2026-01-17T02:05:54.524978",
    "cve_id": "CVE-2021-37642",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "29e11f55",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs tensor scatter operations with input validation, while CVE-2015-7511 involves cryptographic side-channel vulnerabilities in elliptic curve operations. The vulnerability types (CWE-200/385 vs. potential integer/bounds issues), domains (cryptography vs. tensor computation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve input validation and integer overflow concerns. CVE-2016-5844 is an integer overflow in file position calculation (CWE-190), while the target code performs bounds checking (N_big <= limits<Index>::max(), params->dim_size(0) <= limits<Index>::max()) to prevent similar issues. The domains differ (archive parsing vs. tensor ops), but the defensive pattern against integer overflows is similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-5745 involves cryptographic algorithm handling and NULL pointer dereference in DNS key processing, while the target code performs tensor operations with explicit error checking (OP_REQUIRES). No cryptographic operations or complex error state management present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve input validation to prevent security issues from malicious inputs. CVE-2011-1178 is an integer overflow leading to buffer overflow (CWE-190122), while the target code validates tensor dimensions and indices to prevent out-of-bounds access. The target code's checks (updates.dims() validation, N_big <= limits) serve a similar defensive purpose against malformed inputs.",
        "case_metadata": {
          "cve_id": "CVE-2011-1178"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2019-11235 involves insufficient validation of cryptographic parameters (CWE-345), while the target code validates tensor indices and dimensions. Both perform input validation, but the nature (cryptographic scalar/point validation vs. array bounds checking) and consequences (authentication bypass vs. memory corruption) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11235"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve processing external inputs with bounds checking. CVE-2016-7837 is a buffer overflow from improper input parsing (CWE-119), while the target code validates indices to prevent out-of-bounds tensor access. The target code's OP_REQUIRES checks for indices_flat(bad_i) being in [0, params->dim_size(0)) directly addresses similar bounds concerns.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve dimension validation to prevent security issues. CVE-2009-3909 is an integer overflow in image dimension calculation (CWE-190), while the target code validates tensor dimensions and performs bounds checking. The target code's explicit checks against numeric_limits<Index>::max() directly addresses integer overflow/wraparound concerns similar to the vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2011-3603 involves privilege separation failure (CWE-20/250) in a network daemon, while the target code is a tensor computation kernel with input validation. The vulnerability types, domains (privilege management vs. numerical computation), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve bounds checking during computational operations. CVE-2016-7970 is a buffer overflow in blur coefficient calculations (CWE-119), while the target code validates indices before tensor access. The target code's validation of indices against params->dim_size(0) serves a similar purpose of preventing out-of-bounds memory access during computation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-8692 involves divide-by-zero from invalid sampling factors (CWE-369), while the target code includes a division-by-zero prevention check for CPU DIV operations. Both check for dangerous arithmetic conditions, but the target code's check is specific and limited (only for CPU DIV op), while the vulnerability involves more fundamental input validation failures.",
        "case_metadata": {
          "cve_id": "CVE-2016-8692"
        }
      }
    ]
  },
  "CVE-2017-9782_before_exclude_100:5e95bef3:vulspec": {
    "timestamp": "2026-01-17T02:06:09.358184",
    "cve_id": "CVE-2017-9782",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5e95bef3",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free (CWE-416) in a network service daemon due to uninitialized pointers and inconsistent state management. The target code is an image decoder (JPEG 2000) with complex parsing and memory allocation, but its primary error handling uses `goto error` with cleanup, which is more structured. The vulnerability patterns (UAF vs. potential heap overflows/integer issues in parsing) and domains (network service vs. image parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is an Out-of-bounds Write (CWE-787) in a VNC file transfer handler due to integer overflow in allocation. The target code performs image parsing with several dynamic allocations (e.g., `jas_alloc2` for LUTs) and uses unsigned loop counters. While both involve parsing complex external data and have potential for integer issues in size calculations (e.g., `numchans * sizeof(...)`), the specific trigger (file transfer length field) and code patterns differ significantly. The target code's vulnerability surface is more about crafted image boxes leading to logic errors or overflows in palette handling.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an Out-of-bounds Read (CWE-125) in a regex compiler due to improper NUL byte handling. The target code reads a stream of structured boxes but does not involve string parsing with embedded NULs. The data structures and parsing logic (box types, lengths) are different. Both process external input, but the vulnerability mechanisms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 4 is a heap buffer overflow (CWE-119) in OpenJPEG, a JPEG 2000 codec library, specifically in code block encoding allocation. The target code is from JasPer, another JPEG 2000 decoder (`jp2_decode`). Both are in the same domain (JPEG 2000 image parsing), handle similar structures (boxes, code streams), and involve complex memory management for components, channels, and palette data. Vulnerabilities in such parsers often stem from integer overflows in allocations (e.g., `jas_alloc2`), out-of-bounds reads/writes in LUTs, or improper validation of box data (e.g., `numchans`, `cmptno`). The code patterns and attack surfaces are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an Improper Input Validation (CWE-20) leading to memory corruption in a decompression module (Quantum/CAB). The target code also decompresses/decodes image data (`jpc_decode`) and validates box fields. Both involve parsing compressed formats and have validation points (e.g., checking `cmptno` bounds). However, the specific vulnerability (sliding window boundary check) and data format are different. The relevance is limited to the general theme of input validation in decompression/decoding.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 is an Out-of-bounds Write (CWE-787) in an image file parser (XWD) due to mismatched color count and color map entries. The target code parses JPEG 2000 and handles palette data (`PCLR` box) and component mapping (`CMAP` box). Similar validation issues could arise if `numlutents` or `numchans` are not properly checked against allocated LUT sizes, leading to OOB writes in `lutents` or `lutdata`. The code patterns (color/palette handling) and vulnerability type are comparable, though the specific image format differs.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an Out-of-bounds Read (CWE-125) in a network protocol parser (LDP) due to insufficient TLV length validation. The target code parses box lengths but does so via `jp2_box_get`, which likely handles lengths internally. Both parse TLV-like structures (boxes have type and data), but the domain (network vs. image) and typical vulnerability patterns (length field attacks vs. image-specific logic errors) are different. The target code's primary risks are more in complex data relationships (e.g., CMAP, CDEF).",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 is an Integer Overflow (CWE-190) in an audio codec's codebook calculations. The target code uses several multiplications for allocations (e.g., `jas_alloc2(dec->numchans, sizeof(...))`) and could theoretically overflow if `numchans` is large. However, `numchans` is derived from box data (`cmap->data.cmap.numchans` or image components), which may be validated earlier. Both involve parsing complex binary formats where integer overflows in size calculations are a concern. The relevance is moderate as the domains differ (audio vs. image), but the vulnerability class is applicable.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an Out-of-bounds Write due to unaligned memory access in a WebSocket decoder. The target code does not perform word-sized operations on potentially unaligned network data. It uses structured parsing with box types and allocated buffers. The vulnerability mechanisms (alignment issues) and domain (network protocol vs. image parsing) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a Race Condition (CWE-362) in a filesystem's node ID management. The target code is a single-threaded image decoding function with no concurrency. The vulnerability types (race vs. memory corruption) and domains (filesystem vs. image parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2017-9782_after_exclude_100:1197ce4e:vulspec": {
    "timestamp": "2026-01-17T02:06:40.213637",
    "cve_id": "CVE-2017-9782",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1197ce4e",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves Use-After-Free due to uninitialized pointers and inconsistent state management in a network daemon. The target code is an image decoder with structured error handling using `goto error` and centralized cleanup. While both involve resource management, the vulnerability type (UAF), domain (network vs. image parsing), and code patterns (pointer lifecycle management) are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 2 involves an Out-of-bounds Write due to integer overflow in memory allocation (CWE-787/190) in a VNC file transfer. The target code performs multiple memory allocations (e.g., `jas_alloc2`) and uses unsigned integers for sizes. The pattern of allocating based on input data (like `dec->numchans`) shares similarity, but the specific trigger (integer overflow in allocation size calculation) is not directly evident in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an Out-of-bounds Read in a regex compiler due to improper NUL byte handling. The target code parses box structures from a stream but does not show similar pattern of string/character processing with embedded NULs. The domains (text parsing vs. binary image format parsing) and vulnerability mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 4 is a heap buffer overflow (CWE-119) in OpenJPEG, a JPEG 2000 codec library, specifically in memory allocation for code block encoding. The target code is from a JPEG 2000 decoder (`jp2_decode`), part of the same domain (JPEG 2000 image parsing). Both handle complex image format structures, perform memory allocations based on parsed input, and must validate relationships between different data sections (e.g., CMAP, PCLR boxes). The code patterns and attack surface (malicious image input) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves Improper Input Validation (CWE-20) leading to memory corruption in a decompression module. The target code validates box structures and relationships (e.g., CMAP with PCLR) which is a form of input validation. However, the core flaw (failing to check match operations against window boundaries in a compression algorithm) is not present in the shown image header parsing logic.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 6 is an Out-of-bounds Write due to insufficient validation of color count vs. color map entries in an image file parser (GIMP XWD plugin). The target code validates relationships between different image metadata boxes (e.g., ensuring CMAP and PCLR boxes are both present or absent, checking `cmptno` and `pcol` indices). This is a very similar pattern: parsing a complex file format and ensuring consistency between interdependent header fields to prevent out-of-bounds accesses. The domain (image parsing) is also identical.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an Out-of-bounds Read in a network protocol parser due to insufficient validation of a length field. The target code reads box structures which have types and lengths, but the shown code delegates length parsing to `jp2_box_get`. While the high-level concept of parsing TLV-like structures is similar, the vulnerability specifics (missing RFC check, direct length field misuse) and domain (network packets vs. image files) differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 involves an Integer Overflow (CWE-190) in an audio codec's mathematical computations. The target code uses unsigned integers for counts (e.g., `numchans`, `numlutents`) and performs arithmetic for memory allocation (`jas_alloc2`). While no obvious overflow is shown, the pattern of using input-controlled integers for allocation size is a shared risk factor. The domains (audio vs. image codecs) are related in terms of being complex parsers.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an Out-of-bounds Write due to unaligned memory access in a WebSocket decoder. The target code performs aligned memory operations on structured data. There is no evidence of low-level byte manipulation or assumptions about alignment. The vulnerability type and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a Race Condition (CWE-362) in a kernel filesystem's node ID management. The target code is a single-threaded image decoding function with no concurrency mechanisms. The vulnerability class and execution context are completely different, offering no reference value for the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2022-0518_before_exclude_100:9adee18e:vulspec": {
    "timestamp": "2026-01-17T02:07:40.233959",
    "cve_id": "CVE-2022-0518",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9adee18e",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free (CWE-416) in a network daemon's state management. The target code is a Java class file parser performing structured data reading with bounds checks and error handling. The vulnerability type, domain (parsing vs. network protocol), and memory management patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves an out-of-bounds write (CWE-787) due to integer overflow (CWE-190) in a parser (VNC file transfer). The target code also parses structured data (Java class attributes) and performs bounds checking (`if (offset + 8 > sz) { break; }`). The pattern of reading multiple fields from a buffer with a moving offset is similar. However, the target code uses explicit size checks on each iteration, making integer overflow less likely, and the vulnerability class (OOB write vs. potential OOB read/info leak) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves an out-of-bounds read (CWE-125) in a parser (Perl regex) due to improper NUL byte handling. The target code parses binary data with explicit size checks, making OOB reads less likely. The connection is the general theme of parsing untrusted input, but the specific vulnerability mechanism and data format (textual regex vs. binary Java class) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves a buffer overflow (CWE-119) due to insufficient allocation in an image codec. The target code reads data into pre-allocated structures but does not perform dynamic allocations based on untrusted input sizes in the same way. The relevance is limited to the broad category of parsing untrusted binary data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 involves a Double Free (CWE-415) in a file parser (ClamAV VBA). The target code uses `R_NEW0` for allocation and `r_list_newf` with a free function for cleanup. While there is memory management, the code pattern shows careful cleanup on error (`free(icattr); break;`) and no obvious double-free or use-after-free pattern in the shown path. The domains and flaw patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves buffer management issues (CWE-119) in a network library, focusing on missing sentinel values. The target code manages buffers and offsets but does not involve string sentinels. The similarity is in the careful management of buffer sizes and offsets to prevent OOB access, which is a common theme in safe parsing.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 involves an out-of-bounds read (CWE-125) in a parser (libxml2) due to insufficient bounds checking. The target code is also a parser (Java class files) and includes a key bounds check (`if (offset + 8 > sz)`). This is a direct parallel: both parse structured formats and must validate that reads stay within the input buffer. The vulnerability class (OOB read) is relevant, though the target code's check appears robust for the shown fields.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 involves an out-of-bounds read (CWE-125) in a network protocol parser (tcpdump LDP) due to insufficient validation of a length field. The target code validates a count (`number_of_classes`) and then, in a loop, checks `offset + 8 > sz` before reading fixed-size entries. This is a similar pattern: validate a count, then in a loop, ensure enough data remains for each entry. The target code's check is more granular (per-entry) which is safer.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 involves improper input validation (CWE-20) leading to out-of-bounds write in a decompression module. The target code performs input validation (size checks) but does not involve complex decompression algorithms or sliding window buffers. The connection is the need to validate offsets against total size, which the target code does.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 10 involves an integer overflow (CWE-190) leading to an out-of-bounds write in a DNS name parser. The target code performs arithmetic (`offset + 8 > sz`) to check for buffer boundaries. If `offset` were attacker-controlled and near the maximum value of its type (`ut64`), the addition could overflow, making the check pass incorrectly. This is a classic integer overflow pattern in parsers. While the target code's `offset` is derived from parsing, not directly from an untrusted field, the pattern of additive bounds checking is a shared risk point.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2022-0518_after_exclude_100:7b2d032b:vulspec": {
    "timestamp": "2026-01-17T02:08:05.861181",
    "cve_id": "CVE-2022-0518",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7b2d032b",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 (CWE-416 Use After Free) involves complex state management and double-free scenarios. The target code has simple memory allocation (R_NEW0) and frees the structure on a specific error path (`free(icattr); break;`), but does not exhibit the intricate error handling or pointer invalidation patterns typical of use-after-free vulnerabilities. The primary flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 (CWE-787 Out-of-bounds Write via Integer Overflow) involves improper validation of size calculations leading to heap corruption. The target code performs bounds checks (`buf_offset + offset + 8 > sz`) to prevent over-reads, but the pattern of validating data from an untrusted source (buffer) before allocation/use is conceptually similar. However, the target code does not perform dynamic allocations based on the parsed data, reducing the direct parallel.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 (CWE-125 Out-of-bounds Read) involves reading past buffer boundaries due to improper handling of input (NUL bytes). The target code explicitly checks buffer boundaries (`buf_offset + offset + 8 > sz`) in a loop to prevent over-reads when parsing `inner_classes_attr` entries. This is a defensive pattern against the same class of vulnerability. The similarity lies in parsing untrusted structured data with length fields.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 (CWE-119 Buffer Overflow due to insufficient allocation) involves a miscalculation of required buffer size. The target code does not perform complex buffer size calculations. Its allocations are for fixed-size structures (RBinJavaClassesAttribute). The only potential similarity is the manipulation of an `offset` variable, but it's checked against the input size `sz`.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 (CWE-415 Double Free) involves inconsistent freeing of memory during error handling. The target code has a single error path where it frees a newly allocated `icattr` before breaking. This is a clean-up, not a double-free. The `r_list_newf` with `r_bin_java_inner_classes_attr_entry_free` as a free function suggests list-managed memory, but the pattern is not similar to the complex error state leading to a double free in the case.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 (CWE-119 Buffer Management) involves improper buffer handling leading to overreads. The target code's core function is parsing a serialized data structure from a buffer, which is analogous to Tor's buffer handling. The explicit size checks (`buf_offset + offset + 8 > sz`) are defenses against the same root cause. The relevance is in the domain of safely parsing untrusted binary data.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 (CWE-125 Out-of-bounds Read in a Parser) is highly relevant in context. Both involve parsers (XML vs. Java class attributes) reading structured data from an input buffer. The target code's loop with bounds checking is a direct countermeasure to the flaw present in libxml2. The pattern of parsing a count (`number_of_classes`) then iterating is a classic source of this vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 8 (CWE-125 Out-of-bounds Read in a Protocol Parser) is very similar. Both target code and case involve parsing a binary protocol/format (Java class file vs. LDP packet) with TLV-like structures (inner class entries). The vulnerability stems from trusting a length/count field from the input without proper bounds checking. The target code's checks defend against this exact flaw, making the case a valuable reference for what could go wrong.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 (CWE-20 Improper Input Validation leading to buffer writes in a decompressor) involves complex stateful decompression logic with a sliding window. The target code performs simple parsing of static fields. The attack surfaces (complex compressed data vs. structured class metadata) and the mechanisms for corruption are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 10 (CWE-190 Integer Overflow leading to OOB write) involves an integer overflow in a length calculation during parsing. The target code uses `R_BIN_JAVA_USHORT` to read 16-bit counts and offsets, which are less prone to overflow than the 32-bit arithmetic in the Unbound case. However, the pattern of reading a field from an untrusted buffer and using it in arithmetic (`buf_offset + offset + 8`) is conceptually similar and must be validated carefully, as done in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      }
    ]
  },
  "CVE-2021-37682_before_exclude_100:83f167f4:vulspec": {
    "timestamp": "2026-01-17T02:08:12.311169",
    "cve_id": "CVE-2021-37682",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "83f167f4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a TensorFlow Lite SVDF operator preparation function focused on tensor dimension validation and memory allocation. The domains (regex parsing vs. neural network inference), vulnerability types (CWE-125 vs. potential integer overflows or allocation errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-7511 is a side-channel vulnerability (CWE-200/385) in a cryptographic library's elliptic curve multiplication. The target code performs tensor shape validation and resource preparation for a machine learning operation. There is no cryptographic logic, secret-dependent branching, or timing-sensitive operations in the target code. The functional domains and flaw nature are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-10128 is an access control vulnerability (CWE-284) in a database query planner. The target code is a low-level tensor operator with no privilege checks, user authentication, or database concepts. The code patterns involve tensor dimension arithmetic and memory allocation, not SQL parsing or authorization logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-5844 is an integer overflow (CWE-190) in a file parser (libarchive). The target code performs multiple arithmetic operations on tensor dimensions (e.g., `num_filters / rank`, `memory_size * num_filters`) and uses these results for memory allocation. While not identical, both involve parsing structured input (tensor metadata vs. archive headers) and performing calculations that could overflow if inputs are maliciously large, leading to incorrect memory operations. The reference value is in checking for unchecked integer arithmetic on untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2016-7837 is a stack buffer overflow (CWE-119) in a configuration parser. The target code allocates heap memory (via `TfLiteIntArrayCreate`, `context->ResizeTensor`) based on calculated sizes. Both involve input-dependent allocation, but the vulnerability mechanism (stack vs. heap, direct string parsing vs. structured tensor validation) and code patterns differ significantly. The weak similarity is in deriving sizes from external input.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-7972 is a resource management error (CWE-399) involving inconsistent memory tracking in a subtitle renderer. The target code manages temporary tensors and their sizes, ensuring they are resized correctly (e.g., checking `TfLiteIntArrayEqual`). There is a conceptual similarity in managing auxiliary buffers based on operational modes (hybrid, integer, float). The reference value lies in verifying that all allocated resources are correctly tracked and sized.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-9619 is a buffer overflow (CWE-119) via integer issues in a font glyph index parser. The target code uses indices to access tensor arrays but performs bounds checks (e.g., `TF_LITE_ENSURE_EQ`). Both process structured data, but the target code's indices are derived from validated tensor dimensions, not directly from untrusted data. The weak similarity is in using indices for memory access after arithmetic.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2016-7970 is a buffer overflow in a blur effect calculation due to unchecked parameters. The target code performs calculations for tensor sizes but includes validation (e.g., `TF_LITE_ENSURE`, `TF_LITE_ENSURE_EQ`). Both involve mathematical operations on input parameters to determine memory needs, but the target code's validation reduces risk. The similarity is low.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2018-14461 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length validation. The target code validates tensor dimensions and sizes extensively. Both parse structured data, but the validation rigor differs. The weak similarity is in checking length/consistency of input structures.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2009-3909 is an integer overflow (CWE-190) leading to a heap buffer overflow in an image parser. The target code contains similar integer arithmetic on tensor dimensions (e.g., `batch_size * num_filters` implied in scratch size) and uses results to allocate memory. While the target code has more validation, a missing check on the multiplication `memory_size * num_filters` (used in state tensor validation) or similar could lead to an overflow/wraparound, affecting subsequent memory operations. The code pattern of calculating sizes from parsed headers is conceptually similar, providing reference for auditing integer operations.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      }
    ]
  },
  "CVE-2021-37682_after_exclude_100:1a12f78d:vulspec": {
    "timestamp": "2026-01-17T02:08:17.916436",
    "cve_id": "CVE-2021-37682",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1a12f78d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a buffer over-read in a regex parser due to improper NUL byte handling. The target code is a TensorFlow Lite SVDF operator preparation function focused on tensor dimension validation and memory allocation. The domains (regex parsing vs. neural network inference), vulnerability types (CWE-125 vs. potential integer overflows or allocation issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a side-channel vulnerability (CWE-385) in a cryptographic library's elliptic curve implementation. The target code performs tensor setup and validation for a machine learning operation. There is no overlap in functionality (cryptography vs. ML), attack surface (physical side channels vs. malformed model inputs), or vulnerability type (timing attack vs. memory safety/logic errors).",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an access control vulnerability (CWE-284) in a database query planner. The target code is a low-level tensor operator with no concept of users, privileges, or access control. The functional domains (database security vs. numerical computation) and the nature of the flaws are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 is an integer overflow (CWE-190) in a file parser leading to miscalculated positions. The target code performs multiple arithmetic operations on tensor dimensions (e.g., `num_filters / rank`, `memory_size * num_filters`) and uses these values to allocate memory. While the context differs (archive parsing vs. ML kernel), the core risk of integer overflows/wraparounds during size calculations based on untrusted input (the model parameters) is a shared concern. The reference value is in validating all dimension calculations.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 is a stack buffer overflow (CWE-119) in a configuration parser. The target code does not parse untrusted string data; it works on structured tensor data. Both involve processing external input, but the data formats (hex strings vs. tensor buffers), memory models (stack vs. heap/arena allocation), and primary vulnerability mechanisms are different. The weak link is the general principle of validating input before using it to calculate sizes.",
        "case_metadata": {
          "cve_id": "CVE-2016-7837"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a resource management error (CWE-399) involving inconsistent memory tracking. The target code manages temporary tensors and their allocations (`node->temporaries`). There is a conceptual similarity in managing auxiliary memory buffers based on operational modes (`is_hybrid_op`, `is_full_integer`). The reference value lies in ensuring that allocation states are consistent and correctly tracked, though the specific flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a buffer access vulnerability (CWE-119) stemming from unsafe arithmetic on font indices. The target code uses indices to access tensor arrays but performs bounds checking via `TF_LITE_ENSURE` macros. The similarity is the use of indices derived from data. The relevance is weak because the target code appears to have explicit dimension checks, whereas the case lacked them. The reference is in ensuring all index calculations are safe.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 is a buffer overflow in a blur effect calculation due to malicious parameters. The target code uses parameters (`rank`, dimensions) to calculate sizes for allocation. Both involve parameters influencing memory layout. However, the target code's calculations are simpler (multiplications) and are followed by explicit allocations, whereas the case involved an internal array growth loop. The similarity is limited to parameter validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length validation. The target code validates tensor dimensions and sizes but does not parse a TLV-like stream. The common theme is validating size/length fields before using them, but the data structures and parsing models are not analogous. The target code's checks are against fixed tensor metadata, not variable-length fields within a stream.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is an integer overflow (CWE-190) in image dimension calculation leading to a heap overflow. This is the most relevant case. The target code performs several multiplications with user-controlled dimensions (e.g., `batch_size`, `num_filters`, `memory_size`) to calculate sizes for `scratch_size_array` and other tensors. While the code uses `int` types and the context is ML, the fundamental risk is identical: integer overflows in size calculations can lead to undersized allocations and subsequent buffer overflows. The checks present (e.g., `TF_LITE_ENSURE_EQ`) do not explicitly guard against overflow. This case provides a valuable reference for the need to validate that products like `memory_size * num_filters` do not overflow.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      }
    ]
  },
  "CVE-2022-24764_before_exclude_100:c1de04af:vulspec": {
    "timestamp": "2026-01-17T02:08:31.890713",
    "cve_id": "CVE-2022-24764",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c1de04af",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves integer overflow leading to out-of-bounds write during memory allocation. Target code performs bounds checking with arithmetic (m->desc.media.slen+m->desc.transport.slen+12+24) but uses pj_size_t (unsigned) and checks against buffer length. While both involve buffer size calculations, the vulnerability patterns differ: CVE-2018-20750 is a complex integer overflow in allocation, while target code has simpler length validation. Only similarity is buffer boundary concerns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read due to improper NUL byte handling in regex parsing. Target code is an SDP media description printer that copies data with explicit length fields (slen) using pj_memcpy. No NUL termination issues or regex parsing. Different domain, functionality, and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 involves use-after-free in a service discovery daemon. Target code is a straightforward serialization function with no dynamic memory allocation or pointer management. It operates on provided buffers and structures without freeing resources. Completely different vulnerability class.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 involves use-after-free with race conditions in kernel memory policy. Target code is a simple serialization function in user space with no concurrency, locking, or complex resource management. Different environment, complexity level, and vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves NULL pointer dereference in kernel CIPSO validation. Target code checks for NULL (m->conn pointer) but otherwise doesn't have similar parameter validation issues. Different context (kernel vs user space, network security vs SDP serialization).",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves out-of-bounds read in XML parsing due to insufficient bounds checking. Target code similarly processes structured data with potential buffer overrun risks. Both handle variable-length data fields. However, XML parsing is more complex with recursive structures, while SDP printing is linear. Some reference value for buffer management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 involves out-of-bounds read during character encoding processing. Target code handles text data but with explicit length fields rather than NUL-terminated strings. Both involve careful buffer management when processing formatted data. Some similarity in needing to track buffer positions and remaining space.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves missing authorization in kernel key management. Target code has no authentication, authorization, or permission checking. Completely different security domain and functionality.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves improper memory buffer restrictions in kernel crypto operations. Target code has buffer bounds checking and uses stack-allocated buffer pointer arithmetic. Both need to ensure operations stay within buffer boundaries. However, kernel crypto vs user-space SDP printing represents different contexts and complexity levels.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2022-24764_after_exclude_100:e5468368:vulspec": {
    "timestamp": "2026-01-17T02:09:22.307797",
    "cve_id": "CVE-2022-24764",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e5468368",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves integer overflow leading to heap corruption (CWE-787). The target code performs bounds checking with length calculations but uses simple subtraction and size comparisons, not complex arithmetic that could overflow. Both deal with buffer boundaries, but the vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is an out-of-bounds read (CWE-125) due to improper NUL byte handling in regex parsing. The target code performs bounds checks before memory copies (pj_memcpy) and has explicit length validation. Both involve processing external input with length fields, but the code patterns and vulnerability mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a use-after-free (CWE-416) in a daemon's resource management. The target code is a pure formatting/output function with no dynamic memory allocation or pointer management that could lead to use-after-free. The functional domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 4 is an out-of-bounds read (CWE-125) in a protocol parser due to insufficient length validation. The target code also parses structured data (SDP media descriptions) and performs bounds checking before buffer writes. Both involve protocol parsing with length fields, though the target code appears more defensive with its checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a use-after-free (CWE-416) with race conditions in kernel memory policy. The target code is a simple, synchronous formatting function with no concurrency, locking, or complex resource management. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a NULL pointer dereference (CWE-476) in kernel socket option handling. The target code checks buffer lengths but doesn't appear to dereference pointers that could be NULL (it receives non-NULL buffer 'buf'). The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 7 is an out-of-bounds read (CWE-125) in XML parsing due to insufficient bounds checking. The target code has similar pattern of processing structured input with length fields and performs bounds checks (e.g., `if (end-p > m->desc.fmt[i].slen)`). Both involve careful boundary management during parsing operations.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 is an out-of-bounds read (CWE-125) in libxml2 due to inadequate bounds checking during character encoding. The target code similarly processes variable-length data with explicit pointer arithmetic and bounds checks. Both require careful buffer boundary management, though the specific data structures differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a missing authorization vulnerability (CWE-862) in the Linux kernel keys subsystem. The target code has no authentication, authorization, or permission checking mechanisms. It's purely a data formatting function with no security policy enforcement.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a buffer boundary issue (CWE-119) with scatterlist and stack memory in kernel crypto. The target code deals with buffer bounds checking for memory copies, but uses simple contiguous buffers, not scatterlists or complex memory layouts. Both involve ensuring operations stay within buffer bounds, but the mechanisms and contexts differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2022-37032_before_exclude_100:0b19ef00:vulspec": {
    "timestamp": "2026-01-17T02:10:06.565146",
    "cve_id": "CVE-2022-37032",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0b19ef00",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. Both involve parsing BGP capabilities, specifically the MP (Multiprotocol) capability (CAPABILITY_CODE_MP). The vulnerability type (CWE-125: Out-of-bounds Read) is identical, stemming from insufficient bounds checking on capability length fields. The target code performs length checks (`if (pnt + (cap.length + 3) > end)`), but the pattern of parsing a structure from the network stream (`memcpy (&cap, pnt + 1, sizeof (struct capability))`) before fully validating the subsequent data's length is a classic flaw pattern seen in such parsers. The trigger condition (malicious BGP packet with manipulated capability length) is directly applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-14467"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve network protocol parsing and CWE-125, but the domains differ significantly (BGP vs. LDP). The key flaw in Case 2 is insufficient validation of TLV length in a different protocol. While the general principle of \"validate length before use\" applies, the specific code patterns, data structures, and protocol logic are not similar enough to provide strong reference value for the target BGP capability code.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. Both involve parsing BGP capabilities and share the exact same vulnerability type (CWE-125: Out-of-bounds Read). The attack surface (malformed BGP capability advertisement) and the core flaw pattern (insufficient bounds checking when processing capability-specific fields after a generic header) are nearly identical. Case 3's flaw in RESTART capability parsing is structurally analogous to the target code's MP capability parsing, where fields (`afi`, `safi`) are read from the network buffer after a length check that may be insufficient for the specific capability's internal structure.",
        "case_metadata": {
          "cve_id": "CVE-2018-14881"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The vulnerability type is different (CWE-787/190: Out-of-bounds Write/Integer Overflow vs. CWE-125: Out-of-bounds Read). The domain is completely different (VNC file transfer vs. BGP protocol). The flaw pattern (integer overflow in allocation size calculation) is not present in the target code, which performs arithmetic for pointer bounds checking. Provides minimal reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve BGP protocol parsing and CWE-125. The attack surface (malformed BGP packets) is the same. The key flaw pattern (incorrect offset calculation leading to out-of-bounds read) is conceptually similar to the risks in the target code's pointer arithmetic (`pnt += cap.length + 3`). However, the specific component differs (VPN route target parsing vs. capability parsing). The target code's explicit length checks reduce the direct similarity, but the case highlights the importance of rigorous bounds validation in BGP parsers.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The domain is entirely different (Perl regex engine vs. BGP network parser). While both involve CWE-125, the root cause (improper NUL byte handling in strings) and the code patterns have no meaningful similarity to the network buffer parsing logic in the target code. Provides almost no reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve BGP protocol parsing (specifically extensions: MVPN vs. MP-BGP) and share CWE-125. The flaw pattern (incorrect offset calculation when processing specific BGP route types/capabilities) is analogous. The attack vector (crafted BGP packet) is identical. The target code's handling of the MP capability's internal `afi`/`safi` fields parallels the MVPN route type field parsing, sharing the need to validate sub-field access within a previously length-checked container.",
        "case_metadata": {
          "cve_id": "CVE-2017-13043"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Different domain (DNS resolver vs. BGP), different primary vulnerability type (CWE-190/787: Integer Overflow/Out-of-bounds Write vs. CWE-125: Read). The integer overflow flaw pattern is not evident in the target code's length arithmetic, which uses comparison to a boundary (`pnt + (cap.length + 3) > end`). The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve network protocol parsing and CWE-125 due to missing length validation. The general principle of validating TLV/capability lengths before accessing their contents is shared. However, the protocols are different (LLDP vs. BGP), and the target code appears to have explicit length checks, making it less directly similar to the \"missing validation\" flaw in Case 9. Some reference value exists for the general parsing safety approach.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The primary relevance comes from CWE-20 (Improper Input Validation), which is the foundational issue underlying many out-of-bounds reads. Both involve parsing variable-length structures in network protocols. The target code's validation steps (checking `action`, `cap.code`, `cap.length`) are directly addressing this CWE. While the specific protocols differ, the case reinforces the critical need for the comprehensive validation seen in the target code's loops and checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2022-37032_after_exclude_100:f2bb1a2e:vulspec": {
    "timestamp": "2026-01-17T02:10:12.049835",
    "cve_id": "CVE-2022-37032",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f2bb1a2e",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. Both involve parsing BGP capabilities, specifically MP-BGP (CAPABILITY_CODE_MP). The target code performs bounds checks (e.g., `if (pnt + hdr->length + 3) > end`), which is the exact vulnerability type (CWE-125: Out-of-bounds Read) present in CVE-2018-14467. The code patterns (parsing capability headers, length validation) and protocol domain are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-14467"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The vulnerability is in LDP protocol parsing (CWE-125), which is a different network protocol (LDP vs. BGP). The functional domain and code patterns (TLV parsing vs. capability parsing) are not similar to the target BGP capability parsing code.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve BGP capability parsing with insufficient bounds checking (CWE-125). While CVE-2018-14881 targets the RESTART capability and the target code handles MP capability, the overall structure (parsing capability headers, length validation loops, pointer arithmetic) is very similar. The attack surface (malformed BGP capability packets) is identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-14881"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The vulnerability is an integer overflow leading to out-of-bounds write (CWE-787) in a VNC file transfer subsystem. The domain (remote desktop protocol vs. BGP routing), vulnerability type (write vs. read), and code patterns (memory allocation vs. network packet parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve BGP protocol parsing and potential out-of-bounds read issues (CWE-125). However, CVE-2017-13053 is in VPN route target attribute parsing, while the target code is in capability advertisement parsing. The similarity lies in BGP message dissection and the need for careful bounds checking on variable-length fields.",
        "case_metadata": {
          "cve_id": "CVE-2017-13053"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The vulnerability is in a Perl regular expression engine (CWE-125) due to NUL byte handling. The domain (text processing vs. network protocol), functionality, and code patterns have no meaningful similarity to the BGP network packet parsing code.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are in BGP protocol parsing (tcpdump vs. Quagga/FRR) and involve bounds checking issues. CVE-2017-13043 is in MVPN route type decoding, while the target is capability parsing. The relevance comes from shared context: parsing complex BGP messages with nested structures requiring length validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-13043"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The vulnerability is an integer overflow in DNS domain name parsing (CWE-190/787). The domain (DNS vs. BGP), protocol, and vulnerability type (integer overflow/write vs. bounds check/read) are not similar to the target code's network packet parsing with explicit length checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The vulnerability is in LLDP protocol parsing (CWE-125), a different link-layer protocol. While both involve network protocol parsing and length validation, the specific protocols (LLDP vs. BGP), message structures, and code patterns are not similar enough for strong reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The vulnerability is in LMP protocol parsing (CWE-20). Both involve network protocol parsing, but the protocols are different (LMP vs. BGP). The target code already includes several bounds checks, making the \"improper input validation\" aspect less directly comparable than the specific BGP capability parsing cases.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      }
    ]
  },
  "CVE-2017-12904_before_exclude_100:bc56ca7a:vulspec": {
    "timestamp": "2026-01-17T02:10:32.350104",
    "cve_id": "CVE-2017-12904",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bc56ca7a",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code involves command execution with user-controlled input, but the vulnerability type (CWE-787 Out-of-bounds Write) and trigger conditions (integer overflow in file transfer) are fundamentally different. The code patterns (shell command construction vs. network protocol parsing) share no similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not involve complex memory management, pointer operations, or the specific error handling paths that lead to Use-After-Free (CWE-416). The functional domains (network service discovery vs. bookmark command execution) and code patterns are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "The vulnerability (CWE-787 in a regex library) stems from improper validation of input data (octal escapes) leading to out-of-bounds writes in an array. The target code's primary concern is shell command injection via improper quoting/escaping of user input, not array index validation or buffer overflows in a parsing engine.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 2,
        "reasoning": "The vulnerability (CWE-416 Use-After-Free in kernel memory policy) is related to complex concurrency and locking issues in kernel-space resource management. The target code is a user-space application performing command execution with no shared resource management or concurrency patterns in sight.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "The vulnerability (CWE-862 Missing Authorization in kernel keyring) is about permission bypass in a security subsystem. The target code has no authorization checks or permission model; its security flaw potential is entirely in the area of injection, not authorization.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 2,
        "reasoning": "The vulnerability (CWE-190 Integer Overflow in an audio decoder) occurs in mathematical computations on untrusted file data. The target code performs string formatting and shell invocation. While both process untrusted input, the vulnerability types, data types (integers vs. strings), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 2,
        "reasoning": "The vulnerability (CWE-362 Race Condition in a filesystem) involves concurrent access to shared kernel data structures. The target code shows no evidence of multi-threading or shared state that could lead to a race condition. The domains and code patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "The vulnerability (CWE-119 Buffer Overflow in an image codec) is a classic case of insufficient memory allocation for parsed data. The target code's risk is argument injection into a shell command, not a buffer overflow during the parsing of a complex binary format. The code patterns (allocation calculations vs. string formatting) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "There is a very weak similarity: both involve processing formatted text input (IRC colors vs. URL/title/description) and have the potential for output to exceed expected bounds. However, the vulnerability in Case 9 is a precise heap buffer overflow due to a flawed growth strategy within a single process. The target code's risk is argument injection into an external shell, which is a different vulnerability class (CWE-78 OS Command Injection) and exploitation mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 2,
        "reasoning": "The vulnerability (CWE-415 Double Free) is a specific memory management error during error handling in a file parser. The target code does not perform manual memory management (it uses std::string) and its error paths do not involve freeing resources multiple times. The domains and flaw patterns are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2017-12904_after_exclude_100:0aaded85:vulspec": {
    "timestamp": "2026-01-17T02:10:38.382234",
    "cve_id": "CVE-2017-12904",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0aaded85",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a command execution wrapper with string formatting and shell invocation. The vulnerability types (CWE-787 vs. potential command injection), domains (network protocol vs. local command execution), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network daemon's memory management. The target code does not involve complex dynamic memory allocation or pointer management that could lead to use-after-free in a similar way. The functional domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an out-of-bounds write in a regex library due to improper validation of escape sequences. The target code performs string formatting and shell command execution. The vulnerability mechanisms and code contexts share no meaningful similarities.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a use-after-free due to a race condition in the Linux kernel's memory policy subsystem. The target code is user-space, single-threaded command execution with no complex concurrency or kernel-level resource management. The vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a missing authorization flaw in the Linux kernel's key management subsystem. The target code does not implement any authorization or permission checks; it simply formats and executes a user-configured command. The security concern domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-17807"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is an integer overflow in an audio codec's mathematical computations. The target code performs string operations and process execution. There are no complex integer calculations or array indexing operations in the target code that could lead to similar overflow conditions.",
        "case_metadata": {
          "cve_id": "CVE-2019-13219"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a race condition in a filesystem's node ID management. The target code shows no evidence of concurrent execution or shared resource management that could lead to race conditions. The code patterns and vulnerability triggers are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow in an image codec due to insufficient padding allocation. The target code uses string formatting with shell escaping but does not perform low-level buffer allocation or image processing. The vulnerability mechanisms are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is a heap buffer overflow due to unsafe string concatenation and insufficient buffer growth. While the target code uses `strprintf::fmt` (likely safer) and shell escaping, the broader theme of improper string handling and potential for buffer-related issues is a tangential similarity. However, the specific vulnerability pattern (dynamic buffer growth failure) is not present in the shown target code.",
        "case_metadata": {
          "cve_id": "CVE-2012-5854"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a double-free in a document parser during error handling. The target code does not show manual memory allocation/deallocation patterns that could lead to double-free. The resource management contexts and error paths are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      }
    ]
  },
  "CVE-2022-0890_before_exclude_100:91b6f52b:vulspec": {
    "timestamp": "2026-01-17T02:11:56.015839",
    "cve_id": "CVE-2022-0890",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "91b6f52b",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol parser. The target code is a fiber/context switching function in an interpreter runtime, dealing with state management and stack manipulation, with no integer arithmetic or network input parsing.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 is a Use-After-Free due to inconsistent state management during error handling. The target code performs complex state transitions (MRB_FIBER_*) and context switching. While not directly a UAF, the pattern of managing state (status flags, prev pointers) and ensuring consistency during transitions shares conceptual similarity with vulnerability-prone resource state management.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a Double Free during error handling in a file parser. The target code does not explicitly free memory. However, both involve error path handling and state validation (fiber_check, status checks), which are common sources of inconsistency that could lead to memory management flaws in a broader context.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an improper input validation leading to out-of-bounds write in a decompression module. The target code validates fiber status but primarily performs stack manipulation and context switching. The domains (compression vs. VM runtime) and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow due to incorrect size calculation in an image codec. The target code uses `mrb_stack_extend` which likely does bounds checking, and its operations are on interpreter stacks, not image data buffers. No similarity in vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds write in a binary data parser. The target code parses VM instructions/state, not binary file formats. While both involve parsing, the level of abstraction (VM control flow vs. data decoding) and the specific flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds write in a text encoding converter. The target code handles fiber and stack data, not character encoding. The vulnerability patterns (missing error code checks vs. state machine validation) are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow in a network protocol parser due to negative length. The target code deals with internal VM context switching. The domains (network security vs. language runtime) and flaw triggers are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an out-of-bounds write in a regex compiler due to insufficient validation of escape sequences. The target code validates fiber statuses (e.g., checking for MRB_FIBER_TRANSFERRED before resume) but does not parse string escapes. The similarity is limited to the general concept of input/state validation, but the execution context and flaw details are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      }
    ]
  },
  "CVE-2022-0890_after_exclude_100:8a37a6ed:vulspec": {
    "timestamp": "2026-01-17T02:12:09.799903",
    "cve_id": "CVE-2022-0890",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8a37a6ed",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a fiber/context switching function in an interpreter runtime, dealing with state management and stack manipulation, with no network parsing or integer overflow patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code manages fiber state transitions and stack frames; it does not parse untrusted string patterns or have similar buffer access patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is a use-after-free in a network daemon due to inconsistent state management. The target code also performs state management (fiber status checks) and context switching, but the vulnerability patterns differ significantly (no dynamic memory deallocation/free operations are visible in the provided snippet). The state validation logic is the only weak similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a double-free in a file parser during error handling. The target code does not show explicit memory deallocation or error paths that could lead to double-free. It focuses on control flow and stack manipulation.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an improper input validation leading to out-of-bounds write in a decompression module. The target code validates fiber states but does not parse complex untrusted input formats or perform bounds-checked buffer writes in a similar manner.",
        "case_metadata": {
          "cve_id": "CVE-2010-1311"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow due to insufficient allocation in an image codec. The target code uses `mrb_stack_extend` for stack growth, which may involve bounds checking internally, but the pattern is not similar to image block encoding buffer allocation.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds write in a binary data parser. The target code copies values within a stack frame (`b = c->stbase+1; ... *b++ = *a++`) but with explicit length checks (`len >= 15` branch). The context and vulnerability pattern (hex parsing OOB write) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11222"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds write in a text encoding converter due to unhandled error codes. The target code does not perform text encoding conversion or have similar error code propagation issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow in a network protocol parser due to negative length. The target code uses `mrb_int len` (signed) but does not perform negative length checks visibly. However, the overall functionality (fiber switching vs. network packet parsing) is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds write in a regex library due to invalid octal escapes. The target code does not process escape sequences or character classes; it manipulates interpreter stacks and control flow.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      }
    ]
  },
  "CVE-2022-32978_before_exclude_100:cf193faf:vulspec": {
    "timestamp": "2026-01-17T02:12:46.162573",
    "cve_id": "CVE-2022-32978",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cf193faf",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves Use-After-Free in a network service daemon due to memory management errors. The target code is a JPEG-LS image parsing function with no dynamic memory allocation or pointer management in the shown segment. The domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 is an Out-of-bounds Read in a regex parser due to improper NUL byte handling. The target code parses a structured image format stream with its own logic for reading symbols and updating state. While both involve parsing input, the mechanisms (Golomb decoding vs. string parsing) and vulnerability patterns (buffer over-read vs. potential arithmetic/logic errors) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a buffer overflow in a JPEG 2000 codec due to incorrect buffer size calculation. The target code is also for an image codec (JPEG-LS) and involves writing decoded pixel data to a buffer (`*lp = rx << preshift`). There is a potential similarity in the domain (image parsing) and the act of writing transformed data, but the specific flaw (allocation miscalculation) is not evident in the provided code, which lacks memory allocation.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is an Improper Input Validation in a network protocol parser leading to potential memory issues. The target code also parses input (an encoded image stream) and has several reads from the `m_Stream` and calls like `GolombDecode`. The relevance is in the general pattern of parsing untrusted input. However, the code shows extensive use of assertions and structured decoding steps, differing from the simple missing bounds check in the LMP parser.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is an Integer Overflow leading to an Out-of-bounds Write in a DNS parser. The target code uses integer variables like `length`, `run`, and `lines` in loops and shifts (`rx << preshift`). There is a theoretical risk of integer overflows or underflows in these operations if the input data is malicious, which is a minor point of similarity. However, the code structure and primary vulnerability mechanism are very different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow in an image format converter (BMP to JPEG 2000) due to an unchecked header value. The target code is also for image format parsing (JPEG-LS). The shared domain of image codec processing provides some contextual relevance. Both must handle potentially malicious image files. However, the specific flaw of header validation is not present in this low-level scan parsing function.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an Out-of-bounds Read in a network protocol parser due to insufficient length validation. The target code reads from a stream (`BeginReadMCU`, `GolombDecode`) and could theoretically read out-of-bounds if the stream is malformed and decoding functions lack proper checks. This is a general similarity in parsing untrusted data. The code patterns, however, are not identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 8 is an Out-of-bounds Write in a DNS token parser due to incorrect parenthesis counting. The target code writes to a buffer `*lp` within a loop bounded by `length`. While both involve writing to buffers, the target code's logic is arithmetic and prediction-based, not syntax/grammar parsing. The flaw patterns (state management of nested structures vs. pixel prediction) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 9 is an Out-of-bounds Read in an XML parser due to improper buffer management during multi-byte character processing. The target code processes a byte stream but does not involve character encoding complexities. Both parse structured formats, but the vulnerability root cause (character encoding buffer handling) is not applicable to the shown JPEG-LS bitstream decoding.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 10 is a side-channel information leak in a cryptographic library. The target code is a non-cryptographic image decoding function. There is no similarity in functionality, vulnerability type (timing/EM side-channel vs. memory corruption/parsing error), or code patterns. The only vague link is that both process data.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      }
    ]
  },
  "CVE-2022-32978_after_exclude_100:da4e78ec:vulspec": {
    "timestamp": "2026-01-17T02:13:06.201479",
    "cve_id": "CVE-2022-32978",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "da4e78ec",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a Use-After-Free vulnerability in a network service daemon (MiniSSDPd) related to memory management errors during error handling. The target code is a JPEG-LS image parsing function with no dynamic memory allocation or pointer management in the shown code path. The domains (network service vs. image codec) and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 involves an Out-of-bounds Read in a Perl regex engine due to improper NUL byte handling. The target code is a deterministic image decoding loop with no regex parsing, string processing, or similar input validation issues. The code patterns and attack surfaces are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is a buffer overflow in OpenJPEG's code block allocation due to insufficient padding calculation. The target code is also from an image codec (JPEG-LS) and involves parsing compressed image data. While the specific flaw (heap buffer overflow from miscalculation) differs from the target's stream decoding logic, both belong to the image parsing domain where malformed inputs could lead to memory safety issues. The reference value is moderate.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves improper input validation in a network protocol parser (tcpdump's LMP decoder) leading to potential memory corruption. The target code parses image data but includes multiple context checks, predictions, and error mappings. Both involve parsing structured binary data, but the vulnerability pattern (missing bounds checks on packet data) is not evident in the shown target code, which uses length-controlled loops.",
        "case_metadata": {
          "cve_id": "CVE-2019-15166"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an integer overflow leading to buffer overflow in a DNS domain name parser. The target code performs arithmetic shifts and uses LONG types, but no complex integer arithmetic that could wrap around is visible. The domains (DNS parsing vs. image decoding) and vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 is a buffer overflow in OpenJPEG's BMP converter due to unchecked header values. The target code is also from an image codec (JPEG-LS) and processes image data streams. Both involve parsing potentially malicious image files. The specific flaw (unchecked header causing allocation issues) is not directly mirrored, but the domain similarity and potential for input validation bugs provide moderate reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-12982"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in a network protocol parser (tcpdump's LDP decoder) due to insufficient length validation. The target code reads from a byte stream (`m_Stream.ByteStreamOf()`) but uses a length-controlled loop (`LONG length = m_ulWidth[0]`). Both parse binary data, but the target code's structure appears more bounded. The vulnerability pattern is only superficially similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds write in a DNS token parser due to incorrect parenthesis counting. The target code does not parse textual tokens or manage parentheses. The code patterns and data structures are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an out-of-bounds read in libxml2 due to inadequate bounds checking during multi-byte character processing. The target code reads a byte stream and could theoretically have similar issues if `BeginReadMCU` or `GolombDecode` read past buffer boundaries. However, the shown code does not explicitly show the low-level byte reading. The domain difference (XML vs. image) is significant, but the concept of parsing a byte stream with potential for bounds errors provides weak reference.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 10 is a side-channel vulnerability (timing attack) in a cryptographic library. The target code is a non-cryptographic image decoding function with no secret-dependent branches or data. The vulnerability class and domain are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      }
    ]
  },
  "CVE-2022-31307_before_exclude_100:744d7366:vulspec": {
    "timestamp": "2026-01-17T02:13:11.795228",
    "cve_id": "CVE-2022-31307",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "744d7366",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is an iterator function for arrays, strings, and objects. While both involve bounds checking, the domain (regex compilation vs. language runtime iteration), vulnerability trigger (embedded NUL vs. index miscalculation), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs reverse iteration with integer indices (`from`, `to`, `i`). There is a superficial similarity in integer handling for loops and bounds, but the core flaw (arithmetic overflow/wraparound in allocation) and context (file transfer vs. VM iterator) are not present in the target code, which uses simple decrement loops.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is an out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code does involve bounds checking (e.g., `from < array->length`) when accessing array elements, which is a generic similarity. However, the specific vulnerability pattern (parsing untrusted network packets with length fields) and the code structure are not analogous to the iterator's logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read in an image file parser due to improper string termination validation. The target code processes strings, but in a controlled manner using `njs_string_prop` and pointer arithmetic with checks (`p = njs_string_offset`). The flaw pattern (reading external file data without proper sentinel checks) does not align with the internal string iteration shown.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a use-after-free vulnerability in a daemon's resource cleanup path. The target code allocates memory (`njs_object_value_alloc`) and has cleanup paths (`njs_array_destroy`), but there is no evidence of pointer invalidation, double-free, or error state inconsistency that leads to a use-after-free. The memory management patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a double-free vulnerability during error handling in a file reading utility. The target code has error paths that return `NJS_ERROR` and destroys arrays, but the code shows disciplined ownership (keys array is destroyed once). There is no pattern of freeing the same resource multiple times or ambiguous ownership transfer.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in an XML parser due to insufficient bounds checking during end tag processing. The target code has several bounds checks (e.g., `from < array->length`, pointer arithmetic within `string_prop.start` and `end`). The general theme of ensuring indices/pointers stay within bounds is similar, but the specific vulnerability mechanism (parser state corruption) and domain are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is an out-of-bounds read in an XML parser due to inadequate bounds checking during multi-byte character processing. The target code handles UTF-8 strings with `njs_utf8_next` and `njs_utf8_prev`, ensuring `p` stays between `string_prop.start` and `end`. This shows a similar concern for safe buffer traversal, but the vulnerability root cause (encoding error recovery) is not mirrored here.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a buffer management flaw involving missing sentinel values and improper use with string functions. The target code deals with string buffers (`string_prop.start`, `end`) and uses `njs_string_new` to create properly terminated strings. The relevance is in the shared domain of safe string/buffer handling within iterative loops, though the specific sentinel flaw is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a heap buffer overflow due to improper string length validation. The target code uses `njs_string_prop` to get string properties and performs careful pointer arithmetic. While both involve string operations, the target code does not compute dynamic lengths that could become negative or overflow; its indices are validated against known bounds (`length`, `from`, `to`). The flaw pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2022-31307_after_exclude_100:34d7b269:vulspec": {
    "timestamp": "2026-01-17T02:13:56.181820",
    "cve_id": "CVE-2022-31307",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "34d7b269",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-18313 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is an iterator function for arrays, strings, and objects, with no regex parsing or similar pattern matching logic. The vulnerability type and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20750 involves an integer overflow leading to an out-of-bounds write in a network protocol handler. The target code performs iteration with bounds checking (from/to) and uses int64_t for indices, reducing integer overflow risk. The domains (VNC file transfer vs. language runtime iteration) and primary flaw mechanisms are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-14461 is an out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code does not parse network packets or TLVs. It performs bounds-checked iteration over internal data structures (arrays, strings, objects). The context and flaw pattern are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-17787 is an out-of-bounds read in an image file parser due to improper string termination validation. The target code is not a file format parser. It handles string iteration but uses `njs_string_prop` and explicit pointer arithmetic with checks. The attack surface and flaw nature are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-3179 is a use-after-free due to uninitialized pointers and error handling issues. The target code has error paths that free resources (e.g., `njs_array_destroy` on error) and returns error codes. While both involve careful resource management, the specific vulnerability pattern (UAF from uninitialized state) is not directly evident in the target code's patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2013-2124 is a double-free due to violated memory ownership semantics during error handling. The target code has cleanup paths (`njs_array_destroy`) that could be problematic if ownership rules are violated, but the code shows a clear pattern: `njs_array_destroy` is called only when `keys` is non-NULL and before returning. The similarity is limited to general error-handling caution.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1838 is an out-of-bounds read in an XML parser during end-tag processing. The target code does not parse markup languages. Its string iteration for UTF-8 uses `njs_utf8_prev` and `njs_utf8_next`, which should maintain bounds, but the overall context and vulnerability pattern are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in libxml2 due to inadequate bounds checking during multi-byte character processing. The target code also processes UTF-8 strings with pointer arithmetic (`njs_string_offset`, `njs_utf8_prev/next`). However, the target code operates on known string properties and appears to calculate offsets within the string's bounds. The vulnerability pattern (parser state error leading to OOB read) is not clearly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-8860 involves improper buffer management and missing sentinel values, leading to potential overreads. The target code handles string buffers and uses pointer arithmetic (`p--`, `pos = njs_utf8_prev(p)`). While it calculates bounds (`end = string_prop.start + string_prop.size`), incorrect calculations or offsets could lead to similar out-of-bounds reads. The relevance is in the domain of safe buffer/string iteration.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-1834 is a heap buffer overflow due to improper string length validation. The target code uses string length properties and performs iteration. It does not dynamically allocate buffers based on unchecked lengths in the same way. However, both involve careful handling of string lengths and offsets to prevent memory corruption. The direct flaw pattern is not strongly present.",
        "case_metadata": {
          "cve_id": "CVE-2016-1834"
        }
      }
    ]
  },
  "CVE-2021-46668_before_exclude_100:dea4995c:vulspec": {
    "timestamp": "2026-01-17T02:14:00.681447",
    "cve_id": "CVE-2021-46668",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "dea4995c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs file deletion and cleanup for a temporary table in a database storage engine (likely MariaDB/MySQL). Case 1 involves an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The domains (database storage vs. regex parsing), vulnerability types (logic/cleanup vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to heap corruption in a VNC file transfer protocol. The target code is a straightforward cleanup routine for a database table. There is no similarity in functionality, data flow, or vulnerability pattern (no integer operations or network data parsing in the target).",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 3 is a Use-After-Free in a network daemon due to error handling and state management. The target code's `ha_close()` and `maria_delete_table_files` could involve resource cleanup, but the code pattern is simple and sequential, not showing the complex state or error path management that leads to UAF. The connection is very weak.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow in an image codec due to incorrect size calculation. The target code performs file deletion, not buffer allocation or data writing. The domains and vulnerability mechanics are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a Double Free in a file parser during error handling. The target code calls two cleanup/close functions. While both involve resource cleanup, the target code shows no error paths or conditional logic that could lead to inconsistent state or double invocation. The similarity is superficial (both \"free\" resources) but the vulnerability pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a race condition in a filesystem's node ID management. The target code is a single-threaded table drop function with no concurrency mechanisms shown. The vulnerability types and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in an image file parser. The target code deletes files and does not parse external data. No relevance in functionality or vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in an XML parser. The target code is a database storage engine cleanup routine. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is another out-of-bounds read in a text parser due to encoding issues. The target code performs file operations, not text parsing or buffer management. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an integer overflow in a filesystem image parser. The target code has no arithmetic operations or parsing of complex structures. The functionality and potential flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      }
    ]
  },
  "CVE-2021-46668_after_exclude_100:d67371db:vulspec": {
    "timestamp": "2026-01-17T02:14:20.676469",
    "cve_id": "CVE-2021-46668",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d67371db",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves an out-of-bounds read in a regex parser due to improper NUL byte handling. The target code is a database table deletion function with no pattern parsing, string processing, or similar memory safety issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to an out-of-bounds write in a network file transfer protocol. The target code performs file deletion with no arithmetic on user-controlled sizes, network input, or dynamic memory allocation/writing.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 is a use-after-free in a network daemon due to uninitialized pointers and error handling. The target code has a simpler control flow but shares the domain of resource cleanup (closing a file handle, deleting files). However, the vulnerability patterns (UAF vs. simple deletion) and attack surfaces are very different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow in an image codec due to incorrect size calculation. The target code does not perform any buffer operations or complex size calculations that could lead to similar memory corruption.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a double free in a document parser during error handling. The target code calls `ha_close()` and `maria_delete_table_files()`, which could involve resource deallocation. If error paths or state management in these called functions are flawed, a double-free or similar resource management error could theoretically occur, but the code pattern is not directly similar.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a race condition in a filesystem's node ID management. The target code is a straightforward, non-concurrent table drop operation with no apparent shared state or check-then-act sequences that could lead to a race.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read in an image file parser due to improper string termination checks. The target code does not parse file contents or read data from untrusted inputs in a way that could cause a buffer over-read.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an out-of-bounds read in an XML parser during end tag processing. The target code performs file system operations, not parsing of structured, untrusted data formats where bounds checking is critical.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is another out-of-bounds read in a parser, this time related to character encoding. The target code has no functionality related to parsing, encoding, or multi-byte character processing.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an integer overflow in a filesystem image parser leading to bypassed bounds checks. The target code deletes files based on a path name; it does not parse complex filesystem structures or perform arithmetic on untrusted integer values from an image file.",
        "case_metadata": {
          "cve_id": "CVE-2019-1010065"
        }
      }
    ]
  },
  "CVE-2013-4668_before_exclude_100:5ab17dd3:vulspec": {
    "timestamp": "2026-01-17T02:14:39.036531",
    "cve_id": "CVE-2013-4668",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5ab17dd3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-20750 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a GUI dialog function for file extraction with no integer arithmetic, memory allocation, or network parsing. The domains (remote desktop vs. local file manager) and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-18313 involves out-of-bounds read in a regular expression compiler due to NUL byte handling. The target code performs file operations and GUI dialog management with no regex parsing or string processing that could lead to similar buffer over-reads.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-1838 involves out-of-bounds read in XML parser during end tag processing. The target code handles file extraction dialogs with no XML parsing, no complex string parsing, and no similar bounds checking issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-1833 involves out-of-bounds read in libxml2 character encoding processing. The target code performs file operations and GUI interactions with no multi-byte character encoding handling or similar parser state management.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-10218 involves NULL pointer dereference in PDF transparency stack. While the target code uses GTK objects that could potentially be NULL, the vulnerability pattern (unmatched push/pop operations in graphics rendering) is completely different from file extraction dialog logic. Some reference value for general NULL pointer safety.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-12898 involves out-of-bounds read in network packet parsing (NFS protocol). The target code is a local file manager dialog with no network protocol parsing, no length field validation, and completely different attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2014-9512 involves improper path resolution in rsync file transfer. The target code extracts files and constructs paths using `g_file_get_child()` with `base_name` derived from user-controlled input (`odata->current_file->data`). Similar concerns about path traversal or symlink attacks exist, though the specific vulnerability patterns differ. The file extraction context provides some reference value for path validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2014-9512"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13001 involves out-of-bounds read in network packet parsing (NFS file handles). The target code handles local file operations with no network data parsing, no binary protocol decoding, and completely different data validation requirements.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-14461 involves out-of-bounds read in network protocol parsing (LDP TLVs). The target code is a GUI file extraction dialog with no network protocol handling, no TLV parsing, and no similar length field validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 involves race condition in filesystem node ID management in kernel space. The target code is user-space GUI code with no concurrent data structure management, no lock-free algorithms, and completely different synchronization requirements.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2013-4668_after_exclude_100:1286b270:vulspec": {
    "timestamp": "2026-01-17T02:14:52.697339",
    "cve_id": "CVE-2013-4668",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1286b270",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a network protocol handler. The target code is a GUI file extraction dialog with no integer arithmetic, memory allocation, or network protocol parsing. Different domain, vulnerability type, and code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves out-of-bounds read in a regex parser due to NUL byte handling. The target code performs file operations and dialog management with no regex parsing or complex string processing. Different functionality and vulnerability class.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves out-of-bounds read in an XML parser during end tag processing. The target code handles file extraction confirmation with no XML parsing or similar buffer manipulation patterns. Different domain and vulnerability mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves out-of-bounds read in character encoding processing. The target code uses GLib file operations with no multi-byte character processing or similar buffer management issues. Different functionality and attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 involves NULL pointer dereference due to state management errors in PDF rendering. The target code has potential for NULL pointer issues (e.g., odata->window could be NULL), but the context and patterns are different - one is graphics rendering state, the other is file extraction dialog flow.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 involves out-of-bounds read in network packet parsing due to insufficient length validation. The target code performs local file operations with no network protocol parsing or similar length field validation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves improper link resolution/path validation in file synchronization. The target code extracts files to a destination directory and uses `_g_path_get_relative_basename_safe` for path sanitization, which shares the domain of file path security. However, the specific vulnerability pattern (symlink attacks vs. extraction overwrite) differs.",
        "case_metadata": {
          "cve_id": "CVE-2014-9512"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves out-of-bounds read in network protocol file handle parsing. The target code handles local file extraction with no network protocol decoding or similar buffer copy operations.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves out-of-bounds read in network protocol TLV parsing. The target code is a GUI file extraction dialog with no network protocol parsing, TLV structures, or similar length field validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves race condition in filesystem node ID management. The target code runs in GUI context (likely single-threaded for dialog operations) with no concurrent data structure manipulation or similar synchronization issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      }
    ]
  },
  "CVE-2022-3303_after_exclude_100:e642d750:vulspec": {
    "timestamp": "2026-01-17T02:17:24.547012",
    "cve_id": "CVE-2022-3303",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e642d750",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2016-3179) is a Use-After-Free in a user-space network daemon (MiniSSDPd) related to improper cleanup of allocated structures. The target code is a kernel audio subsystem function managing synchronization and buffer states with mutex locks and reference counts. The domain (kernel vs. user-space), vulnerability type (UAF vs. potential logic/race/sync issues), and code patterns (memory management vs. concurrency control) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 2 (CVE-2018-20750) is an Out-of-bounds Write in LibVNC due to integer overflow in memory allocation. The target code performs audio buffer manipulation and synchronization with careful size calculations using runtime parameters. While both involve size calculations, the target code's calculations are based on internal state (buffer_used, period_bytes) and do not involve user-controlled allocation sizes or integer overflows. The attack surface and flaw nature are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 (CVE-2018-18313) is an Out-of-bounds Read in Perl's regex engine due to improper NUL byte handling. The target code is a kernel audio sync function with no string parsing or regex processing. The vulnerability type (memory read vs. kernel state management) and code context are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 (CVE-2010-4650) is a buffer overflow in the Linux kernel FUSE subsystem due to insufficient iovec length validation. The target code is also in the Linux kernel and involves careful buffer size calculations (e.g., `size * 8 / width`). However, the target code's calculations are for internal silence filling, not user-provided iovec structures. Both are kernel code, but the vulnerability mechanism (lack of validation of external inputs vs. internal arithmetic) and subsystem are different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 (CVE-2017-14151) is a heap buffer overflow in OpenJPEG due to insufficient padding allocation. The target code performs size calculations for buffer operations but within a tightly controlled kernel audio context, not based on external image data. The flaw pattern (allocation miscalculation vs. state-based synchronization) is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 (CVE-2017-18249) is a Race Condition in the Linux kernel F2FS filesystem related to non-atomic check-and-use operations on shared state (nid lists). The target code uses mutex locks (`runtime->oss.params_lock`) and atomic references (`atomic_inc/dec`, `atomic_read`) to protect shared structures (`runtime->oss` state). Both are Linux kernel code dealing with concurrency control. The relevance is in the shared concern for proper synchronization of shared kernel data structures, though the specific patterns (list management vs. audio buffer state) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CVE-2018-20760) is an Out-of-bounds Write in a multimedia framework's text import due to improper error handling in encoding conversion. The target code is kernel audio synchronization with no text/encoding processing. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 8 (CVE-2011-3601) is a buffer overflow in a network daemon due to negative length value from external packets. The target code performs arithmetic (`size * 8 / width`) but on internal state, not untrusted network data. Both involve size calculations, but the trust boundary and vulnerability trigger are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 9 (CVE-2014-0196) is a Race Condition in the Linux kernel TTY subsystem leading to memory corruption, involving concurrent writers to a shared buffer. The target code is also in the Linux kernel and employs concurrency mechanisms (mutex, atomic ops) to protect shared audio runtime state. Both are classic kernel synchronization challenges. The pattern of using locks to serialize access to shared data structures (TTY buffer vs. OSS audio buffer) is highly similar. The key difference is the specific subsystem and data structure, but the vulnerability class (concurrency) and mitigation patterns are closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 (CVE-2019-20840) is an Out-of-bounds Write in LibVNCServer due to unaligned memory access during WebSocket frame processing. The target code is kernel audio synchronization with no network protocol parsing or alignment-sensitive operations. The vulnerability type and context are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      }
    ]
  },
  "CVE-2022-3303_before_exclude_100:9d8a28f6:vulspec": {
    "timestamp": "2026-01-17T02:17:25.024100",
    "cve_id": "CVE-2022-3303",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9d8a28f6",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 (CVE-2016-3179) is a Use-After-Free vulnerability in a user-space network daemon (MiniSSDPd) related to improper cleanup of allocated structures. The target code is a kernel-space audio driver synchronization function with no dynamic memory allocation/free operations in the shown path. The vulnerability types, domains, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 (CVE-2018-20750) is an integer overflow leading to out-of-bounds write in a VNC library's file transfer. The target code performs size calculations (e.g., `size * 8 / width`) which could theoretically involve integer issues, but the context is entirely different (audio buffer synchronization vs. network protocol parsing). The core flaw pattern (integer mishandling in allocation) is not present in the target code's shown calculations, which are for buffer fill sizes, not allocations.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 (CVE-2018-18313) is an out-of-bounds read in a regular expression compiler due to improper NUL byte handling. The target code is a kernel audio driver function that operates on internal kernel buffers with no regex parsing or similar string processing. The vulnerability domain and trigger conditions are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 (CVE-2010-4650) is a buffer overflow in the Linux kernel FUSE subsystem due to insufficient validation of iovec lengths. The target code is also in the Linux kernel and involves careful manipulation of buffer pointers and sizes (`runtime->oss.buffer`, `size`). While both are kernel code dealing with buffer boundaries, the specific vulnerability pattern (iovec length validation) and subsystem (filesystem vs. audio) are different. The target code's size calculations and silent buffer fills share a conceptual similarity with buffer management flaws.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 (CVE-2017-14151) is a buffer overflow in an image codec due to insufficient padding allocation. The target code involves writing silence to an audio buffer based on calculated sizes. Both involve writing data to a buffer based on a computed size, but the target code's size calculation (`(8 * (...) + 7) / width`) and subsequent `snd_pcm_format_set_silence` call appear to be careful about width alignment. The flaw pattern (incorrect size calculation for a specialized allocator) is not directly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 (CVE-2017-18249) is a race condition in the Linux kernel F2FS filesystem related to non-atomic check-and-use operations. The target code is also in the Linux kernel and uses concurrency controls (`mutex_lock_interruptible`, `atomic_inc/dec`). It manages shared state (`runtime->oss.params_lock`, `runtime->oss.rw_ref`) across multiple code paths (normal and `__direct`). While the specific resource (nid list vs. audio runtime parameters) differs, the pattern of managing shared kernel object state with locks and atomics is similar. A missing lock or incorrect lock ordering in the target code could lead to similar state corruption.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 (CVE-2018-20760) is an out-of-bounds write in a multimedia framework's text import due to improper error handling after a failed encoding conversion. The target code performs binary buffer operations in the kernel with no text encoding or complex error path handling for external data. The domains and flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 (CVE-2011-3601) is a buffer overflow in a network daemon parser due to a negative length value. The target code calculates a `size` variable. If `width` could be zero or certain values, the division `size * 8 / width` could cause issues, but `width` is derived from a physical format width. The potential for miscalculation exists in both, but the attack surface (network packet vs. internal kernel audio state) and context are very different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3601"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 9 (CVE-2014-0196) is a race condition in the Linux kernel TTY subsystem leading to a buffer overflow. The target code is also in the Linux kernel, uses shared resources protected by mutexes (`runtime->oss.params_lock`), and has a complex control flow with multiple entry/exit points (including the `__direct` goto). The pattern of taking a lock, manipulating shared buffer/state pointers (`runtime->oss.buffer`), and releasing the lock is very similar. The `atomic_inc`/`atomic_dec` on `rw_ref` alongside the mutex is a classic pattern for reference-counted resources vulnerable to race conditions if not paired correctly. The structure and concurrency patterns are highly analogous, though the specific subsystem differs.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 (CVE-2019-20840) is an out-of-bounds write in a VNC library due to unaligned memory access during WebSocket frame processing. The target code performs aligned memory writes via `snd_pcm_format_set_silence` and does not process network data. The vulnerability type and underlying cause (alignment assumption) are not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-20840"
        }
      }
    ]
  },
  "CVE-2022-29212_before_exclude_100:bb4ed060:vulspec": {
    "timestamp": "2026-01-17T02:18:06.332656",
    "cve_id": "CVE-2022-29212",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bb4ed060",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a side-channel timing attack in cryptographic operations (CWE-385). The target code performs quantized tensor comparisons in a machine learning context, with no cryptographic operations, secret-dependent branches, or timing-sensitive logic. The vulnerability types and domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an improper access control vulnerability (CWE-284) in a database query planner. The target code is a numerical computation function in a tensor library with no privilege checks, user authentication, or SQL/query processing. The attack surfaces and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is an out-of-bounds read (CWE-125) in a regex parser due to improper NUL byte handling. The target code performs arithmetic operations on tensor data with defined shapes. While both involve parsing/processing input data, the target code does not directly parse untrusted byte streams or perform string operations that could lead to buffer over-reads.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an integer overflow (CWE-190) during file position calculation in an archive parser. The target code performs arithmetic operations (multiplications, shifts) on quantization parameters. There is a conceptual similarity in performing arithmetic on potentially untrusted input (tensor scales/zero_points), but the context (file parsing vs. numerical computation) and specific overflow triggers differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is a resource management error (CWE-399) involving inconsistent memory tracking in a subtitle renderer. The target code does not perform dynamic memory allocation or maintain complex state across operations. It is a self-contained arithmetic function.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow (CWE-119) in a blur effect calculation due to unsafe array indexing. The target code uses safe library functions (`reference_ops::ComparisonWithScaling`) and does not perform direct array indexing or buffer writes. Both involve mathematical operations on parameters, but the target code delegates bounds-checked operations to a reference implementation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient bounds checking. The target code operates on structured tensor data with known shapes via accessor functions (`GetTensorShape`, `GetTensorData`), which should provide bounds safety. The domains (network packet parsing vs. tensor computation) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is an integer overflow (CWE-190) leading to an out-of-bounds read during memory size calculation in an image decoder. The target code performs integer arithmetic on quantization multipliers and shifts. There is a similarity in performing arithmetic on input-derived values (scales), but the target code's operations are simpler and less likely to overflow (shifts, multiplications on likely small ints). The critical difference is the lack of subsequent memory allocation based on these calculations in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-7163"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an integer overflow (CWE-190) leading to a heap buffer overflow in an image file header parser. Similar to Case 4 and 8, the relevance stems from performing arithmetic on input data (tensor parameters). However, the target code does not use the results to allocate memory or index buffers directly; it passes them as parameters to a library function. The risk profile is lower.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a double free (CWE-415) due to inconsistent state management in a ZIP archive parser. The target code has no dynamic memory management, error paths that free resources, or complex state transitions. It is a pure function with no persistent state.",
        "case_metadata": {
          "cve_id": "CVE-2017-12858"
        }
      }
    ]
  },
  "CVE-2022-29212_after_exclude_100:1dd64377:vulspec": {
    "timestamp": "2026-01-17T02:18:21.034664",
    "cve_id": "CVE-2022-29212",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1dd64377",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a side-channel timing attack in cryptographic operations (CWE-385). The target code performs quantized tensor comparisons in a machine learning context, with no cryptographic operations, secret-dependent branches, or timing-sensitive logic. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an improper access control vulnerability (CWE-284) in a database query planner. The target code is a numerical computation function in a tensor library with no privilege checks, user authentication, or access control logic. The functional domains and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is an out-of-bounds read (CWE-125) caused by improper NUL byte handling in a regex parser. The target code performs arithmetic operations on tensor data with defined shapes. While both involve parsing/processing input data, the target code shows no direct string/buffer manipulation or boundary validation that would lead to a similar memory read flaw.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an integer overflow (CWE-190) during file position calculation in an archive parser. The target code involves integer arithmetic for quantization parameters (offsets, multipliers, shifts). There is a superficial similarity in performing integer calculations on potentially untrusted input (tensor parameters), but the target code lacks the complex, multi-step calculations on large, user-controlled values that typically lead to overflow. The `QuantizeMultiplier` function's implementation is critical but not shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is a resource management error (CWE-399) due to inconsistent memory tracking in a text shaper. The target code performs calculations but does not show explicit dynamic memory allocation or deallocation. The vulnerability patterns (state tracking errors vs. arithmetic logic) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow (CWE-119) in a blur effect calculation due to unchecked parameters. The target code passes parameters to comparison functions. There is a distant similarity in performing calculations based on input parameters, but the target code's operations (scaling, offset application) are simpler and less likely to produce unbounded growth. The risk would depend on the implementation of the called `BroadcastComparison4DSlowWithScaling` and `ComparisonWithScaling` functions.",
        "case_metadata": {
          "cve_id": "CVE-2016-7970"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is an out-of-bounds read (CWE-125) in a network protocol parser due to incorrect bounds checking. The target code works on tensor data structures with presumably validated shapes. While both process structured input, the target code's data flow is more controlled, and the primary risk is not a simple bounds check omission during sequential parsing.",
        "case_metadata": {
          "cve_id": "CVE-2017-12899"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is an integer overflow leading to an out-of-bounds read (CWE-190 -> CWE-125) during memory size calculation in an image decoder. The target code performs integer arithmetic for quantization. The relevance is slightly higher than Case 4 because both involve calculations (multipliers, shifts) that could theoretically overflow if inputs are malicious, potentially affecting subsequent operations. However, the scale of calculations and connection to memory allocation is less direct in the shown target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-7163"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an integer overflow leading to a heap buffer overflow (CWE-190 -> CWE-122) in an image header parser. Similar to Cases 4 and 8, the target code performs integer arithmetic (calculating offsets, applying shifts). The potential link exists if the quantization parameters (`scale`, `zero_point`) are derived from untrusted data and the `QuantizeMultiplier` function or the subsequent comparison operations contain overflow-prone calculations that affect memory access.",
        "case_metadata": {
          "cve_id": "CVE-2009-3909"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is a double free (CWE-415) due to inconsistent state management on error paths in an archive parser. The target code shows a straightforward function with no visible dynamic memory management or complex error state cleanup. The vulnerability patterns (memory ownership vs. arithmetic logic) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12858"
        }
      }
    ]
  },
  "CVE-2021-37672_before_exclude_100:8cca0078:vulspec": {
    "timestamp": "2026-01-17T02:19:13.217156",
    "cve_id": "CVE-2021-37672",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8cca0078",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a cryptographic side-channel vulnerability (CWE-200/385) in libgcrypt. The target code is a TensorFlow feature initialization routine with no cryptographic operations, constant-time requirements, or secret-dependent branching. The domains and flaw patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an improper access control (CWE-284) vulnerability in PostgreSQL's query planner related to privilege checks. The target code performs input validation and resource initialization in a machine learning context with no access control or privilege management logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves improper input validation (CWE-20) leading to unnecessary privilege execution (CWE-250) in a daemon's privilege separation. The target code does perform input validation (checking tensor list sizes), but it's for data consistency, not security boundaries or privilege state. The execution context and consequences are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a cryptographic algorithm handling flaw (CWE-327) leading to a NULL pointer dereference (CWE-476) in BIND9's DNSSEC. The target code has no cryptographic processing, algorithm selection, or complex error cleanup chains that could lead to NULL dereference from prior failures.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds read (CWE-125) due to improper NUL byte handling in Perl's regex engine. The target code uses TensorFlow input lists and tensors which have bounds-checked access patterns. While both process external input, the data structures (flat tensors vs. strings) and vulnerability mechanisms (buffer over-read vs. size validation) are different. However, both involve parsing/validating structured input.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a use-after-free (CWE-416) due to uninitialized pointers and inconsistent state management in a network daemon. The target code uses C++ vectors and TensorFlow objects with RAII patterns, showing no manual memory management or pointer handling that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read (CWE-125) in a file parser due to improper string termination validation. The target code reads from TensorFlow tensors with known sizes via `flat()` accessors, which provide bounds checking. The input sources and parsing mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a resource management error (CWE-399) in a subtitle renderer due to inconsistent memory tracking. The target code allocates vectors with `resize()` and uses TensorFlow's memory management, showing no manual size tracking or allocation patterns that could lead to similar inconsistencies.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves incorrect buffer size calculation (CWE-17) leading to invalid free (CWE-590) in PHP's fileinfo. The target code has no manual buffer size calculations, heap/stack confusion, or direct memory deallocation.",
        "case_metadata": {
          "cve_id": "CVE-2014-9426"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is an integer overflow (CWE-190) in an archive parser when calculating file positions. The target code contains a similar integer overflow check: `if (example_weights.size() >= std::numeric_limits<int>::max())`. It validates that a size_t value fits into an int before a static_cast, preventing an overflow/wraparound when converting to a smaller integer type. The vulnerability pattern (integer size validation) and defensive code pattern are similar, though the contexts (file parsing vs. ML batch processing) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      }
    ]
  },
  "CVE-2021-37672_after_exclude_100:a34d0faa:vulspec": {
    "timestamp": "2026-01-17T02:19:18.261192",
    "cve_id": "CVE-2021-37672",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a34d0faa",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a cryptographic side-channel vulnerability (CWE-200/385) in a low-level math library. The target code is a TensorFlow feature initialization routine performing data validation and memory allocation. No cryptographic operations, secret-dependent branches, or timing-sensitive logic are present.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an access control flaw (CWE-284) in a database query planner related to privilege checks on system catalogs. The target code performs input validation and resource initialization within a single kernel context, with no multi-user privilege model or access control logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves improper input validation (CWE-20) leading to unnecessary privilege execution (CWE-250) during daemon initialization. The target code also performs input validation (checking tensor sizes) but within a constrained OpKernel context, not a privilege-separated system process. The error handling pattern (returning errors::InvalidArgument) is robust and does not lead to elevated privilege states.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a cryptographic algorithm handling flaw (CWE-327) leading to a NULL pointer dereference (CWE-476) in a DNS security subsystem. The target code does not process cryptographic keys, algorithms, or DNSSEC data. Its error paths return status objects rather than risking NULL dereference.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds read (CWE-125) due to improper NUL byte handling in a regex parser. The target code validates input tensor sizes and performs bounds checking (e.g., checking example_weights.size() against numeric_limits<int>::max()). While both involve input validation, the vulnerability patterns differ significantly: one is a parser flaw with embedded NULs, the other is a resource initialization routine with explicit size checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a use-after-free (CWE-416) due to uninitialized pointers and inconsistent state management in a network daemon. The target code uses C++ standard containers (vectors) that manage their own memory, with clear initialization paths and no manual pointer management that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read (CWE-125) in a file format parser due to improper string termination validation. The target code reads tensor data via TensorFlow's abstraction layer, not raw file bytes. Both perform validation, but the attack surface (malformed PSP file vs. malformed tensor dimensions) and data parsing mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-17787"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a resource management error (CWE-399) involving inconsistent memory tracking in a text rendering library. The target code allocates memory via std::vector::resize() and manages resources within the TensorFlow framework. Both involve resource initialization, but the vulnerability pattern (incorrect size tracking leading to allocation failure) is not evident in the target code's straightforward container usage.",
        "case_metadata": {
          "cve_id": "CVE-2016-7972"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a buffer size miscalculation (CWE-17) leading to invalid free (CWE-590) in a magic file loader. The target code does not perform manual buffer size calculations or direct heap deallocation; it uses RAII patterns and TensorFlow's memory management.",
        "case_metadata": {
          "cve_id": "CVE-2014-9426"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is an integer overflow (CWE-190) during file position calculation in an archive parser. The target code contains a similar integer overflow check: `if (example_weights.size() >= std::numeric_limits<int>::max())`. Both validate that a size value fits within a specific integer type before conversion. However, the target code's check is defensive and returns an error, while the vulnerability case involves an actual overflow during calculation. The code pattern (size validation before static_cast) is conceptually similar but implemented safely in the target.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      }
    ]
  },
  "CVE-2015-8874_after_exclude_100:e13340e2:vulspec": {
    "timestamp": "2026-01-17T02:19:39.472806",
    "cve_id": "CVE-2015-8874",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e13340e2",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a recursive flood fill algorithm in a graphics library (likely libgd). Case 1 is a Use-After-Free in a network service discovery daemon (MiniSSDPd). The domain (image processing vs. network protocol), vulnerability type (logic/recursion vs. memory corruption), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Both the target code and this case involve PHP's GD graphics library (libgd). The vulnerability type (CWE-681 - integer signedness) is different from the target's logic, but the shared domain (core libgd image processing) and component make this highly relevant for understanding the library's security context and common flaw patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This case is also in PHP's GD library (libgd), specifically in image scaling. While the vulnerability type (CWE-399 - resource management) differs from the target's flood fill logic, the shared system, domain (image processing), and library context provide extremely valuable reference for the security posture and common error patterns of the codebase containing the target function.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is image flood fill in libgd. Case 4 is an out-of-bounds read in Perl's regular expression engine. The systems, domains (image processing vs. text parsing), vulnerability types (logic recursion vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve image processing (GIMP's XWD plugin vs. libgd's flood fill). The vulnerability type (CWE-787 - out-of-bounds write) is different, but the shared high-level domain means there might be some overlap in concepts like color/border value handling, though the specific code patterns and systems are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This case is highly relevant as it involves the PHP GD library's buffer handling (gd_io_dp.c). Although the specific vulnerability (CWE-119 - buffer bounds) and component differ from the target's `gdImageFillToBorder` function, they belong to the same core library (libgd) and image processing subsystem. This provides critical context for the security environment of the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is an image flood fill algorithm. Case 7 is an out-of-bounds write in a VNC server's file transfer protocol. The systems (libgd vs. LibVNC), domains (image processing vs. remote desktop/file transfer), and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve image processing (Ghostscript's color rendering vs. libgd's flood fill). The vulnerability type (CWE-787 - out-of-bounds write) is different, but the shared domain of manipulating pixel data based on color/border conditions offers a tangential similarity in problem space, though the implementations and systems are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This case is directly in the libgd library, concerning BMP image handling and double-free vulnerabilities. The target function `gdImageFillToBorder` is part of the same libgd library. While the specific vulnerability type (CWE-415) and module differ, the shared codebase is critical. Understanding flaws in adjacent modules (like error handling, memory management) is highly valuable for evaluating the target code's security context.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is image flood fill in libgd. Case 10 is a buffer bounds issue in Ghostscript's font processing subsystem. The systems (libgd vs. Ghostscript), domains (general image processing vs. font glyph processing), and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      }
    ]
  },
  "CVE-2015-8874_before_exclude_100:db5432e6:vulspec": {
    "timestamp": "2026-01-17T02:19:40.233510",
    "cve_id": "CVE-2015-8874",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "db5432e6",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2016-3179) involves a Use-After-Free in a network service daemon (MiniSSDPd). The target code is a recursive image fill function in libgd with no dynamic memory allocation, pointer manipulation, or network handling. The vulnerability types, domains, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 2 (CVE-2018-5711) is a vulnerability in PHP's GD library (libgd), the same library as the target code. While the specific flaw (integer signedness in GIF decoder) differs, the domain (libgd image processing), attack surface (malformed image data), and system context are identical. This provides highly valuable reference for understanding libgd's vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-5711"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 3 (CVE-2015-8877) is also a vulnerability in PHP's GD library, specifically in image scaling. The core system (libgd) and domain (image processing) are identical to the target code. The vulnerability type (resource management) is different, but the shared context makes it highly relevant for understanding libgd's error handling and memory management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 (CVE-2018-18313) involves an out-of-bounds read in Perl's regular expression engine. The target code is an image fill algorithm in C with no regex parsing, string processing, or Unicode handling. The systems, domains, and vulnerability patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 (CVE-2013-1978) is an out-of-bounds write in GIMP's XWD file plugin. Both involve image processing, but the systems (GIMP vs. libgd) and specific functions (file parsing vs. in-memory fill algorithm) are different. The vulnerability type (OOB write) is not immediately apparent in the target recursive fill code, which lacks explicit buffer writes.",
        "case_metadata": {
          "cve_id": "CVE-2013-1978"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 6 (CVE-2016-8670) is a buffer overflow in PHP's GD library integration. The system (PHP GD/libgd) is the same as the target code. The vulnerability involves bounds checking and arithmetic issues. The target `gdImageFillToBorder` function performs pixel access (`gdImageGetPixel`) which relies on safe bounds checking; a flaw in those underlying functions or in the recursive logic could lead to similar memory safety issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CVE-2018-20750) is an out-of-bounds write in LibVNC's file transfer protocol handler. The domain (network protocol vs. image processing), functionality, and vulnerability trigger (integer overflow in network data) are completely different from the target image fill algorithm.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 (CVE-2020-16304) is an out-of-bounds write in Ghostscript's image renderer. Both involve image processing, but the systems (Ghostscript vs. libgd) and specific operations (color space conversion vs. flood fill) are distinct. The potential for OOB write in the target code exists only if the recursive calls or pixel setting exceed image dimensions, which would be a bounds checking issue elsewhere.",
        "case_metadata": {
          "cve_id": "CVE-2020-16304"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 9 (CVE-2018-1000222) is a Double Free vulnerability in libgd's BMP handling module. This is the most directly relevant case as it involves the exact same library (libgd). While the target `gdImageFillToBorder` function does not obviously contain dynamic memory management, understanding memory ownership and error handling patterns within the same codebase is highly valuable for a security audit.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000222"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 (CVE-2017-9619) is a buffer overflow in Ghostscript's font processing. The system (Ghostscript vs. libgd), domain (font glyph processing vs. image fill), and attack surface (XPS documents vs. in-memory image) are fundamentally different. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-9619"
        }
      }
    ]
  },
  "CVE-2012-4559_before_exclude_100:51b45140:vulspec": {
    "timestamp": "2026-01-17T02:19:53.510380",
    "cve_id": "CVE-2012-4559",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "51b45140",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code is an SFTP directory creation function with different protocol handling, memory management patterns, and no complex integer calculations that could overflow. Both handle file operations but the vulnerability mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves buffer over-read in Perl regex engine due to NUL byte handling. The target code performs SFTP protocol operations with structured buffer handling and doesn't involve regular expression parsing or similar string processing vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 involves out-of-bounds read in tcpdump's NFS protocol decoder. The target code is an SFTP client implementation with different protocol semantics. While both handle network protocols, the vulnerability patterns (protocol field parsing vs. command/response handling) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 involves out-of-bounds read in tcpdump's NFSv3 parser due to insufficient length validation. The target code uses structured buffer operations with explicit size management (buffer_add_* functions) and doesn't parse variable-length protocol fields in the same way.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 involves out-of-bounds read in tcpdump's LDP protocol parser. The target code implements SFTP command/response handling with different buffer management patterns. Both are network protocol implementations but with fundamentally different vulnerability profiles.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves path validation issues in rsync leading to symlink attacks. The target code handles directory creation in SFTP with path parameter validation. Both deal with file system operations and path handling, but the specific vulnerability (improper link resolution) isn't directly apparent in the target code which doesn't resolve symlinks.",
        "case_metadata": {
          "cve_id": "CVE-2014-9512"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 involves use-after-free in MiniSSDPd due to improper resource cleanup. The target code has careful resource management (buffer/string freeing) and error handling. Both involve network service implementations, but the memory management patterns and error paths differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves improper privilege handling in radvd when privilege separation fails. The target code doesn't involve privilege management or daemon initialization. Both are network service components but address completely different security aspects.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 involves integer overflow in DNS domain name parsing leading to buffer overflow. The target code performs SFTP operations with fixed-size integer handling and doesn't involve complex string parsing or length calculations that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 involves out-of-bounds read in libxml2's end tag parser. The target code handles SFTP protocol messages with structured parsing, not XML document parsing. The code patterns and vulnerability mechanisms are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2012-4559_after_exclude_100:1e22750c:vulspec": {
    "timestamp": "2026-01-17T02:20:47.483213",
    "cve_id": "CVE-2012-4559",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1e22750c",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code is an SFTP directory creation function with careful buffer management using safe buffer APIs (buffer_add_u32, buffer_add_ssh_string). No integer overflow or heap corruption patterns are present.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves buffer over-read in Perl regex engine due to NUL byte handling. The target code performs SFTP protocol operations with structured message parsing, not regex processing or string parsing vulnerable to embedded NUL bytes.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves out-of-bounds read in tcpdump's NFS protocol decoder due to insufficient bounds checking. The target code is an SFTP client implementation that uses safe buffer operations and structured protocol messages, not network packet parsing with direct memory access.",
        "case_metadata": {
          "cve_id": "CVE-2017-13001"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves out-of-bounds read in tcpdump's NFSv3 parser due to insufficient length validation. The target code uses structured SFTP protocol with message queuing and proper error handling, not raw packet parsing with length field validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-12898"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves out-of-bounds read in tcpdump's LDP protocol parser due to insufficient TLV length validation. The target code implements SFTP client operations with proper message handling, not network protocol decoding with TLV parsing vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves improper link resolution in rsync's file transfer. The target code's sftp_mkdir function handles directory creation and includes a stat call (sftp_lstat) to check if directory exists, showing some path validation. However, the vulnerability patterns differ significantly (symlink attacks vs. protocol implementation).",
        "case_metadata": {
          "cve_id": "CVE-2014-9512"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 involves use-after-free in MiniSSDPd due to improper resource cleanup. The target code shows careful resource management with proper freeing of buffers and strings, and uses message queuing without apparent memory management flaws in error paths.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves improper input validation leading to unnecessary privilege execution in radvd. The target code performs input validation (path conversion, buffer operations) and error handling, but doesn't involve privilege separation or root privilege management issues.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 involves integer overflow leading to buffer overflow in DNS domain name parsing. The target code uses safe buffer addition functions and doesn't perform manual length calculations or arithmetic that could overflow. The protocol domains are completely different (DNS vs SFTP).",
        "case_metadata": {
          "cve_id": "CVE-2019-25034"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves out-of-bounds read in libxml2's end tag parsing. The target code doesn't parse XML or similar hierarchical text formats, and uses structured SFTP protocol messages rather than text parsing with potential bounds checking issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      }
    ]
  },
  "CVE-2021-40574_before_exclude_100:068bcf0f:vulspec": {
    "timestamp": "2026-01-17T02:21:46.311852",
    "cve_id": "CVE-2021-40574",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "068bcf0f",
    "scores": [
      {
        "score": 10,
        "reasoning": "This is the exact same vulnerability (CVE-2018-20760) in the same function `gf_text_get_utf8_line` in the GPAC framework. The target code is the vulnerable code itself. The vulnerability type (CWE-787 Out-of-bounds Write), system, component, and attack surface (malformed text file encoding) are identical. This is a perfect match.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The system (MiniSSDPd), domain (network service discovery), and vulnerability type (CWE-416 Use After Free) are completely different from the target code's text encoding conversion functionality and potential buffer overflow issues.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve processing of text/character data (regex vs. UTF conversion). The vulnerability type (CWE-125 Out-of-bounds Read) is different from the primary risk in the target code (out-of-bounds write). The attack surface (malformed input) is a superficial similarity.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The vulnerability type (CWE-787 Out-of-bounds Write) is the same. The root cause (integer handling/overflow in allocation) is different from the target code's direct buffer copy operations (`strcpy`). The domains (VNC file transfer vs. text encoding) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Both involve encoding conversion, but the system (Oniguruma regex library) and vulnerability type (CWE-416 Use After Free) are different. The target code does not show complex memory management patterns that would lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2019-13224"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The system (ClamAV) and domain (VBA extraction) are unrelated. The vulnerability type (CWE-415 Double Free) is different. The only weak similarity is parsing complex input formats, but the mechanisms are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve parsing/processing text with complex multi-byte character encodings (UTF-8). The vulnerability type (CWE-125 Out-of-bounds Read) is related to the broader class of memory safety issues present in the target code. The attack surface (malformed encoding sequences) is similar, though the specific flaw (read vs. write) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The system (libxml2) and domain (XML parsing) are different. The vulnerability type (CWE-125 Out-of-bounds Read) is related but not the primary concern for the target code. The similarity is limited to the general concept of insufficient bounds checking during parsing.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The vulnerability type (CWE-119/787 buffer overflow) is the same core issue. The domain (image encoding vs. text encoding) and root cause (padding calculation vs. direct string copy) are different, but the pattern of writing data beyond allocated bounds is conceptually similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The system (Oniguruma) is different. The vulnerability type (CWE-787 Out-of-bounds Write) is identical. The root cause (improper validation of input values leading to invalid array indexing) is conceptually similar to the target code's risk of indexing `szLineConv` based on unchecked `i` and `j` values during complex UTF-8 byte analysis.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      }
    ]
  },
  "CVE-2021-37652_after_exclude_100:897b8637:vulspec": {
    "timestamp": "2026-01-17T02:22:15.135282",
    "cve_id": "CVE-2021-37652",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "897b8637",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code involves TensorFlow resource management and parsing, with no cryptographic operations, side-channel concerns, or mathematical computations related to elliptic curves. The vulnerability types (CWE-200, CWE-385) and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve DNSSEC, cryptographic algorithm validation, or trust anchor management. The core flaw (CWE-327 leading to CWE-476) is not present; the target code's error handling does not involve NULL pointer dereference from unsupported algorithms.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve error handling paths, but the vulnerability types differ. CVE-2011-3603 is about improper input validation (CWE-20) leading to unnecessary privileges (CWE-250) during privilege separation failure. The target code's error path (after `InitFromSerialized` fails) carefully releases resources (`Unref`, `release`) to prevent UAF before returning an error, showing more robust handling. The similarity is only in the general concept of managing failure states.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve database query planning, privilege checks, or access control (CWE-284). It is a TensorFlow kernel for initializing a tree ensemble resource, with no user/privilege differentiation.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The primary vulnerability is a NULL pointer dereference (CWE-476) due to stack pairing violation. The target code does not involve a push/pop stack or transparency handling. While both involve resource/state management, the patterns and flaw mechanisms are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve parsing DNS tokens, buffer management, or out-of-bounds writes (CWE-787). It uses standard TensorFlow input retrieval and proto parsing.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve parsing ISO9660 archives, calculating file positions, or integer overflows (CWE-190). The operations are on serialized protobuf data and resource handles.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve low-level buffer management for network data, sentinel values, or string function misuse (CWE-119). It uses TensorFlow's abstraction for tensors and resources.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve regular expression compilation, character class parsing, or out-of-bounds reads (CWE-125) due to NUL bytes. It processes serialized protocol buffers.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Both involve input validation, but the context and flaw are different. CVE-2017-18248 is about improper UTF-8 validation (CWE-20) in usernames causing encoding errors. The target code validates a serialized proto via `InitFromSerialized` and handles the failure, but the input type (binary proto vs. string), validation mechanism, and consequence (crash vs. error return) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18248"
        }
      }
    ]
  },
  "CVE-2021-40574_after_exclude_100:6c712836:vulspec": {
    "timestamp": "2026-01-17T02:22:17.234957",
    "cve_id": "CVE-2021-40574",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6c712836",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The target code is the exact function `gf_text_get_utf8_line` from the GPAC framework, which is the vulnerable component in CVE-2018-20760. The vulnerability type (CWE-787: Out-of-bounds Write), the attack surface (text file input with malformed encoding), and the key flaw (improper handling of error return codes and unsafe buffer copies) are identical. The code patterns, including the use of `strcpy` and the manipulation of the `szLineConv` buffer, directly match the historical case.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The system (MiniSSDPd), domain (network service discovery), and vulnerability type (CWE-416: Use After Free) are completely different from the target code, which is a text encoding conversion function in a multimedia framework. There is no overlap in functionality or flaw patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-13224"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2011-1003"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      }
    ]
  },
  "CVE-2021-37652_before_exclude_100:48fbad19:vulspec": {
    "timestamp": "2026-01-17T02:22:20.672483",
    "cve_id": "CVE-2021-37652",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "48fbad19",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code involves resource initialization and management in a machine learning framework (TensorFlow), with no cryptographic operations, side-channel concerns, or low-level mathematical computations like elliptic curve point multiplication. The vulnerability types (CWE-200, CWE-385) and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-7511"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not involve DNSSEC, cryptographic algorithm validation, or complex key processing. The core flaw (CWE-327 leading to CWE-476) is tied to a specific DNS subsystem, while the target code's error handling is related to parsing a serialized protocol buffer and managing a resource.",
        "case_metadata": {
          "cve_id": "CVE-2018-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The only tangential similarity is in error handling and control flow continuation. CVE-2011-3603 involves continuing execution with elevated privileges after a security mechanism (privsep) fails. The target code also has a conditional check on error status (`ALREADY_EXISTS`) and continues execution. However, the vulnerability types (CWE-20, CWE-250 vs. potential resource management issues) and contexts (privilege separation vs. kernel op creation) are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2011-3603"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve query planning, database statistics, or privilege checks on database objects. The vulnerability (CWE-284) is specific to PostgreSQL's access control model for system catalogs, which has no parallel in the provided TensorFlow kernel code.",
        "case_metadata": {
          "cve_id": "CVE-2019-10128"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve a state stack (like a transparency stack), push/pop operations, or graphical file format parsing. The NULL pointer dereference (CWE-476) in Ghostscript arises from a corrupted internal state machine, while the target code's potential for a NULL dereference would be more conventional (e.g., from an invalid pointer). The contexts are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-10218"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve parsing complex, nested textual structures from untrusted data (like DNS tokens). The primary vulnerability (CWE-787) is a direct buffer overflow in a parser, while the target code's main operation is deserializing a protobuf. The attack surfaces (network data parsing vs. ML model loading) and code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-25035"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not perform arithmetic calculations on file offsets or positions derived from untrusted data. The integer overflow (CWE-190) in libarchive is specific to ISO9660 image parsing. The target code's parsing is handled by protobuf libraries, which have different failure modes.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not implement low-level memory buffer management or string handling. The vulnerability (CWE-119) in Tor is specific to its custom buffer abstraction and sentinel values. The target code uses standard C++ and TensorFlow abstractions for resource management, presenting a different attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve parsing regular expressions or complex string patterns with embedded special characters (like NUL). The out-of-bounds read (CWE-125) in Perl is tied to its regex compilation engine. The target code's input is a serialized protobuf, where parsing logic is delegated to a library.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. This is the most relevant case. Both involve improper input validation (CWE-20) leading to a crash. CVE-2017-18248 fails to validate UTF-8 in a username before passing it to another subsystem (D-Bus). The target code accepts a serialized `tree_ensemble_serialized` input and passes it to `InitFromSerialized()`. If this function does not robustly handle all malformed inputs, it could lead to a crash or other undefined behavior (e.g., memory corruption) when the parsed data is used later. The pattern of accepting external input and delegating parsing to a function with potentially insufficient validation is similar. However, the specific contexts (printing system vs. ML framework) and the nature of the invalid data (UTF-8 vs. protobuf) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-18248"
        }
      }
    ]
  },
  "CVE-2022-25258_before_exclude_100:1fd9edb6:vulspec": {
    "timestamp": "2026-01-17T02:23:59.200306",
    "cve_id": "CVE-2022-25258",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1fd9edb6",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to out-of-bounds write in a VNC file transfer protocol handler. The target code is a USB gadget composite setup handler dealing with control requests, descriptors, and interface management. The domains (USB vs VNC), vulnerability patterns (integer overflow/wraparound vs potential buffer length mismanagement), and code structures are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network service discovery daemon related to improper cleanup of allocated structures. The target code manages USB control requests with careful state locking (spin_lock) and does not show obvious dynamic allocation/free patterns in the critical path. The vulnerability class and context are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a buffer overflow in a kernel FUSE ioctl handler due to insufficient validation of iovec lengths. The target code also handles data transfer (USB control requests) and performs length checks (e.g., `min(w_length, ...)`). Both involve kernel-level data copying with user/device-supplied length fields. However, the specific mechanisms (ioctl vs USB EP0), data structures (iovec vs USB requests), and vulnerability patterns (direct overflow vs bounded copies) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code is a USB driver setup function with no regex parsing or similar string processing logic. The vulnerability types and code domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code parses USB control requests (a form of protocol) and validates lengths (e.g., checking w_length against USB_COMP_EP0_BUFSIZ). Both involve parsing structured messages from an external source. However, the target code appears to use bounded copies (`min`) consistently, reducing direct overflow risk, and the contexts (kernel USB vs user-space packet analyzer) are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds write in a text encoding conversion utility. The target code does not perform complex text encoding conversions. The vulnerability patterns and functional domains share no meaningful overlap.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 is a NULL pointer dereference in the Linux USB/IP subsystem due to insufficient validation of URB fields. The target code is also in the Linux kernel USB subsystem (gadget/composite driver). Both handle USB request structures and must validate incoming request fields. The target code extracts fields like w_length, w_index, w_value from a USB control request and has various validation gates (e.g., checking bRequestType). While the specific flaw (NULL dereference vs other issues) and component (USB/IP vs USB gadget) differ, the domain similarity and need for robust validation of external device-provided data provide valuable reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a race condition leading to a NULL pointer dereference in the kernel keyring subsystem. The target code uses spinlocks (`spin_lock(&cdev->lock)`) in some paths (e.g., set_config, set_interface) to protect critical sections, showing awareness of concurrency issues. However, the primary focus of the target code is request processing, not complex shared resource initialization prone to races like in the keyring case. The similarity is limited to the general kernel programming practice of using locking.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds write in a regex library due to invalid octal escape values. The target code contains no regex compilation or character class processing logic. No meaningful similarity exists.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a race condition in the kernel TTY subsystem leading to buffer overflow. The target code uses spinlocks, indicating concurrency considerations. Both are kernel subsystems handling asynchronous events (USB requests, TTY writes). However, the TTY flaw involves a specific buffer management race between a workqueue and direct writes, a pattern not evident in the linear, request-response style USB control transfer handling shown in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2022-25258_after_exclude_100:e3514cc4:vulspec": {
    "timestamp": "2026-01-17T02:24:07.468536",
    "cve_id": "CVE-2022-25258",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e3514cc4",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow leading to out-of-bounds write in a VNC file transfer protocol. The target code is a USB gadget composite setup handler dealing with control requests, buffer sizes, and descriptor management. The domains (USB vs VNC), vulnerability patterns (integer overflow/write vs potential buffer over-read/race), and code structures are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free in a network service discovery daemon due to improper resource cleanup. The target code manages USB control requests with careful state locking (spin_lock) and does not show similar dynamic allocation/free patterns that could lead to use-after-free. The attack surfaces and error handling patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves buffer overflow in a FUSE ioctl handler due to insufficient validation of iovec lengths. The target code also performs length validation (e.g., `min(w_length, ...)`) and copies data to buffers. However, the context is different (USB control requests vs FUSE ioctl), and the target code appears more defensive with bounds checking. The similarity is in the general pattern of validating user-controlled length fields.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code handles USB descriptors and strings but uses length-limited operations like `memcpy` with calculated sizes. While both process external input, the vulnerability pattern (string parsing with embedded NULs vs structured protocol requests) and code constructs differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds read in a network protocol parser due to insufficient TLV length validation. The target code validates lengths in USB descriptor requests (e.g., `min(w_length, ...)`). Both involve parsing structured protocols with length fields, but the domains (USB vs LDP) and specific validation patterns differ. The target code's validation appears more robust.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves out-of-bounds write in a text encoding converter due to unhandled error returns. The target code handles binary USB requests with explicit error paths (`goto done`, `break`). The code patterns (character conversion vs request state machine) and vulnerability triggers (encoding errors vs malformed requests) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20760"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 is a NULL pointer dereference in the USB/IP subsystem due to insufficient validation of URB fields. The target code is also in the USB subsystem (gadget driver) and validates request fields (bRequestType, w_index bounds). Both handle USB protocol data, but the target code deals with gadget-side control requests while Case 7 deals with USB/IP virtualization. The pattern of validating USB request structures is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a race condition leading to NULL pointer dereference in the kernel keyring subsystem. The target code uses spinlocks (`spin_lock(&cdev->lock)`) to protect critical sections when modifying configuration state. Both involve kernel synchronization, but the contexts (USB gadget setup vs keyring management) and race patterns (concurrent setup requests vs concurrent keyring creation) are different.",
        "case_metadata": {
          "cve_id": "CVE-2013-1792"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds write in a regex library due to invalid octal escape values. The target code processes numeric fields (w_value, w_index) but validates them against bounds (MAX_CONFIG_INTERFACES). The domains (text processing vs USB protocol) and vulnerability mechanisms (integer overflow in array index vs buffer bounds) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-9226"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a race condition in the TTY subsystem leading to buffer overflow. The target code uses locking for configuration changes but handles atomic request processing. Both are kernel subsystems requiring concurrency management, but the synchronization patterns (spinlocks for configuration vs TTY buffer locks) and data flow (synchronous control requests vs asynchronous echo workqueue) differ substantially.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      }
    ]
  },
  "CVE-2020-12674_before_exclude_100:d064254f:vulspec": {
    "timestamp": "2026-01-17T02:24:17.701960",
    "cve_id": "CVE-2020-12674",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d064254f",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The target code and CVE-2018-20750 both involve parsing a length field from a network/data stream and allocating a buffer based on that length. The core vulnerability pattern is identical: insufficient validation of the relationship between the length value, the current pointer (`p`), and the buffer end (`end`). In the target code, the check `if (p + len > end)` is vulnerable to integer overflow/wraparound (CWE-190) if `len` is very large (e.g., close to `UINT_MAX`), causing the sum to wrap around and bypass the check, leading to an out-of-bounds write (CWE-787) via `memcpy`. This is the exact flaw chain described in Case 1.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      }
    ]
  },
  "CVE-2020-12674_after_exclude_100:80a6eba4:vulspec": {
    "timestamp": "2026-01-17T02:24:24.829172",
    "cve_id": "CVE-2020-12674",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "80a6eba4",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve parsing a length field from a network/data stream and allocating a buffer based on that length. The target code's check `p + len > end` is a bounds check similar to what would be needed to prevent the integer overflow/wraparound (CWE-190) and out-of-bounds write (CWE-787) seen in CVE-2018-20750. The vulnerability pattern of \"read length -> allocate buffer -> copy data\" is identical, making this a highly valuable reference for validating the safety of the target code's arithmetic and checks.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-3179 is a Use-After-Free (CWE-416) vulnerability related to error handling and inconsistent state management in a service daemon. The target code is a simple buffer reading function with straightforward allocation and copy, no complex state or error paths that could lead to UAF. The core flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-18313 is an out-of-bounds read (CWE-125) in a regex compiler due to improper NUL byte handling. The target code reads a length-prefixed buffer and performs a bounds check (`p + len > end`). While both involve preventing reads past a boundary, the domain (regex parsing vs. generic data reading), attack vector (embedded NULs vs. integer length), and vulnerability root cause are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2017-14151 is a buffer overflow (CWE-119) due to insufficient allocation (padding). The target code's core operation is allocating a buffer (`p_malloc(pool, len)`) and copying data into it (`memcpy`). The relevance lies in the critical pattern of allocating based on a derived size and copying data, where an incorrect size calculation (not present in the simple target code) would lead to a similar overflow. The target code's validation is the key safety measure against this class of flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-14151"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2018-14461 is an out-of-bounds read (CWE-125) due to insufficient validation of a TLV length field. This is directly analogous to the target code, which reads a length byte (`len = *p++`) and must validate that `p + len > end` is false before proceeding. The vulnerability pattern of parsing an untrusted length and using it to access a buffer is identical. The target code's check is the essential mitigation for this type of vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-1833 is an out-of-bounds read in an XML parser due to complex multi-byte character encoding state issues. The target code performs simple bounds-checked memory copying of a byte array. While both tangentially relate to buffer bounds, the target code's logic is trivial and linear compared to the intricate state machine and encoding logic vulnerable in the libxml2 case.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Similar to case 6, CVE-2016-1838 is an out-of-bounds read in an XML parser during end-tag processing, involving parser state and complex document structure. The target code is a generic data buffer reader with no parsing logic. The similarity is only at the high level of \"memory safety\" but not in code pattern, domain, or flaw mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2016-1838"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-10675 is a Use-After-Free (CWE-416) due to a race condition in kernel memory policy locking. The target code is a simple, synchronous function for reading a buffer, with no concurrency, complex resource lifecycle, or locking mechanisms. The vulnerability categories are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-10675"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18249 is a race condition (CWE-362) in a filesystem's node ID management. The target code has no concurrency, no shared state, and no resource management beyond a single allocation and copy. The flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-8860 involves improper buffer restriction (CWE-119) in a network buffer manager, leading to potential overreads. The target code also manages buffer reading and copying. The relevance is in the shared domain of network/data buffer handling and the need for precise bounds checking. However, the Tor vulnerability is more about missing sentinel values and string function misuse, whereas the target code's flaw would be a classic buffer overflow/overread if its bounds check were flawed.",
        "case_metadata": {
          "cve_id": "CVE-2016-8860"
        }
      }
    ]
  },
  "CVE-2022-28389_before_exclude_100:9026c71a:vulspec": {
    "timestamp": "2026-01-17T02:24:47.183564",
    "cve_id": "CVE-2022-28389",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9026c71a",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves integer overflow/wraparound leading to out-of-bounds write in a network protocol parser. The target code is a CAN bus USB driver transmit function that copies data from a kernel sk_buff into a USB message structure. There is no complex integer arithmetic for allocation sizes, and the data source (skb->data) is validated by `can_dropped_invalid_skb`. The vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in a FUSE ioctl handler due to insufficient validation of iovec lengths. The target code performs a bounded copy (`memcpy(usb_msg.data, cf->data, usb_msg.dlc)`) where `dlc` is derived from `cf->len` (CAN frame data length, max 8). While both involve copying data to a driver/component, the attack surface (malicious userspace server vs. network packet), validation context, and overflow mechanism (length summation vs. fixed small copy) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is a race condition in a filesystem's node ID management. The target function `mcba_usb_start_xmit` is a network device transmit handler typically called under lock (netdevice tx queue lock). It allocates a context via `mcba_usb_get_free_ctx` which may have concurrency aspects, but the core vulnerability pattern (race in metadata state management) is not evident in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 is an out-of-bounds read in a protocol parser due to insufficient length validation. The target code parses and restructures a CAN frame ID field, but all operations are on fields within the `skb->data` which points to a `struct can_frame`. The kernel's CAN subsystem and `can_dropped_invalid_skb` provide initial validation. However, both involve parsing and reformatting protocol fields from network data, sharing a conceptual similarity in processing untrusted input, though the specific flaw type (OOB read) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a use-after-free due to error handling and uninitialized state. The target code has an error path (`xmit_failed`) that frees resources (context, skb), but it follows a clear, linear failure flow after a failed transmission. There is no complex state management or double-free pattern visible.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code deals with binary CAN data, not string parsing. The `memcpy` uses a length (`dlc`) that is not derived from string semantics. The vulnerability domains are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a race condition leading to buffer overflow in the TTY layer. The target code is a network driver transmit function. While both are kernel subsystems handling data transmission, the concurrency model (TTY line discipline workqueue vs. netdevice queue) and the mechanism for overflow (concurrent writers to a shared buffer vs. a single copy to a local struct) are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Similar to Case 4, this is an out-of-bounds read in a protocol parser (tcpdump) due to incorrect field size handling. The target code also parses protocol fields (CAN ID) and performs bitwise operations and unaligned writes. The relevance is in the pattern of parsing network packet data, though the target code is in a kernel driver with different memory safety guarantees and does not exhibit the specific OOB read flaw.",
        "case_metadata": {
          "cve_id": "CVE-2018-14466"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is a NULL pointer dereference in the Linux Kernel USB/IP subsystem due to insufficient validation of URB fields. The target code is in a USB CAN driver. Both are kernel USB device drivers handling data transmission. The target code validates the SKB via `can_dropped_invalid_skb` and checks for a free context, but does not explicitly show validation of the `cf->data` pointer before the `memcpy`. If `cf->data` were NULL but `cf->len` (dlc) > 0, the `memcpy` would fault. This mirrors the insufficient validation pattern in Case 9, though the specific trigger (null buffer with positive length) and subsystem (USB/IP vs. USB CAN) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is an out-of-bounds read in a protocol parser (tcpdump) due to missing length validation. As with Cases 4 and 8, the relevance lies in the common theme of parsing network-provided data. The target code's parsing of the CAN ID and data length is more structured, relying on the kernel CAN framework's initial validation. The reference value is in emphasizing the need for careful validation of all fields derived from the network packet.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      }
    ]
  },
  "CVE-2022-28389_after_exclude_100:124ed1c9:vulspec": {
    "timestamp": "2026-01-17T02:25:52.650161",
    "cve_id": "CVE-2022-28389",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "124ed1c9",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves an integer overflow leading to an out-of-bounds write in a VNC file transfer protocol handler. The target code is a CAN bus USB driver transmit function that performs data copying with a fixed, validated length (cf->len, max 8 for CAN frames). No complex integer arithmetic or dynamic memory allocation is present that could lead to similar overflow/wraparound issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-20750"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in a FUSE ioctl handler due to insufficient validation of iovec lengths. The target code copies a fixed amount of data (usb_msg.dlc, derived from cf->len) into a fixed-size array (usb_msg.data). While both involve data copying, the target code's copy length is inherently bounded by the CAN protocol (dlc  8), and there is no equivalent to an attacker-controlled iovec structure. The validation mechanisms and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2010-4650"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is a race condition in a filesystem's node ID management. The target code is a network device transmit function that operates in a single execution context (called from the network stack) and manages its own context objects (mcba_usb_ctx). There is no evident shared resource accessed without proper synchronization that could lead to a similar concurrency flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 is an out-of-bounds read in a network protocol parser due to insufficient validation of a length field. The target code also processes network data (CAN frames) but is a transmitter, not a parser. The primary similarity is the handling of structured data from an untrusted source (the skb). However, the vulnerability pattern (missing bounds check on a parsed length) is not present in the target code, which uses the pre-validated `cf->len`.",
        "case_metadata": {
          "cve_id": "CVE-2018-14461"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a use-after-free caused by complex error handling and inconsistent state management in a daemon. The target code has a simple error path (`xmit_failed`) that frees resources consistently. There is no dynamic memory management of complex structures with interdependent pointers that could lead to a similar state corruption issue.",
        "case_metadata": {
          "cve_id": "CVE-2016-3179"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is an out-of-bounds read in a regex compiler due to improper NUL byte handling. The target code copies data using `memcpy` with a bounded length. While both use `memcpy`, the target code's source (`cf->data`) and length are well-defined by the kernel's CAN subsystem, and there is no parsing of string-like data where embedded NULs could cause misinterpretation of length.",
        "case_metadata": {
          "cve_id": "CVE-2018-18313"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a race condition leading to buffer overflow in the TTY subsystem between concurrent writers. The target code is a network driver's transmit function. Although both are kernel drivers, the target function is called under the netdevice's transmit lock, preventing concurrent execution on the same queue. The structure of the code and the concurrency model are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2014-0196"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is an out-of-bounds read in a network protocol parser due to incorrect field size handling (32-bit read on 16-bit field). The target code reads and manipulates bitfields from `cf->can_id` but does so using standard C operations and `put_unaligned_be16` for well-defined, fixed-size fields. The risk of misinterpreting field sizes exists in both, but the target code's operations are on local integers derived from a kernel-provided structure, not directly on packet bytes.",
        "case_metadata": {
          "cve_id": "CVE-2018-14466"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 9 is a NULL pointer dereference in a USB/IP driver due to insufficient validation of URB fields. The target code is also a USB driver (CAN over USB) that passes a message (`usb_msg`) to a USB transmission function (`mcba_usb_xmit`). Both are USB device drivers in the kernel handling data transmission. The key similarity is the need to validate the state and content of data structures before passing them to lower-level USB functions. While the specific flaw (null `transfer_buffer`) is not present, the pattern of validating driver-specific context and message integrity before submission is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-16914"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is an out-of-bounds read in a network protocol parser due to missing length validation before accessing a specific TLV field. The target code handles a different network protocol (CAN) and is a transmitter, not a parser. The core similarity is the general principle of validating structure fields (like `cf->len`) before using them to control operations (like `memcpy`). The target code does this implicitly via `can_dropped_invalid_skb`, but the validation depth is a common concern.",
        "case_metadata": {
          "cve_id": "CVE-2017-13054"
        }
      }
    ]
  },
  "CVE-2021-33909_before_subset_100:eda1afb6:vulspec": {
    "timestamp": "2026-01-17T02:26:14.033893",
    "cve_id": "CVE-2021-33909",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "eda1afb6",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 is a double-free vulnerability in a userspace library (libguestfs) related to file content processing and error handling. The target code is a simple kernel memory allocator wrapper (kvmalloc). The vulnerability type, context (userspace vs kernel), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an integer overflow leading to an infinite loop in a filesystem block mapping function. The target code performs a straightforward memory allocation with no arithmetic, loop constructs, or block management logic. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in a reverse engineering tool's analysis data structure cleanup. The target code is a single allocation function in the kernel with no deallocation or complex structure management involved. The contexts and flaw mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow in a network driver due to incorrect feature declaration and fragment handling. The target code is a generic memory allocator. While both are in the Linux kernel, the subsystem (networking vs core memory), vulnerability type (buffer overflow vs allocation wrapper), and code complexity are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is an integer overflow in a kernel audio subsystem leading to incorrect memory allocation size. The target code also involves memory allocation (kvmalloc). There is a tangential connection through the theme of allocation, but the flaw mechanism (integer overflow in parameter calculation vs simple allocation wrapper), attack surface (ioctl vs internal function), and context (sound subsystem vs generic seq_buf) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow in QEMU's virtio-serial device emulation due to missing size checks on guest-provided descriptors. The target code is a kernel memory allocator. The environments (hypervisor vs kernel), vulnerability patterns, and functionalities are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a race condition in a filesystem's node ID management. The target code is a non-atomic allocation function. Both are in the kernel, but the flaw type (concurrency bug vs simple function), subsystem (F2FS vs core), and code logic are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to use-after-free in the TTY subsystem. The target code has no concurrency or deallocation logic. The vulnerability patterns (timing, pointer management) are not present in the simple allocator wrapper.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow in a SCSI driver due to missing length validation. The target code performs allocation but includes no input parsing or buffer operations. The driver-specific vulnerability pattern does not relate to the generic allocator.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a buffer bounds issue in PHP's GD library due to incorrect arithmetic validation. The target code is a kernel allocator with no arithmetic or buffer manipulation. The languages, domains, and flaw root causes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2021-33909_after_subset_100:3471d20b:vulspec": {
    "timestamp": "2026-01-17T02:26:38.690184",
    "cve_id": "CVE-2021-33909",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3471d20b",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a simple memory allocation function with a size check. Case 1 (CVE-2013-2124) involves a double-free vulnerability in a user-space library (libguestfs) related to complex error handling and file processing. The vulnerability type (CWE-415), domain, and code patterns are fundamentally different. The target code shows no sign of memory deallocation or ownership transfer issues.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Case 2 (CVE-2017-18257) involves an integer overflow leading to an infinite loop in a filesystem block mapping function. The target code performs a size check (`size > MAX_RW_COUNT`) which is a form of integer validation to prevent excessive allocation, but it is a simple bounds check, not an arithmetic operation vulnerable to overflow/wraparound. The context (kernel memory allocator helper vs. filesystem block calculation) and the specific flaw pattern are different, showing only a superficial similarity in performing a size validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 3 (CVE-2018-12320) is a use-after-free leading to double-free in a reverse engineering framework's data structure cleanup. The target code is a pure allocation function (`seq_buf_alloc`) with no deallocation logic, linked structures, or pointer management. The vulnerability types (CWE-416) and code patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 4 (CVE-2015-5156) is a buffer overflow in a network driver due to incorrect feature declaration and insufficient buffer allocation. The target code also involves memory allocation but is a generic allocator helper. The similarity is weak: both involve ensuring sufficient memory is allocated. However, the target's check is a simple guard against overly large single allocations, while CVE-2015-5156's flaw is a semantic mismatch between declared capabilities and actual allocation logic for a complex data structure (fragmented packets). The vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 7,
        "reasoning": "Case 5 (CVE-2014-9904) is highly relevant. It involves an integer overflow in a kernel subsystem (ALSA) during a size calculation for memory allocation, leading to an incorrect allocation size. The target code is a kernel memory allocation function (`seq_buf_alloc`) that includes a size check to prevent excessively large allocations. The core similarity is the pattern of validating an allocation size in the kernel to prevent memory exhaustion or incorrect allocation. The vulnerability type (CWE-190 related to size checks) and the context (kernel memory allocation path) are strongly aligned. The target code's check is a simple bounds guard, while CVE-2014-9904's flaw was in a more complex overflow check, but the defensive intent and code location are similar.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 6 (CVE-2015-5745) is a buffer overflow in QEMU due to missing size checking when copying data from guest-controlled descriptors. The target code performs a size check before allocation but does not involve copying data from untrusted sources or managing descriptor chains. The vulnerability type (CWE-120) and the attack surface (parsing untrusted input structures) are not present in the simple allocator.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 7 (CVE-2017-18249) is a race condition in filesystem metadata management. The target code is a straightforward, likely non-concurrent allocation function with no shared state management, locking, or complex state transitions. The vulnerability types (CWE-362) and code patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18249"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 8 (CVE-2016-0723) is a race condition leading to use-after-free in the TTY subsystem. The target code has no concurrency mechanisms, no pointer sharing, and no deallocation logic. The vulnerability patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 9 (CVE-2016-7425) is a buffer overflow in a kernel driver due to insufficient validation of a user-controlled length parameter. The target code also validates a size parameter (`size > MAX_RW_COUNT`). This represents a moderate relevance: both are in the kernel, both perform validation on a size value to prevent memory safety issues. However, the target code's check is a simple upper bound, while CVE-2016-7425's flaw was a missing check entirely on a length used for a copy operation. The vulnerability type (CWE-119) is related, but the manifestation (overflow during copy vs. rejecting large allocation) and context (driver IOCTL vs. generic allocator) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Case 10 (CVE-2016-8670) is an improper bounds check in an image library due to arithmetic underflow. The target code performs a bounds check (`size > MAX_RW_COUNT`). The weak relevance lies in both functions performing a check on a size/remain value. However, the target's check is a simple comparison, not an arithmetic operation vulnerable to underflow. The domain (PHP image processing vs. kernel memory allocator) and the specific flaw (underflow leading to negative value misinterpretation vs. large size rejection) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2022-23566_before_subset_100:35405ae6:vulspec": {
    "timestamp": "2026-01-17T02:26:50.448389",
    "cve_id": "CVE-2022-23566",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "35405ae6",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs shape inference and context management in a machine learning framework (likely TensorFlow). Case 1 is a double-free vulnerability in a virtual disk image library related to file content processing and error handling. The domains (ML graph processing vs. VM disk I/O), vulnerability types (logic error vs. memory corruption), and code patterns (safe getter/setter vs. manual memory management) are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 2 is an injection vulnerability (CRLF) in a printing system's PPD file generation. The target code is a simple setter function in a shape inference engine, performing no string processing, input parsing, or command generation. The attack surfaces (network protocol vs. internal API) and flaw nature (input validation vs. state management) are unrelated. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 3 is an XXE vulnerability in an XML parser. The target code deals with internal graph node shapes and has no functionality for parsing external data formats, resolving entities, or processing untrusted input files. The vulnerability class (external entity expansion) and context are completely dissimilar. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 4 is a use-after-free/double-free in a reverse engineering tool's linked structure cleanup. The target code shows no dynamic memory allocation, pointer manipulation, or structure traversal. It manages shape handles within a context object. While both involve internal data structure management, the specific memory corruption patterns and lifecycle issues are not present in the target. Weak relevance at best.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Case 5 is a resource exhaustion vulnerability due to lack of validation between declared and actual data size in an image decoder. The target code has a validation check (`ctx == nullptr`) but does not handle numeric inputs or perform allocations based on untrusted data. The broader theme of input validation and preventing invalid state is somewhat similar, but the specific vulnerability mechanism is not. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 6 is a path validation issue in an archive library leading to filesystem race conditions. The target code operates on abstract graph nodes and shapes, not filesystem paths. The core flaw of improper input validation is a high-level similarity, but the domain-specific manifestations (pathnames vs. graph ports/contexts) and consequences are entirely different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 7 is an improper initialization vulnerability in a network packet dissector, leaving state uninitialized on error paths. The target code includes a check for a null context, which is a form of state validation to prevent use of an uninitialized/invalid context. The pattern of checking for a valid object/context before performing operations is conceptually similar. However, the target code's error path returns early and does not leave partial state, making it safer. Moderate relevance due to the shared theme of validating internal state before use.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 6,
        "reasoning": "Case 8 is a reachable assertion due to insufficient validation of a numeric input field. The target code validates that `ctx` is not null but does not validate the `output_port` parameter against bounds (e.g., is it less than `ctx->num_outputs()`?). This pattern of missing validation on input arguments (especially indices) that are used to access internal data structures is similar. The potential consequence in the target code could be an out-of-bounds write if `ctx->set_output` uses the port index unsafely. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 9 is a use-after-free in a mail server related to memory ownership during message processing. The target code shows no manual memory management, allocation, or release. It works with handle-based objects managed by a larger framework. The vulnerability patterns and memory lifecycle concerns are not applicable. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 10 is a heap buffer overflow due to an off-by-one error in a path expansion function. The target code performs no string manipulation, buffer allocation, or arithmetic calculations that could lead to boundary errors. The code patterns and vulnerability classes are completely distinct. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-23566_after_subset_100:c3a93b49:vulspec": {
    "timestamp": "2026-01-17T02:26:52.797129",
    "cve_id": "CVE-2022-23566",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c3a93b49",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory corruption vulnerability in a file processing library. The target code is a shape inference utility performing bounds checking and setting an output shape. There is no similarity in vulnerability type (CWE-415 vs. potential logic/validation errors), domain (VM disk image processing vs. tensor shape inference), or code patterns (memory management vs. API parameter validation).",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in a printing system's PPD file generation. The target code performs input validation (bounds checking on `output_port`) and sets a data structure field. The domains (printing protocol vs. computational graph shape inference), vulnerability types (CWE-93 vs. potential bounds error), and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an XXE (XML External Entity) vulnerability in a parsing library. The target code is a simple validation and assignment function within a shape inference context. There is no similarity in vulnerability type (CWE-611 vs. potential out-of-bounds access), functionality (parsing untrusted data vs. internal API), or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a use-after-free/double-free vulnerability in a reverse engineering tool related to linked list cleanup. The target code has no dynamic memory allocation, deallocation, or pointer manipulation. It performs a bounds check and a setter operation. The vulnerability classes (CWE-416 vs. potential logic error) and code constructs are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 is an uncontrolled resource consumption (CWE-400) vulnerability due to lack of validation between declared image dimensions and actual data. The target code *does* perform validation (bounds check on `output_port`), which is the defensive practice missing in Case 5. The relevance is only in the abstract theme of input validation, but the context (image parsing vs. shape inference), vulnerability type, and code patterns are very different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 6 is an improper input validation (CWE-20) leading to path traversal issues in an archive library. The target code also performs input validation (bounds checking). This is the only point of similarity. The specific vulnerability (path manipulation), domain (filesystem operations vs. tensor shape management), and resulting impact are completely different. The validation in the target code is simple integer bounds checking, not complex path/string validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an improper initialization (CWE-665) leading to uninitialized memory exposure in a network packet parser. The target code does not deal with uninitialized memory or complex state machines. It validates a parameter and calls a setter. The domains (kernel networking vs. ML framework), vulnerability patterns, and code constructs share no similarities.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak to moderate relevance. Case 8 is a reachable assertion (CWE-617) due to insufficient validation of a numeric input field (`number_meta_channels`). The target code performs validation of a numeric input (`output_port`) against bounds (`ctx->num_outputs()`). The similarity lies in the pattern of validating an integer parameter before use. However, the contexts differ (image file parsing vs. internal API), and the consequence in Case 8 is an assertion failure, while the target code returns an error status. The validation logic itself is conceptually similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a use-after-free (CWE-416) in a mail server related to memory ownership during header processing. The target code has no dynamic memory allocation or freeing, dealing only with stack/local objects and pointer parameters. The vulnerability type, domain, and code patterns are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a heap buffer overflow (CWE-122) due to an off-by-one error in a path expansion function. The target code performs a bounds check to prevent an out-of-bounds access, which is the correct mitigation for such errors. However, the target code itself is not vulnerable to an overflow; it's the defensive code. The domains (libc pathname matching vs. ML shape inference) and specific code patterns (string manipulation vs. integer validation) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-29199_before_subset_100:2b8f7631:vulspec": {
    "timestamp": "2026-01-17T02:27:44.464299",
    "cve_id": "CVE-2022-29199",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2b8f7631",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-9499 involves an assertion failure due to insufficient input validation of a numeric field. The target code performs validation (OP_REQUIRES) on input sizes but does not have assertions. The vulnerability type (CWE-617) and trigger conditions (malicious file input causing a crash) are different from the target code's focus on tensor remapping and loading.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-11470 involves uncontrolled resource consumption due to lack of validation between declared dimensions and actual data. The target code validates tensor dimensions (e.g., checking `col_remapping.size() == num_cols_`) and uses bounds checking for indices. Both involve validating size fields from input, but the target code's context (tensor loading with remapping) and specific flaw (memory exhaustion vs. bounds checking) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection in generated PPD files. The target code processes tensor data and checkpoint files but does not generate configuration files or involve command injection. The vulnerability type (CWE-93) and attack surface (protocol response parsing) are unrelated to the tensor operations in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in file content processing error paths. The target code manages C++ objects and containers (vectors, unordered_maps) with automatic destruction, and does not show manual memory management or double-free patterns. The flaw type (CWE-415) and context (guest disk inspection) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-8670 involves improper bounds checking leading to out-of-bounds read/write due to arithmetic issues. The target code performs bounds checking (e.g., `new_row < num_rows_ && new_col < num_cols_`) but also has loops and index calculations (e.g., `row_index`, `initializing_values_index`) that could potentially have off-by-one or overflow issues if inputs are malicious. The similarity lies in the need for rigorous index validation in data processing code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-12667 is a memory leak in error handling paths of a file parser. The target code uses RAII patterns (C++ containers) and does not show explicit resource management that could leak. The vulnerability type (CWE-401) and context (MAT-file parsing) are not relevant to the tensor loading logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-5418 involves improper input validation leading to path traversal issues. The target code validates tensor dimensions and indices but also reads from a file path (`ckpt_path`). While both involve input validation, the target code's file reading is via a trusted `BundleReader` and the primary flaw pattern (path manipulation) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-18257 involves integer overflow leading to an infinite loop. The target code has integer calculations (e.g., `max_old_row - row_start + 1`, slice length calculations) and loops that depend on these values. While no obvious overflow is present, the pattern of using input-dependent values in loop conditions shares some similarity with the vulnerability's root cause (CWE-190).",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in a linked structure. The target code uses standard C++ containers and does not manually manage linked lists or have similar deallocation logic. The vulnerability type (CWE-416) and data structures are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-18609 involves integer overflow in size calculation leading to buffer overflow. The target code has size validations (e.g., checking `row_remapping.size() == num_rows_`) and uses signed integers (`int64_t`) for indices and sizes. While no obvious overflow exists, the pattern of calculating slice lengths and indices based on user input shares conceptual similarity with the need to prevent integer overflows in memory/range calculations.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      }
    ]
  },
  "CVE-2022-29199_after_subset_100:8d0da41f:vulspec": {
    "timestamp": "2026-01-17T02:27:57.259495",
    "cve_id": "CVE-2022-29199",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8d0da41f",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves an assertion failure due to insufficient validation of numeric input in an image processing library. The target code performs numeric validation (e.g., checking tensor dimensions, bounds checking for new_row/new_col) and is not in an image processing context. The vulnerability patterns (reachable assertion vs. potential out-of-bounds access) and domains differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves uncontrolled resource consumption due to lack of validation between declared image dimensions and actual data size, leading to excessive memory allocation. The target code validates tensor dimensions against expected sizes (num_rows_, num_cols_) and uses controlled slicing (max_rows_in_memory_) to manage memory. While both involve dimension validation, the core flaw (unbounded allocation vs. bounded, validated allocation) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves CRLF injection/command injection via insufficient validation of protocol attribute values. The target code processes tensor data and file paths but does not generate or parse textual protocol data where injection could occur. The vulnerability types (injection vs. memory/bounds issues) and domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a double-free vulnerability in a file reading utility due to ownership semantics violation during error handling. The target code uses C++-style resource management (tensors, vectors) and does not exhibit manual memory management patterns that could lead to double-free. The flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 involves improper bounds checking leading to out-of-bounds read/write due to arithmetic underflow/overflow. The target code performs several bounds checks (e.g., `new_row < num_rows_ && new_col < num_cols_`). However, it also contains loops and indexing based on user-controlled inputs (row_remapping, col_remapping). While the target code has validation, a similar pattern of insufficient validation on indices derived from user input could lead to out-of-bounds access. The context differs (image processing vs. tensor loading), but the core issue of bounds validation is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a memory leak in an image file parser during error handling. The target code uses stack-allocated containers (vector, unordered_map) and Tensor objects which likely have RAII semantics, making memory leaks less probable. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 involves improper input validation leading to path traversal or symlink issues in an archive extractor. The target code reads a file path (`ckpt_path`) but does not appear to perform extensive path validation or create filesystem links. The vulnerability types (filesystem vs. memory/bounds) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 involves an integer overflow leading to an infinite loop in a filesystem block mapping function. The target code uses int64_t for indices and sizes and has loops that depend on user-controlled values (e.g., row_remapping size). While no obvious integer overflow is present, the pattern of calculating ranges (`max_old_row - row_start + 1`) and loop conditions based on user data shares some conceptual similarity. The specific overflow-to-loop flaw is not directly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a use-after-free/double-free due to improper cleanup of linked structures. The target code uses standard containers and does not manually manage linked lists or have obvious use-after-free patterns. The vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 involves an integer overflow in frame size calculation leading to out-of-bounds write. The target code uses int64_t and performs arithmetic (e.g., `max_old_row - row_start + 1`, `slice_length` calculations) that could theoretically overflow if inputs are malicious, but the values are derived from tensor dimensions which are validated and likely bounded. The pattern of size calculation leading to allocation/indexing is conceptually similar, but the target code's context and validation reduce the direct relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      }
    ]
  },
  "CVE-2021-3751_before_subset_100:54fc979b:vulspec": {
    "timestamp": "2026-01-17T02:28:23.036826",
    "cve_id": "CVE-2021-3751",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "54fc979b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) related to memory ownership and cleanup in error paths. The target code performs a memory move operation with bounds checking and does not involve dynamic memory allocation, deallocation, or ownership transfer.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is about uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data, leading to excessive memory allocation. The target code performs a bounded memory move with size checks and does not involve parsing untrusted file headers or allocating memory based on unvalidated inputs.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 3 is an improper restriction of operations within a memory buffer (CWE-119) due to incorrect bounds checking, specifically an arithmetic underflow issue. The target code performs similar buffer offset arithmetic and bounds checks (`buf->offset + aoffset + len > buf->maxlen` and `buf->offset < aoffset`). The pattern of validating offsets and lengths before a memory operation (memmove) is directly comparable. The primary difference is the specific underflow trigger, but the vulnerability class and defensive coding pattern are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a use-after-free (CWE-416) leading to a double-free, related to linked structure cleanup. The target code does not involve freeing memory or managing pointer-based data structures; it only moves data within a pre-allocated buffer.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 5 is a buffer overflow (CWE-119) due to insufficient validation of user-controlled length parameters before memory operations. The target code's core function is to safely move data within a buffer, and its central security concern is validating the `offset` and `len` parameters against the buffer's bounds (`buf->maxlen`) to prevent an out-of-bounds read or write via `memmove`. The code patterns (bounds check then memory operation) and the vulnerability type are closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 is a heap-based buffer overflow (CWE-122) due to an off-by-one error in allocation calculations. While the target code also performs bounds checking to prevent buffer overflows, its checks are for a move operation within an existing buffer, not for calculating an allocation size. The relevance lies in the common theme of precise bounds calculation being critical for memory safety, but the implementation context and error pattern differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves an integer overflow (CWE-190) in a size calculation leading to incorrect memory allocation. The target code uses `size_t` for lengths and performs addition (`buf->offset + aoffset + len`), which could theoretically overflow, but this is a standard buffer overflow prevention check, not an allocation size calculation. The connection is tenuous, focusing only on the arithmetic operation aspect.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 involves an integer overflow (CWE-190) leading to an infinite loop. The target code performs integer addition in its bounds check but is not in a loop and is not calculating a block count or size that would cause a wraparound to a small value. The relevance is limited to the general concept of integer arithmetic in safety checks.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an XML External Entity (XXE) injection vulnerability (CWE-611). The target code is a low-level buffer manipulation function with no relation to parsing, external entities, or network/data formats.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an CRLF injection/command injection vulnerability (CWE-93) in a printer protocol handler. The target code deals with raw memory buffers and has no relation to protocol parsing, string neutralization, or command execution.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      }
    ]
  },
  "CVE-2013-0157_before_subset_100:a5a4affe:vulspec": {
    "timestamp": "2026-01-17T02:28:23.315284",
    "cve_id": "CVE-2013-0157",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a5a4affe",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk image inspection library (libguestfs) triggered by processing malicious files. The target code is a mount utility command-line parser and executor. The domains (filesystem mounting vs. VM disk inspection), vulnerability types (memory corruption vs. command-line parsing and privilege checks), and attack surfaces (local command execution vs. crafted disk images) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parsing library (libxml2). The target code does not parse XML or any complex, untrusted data formats. It parses command-line arguments and mounts filesystems. The vulnerability patterns (improper restriction of external entities) and attack surfaces (malicious document input vs. command-line/system call interface) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in a binary analysis tool (radare2) related to linked list cleanup. The target code is a utility that manages command-line options and calls libmount functions. It does not implement complex data structures like basic block graphs, and its memory management is largely handled by the libmount library. The flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a heap buffer overflow in glibc's glob() function due to incorrect size calculation during path expansion. The target code uses path arguments but does not perform wildcard expansion itself; it passes them to the kernel or libmount. While both deal with filesystem paths, the specific vulnerability mechanism (off-by-one in a library function) is not present in the shown code, which focuses on argument parsing and delegation.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a race condition leading to use-after-free in the kernel TTY subsystem. The target code is a userspace utility. While both involve system interfaces (ioctl vs. mount syscall), the concurrency model and vulnerability class are entirely different. The mount utility is a single-process, sequential program, not a kernel driver susceptible to concurrent access races. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a buffer overflow in a kernel SCSI driver due to missing bounds checks on user-controlled length fields. The target code parses command-line strings but does not perform low-level buffer copies based on untrusted size values. The attack surface (kernel driver ioctl vs. command-line utility) and the code's responsibility for memory safety are at different levels of the stack.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is an improper neutralization of CRLF sequences leading to injection in CUPS. The target code handles user-provided strings (e.g., via -o option) and passes them to the kernel/libmount. There is a tangential similarity: both process untrusted input that could influence subsequent operations. However, the target code does not generate script/configuration files like the PPD files in CUPS, making direct command injection less likely. The reference is limited to the general principle of validating option strings.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 involves improper path validation in libarchive during extraction, potentially leading to symlink/hardlink issues. The target code is a mount utility that also deals with paths (source, target). While it doesn't extract archives, it must handle paths safely, especially with options like --bind, -B, -R. The code shows path canonicalization control (-c flag) and source/target setting. The relevance lies in the shared domain of filesystem operations and the need for secure path handling, though the specific vulnerability pattern differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a use-after-free in an MTA (Exim) related to BDAT command and header processing. The target code has no network parsing functionality, no complex state machine for processing streaming data, and a much simpler memory management model. The systems and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is a buffer overflow in a kernel USB network driver related to DMA and stack allocation. The target code is a userspace application with no driver-level buffer management or DMA operations. The only vague similarity is that both interact with kernel subsystems (USB networking vs. filesystem mounting), but the vulnerability mechanisms are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      }
    ]
  },
  "CVE-2013-0157_after_subset_100:d8f0d1dc:vulspec": {
    "timestamp": "2026-01-17T02:28:24.837726",
    "cve_id": "CVE-2013-0157",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d8f0d1dc",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk image inspection library (libguestfs) triggered by processing malicious file content. The target code is a mount utility command-line parser and executor. The domains (VM disk inspection vs. filesystem mounting), vulnerability types (memory corruption vs. potential logic/privilege issues), and code patterns (file content parsing vs. option parsing and system calls) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parsing library (libxml2). The target code does not parse XML or any complex, untrusted file formats. It parses command-line arguments and interacts with the mount system call and libmount library. The attack surfaces (malicious XML documents vs. command-line arguments from a privileged user) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in a reverse engineering tool's (radare2) analysis data structures, triggered by a malicious binary file. The target code is a straightforward CLI tool with linear execution flow, managing command-line options and calling libmount functions. It does not involve complex, linked data structures prone to circular references or similar memory management pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a heap buffer overflow in glibc's glob() function due to incorrect path expansion. The target code uses path arguments (source/target) but does not perform wildcard expansion itself; it passes them to libmount. The potential security concern in the target code regarding paths is more about canonicalization and privilege checks (seen in `sanitize_paths` and `mnt_context_is_restricted`), not buffer overflows in path processing logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a kernel race condition (use-after-free) in the TTY subsystem. The target code is a userspace utility. While both involve system interfaces (ioctl vs. mount syscall via libmount), the vulnerability class (concurrency flaw in kernel driver) is not applicable to the single-threaded, sequential command parsing of the mount utility. The only weak link is that both are part of system administration tools interacting with kernel subsystems.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow in a specific Linux kernel SCSI driver due to lack of input validation on SCSI commands. The target code is a userspace application. The context (kernel driver vs. userspace CLI tool), attack vector (crafted hardware commands vs. command-line arguments), and code complexity are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is a CRLF injection/command injection in CUPS during PPD file generation from network data. The target code also processes external input (command-line options) and passes it to critical system operations (mounting). While the specific flaw (CRLF injection) is not present, the broader theme of validating and sanitizing untrusted input before it influences privileged operations is relevant. The `sanitize_paths` function indicates awareness of this class of issue.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 involves improper path validation in libarchive during extraction, leading to potential symlink/hardlink attacks. The target code's `sanitize_paths(cxt)` function, called when the user is restricted, directly addresses this concern by preventing traversal attacks when setting mount source/target. Both deal with validating filesystem paths provided by users before performing sensitive operations (extraction vs. mounting). The vulnerability pattern (path traversal/symlink attack) is a relevant consideration for the mount utility.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a use-after-free in the Exim MTA related to complex memory management during SMTP BDAT command processing. The target code has simple, linear memory allocation (e.g., `srcbuf` via `xasprintf`) and immediate freeing, with no complex state or reference counting that could lead to a use-after-free. The domains (mail server vs. mount utility) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a buffer overflow in a Linux kernel USB network driver. Similar to Case 6, this is a kernel driver vulnerability unrelated to the userspace mount utility code. The attack surface (malicious USB device) and code context are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      }
    ]
  },
  "CVE-2021-3751_after_subset_100:ef1c0b2e:vulspec": {
    "timestamp": "2026-01-17T02:29:35.957014",
    "cve_id": "CVE-2021-3751",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ef1c0b2e",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) related to memory ownership and cleanup in error paths. The target code performs a memory move operation with bounds checking and error flagging, but does not involve dynamic memory allocation, deallocation, or pointer ownership issues central to double-free flaws.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is about uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data, leading to excessive memory allocation. The target code performs a bounded memory move with explicit size checks against a fixed buffer maxlen, focusing on buffer bounds, not resource exhaustion from untrusted size inputs.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 3 (CVE-2016-8670) is primarily CWE-119 (Improper Restriction of Operations within Bounds of a Memory Buffer) involving incorrect bounds checking that can lead to out-of-bounds read/write. The target code's core function is to perform a safe memmove within a buffer, with explicit bounds checks for both positive and negative offsets. The pattern of validating `buf->offset + len` against `buf->maxlen` is directly analogous to buffer overflow/underflow prevention. The key difference is the target code uses `abs(offset)` and separate conditionals, but the vulnerability class and defensive intent are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a use-after-free (CWE-416) leading to double-free, involving linked structure cleanup and pointer manipulation. The target code operates on a contiguous data buffer with no dynamic object lifecycle or pointer indirection issues. The memory operation is a simple memmove on a static buffer range.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 5 (CVE-2016-7425) is a buffer overflow (CWE-119) due to insufficient validation of user-controlled length parameters before memory operations. The target code's primary purpose is to prevent buffer over/underflow by validating `offset` and `len` against `buf->maxlen`. The pattern of checking source/destination ranges before memmove is directly relevant to preventing the type of flaw in Case 5. The main difference is the target code works on an internal buffer with a known maxlen, while the driver accepts an external length parameter.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 (CVE-2017-15670) is a heap-based buffer overflow (CWE-122) due to an off-by-one error in allocation calculations. The target code also performs bounds checking to prevent buffer overrun, and a subtle off-by-one error in its conditions (e.g., `buf->offset + aoffset + len > buf->maxlen`) could lead to a similar flaw. The relevance is strong in the category of bounds checking errors, though the target code does not involve dynamic memory allocation.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 involves an integer overflow (CWE-190) in size calculations leading to incorrect memory allocation. The target code uses `size_t` for lengths and offsets and performs addition checks (`buf->offset + aoffset + len`). While integer overflow in these additions could bypass the checks, the code does not perform any multiplication or allocation based on calculated sizes. The relevance is limited to the general theme of arithmetic validation.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves an integer overflow (CWE-190) leading to an infinite loop. The target code uses addition with `size_t` (unsigned) so overflow would wrap, potentially causing the bounds check to pass incorrectly. This is a tangential similarity, but the primary flaw patterns (loop condition vs. buffer bounds check) and consequences are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 9 is an XML external entity (XXE) vulnerability (CWE-611). The target code is a low-level buffer manipulation function with no parsing, entity handling, or network/data format processing. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 10 is an injection vulnerability (CWE-93) due to improper neutralization of CRLF sequences in IPP attributes. The target code performs binary buffer movement with no interpretation of content, protocol handling, or string processing. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      }
    ]
  },
  "CVE-2016-2087_before_subset_100:f7d3b96d:vulspec": {
    "timestamp": "2026-01-17T02:29:41.711513",
    "cve_id": "CVE-2016-2087",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f7d3b96d",
    "scores": [
      {
        "score": 3,
        "reasoning": "CWE-93 (CRLF injection) is about improper neutralization of special elements in output. The target code uses `strcpy`/`strcat` on a fixed buffer with user-controlled input (`extensions_str`), which is a classic buffer overflow pattern, not CRLF injection. The functional domains (IRC client vs. printing system) and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "CWE-415 (Double Free) is a memory management flaw. The target code performs string operations on a stack buffer and has no dynamic memory allocation or freeing logic within the shown function. The core vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "CWE-611 (XXE) involves parsing malicious XML documents with external entities. The target code parses a space-separated string list for IRC capabilities. The functionality, data format, and vulnerability class (injection vs. buffer overflow) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "CWE-125 (Out-of-bounds Read) involves reading beyond buffer boundaries. The target code's primary risk is writing out-of-bounds (buffer overflow via `strcat`). While both involve memory safety, the specific flaw (read vs. write), context (network packet parsing vs. string construction), and root cause are only weakly similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 7,
        "reasoning": "CWE-119 (Buffer Overflow) is highly relevant. The target code uses `strcat` to concatenate user-controlled strings (`extensions_str`) into a fixed-size stack buffer (`buffer[256]`) without checking length. This is a classic stack-based buffer overflow vulnerability pattern, similar to the kernel driver's buffer overflow from unchecked input. The main differences are the context (user-space IRC client vs. kernel driver) and the specific trigger (string concatenation vs. length parameter).",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "CWE-416 (Use After Free) involves incorrect memory reference after deallocation. The target code uses only stack buffers and string functions, with no heap allocation or pointer management that could lead to a use-after-free. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 6,
        "reasoning": "CWE-119 (Buffer Overflow) is relevant. Both involve a stack buffer overflow risk. The target code's overflow is via unchecked `strcat` on a user-controlled string, while the kernel driver's is via improper DMA buffer handling. The core vulnerability class is the same, but the mechanisms and contexts (user-space string processing vs. kernel USB driver) differ moderately.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 4,
        "reasoning": "CWE-125 (Out-of-bounds Read) involves reading past buffer limits. The target code's flaw is primarily an out-of-bounds write risk. Both are memory safety issues arising from insufficient validation of input (length fields vs. number of extension strings), but the specific violation (read vs. write) and domain (packet dissection vs. string building) limit relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 3,
        "reasoning": "CWE-665 (Improper Initialization) leads to uninitialized memory use. The target code initializes its variables (`buffer` contents are written, `want_cap`, `want_sasl` are set). Its flaw is lack of bounds checking, not initialization. The vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "CWE-190 (Integer Overflow) leads to an infinite loop. The target code uses integer flags (`want_cap`, `want_sasl`) but does not perform arithmetic that could overflow. Its primary flaw is string buffer overflow. The vulnerability classes are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-7542"
        }
      }
    ]
  },
  "CVE-2016-2087_after_subset_100:d8fd07c6:vulspec": {
    "timestamp": "2026-01-17T02:30:04.189114",
    "cve_id": "CVE-2016-2087",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d8fd07c6",
    "scores": [
      {
        "score": 3,
        "reasoning": "CWE-93 (CRLF injection) is not relevant. The target code uses `g_strlcat` with explicit size limits for buffer concatenation and sends data via `tcp_sendf`. While there is a `strcpy` at the beginning, it copies a fixed string. The primary concern in the target code is potential buffer overflow, not CRLF injection leading to command execution.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "CWE-415 (Double Free) is not relevant. The target code does not perform dynamic memory allocation or freeing within the shown function. It uses stack-allocated buffers and `g_strsplit`/`g_strfreev` for string array management, which is a standard GLib pattern not indicative of the double-free flaw described.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "CWE-611 (XXE) is not relevant. The target code processes a space-separated string of IRC capability names, not XML data. There is no parsing of hierarchical markup or external entity references. The functionality and data format are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "CWE-125 (Out-of-bounds Read) has weak relevance. The target code does not directly exhibit an out-of-bounds read. However, it does involve parsing a string array (`extensions`) and concatenating strings into a fixed-size buffer (`buffer[256]`). The risk is an out-of-bounds *write* (buffer overflow) if the concatenated string exceeds the buffer size, which is a related memory safety issue but with a different primary CWE (CWE-120/CWE-119).",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 7,
        "reasoning": "CWE-119 (Buffer Overflow) has moderate relevance. The target code's primary vulnerability pattern is a classic stack-based buffer overflow risk. It uses `strcpy` to initialize a buffer and then `g_strlcat` in a loop. While `g_strlcat` is bounds-checked, the initial `strcpy` is safe as it copies a fixed string. The real risk is the preceding logic: if `extensions_str` contains many or long capability names, the loop could concatenate more data than the fixed `buffer[256]` can hold, leading to overflow. This pattern of building a command/request string in a fixed buffer based on variable input is conceptually similar to the kernel driver's buffer management flaw.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "CWE-416 (Use After Free) is not relevant. The target code shows no evidence of complex pointer management, reference counting, or memory release that could lead to a use-after-free scenario. Memory management is handled via stack variables and GLib helpers with clear ownership.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "CWE-119 (Buffer Overflow) has weak relevance. The relevance is similar to Case 5 but weaker. Case 7 specifically involves a stack buffer overflow in a kernel driver due to improper DMA buffer handling. The target code's potential overflow is more straightforward: building a string in a fixed-size stack buffer (`buffer[256]`) based on user/network input (`extensions_str`). The context (user-space IRC client vs. kernel driver) and trigger mechanisms are different, but the core flaw of exceeding a stack buffer's bounds is shared.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 4,
        "reasoning": "CWE-125 (Out-of-bounds Read) has weak relevance. Similar to Case 4, the connection is indirect. The target code's risk is buffer overflow (write), not an out-of-bounds read. Both involve parsing network/protocol data (IRC CAP LS vs. BGP AIGP TLV) but the specific memory safety violation differs. The parsing loop over `extensions` array could be seen as analogous to parsing TLV fields, but bounds checking is done via null-termination, not length fields.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 3,
        "reasoning": "CWE-665 (Improper Initialization) is not relevant. The target code clearly initializes its key variables (`buffer` content is set via `strcpy`, `want_cap = FALSE`, `want_sasl = FALSE`). There is no evidence of uninitialized structs or variables being used. The vulnerability pattern does not match.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "CWE-190 (Integer Overflow) is not relevant. The target code uses integer `i` for array indexing and `gsize x` for loop control, but these are bounded by the null-terminated `extensions` array. There are no arithmetic operations on user-controlled integers that could wrap around. The loop's termination condition is based on string pointers, not calculated lengths.",
        "case_metadata": {
          "cve_id": "CVE-2017-7542"
        }
      }
    ]
  },
  "CVE-2010-0433_before_subset_100:da1a168f:vulspec": {
    "timestamp": "2026-01-17T02:30:08.084980",
    "cve_id": "CVE-2010-0433",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "da1a168f",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file content processing function within a VM disk inspection library. The target code is a Kerberos keytab availability check function that performs resource lookups and cleanup. Both involve C resource management, but the vulnerability type (double-free vs. potential NULL/error handling), domain (VM inspection vs. security/authentication), and code patterns (file I/O and string processing vs. Kerberos API calls) are fundamentally different. The error handling pattern in the target code uses `goto exit` with centralized cleanup, which is a safer pattern than the flawed one in the historical case.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parsing library. The target code performs Kerberos keytab operations with no parsing of untrusted data formats, no entity expansion, and operates in a completely different domain (authentication vs. document processing). The attack surfaces and flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves CRLF injection leading to command injection during PPD file generation in a printing system. The target code performs read-only checks on a local Kerberos keytab file. There is no generation of structured text files, no command execution, and no injection of control characters. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a heap buffer overflow due to an off-by-one error in path expansion. The target code uses high-level Kerberos library APIs (krb5_kt_get_entry, etc.) for lookup operations. There is no manual string manipulation, array indexing, or memory allocation based on untrusted input sizes that could lead to similar boundary calculation errors. The resource management is handled by the Kerberos library.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a use-after-free/double-free in a reverse engineering tool due to improper linked list cleanup. The target code also manages resources (Kerberos context, keytab, principal, entry) and has cleanup paths. There is a superficial similarity in the need for proper cleanup in error conditions. However, the target code uses a simple `goto exit` pattern with null checks, and the resources are opaque objects from a library, not complex internal linked structures prone to the same circular reference flaw. The risk level and pattern are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an integer overflow leading to an infinite loop in a filesystem driver. The target code performs sequential API calls with error checking. There are no arithmetic operations on untrusted integers, no loops whose conditions depend on calculated values, and the domain (kernel filesystem vs. user-space authentication) is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 is a NULL pointer dereference in a database connection pooler during authentication state handling. The target code is also in the authentication domain (Kerberos) and involves checking resource (keytab) availability. Both functions are steps in an authentication pipeline. The relevance comes from the shared domain and the potential for state/error handling flaws. However, the specific vulnerability pattern (missing check for a NULL `auth_user` pointer) is not directly mirrored in the target code, which checks return codes from Kerberos APIs. The target code's `princ` variable could be NULL if `krb5_sname_to_principal` fails, but it is checked before use in `krb5_kt_free_entry` and is only freed if non-NULL, suggesting safer practices.",
        "case_metadata": {
          "cve_id": "CVE-2015-4054"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to use-after-free in a kernel TTY subsystem. The target code is a user-space function performing a one-time, synchronous check for keytab availability. There is no concurrency, no shared state accessed via ioctl, and no reference-counted objects where timing issues could arise. The vulnerability patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an uncontrolled resource consumption (memory) vulnerability in an image parser due to lack of validation of dimensions from file headers. The target code reads a configuration path (`kssl_ctx->keytab_file`) and a service name, but these are not untrusted file format fields that dictate large memory allocations. The Kerberos library handles the internal parsing of the keytab file format. The attack surface and flaw pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 involves improper input validation and error handling in an LDAP query translator within an authentication-adjacent service (Samba). The target code also exists in the security/authentication domain (Kerberos). Both involve queries to a security database (keytab, LDAP). The moderate relevance stems from the shared domain and the importance of robust error handling in security-critical code. However, the specific flawfailure to handle a NULL return from a string transformation functionis not present in the target code, which propagates error codes from the Kerberos library. The target code's error handling, while using `goto`, appears consistent.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      }
    ]
  },
  "CVE-2010-0433_after_subset_100:443a9d89:vulspec": {
    "timestamp": "2026-01-17T02:30:11.966991",
    "cve_id": "CVE-2010-0433",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "443a9d89",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 is a double-free vulnerability in a file processing function. The target code is a Kerberos keytab availability check that performs clean resource management (krb5_kt_free_entry, krb5_kt_close, krb5_free_principal, krb5_free_context) with a clear ownership and cleanup path in its exit block. No double-free pattern is present.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parser. The target code performs local Kerberos keytab operations using the krb5 library. There is no parsing of untrusted data formats, no entity expansion, and the functionality domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a CRLF injection leading to command injection in a PPD file generator. The target code performs authentication checks using a trusted system API (Kerberos). It does not generate structured text files, embed user input into commands, or process network protocol data in a way that could allow injection.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a use-after-free/double-free in a linked structure cleanup. The target code manages simple, non-linked resources (context, keytab, principal, entry) with a linear cleanup routine. While both involve resource cleanup, the target code's pattern is straightforward and does not involve complex pointer relationships or circular references that could cause a use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an integer overflow leading to an infinite loop in a filesystem block mapping function. The target code performs simple integer return code checks and has no loops or arithmetic operations on untrusted size values. The domains (filesystem vs. authentication) and flaw patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a NULL pointer dereference due to a protocol state violation. The target code also performs authentication-related checks and has multiple error-handling goto paths. There is a potential similarity in the risk of missing a NULL check on a structure member (e.g., `kssl_ctx->service_name` is used after a ternary check, but `kssl_ctx` itself is not checked). However, the trigger condition (protocol sequence violation) is not present here, and the code pattern is less complex.",
        "case_metadata": {
          "cve_id": "CVE-2015-4054"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to use-after-free in a kernel driver. The target code is a user-space library function with no concurrency mechanisms (no locks, threads, or shared state). It operates on local variables and library handles, making race conditions irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an uncontrolled resource consumption (memory) due to unvalidated image dimensions. The target code does not parse complex file headers or allocate memory based on untrusted size values. It relies on the Kerberos library to handle keytab entries, which internally validates data.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an improper input validation leading to a NULL dereference in an LDAP query translator. The primary similarity is the pattern of a library function (`krb5_sname_to_principal`) returning an error that might not be fully validated before proceeding, though the target code does check `krb5rc`. The deeper flaw in Case 10 involves complex query transformation failure, which is not mirrored in the simpler, linear control flow of the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      }
    ]
  },
  "CVE-2022-23593_before_subset_100:a0daa45a:vulspec": {
    "timestamp": "2026-01-17T02:31:12.582317",
    "cve_id": "CVE-2022-23593",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a0daa45a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs shape analysis and simplification for tensor broadcasting, involving symbolic expression comparison and safe value extraction. Case 1 is a double-free vulnerability in a virtual disk file reading function, involving complex memory ownership and error handling. The domains (compiler/tensor analysis vs. VM disk access), vulnerability types (logic error vs. memory corruption), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an injection vulnerability (CRLF sequences leading to command injection) in a printing system's PPD file generator. The target code is a mathematical shape analysis function that processes symbolic dimensions and constructs new tensor shapes. There is no parsing of untrusted text, no command generation, and no injection vectors. The code patterns and security concerns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in a reverse engineering framework's linked list cleanup. The target code operates on immutable value ranges and analysis results, performing comparisons and constructing new IR operations. It does not involve manual memory management, pointer manipulation, or deallocation of complex data structures. The vulnerability class and code context are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The only tangential similarity is that both codes process structured input (image dimensions vs. tensor shapes). However, the vulnerability in Case 4 is a resource exhaustion issue due to lack of validation between declared size and actual data. The target code validates symbolic expressions and uses safe builder APIs; it does not allocate memory based on unvalidated user input. The risk profile and code patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 involves an assertion failure triggered by an out-of-bounds input value. The target code also processes numeric/symbolic dimensions but performs equality checks (`isConstant(1)`, `!=`) and uses controlled builder methods. It does not have assertions on input values that could be disabled in production. The potential flaw would be a logic error (incorrect shape simplification), not a reachable assertion.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a path validation and filesystem race condition vulnerability during archive extraction. The target code performs pure computation on shape values within a compiler context; it does not interact with the filesystem, handle paths, or create links. The domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a heap buffer overflow due to an off-by-one calculation in path expansion. The target code uses high-level MLIR builder operations and LLVM containers; it does not perform manual buffer allocation or pointer arithmetic. The code patterns and memory safety concerns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an uninitialized memory exposure in a network packet parser. The target code initializes all local containers (SmallVector) and operates on already-analyzed symbolic expressions. It does not parse raw byte streams or leave state uninitialized. The contexts (kernel networking vs. compiler mid-end) and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is a buffer overflow due to integer underflow in image processing. The target code uses index calculations (`maxRank - dim.index() - 1`), which, if incorrect, could lead to out-of-bounds access within the `joined_dimensions` vector. However, the indices are derived from container sizes and reverse iteration, making underflow/overflow less likely. The code uses safe SmallVector access (via `[]`), not raw pointer arithmetic. The similarity is limited to potential index miscalculation.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an XXE vulnerability in an XML parser. The target code does not parse any external data formats, resolve external entities, or process markup languages. It works on internal compiler IR values and analysis results. There is no meaningful overlap in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      }
    ]
  },
  "CVE-2022-23593_after_subset_100:0a3258ff:vulspec": {
    "timestamp": "2026-01-17T02:31:33.282752",
    "cve_id": "CVE-2022-23593",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0a3258ff",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs symbolic shape analysis and simplification for tensor broadcasting. It involves logic and memory-safe operations on symbolic expressions and values. Case 1 (CVE-2013-2124) is a double-free vulnerability in a file processing module of libguestfs, involving raw pointer management and error handling. The domain (compiler/tensor analysis vs. VM disk inspection), vulnerability type (logic/API misuse vs. memory corruption), and code patterns (high-level MLIR builder ops vs. low-level C memory management) are fundamentally different. Relevance is very low.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 2 (CVE-2017-15400) is an injection vulnerability (CRLF to command) in a printing system's PPD file generator. The flaw stems from improper neutralization of data used in a command context. The target code is a compiler optimization pass that manipulates symbolic dimensions and constructs new IR values; it does not parse, serialize, or execute external data. The attack surfaces (network protocol vs. internal IR), vulnerability classes (injection vs. potential logic error), and code constructs are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 3 (CVE-2018-12320) is a use-after-free/double-free in a reverse engineering framework's basic block analysis, involving manual management of linked data structures. The target code uses LLVM/MLIR's value and builder system, which typically employs RAII and managed ownership, avoiding raw pointer lifecycle issues. The code focuses on algebraic simplification of shapes, not on manual memory management of graph nodes. The core flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 4 (CVE-2019-11470) is a resource exhaustion vulnerability in an image decoder due to lack of validation between declared dimensions and actual data. The target code also processes dimensions but in a purely symbolic, analytical context for compiler optimization. It does not allocate memory based on these dimensions (it extracts existing values). The risk of unbounded allocation is absent. There is a weak similarity in processing dimension-like data, but the vulnerability mechanism and context are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 5 (CVE-2017-9499) is a reachable assertion due to insufficient validation of an input numeric field against a maximum bound. The target code performs comparisons and equality checks on symbolic expressions but does not have explicit assertions or validate external input against fixed limits. The potential flaw in the target code would be a logic error (incorrect simplification) rather than a crash from a failed assertion. The similarity is weak, limited to the general concept of validating values.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 6 (CVE-2016-5418) is a path validation and filesystem race condition vulnerability during archive extraction. The target code operates on in-memory compiler IR with no filesystem interaction, path resolution, or concurrency. The domains and vulnerability classes (filesystem security vs. compiler correctness) are completely different, offering no reference value for the target code's analysis.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 7 (CVE-2017-15670) is a heap buffer overflow due to an off-by-one error in memory allocation calculations in a path expansion function. The target code uses high-level container classes (SmallVector) and builder methods that abstract away manual memory calculations. While buffer overflows are always a risk in C/C++, the specific pattern (off-by-one in tilde expansion) and the code's structure (manual string manipulation vs. symbolic algebra) are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 8 (CVE-2017-13715) is an uninitialized memory exposure in a network packet parser due to improper state cleanup on error paths. The target code has straightforward control flow and initializes its data structures (e.g., SmallVector). It does not parse untrusted binary data with complex state machines or have error paths that skip initialization. The vulnerability pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 9 (CVE-2016-8670) is a buffer bounds violation due to incorrect arithmetic and validation in an image processing library. The target code uses indexing (`i - maxRank + shape_and_rank_for_dim[i].second`) which, if logic were flawed, could lead to out-of-bounds access. However, the indices are derived from previously validated symbolic ranks and are used with `tensor::ExtractOp`, which likely has its own bounds checks. The similarity is weak: both involve index calculations, but the target code's context is higher-level and less prone to raw memory corruption.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 10 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability due to unsafe default processing of external references. The target code does not parse any external data formats, resolve external resources, or have any configuration akin to entity resolution. The vulnerability class and attack surface are entirely unrelated to the symbolic shape analysis being performed.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      }
    ]
  },
  "CVE-2022-23565_before_subset_100:a92cde1c:vulspec": {
    "timestamp": "2026-01-17T02:31:48.907428",
    "cve_id": "CVE-2022-23565",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a92cde1c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine disk image library, related to memory ownership and error handling. The target code performs a comparison of protocol buffer fields using a map, with no dynamic memory allocation, deallocation, or error handling paths that could lead to double-free.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free/double-free vulnerability (CWE-416) in a reverse engineering framework, involving linked list cleanup and circular references. The target code is a simple comparison function operating on provided container references, with no manual memory management or linked data structures.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 3 is an injection vulnerability (CWE-93) in a printing system due to improper neutralization of CRLF sequences. The target code compares attribute definitions in a controlled, internal data structure with no parsing of external input or string injection concerns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a reachable assertion (CWE-617) due to insufficient input validation in an image library. The target code contains a DCHECK (debug assertion) for uniqueness, which could be a reachable assertion if the check fails in a debug build. However, the context (internal data validation vs. file parsing) and vulnerability class differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is a heap buffer overflow (CWE-122) in a C library's path expansion function due to an off-by-one calculation. The target code uses standard C++ containers and performs no low-level memory allocation or buffer manipulation.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an uncontrolled resource consumption vulnerability (CWE-400) in an image decoder due to lack of validation between declared dimensions and file size. The target code operates on already-parsed in-memory data structures with no resource allocation based on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an improper input validation issue (CWE-20) leading to path traversal in an archive library. The target code validates internal data consistency (uniqueness of names) but does not process file system paths or external archive data.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 8 is an XXE vulnerability (CWE-611) in an XML parser. The target code does not parse any external data formats (XML or otherwise) and has no entity resolution mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is an improper input validation issue (CWE-20) in an LDAP server, where a failed string transformation leads to a NULL pointer dereference. The target code includes a check (via find) for the existence of a key in a map, which is a form of validation, but the context (query translation vs. data comparison) and potential consequences (crash vs. logic error) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read (CWE-125) in a network packet parser due to insufficient bounds checking. The target code iterates over standard C++ containers with defined bounds, using iterators, and performs no pointer arithmetic or direct buffer access.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      }
    ]
  },
  "CVE-2017-11600_before_subset_100:79fd0ce1:vulspec": {
    "timestamp": "2026-01-17T02:31:50.556487",
    "cve_id": "CVE-2017-11600",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "79fd0ce1",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file processing. The target code is a Linux kernel network subsystem function (xfrm_migrate) handling state migration with complex error paths. Both involve error handling and resource cleanup, but the domain (kernel vs. userspace), vulnerability pattern (double-free vs. general error path resource management), and attack surface (disk images vs. network policy) are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability (CWE-611) in an XML parsing library. The target code is a kernel function for IPsec state migration with no XML parsing, external entity handling, or similar input validation logic. The domains and vulnerability types are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a use-after-free/double-free (CWE-416) in a reverse engineering tool due to improper linked list cleanup. The target code also manages lists of states (`x_cur`, `x_new`) and has complex error paths (`restore_state`) where cleanup logic is critical. The similarity lies in the need for careful state cleanup in error conditions to avoid memory safety issues. However, the context (kernel network security vs. binary analysis) and specific flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow (CWE-119) in a SCSI driver due to missing length validation. The target code performs policy and state migration with no evident array or buffer operations without bounds checking (arrays are bounded by `XFRM_MAX_DEPTH` and `num_migrate` is checked). The vulnerability class and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow (CWE-119) in a USB driver related to DMA and stack buffers. The target code involves no USB, DMA, or buffer manipulation prone to overflows. The domains and flaw characteristics are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow (CWE-119) in a network driver due to incorrect feature negotiation and fragment handling. The target code is in the XFRM (IPsec) subsystem for policy migration, not packet processing or fragment reassembly. The vulnerability mechanism is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read (CWE-125) in a packet analyzer's protocol parser. The target code does not parse network packet data; it operates on internal kernel objects (policies, states). No relevance in vulnerability type or code pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves improper initialization (CWE-665) leading to information disclosure in a network packet dissector. The target code's `restore_state` error path must correctly manage state objects to avoid leaks or corruption. Both involve careful state management in error conditions. However, the specific flaw (uninitialized struct on stack vs. object lifecycle management) and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a race condition (CWE-362) in KVM error handling between guest levels. The target code's `xfrm_migrate` performs a multi-stage operation (find, update, delete, announce) on kernel networking objects. While not explicitly concurrent, complex multi-step state transitions in kernel space share conceptual similarity with the need for atomicity and consistent state management. Error paths (`restore_state`) must correctly roll back partial changes, analogous to handling race-induced inconsistent states. The vulnerability types differ but the underlying theme of robust state machine handling is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2010-5313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a use-after-free (CWE-416) in a mail server due to improper memory ownership tracking during error/cleanup paths. The target code has a detailed error cleanup path (`restore_state`) where it must `put` and `delete` state objects correctly to avoid reference counting issues or use-after-free. The pattern of acquiring resources (states) and needing to clean them up partially on failure is similar. However, the context (kernel vs. MTA) and specific memory management APIs differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      }
    ]
  },
  "CVE-2017-11600_after_subset_100:b51910d6:vulspec": {
    "timestamp": "2026-01-17T02:31:56.544523",
    "cve_id": "CVE-2017-11600",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b51910d6",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file processing. The target code is a Linux kernel network subsystem function (xfrm_migrate) with complex state migration and cleanup. Both involve error handling and resource cleanup, but the domain (kernel vs. userspace), vulnerability pattern (double-free vs. general error path), and attack surface (disk images vs. network policy) are fundamentally different. Only the broad theme of cleanup on error paths is similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability (CWE-611) in an XML parsing library. The target code is a kernel function for migrating IPsec states and policies. There is no overlap in vulnerability type, domain, or code patterns. The target code does not parse untrusted data formats like XML.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a use-after-free/double-free (CWE-416) in a reverse engineering tool due to improper linked list cleanup. The target code also manages lists of states (`x_cur`, `x_new`) and has complex error paths (`restore_state`) where cleanup of these lists is critical. The similarity lies in the need for careful state management and cleanup of interconnected objects during error conditions. However, the context (kernel security subsystem vs. binary analysis) and specific flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow (CWE-119) in a kernel SCSI driver due to missing bounds checks on user-controlled length parameters. The target code performs policy and state migration with no evident array or buffer operations on untrusted data without bounds checking. The attack surface (SCSI commands vs. XFRM migration control) and flaw type are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow (CWE-119) in a USB network driver related to DMA and stack buffer handling. The target code does not involve USB, DMA, or buffer overflows. The only tangential similarity is that both are kernel drivers, but the subsystems and flaw mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow (CWE-119) in a virtio network driver due to incorrect feature negotiation and fragment handling. The target code is in the XFRM (IPsec) subsystem and deals with policy/state objects, not packet buffers or network offloading features. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read (CWE-125) in a network protocol dissector (tcpdump) due to insufficient validation of length fields. The target code is a kernel function for internal state migration, not parsing untrusted network packet data. Different domains, vulnerability types, and code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an improper initialization (CWE-665) leading to information disclosure in the kernel's flow dissector. The target code's `restore_state` error path performs cleanup but does not obviously leave uninitialized data exposed. The moderate similarity is that both are in the kernel networking sphere and involve careful state management during error conditions. However, the specific flaw (uninitialized data on error path) is not clearly mirrored in the target code's structure.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a race condition (CWE-362) in the KVM subsystem related to error reporting and state synchronization between hierarchical components (L1/L2 guests). The target code manages multiple states (`x_cur`, `x_new`) and policies in a transactional-like manner with a rollback path (`restore_state`). While not a classic concurrency bug, the pattern of acquiring multiple resources (states) and needing atomic commit/rollback to avoid inconsistent system state is conceptually similar. Both involve complex kernel subsystem state management. The vulnerability types differ (race vs. logic/cleanup error), but the reference value for safe multi-object state transitions is present.",
        "case_metadata": {
          "cve_id": "CVE-2010-5313"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is a use-after-free (CWE-416) in Exim due to improper memory ownership tracking during message processing. The target code also tracks ownership of kernel objects (states) references via `x_cur` and `x_new` arrays, and must correctly `put`/`delete` them in various success/error paths. The similarity is in the pattern of managing a collection of referenced objects and ensuring correct cleanup order and ownership semantics to avoid double-free or use-after-free. However, the environment (mail server vs. kernel) and specific APIs differ greatly.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      }
    ]
  },
  "CVE-2022-23565_after_subset_100:40230d9d:vulspec": {
    "timestamp": "2026-01-17T02:32:44.752319",
    "cve_id": "CVE-2022-23565",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "40230d9d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management vulnerability in a virtual disk inspection library. The target code performs a comparison of protocol buffer fields using a map and has no dynamic memory allocation, deallocation, or error handling paths that could lead to double-free issues.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free/double-free vulnerability in a linked structure cleanup within a reverse engineering tool. The target code is a simple comparison function operating on stack/local containers with no manual memory management or linked list traversal that could lead to similar pointer misuse.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      }
    ]
  },
  "CVE-2021-40565_before_subset_100:a7f559e5:vulspec": {
    "timestamp": "2026-01-17T02:33:32.364252",
    "cve_id": "CVE-2021-40565",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a7f559e5",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing binary formats (image vs. video), but the vulnerability types differ significantly. CVE-2019-11470 is about uncontrolled resource consumption (CWE-400) due to lack of validation between declared dimensions and actual data. The target code parses AVC/H.264 NAL units and includes various validation checks (e.g., bounds checking via gf_bs_read functions, state comparisons). The core flaw pattern (unvalidated dimensions leading to excessive allocation) is not present in the provided AVC parsing code.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free (CWE-415) in a file reading utility within a VM inspection library. The target code is a video parser that reads from a bitstream (`GF_BitStream *bs`) and manages internal state (`AVCState *avc`). There is no dynamic memory allocation or deallocation visible in the provided function; it primarily copies structures and calls parsing sub-functions. The memory ownership and cleanup patterns central to the double-free flaw are not apparent here.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE (CWE-611) vulnerability in an XML parser. The target code parses a binary video compression format (AVC/H.264). The domains (structured text vs. binary video), attack surfaces (external entity references vs. bitstream data), and vulnerability patterns (entity expansion vs. buffer/state handling) are fundamentally different. No external resource fetching or recursive expansion logic is present.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-13033 is an out-of-bounds read (CWE-125) in a network protocol dissector. The target code also parses a structured binary format (video NAL units) from a bitstream. Both involve reading fields from an input stream and performing conditional logic. However, the specific trigger in the VTP case (insufficient validation of length fields before memory access) is not directly visible here. The target code uses `gf_bs_read_*` functions which likely include bounds checking, and the primary logic revolves around state comparison rather than direct pointer arithmetic on unchecked lengths.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free (CWE-416) in a reverse engineering framework's analysis structure cleanup. The target code shows no dynamic allocation or freeing of complex linked structures. It works on passed-in state objects and a bitstream. The flaw pattern involving circular references and improper `next` pointer cleanup during deallocation is not applicable to the shown code's logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13715 is an improper initialization (CWE-665) leading to uninitialized memory exposure in a network packet parser. The target code is also a parser for a stream format. Both involve complex state machines. A potential point of similarity is that the target code copies state (`memcpy(&n_state, &avc->s_info, ...)`) and then conditionally updates fields; if the source state (`avc->s_info`) were improperly initialized, it could lead to problems. However, the specific error-path state leakage flaw in the flow dissector is not directly mirrored, and the target code's structure copying seems more controlled.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection (CWE-93) in a printing protocol handler generating configuration files. The target code is a low-level video codec parser. The functionality, data types (textual IPP attributes vs. binary video parameters), and vulnerability class (injection vs. memory corruption/state confusion) are completely dissimilar. No string concatenation or command generation occurs in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7101 is an out-of-bounds read (CWE-125) in an image format parser due to unvalidated dimensions. The target code parses a different binary format (video). Both are in the multimedia parsing domain. The similarity lies in the need to validate values read from the input file/stream (like `nal_unit_type`, `frame_num`) before using them for logic or array indexing. However, the specific mechanism in the SGI coder (large row value causing allocation/access issues) is not directly comparable, as the AVC parser's primary operations are on existing state structures, not large pixel buffers based on dimensions.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-8670 is a buffer bounds violation (CWE-119) in an image processing library due to incorrect arithmetic checks. The target code is also within a multimedia processing context (video). The potential connection is the need for careful bounds checking when reading from the bitstream (`gf_bs_read_*`). If these underlying read functions have flaws similar to the PHP/GD issue (e.g., integer underflow/overflow in size calculations), they could lead to similar problems. However, the provided high-level code does not show the low-level buffer arithmetic, making direct comparison difficult.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-9499 is a reachable assertion (CWE-617) in an image parser due to lack of validation on an input field (`number_meta_channels`). The target code includes an `assert(avc->s_info.sps);` statement. If the `sps` pointer could be NULL when reaching this assert due to earlier parsing errors or malicious input, it could trigger an assertion failure, similar in outcome. However, the contexts are different (image metadata vs. video parameter sets), and the assert in the target code seems to guard a dereference rather than validate an input range. The root cause of missing validation is a broader similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      }
    ]
  },
  "CVE-2021-40565_after_subset_100:5f146953:vulspec": {
    "timestamp": "2026-01-17T02:33:37.799907",
    "cve_id": "CVE-2021-40565",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5f146953",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing binary formats (image vs. video), but the vulnerability types differ significantly. CVE-2019-11470 is about resource exhaustion due to unvalidated dimensions leading to large allocations. The target code parses AVC NAL units and performs many state comparisons and memory copies, but does not show obvious dimension validation flaws or unbounded allocation based on untrusted input. The core flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability related to improper memory ownership and cleanup in error paths. The target code primarily reads and parses data, copies structures, and returns status codes. It does not show complex dynamic memory management, pointer aliasing, or error paths that free the same resource twice. The code patterns and vulnerability class are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XML External Entity (XXE) injection vulnerability. The target code parses a binary video stream (AVC/H.264) and has no XML parsing, entity resolution, or external resource fetching logic. The domains (multimedia vs. document markup) and attack patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing binary protocol/data structures (VTP vs. AVC NAL units). CVE-2017-13033 is an out-of-bounds read due to insufficient validation of length fields before memory access. The target code uses GF_BitStream for reading, which may have internal bounds checking, but there are direct memory copies (`memcpy`) of state structures. A potential similarity lies in parsing untrusted bitstreams where malformed data could lead to state corruption, but the specific OOB read pattern is not evident here.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in a linked structure cleanup. The target code does not show dynamic allocation/deallocation of linked structures like basic blocks. It works on a passed-in `AVCState` pointer and local stack variables. The memory management patterns and flaw type are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13715 involves improper initialization of stack memory in a network dissector after an error path. The target code has a local `AVCSliceInfo n_state` that is initialized via `memcpy` from `avc->s_info`. If `avc->s_info` itself is uninitialized or corrupted, it could propagate bad state. However, the code does not show a clear error path that leaves `n_state` partially uninitialized before use. The similarity is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection in a text-based protocol (IPP) response parser. The target code parses binary video data and does not construct or interpret text-based commands, shell strings, or configuration files. The vulnerability mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Similar to Case 1, both parse binary formats (SGI image vs. AVC video). CVE-2016-7101 is an out-of-bounds read due to unvalidated dimension fields. The target code reads a NAL header and parses slice parameters. While it reads various `ue` (unsigned exponential Golomb) codes and other values, the direct connection to dimension-based memory calculation flaws is not present. The potential for integer overflows in state calculations exists but is not the primary flaw pattern shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-8670 involves improper bounds checking leading to potential buffer over-read/over-write due to arithmetic issues. The target code uses `gf_bs_read_*` functions and `memcpy`. If the bitstream functions or the parsed values (like `last_ps_idx`) are not correctly bounds-checked, they could lead to invalid memory accesses. The pattern of trusting parsed integers without sufficient validation before using them as indices or sizes is a common theme, though not explicitly shown here. The `memcpy` size is fixed (sizeof(AVCSliceInfo)), not dynamic.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-9499 is a reachable assertion due to an unvalidated numeric field. The target code does not contain visible assertions. It does have checks like `if (avc->last_ps_idx < 0) return -1;`, but these are error returns, not assertions that crash. The flaw pattern of missing validation on numeric input is a generic programming issue, but the specific manifestation (assertion crash) is not relevant to this code.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      }
    ]
  },
  "CVE-2014-0178_before_subset_100:393bad68:vulspec": {
    "timestamp": "2026-01-17T02:33:46.634922",
    "cve_id": "CVE-2014-0178",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "393bad68",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file content processing function within a virtual machine inspection library. The target code is an FSCTL (File System Control) dispatcher in a file server (likely Samba), handling structured I/O control requests. The vulnerability types (memory corruption vs. IOCTL validation), attack surfaces (parsing VM disk files vs. processing network file system requests), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parsing library. The target code handles Windows-specific file system control codes (FSCTLs) and does not parse XML or external entities. The domains (file system operations vs. document parsing) and vulnerability classes (input validation, memory management vs. improper restriction of XML entities) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a heap buffer overflow in a pathname pattern matching function (glob) due to an off-by-one error. The target code is a switch-based dispatcher for FSCTL operations, performing data copying and validation. While both involve system-level C code, the core flaw (bounds calculation error) and context (globbing vs. FSCTL handling) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves CRLF injection leading to command injection in a printing system's PPD file generation. The target code also processes external input (FSCTL requests) and performs data copying (e.g., `srvstr_push`). There is a tangential similarity in the need to validate and safely handle untrusted input data that influences output formatting. However, the vulnerability mechanism (injection vs. buffer overflows/validation errors) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a use-after-free/double-free in a reverse engineering framework's basic block analysis. The target code allocates and frees memory using `talloc` routines but manages memory in a relatively straightforward, linear fashion per request. The complex linked list cleanup issue and the resulting state inconsistency are not present in the target code's simpler per-case memory management.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 is an integer overflow in a filesystem's (F2FS) block mapping function for the FIEMAP ioctl, leading to an infinite loop. The target code explicitly handles the `FSCTL_QUERY_ALLOCATED_RANGES` ioctl (a Windows analogue to FIEMAP) and performs arithmetic on user-provided `offset` and `length` values (using `BVAL`), checking for 64-bit integer wrap. This represents a direct functional and attack surface parallel: both process filesystem extent queries, take user-controlled numeric inputs, and must perform safe arithmetic and bounds checking to prevent overflows or logic errors. The vulnerability class (integer handling) is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 is a buffer overflow in a kernel SCSI driver due to insufficient validation of a user-controlled length field. The target code processes numerous FSCTLs, each with its own input data (`_in_data`, `in_len`) and output buffers. It performs length checks (e.g., `if (in_len < 8)`, `if (max_out_len < *out_len)`), but missing or incorrect checks in any case could lead to buffer overflows. The pattern of validating user-supplied sizes before memory operations is a key similarity, though the target code appears more defensive in the shown snippets.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is an uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared image dimensions and actual data. The target code's `FSCTL_GET_SHADOW_COPY_DATA` case allocates memory based on `shadow_data->num_volumes`, which comes from a VFS call. If a malicious VFS module or underlying system provided a huge `num_volumes`, it could lead to excessive allocation similar to CVE-2019-11470. The relevance is indirect, as the primary vulnerability would lie in the VFS layer, not the shown code which trusts its input.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a stack buffer overflow in a USB network driver related to DMA and VMAP_STACK. The target code is user-space file server code handling network requests, not a kernel driver dealing with hardware DMA. The memory models and vulnerability contexts are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is a race condition (use-after-free) in the kernel TTY subsystem's ioctl handling. The target code is a user-space function `vfswrap_fsctl` that handles FSCTL ioctls. While a direct race condition is less likely in this single-threaded-looking dispatcher, the broader pattern is relevant: both are *ioctl/FSCTL handler functions* that must safely manage state and resources (file descriptors, memory) based on concurrent or sequential operations. The target code accesses `fsp` and `fsp->conn` without obvious locking, which could be problematic if called concurrently. The similarity lies in the \"ioctl handler\" archetype and its associated state management challenges.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      }
    ]
  },
  "CVE-2014-0178_after_subset_100:ba180a6e:vulspec": {
    "timestamp": "2026-01-17T02:33:51.205000",
    "cve_id": "CVE-2014-0178",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ba180a6e",
    "scores": [
      {
        "score": 3,
        "reasoning": "The target code handles FSCTL ioctls in a Samba VFS module, focusing on file system control operations. CVE-2013-2124 is a double-free in a virtual disk image inspection library (libguestfs) related to file content processing. The domains (file system control vs. VM disk inspection), vulnerability types (general memory safety vs. double-free in a specific cleanup path), and code patterns are fundamentally different. Only weak similarity exists in that both involve processing external input.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2013-0339 is an XXE vulnerability in an XML parsing library (libxml2). The target code is a Samba VFS module handling Windows FSCTL commands, with no XML parsing functionality. The attack surfaces (malicious XML documents vs. SMB protocol FSCTL requests), vulnerability classes (improper restriction of external entities vs. potential memory/buffer issues in FSCTL handlers), and code contexts are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2017-15670 is a heap buffer overflow in glibc's glob() function due to an off-by-one error in path expansion. The target code performs FSCTL handling with several buffer allocations and length calculations (e.g., in FSCTL_GET_SHADOW_COPY_DATA, FSCTL_QUERY_ALLOCATED_RANGES). There is weak relevance: both involve careful management of output buffer sizes based on input parameters, and miscalculations could lead to buffer overflows. However, the specific trigger (tilde expansion) and domain (libc vs. Samba VFS) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-15400 is a CRLF injection/command injection in CUPS during PPD file generation from IPP attributes. The target code processes FSCTL input data but does not generate script or configuration files from untrusted data in a similar way. The vulnerability pattern (improper neutralization of control sequences) is not evident in the target code, which primarily copies data or returns structured responses. The domains (printing system vs. file server) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free in a reverse engineering framework (radare2) due to improper cleanup of linked structures. The target code uses talloc for memory management and has clean error paths with TALLOC_FREE. While both involve C code and memory management, the specific flaw (circular references in analysis data structures) and context (binary analysis vs. FSCTL dispatch) are not similar. The target code shows no evidence of complex pointer relationships that could lead to a UAF.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 7,
        "reasoning": "CVE-2017-18257 is an integer overflow leading to an infinite loop in the Linux kernel F2FS filesystem's FIEMAP ioctl handler. The target code implements its own handler for FSCTL_QUERY_ALLOCATED_RANGES, which is a similar filesystem ioctl for querying file extents. Both involve processing offset and length inputs (64-bit values in the target code), performing bounds checking, and calculating output ranges. The relevance is moderate: the same class of vulnerability (integer overflow/wraparound in offset/length calculations) could potentially exist in the target's handling, though the specific overflow-to-loop pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7425 is a buffer overflow in a kernel SCSI driver due to insufficient validation of a length field from a (potentially malicious) hardware device. The target code validates input lengths (e.g., checking `in_len` for FSCTL_QUERY_ALLOCATED_RANGES) and output buffer sizes (`max_out_len`). There is weak-to-moderate relevance: both are kernel/driver-level code processing untrusted size fields, requiring careful bounds checking. However, the attack surface differs (local SMB client vs. physical/malicious SCSI device), and the target code appears more defensive in its checks.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2019-11470 is an uncontrolled resource consumption (CWE-400) in ImageMagick due to lack of validation between declared image dimensions and actual data. The target code's FSCTL_GET_SHADOW_COPY_DATA allocates memory based on `shadow_data->num_volumes`, which comes from a VFS call. If a malicious VFS module returned an extremely large `num_volumes`, it could cause excessive allocation. This provides weak relevance: both allocate memory based on untrusted/derived size values. However, the target code has a `max_out_len` check which should limit the impact, and the data source (VFS module) is different from a file parser.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-8068 is a stack buffer overflow in a USB network driver related to DMA buffer handling. The target code performs no DMA operations and uses heap allocation via talloc. Both are in the general category of \"driver/kernel code,\" but the vulnerability mechanism, attack surface (USB device vs. SMB packet), and memory patterns are completely different. No stack buffers are used in the FSCTL data handling paths shown.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 6,
        "reasoning": "CVE-2016-0723 is a race condition (use-after-free) in the kernel tty subsystem involving concurrent ioctl operations. The target function `vfswrap_fsctl` is itself an ioctl handler. While the code shows no obvious shared state or locking issues (it primarily operates on local variables and the `fsp`), the context of handling concurrent ioctl requests on the same file descriptor is similar. A moderate relevance exists because both involve the safety patterns required for ioctl implementations in a multi-threaded environment. However, the specific race condition flaw (accessing a freed ldisc pointer) is not mirrored in the target's simpler switch statement.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      }
    ]
  },
  "CVE-2021-4154_before_subset_100:ae35f13a:vulspec": {
    "timestamp": "2026-01-17T02:34:19.303367",
    "cve_id": "CVE-2021-4154",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ae35f13a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a user-space library (libguestfs) related to file content processing. The target code is a kernel cgroup parameter parsing function with no dynamic memory deallocation, focusing on string validation and flag setting. The vulnerability type, context, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability (CWE-611) in an XML parsing library. The target code parses simple key-value parameters for cgroup configuration, with no XML processing, external entity resolution, or similar complex parsing logic. The domains and attack surfaces are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free (CWE-416) in a reverse engineering tool's data structure cleanup. The target code performs parameter parsing and stores results in a context structure; it does not involve freeing complex linked structures or have similar memory lifecycle management issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 involves CRLF injection (CWE-93) leading to command injection in a printing system. The target code validates parameter strings (e.g., for `Opt_name`) against a character whitelist, which is a form of input neutralization. However, the context (kernel vs. user-space daemon), purpose (configuration vs. file generation), and severity of the injection are vastly different. The similarity is limited to the concept of validating string content.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a heap buffer overflow (CWE-122) in glibc's glob() due to an off-by-one calculation. The target code performs bounds checking on string length (`param->size > MAX_CGROUP_ROOT_NAMELEN - 1`) but does not involve any complex arithmetic for memory allocation or buffer writes that could lead to similar overflow conditions.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an uncontrolled resource consumption (CWE-400) issue in an image decoder due to unvalidated dimensions. The target code validates a name length against a fixed maximum but does not parse any complex binary structures or allocate resources based on untrusted numeric values. The core flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an out-of-bounds read (CWE-125) in a network protocol dissector. The target code parses simple strings and sets flags; it does not parse binary packet structures with length fields, perform pointer arithmetic, or access memory buffers in a way that could lead to out-of-bounds reads.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow (CWE-119) in a kernel SCSI driver due to missing length validation. The target code is also in the kernel but operates on simple string parameters with explicit size checks. It does not copy user data into fixed-size kernel buffers without validation, which is the core flaw in Case 8.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is a race condition (CWE-362) leading to use-after-free in the kernel TTY subsystem. The target code is also kernel code. While the target function itself (`cgroup1_parse_param`) is likely called in a context that serializes access (e.g., during filesystem mounting), both involve managing kernel object state. However, the specific concurrency flaw pattern and the manipulation of object pointers are not evident in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a buffer overflow (CWE-119) in a network driver due to incorrect feature negotiation and buffer sizing. The target code is a subsystem configuration parser with no network packet processing, scatter-gather lists, or similar low-level buffer management concerns.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2021-4154_after_subset_100:f4ffff00:vulspec": {
    "timestamp": "2026-01-17T02:35:32.236243",
    "cve_id": "CVE-2021-4154",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f4ffff00",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a user-space library (libguestfs) related to file content processing. The target code is a kernel-space cgroup parameter parser with no dynamic memory deallocation. The vulnerability types (CWE-415 vs. input validation/state management) and domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in an XML parsing library. The target code parses simple key-value parameters for cgroup configuration. There is no similarity in functionality (file format parsing vs. kernel sysfs parameter parsing), attack surface, or vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool's analysis data structure cleanup. The target kernel cgroup code performs parameter validation and state assignment; it does not dynamically allocate/free complex linked structures within this function. The memory management models are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-15400 involves improper neutralization of CRLF sequences leading to injection. The target code also parses string parameters (e.g., `release_agent`, `name`) and performs some validation (character whitelist, length check). The similarity is limited to the general theme of input validation for strings that may later be used, but the context (PPD file generation vs. kernel object configuration) and specific flaw (injection vs. other misuse) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob() due to an off-by-one calculation. The target code performs bounds checking on a string length (`param->size > MAX_CGROUP_ROOT_NAMELEN - 1`) but does not involve complex string expansion or the same type of arithmetic error leading to allocation mismatch. The domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-11470 is an uncontrolled resource consumption issue in an image decoder due to lack of validation between declared dimensions and data size. The target code validates a string length against a fixed maximum but does not process bulk data or allocate memory proportional to untrusted inputs. The resource exhaustion threat model is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13033 is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code reads from a `fs_parameter` structure which is managed by the VFS layer; there is no direct parsing of binary packet data with internal length fields that could cause OOB reads within this function.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7425 is a kernel driver buffer overflow due to insufficient validation of user-controlled length. The target code is also in the kernel and validates user input (string length). However, the target code does not perform any copy operations based on a user-provided length into a fixed-size buffer; its validation is simple comparison against a constant. The vulnerability pattern (CWE-119) is more generic.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-0723 is a race condition (use-after-free) in the kernel TTY subsystem. The target code is also in the Linux kernel and manages state (ctx fields like `release_agent`, `name`). While this specific function (`cgroup1_parse_param`) is likely called during filesystem context setup (not a highly concurrent path), the broader context of safely managing assigned pointers (e.g., `param->string = NULL` to avoid double references) and checking for duplicate assignments (`ctx->release_agent`, `ctx->name`) shows awareness of state management issues common in kernel code. The relevance is thematic rather than identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2015-5156 is a kernel driver buffer overflow due to incorrect feature assumptions. The target code is also in the kernel and involves configuration/feature handling (subsys_mask, flags). The similarity is limited to being kernel code that processes configuration inputs. The specific flaw (buffer overflow from miscalculated size) is not present in the target code, which only does bitmask and flag operations.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2021-38205_before_subset_100:cbaf701b:vulspec": {
    "timestamp": "2026-01-17T02:35:39.229697",
    "cve_id": "CVE-2021-38205",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cbaf701b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a user-space library (libguestfs) related to file content processing. The target code is a Linux kernel network driver probe function with no dynamic memory deallocation or complex error paths that could lead to double-free. The functional domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 is a buffer overflow (CWE-119) in a kernel network driver (virtio_net) due to incorrect feature handling and insufficient buffer allocation. The target code is also a kernel network driver (xemaclite) probe function. While the specific flaw (fragmented packet handling) is not present, both involve network driver initialization and resource setup, sharing the domain and potential for resource management errors. However, the trigger conditions and code patterns differ significantly (probe vs. packet processing).",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 is a buffer overflow (CWE-119) in a kernel USB network driver (pegasus) related to improper DMA buffer handling. The target code is also a kernel network driver probe function. Both are network drivers in the kernel, sharing the broader subsystem. The relevance comes from the shared context of device driver initialization and potential for resource mapping/IRQ handling bugs. However, the specific vulnerability (stack buffer/DMA issue with VMAP_STACK) is not mirrored in the target code's pattern of using `devm_ioremap_resource`.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow (CWE-119) in a kernel SCSI driver (arcmsr) due to insufficient validation of user-controlled length parameters in an I/O control path. The target code is a network driver probe function that parses device tree properties. Both are kernel drivers, but the domains (storage vs. network), attack surfaces (SCSI commands vs. device tree), and code patterns (message transfer function vs. initialization function) are very different. The only weak similarity is parsing external input (device tree properties vs. SCSI commands).",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 is an improper initialization (CWE-665) leading to information disclosure in the kernel network stack's flow dissector. The target code is a network driver probe function. Both are in the kernel networking subsystem. The weak relevance stems from the shared subsystem and the fact that both involve state initialization. However, the vulnerability type (uninitialized memory in packet parsing) and code pattern (protocol dissection vs. device resource setup) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a race condition (CWE-362) leading to use-after-free (CWE-416) in the kernel TTY subsystem. The target code is a network driver probe function that runs during device initialization, likely not susceptible to concurrent access races. Both are kernel code, but the subsystems, vulnerability types (concurrency flaw vs. potential resource leak), and attack surfaces (local ioctl vs. device tree probing) are distinct. A minor similarity is the management of kernel objects (net_device, tty_struct), but their lifecycle is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 7 is a CRLF injection (CWE-93) leading to command injection in a user-space printing service (CUPS). The target code is a kernel network driver. The systems (user-space daemon vs. kernel driver), vulnerability types (injection vs. memory/resource error), and functional domains (printing protocol processing vs. hardware initialization) are completely different, offering no meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free (CWE-416) in a user-space reverse engineering tool (radare2) due to linked list cleanup issues. The target code is a kernel network driver probe function with no dynamic data structures like linked lists being freed. The context, vulnerability pattern, and code constructs are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is a buffer overflow (CWE-120) in QEMU's virtio-serial emulation due to lack of size validation on guest-provided descriptors. The target code is a kernel network driver. Both involve virtualization/device drivers in a broad sense. The weak link is that both handle device initialization and resources from an external source (device tree for target, guest descriptor for case). However, the environment (hypervisor vs. kernel), specific vulnerability mechanism, and code patterns are not aligned.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is an off-by-one buffer overflow (CWE-119) in a kernel SPI flash controller driver during initialization, triggered by a malicious Device Tree property. The target code is also a kernel driver probe function that parses Device Tree properties (e.g., \"xlnx,tx-ping-pong\", \"phy-handle\"). This is the strongest similarity among the cases: both are peripheral driver probe functions in the kernel that parse and act on Device Tree input. The vulnerability type (bounds checking) is potentially relevant if the target code's `get_bool` or `of_parse_phandle` were improperly implemented, though the provided code does not show such flaws. The domains differ (MTD/SPI vs. Network).",
        "case_metadata": {
          "cve_id": "CVE-2016-10764"
        }
      }
    ]
  },
  "CVE-2021-38205_after_subset_100:596b08dc:vulspec": {
    "timestamp": "2026-01-17T02:35:48.900231",
    "cve_id": "CVE-2021-38205",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "596b08dc",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a user-space library (libguestfs) related to file content processing and error handling. The target code is a kernel network driver probe function with no dynamic memory deallocation or complex error paths that could lead to double-free. The domains and memory management patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both are network device drivers in the Linux kernel (virtio_net vs. xemaclite). Both involve device initialization and resource acquisition (IRQ, memory). However, the specific vulnerability in Case 2 is a buffer overflow in packet handling (NETIF_F_FRAGLIST), while the target probe function focuses on setup and registration. The relevance comes from the shared subsystem and driver model patterns, but the flaw mechanisms differ.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are network device drivers (USB Ethernet vs. OF Ethernet). Both perform similar probe-time operations: resource mapping (devm_ioremap_resource), IRQ acquisition, and netdev registration. The vulnerability in Case 3 is a stack buffer overflow in USB control message handling, which is not present in the target code. The shared driver lifecycle and resource management patterns provide some reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is a SCSI storage driver vulnerability involving buffer overflow from untrusted input (SCSI commands). The target is a network driver probe function that parses device tree properties, which are considered trusted firmware data. Both are kernel drivers, but the attack surface (SCSI command interface vs. device tree) and data trust models are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves uninitialized memory in the network stack's flow dissector. The target code is a device driver probe function. Both are in the networking domain, but the vulnerability type (improper initialization leading to info leak) is not apparent in the target code, which initializes all critical fields (spin_lock_init, zeroing buffer indices). The shared networking context provides minimal relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 6 is a race condition (use-after-free) in the TTY subsystem's ioctl handling. The target code is a driver probe function that runs during device initialization, not in response to concurrent user requests. Both are kernel code, but the concurrency model and lifecycle (probe-time setup vs. runtime ioctl) are fundamentally different, offering little reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 7 is a CRLF injection vulnerability in a user-space printing system (CUPS) when processing IPP attributes. The target is a kernel network driver that reads boolean properties from the device tree. The domains (user-space printing vs. kernel networking), vulnerability types (injection vs. memory safety), and data sources (network protocol vs. firmware) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free/double-free in a user-space reverse engineering tool (radare2) related to linked list management. The target kernel driver probe function allocates a net_device but frees it only once on error paths. The memory management models (kernel vs. user-space, automatic cleanup with devm_* functions) and data structures are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve virtual/emulated device drivers (virtio-serial vs. Xilinx EmacLite). Both handle device initialization. The vulnerability in Case 9 is a buffer overflow in scatter-gather I/O, which is not present in the target probe function. The relevance stems from the shared paradigm of virtual device drivers and similar initialization patterns, but the runtime data path flaws differ.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are Linux kernel drivers for hardware controllers (SPI flash vs. Ethernet). Both are probed via the device tree and parse DT properties (get_bool for xlnx,tx-ping-pong similar to reading chip select \"reg\" property). Both perform resource mapping and device registration. The vulnerability pattern (off-by-one/bounds check) is not directly present in the target, but the driver structure, DT parsing, and initialization flow are highly similar, providing excellent reference for secure probe implementation.",
        "case_metadata": {
          "cve_id": "CVE-2016-10764"
        }
      }
    ]
  },
  "CVE-2017-17723_before_subset_100:a0ecf0e7:vulspec": {
    "timestamp": "2026-01-17T02:35:58.667959",
    "cve_id": "CVE-2017-17723",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a0ecf0e7",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve image file parsing and have a check for excessive directory length (`dirLength > 500` in target code, dimension validation in CVE-2019-11470). The vulnerability type differs (CWE-400 vs. potential out-of-bounds read/write in target code), but the pattern of validating input sizes before processing is a shared security concern. The target code's check for `tooBig` is a direct parallel to the missing validation in the Cineon case.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection in a printing system (PPD file generation). The target code is an image metadata (TIFF/Exif) parser with no command execution, network protocol handling, or text-based configuration generation. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve parsing image file metadata where numeric fields from the file (`dirLength`, `count`, `type` in target; `number_meta_channels` in CVE-2017-9499) are used without sufficient validation for logical consistency or safety. The target code validates `type` with `typeValid(type)` and checks `dirLength`, but other fields like `count` are used to calculate buffer sizes and read operations, creating a similar attack surface for integer overflows or excessive memory allocation if malicious values are provided.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2013-2124 is a double-free vulnerability in a file reading utility. The target code performs file I/O and dynamic memory allocation (`new byte[count]`), but its memory management patterns (explicit `delete[]`) are simple and local. There is no obvious shared ownership or complex cleanup path that would lead to a double-free in the provided code snippet. The relevance is limited to the broad category of file parsing.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2016-8670 is an integer underflow/overflow leading to buffer bounds issues in an image processing library. The target code performs numerous arithmetic operations for buffer sizing (`size*count + pad+20`) and loop bounds (`kount`). While it uses `uint32_t`, the lack of validation for the product `size*count` against the file size or available memory is a similar flaw pattern. The risk of integer overflow leading to an undersized buffer (`DataBuf buf(...)`) and subsequent out-of-bounds read/write is present.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-12667 is a memory leak in an error path. The target code has several error/exception paths (e.g., `throw Error(56)`). While it generally uses RAII (`DataBuf`) and explicit `delete[]`, the `MemIo` and `new byte[count-jump]` in the MakerNote block could potentially leak if an exception is thrown before the `delete[]`. However, the pattern is not the central flaw of the target code, and the connection is speculative.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code parses binary TIFF/Exif data, not text-based XML. It does not process external entities or have a remotely similar attack model. The only faint connection is parsing structured data from an untrusted source.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. CVE-2016-7101 involves out-of-bounds read due to insufficient validation of image dimensions (rows/columns) before memory access. The target code validates `dirLength` but uses other untrusted fields (`count`, `offset`) to calculate read sizes and seek positions. The line `io.seek(offset,BasicIo::beg)` and `io.read(buf.pData_,count*size)` are highly similar to the flawed pattern: using file-supplied values to control memory and I/O operations without fully validating they lie within the bounds of the file. This is a direct parallel.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2018-12320 is a use-after-free/double-free in a complex linked data structure (basic blocks). The target code's memory operations are simpler, with linear allocations and immediate use. There is no manipulation of pointer-based structures that could create dangling references or circular dependencies. The relevance is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2017-13033 is an out-of-bounds read in a network protocol parser due to insufficient validation of length fields before memory access. The target code is a file format parser, but the core flaw pattern is identical: it reads a `count` and `size` from untrusted input, calculates a length (`count*size`), and uses it to read data (`io.read(buf.pData_,count*size)`) without validating that the operation stays within the intended buffer (`buf`) or the file bounds. The main difference is the data source (file vs. network packet).",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2017-17723_after_subset_100:3bf5df09:vulspec": {
    "timestamp": "2026-01-17T02:36:06.884692",
    "cve_id": "CVE-2017-17723",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3bf5df09",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve image file parsing and have checks to prevent excessive memory allocation (dirLength > 500 vs. dimension validation). The target code's check `if ( allocate > (long long) io.size() )` is a resource consumption defense similar to CVE-2019-11470's missing validation. However, the vulnerability types differ (CWE-400 vs. the target's focus on bounds checking and allocation size validation). The pattern of validating input fields before allocation is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection in a printing system (CWE-93). The target code is an image metadata parser with no command execution, output generation for configuration files, or CRLF sequence handling. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve parsing structured file formats (MPC vs. TIFF/EXIF) and have numeric field validation. CVE-2017-9499's lack of validation for `number_meta_channels` is analogous to the target code's validation of `type`, `count`, and allocation size. The target code has explicit checks (`typeValid(type)`, allocation vs. io.size()), showing a similar defensive concern. However, the specific trigger (assertion failure) and data type differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2013-2124 is a double-free (CWE-415) in a file content reader. The target code performs memory allocation (`DataBuf buf(allocate)`, `new byte[count]`) and cleanup (`delete[]`), but its structure is different. The recursive `printIFDStructure` could theoretically have complex state, but no clear double-free pattern or ownership ambiguity is evident in the shown code. The relevance is low.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2016-8670 involves improper bounds checking leading to out-of-bounds read/write (CWE-119) in an image processing context. The target code performs extensive bounds checking: validating `type`, calculating `kount` to limit printed values, checking `allocate > io.size()`, and using `bOffsetIsPointer` to conditionally seek. The pattern of validating sizes before memory access and buffer allocation is very similar, though the specific arithmetic underflow flaw is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-12667 is a memory leak (CWE-401) in an image parser during error handling. The target code allocates memory (`new byte[count]` for IPTCNAA and MakerNote) and has corresponding `delete[]`. While it must manage resources correctly across multiple code paths (including recursive calls and early returns on error), the shown code appears to have paired allocation/deallocation. The relevance is in the domain (image parsing) and need for careful resource management, but the flaw type differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 involves XXE (CWE-611) in an XML parser. The target code parses binary TIFF/EXIF structures, does not parse XML, and does not process external entities. The vulnerability class and attack patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. CVE-2016-7101 involves insufficient validation of image dimensions leading to out-of-bounds read (CWE-125). The target code has multiple similar validations: checking `dirLength > 500`, validating `type`, and crucially checking `allocate > (long long) io.size()` before allocating `DataBuf buf(allocate)`. This prevents allocating an oversized buffer based on untrusted `count` and `size` fields. The code patterns (parsing headers, validating fields before allocation/access) and domain (image file parsing) are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2018-12320 is a use-after-free/double-free (CWE-416) in a linked structure within a code analysis tool. The target code uses simple allocations (`new byte[]`) and immediate cleanup within the same scope, not complex linked structures. While memory management is involved, the patterns of circular references and pointer manipulation leading to use-after-free are not present. The relevance is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-13033 involves out-of-bounds read (CWE-125) due to insufficient validation of length fields in a network protocol parser. The target code validates sizes before reads (e.g., `allocate` check, `bOffsetIsPointer` conditional read). Both involve parsing structured data with length fields. However, the domains differ (network packets vs. image files), and the target code's validation appears more comprehensive. The core similarity is validating input-controlled sizes before memory access.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2021-40524_before_subset_100:a53a06a0:vulspec": {
    "timestamp": "2026-01-17T02:37:18.170489",
    "cve_id": "CVE-2021-40524",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a53a06a0",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is an FTP server upload function focusing on file system operations, path validation, and quota management. CVE-2013-2124 is a double-free vulnerability in a virtual machine inspection library related to memory management of file content buffers. The vulnerability type (CWE-415), domain (VM disk inspection vs. FTP file transfer), and code patterns (memory allocation/free vs. file I/O) are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-15400 is a CRLF injection/command injection vulnerability in a printing system's PPD file generation. The target code handles file uploads with path validation and atomic rename operations. While both involve processing external input (network data) and writing files, the core flaw (improper neutralization of sequences leading to injection) and the attack surface (protocol attribute parsing vs. raw data transfer) are distinct. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-16943 is a use-after-free vulnerability in an MTA's SMTP message processing, specifically in memory management for message headers. The target code performs file system operations with careful state management but does not involve complex dynamic memory allocation or pointer management for network data structures. The vulnerability type (CWE-416) and context (email spool vs. FTP upload) are unrelated. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2016-7425 is a buffer overflow in a kernel SCSI driver due to insufficient validation of length parameters. The target code validates file names (`checknamesanity`) and uses safe system calls, but does not perform complex buffer operations on user-controlled data sizes. The similarity is in the general principle of validating external input, but the specific flaw type (heap buffer overflow in driver IOCTL) and environment are very different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-1000852"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-18609 is an integer overflow leading to an out-of-bounds write in an AMQP client library. The target code uses `off_t` (signed) for file sizes and performs quota calculations (`ul_quota_update`). While there is no obvious integer overflow in the shown code, the pattern of performing arithmetic on sizes received from the network (e.g., `restartat`, `filesize`) for memory or disk operations is a shared concern. The relevance is moderate because the domain (network protocol handling) and risk category (integer issues) are somewhat aligned, but the specific trigger and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 7,
        "reasoning": "CVE-2016-5418 is an improper input validation leading to path traversal/symlink race issues in an archive extraction library. The target code performs similar file system operations (`open`, `rename`, `unlink`) on user-supplied paths (`name`). It includes path sanity checks (`checknamesanity`) and uses atomic rename patterns to mitigate races. Both deal with the security of writing files based on untrusted input. The vulnerability type (CWE-20/22) and attack surface (file system operations) are similar, providing valuable reference for path validation and race condition pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-8670 is a buffer overflow in an image processing library due to incorrect bounds checking. The target code does not show low-level buffer manipulation of image data. Its primary data handling is via `ul_send` which likely uses safe I/O routines. The flaw pattern (arithmetic underflow in buffer size calculation) is not evident in the presented code which focuses on file descriptors and system calls. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool's analysis data structure cleanup. The target code manages file descriptors and simple local variables, not complex linked data structures allocated on the heap. There are no `free()` calls or pointer manipulations in the shown code. The vulnerability type (CWE-416) and context are completely different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 6,
        "reasoning": "CVE-2018-20749 is an integer overflow leading to an out-of-bounds write in a VNC server's file transfer feature. This is highly analogous to the target code's functionality: both are server applications handling file transfers over a network protocol. The target code uses `off_t` for file sizes and may be vulnerable to integer overflows in quota calculations or size checks (e.g., `max_filesize` logic). The attack surface (network file transfer) and potential flaw pattern (integer issues affecting memory/disk allocation) are similar. Moderate relevance with valuable reference for auditing size calculations.",
        "case_metadata": {
          "cve_id": "CVE-2018-20749"
        }
      }
    ]
  },
  "CVE-2022-30975_before_subset_100:7f091387:vulspec": {
    "timestamp": "2026-01-17T02:37:25.196709",
    "cve_id": "CVE-2022-30975",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7f091387",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a syntax dumping/printing function with no dynamic memory allocation, deallocation, or error handling paths that could lead to a double-free. The functionality and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code performs simple AST traversal and output formatting. It does not parse external input (XML or otherwise), handle entities, or have any configuration interfaces related to security restrictions.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code outputs syntax, but it does not process or neutralize CRLF sequences from external input (like IPP attributes). The `putchar` calls are for formatting, not generating structured files (like PPDs) that are later parsed as code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code walks an AST and prints it. It does not manage linked data structures with `next` pointers, perform manual memory deallocation, or have any state that could lead to a use-after-free or double-free during cleanup.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse file formats, read dimensions from untrusted input, or perform any memory allocation based on external data. It operates on an already-parsed AST structure.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The only tangential similarity is that both involve output functions (`putchar` vs. pathname expansion output). However, the target code has no path expansion, tilde processing, recursive traversal, or complex memory allocation with off-by-one calculations. The risk profile is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not handle filesystem operations, extract archives, create links, or validate paths. It is a purely in-memory AST printing routine.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not process image data, perform bounds-checked buffer operations, or have arithmetic that could underflow. The `putchar` calls write single characters to stdout, not to bounded buffers.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse network packets or binary protocols, read length fields from untrusted data, or perform bounds checking before memory access. It traverses a trusted, internal AST.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not read file headers, parse numeric fields from untrusted input, or have assertions that could be triggered by invalid data. It simply prints an existing AST.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      }
    ]
  },
  "CVE-2021-40524_after_subset_100:1cb494d2:vulspec": {
    "timestamp": "2026-01-17T02:37:26.812153",
    "cve_id": "CVE-2021-40524",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1cb494d2",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a library for inspecting VM disk images. The target code is an FTP server's file upload function. The vulnerability types (memory corruption vs. file system operations), domains, and code patterns are fundamentally different. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection leading to command injection in a printing system's PPD file generation. The target code handles file uploads and file system operations (open, rename, truncate). The attack surfaces (network protocol parsing vs. local file ops) and flaw types (input validation/injection vs. potential race conditions or TOCTOU) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-16943 is a use-after-free in an MTA's SMTP message processing. The target code performs file I/O and management with no apparent dynamic memory management of complex structures. The vulnerability class (memory safety) and context (network server vs. file operations) are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7425 is a buffer overflow in a kernel SCSI driver due to improper length validation. The target code performs file operations with standard C library functions and does not show obvious buffer operations on user-controlled data of variable length. The domain (kernel driver vs. user-space FTP) and flaw pattern are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-1000852 is an out-of-bounds read in an RDP client's channel data reassembly. The target code's data transfer is abstracted into `ul_send(&ulhandler)`. The vulnerability pertains to improper reassembly logic and bounds checking, which is not visible in the provided high-level file upload code.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000852"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-18609 involves an integer overflow leading to an out-of-bounds write in an AMQP library. The target code uses `off_t` for file sizes and has checks for disk space and quotas. There is a superficial similarity in the need to handle large sizes correctly to prevent overflow in calculations (e.g., quota updates), but the specific context (protocol parsing vs. file size arithmetic) and risk level differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-5418 involves improper input validation leading to path traversal and symlink race conditions during archive extraction. The target code performs similar file system operations: it validates filenames (`checknamesanity`), uses `rename()` with temporary atomic files, and has complex logic for overwriting, appending, and autorename. Both deal with the security of writing files to the filesystem from an untrusted source (network). The patterns of using temporary files and renaming are similar, and both could be susceptible to TOCTOU (Time-of-check Time-of-use) races if not careful, though the target code uses atomic rename patterns which are a mitigation.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-8670 is a buffer overflow in PHP's GD image processing due to incorrect bounds checking. The target code does not contain visible buffer manipulation or image processing logic. The core functionality and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool's analysis data structure cleanup. The target code manages file descriptors and paths, not complex linked data structures in heap memory. The memory management patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-20749 is an integer overflow leading to an out-of-bounds write in a VNC server's file transfer. The target code also handles file transfers. Both involve allocating resources based on client-supplied size information (the target code's `max_filesize` is derived from quotas). The relevance is weak because the target code's size handling appears to use signed `off_t` and has quota checks, but the specific integer overflow-to-buffer overflow chain is not evident in the shown code path, which delegates the actual data transfer to `ul_send`.",
        "case_metadata": {
          "cve_id": "CVE-2018-20749"
        }
      }
    ]
  },
  "CVE-2022-30975_after_subset_100:966bfe09:vulspec": {
    "timestamp": "2026-01-17T02:37:44.745111",
    "cve_id": "CVE-2022-30975",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "966bfe09",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual disk image processing library due to complex memory ownership and error handling issues. The target code is a simple syntax dumping function with no dynamic memory allocation, deallocation, or error handling paths that could lead to double-free.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability (CWE-611) in an XML parser due to improper restriction of external entity references. The target code performs syntax tree printing with no XML parsing, entity resolution, or external resource handling.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 involves CRLF injection (CWE-93) leading to command injection in a printing system's PPD file generation. The target code outputs formatted text to stdout but does not generate configuration files, process untrusted input for command execution, or handle CRLF sequences in a security-sensitive context.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a use-after-free vulnerability (CWE-416) in a reverse engineering framework due to improper linked list cleanup. The target code has no dynamic memory management, pointer manipulation, or complex data structure deallocation logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared dimensions and actual data. The target code performs simple tree traversal and output formatting with no resource-intensive operations or validation of untrusted numeric inputs.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a heap buffer overflow (CWE-122) in glibc's glob function due to off-by-one calculation. The target code has no buffer operations, memory allocation calculations, or pathname expansion logic that could lead to buffer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves improper input validation (CWE-20) leading to path traversal issues in an archive extraction library. The target code does not process file paths, perform filesystem operations, or handle archive formats that could be vulnerable to path manipulation.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a buffer handling vulnerability (CWE-119) in PHP's GD library due to incorrect bounds checking. The target code performs simple output operations with putchar() and has no buffer manipulation, arithmetic operations, or image data processing.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length validation. The target code does not parse network packets, validate length fields, or access memory buffers based on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves a reachable assertion (CWE-617) in an image decoder due to insufficient validation of numeric input. The target code has no assertions, numeric input validation, or channel processing logic that could lead to assertion failures.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      }
    ]
  },
  "CVE-2022-1795_before_subset_100:24fab362:vulspec": {
    "timestamp": "2026-01-17T02:37:58.857282",
    "cve_id": "CVE-2022-1795",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "24fab362",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 (CWE-415 Double Free) involves memory ownership and cleanup issues during error handling. The target code manipulates reference counts (`node->sgprivate->num_instances = 2`) which is a form of resource management, but the pattern is not about double-free. The core flaw and trigger conditions are different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 (CWE-400 Uncontrolled Resource Consumption) is about missing validation leading to excessive memory allocation. The target code does parse a node but does not show dimension validation or large allocation patterns. The vulnerability type and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 (CWE-611 XXE) is about improper restriction of external entities during XML parsing. The target code parses a node from a bitstream in a multimedia context (GPAC/BIFS), which is unrelated to XML entity processing. The domain and flaw are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 (CWE-416 Use After Free) involves improper cleanup of linked structures leading to double-free. The target code manually sets a reference count (`num_instances = 2`), which is a pattern of managing object lifetime. If the reference counting logic is flawed (e.g., not decremented correctly), it could lead to use-after-free or double-free scenarios. However, the specific linked list circular reference flaw is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 (CWE-93 CRLF Injection) is about improper neutralization of control sequences leading to command injection. The target code parses binary data and constructs internal commands/comments, but there is no indication of injecting sequences into a text-based protocol or file. The vulnerability type is unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 (CWE-119 Buffer Overflow) involves incorrect bounds checking leading to out-of-bounds read/write. The target code does not show buffer operations or arithmetic checks. The code patterns and flaw type are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 (CWE-122 Heap Buffer Overflow) is about an off-by-one error in memory allocation. The target code does not perform direct memory allocation or string manipulation. The vulnerability type is not relevant to the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 (CWE-617 Reachable Assertion) involves insufficient validation of numeric input leading to an assertion failure. The target code validates the node tag (`TAG_MPEG4_QuantizationParameter`), which is a form of input validation. If the validation is missing or incorrect, it could lead to an unexpected state. However, the specific pattern of numeric overflow/assertion is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 (CWE-119 Buffer Overflow) is about insufficient validation of user-controlled length parameters in a kernel driver. The target code is in a user-space multimedia decoder and does not show similar buffer copy operations with length parameters. The domain and flaw pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2022-1795_after_subset_100:4d5e333f:vulspec": {
    "timestamp": "2026-01-17T02:38:55.400335",
    "cve_id": "CVE-2022-1795",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4d5e333f",
    "scores": [
      {
        "score": 8,
        "reasoning": "The target code contains a clear double-free vulnerability pattern: `gf_node_unregister(node, NULL);` is called twice consecutively on the same `node` pointer. This directly mirrors the core flaw in CVE-2013-2124 (CWE-415: Double Free). The trigger condition involves error handling and node registration/unregistration logic, which is highly similar to memory ownership and cleanup issues in the historical case.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-11470 is about uncontrolled resource consumption (CWE-400) due to lack of validation of image dimensions leading to excessive memory allocation. The target code performs no allocation based on untrusted size inputs and deals with node registration/unregistration, not resource exhaustion.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. CVE-2013-0339 is an XML External Entity (XXE) vulnerability (CWE-611). The target code parses a binary stream for a node structure and has no XML parsing, external entity fetching, or related functionality.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2018-12320 is a Use-After-Free (CWE-416) that can lead to a double-free. The target code's double-free flaw could potentially create a similar corrupted memory state exploitable for UAF. Both involve improper cleanup of data structures (nodes/basic blocks) and linked state management, though the specific mechanisms differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. CVE-2017-15400 involves CRLF injection (CWE-93) and command injection during PPD file generation. The target code performs binary structure parsing and node management with no string processing, command generation, or injection vectors.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-8670 is a buffer overflow (CWE-119) due to incorrect bounds checking in image data handling. The target code's primary flaw is a double-free, not a buffer overflow. A weak connection exists in that both involve improper operations on memory (freeing vs. read/write), but the vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13033 is an out-of-bounds read (CWE-125) in a network protocol parser due to insufficient length validation. The target code does not parse variable-length packet data and the flaw is not related to bounds checking of array or buffer indices.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow (CWE-122) due to an off-by-one allocation error. The target code's flaw is a double-free. Both are memory corruption vulnerabilities on the heap, but the root cause (allocation math error vs. repeated free) and exploitation patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-9499 is a reachable assertion (CWE-617) due to lack of input validation on a numeric field. The target code does not contain assertions and its flaw is not triggered by invalid numeric input, but by a logic error in function call sequencing.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-7425 is a buffer overflow (CWE-119) in a kernel driver due to missing length validation. The target code's double-free is a different class of memory corruption. A tangential similarity is that both involve improper handling of data from an external source (bitstream/SCSI command), but the specific vulnerabilities are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2020-19490_before_subset_100:6cdc455d:vulspec": {
    "timestamp": "2026-01-17T02:39:13.797387",
    "cve_id": "CVE-2020-19490",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6cdc455d",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve image format parsing with insufficient validation of image dimensions (data_width/data_height) leading to potential uncontrolled resource consumption (CWE-400). The target code has checks for negative and overly large dimensions, but the validation logic (threshold of 1024*8192) is heuristic and could be bypassed. The pattern of allocating memory based on unvalidated or poorly validated header fields is similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The historical case is a double-free (CWE-415) in a virtual machine disk inspection library related to error handling and memory ownership. The target code is an image decoder focusing on data validation and parsing. The memory management patterns (calloc/free) and error conditions are different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve insufficient validation of numeric input fields from a file header. CVE-2013-2124's flaw is an unvalidated `number_meta_channels` field leading to an assertion failure. The target code validates several numeric fields (data_width, data_height, tile_size_x/y, data_len) but the validation logic for `data_len` and the arithmetic for `lno` could be sources of similar issues (integer overflow/underflow). The pattern of reading and using untrusted integers is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Both involve improper bounds checking leading to potential buffer over-read/write (CWE-119). The historical flaw was an incorrect check (`remain == 0`) failing to account for underflow. The target code has multiple bounds checks (e.g., `offsets[tile_idx] + sizeof(int)*5 > size`, `size_t(data_len) > data_size`), but subtle integer overflows in calculations like `size - (offsets[tile_idx] + sizeof(int)*5)` could lead to similar vulnerabilities. The context of processing binary data chunks is analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The historical case is a memory leak (CWE-401) during error handling in a MATLAB file parser. The target code uses `calloc` and allocates images, but the provided snippet does not show the corresponding cleanup/deallocation paths. While resource management is a concern, the specific flaw pattern (leak on error path) is not directly visible in the given code.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Highly similar to Case 1 (CVE-2019-11470) and directly relevant. Both involve image format parsing where malicious dimension values (rows/columns or data_width/data_height) can cause excessive memory allocation or out-of-bounds reads. The target code's validation of dimensions and subsequent use in calculations (e.g., `total_data_len`) is a critical area for similar vulnerabilities, including integer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The historical case is a CRLF injection (CWE-93) leading to command injection in a printing system's PPD file generator. The target code is a binary image decoder that does not generate text configuration files or execute commands. The attack surfaces and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The historical case is an XXE (CWE-611) vulnerability in an XML parser. The target code parses a binary image format (EXR) and does not process XML or external entities. The domains and vulnerability classes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve parsing a file format and insufficient validation between a declared size field and actual data size, leading to potential out-of-bounds read (CWE-125). The historical case failed to validate decompressed size against a header value. The target code validates `data_len` against `data_size`, which is derived from `size - offset`. This is a similar validation pattern, though the context (compressed XML TOC vs. image tile/scanline data) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The historical case is a use-after-free/double-free (CWE-416) in a reverse engineering framework's linked structure cleanup. The target code allocates structures with `calloc` but does not show complex linked list manipulation or the corresponding free logic. The memory management patterns and potential flaw triggers are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      }
    ]
  },
  "CVE-2020-19490_after_subset_100:29d7f7ef:vulspec": {
    "timestamp": "2026-01-17T02:39:17.703775",
    "cve_id": "CVE-2020-19490",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "29d7f7ef",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve image format parsing with insufficient validation of image dimensions leading to potential uncontrolled resource consumption (CWE-400). The target code performs checks on data_width/data_height (threshold) and total_data_len, but the pattern of allocating memory based on user-controlled dimensions before fully validating the data size is similar. The vulnerability type and attack surface (malicious file with manipulated dimensions) are closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves a double-free vulnerability (CWE-415) in a virtual machine disk inspection library related to error handling and memory ownership. The target code is an image decoder focusing on bounds checking, memory allocation based on dimensions, and data validation. The vulnerability types, domains, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve image format parsing where insufficient validation of numeric input fields (like number_meta_channels or image dimensions/offsets) can lead to security issues. The target code validates data_width/data_height against a threshold and checks offsets against size, which is a similar defensive pattern against malformed headers. The core issue of validating user-controlled numeric fields from file headers is shared, though the specific vulnerability (reachable assertion vs. buffer overflow/DoS) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve buffer handling in image processing with potential integer overflow/underflow in bounds checking. The target code has several size calculations (e.g., `size_t(data_width) * size_t(data_height) * size_t(num_channels)`) and checks for overflow (`total_data_len_overflown`). The pattern of validating arithmetic operations on user-controlled values to prevent CWE-119 is similar, though the specific flaw (underflow in `remain` check) is not directly present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 is a memory leak (CWE-401) in an image parser during error handling. The target code focuses on preventing buffer overflows and resource exhaustion through validation, and while it allocates memory (e.g., `calloc` for tiles), it does not show explicit cleanup paths that could be compared. The vulnerability class and code patterns are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. Both are image decoders (EXR vs. SGI) where malicious file headers with manipulated dimensions (rows/columns or data_width/data_height) can cause out-of-bounds reads (CWE-125) or denial of service. The target code explicitly validates `data_width` and `data_height` against a threshold and checks for negative values, which is the exact mitigation for the flaw in Case 6. The attack surface, vulnerability type, and defensive coding patterns are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 7 involves CRLF injection (CWE-93) and command injection in a printing system's PPD file generation. The target code is a binary image decoder that parses numerical data and compressed pixel data, with no text processing, command execution, or CRLF handling. The domains and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an XXE vulnerability (CWE-611) in an XML parser. The target code parses a binary image format (EXR) with no XML processing, external entity resolution, or related features. The vulnerability classes and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve file format parsing (EXR vs. XAR) where declared data sizes in headers (`data_len`, `toc_length_decompressed`) are validated against actual available data size (`data_size`, `strm.total_out`) to prevent out-of-bounds reads (CWE-125). The target code performs checks like `size_t(data_len) > data_size` and `offsets[tile_idx] + sizeof(int) * 5 > size`, which directly mirror the missing validation in Case 9. The vulnerability pattern and defensive checks are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a use-after-free/double-free (CWE-416) in a reverse engineering framework's linked structure cleanup. The target code uses `calloc` and vectors for allocation, with no complex pointer-based structures or manual `free` operations shown. The memory management patterns and vulnerability types are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      }
    ]
  },
  "CVE-2022-1154_before_subset_100:50528e8e:vulspec": {
    "timestamp": "2026-01-17T02:39:36.608845",
    "cve_id": "CVE-2022-1154",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "50528e8e",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XML external entity (XXE) vulnerability in libxml2, involving improper restriction of external entity references during XML parsing. The target code is a regular expression matching engine in Vim (regmatch.c). The domains (XML parsing vs. regex execution), vulnerability types (CWE-611 vs. potential CWE-190/125/400), and code patterns are completely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-16943 is a Use-After-Free (CWE-416) in Exim's SMTP message processing. The target code performs complex state management using a custom stack (`regstack`) and position arrays (`backpos`). While both involve intricate state handling, the vulnerability mechanism (explicit memory deallocation vs. custom stack management), domain (network service vs. text processing), and code patterns are distinct. Limited reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-11470 is an Uncontrolled Resource Consumption (CWE-400) in ImageMagick due to lack of validation between declared image dimensions and actual data. The target regex engine also performs repetitive matching (e.g., `regrepeat` function, loops for `STAR`, `PLUS`, `BRACE_COMPLEX`) which could lead to excessive resource use (catastrophic backtracking). The vulnerability type (resource exhaustion) and potential trigger (complex regex patterns) are similar, but the implementation (image parsing vs. automaton execution) differs.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2016-9426 is an Integer Overflow (CWE-190) in w3m's table rendering leading to excessive memory allocation. The target code contains several integer calculations for positions, counts (e.g., `brace_count`, `rst->count`), and memory growth checks (`ga_grow`). While no direct matrix allocation is seen, the pattern of using unchecked integers to control loops and state could lead to similar issues (e.g., in `regrepeat`). The vulnerability class and the need for bounds checking are relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-9426"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-1140 is an Improper Input Validation (CWE-20) in Samba's LDAP query to SQL translation, involving NULL pointer handling after a failed string operation. The target code has extensive input character processing but uses direct pointer access (`rex.input`) and checks for `NUL`. The error handling patterns and domain (database query translation vs. character-by-character matching) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2013-2124 is a Double Free (CWE-415) in libguestfs due to error path cleanup issues. The target code has many error paths (`status = RA_FAIL`, `status = RA_NOMATCH`) and cleanup functions (`cleanup_subexpr`), but it does not use standard `malloc`/`free` in this function; it manages external arrays. The memory ownership patterns are different. Minimal reference.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2016-9440 is a NULL Pointer Dereference (CWE-476) in w3m's form buffer handling. The target code dereferences pointers like `rex.input`, `rex.line`, and `scan`, but they are likely validated by the caller or in loops (`scan == NULL` check). The context (HTML form rendering vs. regex matching) and the specific pattern of buffer state management are different. Limited reference.",
        "case_metadata": {
          "cve_id": "CVE-2016-9440"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2020-16296"
        }
      }
    ]
  },
  "CVE-2022-1154_after_subset_100:0edb9d84:vulspec": {
    "timestamp": "2026-01-17T02:39:52.950300",
    "cve_id": "CVE-2022-1154",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0edb9d84",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XML external entity (XXE) vulnerability in libxml2, involving improper restriction of external entity references during XML parsing. The target code is a regular expression matching engine in Vim (regmatch.c). The domains (XML parsing vs. regex execution), vulnerability types (CWE-611 vs. potential memory/state management issues), and code patterns are completely different. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-16943 is a Use-After-Free (CWE-416) in Exim's SMTP BDAT command handling. The target code is a regex engine with complex state management using a custom stack (regstack). While both involve careful memory/state management, the contexts are vastly different (mail server vs. text editor regex engine). The specific patterns (store_release() vs. ga_grow/regstack_push) and trigger conditions are not similar. Limited reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-11470 is an uncontrolled resource consumption (CWE-400) in ImageMagick's Cineon decoder due to lack of validation between declared image dimensions and file size. The target regex code also has potential for resource exhaustion via complex patterns leading to deep recursion/loops (e.g., patterns like \"\\([a-z]\\+\\)\\+Q\" mentioned in comments). Both could lead to DoS. However, the mechanisms differ: image dimension integer overflow vs. regex backtracking/state explosion. Some reference value for understanding DoS risks in parsers/interpreters.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-9426 is an integer overflow (CWE-190) in w3m's table rendering leading to excessive memory allocation. The target regex code performs memory allocations via ga_grow() for regstack and backpos, and has checks against p_mmp (maxmempattern) to limit memory use. While both involve calculations that could lead to excessive memory use, the vulnerability patterns differ: integer overflow in width calculations vs. uncontrolled growth of state stacks due to malicious regex patterns. The check `(long)((unsigned)regstack.ga_len >> 10) >= p_mmp` shows awareness of this risk. Provides some reference for memory exhaustion defenses.",
        "case_metadata": {
          "cve_id": "CVE-2016-9426"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-1140 is an improper input validation (CWE-20) in Samba's LDAP server leading to NULL pointer dereference during SQL query generation. The target regex code has extensive input validation (the regex \"program\" bytecode is assumed valid after compilation). Error handling exists (e.g., checking ga_grow() result). The domains (LDAP/SQL translation vs. regex VM execution) and flaw patterns are dissimilar. Minimal reference value.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-12320 is a Use-After-Free (CWE-416) in radare2's basic block analysis due to incomplete cleanup of linked structures (circular references). The target regex code manages complex state with stacks (regstack) and position arrays (backpos). It must carefully save and restore state for backtracking. While not using the same memory allocator, the pattern of managing interconnected state (e.g., backpos entries linked to scan pointers) and ensuring clean state restoration on failure/backtracking is conceptually similar. A flaw in state management (e.g., not properly clearing backpos entries) could lead to similar logic errors. Provides valuable reference for state machine integrity.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2013-2124 is a Double Free (CWE-415) in libguestfs due to error path cleanup issues. The target code uses arena-like allocation for regstack and backpos (allocated/freed in bt_regexec_both), not fine-grained malloc/free. There's no direct memory ownership ambiguity in the shown code. The error paths use status codes and cleanup functions (cleanup_subexpr, restore_se). Different memory models reduce relevance. Some reference for error handling discipline.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2019-19012 is an Out-of-bounds Read (CWE-125) in Oniguruma regex library due to integer overflow in pointer arithmetic during forward search. The target code is also a regex engine (Vim's) with similar functionality: processing input strings (rex.input), advancing pointers (ADVANCE_REGINPUT, MB_PTR_BACK), and checking bounds (c == NUL). It handles multi-byte characters (has_mbyte, enc_utf8). The vulnerability patterns are highly similar: incorrect arithmetic when calculating distances/offsets in the input buffer could lead to OOB reads/writes. The code shows careful pointer advances but must be scrutinized for similar overflow issues (e.g., in `rex.input += len` calculations). Almost identical domain and vulnerability type. Highly valuable reference.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-9440 is a NULL pointer dereference (CWE-476) in w3m's form rendering due to invalid buffer state. The target regex code dereferences pointers (e.g., rex.input, rex.line) but they appear to be initialized before use. The contexts (HTML form rendering vs. regex matching) are unrelated. The flaw pattern (missing validation of state before access) is generic, but the specific code patterns are not similar. Minimal reference.",
        "case_metadata": {
          "cve_id": "CVE-2016-9440"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2020-16296 is an Out-of-bounds Write (CWE-787) in GhostPDL's printer driver due to incorrect bounds checking order. The target code performs bounds checks (e.g., against end of line) but primarily reads input. It writes to stack structures (regstack, backpos) within allocated bounds. The vulnerability mechanism (bounds check order) is specific to buffer comparison loops, not obviously present in the target code. Some reference for ensuring safe pointer arithmetic, but direct relevance is low.",
        "case_metadata": {
          "cve_id": "CVE-2020-16296"
        }
      }
    ]
  },
  "CVE-2012-6113_before_subset_100:9ed340dc:vulspec": {
    "timestamp": "2026-01-17T02:40:42.710352",
    "cve_id": "CVE-2012-6113",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9ed340dc",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in a virtual machine disk image library. The target code is an OpenSSL encryption function in PHP. Both involve C memory management, but the domain, functionality, and specific flaw (double-free vs. potential buffer/IV handling issues) are fundamentally different. The target code shows careful `efree` checks, making a direct double-free pattern less likely.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 (CVE-2019-11470) is an uncontrolled resource consumption (CWE-400) issue in an image decoder due to unvalidated dimensions leading to huge allocations. The target code performs encryption with bounded allocations based on `data_len` and cipher block size. There is no similarity in the attack vector (image files vs. encryption parameters) or the core flaw (unbounded allocation vs. controlled allocation).",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 (CVE-2018-12320) is a use-after-free/double-free in a reverse engineering tool's linked list cleanup. The target code manages simple, linear buffers (`key`, `outbuf`, `iv`) with clear ownership flags (`free_iv`). While both involve C and manual memory management, the complexity of data structures (linked lists with circular references vs. flat buffers) and the resulting vulnerability patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 (CVE-2016-8670) is a buffer overflow in PHP's GD library due to an arithmetic underflow in bounds checking. The target code is also in PHP core and performs buffer operations (`memcpy`, `EVP_EncryptUpdate`). The relevance is higher due to the shared environment (PHP core) and the domain of buffer handling. However, the specific flaw (underflow in image processing) is not directly mirrored in the encryption logic, which uses OpenSSL's EVP API for buffer management.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 (CVE-2017-15400) is a CRLF injection/command injection in a printing system's PPD file generator. The target code performs symmetric encryption and base64 encoding. There is no overlap in vulnerability type (injection vs. memory/crypto flaw), functionality, or data flow. The target code does not generate or parse structured text files where injection is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 (CVE-2017-15670) is a heap buffer overflow in glibc's `glob()` due to an off-by-one allocation error. The target code also performs memory allocation (`emalloc`) and could theoretically have calculation errors (e.g., `outlen = data_len + EVP_CIPHER_block_size(cipher_type)`). This provides a vague conceptual similarity in \"allocation size calculation.\" However, the domains (path expansion vs. encryption) and the specific error pattern are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 7 (CVE-2013-7459) is an out-of-bounds write in a cryptographic library (pycrypto) due to improper handling of an Initialization Vector (IV) for a cipher mode that doesn't use one (ECB/CTR). The target code is the `openssl_encrypt` function in PHP, which handles IVs (`iv` parameter) and cipher modes (`method`). The key similarity is the cryptographic domain and the critical, error-prone parameter validation for IVs. The target code validates IV length (`php_openssl_validate_iv`) and warns about empty IVs, but flaws could exist in this validation or in the interaction between key/IV length and the OpenSSL EVP API. The vulnerability pattern is highly analogous.",
        "case_metadata": {
          "cve_id": "CVE-2013-7459"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability in libxml2. The target code performs encryption and has no XML parsing functionality. The vulnerability classes (injection/entity expansion vs. memory/crypto issues) and attack surfaces are completely disjointed.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 (CVE-2017-13033) is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code validates input lengths (`data_len`, `password_len`, `iv_len`) against cryptographic constants (`EVP_CIPHER_key_length`, `EVP_CIPHER_iv_length`). The conceptual similarity is \"length field validation before buffer access,\" but the context (network packet parsing vs. API parameter checking) and the typical consequences differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 (CVE-2017-13715) is an improper initialization/uninitialized memory exposure in a kernel network dissector. The target code initializes the `EVP_CIPHER_CTX` context and buffers (`memset(key, 0, keylen)`). The shared theme is \"proper initialization of C structures.\" A potential flaw in the target code could be missing initialization (though `EVP_EncryptInit` is called) or incorrectly handling the `cipher_ctx` state on error paths. However, the domains (kernel networking vs. userland crypto) and the specific manifestations are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2021-46664_before_subset_100:ac700691:vulspec": {
    "timestamp": "2026-01-17T02:40:56.747988",
    "cve_id": "CVE-2021-46664",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ac700691",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk image library (libguestfs) related to file content processing and error handling. The target code is MySQL/MariaDB subquery optimization logic with no direct memory management operations like allocation or freeing. The domains and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in libxml2 related to improper restriction of external entity references during XML parsing. The target code performs SQL subquery optimization and execution planning. There is no similarity in functionality, input processing, or vulnerability type.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in radare2's basic block analysis due to improper linked list cleanup. The target code manages SQL query execution plans and subquery optimization without low-level memory management of complex linked structures. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a CRLF injection/command injection vulnerability in CUPS PPD file generation. The target code is database query optimization logic that processes SQL parse trees, not text generation with injection concerns. Different domains and vulnerability types.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves improper input validation in Samba's LDAP-to-SQL translation, leading to NULL pointer issues. The target code also processes query structures (SQL subqueries) and has error handling paths. There is a superficial similarity in processing hierarchical query representations, but the vulnerability mechanisms (NULL pointer vs. state management) and domains differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a heap buffer overflow in glibc's glob() function due to off-by-one calculation. The target code performs logical optimization of SQL queries without string manipulation, path expansion, or buffer management. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an uninitialized memory issue in the Linux kernel's network flow dissector. The target code is user-space database logic focused on query plan state management. Different environments, domains, and vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a resource exhaustion vulnerability in ImageMagick due to lack of validation between image dimensions and data size. The target code optimizes query execution plans; while it allocates memory for join structures, it doesn't parse untrusted binary file headers or have similar validation gaps.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a use-after-free in Exim's SMTP header processing during memory release. The target code manages SQL query execution context without analogous store_release() operations or email header parsing. Different application domains and memory management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a path validation/symlink race condition in libarchive during archive extraction. The target code operates on in-memory SQL parse trees, not filesystem paths or archive contents. Completely different vulnerability types and domains.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      }
    ]
  },
  "CVE-2012-6113_after_subset_100:f55c2194:vulspec": {
    "timestamp": "2026-01-17T02:41:07.947948",
    "cve_id": "CVE-2012-6113",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f55c2194",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in a virtual machine disk image library. The target code is an OpenSSL decryption function in PHP. While both involve memory management, the domain, functionality, and specific flaw patterns (double-free vs. potential buffer/initialization issues) are fundamentally different. The target code shows careful cleanup with conditionals to avoid double frees.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 (CVE-2019-11470) is an uncontrolled resource consumption (CWE-400) issue in an image decoder due to lack of validation between declared dimensions and actual data. The target code performs cryptographic operations with fixed-size allocations based on cipher block size. While both parse input, the attack vector (malformed image headers vs. encrypted data) and the nature of the flaw (unbounded allocation vs. bounded calculation) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 (CVE-2018-12320) is a use-after-free/double-free in a reverse engineering tool's linked structure cleanup. The target code manages simple, linear buffers and cleans up resources in a straightforward sequence. The complexity of managing circular references in graph-like structures (basic blocks) is absent from the target code's memory management pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 4 (CVE-2016-8670) is a buffer overflow in PHP's GD library due to incorrect bounds checking involving arithmetic underflow. The target code is also within PHP core, handles user input (data, password, IV), and performs memory operations (malloc, memcpy). The relevance is elevated because both are in the same system (PHP) and involve parsing untrusted input with potential for miscalculation (e.g., `outlen = data_len + EVP_CIPHER_block_size(cipher_type)` could theoretically overflow). However, the specific flaw pattern (arithmetic underflow in image processing vs. cryptographic buffer sizing) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 (CVE-2017-15400) is a CRLF injection/command injection in a printing system's PPD file generation. The target code performs symmetric decryption and does not generate structured text files or execute commands. The domains (printing vs. cryptography) and vulnerability classes (injection vs. memory corruption) are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 (CVE-2017-15670) is a heap buffer overflow due to an off-by-one error in a path expansion function. The target code allocates buffers (`outbuf`) based on calculations involving `data_len` and cipher block size. While both involve buffer allocation based on input-derived sizes, the specific cause (off-by-one in string expansion) is not evident in the target code. The relevance is limited to the general theme of calculating buffer sizes.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 7 (CVE-2013-7459) is an out-of-bounds write in a cryptographic library (pycrypto) due to improper handling of an Initialization Vector (IV) parameter for cipher modes that don't use one (like ECB). The target code is the `openssl_decrypt` function in PHP, which also handles cipher modes, keys, and IVs. The key flaw similarity is critical: both functions accept an IV parameter from the user and pass it to the cryptographic context without first validating if the requested cipher mode actually requires an IV. In the target code, `php_openssl_validate_iv` is called, but it may still allow a non-NULL IV for modes like ECB. This pattern of improper parameter validation for cryptographic operations is highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-7459"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability. The target code deals with binary decryption, not XML parsing. The attack surfaces (XML documents vs. encrypted data blobs) and vulnerability classes (external entity expansion vs. memory/crypto issues) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 (CVE-2017-13033) is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code parses input (`data`) but its length is used directly in memory operations (`memcpy`, `EVP_DecryptUpdate`) after potential base64 decoding. While both involve parsing untrusted input, the target code's operations are bounded by the allocated `outbuf` size, and the primary risk is more related to the cryptographic context than raw length field validation. The similarity is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 (CVE-2017-13715) is an improper initialization issue in a network flow dissector leading to uninitialized memory exposure. The target code initializes the `EVP_CIPHER_CTX` structure (`cipher_ctx`) on the stack and uses `EVP_DecryptInit` followed by `EVP_DecryptInit_ex`. If an error occurs between these calls or in a different code path, the context might be used in a partially initialized state. Additionally, the stack-allocated context is cleaned up with `EVP_CIPHER_CTX_cleanup` at the end. The pattern of initializing a complex context object and ensuring it's properly cleaned up in all paths is similar. However, the domains (kernel networking vs. userland crypto) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2021-46664_after_subset_100:84bf2b44:vulspec": {
    "timestamp": "2026-01-17T02:41:22.223063",
    "cve_id": "CVE-2021-46664",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "84bf2b44",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk image library (libguestfs) related to file content processing. The target code is MySQL/MariaDB subquery optimization logic with no apparent memory deallocation patterns or similar error handling paths.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in libxml2 related to improper restriction of external entity references during XML parsing. The target code performs SQL query optimization with no XML parsing or external resource handling.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free vulnerability in radare2's binary analysis component involving improper cleanup of linked data structures. The target code manages query execution plans and subquery optimization without similar pointer manipulation or linked list deallocation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves CRLF injection in CUPS during PPD file generation from IPP responses. The target code is database query optimization with no text generation, protocol parsing, or injection vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 involves improper input validation in Samba's LDAP query processing leading to NULL pointer issues. The target code has some error handling (return TRUE/FALSE) and state management, but focuses on query optimization rather than input parsing. Both involve complex query processing systems, but vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a heap buffer overflow in glibc's glob() function due to incorrect bounds calculations. The target code performs logical operations on query structures without buffer manipulation or arithmetic boundary checks.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves improper initialization in Linux kernel's network flow dissector leading to uninitialized memory exposure. The target code initializes and manages query execution state properly with no similar memory exposure patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a resource consumption vulnerability in ImageMagick due to unvalidated image dimensions. The target code manages query optimization resources but includes proper limit checks (set_limit) and doesn't allocate memory based on untrusted input dimensions.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a use-after-free vulnerability in Exim's SMTP message processing during header parsing. The target code manages query execution plans without similar dynamic memory management or message parsing patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves improper input validation in libarchive's hardlink extraction leading to path traversal issues. The target code processes SQL query structures internally with no filesystem operations or path validation requirements.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      }
    ]
  },
  "CVE-2021-46225_before_subset_100:63506481:vulspec": {
    "timestamp": "2026-01-17T02:41:57.884896",
    "cve_id": "CVE-2021-46225",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "63506481",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 (CVE-2013-2124) involves a double-free vulnerability in libguestfs during error handling. The target code uses `longjmp` for error handling with cleanup (freeing memory, closing files), which is a complex pattern that could lead to similar resource management issues (e.g., double-free if `longjmp` is misused or if cleanup is called multiple times). However, the specific double-free trigger and memory ownership semantics in the libguestfs case are not directly mirrored in the provided code. The relevance is low but non-zero due to the shared theme of error-handling complexity.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 2 (CVE-2019-11470) is an uncontrolled resource consumption (CWE-400) issue in ImageMagick due to lack of validation between declared image dimensions and actual file data. The target code validates version (`msh->ver`) and dimension (`msh->dim`) fields read from the file header against hardcoded ranges (1-4 and 2-3). While it performs basic validation, it does not later validate that the file contains enough data for the declared structure, which is a similar conceptual flaw. The pattern of trusting header values without subsequent data availability checks is shared.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability in libxml2. The target code parses a custom mesh file format, not XML. There is no entity expansion, no external reference fetching, and no related functionality. The vulnerability type and attack surface are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 (CVE-2016-8670) is a buffer overflow/underflow in PHP's GD library due to incorrect bounds checking. The target code uses `strcpy` to copy `FilNam` into `msh->FilNam` after a length check against `GmfStrSiz`. This is a classic buffer overflow prevention pattern, but it is correctly implemented here (check then copy). The relevance stems from the shared concern of buffer bounds validation for string operations, but the specific flaw (arithmetic underflow) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 (CVE-2017-12667) is a memory leak in ImageMagick's MAT parser during error handling. The target code has extensive error handling using `longjmp` which centralizes cleanup (free, fclose, close). This pattern, if not carefully managed, could lead to memory leaks if resources are allocated before the `longjmp` but not added to the cleanup logic. However, the provided code snippet shows cleanup for the main `msh` struct and file handles. The relevance is in the shared context of error-path resource management.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 6 (CVE-2017-15670) is a heap buffer overflow in glibc's glob due to an off-by-one allocation error. The target code does not contain complex dynamic string allocation or path expansion logic similar to glob. The only string operation is the bounded `strcpy`. The vulnerability pattern is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 (CVE-2017-9499) is a reachable assertion (CWE-617) in ImageMagick due to insufficient validation of an input field (`number_meta_channels`). The target code validates integer inputs (`msh->ver`, `msh->dim`) against allowed ranges. This is a direct parallel: validating numeric values read from a file header. The target code's validation is correct for its context, but the case is relevant as an example of what happens when such validation is missing or inadequate.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CVE-2017-15400) is a CRLF injection/command injection in CUPS during PPD file generation. The target code writes data to a file using `fprintf` but does not generate scripts or configuration files that are later parsed/executed. It writes binary data or simple formatted text (version, dimension). There is no injection vector or command execution context.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 (CVE-2016-5418) is a path validation/symlink race condition in libarchive during hardlink extraction. The target code opens a file based on a user-provided path (`FilNam`). It does not extract archives or create links. The only tangential similarity is the use of a user-controlled string for a filesystem operation (`open`, `fopen`), but there is no path traversal or link resolution complexity evident in this function.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      }
    ]
  },
  "CVE-2021-46225_after_subset_100:d2e06400:vulspec": {
    "timestamp": "2026-01-17T02:42:26.215613",
    "cve_id": "CVE-2021-46225",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d2e06400",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves a double-free vulnerability in error handling paths of libguestfs. The target code uses `longjmp` for error handling with cleanup (freeing memory, closing files), but there's no evidence of double-free or complex ownership issues. Both involve resource cleanup on error, but the vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves CWE-400 (Uncontrolled Resource Consumption) in ImageMagick due to lack of validation between declared image dimensions and actual data. The target code validates version (1-4) and dimension (2 or 3) fields from file headers, preventing extreme values that could cause excessive allocation. Both involve validating header fields from external files, though the specific fields and consequences differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves XML external entity (XXE) processing in libxml2. The target code processes mesh/solution files with simple binary/ASCII formats, not XML. No entity resolution or complex parsing that could lead to similar attacks.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 involves CWE-119 (buffer bounds issues) in PHP's GD library due to incorrect bounds checking with potential underflow. The target code has buffer usage with `strcpy` into `msh->FilNam` after a length check against `GmfStrSiz`. While both involve bounds checking, the target's check appears correct (though `+7` is suspicious), and the vulnerability patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 involves a memory leak in ImageMagick's error handling. The target code has comprehensive error handling with `longjmp` that frees the `msh` structure and closes files. Both involve resource management during errors, but the target appears to clean up properly, making the vulnerability pattern different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 involves a heap buffer overflow in glibc's glob() due to off-by-one allocation. The target code doesn't perform complex string expansion or similar allocation calculations that could lead to similar off-by-one errors.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 involves CWE-617 (Reachable Assertion) in ImageMagick due to insufficient validation of numeric input (`number_meta_channels`). The target code validates numeric inputs (version 1-4, dimension 2 or 3) from file headers. Both involve validating numeric fields from external files to prevent assertion failures or controlled crashes, though the target uses `longjmp` rather than assertions.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves CRLF injection in CUPS PPD generation. The target code doesn't generate configuration files with embedded user input that could lead to injection attacks. It reads/writes binary/ASCII mesh data with structured formats.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 9 involves CWE-125 (Out-of-bounds Read) in ImageMagick's SGI coder due to insufficient validation of image dimensions. The target code validates dimension values (must be 2 or 3) and version-specific constraints. Both involve validating dimension fields from file headers before memory operations, though the target's constraints are much tighter (only 2 valid values).",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 involves path validation issues in libarchive during extraction. The target code copies a filename (`FilNam`) into a buffer with length checking, but doesn't perform complex path resolution or filesystem operations that could lead to symlink/hardlink issues. Both involve input validation, but the vulnerability domains differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      }
    ]
  },
  "CVE-2021-37651_before_subset_100:7e088572:vulspec": {
    "timestamp": "2026-01-17T02:42:40.792381",
    "cve_id": "CVE-2021-37651",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7e088572",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management flaw in a file processing library. The target code is a TensorFlow kernel performing arithmetic operations on tensors with no dynamic memory allocation/deallocation in the shown path. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves resource consumption via unvalidated dimensions leading to excessive allocation. The target code does validate tensor dimensions (e.g., OP_REQUIRES checks) and uses pre-allocated tensors. While both involve processing multi-dimensional data, the flaw pattern (unchecked allocation vs. arithmetic division) and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves CRLF injection in a printing protocol. The target code performs numerical computations on tensor data with no string parsing, protocol handling, or command generation. The domains and vulnerability patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 involves a bounds checking flaw due to arithmetic underflow in an image processing library. The target code involves careful index calculations (e.g., in_row_end, in_col_end) with clamping via std::min. While both process multi-dimensional data, the target code shows explicit bounds protection, making the flaw pattern less similar. However, the domain of numerical tensor/image processing is related.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 involves an assertion failure due to unvalidated numeric input in an image library. The target code validates inputs via OP_REQUIRES and does not contain assertions. The vulnerability mechanism (reachable assertion) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 involves an integer overflow leading to an infinite loop in a filesystem block calculation. The target code performs numerous integer calculations for indices and pooling cell sizes (e.g., num_elements_in_pooling_cell). While the target code uses 64-bit integers and clamping, the pattern of integer arithmetic on user-influenced dimensions is similar. However, there is no evident loop exit condition based on these calculations in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves a use-after-free/double-free in a linked structure within a reverse engineering tool. The target code has no dynamic memory management of pointer-based structures; it operates on contiguous tensor buffers. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 involves a buffer overflow in a network driver due to incorrect fragment count handling. The target code does not process network packets or variable-length fragments. While both involve multi-dimensional data, the context and flaw pattern (buffer overflow vs. arithmetic division) are different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves uninitialized memory exposure in a network packet parser. The target code explicitly zero-initializes its temporary tensor (`setZero()`) and does not parse complex protocol headers. The vulnerability types are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 involves an out-of-bounds read in an assembler due to missing bounds checks on an array index. The target code uses loop variables to index into tensors, with bounds implicitly defined by loop limits and tensor dimensions. While both involve index calculations, the target code's structure (nested loops over validated ranges) makes an out-of-bounds access less likely, and the flaw pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      }
    ]
  },
  "CVE-2021-37651_after_subset_100:9d65a7d3:vulspec": {
    "timestamp": "2026-01-17T02:43:10.943767",
    "cve_id": "CVE-2021-37651",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9d65a7d3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a file processing library due to improper memory ownership and cleanup. The target code is a TensorFlow kernel performing tensor backpropagation with arithmetic operations and memory allocation via framework APIs. No manual memory management, pointer manipulation, or similar error handling paths exist.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is about uncontrolled resource consumption (CWE-400) in an image parser due to lack of validation between declared dimensions and actual data. The target code validates input tensor dimensions (e.g., checks for non-zero dimensions) and uses safe loops bounded by validated sizes. The core flaw pattern (unchecked user-controlled allocation size) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 involves CRLF injection (CWE-93) leading to command injection in a printing protocol handler. The target code performs numerical computations on tensor data with no string processing, protocol parsing, or command generation. The vulnerability domains (text injection vs. numerical tensor ops) are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 is a buffer overflow (CWE-119) in an image library due to incorrect bounds checking involving arithmetic underflow. The target code contains loop calculations with indices (e.g., `in_row_end - in_row_start + 1`) that could theoretically underflow if `in_row_end < in_row_start - 1`, but the surrounding logic using `std::min` and sequence tensors likely prevents this. The pattern of arithmetic operations on indices is similar, but the context and risk level differ significantly (image parsing vs. internal tensor shape math).",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a reachable assertion (CWE-617) due to insufficient validation of a numeric input field. The target code validates tensor dimensions (non-zero checks) and sequence tensor sizes, but does not have assertions or similar validation of computed values like `num_elements_in_pooling_cell`. The similarity is limited to the general concept of input validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 6 is an integer overflow (CWE-190) leading to an infinite loop (CWE-835) in a filesystem block calculation. The target code performs multiple arithmetic operations on `int64_t` indices (multiplications like `b * out_rows + r`, subtractions like `in_row_end - in_row_start`). If `row_seq_tensor` or `col_seq_tensor` contain malicious values (e.g., making `in_row_start > in_row_end`), the calculation of `num_elements_in_pooling_cell` could overflow or become negative/zero, leading to division by zero in `out_backprop_element / num_elements_in_pooling_cell`. The pattern of index arithmetic without overflow checks is similar, though the specific trigger (malicious sequence tensors) differs from the filesystem case.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a use-after-free (CWE-416) due to improper linked list cleanup in a reverse engineering tool. The target code uses Eigen matrix maps and TensorFlow tensors with managed memory, no manual pointer manipulation or complex data structure cleanup. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow (CWE-119) in a network driver due to incorrect feature declaration and insufficient buffer allocation for fragmented packets. The target code operates on pre-allocated tensors with sizes determined by validated dimensions. No direct buffer management or feature negotiation exists. The only weak similarity is the potential for miscalculation of required space (like `num_elements_in_pooling_cell`), but not in a buffer allocation context.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is improper initialization (CWE-665) leading to uninitialized memory exposure in a network packet parser. The target code explicitly zero-initializes the temporary tensor (`setZero()`). While both involve state management, the target code's state is simple and well-initialized. The error condition handling is minimal and does not leave partial state.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read (CWE-125) in an assembler due to missing bounds check on an array index. The target code uses array-like indexing via `coeffRef` on Eigen matrices, but the indices are derived from loop counters bounded by validated tensor dimensions. No user-controlled, unchecked direct array indexing occurs. The pattern of potential index miscalculation exists but is far less direct.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      }
    ]
  },
  "CVE-2019-11598_before_subset_100:bae2a0d2:vulspec": {
    "timestamp": "2026-01-17T02:43:22.084095",
    "cve_id": "CVE-2019-11598",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bae2a0d2",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve ImageMagick's image processing core and memory allocation based on image dimensions/colors. The target code allocates memory for `colormap_index` based on `image->colors` or `MaxColormapSize`, similar to CVE-2019-11470's dimension-based allocation. The flaw pattern of insufficient validation before allocation is conceptually similar, though the specific trigger (grayscale conversion vs. Cineon parsing) and vulnerability type (potential DoS vs. confirmed DoS) differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image processing libraries (ImageMagick vs. PHP's GD) and memory operations. However, CVE-2016-8670's core flaw is an arithmetic underflow leading to improper bounds checking in buffer transfers. The target code performs bounds-checked array accesses (`colormap_index[intensity]`) where `intensity` is derived from `ScaleQuantumToMap`, which likely provides some bounds. The memory management patterns and vulnerability types (OOB read/write vs. resource management) are not strongly aligned.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to error handling and memory ownership. The target code uses `AcquireQuantumMemory`/`RelinquishMagickMemory` with clear, single-owner patterns and does not show obvious double-free or ownership transfer issues. The functional domains (image color conversion vs. VM disk inspection) and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are within ImageMagick and involve processing image metadata that influences internal structures (colormap vs. channel attributes). CVE-2017-9499 is a reachable assertion due to insufficient validation of a numeric field (`number_meta_channels`). The target code reads and uses `image->colors`, a similar internal numeric state, but does not have an obvious, analogous assertion trigger. The relevance lies in the pattern of trusting internal state without sufficient validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection vulnerability in CUPS during PPD file generation from external input. The target code is an internal image processing function in ImageMagick that does not generate files, parse external strings, or involve command execution. The vulnerability class and attack surface are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are in ImageMagick and involve potential out-of-bounds read issues stemming from insufficient validation of image properties before memory access. CVE-2016-7101 triggers on malicious image dimensions. The target code uses `image->rows` and `image->columns` in loops and accesses `colormap_index` based on calculated `intensity`. If `image->colors` or the calculated index were maliciously large (e.g., via a crafted image before this function is called), similar OOB reads could occur. The code pattern of using image properties to index arrays is shared.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are in ImageMagick. CVE-2017-12667 is a memory leak in an error path of a file decoder. The target code has multiple error paths that release allocated memory (`colormap_index`, `colormap`) before throwing an exception, showing awareness of cleanup. However, a subtle leak could exist if an error (like `status=MagickFalse`) occurs mid-loop after `image->colors` has been incremented but before resources are freed. The shared context is resource management in ImageMagick, but the specific leak pattern is not clearly replicated.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image processing libraries and resource management errors. CVE-2015-8877 is a memory leak in a scaling function. The target code also manages temporary memory (`colormap_index`, `colormap`) and must ensure it is freed on all paths. The relevance is generic to the pattern of symmetric allocation/deallocation in image processing code, but the specific flaw (leak in a two-pass scaling algorithm) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. High relevance. Both are in ImageMagick's core image processing routines and involve potential out-of-bounds reads when accessing pixel data arrays. CVE-2019-13302 involves inconsistent channel counts leading to OOB reads during pixel iteration. The target code iterates over pixels with `q+=GetPixelChannels(image)` and accesses `image->colormap` using an index. If `image->colors` is corrupted or `colormap_index[intensity]` is an invalid index, it could lead to an OOB read when accessing `image->colormap[...]`. The pattern of pixel traversal and array indexing based on image state is very similar, and both functions are susceptible to state corruption from a prior processing stage.",
        "case_metadata": {
          "cve_id": "CVE-2019-13302"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are in ImageMagick and involve risks related to image dimensions and memory. CVE-2018-12600 is an out-of-bounds write due to integer overflow/insufficient validation in a file decoder. The target code performs writes via `SetPixelIndex` based on a calculated index. While it doesn't show an obvious integer overflow, the pattern of writing to pixel data based on derived indices (`colormap_index[intensity]`) shares conceptual similarity with writing based on calculated positions. The vulnerability type (OOB write) is more severe than what's immediately apparent in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2018-12600"
        }
      }
    ]
  },
  "CVE-2019-11598_after_subset_100:e4380e83:vulspec": {
    "timestamp": "2026-01-17T02:43:52.678058",
    "cve_id": "CVE-2019-11598",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e4380e83",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve ImageMagick's image processing core and memory allocation based on image dimensions/colors. The target code allocates memory for `colormap_index` based on `image->colors` or `MaxColormapSize`, similar to CVE-2019-11470's dimension-based allocation. The flaw pattern of insufficient validation before allocation is relevant, though the specific subsystem (grayscale conversion vs. Cineon decoder) differs.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image processing libraries (ImageMagick vs. PHP GD) and memory buffer operations. However, CVE-2016-8670's core flaw is an arithmetic underflow in a bounds check (`remain == 0`), leading to OOB read/write. The target code performs bounds-checked array accesses (`colormap_index[intensity]`) where `intensity` is derived from `ScaleQuantumToMap`, which likely provides some validation. The memory management patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free in libguestfs due to error handling and ownership issues. The target code uses `AcquireQuantumMemory`/`RelinquishMagickMemory` with clear ownership and no double-free patterns. Both involve C memory management, but the vulnerability type and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Both are within ImageMagick and involve insufficient validation of numeric inputs leading to potential assertion failures or out-of-bounds access. CVE-2017-9499 fails to validate `number_meta_channels` against `MaxPixelChannels`. The target code uses `image->colors` to index `colormap` and `colormap_index` after potential growth in a loop, but lacks explicit validation against allocated size (`MaxColormapSize`). The pattern of trusting unchecked counts is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection in CUPS PPD generation. The target code is an ImageMagick image processing function with no string parsing, command execution, or CRLF handling. No meaningful similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are ImageMagick coders/processing functions where insufficient validation of image dimensions/colors can lead to memory issues (OOB read in CVE-2016-7101). The target code uses `image->colors` and `image->rows` for loops and allocations. While it doesn't directly read these from an untrusted file header in this function, it relies on values potentially set by earlier parsing stages. The pattern of using unchecked counts for memory operations is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are in ImageMagick and involve resource management (memory leaks). CVE-2017-12667 is a leak in error paths. The target code has multiple error paths that release `colormap_index` but not `colormap` if `AcquireQuantumMemory` fails after `colormap` allocation (line after `qsort`). This is a similar error-handling flaw pattern, though not identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve image processing libraries and resource management errors (memory leaks). CVE-2015-8877 is a leak in a scaling function due to asymmetric cleanup. The target code, as noted for Case 7, has a potential leak if `AcquireQuantumMemory` for `colormap` fails. The pattern of missing cleanup in error paths is similar, though the context (grayscale conversion vs. image scaling) differs.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Both are in ImageMagick core processing functions and involve potential out-of-bounds read/write due to inconsistent channel/color count handling. CVE-2019-13302 involves mismatched channel counts between images. The target code increments `image->colors` in a parallel region with a critical section, but later uses `image->colors` to iterate and allocate `colormap`. If the parallel increment leads to `image->colors` exceeding allocated `colormap` size (initially `MaxColormapSize`), it could cause OOB access. This is a similar concurrency/validation flaw pattern.",
        "case_metadata": {
          "cve_id": "CVE-2019-13302"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are ImageMagick functions handling image data with potential for out-of-bounds write due to insufficient dimension/color validation. CVE-2018-12600 involves integer overflow in size calculation. The target code calculates `colormap_index` size using `MagickMax` and multiplies in `memset`. While not obviously vulnerable to overflow, the pattern of using image properties for memory operations without rigorous bounds checking is relevant. The `colormap_index` is indexed by `intensity` (capped by `ScaleQuantumToMap`) and `colormap` by `image->colors`, which could grow unchecked.",
        "case_metadata": {
          "cve_id": "CVE-2018-12600"
        }
      }
    ]
  },
  "CVE-2018-25033_before_subset_100:8ced705b:vulspec": {
    "timestamp": "2026-01-17T02:44:13.370008",
    "cve_id": "CVE-2018-25033",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8ced705b",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs simple arithmetic and conditional decrements on integer statistics. It does not involve any dynamic memory management (allocation, freeing, or pointer manipulation), which is the core of CVE-2013-2124 (Double Free). The functional domains and code patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code is a simple statistical update function for a 3D mesh structure. It does not parse any input, handle entities, or process any data formats like XML. The vulnerability class (XXE) and attack surface are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not free any memory, manage linked lists, or manipulate pointers that could lead to a Use-After-Free or Double Free condition. It operates on a simple array of structs and updates integer counters. The core flaw mechanisms are not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code does not process any external input (like IPP attributes), generate files, or perform string manipulation where CRLF injection could occur. It is a purely internal bookkeeping function.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The only potential similarity is the concept of state tracking (counting neighbors) and updating statistics based on that state. However, CVE-2017-13715 is about improper initialization of complex network packet parsing state leading to information leaks, while the target code's state is simple, well-defined, and does not involve uninitialized memory or parsing untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code updates statistical counters. It does not handle file data, compression, metadata consistency, or sensitive information exposure. The core flaw of failing to sanitize data remnants is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2015-8374"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code contains no array or buffer operations, no pointer arithmetic, and no memory allocation. It is immune to buffer overflows. The code patterns and vulnerability class are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code does not parse any file format, allocate memory based on external inputs, or perform any validation of external data. It operates on an already-initialized internal data structure.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code does not read from arrays or buffers using indices derived from external/untrusted data. All array accesses (`stl->neighbors_start[facet_num]`) use a provided `facet_num` parameter, but there is no indication of bounds checking, which is a separate issue from the out-of-bounds read in CVE-2017-13033 which involved parsing packet fields. The code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code does not process network packets, manage buffers for data fragments, or perform any operations that could lead to a buffer overflow. The code is purely arithmetic and statistical.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2018-25033_after_subset_100:2976908d:vulspec": {
    "timestamp": "2026-01-17T02:44:17.732912",
    "cve_id": "CVE-2018-25033",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2976908d",
    "scores": [
      {
        "score": 3,
        "reasoning": "The target code performs simple arithmetic and updates statistics counters. It does not involve any dynamic memory allocation, deallocation, or pointer manipulation that could lead to a double-free (CWE-415). The functional domain (STL file processing vs. VM disk image inspection) and flaw pattern are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code does not parse any external data format (like XML), handle entities, or involve any form of input validation or restriction. It is a simple internal state update function.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not free any memory, manage linked data structures, or manipulate pointers that could become dangling. The \"update\" in the function name refers to decrementing integer counters, not memory deallocation. The risk of use-after-free (CWE-416) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code does not process any external input strings, perform output generation, or involve any form of injection (CRLF or otherwise). It operates purely on internal data structures.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The only similarity is that both functions perform conditional logic based on state (error checks, neighbor counts). However, the target code's error check is a simple early return and does not lead to improper initialization (CWE-665) or leave complex structures in an inconsistent state. The domain and complexity are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code updates statistical counters but does not handle file data, metadata, compression, or sensitive information. There is no risk of information exposure (CWE-200) from this counter update logic.",
        "case_metadata": {
          "cve_id": "CVE-2015-8374"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not perform any string manipulation, memory allocation, or buffer operations. It performs integer arithmetic and assignments, so heap buffer overflows (CWE-122) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not parse file headers, allocate memory based on external inputs, or validate any resource-consuming parameters. The integer operations are bounded and safe.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code accesses array elements (`stl->neighbors_start[facet_num].neighbor[0/1/2]`) but only after a bounds check (`facet_num < 0`). It does not parse variable-length data from an external source, so out-of-bounds read (CWE-125) risks are minimal and of a different nature.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code does not process network packets, manage buffers, or perform any operations that could overflow a memory buffer (CWE-119). The array accesses are fixed (index 0,1,2) and safe.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2022-36042_before_subset_100:04f49c65:vulspec": {
    "timestamp": "2026-01-17T02:45:03.572347",
    "cve_id": "CVE-2022-36042",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "04f49c65",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves a double-free vulnerability in libguestfs related to file content processing and error handling. The target code is from radare2/rizin, handling dyld cache rebase information with careful memory allocation and cleanup using goto beach pattern. While both involve memory management, the specific vulnerability type (double-free vs. potential buffer/integer issues), domain (VM disk inspection vs. binary analysis), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Case 2 is a use-after-free/double-free vulnerability in radare2 (the same project family as the target code, likely rizin). Both involve reverse engineering frameworks, complex data structure management (RzDyldRebaseInfos vs. basic blocks), and memory allocation/deallocation patterns. The target code shows similar error handling with goto beach and careful memory cleanup, making this case highly relevant for understanding common pitfalls in such codebases.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves uncontrolled resource consumption in ImageMagick due to lack of validation of image dimensions. The target code performs bounds checking (i < MAX_N_HDR) and validates read operations, but doesn't have similar unchecked user-controlled allocations. Both parse binary structures, but the vulnerability pattern (memory exhaustion vs. buffer/integer issues) and domain differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 4 involves improper bounds checking and integer underflow in PHP's GD library. The target code performs multiple bounds checks and uses ut32/ut64 types, but similar integer handling issues could occur in calculations like `slide_infos_offset + j * sizeof(cache_mapping_slide)`. Both parse binary formats and need to validate offsets/sizes read from buffers, though the specific vulnerability mechanism differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 involves XML external entity injection in libxml2. The target code parses dyld cache binary structures without any XML processing, entity resolution, or network operations. The vulnerability types (XXE vs. memory corruption) and domains (XML parsing vs. binary format parsing) are completely different with no overlapping code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 involves CRLF injection and command injection in CUPS PPD generation. The target code performs binary parsing without any command execution, text processing, or CRLF handling. The vulnerability types (injection vs. memory corruption) and domains (printing system vs. binary analysis) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 7 involves insufficient validation of numeric input fields leading to assertion failure in ImageMagick. The target code reads various numeric fields (slideInfoOffset, slideInfoSize, n_slide_infos[i]) from buffers and uses them in calculations. While not identical, both share the pattern of parsing binary headers and using unchecked numeric values in subsequent operations, which could lead to similar validation issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 involves heap buffer overflow due to off-by-one error in glibc's glob function. The target code performs memory allocations based on calculated sizes (total_slide_infos, k) and could potentially have similar boundary calculation errors. Both involve careful memory management and size calculations, though the specific overflow pattern and domain differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Case 9 involves out-of-bounds read in tcpdump due to insufficient validation of length fields before memory access. The target code reads multiple fields from buffers (rz_buf_read_le32_at, rz_buf_fread_at) and uses them as offsets (slide_infos_offset, entry.slideInfoOffset). Both parse binary structures where attacker-controlled values determine memory access locations, creating similar validation challenges.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Case 10 involves integer overflow in Linux kernel F2FS leading to infinite loop. The target code performs arithmetic operations like `slide_infos_offset + j * sizeof(cache_mapping_slide)` and `entry.fileOffset + hdr_offset` which could potentially overflow if offsets are maliciously crafted. Both handle binary format parsing with offset calculations, though the specific manifestation (infinite loop vs. memory corruption) may differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-36042_after_subset_100:29ae75c0:vulspec": {
    "timestamp": "2026-01-17T02:45:32.713569",
    "cve_id": "CVE-2022-36042",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "29ae75c0",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves a double-free vulnerability in libguestfs related to file content processing and error handling. The target code is a dyld cache rebase info parser in a reverse engineering context. Both involve memory management, but the vulnerability type (double-free vs. potential integer overflow/underflow), domain (VM disk inspection vs. binary format parsing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 2 is a use-after-free/double-free in radare2, which is the same ecosystem as the target code (likely from rizin/radare2). Both involve parsing complex binary structures (Java class files vs. dyld cache). The memory management patterns (allocating arrays, error handling with goto beach) are similar. However, the specific flaw (circular linked list cleanup) is not present in the target code, which focuses more on arithmetic validation and buffer reads.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is an uncontrolled resource consumption (CWE-400) in ImageMagick due to unvalidated image dimensions. The target code performs arithmetic operations (total_slide_infos addition with overflow check) and validates data sizes. Both involve validating input from a file format, but the vulnerability type (memory exhaustion vs. integer overflow/underflow) and domain (image parsing vs. binary rebase info parsing) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 is an improper bounds check due to arithmetic underflow in PHP's GD library. The target code contains an explicit integer overflow check (`if (total < total_slide_infos)`) when summing `n_slide_infos`. Both involve careful arithmetic validation when processing external input. The similarity lies in the need to prevent integer wrapping during size calculations, though the specific underflow pattern is not identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an XXE vulnerability in libxml2. The target code parses a binary dyld cache format with no XML processing, external entity resolution, or string-based parsing. The vulnerability types and domains are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a CRLF injection/command injection in CUPS via IPP attribute processing. The target code reads binary structures with `rz_buf_fread_at` and performs arithmetic, with no string parsing, command generation, or protocol handling. The attack surfaces and flaw types are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a reachable assertion (CWE-617) in ImageMagick due to lack of validation on a numeric field. The target code validates the `total_slide_infos` value before allocation and checks for overflow. Both involve validating numeric inputs from a file, but the manifestation (assertion crash vs. memory corruption/DoS) and context differ. The target code's validation is more proactive (overflow check).",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a heap buffer overflow in glibc's glob due to an off-by-one allocation error. The target code allocates memory based on calculated sizes (`RZ_NEWS0`) and could potentially have similar issues if the size calculation is wrong. However, the target code's overflow check protects one sum, but other calculations (like `k` vs. `total_slide_infos`) rely on correct parsing. The domains (pathname expansion vs. binary parsing) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an out-of-bounds read in tcpdump due to insufficient validation of length fields before memory access. The target code reads binary structures (`cache_mapping_slide`) using `rz_buf_fread_at` and uses fields like `slideInfoOffset` and `slideInfoSize` without obvious validation before passing them to `get_rebase_info`. Both involve parsing untrusted binary data with length/offset fields. The similarity is in the pattern of reading structured data from buffers, though the specific vulnerability type is not directly mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is an integer overflow (CWE-190) in the Linux kernel F2FS leading to an infinite loop. The target code explicitly checks for integer overflow when summing `total_slide_infos`. Both involve critical integer arithmetic when processing file/system structures to prevent security issues. The target code's check is a direct mitigation for the type of flaw seen in Case 10. The domains are different (filesystem vs. dyld cache), but the integer safety concern is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-23595_after_subset_100:25a7fdd3:vulspec": {
    "timestamp": "2026-01-17T02:45:51.871212",
    "cve_id": "CVE-2022-23595",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "25a7fdd3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file processing library (libguestfs). The target code is a TensorFlow/XLA compilation cache builder performing resource initialization and configuration parsing. There is no dynamic memory deallocation or similar error-handling paths that could lead to double-free. The domains and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in a printing system (CUPS) due to improper neutralization of IPP attribute values. The target code parses a configuration string (`visible_device_list`) but uses a dedicated parsing function (`ParseVisibleDeviceList`). There is no generation of script/command output, making injection patterns irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 3 is a reachable assertion (CWE-617) due to insufficient validation of numeric input in an image library. The target code does parse a numeric string (`visible_device_list`), but the validation responsibility lies within `ParseVisibleDeviceList`. The core functionality (compiler client setup) and the specific flaw pattern (unchecked `StringToUnsignedLong`) are not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 4 is an uncontrolled resource consumption (CWE-400) via unvalidated image dimensions leading to excessive memory allocation. The target code allocates a cache object and a client, but these are singular, managed objects, not based on unvalidated user-input dimensions. The risk pattern of allocating based on untrusted size fields is absent.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a use-after-free/double-free in a reverse engineering tool due to improper cleanup of linked data structures. The target code constructs new objects but does not perform complex deallocation or manage interconnected data structures like basic block graphs. The memory management patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an improper input validation (CWE-20) leading to path traversal issues in an archive library. The target code validates platform IDs and retrieves compilers via a manager API. It parses a device list string but does not perform filesystem path operations. The attack surfaces and validation contexts are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a heap buffer overflow (CWE-122) due to an off-by-one error in path expansion in glibc. The target code does not perform string expansion, pattern matching, or low-level buffer arithmetic. Its string handling is limited to passing configuration strings to parsing functions. The flaw mechanism is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an XXE (CWE-611) vulnerability in an XML parser. The target code does not parse any structured document formats like XML. It deals with platform IDs, compiler handles, and device configuration. The data processing models and associated vulnerabilities are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 9 is a buffer boundary violation (CWE-119) in an image library due to incorrect bounds checking and integer underflow. The target code uses `StatusOr` and `ValueOrDie()` patterns which, if misused, could cause crashes, but there is no direct buffer manipulation or arithmetic that could lead to underflow/overflow in a similar way. The similarity is only in the general concept of error handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an integer overflow (CWE-190) leading to an infinite loop in a filesystem. The target code performs arithmetic (`device->tensorflow_cpu_worker_threads()->num_threads`) to set thread counts. While integer overflows are a general concern, the specific context (block size calculations in FS) and consequence (infinite loop) are not mirrored here. The potential for integer issues exists but is minimal and not the code's focus.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-23595_before_subset_100:a0edd8b1:vulspec": {
    "timestamp": "2026-01-17T02:45:56.555236",
    "cve_id": "CVE-2022-23595",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a0edd8b1",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a resource initialization function for an XLA compilation cache, focusing on platform detection and client creation. Case 1 (CVE-2013-2124) is a double-free vulnerability in a file content processing module of a virtual disk inspection library. The domains (compiler infrastructure vs. VM disk inspection), vulnerability types (resource management errors vs. memory corruption), and code patterns (initialization and error propagation vs. file reading and cleanup) are fundamentally different. There is very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code handles platform identification and client library initialization. Case 2 (CVE-2017-15400) is an injection vulnerability (CRLF to command injection) in a printing system's PPD file generator. The core issues are unrelated: one is about input validation and sanitization of protocol data, the other is about safe API usage and error handling during system component initialization. The attack surfaces and flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Both involve processing external inputs (platform info/file metadata) but diverge significantly. Case 3 (CVE-2017-9499) is a reachable assertion due to lack of validation on a numeric input field (`number_meta_channels`). The target code performs validation (e.g., checking `platform.ok()`, `compiler_for_platform.ok()`) and propagates errors safely. While both must validate inputs, the vulnerability mechanism (assertion crash) and context (image parsing vs. runtime initialization) are very different, offering minimal reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 4 (CVE-2019-11470) is an uncontrolled resource consumption (CWE-400) issue due to unvalidated image dimensions leading to excessive allocation. The target code allocates a cache object but does not process size-controllable user data in a similar way. It validates the results of library calls (`platform.ok()`, `client.ok()`) but does not perform arithmetic on untrusted sizes. The resource consumption risk profile is much lower and different in nature.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 5 (CVE-2018-12320) is a use-after-free/double-free in a data structure cleanup function within a reverse engineering framework. The target code is a construction function that allocates an object (`new XlaCompilationCache`) and does not contain any complex internal data structure cleanup logic. The memory management contexts (allocating a single object vs. freeing a linked list) and vulnerability patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 6 (CVE-2016-5418) is an improper input validation (CWE-20) leading to path traversal issues in an archive extraction library. The target code parses a configuration string (`allowed_gpus`) but does so in a controlled context (visible device list for GPU configuration) unrelated to filesystem paths. The validation challenges and security implications are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 7 (CVE-2017-15670) is a heap buffer overflow due to an off-by-one error in a path expansion function. The target code does not perform string manipulation or buffer allocation based on user-controlled patterns. Its allocations are for objects, not character buffers, and it does not contain similar arithmetic for buffer sizing. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 8 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability. The target code does not parse XML or any structured document format. It processes platform IDs and configuration protobufs, but the attack vector (malicious external entities) and the parsing context are completely absent.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 9 (CVE-2016-8670) is a buffer bounds violation due to incorrect arithmetic validation (underflow). The target code contains arithmetic (`device->tensorflow_cpu_worker_threads()->num_threads`) but on trusted, internal data. The `ParseVisibleDeviceList` function could theoretically have parsing issues, but the code shown does not reveal low-level buffer operations. The core flaw pattern (integer underflow in buffer size calculation) is not evident here.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "This case has the highest, though still weak, relevance. Case 10 (CVE-2017-18257) is an integer overflow leading to an infinite loop in a filesystem. The target code does not contain loops or complex arithmetic on user-controlled integers. However, both involve system-level software (compiler runtime/kernel) and require robust error handling to prevent instability. The *potential* for resource exhaustion or hangs exists if `client_options.set_intra_op_parallelism_threads` receives a problematic value, but the source is not directly user-controlled. The vulnerability patterns are not similar, but the domain (low-level system components) shares some broad principles of defensive programming.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2019-11929_before_subset_100:1404ab40:vulspec": {
    "timestamp": "2026-01-17T02:45:56.709855",
    "cve_id": "CVE-2019-11929",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1404ab40",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual machine disk image library due to improper memory ownership and cleanup. The target code is a string formatting function with careful memory management using RAII-style String objects, making manual double-free unlikely. The domains (string formatting vs. VM disk access) and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is about CRLF injection leading to command injection in a printing system's PPD file generation. The target code performs numeric string formatting with no command execution, network protocol handling, or injection of control characters. The vulnerability class (injection) and context are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is a heap buffer overflow in glibc's glob() due to an off-by-one error in allocation calculation. The target code also performs careful buffer length calculations (reslen) to allocate memory, including checks for integer overflow. While the specific flaw (off-by-one in home directory expansion) differs, the pattern of calculating buffer sizes based on input parameters and the risk of miscalculation is similar and provides valuable reference for secure coding in the target function.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared dimensions and actual data. The target code validates input (dec parameter) and performs bounded calculations, but shares a conceptual similarity in performing arithmetic (integral + thousand_sep.size() * ((integral-1) / 3)) that could theoretically overflow, though it has an overflow check. The resource exhaustion risk is much lower and more controlled in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an XXE vulnerability in libxml2. The target code does not parse XML, handle external entities, or process untrusted structured data in a similar way. The vulnerability mechanisms are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 6 is a buffer overflow in PHP's GD library due to incorrect bounds checking and arithmetic underflow. The target code is also from PHP (or a PHP-like codebase) and performs similar buffer length calculations and memory operations. It includes explicit overflow checks (e.g., `if (integral + thousand_sep.size() * ((integral-1) / 3) < integral)`), which directly address the kind of integer overflow/underflow flaws seen in CVE-2016-8670. The domain (PHP core utilities) and the need for meticulous bounds checking are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a use-after-free/double-free in a reverse engineering tool due to improper linked list cleanup. The target code uses RAII-style String objects for automatic memory management, avoiding manual free() operations. The memory ownership patterns and flaw triggers are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 involves path validation and symlink race conditions in an archive extraction library. The target code formats numbers into strings and does not interact with the filesystem, create links, or validate paths. The vulnerability classes (CWE-20 vs. buffer/arithmetic issues) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code reads from its own internally generated buffer (`tmpbuf`) based on a known length (`tmplen`), and uses `memcpy` with calculated sizes. While both involve reading from buffers, the target code's data source and length are self-derived from `snprintf`, not directly from untrusted input, making OOB reads less likely. However, the pattern of using `memcpy` and pointer arithmetic warrants caution.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is improper initialization leading to uninitialized memory exposure in a network packet dissector. The target code initializes its buffers via `String(reslen, ReserveString)` and writes data before reading, minimizing uninitialized read risks. However, both involve parsing/formatting data with multiple steps where state management is important. The relevance is limited to the general principle of ensuring proper initialization and state consistency.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2019-11929_after_subset_100:364397b5:vulspec": {
    "timestamp": "2026-01-17T02:46:53.721744",
    "cve_id": "CVE-2019-11929",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "364397b5",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual machine disk image library due to error handling issues. The target code is a string formatting function with no dynamic memory deallocation, ownership transfer, or similar error paths that could cause double-free.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in a printing system due to improper neutralization of special sequences. The target code performs numeric string formatting with controlled inputs (dec_point, thousand_sep) and uses memcpy, with no command or output injection vectors.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a heap buffer overflow due to an off-by-one allocation error. The target code also performs buffer size calculations (reslen) and memory copies (memcpy), but it uses careful length calculations and snprintf with size limits. The similarity is in buffer size computation, but the flaw patterns differ (off-by-one vs. integer overflow checks present).",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is an uncontrolled resource consumption (memory exhaustion) vulnerability in an image parser due to lack of validation between declared and actual data size. The target code has bounded allocations based on snprintf output and validated 'dec' parameter, with explicit overflow checks (raise_error). No similarity in attack pattern.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is an XXE (XML External Entity) vulnerability. The target code has no XML parsing, external entity resolution, or network/data retrieval functionality. Completely different domain and vulnerability class.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 is a buffer overflow in PHP's GD library due to incorrect bounds checking and arithmetic underflow. The target code is also from PHP (string_number_format), involves buffer size calculations, memory operations (memcpy), and has integer arithmetic for buffer lengths (e.g., `integral + thousand_sep.size() * ((integral-1) / 3)`). Both deal with C++ string buffers and require careful bounds management. The primary similarity is in the domain (PHP internal functions) and the need for robust integer arithmetic to prevent overflows, though the specific flaw (underflow) is not obviously present here.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a use-after-free/double-free in a reverse engineering tool due to improper linked list cleanup. The target code uses String RAII wrappers (ReserveString) which manage memory automatically, with no manual free() or pointer-based structure manipulation that could cause use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a path validation/symlink race vulnerability in an archive library. The target code performs pure in-memory string formatting with no filesystem operations, path resolution, or race conditions.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an out-of-bounds read in a network protocol dissector due to insufficient length validation. The target code uses memcpy with calculated lengths and has bounds defined by reslen/tmplen. There is a general similarity in ensuring buffer accesses stay within bounds, but the context (network parsing vs. string formatting) and flaw pattern (missing validation vs. explicit checks) differ. The target code does have validation (e.g., overflow checks) but shares the common theme of buffer boundary safety.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an uninitialized memory exposure in a kernel network dissector due to improper state management on error paths. The target code initializes variables, uses RAII strings, and has no complex state machine or error paths that leave memory uninitialized.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2014-3566_before_subset_100:7c789221:vulspec": {
    "timestamp": "2026-01-17T02:47:23.372290",
    "cve_id": "CVE-2014-3566",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7c789221",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management flaw in a file processing utility. The target code is a TLS cipher suite negotiation function with no dynamic memory allocation or deallocation in the shown path. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a heap buffer overflow in glibc's glob function due to incorrect length calculation. The target code performs array bounds checking (datalen % 2) and uses fixed-size arrays (MAX_CIPHERSUITE_SIZE, MAX_ALGOS) with memcmp operations. No similar pattern of dynamic buffer allocation with off-by-one errors.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an XXE vulnerability in an XML parser. The target code processes TLS cipher suite lists, not XML data. The attack surfaces (network protocol negotiation vs. document parsing) and vulnerability patterns (entity expansion vs. array processing) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 is a NULL pointer dereference in an authentication state machine due to protocol sequence violation. The target code also handles protocol state (TLS handshake) and has credential checks, but it validates pointers (e.g., checking auth_struct != NULL) and doesn't show similar state machine confusion patterns. Some conceptual similarity in protocol handling but different flaw patterns.",
        "case_metadata": {
          "cve_id": "CVE-2015-4054"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a CRLF injection/command injection vulnerability in PPD file generation. The target code processes binary cipher suite identifiers with memcmp operations, not text-based protocol data that could embed injection sequences. Different vulnerability class entirely.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 6 involves improper initialization leading to information disclosure in a network packet parser. The target code also parses network data (TLS ClientHello cipher suites) and has initialization (memset of cipher_suite), but doesn't show similar error path state leakage patterns. Some similarity in network protocol parsing domain.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow in a network driver due to incorrect fragment count handling. The target code uses fixed-size arrays with bounds checking and doesn't process variable-length packet fragments. Different memory safety issue patterns.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an out-of-bounds read in a network protocol parser (BGP). The target code also parses network protocol data (TLS) and performs bounds checking (datalen % 2). Both involve parsing binary protocol fields, but the specific flaw pattern (insufficient validation of attribute length vs. cipher suite list processing) differs. Some reference value for protocol parsing safety.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Similar to case 8, this is an out-of-bounds read in a network protocol parser (VTP). The target code shares the domain of network protocol parsing and has similar structural patterns (iterating over protocol fields with index increments). However, the specific vulnerability mechanism (length field validation) isn't directly mirrored in the target's cipher suite list processing.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a use-after-free/double-free in a reverse engineering tool's data structure cleanup. The target code has no dynamic memory management of complex linked structures. Completely different memory management patterns and vulnerability types.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      }
    ]
  },
  "CVE-2020-20276_before_subset_100:ac1192cc:vulspec": {
    "timestamp": "2026-01-17T02:47:34.129649",
    "cve_id": "CVE-2020-20276",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ac1192cc",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management flaw in a file processing library. The target code is a simple FTP command parser with no dynamic memory allocation or complex resource management. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a kernel-level USB driver stack buffer overflow related to DMA and VMAP_STACK. The target code is a user-space FTP server function performing basic string parsing and validation. The attack surfaces (USB vs. network protocol), memory models, and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 involves improper neutralization of CRLF sequences leading to injection. The target code uses `sscanf` and `sprintf` on untrusted input (`str`) without strict format validation, which could be a vector for buffer overflows or integer issues, though not specifically CRLF injection. Both involve parsing untrusted protocol data.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 4 is a buffer overflow due to insufficient validation of user-controlled length parameters. The target code uses `sscanf` on untrusted input without checking the number of successfully parsed items or the ranges of `a,b,c,d,e,f`. This could lead to buffer overflows if `addr` is overflowed by `sprintf` (though size is bounded by INET_ADDRSTRLEN) or integer overflows in port calculation. The pattern of parsing untrusted input without validation is similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an out-of-bounds read due to insufficient validation of length fields. The target code does not have explicit length field parsing, but the `sscanf` on untrusted input could leave variables uninitialized if parsing fails, leading to undefined behavior. Both involve lack of input validation, but the specific vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 involves an integer overflow leading to a denial of service. The target code calculates `ctrl->data_port = e * 256 + f`. If `e` or `f` are negative or large (outside 0-255), this can cause an integer overflow/wraparound, resulting in an invalid port number. This is a direct parallel: integer operation on untrusted input without range checks.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a buffer copy without checking input size in a virtual device emulator. The target code uses `sscanf` and `sprintf` with fixed buffers, which is generally safe regarding buffer size for `addr` (INET_ADDRSTRLEN). However, the lack of input validation before the copy operations is a similar high-level flaw, though the context and severity differ greatly.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to use-after-free in the kernel TTY subsystem. The target code is a simple, synchronous FTP command handler with no concurrency, dynamic memory, or resource sharing. The vulnerability classes are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 involves an integer overflow in a parameter check leading to incorrect memory allocation. The target code has a potential integer overflow in port calculation (`e * 256 + f`). While not leading to memory corruption directly, it could cause an invalid port and subsequent connection issues or unexpected behavior. The core issue of missing integer range validation on untrusted input is similar.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a use-after-free in a mail server due to complex memory ownership issues. The target code has no dynamic memory allocation or release; all variables are stack-allocated or simple integer/array members. The vulnerability patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      }
    ]
  },
  "CVE-2014-3566_after_subset_100:0c2da4fb:vulspec": {
    "timestamp": "2026-01-17T02:47:38.301230",
    "cve_id": "CVE-2014-3566",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0c2da4fb",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to file content processing and error handling. The target code is a TLS cipher suite negotiation function in GnuTLS, focusing on protocol parsing and selection logic. The vulnerability types (memory corruption vs. protocol logic), domains (virtual disk management vs. cryptographic protocol), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob() function due to an off-by-one error in string/memory handling. The target code performs array bounds checking (datalen % 2) and uses memcmp on fixed-size buffers. While both involve parsing input data, the vulnerability mechanism (allocation miscalculation), data types (path strings vs. cipher suite bytes), and attack surfaces are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in libxml2 related to external entity processing. The target code parses a list of cipher suite identifiers from a network packet but does not involve parsing complex structured data like XML, entity resolution, or file system access. The vulnerability class (injection/interpretation vs. logic error) and domain are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2015-4054 is a NULL pointer dereference in PgBouncer's authentication state machine due to protocol sequence violation. The target code also implements a protocol state machine (TLS handshake) and checks for NULL credentials (`_gnutls_get_kx_cred`). However, the vulnerability trigger is different (packet ordering vs. missing cipher suite match), and the target code has more robust error checking (returns error codes). Some reference value for state validation.",
        "case_metadata": {
          "cve_id": "CVE-2015-4054"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection in CUPS during PPD file generation. The target code reads binary cipher suite identifiers and compares them with a list; it does not generate text files, embed user input into scripts, or handle newline characters. The vulnerability patterns (injection vs. selection logic) and data flows are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13715 is an uninitialized memory disclosure in the Linux kernel flow dissector due to improper cleanup on error paths. The target code initializes `retval` and `session->security_parameters.cipher_suite`, and has structured error handling. Both parse network protocol data, but the vulnerability root cause (missing initialization on error vs. logic flaw in selection) and context (kernel vs. user-space library) differ. Some reference for ensuring state is defined on all paths.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2015-5156 is a buffer overflow in the Linux virtio-net driver due to incorrect feature declaration and fragment handling. The target code uses fixed-size arrays (`cipher_suites[MAX_CIPHERSUITE_SIZE]`, `pk_algos[MAX_ALGOS]`) and checks `datalen` against them indirectly via loops. Both involve parsing network data with potential for bounds issues. The relevance is limited because the target code's arrays are large and bounds are checked via loop limits, not direct buffer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-12994 is an out-of-bounds read in tcpdump's BGP parser due to insufficient bounds checking on TLV length fields. The target code parses a list of 2-byte cipher suites and validates `datalen % 2`. It does not parse variable-length TLV structures. However, both involve parsing attacker-controlled network packets and require careful length validation. The similarity is in the domain (protocol parsing) but not the specific vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-13033 is an out-of-bounds read in tcpdump's VTP parser due to insufficient validation of length fields. Similar to case 8, the target code parses a simpler fixed-format list (2-byte entries) and performs a basic length check. The relevance is in the general principle of validating input lengths in network protocol parsers, but the specific code patterns and complexity differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in radare2's basic block analysis due to improper linked list cleanup. The target code does not perform dynamic memory allocation or deallocation within the function; it works with stack arrays and session structure fields. The vulnerability classes (memory corruption vs. protocol logic) and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      }
    ]
  },
  "CVE-2020-20276_after_subset_100:808efdc9:vulspec": {
    "timestamp": "2026-01-17T02:47:48.447593",
    "cve_id": "CVE-2020-20276",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "808efdc9",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management flaw in a file processing library. The target code is an FTP server command handler that parses a string into integers and validates an IP address. There is no dynamic memory allocation, freeing, or similar resource management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is a stack buffer overflow in a USB driver related to DMA and VMAP_STACK. The target code uses `sscanf` into stack variables but with a fixed format expecting 6 integers, which is not directly analogous to a buffer overflow from untrusted length values. The attack surfaces and contexts are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves CRLF injection leading to command injection in a printer configuration generator. The target code parses a string from a network command, but the primary concern is integer parsing and IP validation, not neutralization of control sequences. Both handle untrusted input, but the vulnerability patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow due to insufficient validation of length parameters in a kernel driver. The target code uses `sscanf` without checking the number of successfully parsed items, which could lead to using uninitialized variables. This is a form of input validation flaw, but the context (SCSI vs. FTP) and specific overflow mechanism differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code does parse integers from a string but does not subsequently use them to read from memory buffers. The vulnerability class and code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is an integer overflow leading to an infinite loop in a filesystem. The target code performs arithmetic (`e * 256 + f`) which could theoretically overflow, but the context and impact (port number calculation vs. block mapping) are vastly different, and the specific flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a buffer copy without checking input size in a virtual device emulator. The target code uses `sscanf` and `snprintf` with fixed buffers, which is generally safe for the given usage. The vulnerability patterns (descriptor chain processing vs. string parsing) and domains are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to use-after-free in a kernel tty subsystem. The target code is a simple, synchronous command handler in what appears to be a single-threaded FTP server context. There are no concurrency or dynamic memory lifetime issues evident.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an integer overflow in an audio subsystem parameter check leading to incorrect memory allocation. The target code has integer operations but no memory allocation based on those results. The flaw patterns and system contexts share almost no similarities.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a use-after-free in an MTA during header processing. The target code has no dynamic memory allocation or pointer manipulation that could lead to a use-after-free. The code patterns and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      }
    ]
  },
  "CVE-2019-13133_before_subset_100:885827bc:vulspec": {
    "timestamp": "2026-01-17T02:48:41.906819",
    "cve_id": "CVE-2019-13133",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "885827bc",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve ImageMagick image format parsers (Cineon vs BMP) and share the core issue of insufficient validation between declared image dimensions and actual file data. The vulnerability type (resource consumption) and attack surface (malicious file with manipulated dimensions) are similar. However, the specific code patterns for dimension validation and memory allocation differ between the two format handlers.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are ImageMagick format decoders (SGI vs BMP) with nearly identical vulnerability patterns: insufficient validation of image dimensions (rows/columns) from file headers before memory operations. Both can lead to out-of-bounds reads/writes or denial of service. The attack surface (crafted image file) and root cause (lack of bounds checking) are highly similar, though the specific header structures differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While both involve ImageMagick, the vulnerability types differ significantly: CVE-2017-9499 is a reachable assertion due to improper validation of a specific metadata field (number_meta_channels), whereas the target BMP code focuses on dimension validation and buffer overflows. The code patterns and trigger conditions are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-12667 is a memory leak in error handling paths of the MATLAB MAT parser, while the target BMP code's primary concerns are dimension validation and buffer boundaries. The vulnerability types, trigger conditions, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve image processing and buffer handling issues, but CVE-2016-8670 is in PHP's GD library wrapper focusing on arithmetic underflow in buffer size calculations, while the target code is ImageMagick's BMP parser with different validation patterns. Some conceptual similarity in bounds checking but different implementations and contexts.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. CVE-2018-12600 is in ImageMagick's DIB coder (closely related to BMP format) with nearly identical vulnerability: insufficient validation of image dimensions leading to out-of-bounds write. Both handle similar compression methods (BI_RGB, BI_RLE4, BI_RLE8, BI_BITFIELDS) and share the same codebase patterns. The attack surface (malformed DIB/BMP file) and vulnerability type are almost identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-12600"
        }
      },
      {
        "score": 5,
        "reasoning": "Highly relevant, almost identical. CVE-2018-12599 is in the EXACT SAME MODULE (coders/bmp.c) as the target code. The vulnerability type (out-of-bounds write due to insufficient dimension validation), attack surface (malicious BMP files), and code patterns are virtually identical. This is essentially a historical vulnerability in the same function being analyzed.",
        "case_metadata": {
          "cve_id": "CVE-2018-12599"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs's file processing, completely unrelated to ImageMagick's BMP parsing. Different systems, different vulnerability types, and different code patterns provide no meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are ImageMagick format parsers (DICOM vs BMP) with similar issues of insufficient input validation leading to potential denial of service. Both involve parsing binary file headers and validating element sizes. However, the specific validation patterns and data structures differ significantly between medical imaging format and bitmap format.",
        "case_metadata": {
          "cve_id": "CVE-2018-16644"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both are ImageMagick decoders (RLE vs BMP) with similar vulnerability patterns: insufficient validation of image dimensions before memory allocation, potentially leading to resource exhaustion or buffer overflows. Both handle run-length encoded data (BI_RLE4/BI_RLE8 in BMP). The attack surface and vulnerability type are similar, though implementation details differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-8862"
        }
      }
    ]
  },
  "CVE-2019-13133_after_subset_100:2683a5c5:vulspec": {
    "timestamp": "2026-01-17T02:49:12.777703",
    "cve_id": "CVE-2019-13133",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2683a5c5",
    "scores": [
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve ImageMagick image parsers and potential resource exhaustion from unvalidated dimensions. However, CVE-2019-11470 targets Cineon format (cin.c) with a specific lack of validation between declared dimensions and file data size. The target BMP code does perform some size checks (e.g., comparing file_size to GetBlobSize, checking for negative/zero dimensions), making the flaw pattern less identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both are ImageMagick format parsers (SGI vs. BMP) where malicious header values (rows/columns) can lead to memory issues. The core flaw of insufficient dimension validation is similar. However, CVE-2016-7101 specifically leads to an out-of-bounds read, while the target BMP code has checks for negative/zero width/height and uses MagickAbsoluteValue, suggesting a different vulnerability pattern may be present.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-9499 involves an assertion failure due to an unvalidated numeric field (number_meta_channels) in the MPC format. The target BMP code reads many numeric fields (width, height, compression, etc.) and validates them against expected ranges (e.g., bits_per_pixel, compression type). The vulnerability type (CWE-617) and trigger condition (unbounded input) are different from the memory safety issues more common in BMP parsing.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are ImageMagick coders, but CVE-2017-12667 is a memory leak (CWE-401) in the MAT parser during error handling. The target BMP code has multiple error paths with resource cleanup (RelinquishMagickMemory, RelinquishVirtualMemory). While resource management is a common concern, the specific flaw pattern (leak on error path) is not directly evident in the provided BMP code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-8670 is in PHP's GD library wrapper, concerning buffer handling with integer underflow. The target code is a pure ImageMagick BMP parser in C. The system, domain, and vulnerability pattern (arithmetic underflow leading to bounds violation) are fundamentally different. No direct reference value for analyzing the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. CVE-2018-12600 is in the DIB coder (dib.c), which is closely related to BMP format (both use similar structures like BITMAPINFOHEADER). The vulnerability is an out-of-bounds write due to insufficient dimension validation before memory allocation. The target ReadBMPImage function performs similar operations: reading dimensions, calculating bytes_per_line, allocating memory via AcquireVirtualMemory based on these calculations. The code patterns and potential attack vectors (malformed header fields) are nearly identical, making this a highly valuable reference.",
        "case_metadata": {
          "cve_id": "CVE-2018-12600"
        }
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. This is a vulnerability in the exact same module (coders/bmp.c) and likely the exact same function (ReadBMPImage). The description matches the target code perfectly: BMP decoder, insufficient validation of dimensions leading to out-of-bounds write. The target code shows validations (e.g., width <= 0, height == 0) but these may be insufficient to prevent integer overflows in calculations like `bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32)` and the subsequent memory allocation. The vulnerability type, trigger conditions, and code patterns are almost identical.",
        "case_metadata": {
          "cve_id": "CVE-2018-12599"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free in libguestfs, a completely different system for VM disk inspection. The domain (image parsing vs. file reading in VM disks), vulnerability type (CWE-415 vs. potential buffer overflows/integer overflows), and code patterns have no meaningful similarity to the target BMP parsing code.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are ImageMagick coders where improper input validation (CWE-20) of file format elements can cause issues. CVE-2018-16644 targets length fields in DICOM elements, while the target BMP code validates various header fields (size, compression, bits_per_pixel). The similarity is generic (input validation) but the specific context (medical image format vs. standard bitmap) and flaw pattern differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-16644"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both are ImageMagick decoders (RLE vs. BMP) where malicious image dimensions can lead to memory allocation issues (CWE-119). The target BMP code handles RLE compression (BI_RLE4, BI_RLE8) and calls a DecodeImage function. The flaw pattern of insufficient dimension validation before allocation is similar. However, CVE-2016-8862 is specifically about the size check bypass via non-overflowing large values, while the target code's validation logic might differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-8862"
        }
      }
    ]
  },
  "CVE-2019-25038_before_subset_100:b3bfaddf:vulspec": {
    "timestamp": "2026-01-17T02:49:18.110616",
    "cve_id": "CVE-2019-25038",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b3bfaddf",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk inspection library due to memory ownership violations during error handling. The target code performs memory allocation and string formatting but does not show evidence of double-free patterns, complex ownership transfers, or similar error handling paths that could lead to double freeing.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parser due to improper restriction of external entity references. The target code processes DNSCrypt certificates and builds DNS resource records; it does not parse XML or handle external entities, making the vulnerability pattern fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a use-after-free vulnerability in a reverse engineering framework caused by incomplete cleanup of linked structures leading to double-free scenarios. The target code allocates and frees memory in a linear fashion within a single function and does not manage complex linked data structures where pointer invalidation could occur.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a CRLF injection/command injection vulnerability in a printing system due to improper neutralization of control sequences when generating configuration files. The target code builds DNS TXT record strings with escaping for non-printable characters, but the context (DNS local data vs. PPD file generation) and the injection vector are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a heap buffer overflow due to an off-by-one error in memory allocation calculations. The target code also performs memory allocation (rr = malloc(rrlen)) based on a calculated length. There is a superficial similarity in performing arithmetic to determine buffer sizes. However, the target code's calculation, while complex, does not show an obvious off-by-one error like the one in glibc's glob. The risk pattern (calculating buffer size from multiple inputs) is similar, but the specific flaw is not clearly present.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 is a buffer overflow due to insufficient validation of user-controlled length parameters. The target code calculates `rrlen` based on several string lengths and a fixed size, then uses `snprintf` with bounds. The relevance is higher than other cases because both involve calculating buffer sizes from inputs. However, the target code's inputs (`provider_name`, fixed struct size) are less directly attacker-controlled than a SCSI command length field, and `snprintf` with `rrlen - 1` provides some mitigation. The pattern of calculating a size and then writing is similar, but the vulnerability severity and control differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow in a network driver due to incorrect feature declaration leading to insufficient buffer allocation for fragmented packets. The target code deals with string formatting and certificate serialization, not network packet processing or scatter-gather lists. The underlying cause (mismatch between declared capability and actual handling) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an uncontrolled resource consumption (CWE-400) issue due to lack of validation between declared image dimensions and actual data. The target code allocates memory based on a calculated worst-case size for a known structure (`sizeof(struct SignedCert)`). While both involve allocation based on input-derived values, the target code's calculation is bounded by a fixed maximum (4 * sizeof(struct SignedCert)), preventing unbounded consumption. The flaw pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code reads from a fixed-size `SignedCert` structure in memory, not from a packet stream with untrusted length fields. There is no parsing of variable-length TLV structures that could cause OOB reads.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an improper input validation issue leading to path traversal and symlink race conditions during archive extraction. The target code manipulates DNS zone names and certificate data, not filesystem paths. The domain (archive extraction vs. DNS configuration) and the vulnerability class are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      }
    ]
  },
  "CVE-2019-25038_after_subset_100:7c932f61:vulspec": {
    "timestamp": "2026-01-17T02:49:25.530251",
    "cve_id": "CVE-2019-25038",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7c932f61",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves a double-free vulnerability in a file processing module due to ownership confusion during error handling. The target code performs memory allocation and string formatting but does not show complex ownership transfer or error paths that could lead to double-free. The primary concerns in the target code are buffer size calculation and formatting, not memory ownership semantics.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parser. The target code processes DNSCrypt certificate data and builds DNS resource records. There is no XML parsing, external entity resolution, or similar functionality. The domains and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 involves use-after-free due to improper cleanup of linked structures in a reverse engineering tool. The target code allocates memory, builds strings, and frees them in a linear fashion without complex data structures or pointer manipulation that could lead to use-after-free. The memory management is simpler and more contained.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves CRLF injection leading to command injection in a printing system. The target code builds DNS TXT records with careful escaping (backslash escaping for non-printable characters and quotes). While both involve string construction, the target code appears to properly neutralize special characters, and the context (DNS record vs. PPD file generation) is very different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 5 is a heap buffer overflow due to an off-by-one error in allocation calculation in glibc's glob function. The target code has a similar pattern: it calculates `rrlen` based on string lengths and a fixed overhead, then allocates and uses `snprintf`. There is a guard against integer overflow (`strlen(...) >= 0xffff0000`), but the calculation `rrlen = strlen(...) + strlen(...) + 4 * sizeof(struct SignedCert) + 2` could still be incorrect if it underestimates the actual needed space, especially since the loop adds escaped representations (up to 4 chars per byte). The `snprintf` calls use `rrlen - 1` as size, which might be off-by-one. This pattern of miscalculated buffer size is conceptually similar to CVE-2017-15670.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 is a buffer overflow in a kernel driver due to insufficient validation of length parameters. The target code calculates a length (`rrlen`) and allocates a buffer, but the calculation might not account for all possible output from the formatting loop (e.g., every byte of the cert could become a 4-character escape sequence `\\ddd`, but the calculation uses `4 * sizeof(struct SignedCert)` as a \"worst case,\" which might be correct but should be verified). If the calculation is wrong, a buffer overflow could occur in the `snprintf` calls. The pattern of calculating a size and then writing data is similar, though the target code is in user-space and deals with strings, not kernel buffers.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is a buffer overflow in a network driver due to incorrect feature declaration and buffer allocation. The target code's potential issue is also related to buffer allocation size calculation versus actual data written. The similarity is in the \"allocation may be insufficient for actual data\" pattern. However, the target code's context (string building for DNS) and the cause (possible miscalculation of escaped string length) are different from driver feature negotiation.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 involves uncontrolled resource consumption (memory) due to lack of validation between declared image dimensions and actual data. The target code has a guard against integer overflow for the provider name length, but the `rrlen` calculation uses `4 * sizeof(struct SignedCert)` as a fixed overhead for the worst-case escaped cert data. If `sizeof(struct SignedCert)` is very large, this could lead to excessive memory allocation. However, the cert size is likely fixed and trusted (comes from the environment, not external input). The similarity is in the potential for large allocation based on a calculated size.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is an out-of-bounds read in a packet parser due to insufficient validation of length fields. The target code does not parse length fields from untrusted data; it calculates sizes based on known object sizes and string lengths. The only similar aspect is the use of `snprintf` with a calculated length, which could lead to truncation but not out-of-bounds read.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low to weak relevance. Case 10 involves improper input validation leading to path traversal and link issues in an archive library. The target code deals with string construction and escaping for DNS records, not filesystem paths. The validation in the target code is about integer overflow and character escaping, not path resolution.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      }
    ]
  },
  "CVE-2022-21711_before_subset_100:c0a26d72:vulspec": {
    "timestamp": "2026-01-17T02:49:39.936447",
    "cve_id": "CVE-2022-21711",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c0a26d72",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XML External Entity (XXE) vulnerability in libxml2, involving improper restriction of external entity references during XML parsing. The target code is an ELF file parser that reads binary structures with no XML processing, entity handling, or similar parsing logic. The vulnerability types (CWE-611 vs. potential memory/input validation issues) and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2013-2124 is a double-free vulnerability (CWE-415) in libguestfs related to error handling and memory cleanup. The target code also performs file I/O and memory mapping (mmap) but does not show explicit dynamic memory allocation (malloc/free) or complex cleanup paths that could lead to a double-free. The primary similarity is file processing, but the memory management patterns and flaw mechanisms are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-11470 is an uncontrolled resource consumption issue (CWE-400) in ImageMagick due to lack of validation between declared image dimensions and actual data. The target code parses ELF headers containing various size/count fields (e.g., e_phnum, e_shnum, sh_size, p_memsz) and uses them for memory offsets and loop bounds without explicit validation against the mapped file size. This creates a similar pattern of trusting untrusted binary data, which could lead to out-of-bounds reads or excessive resource use. However, the specific context (image vs. executable parsing) differs.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-12320 is a use-after-free/double-free (CWE-416) in radare2's basic block analysis due to improper cleanup of linked structures. The target code is also a binary analysis tool (ELF parser) and performs similar operations of walking through structures (section headers, program headers, dynamic entries). While the target code does not show obvious dynamic allocation/free of complex linked structures, the pattern of parsing untrusted binary data and following pointers/offsets is similar. The specific memory corruption flaw type is less directly applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2017-13033 is an out-of-bounds read (CWE-125) in tcpdump's VTP parser due to insufficient validation of length fields before memory access. The target code extensively reads fields from the ELF header (e.g., e_shoff, e_phoff, e_shnum, e_phnum) and uses them to calculate pointers (e.g., `&elf_map[ehdr->e_shoff]`) and loop bounds without explicit validation against the mapped file size. This is a very similar pattern: parsing a binary format with untrusted integers used as offsets/counts, leading to potential OOB reads. The context (network packet vs. file) differs, but the core vulnerability pattern is highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection (CWE-93) in CUPS during PPD file generation from IPP attributes. The target code reads binary data and prints information but does not generate configuration files, process textual attributes from network protocols, or involve command injection vectors. The vulnerability types and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow (CWE-122) in glibc's glob() due to an off-by-one allocation error during path expansion. The target code uses fixed-size stack buffers (e.g., `flag[4]`, `value[50]`) and performs string operations (strcpy, snprintf) which could be problematic, but the primary activity is parsing binary structures, not pathname expansion or complex dynamic string allocation. The flaw pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-9499 is a reachable assertion (CWE-617) in ImageMagick due to insufficient validation of a numeric input field (`number_meta_channels`). The target code reads many numeric fields from the ELF header (e.g., e_machine, e_type, e_version, e_phnum) and uses them in switch statements and as array indices without thorough validation. While the target code may not have assertions, the pattern of trusting untrusted numeric values from a file header without bounds checking is similar and could lead to out-of-bounds access or other logical errors.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13715 is an uninitialized memory exposure (CWE-665) in the Linux kernel flow dissector due to improper state cleanup on error paths. The target code has simple error returns but does not show complex state management or cleanup of uninitialized structures. The code pattern and vulnerability type are not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-8670 is a buffer handling vulnerability (CWE-119) in PHP's GD integration due to incorrect bounds checking involving arithmetic. The target code performs pointer arithmetic using offsets from the ELF header (e.g., `elf_map + shstrtab.sh_offset + shdr[i].sh_name`) and uses `strcpy`/`snprintf` on fixed-size buffers. There is potential for similar issues if offsets are maliciously crafted, leading to out-of-bounds reads/writes. However, the specific arithmetic underflow flaw is not directly mirrored, and the context (image data vs. ELF metadata) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2022-21711_after_subset_100:0bc5d420:vulspec": {
    "timestamp": "2026-01-17T02:50:49.075888",
    "cve_id": "CVE-2022-21711",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0bc5d420",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is an ELF file parser, while CVE-2013-0339 is an XML external entity (XXE) vulnerability in libxml2. The domains (binary parsing vs. XML parsing), vulnerability types (CWE-611 vs. potential memory/parsing issues in ELF), and code patterns are completely different. There is almost no reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2013-2124 is a double-free vulnerability in libguestfs triggered by file processing. The target code also processes external files (ELF) and involves dynamic memory (via mmap). While the core vulnerability type (double-free/use-after-free) is not immediately evident in the target code, both handle untrusted file input and have complex parsing logic where memory management errors could occur. This provides weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "CVE-2019-11470 is an uncontrolled resource consumption issue in an image parser due to lack of validation between declared dimensions and actual data. The target code is also a file format parser (ELF) that reads numerous fields from the file header (e_phnum, e_shnum, shdr[i].sh_size, etc.) and uses them for calculations and loop bounds. If these fields are not validated against the actual mapped file size, similar resource exhaustion or out-of-bounds read issues could occur. The pattern of trusting file-supplied integers is similar, providing moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 6,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool (radare2) related to linked structure cleanup. The target code is also a binary analysis tool (ELF parser). While the specific vulnerability pattern (circular linked list) is not present, both tools parse complex, untrusted binary structures and manage internal state. Errors in parsing ELF structures could lead to similar memory corruption issues. This provides moderate relevance due to the shared domain.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 8,
        "reasoning": "CVE-2017-13033 is an out-of-bounds read in a network protocol dissector (tcpdump) due to insufficient validation of length fields. The target code is a binary file format dissector. It directly reads fields like `e_shoff`, `e_phoff`, `shdr[i].sh_offset`, `shdr[i].sh_name` and uses them as pointers/offsets into the `elf_map` buffer (e.g., `name = elf_map + shstrtab.sh_offset + shdr[i].sh_name`). Although there is a `validated_offset` check for the final `name` pointer, many other offsets are used without similar validation (e.g., for `shdr`, `phdr`, `dyn`). This pattern is highly similar to protocol dissection vulnerabilities. Strong relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-15400 is a CRLF injection/command injection vulnerability in a printing system's PPD file generator. The target code is a read-only ELF parser that prints information but does not generate executable scripts or configuration files. The vulnerability types and code patterns are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-15670 is a heap buffer overflow in glibc's glob() due to an off-by-one allocation error. The target code uses mmap for the primary buffer and has fixed-size stack buffers (e.g., `flag[4]`, `value[50]`). While there is a `strcpy` into `name` buffer that could be problematic if the source isn't null-terminated, the overall memory model and vulnerability pattern (off-by-one in heap allocation) are not similar. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 7,
        "reasoning": "CVE-2017-9499 is a reachable assertion in an image parser due to lack of validation on a numeric input field (`number_meta_channels`). The target code reads many numeric fields from the ELF header (e_phnum, e_shnum, e_shstrndx) and uses them for array indexing and loop iterations. For example, `shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];` and `for (int i = 0; i < ehdr->e_shnum; i++)`. If `e_shoff` is invalid or `e_shnum` is huge, it could lead to crashes or excessive resource use. The pattern of trusting unchecked file-supplied integers for critical operations is similar, providing moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2017-13715 is an improper initialization issue in the Linux kernel's network flow dissector, leading to information disclosure. The target code initializes its local variables but deals with parsing a complex structure from an untrusted source. A closer parallel might be if the parser leaves parts of its internal state inconsistent after encountering an error, but this is not a prominent feature of the shown code. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 6,
        "reasoning": "CVE-2016-8670 is a buffer bounds issue in PHP's GD image processing due to incorrect arithmetic checks. The target code performs arithmetic when calculating pointers (e.g., `elf_map + shstrtab.sh_offset + shdr[i].sh_name`) and validates some results with `validated_offset`. The core risk of integer overflows/underflows when calculating offsets within the mapped file is similar. However, the GD vulnerability is more about a specific flawed check (`remain == 0`), while the ELF parser's risk is more general. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2022-36040_after_subset_100:42200afc:vulspec": {
    "timestamp": "2026-01-17T02:51:02.757945",
    "cve_id": "CVE-2022-36040",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "42200afc",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 is a double-free vulnerability in libguestfs related to inconsistent state management during error handling. The target code has multiple error paths that free memory, but there is no clear evidence of double-free or ownership confusion in the shown logic. The primary similarity is the presence of error handling with memory cleanup.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 2 involves uncontrolled resource consumption (CWE-400) due to lack of validation between claimed dimensions and actual data in ImageMagick. The target code reads two size values (n1, n2) from a buffer and allocates memory based on them. While it performs overflow checks (UT32_ADD_OVFCHK), it does not validate if the buffer contains enough data for the subsequent `rz_buf_read` operations, which is conceptually similar to the dimension-data mismatch flaw. However, the target code checks the read result, mitigating the risk.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 3 is a buffer overflow (CWE-119) due to incorrect bounds checking involving arithmetic underflow in PHP's GD library. The target code performs bounds checking via `UT32_ADD_OVFCHK` to prevent overflow when calculating allocation size (n+1). It also checks the result of `rz_buf_read`. The similarity lies in the general pattern of reading a size and then operating on a buffer, but the specific underflow flaw and context are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a use-after-free/double-free (CWE-416) in radare2's basic block analysis due to improper linked list cleanup. The target code is a simple parser function with linear allocation and deallocation. There are no complex data structures or pointer aliasing that would lead to a similar use-after-free scenario.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is a CRLF injection/command injection (CWE-93) in CUPS during PPD file generation. The target code reads binary data and constructs a string for internal representation. There is no injection context, command execution, or output to an external format that interprets control characters.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 6 is an XXE (CWE-611) vulnerability in libxml2. The target code parses a binary Python object format, not XML. There is no entity resolution or markup language parsing involved.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a heap buffer overflow (CWE-122) due to an off-by-one allocation error in glibc's glob. The target code calculates allocation size as `n+1` for a null-terminator, which is a classic source of off-by-one errors. However, the target uses `UT32_ADD_OVFCHK` to guard against overflow in this calculation, and the flaw context (path expansion vs. binary parsing) is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is a reachable assertion (CWE-617) in ImageMagick due to insufficient validation of an input numeric field. The target code reads integer values (n1, n2) from an untrusted buffer. While it checks for overflow on `n+1`, it does not validate `n1` or `n2` themselves against any reasonable maximum size before allocation, which could lead to excessive memory consumption or a failed assertion elsewhere. The pattern of reading untrusted integers that influence resource allocation is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is excessive iteration (CWE-834) leading to DoS in FFmpeg. The target code does not contain loops that iterate based on untrusted data. The relevance is limited to the broader category of parsing untrusted file formats without sufficient validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-14054"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is a memory leak (CWE-401) in ImageMagick's MAT parser during error handling. The target code has multiple error return paths. A careful review shows a potential memory leak: if the second `malloc` for `s2` fails, the function returns `NULL` without freeing the previously allocated `s1` and `ret`. This is a direct similarity. However, the leak is in an error path, not during complex parsing state.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      }
    ]
  },
  "CVE-2022-36040_before_subset_100:8b77877c:vulspec": {
    "timestamp": "2026-01-17T02:51:03.127051",
    "cve_id": "CVE-2022-36040",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8b77877c",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve memory management and error handling, but the core flaw differs. Case 1 is a double-free due to ownership confusion in a linked structure cleanup. The target code frees memory on error paths but does not show evidence of double ownership or linked list traversal that could cause a double-free. The similarity is limited to general error cleanup patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve parsing file formats and allocating memory based on size values read from an input buffer (n1, n2 in target code; image dimensions in CVE-2019-11470). The target code validates the read size (`size != n1`), which mitigates the unbounded allocation flaw. However, the pattern of reading a size and then allocating is conceptually similar, making it a relevant reference for input validation.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve buffer operations and size validation. The target code correctly checks that `size == n1` after reading, which addresses the bounds checking issue central to CVE-2016-8670. The connection is the general concept of validating input sizes against actual data read, but the specific arithmetic underflow flaw is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are within the radare2 ecosystem (target code is from Rizin, a fork of radare2). However, the vulnerability types are different. Case 4 is a use-after-free/double-free in a linked structure (`anal_bb`). The target code manages simple, flat buffers (`s1`, `s2`) and frees them cleanly before returning. The only similarity is the use of `RZ_FREE` macros.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is an injection vulnerability (CRLF) in a printing protocol. The target code reads binary/string data and constructs a formatted string (`rz_str_newf`), but there is no indication of injecting that string into a command or protocol stream. The relevance is minimal beyond the superficial use of string formatting.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 6 is an XXE vulnerability in an XML parser. The target code parses a Python bytecode format, not XML, and does not involve entity resolution or external resource fetching. No meaningful similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve careful calculation of buffer sizes and null-termination. The target code allocates `n1 + 1` and sets `s1[n1] = '\\0'`, correctly accounting for the terminator, which is the type of off-by-one error that caused CVE-2017-15670. The relevance is in the pattern of size management for strings, though the target code implements it correctly.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both involve parsing a file format and reading numeric fields (`n1`, `n2` in target; `number_meta_channels` in CVE-2017-9499) that influence subsequent operations. The target code uses these values for memory allocation and buffer reads, similar to how the invalid channel count could lead to an assertion. The key difference is the target code validates the subsequent read operation, adding a layer of safety.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an infinite/ excessive loop due to missing EOF check. The target code uses bounded reads with explicit size checks (`rz_buf_read`), not a loop that processes until a condition is met. The only tangential similarity is processing data from a buffer, but the flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-14054"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. High similarity in vulnerability type and code patterns. Both involve parsing a complex file format (Python bytecode vs. MATLAB MAT) and have multiple error paths where allocated resources (`s1`, `s2`, `ret`) must be freed. The target code carefully frees `s1` and `s2` if the second `malloc` fails or the second `rz_buf_read` fails, preventing memory leaks. This mirrors the memory leak concerns in CVE-2017-12667, making it an excellent reference for validating the correctness of the target's cleanup logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      }
    ]
  },
  "CVE-2020-27209_before_subset_100:45ce44af:vulspec": {
    "timestamp": "2026-01-17T02:51:16.406503",
    "cve_id": "CVE-2020-27209",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "45ce44af",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a cryptographic signing function (ECDSA) with a focus on side-channel resistance. Case 1 (CVE-2013-2124) is a double-free vulnerability in a virtual machine disk image inspection library. The domains (cryptography vs. VM file processing), vulnerability types (logic/arithmetic errors vs. memory management), and code patterns are completely different. There is no meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2020-27209_after_subset_100:32e832ad:vulspec": {
    "timestamp": "2026-01-17T02:51:28.563796",
    "cve_id": "CVE-2020-27209",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "32e832ad",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is an ECDSA signing function with careful side-channel countermeasures. Case 1 (CVE-2013-2124) is a double-free vulnerability in a virtual disk image inspection library. The domains (cryptography vs. VM management), vulnerability types (logic/arithmetic errors vs. memory management), and code patterns are completely different. There is no meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 2 (CVE-2013-0339) is an XXE vulnerability in an XML parser. The target code performs cryptographic calculations with no XML parsing, external entity handling, or similar input processing. The functional domains and flaw mechanisms are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 3 (CVE-2018-12320) is a use-after-free/double-free in a reverse engineering tool's data structure cleanup. The target code performs arithmetic operations on fixed-size arrays and big integers, with no dynamic memory allocation or pointer-based data structures like linked lists. The vulnerability patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 4 (CVE-2019-11470) is an uncontrolled resource consumption (CWE-400) issue in an image decoder due to lack of validation between declared dimensions and data size. The target code validates its inputs (e.g., checking k is in range, checking point is not zero) and performs fixed-size arithmetic. While both involve input validation, the context (cryptographic parameters vs. image dimensions) and consequence (logic error vs. DoS) are too dissimilar for strong relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 5 (CVE-2017-8068) is a stack buffer overflow in a USB driver due to improper DMA buffer handling. The target code uses stack arrays (like `tmp`, `s`) but performs no unbounded copies or USB/DMA operations. The code patterns and attack surfaces are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 6 (CVE-2017-15400) is a CRLF injection/command injection in a printing protocol handler. The target code processes binary cryptographic data, not text-based protocols or command generation. There is no similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 7 (CVE-2017-15670) is a heap buffer overflow due to an off-by-one error in a path expansion function. The target code uses fixed-size arrays and big integer arithmetic with no string processing or dynamic heap allocation. The flaw mechanisms are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 8 (CVE-2016-5418) is a path validation/symlink race condition in an archive extraction library. The target code has no filesystem operations, path handling, or symlink logic. The domains and vulnerability classes are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 9 (CVE-2016-7425) is a buffer overflow in a kernel SCSI driver due to missing bounds checks on length parameters. The target code performs modular arithmetic on fixed-size numeric arrays with no user-controlled length fields or buffer copy operations. The code patterns and attack vectors are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Case 10 (CVE-2017-13033) is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code processes fixed-size hash inputs and cryptographic parameters with validation (e.g., `uECC_vli_isZero`, `uECC_vli_cmp`), but does not parse variable-length TLV structures or network packets. The similarity is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2022-2652_before_subset_100:886a8c04:vulspec": {
    "timestamp": "2026-01-17T02:52:39.979348",
    "cve_id": "CVE-2022-2652",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "886a8c04",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a buffer overflow in a network driver due to incorrect feature negotiation and packet processing. The target code is a V4L2 ioctl handler performing string copying and capability reporting. Both are kernel drivers, but the vulnerability type (CWE-119 buffer overflow vs. potential string handling issues), attack surface (network packets vs. local ioctl), and functional domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a double-free in a userspace library (libguestfs) related to file content processing and error handling. The target code is a kernel function with no dynamic memory allocation or deallocation. The vulnerability patterns and code contexts are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in a reverse engineering tool (radare2) related to linked list cleanup. The target kernel code performs no similar dynamic memory management of complex linked structures. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a stack buffer overflow in a USB network driver related to DMA and control messages. The target code is a V4L2 query function. Both are kernel drivers, but the vulnerability mechanism (DMA buffer mishandling vs. string formatting) and subsystem (USB networking vs. video) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a race condition leading to use-after-free in the kernel TTY subsystem. The target code is a V4L2 ioctl handler. Both are kernel ioctl handlers, which is a similarity. However, the target function appears to operate on device-local data without obvious shared state or concurrency issues like the TTY ldisc pointer. The vulnerability patterns (race/UAF vs. potential buffer mishandling) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a buffer copy without size checking in QEMU's virtio-serial emulation. The target is a kernel V4L2 driver. Both involve virtual device interfaces, but one is in a hypervisor and the other in the kernel. The flaw pattern (missing bounds check on guest-controlled data) is not directly mirrored in the target's use of `strlcpy` and `snprintf` with calculated lengths.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is a buffer overflow in a SCSI driver due to insufficient validation of user-controlled length parameters. The target code validates lengths for string operations (`labellen` calculation) but does not process similar untrusted, variable-length data blocks from userspace. The attack surface (SCSI commands vs. V4L2 query) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an infinite loop in the kernel datagram receive path due to improper input validation. The target code has simple, bounded operations with no loops. The vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0290"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an uninitialized memory issue in the network flow dissector. The target code initializes all fields of the `cap` structure (via `memset` on reserved fields and direct assignment) and does not exhibit similar error path state management problems.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. Case 10 is an off-by-one error in a kernel MTD driver's array bounds checking. The target code contains a bounds-conscious calculation (`labellen`) to prevent overflow when copying strings. This shows a similar defensive coding concern for buffer limits. However, the specific flaw (array index error vs. string copy) and subsystem are different. The relevance is higher than other cases due to the shared theme of careful length calculation in kernel drivers.",
        "case_metadata": {
          "cve_id": "CVE-2016-10764"
        }
      }
    ]
  },
  "CVE-2020-15204_before_subset_100:802687a5:vulspec": {
    "timestamp": "2026-01-17T02:52:48.729848",
    "cve_id": "CVE-2020-15204",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "802687a5",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file processing library (libguestfs). The target code is a TensorFlow kernel performing tensor storage and handle allocation with no dynamic memory deallocation or complex error paths that could lead to double-free. The domains and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in a printing system (CUPS) due to improper neutralization of IPP attribute values. The target code deals with internal tensor resource management, allocating outputs and creating resource handles or string handles. There is no parsing of external protocol data or string injection vector.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is a buffer overflow in an image processing library (PHP GD) due to incorrect bounds checking and arithmetic underflow. The target code performs simple tensor allocation and assignment. While both involve memory operations, the target code uses safe allocation primitives (ctx->allocate_output) and does not perform manual buffer size calculations or direct memory writes that could overflow.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a reachable assertion vulnerability in ImageMagick due to insufficient validation of numeric input (number_meta_channels). The target code validates operations via OP_REQUIRES_OK but does not parse numeric inputs from untrusted sources or have assertions that could be triggered by malicious data. The validation context is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a use-after-free/double-free in a reverse engineering framework (radare2) due to improper cleanup of linked structures. The target code allocates and stores tensors but does not demonstrate any deallocation logic, pointer manipulation, or complex data structure cleanup that could lead to use-after-free.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 6 is a resource exhaustion vulnerability in ImageMagick due to lack of validation between declared image dimensions and actual data. The target code allocates a single output tensor of fixed shape (Scalar), not based on untrusted size inputs. While both involve resource allocation, the trigger (unvalidated dimensions leading to huge allocation) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an uninitialized memory exposure in the Linux kernel network stack due to improper initialization during error paths. The target code initializes its output handle (either ResourceHandle or tstring) explicitly. There is no complex error path that skips initialization of sensitive data.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an integer overflow leading to an infinite loop in a filesystem driver. The target code performs simple arithmetic (GetNewId) but no complex size calculations, loop conditions, or block mappings that could overflow or cause denial of service.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 9 is an information leak via uninitialized memory copy to userspace in a kernel driver. The target code may expose a handle (string or ResourceHandle) to userspace, but it is explicitly initialized. There is no copying of partially initialized structures. The exposure vector is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-20855"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a buffer overflow in QEMU virtio due to lack of bounds checking on scatter-gather lists. The target code does not process descriptor chains, perform buffer copies from untrusted inputs, or have ANY_LAYOUT feature semantics. The memory safety patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      }
    ]
  },
  "CVE-2022-2652_after_subset_100:0170c8b9:vulspec": {
    "timestamp": "2026-01-17T02:52:48.891368",
    "cve_id": "CVE-2022-2652",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0170c8b9",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a buffer overflow in a network driver due to incorrect feature negotiation and packet fragment handling. The target code is a V4L2 ioctl handler performing string copying and capability reporting. Both are in the kernel but the vulnerability type (buffer overflow vs. potential info leak/overflow), trigger conditions (network packets vs. user ioctl), and code patterns (packet processing vs. string formatting) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a double-free in a userspace library (libguestfs) related to file content processing and error handling. The target code is a kernel driver function with no dynamic memory allocation or deallocation. The vulnerability class (memory corruption vs. potential buffer overrun) and context (userspace vs. kernel) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a stack buffer overflow in a USB network driver due to improper DMA buffer handling. The target code uses `strlcpy` and `snprintf` which are generally safer, and operates in a different subsystem (video4linux vs. USB networking). While both are kernel drivers, the specific vulnerability mechanism and attack surface (USB control messages vs. V4L2 ioctl) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a race condition leading to use-after-free in the TTY subsystem. The target function `vidioc_querycap` has no concurrency control shown (though it may need it) and performs no pointer dereferencing that could lead to a UAF. The vulnerability pattern (timing attack on ldisc pointer) is not present in the straightforward, side-effect-free query operation.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a buffer overflow in QEMU's virtio-serial due to missing bounds checks on scatter-gather lists. The target code uses bounded string functions (`strlcpy`, `snprintf`). Both involve virtual device interfaces, but the vulnerability root cause (untrusted guest descriptor chains vs. copying fixed driver strings) and environment (hypervisor vs. kernel driver) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a buffer overflow in a SCSI driver due to insufficient validation of a user-controlled length parameter. The target code uses `snprintf` with a calculated limit (`labellen`), which could potentially be miscalculated or lead to truncation. Both are kernel drivers handling ioctl-like commands. However, the target code's buffer sizes are derived from `sizeof` on fixed arrays, not user input, making an overflow less likely. The similarity is in the pattern of copying data into a fixed-size kernel buffer.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an infinite loop in the networking datagram receive path due to improper handling of zero-length packets. The target code has no loops and is a simple query function. The vulnerability class (logic error/DoS vs. memory corruption) and code structure are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0290"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an uninitialized memory exposure in the network flow dissector. The target code explicitly initializes fields (e.g., `memset(cap->reserved, 0, ...)`) and does not parse complex, untrusted packet data. The contexts (network packet parsing vs. device capability reporting) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is an off-by-one buffer overflow in a kernel flash driver due to incorrect array bounds checking. The target code calculates `labellen` as the minimum of two `sizeof` operations. While this is likely safe, miscalculations of buffer sizes are a common source of off-by-one and buffer overflow errors in kernel code. The pattern of calculating a copy limit based on multiple buffer sizes is conceptually similar to the flaw in Case 10, even though the specific trigger (device tree property) is different. This provides some reference value for auditing bounds calculations.",
        "case_metadata": {
          "cve_id": "CVE-2016-10764"
        }
      }
    ]
  },
  "CVE-2020-15204_after_subset_100:e81fde20:vulspec": {
    "timestamp": "2026-01-17T02:53:11.271208",
    "cve_id": "CVE-2020-15204",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e81fde20",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a file processing library due to memory ownership violations. The target code is a TensorFlow kernel performing session handle management and resource allocation. There is no dynamic memory deallocation, pointer manipulation, or similar error handling paths that could lead to a double-free. The domains and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves CRLF injection (CWE-93) leading to command injection in a printing system's PPD file generation. The target code performs tensor handle creation and output allocation in a machine learning framework. There is no string parsing, command generation, or neutralization of external inputs. The attack surfaces and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 involves a buffer overflow (CWE-119) in an image processing library due to incorrect bounds checking and arithmetic underflow. The target code manages session state and allocates output tensors. While both involve resource management, the target code uses framework-provided allocation functions (ctx->allocate_output) which abstract away low-level buffer handling. There is no direct manipulation of buffer sizes or indices that could lead to similar arithmetic flaws.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves a reachable assertion (CWE-617) due to insufficient validation of numeric input in an image library. The target code also involves numeric input (id from GetNewId()) and output allocation. A weak similarity exists in the need to validate or handle numeric values safely. However, the target code's numeric operations are simple assignments and there is no complex parsing or validation logic shown that could lead to a similar assertion failure or integer overflow.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves a use-after-free (CWE-416) in a reverse engineering tool due to improper cleanup of linked data structures. The target code is creating and storing tensor handles, not deallocating complex linked structures. The code pattern is about resource acquisition and registration, not destruction. The memory management models are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 involves uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code allocates an output tensor based on a fixed shape (TensorShape({})). There is a tangential similarity in allocating resources based on some input, but the target code's allocation is for a single scalar handle, not a large buffer based on unvalidated user-controlled dimensions. The risk profile is much lower.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 involves improper initialization (CWE-665) leading to information disclosure in a network packet parser. The target code initializes a Tensor or ResourceHandle object. There is a conceptual similarity in ensuring objects are fully initialized before use. However, the target code's initialization paths (two branches for DT_RESOURCE and legacy) appear straightforward without complex error state transitions that could leave fields uninitialized. The context and severity are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves an integer overflow (CWE-190) in a filesystem block calculation leading to an infinite loop. The target code uses a 64-bit ID (int64 id). While integer overflows are a general concern, the operation shown (GetNewId()) is an accessor, and its result is used as an identifier, not in loop conditions or size calculations. There is no visible arithmetic that could wrap around. The similarity is only in the presence of integer types.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 involves information exposure (CWE-200) via uninitialized memory disclosure in a kernel driver. The target code has two initialization paths for the output `handle`. It must ensure all fields of the `ResourceHandle` or the `tstring` are properly set. If the `setConstant` method or `MakeResourceHandle` function fails to initialize all memory, similar information disclosure could occur. This is the most relevant case so far, as both deal with initializing structured data for output.",
        "case_metadata": {
          "cve_id": "CVE-2018-20855"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 involves a buffer overflow without size checking (CWE-120) in a virtual device emulator handling scatter-gather lists. The target code does not copy buffer data; it copies a handle (string or ResourceHandle object) into an allocated output tensor. The size of the destination is fixed (a scalar). There is no copying of variable-length, untrusted data into fixed-size buffers. The code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      }
    ]
  },
  "CVE-2019-14494_before_subset_100:16f6706a:vulspec": {
    "timestamp": "2026-01-17T02:53:37.814057",
    "cve_id": "CVE-2019-14494",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "16f6706a",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve image/pattern processing and have potential for resource exhaustion (CWE-400). The target code performs size calculations (surface_width, surface_height) and has a check `(unsigned long) surface_width * surface_height > 0x800000L` to limit allocation, similar to CVE-2019-11470's dimension validation flaw. However, the vulnerability type is not identical (one is a parser, the other is a rendering function).",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection (CWE-93) in a printing system's PPD file generation. The target code is a graphics rendering function in a PDF library with no text parsing, protocol handling, or command generation. The attack surfaces and flaw types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free (CWE-415) in a file reading utility within a VM inspection library. The target code performs complex graphics state manipulation and bitmap creation/deletion. While both involve memory management, the target code's pattern of saving/restoring state pointers (`formerSplash`, `formerBitmap`) and careful cleanup (deleting `tBitmap`, `gfx`) shows a different structure. No clear double-free or ownership confusion pattern is evident in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-8670 is a buffer overflow (CWE-119) due to incorrect bounds checking in an image data transfer function. The target code performs numerous arithmetic operations (ceil, fabs, multiplication) on user-influenced values like `width`, `height`, `xStep`, `yStep`, `x1-x0`, `y1-y0`, and matrix elements to calculate dimensions for bitmap allocation (`surface_width`, `surface_height`). There is a risk of integer overflow in these calculations before the `0x800000L` check, which is a similar underlying cause (CWE-1284). However, the specific flaw (underflow leading to negative `remain`) and context (data copying vs. size calculation) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free (CWE-416) in a linked list cleanup function within a reverse engineering tool. The target code manages bitmap and graphics object lifecycles (`splash`, `bitmap`, `gfx`) with clear ownership transfers (e.g., `bitmap = formerBitmap`). It shows careful restoration of original state. The code patterns and data structures (bitmaps vs. analysis basic blocks) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2015-8877 is a memory leak (CWE-399) in an image scaling function. The target code has a complex execution flow with multiple early returns and resource allocations (`new SplashBitmap`, `new Splash`, `new Gfx`). While it appears to clean up allocated resources (`delete splash`, `delete tBitmap`, `delete gfx`) in the main success path, error paths (multiple `return false` statements) must be examined for potential leaks of `bitmap` or `splash` if allocated just before the failure. This mirrors the resource management error theme, though the specific leak pattern is not confirmed in the snippet.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-7101 is an out-of-bounds read (CWE-125) due to lack of validation of image dimensions before memory operations. The target code validates the CTM matrix values for finiteness and checks the product `surface_width * surface_height` against a limit. However, the calculations for `result_width`, `result_height`, `surface_width`, `surface_height` involve many user-controlled inputs (bbox, mat, ptm, x1-x0, etc.) and complex arithmetic. Insufficient validation or integer overflows in these steps could lead to incorrectly sized allocations or out-of-bounds accesses later (e.g., in `blitImage` or `drawImage`). The pattern of calculating sizes from untrusted data is similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability (CWE-611) in an XML parser. The target code is a graphics rendering function for PDF tiling patterns. There is no XML parsing, external entity resolution, or similar functionality. The domains are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-9499 is a reachable assertion (CWE-617) due to insufficient validation of a numeric input field (`number_meta_channels`). The target code performs several validations (e.g., `isfinite(ctm[i])`, size limit check). However, it lacks validation on other calculated integers like `repeatX`, `repeatY`, and the operands in expressions like `result_width / surface_width`. An assertion failure is less likely, but integer division by zero or other arithmetic errors are possible if validations are incomplete. The theme of validating calculated numeric values is shared, but the manifestation differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-12667 is a memory leak (CWE-401) in an image parser during error handling. As with Case 6, the target code has multiple early return points. A key concern is whether all allocated resources (`bitmap`, `splash`, `gfx`) are properly freed on every error path before returning `false`. The code shows cleanup for the `bitmap` allocation failure case, but other early returns (e.g., when `surface_width == 0`) might leak the `formerBitmap` if `bitmap` was already reassigned? The pattern of complex error handling and resource cleanup is similar and warrants careful review.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      }
    ]
  },
  "CVE-2022-1533_before_subset_100:9f564151:vulspec": {
    "timestamp": "2026-01-17T02:54:19.108340",
    "cve_id": "CVE-2022-1533",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9f564151",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine inspection library related to memory ownership and error handling. The target code performs in-place buffer manipulation with insert/delete operations and has bounds checks, but does not involve dynamic memory allocation/deallocation or double-free patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free vulnerability (CWE-416) in a reverse engineering framework involving linked structure cleanup. The target code operates on a fixed buffer with pointer arithmetic and memmove operations, but does not involve dynamic memory management, pointer invalidation, or complex data structure cleanup.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves uncontrolled resource consumption (CWE-400) through unvalidated image dimensions leading to excessive memory allocation. The target code has buffer size checks against INDX_INFLBUF_SIZEMAX, which shows some similarity in resource validation, but the core vulnerability patterns differ significantly (allocation vs. in-place manipulation).",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in an XML parser involving external entity processing. The target code processes a rule-based encoding/decoding scheme with no XML parsing, entity resolution, or network resource access patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves CRLF injection (CWE-93) leading to command injection in a printing system. The target code performs binary buffer manipulation with no string processing, command execution, or protocol handling that could enable injection attacks.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 is a heap buffer overflow (CWE-122) due to off-by-one error in memory allocation. The target code has multiple bounds checks (pos validation, buffer size checks) and uses memmove operations that could potentially lead to buffer overflows if bounds checks are insufficient. Both involve careful boundary management during buffer operations.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 involves improper input validation (CWE-20) leading to path traversal and filesystem issues in an archive library. The target code performs in-memory buffer manipulation with no filesystem operations, path handling, or symlink processing.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 8 involves improper bounds restriction (CWE-119) with potential for out-of-bounds read/write due to incorrect bounds checking. The target code has similar patterns: bounds checking (pos validation, buffer size against INDX_INFLBUF_SIZEMAX), pointer arithmetic, and memmove operations that could lead to buffer overflows if checks are flawed. Both involve careful validation of buffer boundaries during data movement.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 involves integer overflow (CWE-190) leading to buffer overflow in a protocol library. The target code uses integer variables for position and size calculations with bounds checking, but doesn't show obvious integer overflow patterns like large value additions. However, both involve size calculations and buffer operations that require careful integer handling.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 10 is a buffer overflow (CWE-119) due to insufficient validation of user-controlled parameters in a kernel driver. The target code similarly processes external input (rule buffer), performs bounds checking, and uses memmove operations. Both involve validating user-controlled indices/positions against buffer boundaries to prevent corruption.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2019-14494_after_subset_100:985547f7:vulspec": {
    "timestamp": "2026-01-17T02:54:22.224964",
    "cve_id": "CVE-2019-14494",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "985547f7",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve image/pattern processing with dimension calculations that could lead to resource exhaustion. The target code has checks for large allocations (e.g., `surface_width * surface_height > 0x800000L`) similar to CVE-2019-11470's dimension validation issue. However, the target code is for PDF tiling patterns, not Cineon images, and includes more defensive checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection in PPD file generation within a printing system. The target code is a PDF rendering function performing mathematical transformations and bitmap operations with no string processing or protocol handling. The domains and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free in a file reading utility. The target code manages memory (allocates/deletes bitmaps) but follows clear ownership patterns (e.g., deleting `tBitmap` at the end). There is no complex error path or file content parsing that could lead to double-free scenarios similar to libguestfs.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve graphics processing and potential integer handling issues. The target code uses `ceil`, `fabs`, and multiplication on dimensions (e.g., `result_width = (int) ceil(fabs(kx * width * (x1 - x0)))`), which could theoretically overflow, but it has size limits and checks. CVE-2016-8670 is a specific buffer underflow in GD's I/O, which is not directly mirrored here.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in a linked structure for binary analysis. The target code uses simple object allocation/deletion (`new SplashBitmap`, `delete tBitmap`) with no pointer sharing or complex data structures that could cause use-after-free. The memory management patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve image processing with potential resource management errors. The target code allocates bitmaps (`new SplashBitmap`) and must ensure cleanup on failure paths (it does delete bitmaps on allocation failure). CVE-2015-8877 is a memory leak in scaling, while this code could leak if early returns miss cleanup, but it appears to have proper deletion in most paths.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Strong similarity in validating image dimensions before allocation. The target code calculates `surface_width`/`surface_height` from user inputs (via matrices) and checks if `surface_width * surface_height > 0x800000L` to avoid excessive allocation, similar to CVE-2016-7101's lack of dimension validation. Both are in graphics libraries and deal with dimension-based resource consumption.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code processes PDF tiling patterns with mathematical transformations and bitmap rendering, with no XML/entity parsing involved. The vulnerability types and domains are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve validating numeric inputs in image processing. The target code validates `ctm` values with `std::isfinite` and checks for zero dimensions (e.g., `surface_width == 0`), similar to CVE-2017-9499's lack of validation on `number_meta_channels`. However, the target code does not have assertions that could be triggered; it returns false instead.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve potential memory leaks in image format processors. The target code allocates `SplashBitmap` and `Splash` objects and must ensure deletion on all paths (it has deletion in failure and success paths). CVE-2017-12667 is a leak in MAT-file error handling, while this code appears robust but could leak if exceptions occur between `new` and `delete`.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      }
    ]
  },
  "CVE-2022-23586_before_subset_100:4d9cb40b:vulspec": {
    "timestamp": "2026-01-17T02:54:41.125503",
    "cve_id": "CVE-2022-23586",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4d9cb40b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection in a printing system (CWE-93). The target code is a TensorFlow function for building graph nodes from op arguments, dealing with data types and node creation. No string parsing, command execution, or protocol handling is present.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability (CWE-415) in a file reading function within libguestfs. The target code performs graph construction and node addition with no dynamic memory deallocation, error-prone cleanup paths, or file content processing.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-9499 involves an assertion failure (CWE-617) due to insufficient validation of numeric input (number_meta_channels). The target code validates that `dtypes.size()` is at least 1, but a potential parallel exists in validating the `resource_arg_unique_id` or other integer attributes before use. However, the core flaw (reachable assertion) and context (image parsing) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability (CWE-611) in an XML parser. The target code processes internal function definition arguments and builds a computation graph. There is no parsing of external data formats, entity resolution, or configuration from untrusted sources.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-11470 is a resource exhaustion vulnerability (CWE-400) due to unvalidated image dimensions leading to huge memory allocation. The target code loops over `dtypes.size()` to create nodes. If an attacker could control `dtypes` (e.g., via a malicious function definition) to have an extremely large size, it could cause excessive node creation and memory consumption. However, the code itself does not show the allocation of pixel data buffers, which is the core of the ImageMagick flaw.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow (CWE-122) from an off-by-one error in string processing and memory allocation in glibc. The target code performs no string manipulation or manual buffer allocation that could lead to such an off-by-one error. Memory management is likely handled by standard containers.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-5418 involves improper input validation (CWE-20) of archive paths leading to filesystem issues. The target code processes internal data structures (ArgDef, AttrSlice) related to graph construction, not filesystem paths, archive entries, or symlink handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-8670 is a buffer overflow (CWE-119) due to incorrect bounds checking and integer underflow in an image library. The target code does not perform low-level buffer arithmetic or direct memory reads/writes. It uses higher-level abstractions for adding nodes and attributes.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-18609 is an integer overflow (CWE-190) leading to a buffer overflow in a network protocol library. The target code uses `size_t i` to loop over `dtypes.size()`. If `dtypes.size()` could be manipulated to be extremely large (close to `SIZE_MAX`), the loop increment `++i` or the index `arg_index++` could theoretically wrap around, leading to unexpected behavior. However, the code does not show the allocation of a buffer based on these counts, which is the critical step in the rabbitmq-c vulnerability. The relevance is higher than other cases due to the integer iteration pattern but remains speculative without a visible allocation site.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      }
    ]
  },
  "CVE-2022-1533_after_subset_100:a85794cf:vulspec": {
    "timestamp": "2026-01-17T02:54:42.391683",
    "cve_id": "CVE-2022-1533",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a85794cf",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine inspection library related to memory ownership and error handling. The target code performs in-buffer data manipulation (insert/delete) with bounds checking and does not involve dynamic memory allocation/deallocation or similar error handling paths.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a use-after-free/double-free vulnerability (CWE-416) in a reverse engineering framework related to linked structure cleanup. The target code operates on a fixed buffer (`decoded`) with static bounds (`INDX_INFLBUF_SIZEMAX`) and does not involve pointer-based data structures, dynamic memory, or deallocation.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is an uncontrolled resource consumption vulnerability (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code does perform bounds checking (`pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX`) to prevent buffer overflow, which is a form of input validation. However, the core vulnerability type (resource exhaustion vs. buffer overflow) and context (image parsing vs. data decoding) are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in an XML parser. The target code is a simple data decoding routine with no external entity resolution, network interaction, or complex parsing logic.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an CRLF injection/command injection vulnerability (CWE-93) in a printing system's PPD file generation. The target code performs binary data manipulation and does not involve string parsing, command generation, or neutralization of control sequences.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 is a heap-based buffer overflow (CWE-122) due to an off-by-one error in memory allocation. The target code contains explicit bounds checks to prevent buffer overflow (`d + l > decoded + INDX_INFLBUF_SIZEMAX`). While the context is different (pathname expansion vs. data decoding), both involve careful bounds calculation and validation to prevent writing beyond buffer limits. The target code's checks are more direct, but the underlying concern of preventing out-of-bounds writes is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves improper input validation (CWE-20) leading to path traversal and symlink issues in an archive library. The target code does perform input validation (bounds checks on `pos` and `l`), which is a similarity. However, the specific flaw (path validation) and attack surface (filesystem operations) are completely different from the target's in-memory buffer manipulation.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 8 is a buffer overflow (CWE-119) due to incorrect bounds checking, specifically a failure to account for arithmetic underflow leading to a negative value being treated incorrectly. The target code contains multiple bounds checks (`pos < 0 || l < 0 ...`) that explicitly guard against negative indices and lengths, which is a direct countermeasure to the type of flaw in Case 8. The code patterns (bounds checking before `memmove`) and the vulnerability type (buffer overflow prevention) are highly similar, though the specific trigger (underflow) is not obviously present in the target.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is an integer overflow (CWE-190) leading to a buffer overflow. The target code uses signed integers (`pos`, `l`, `decoded_size`) and checks for negative values, which could be a result of an integer overflow/wraparound if upstream calculations are flawed. The code does not perform arithmetic that could obviously overflow (like adding to `decoded_size` within the loop), but the use of signed integers and checks for negativity shows awareness of related issues. The relevance is in the domain of integer handling and buffer safety.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 10 is a buffer overflow (CWE-119) due to insufficient validation of user-controlled length parameters. The target code's core security mechanism is validating the `pos` and `l` parameters derived from `decoded_size` and the `rule` input before performing `memmove` operations. This is a direct parallel to validating length parameters before memory operations. The code pattern of checking `pos` and `l` against buffer bounds is conceptually identical to the missing check in Case 10. The main difference is the context (kernel SCSI driver vs. user-space data decoding).",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2022-23586_after_subset_100:3e754d6b:vulspec": {
    "timestamp": "2026-01-17T02:55:30.698653",
    "cve_id": "CVE-2022-23586",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3e754d6b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection in a printing system's PPD file generation. The target code is a TensorFlow function for building graph nodes from op definitions, dealing with data types and node creation. No input validation, string processing, or command execution patterns are similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to file content processing and error handling. The target code performs graph construction with sequential node addition and status returns. There is no dynamic memory allocation, pointer manipulation, or complex error cleanup that could lead to double-free issues.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in radare2's basic block analysis due to improper linked list cleanup. The target code manages a linear collection (`result_.nodes`) and adds items sequentially. There are no manual memory deallocations, pointer-based data structures, or scenarios where freed objects could be referenced.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-9499 involves an assertion failure due to insufficient validation of numeric input (number_meta_channels). The target code validates `dtypes.size()` is at least 1, but does not perform extensive bounds checking on other inputs like `resource_arg_unique_id`. However, the context (image processing vs. graph construction) and specific failure mode (assertion vs. internal error) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in libxml2 due to improper restriction of external entity references. The target code processes function argument definitions and data types; it does not parse XML, handle external resources, or have any entity expansion mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-11470 involves uncontrolled resource consumption due to lack of validation between declared image dimensions and actual data. The target code iterates over `dtypes.size()` to create nodes, but `dtypes` is derived from validated op attributes. A potential similarity is if `dtypes.size()` is excessively large, it could lead to excessive node creation, but this is mitigated by the earlier validation and the fact that types are from a finite set.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob due to an off-by-one allocation error. The target code does not perform low-level string manipulation, buffer allocation, or path expansion. It uses high-level C++ strings and containers, with no apparent arithmetic errors in size calculations.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-5418 involves improper input validation leading to path traversal and filesystem issues in libarchive. The target code deals with abstract graph node creation and type management, not filesystem paths, archive entries, or symlink/hardlink resolution.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-8670 is a buffer overflow due to incorrect bounds checking (arithmetic underflow). The target code uses loops with `size_t i` and `dtypes.size()`, which are safe. However, a subtle similarity exists in the potential for integer issues: `resource_arg_unique_id` is a signed int64 passed to `AddAttr`. If it's negative (allowed by check `>= -1`), it might cause unexpected behavior elsewhere, though not a direct buffer overflow. The validation logic is simpler.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-18609 is an integer overflow leading to buffer overflow in an AMQP library. The target code uses `size_t` for loop indices and `int64_t` for `resource_arg_unique_id`. There is a risk if `dtypes.size()` is extremely large (unlikely from `ArgNumType`), causing excessive memory consumption but not an integer overflow in buffer allocation. The code does not perform arithmetic on sizes that could wrap. The similarity is limited to the general need for careful integer handling.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      }
    ]
  },
  "CVE-2021-3739_before_subset_100:b025089a:vulspec": {
    "timestamp": "2026-01-17T02:56:16.008508",
    "cve_id": "CVE-2021-3739",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b025089a",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a user-space library (libguestfs) related to file content processing. The target code is a kernel-space Btrfs device removal function focusing on resource management, locking, and state transitions. The vulnerability type, context, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 involves a use-after-free/double-free (CWE-416) in a user-space analysis tool due to improper linked list cleanup. The target code manages kernel data structures (device lists) with RCU and mutexes. While both involve cleaning up data structures, the context (kernel vs. user-space), concurrency mechanisms, and specific flaw patterns (list manipulation errors vs. memory lifecycle errors) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 involves improper input validation (CWE-20) leading to path traversal issues in a user-space archive library. The target code is a kernel filesystem function that validates device states but primarily deals with internal resource management and synchronization, not parsing untrusted path inputs from userspace.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves CRLF injection (CWE-93) in a printing system's protocol parsing. The target code does not parse any textual protocol or user-controlled strings in a way that could lead to injection. The domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves a buffer overflow (CWE-119) in a kernel network driver due to incorrect feature negotiation and buffer sizing. The target code is also in the kernel but in the filesystem subsystem. The weak link is that both are kernel drivers managing resources, but the specific flaw (buffer calculation error vs. state and lock management), attack surface (network packets vs. admin ioctl), and code patterns are very different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves a buffer overflow (CWE-119) in a kernel SCSI driver due to missing bounds checks on user-controlled input. The target code also runs in kernel space and handles a removal ioctl, which is a user-controlled operation. The relevance is weak because the target code performs extensive state checks but does not have obvious buffer operations on attacker-controlled sizes. The core flaw pattern (missing bounds check) is not evident in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 involves a race condition (CWE-362) in a kernel filesystem (OCFS2) due to improper locking during metadata operations. The target code is also a kernel filesystem (Btrfs) function that uses multiple mutexes (uuid_mutex, chunk_mutex, device_list_mutex) and RCU to manage concurrent access to device metadata. The code patterns (lock acquisition/release, state checks under locks) and domain are similar. The relevance is moderate, not strong, because the specific race condition pattern in OCFS2 (direct I/O extent tree access) differs from the device removal sequence in Btrfs, but the synchronization challenges are analogous.",
        "case_metadata": {
          "cve_id": "CVE-2017-18224"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves XXE (CWE-611) in an XML parsing library. The target code does not parse any complex, structured input formats like XML. The functionality and vulnerability class are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 9 involves a vulnerability (CWE-200 - Information Exposure) in the Linux kernel Btrfs filesystem implementation. The target code is from the same subsystem (Btrfs) within the same codebase. Both deal with critical filesystem operations (device removal vs. file truncation/clone) that require careful metadata and state management. The code patterns (structure manipulation, error handling with goto, use of fs_info, device pointers) are nearly identical. The vulnerability types differ (info leak vs. potential state corruption/use-after-free in device removal), but the context and coding style provide extremely valuable reference for understanding Btrfs-specific bug patterns.",
        "case_metadata": {
          "cve_id": "CVE-2015-8374"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves improper initialization (CWE-665) in the kernel network stack leading to information leak. The target code is also in the kernel. The weak link is the potential for similar error handling pitfalls (e.g., leaving structures in an inconsistent state before jumping to error_undo). However, the target code appears careful about state restoration in its error path. The subsystems (networking vs. filesystem) and specific flaw patterns are quite different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2021-3739_after_subset_100:413110aa:vulspec": {
    "timestamp": "2026-01-17T02:56:20.027671",
    "cve_id": "CVE-2021-3739",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "413110aa",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in a user-space library (libguestfs) related to file content processing. The target code is a kernel-space Btrfs device removal function focused on filesystem metadata and device state management. The vulnerability types (double-free vs. state/race condition), domains, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 (CVE-2018-12320) is a use-after-free/double-free in a user-space analysis tool (radare2) due to improper linked list cleanup. The target code involves careful linked list manipulation (`list_del_rcu`, `list_del_init`) and resource cleanup in the kernel. While both involve cleanup of internal data structures, the context (kernel driver vs. analysis tool), attack surface, and specific flaw patterns (circular references vs. concurrency/state errors) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 (CVE-2016-5418) involves improper input validation leading to path traversal/symlink issues in a user-space library (libarchive). The target code performs device removal in a kernel filesystem. Both operate in the storage/filesystem domain and involve careful state updates. However, the vulnerability type (input validation vs. concurrency/state management), layer (user-space library vs. kernel driver), and specific flaw (path handling vs. metadata consistency) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 (CVE-2017-15400) is a CRLF injection/command injection in a printing system (CUPS) due to improper neutralization of protocol data. The target code is a kernel Btrfs function with no parsing of untrusted data strings, no command generation, and a focus on internal device and metadata management. The domains and vulnerability patterns are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 (CVE-2015-5156) is a buffer overflow in a Linux kernel virtio driver due to incorrect feature declaration and buffer size calculation. The target code is also a Linux kernel filesystem driver. Both are in the kernel, involve device/driver management, and require careful resource handling. However, the specific flaw type (buffer overflow vs. potential race/state inconsistency) and subsystem (network vs. filesystem) differ.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 (CVE-2016-7425) is a buffer overflow in a kernel SCSI driver due to lack of bounds checking on user-controlled input. The target code is a kernel Btrfs function. Both are kernel drivers. However, the target code does not appear to have a similar direct copy-from-user operation with an unchecked length. The vulnerability pattern (buffer overflow vs. logic/state error) and attack surface (SCSI command vs. filesystem ioctl) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 7 (CVE-2017-18224) is a race condition (CWE-362) in a kernel filesystem (OCFS2) due to improper locking during concurrent metadata operations. The target code is in the Btrfs kernel filesystem and involves complex device and metadata state updates under multiple locks (`uuid_mutex`, `chunk_mutex`, `device_list_mutex`). The pattern of managing shared filesystem structures, using multiple locks, and the potential for state inconsistency if locking is incorrect is highly similar. Both are in the same domain (kernel filesystems) and share concurrency challenges.",
        "case_metadata": {
          "cve_id": "CVE-2017-18224"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CVE-2013-0339) is an XXE vulnerability in a user-space XML parsing library (libxml2). The target code is a kernel filesystem function with no parsing of complex external data formats. The domains (document parsing vs. storage management) and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. Case 9 (CVE-2015-8374) is a vulnerability in the Linux kernel Btrfs filesystem implementation, specifically related to improper handling of metadata during file operations leading to information exposure. The target code is from the same system (Linux kernel Btrfs), the same subsystem (filesystem storage engine), and involves similar complexity in managing filesystem metadata, device state, and ensuring consistency after operations like removal. The pattern of updating multiple inter-dependent metadata structures (`super_copy`, device lists, counters) and the critical need for correct ordering and error rollback is almost identical. This provides extremely valuable reference for understanding the vulnerability landscape of the target code.",
        "case_metadata": {
          "cve_id": "CVE-2015-8374"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 (CVE-2017-13715) is an uninitialized memory issue in the kernel network stack's flow dissector. The target code is in the kernel filesystem subsystem. Both are in the Linux kernel, requiring careful initialization and cleanup. However, the subsystems are vastly different (networking vs. filesystem), and the flaw pattern (uninitialized stack variable on error path vs. logic/state management) is not closely aligned.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-1452_before_subset_100:b099a3ef:vulspec": {
    "timestamp": "2026-01-17T02:56:33.714225",
    "cve_id": "CVE-2022-1452",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b099a3ef",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 is a double-free vulnerability (CWE-415) in libguestfs related to memory ownership and error handling. The target code is a Java class file parser in radare2 that allocates and appends structures to a list. While both involve dynamic memory management, the core flaw patterns differ significantly. The target code shows no evidence of double-free or complex ownership transfer issues; it uses a list with a custom free function. The error handling path (commented-out TODO) is simplistic and doesn't involve the problematic cleanup logic seen in CVE-2013-2124.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is an injection vulnerability (CWE-93) in CUPS due to improper neutralization of CRLF sequences. The target code parses binary structures (Java bootstrap methods attribute) from a buffer with no string processing, command execution, or output generation. The domains (printing system vs. binary analysis) and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 3 is a buffer overflow (CWE-119) in PHP's GD library due to incorrect bounds checking involving arithmetic underflow. The target code performs bounds checking (`if (offset >= sz)`) and calculates remaining size (`sz - offset`) before passing it to `r_bin_java_bootstrap_method_new`. This pattern is directly relevant for preventing out-of-bounds reads. However, the specific underflow flaw is not present here, as `sz` and `offset` are unsigned 64-bit integers, making `sz - offset` safe from underflow in C's unsigned arithmetic. The relevance lies in the similar defensive pattern of bounds checking and size calculation for safe buffer passing.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an uncontrolled resource consumption (CWE-400) vulnerability in ImageMagick due to lack of validation between declared image dimensions and actual data size. The target code validates the loop counter `i` against `num_bootstrap_methods` (read from the buffer) and also checks `offset >= sz` before each iteration. This provides some mitigation against a maliciously large `num_bootstrap_methods` causing excessive iteration. However, the core flaw is different: CVE-2019-11470 is about trusting untrusted size fields leading to huge allocations, while the target code's primary risk is more about parsing logic errors within the loop, not a single massive allocation.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Case 5 is a use-after-free/double-free (CWE-416) in radare2 itself, specifically in the analysis subsystem. The target code is also from radare2 (libr/bin/format/java). The relevance is extremely high because they share the same codebase, ecosystem, and common patterns for memory management (using `r_list_newf` with custom free functions). While the specific module (Java binary parsing vs. analysis basic blocks) differs, the patterns of allocating structures, appending them to lists, and the potential for similar lifecycle management bugs (e.g., if `r_bin_java_bootstrap_method_new` fails or has internal issues) are very similar. This case provides direct, valuable reference for secure coding within radare2.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a heap buffer overflow (CWE-122) in glibc's glob() due to an off-by-one allocation error during string expansion. The target code performs binary parsing with simple integer arithmetic and list operations. There is no string expansion, path manipulation, or complex size calculation prone to off-by-one errors. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a reachable assertion (CWE-617) in ImageMagick due to insufficient validation of a numeric input field. The target code reads a `num_bootstrap_methods` field from the buffer but does not validate it against any reasonable limit before using it as a loop counter. While it has a size check (`offset >= sz`) inside the loop, a very large number could still cause excessive looping (though bounded by the buffer size). This mirrors the lack of validation on untrusted numeric input. However, the consequence is different (excessive iteration vs. assertion crash), and the code pattern is simpler.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an XXE vulnerability (CWE-611) in libxml2. The target code parses a binary buffer, not XML. There is no entity expansion, external resource fetching, or markup language processing. The domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an improper initialization (CWE-665) in the Linux kernel network stack leading to uninitialized memory exposure. The target code initializes local variables and allocates a structure (`attr`). While proper initialization is a universal concern, the specific contextnetwork packet dissection error paths vs. straightforward binary parsing with clear initializationmakes the flaw pattern dissimilar. The target code does not show complex state recovery or error paths that could leave structures partially initialized.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an integer overflow (CWE-190) in the Linux kernel F2FS leading to an infinite loop. The target code uses unsigned 64-bit integers for `offset` and `sz`. The calculation `sz - offset` is safe from wrap-around in unsigned C, but the subsequent addition `offset += bsm->size` could theoretically overflow if `bsm->size` is huge, bypassing the `offset >= sz` check. However, `bsm->size` is presumably derived from the buffer itself and is likely small. The pattern of updating an offset within a loop based on parsed sizes is conceptually similar to the block calculation in CVE-2018-12320, but the risk and context (file system vs. file format parser) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-1452_after_subset_100:e8b5500b:vulspec": {
    "timestamp": "2026-01-17T02:56:45.822746",
    "cve_id": "CVE-2022-1452",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e8b5500b",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in libguestfs error handling. The target code involves memory allocation and list management but shows no evidence of double-free patterns, ownership confusion, or the specific error handling paths that trigger the double free. The primary similarity is the use of dynamic memory management in C.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 2 (CVE-2017-15400) is an injection vulnerability (CRLF sequences leading to command injection) in CUPS IPP attribute processing. The target code is a binary parser for Java class files, dealing with structured data from a buffer. There is no string processing, command construction, or output generation that could lead to injection.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 (CVE-2019-11470) is an uncontrolled resource consumption (CWE-400) in ImageMagick due to lack of validation between declared image dimensions and actual data. The target code reads a count (`num_bootstrap_methods`) from the buffer and loops based on it. While this could theoretically lead to excessive resource use if the count is maliciously large, the code includes a size check (`offset + 8 > sz`) before reading the count and breaks the loop if `offset >= sz`. This provides some mitigation, making the relevance weaker.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 5 (CVE-2018-12320) is a use-after-free/double-free in radare2's basic block analysis. Crucially, the target code is FROM THE SAME SYSTEM (radare2) and a similar domain (binary analysis, specifically Java binary parsing). The code patterns involve managing linked lists (`r_list_newf`, `r_list_append`) and freeing functions (`r_bin_java_bootstrap_method_free`). The historical case directly demonstrates memory safety pitfalls (incomplete structure cleanup, circular references) that are highly relevant to the author of this `r_bin_java_bootstrap_methods_attr_new` function. The vulnerability type and code patterns are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 (CVE-2017-15670) is a heap buffer overflow in glibc's glob due to an off-by-one allocation error. The target code performs arithmetic with offsets and sizes but does not perform any memory allocations based on calculated sizes from the buffer (allocations are for internal structures via `r_bin_java_default_attr_new` and `r_bin_java_bootstrap_method_new`). The primary similarity is the use of pointer arithmetic and bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 (CVE-2017-9499) is a reachable assertion in ImageMagick due to insufficient validation of a numeric input field. The target code reads a `USHORT` from the buffer without explicit validation against a reasonable maximum (though it is constrained by the loop's `offset` and `sz` checks). However, there are no assertions, and the system/domain (image processing vs. binary analysis) is different. The slight similarity is in reading untrusted numeric values.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CVE-2013-0339) is an XXE vulnerability in libxml2. The target code parses a binary format (Java class file) and does not process XML, entities, or external resources. There is no functional similarity.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 (CVE-2017-13715) is an uninitialized memory issue in the Linux kernel network stack. The target code is user-space application code for parsing. While both handle data from an external source, the vulnerability type (improper initialization leading to information leak) and context (kernel vs. user-space, network packets vs. file buffers) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 (CVE-2017-18257) is an integer overflow leading to an infinite loop in the Linux kernel F2FS. The target code uses integer arithmetic for offsets (`offset += bsm->size`) and loop control (`i < num_bootstrap_methods`). An integer overflow in `bsm->size` or `num_bootstrap_methods` could theoretically lead to similar issues (out-of-bounds read, infinite loop). However, the target code's size variable (`sz`) is 64-bit (`ut64`), and the loop includes an `offset >= sz` break check, which mitigates some risks. The relevance is in the pattern of arithmetic on untrusted data.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-29195_before_subset_100:efa65bf1:vulspec": {
    "timestamp": "2026-01-17T02:57:15.864172",
    "cve_id": "CVE-2022-29195",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "efa65bf1",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a file processing library due to improper memory ownership and cleanup. The target code performs buffer indexing and tuple retrieval with bounds checking via `OP_REQUIRES_OK` but does not show explicit memory deallocation or ownership transfer patterns that would lead to a double-free. The contexts are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is about CRLF injection (CWE-93) leading to command injection in a printing system due to improper input neutralization. The target code deals with indexing into a buffer and copying outputs, with no string parsing, protocol handling, or command generation involved. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a buffer overflow (CWE-119) in a kernel driver due to insufficient validation of a user-controlled length parameter. The target code uses an index (`ctx->input(0).scalar<int>()()`) to access a buffer, which could be similar if the index is not properly validated before `buf->Peek`. However, the target code uses `OP_REQUIRES_OK` which likely includes validation, and the context (user-space framework vs. kernel driver) and specific flaw patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a use-after-free (CWE-416) in a reverse engineering tool due to improper cleanup of linked structures. The target code retrieves a tuple from a buffer and sets outputs, with no visible dynamic memory deallocation or pointer manipulation that could lead to a use-after-free. The code patterns and vulnerability mechanisms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is a buffer overflow (CWE-119) in an image library due to incorrect bounds checking involving arithmetic underflow. The target code uses an index to access a buffer; if the index is user-controlled and not properly bounded, it could lead to an out-of-bounds access. However, the `OP_REQUIRES_OK` with `buf->Peek` likely performs validation, and the specific arithmetic underflow flaw is not present. The contexts are different but share a tangential theme of index/bounds validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a race condition (CWE-362) leading to use-after-free (CWE-416) in a kernel tty subsystem due to lack of synchronization on a shared pointer. The target code shows a single-threaded computation function with no evident concurrency or shared state access patterns. The vulnerability types and code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an integer overflow (CWE-190) leading to an infinite loop (CWE-835) in a filesystem driver. The target code involves simple indexing and iteration with `size_t` types, but no complex arithmetic, loop exit conditions based on calculated sizes, or file system operations. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an uncontrolled resource consumption (CWE-400) vulnerability in an image decoder due to lack of validation between declared image dimensions and actual data. The target code does involve retrieving a data structure (tuple) whose size is compared to an expected output count. If the `index` or the buffer's internal state could cause an unexpectedly large tuple allocation or iteration, it might loosely relate to resource validation. However, the primary flaw (dimension vs. data mismatch) and context are very different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an integer overflow (CWE-190) leading to an out-of-bounds write (CWE-787) in a network protocol library due to overflow in frame size calculation. The target code does not perform any arithmetic on the index or sizes that could overflow; it uses them directly. The vulnerability type and code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a reachable assertion (CWE-617) due to insufficient validation of a numeric input field against a maximum limit. The target code includes a check (`OP_REQUIRES`) that validates the tuple size against the number of outputs, which is a form of bounds/validation. However, the vulnerability type (assertion failure vs. potential out-of-bounds access) and context (image file parsing vs. buffer indexing) are different. The similarity is only in the general theme of input validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      }
    ]
  },
  "CVE-2022-29195_after_subset_100:198ab99b:vulspec": {
    "timestamp": "2026-01-17T02:58:04.713016",
    "cve_id": "CVE-2022-29195",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "198ab99b",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine disk image library due to improper memory ownership and cleanup during error handling. The target code performs buffer tuple retrieval and output assignment with basic size validation. There is no dynamic memory allocation, deallocation, or complex error handling paths that could lead to double-free scenarios. The functional domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves CRLF injection (CWE-93) leading to command injection in a printing system's PPD file generation. The target code deals with internal buffer management and output assignment within a tensor operation kernel. There is no string processing, protocol parsing, or command generation that could be susceptible to injection attacks. The attack surfaces and vulnerability mechanisms are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves a buffer overflow (CWE-119) in a SCSI driver due to insufficient validation of user-controlled length parameters. The target code includes a size validation check (`tuple.size() == ctx->num_outputs()`) which is conceptually similar to bounds checking. However, the target code operates on already-validated internal data structures rather than untrusted external input, and there is no memory copying or pointer arithmetic that could lead to buffer overflows. The similarity is limited to the presence of a size check.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 involves a use-after-free (CWE-416) in a reverse engineering framework due to improper cleanup of linked data structures. The target code uses reference-counted buffer management (`core::ScopedUnref`) and accesses the buffer's tuple content. While both involve managing internal data structures, the target code's use of scoped reference counting and simple data retrieval without complex pointer manipulation or deallocation logic makes it resistant to use-after-free patterns seen in the case.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 involves a buffer overflow (CWE-119) in an image library due to incorrect bounds checking and arithmetic underflow. The target code performs a size comparison (`tuple.size() == ctx->num_outputs()`) which is a form of bounds validation. However, the target code does not perform any arithmetic operations on sizes, does not allocate memory based on user input, and operates on already-contained data structures. The similarity is limited to the general concept of validating sizes before access.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves a race condition (CWE-362) leading to use-after-free (CWE-416) in a kernel TTY subsystem due to lack of synchronization on a shared pointer. The target code appears to be part of a single-threaded operation kernel context with no evident concurrency or shared state accessed without protection. The buffer is managed via reference counting, and there is no indication of race condition vulnerabilities. The domains and synchronization concerns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves an integer overflow (CWE-190) leading to an infinite loop (CWE-835) in a filesystem driver. The target code uses standard size_t for loop iteration with a simple comparison against `tuple.size()`. There are no arithmetic operations on sizes, no multiplication or addition that could overflow, and no complex loop conditions. The vulnerability patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves uncontrolled resource consumption (CWE-400) in an image parser due to lack of validation between declared dimensions and actual data. The target code validates that the number of elements in the tuple matches the expected number of outputs. This is conceptually similar to validating that a data structure's claimed size is consistent with expectations. However, the target code does not allocate memory based on the size and operates on an already-populated internal buffer, making resource exhaustion less likely.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves an integer overflow (CWE-190) leading to out-of-bounds write (CWE-787) in a network protocol library due to miscalculation of buffer size. The target code performs no arithmetic on sizes, does not allocate buffers based on calculated sizes, and simply retrieves and assigns existing data. There is no similarity in the vulnerability mechanism or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 involves a reachable assertion (CWE-617) due to insufficient validation of numeric input in an image library. The target code includes an `OP_REQUIRES` check that validates the tuple size, which is a form of input validation. However, the target code does not use assertions, does not process untrusted numeric fields from external sources, and the validation is a simple equality check rather than a range check. The similarity is superficial.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      }
    ]
  },
  "CVE-2019-11454_before_subset_100:211b7ca8:vulspec": {
    "timestamp": "2026-01-17T02:58:08.132686",
    "cve_id": "CVE-2019-11454",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "211b7ca8",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management flaw (CWE-415) in a complex library for inspecting VM disk images. The target code is a simple log file viewer that reads a file sequentially into a stack buffer and outputs it. There is no dynamic memory allocation, pointer manipulation, or complex error handling that could lead to double-free conditions.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is about CRLF sequence injection (CWE-93) leading to command injection in a printer configuration subsystem. The target code reads a log file and outputs its content into an HTML textarea. While both involve outputting data, the target code does not parse or interpret the log file content as commands, nor does it handle network protocol data where CRLF injection is relevant. The attack surface and flaw nature are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 involves improper input validation (CWE-20) of archive paths leading to filesystem issues like symlink races. The target code validates user privileges but then simply opens a predefined log file path (`Run.files.log`) for reading. It does not process user-supplied file paths, create links, or perform complex filesystem operations that require path validation against traversal or race conditions.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is about uncontrolled resource consumption (CWE-400) due to lack of validation between declared image size and actual data. The target code reads a file in fixed-size chunks (511 bytes) into a stack buffer, which inherently bounds the memory usage per read. However, a weak similarity exists: both read files, and if the log file were extremely large, the `while` loop could consume excessive CPU/time (a DoS vector), but there is no unbounded memory allocation based on untrusted file content.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an XXE vulnerability (CWE-611) in an XML parser. The target code does not parse XML or any structured format; it reads raw bytes from a log file and outputs them. There is no entity expansion, external resource fetching, or markup language processing involved.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 is an out-of-bounds read (CWE-125) due to insufficient validation of length fields in network packets. The target code uses `fread` with a fixed buffer size, ensuring reads are bounded. However, a conceptual similarity exists: both read external data (network packets / file content). The key difference is the target code lacks complex parsing of internal length fields from the data stream that could be maliciously crafted to cause OOB reads. The log file content is treated as an opaque byte stream.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a use-after-free (CWE-416) in an email server's memory management. The target code uses only stack variables (`buf[512]`) and standard C file I/O, with no dynamic memory allocation (`malloc`/`free`) or pointer lifecycle management that could lead to a use-after-free condition.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a reachable assertion (CWE-617) due to insufficient validation of a numeric field in an image header. The target code does not parse numeric fields from the log file header, perform assertions, or have any analogous validation logic. It simply streams data out.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is a buffer overflow (CWE-119) due to insufficient validation of a length parameter. The target code uses a fixed-size stack buffer (`buf[512]`) and reads into it with a size limit (`sizeof(buf) - 1`), preventing overflow. A conceptual link exists: both handle external data. However, the target code lacks the vulnerable pattern of using an *untrusted value from the data itself* to control the size of a copy operation. The length is controlled by the safe return value of `fread`.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 10 involves improper bounds checking (CWE-119) due to arithmetic issues (underflow) in image processing. The target code has a potential, though less severe, bounds-related flaw: it uses `sizeof(buf) - 1` (511) as the size for `fread`, but the buffer is 512 bytes. The `buf[n] = 0;` null-termination assumes `n` is less than 512. If `fread` ever returned exactly `sizeof(buf) - 1` (511), the assignment `buf[511] = 0;` would be safe. The arithmetic is safe here. The stronger relevance is the pattern of reading external data into a buffer and the need to ensure operations stay within bounds, which the target code does correctly. The similarity is in the defensive programming mindset required.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2019-11454_after_subset_100:a6c151b0:vulspec": {
    "timestamp": "2026-01-17T02:58:16.007233",
    "cve_id": "CVE-2019-11454",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a6c151b0",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management flaw in a virtual disk inspection library. The target code performs simple file reading and HTML escaping with no dynamic memory allocation or complex error handling paths that could lead to double-free issues.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 involves CRLF injection leading to command injection in a printing system. The target code reads a log file and escapes HTML content, with no command execution, protocol parsing, or CRLF sequence handling that could be similarly exploited.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 involves path validation and symlink race conditions in an archive extraction library. The target code opens a fixed log file path (Run.files.log) with fopen() but doesn't involve user-controlled paths, archive parsing, or complex filesystem operations vulnerable to symlink attacks.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 involves uncontrolled resource consumption through unvalidated image dimensions. The target code reads a log file in fixed-size chunks (512 bytes) with no dimension parsing or unbounded allocations. Both handle file input, but the vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 involves XML external entity injection. The target code performs simple file I/O and HTML escaping with no XML parsing, entity resolution, or similar complex parsing logic that could be vulnerable to injection attacks.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 involves out-of-bounds read in network protocol parsing. The target code reads files with proper bounds checking (sizeof(buf)-1) and null termination. Both parse data, but the vulnerability context (network packets vs. file reading) and patterns differ substantially.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 involves use-after-free in email header processing. The target code uses simple FILE* operations with no dynamic memory management, pointer manipulation, or complex state tracking that could lead to use-after-free conditions.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 involves reachable assertion due to unvalidated numeric input. The target code reads file content without parsing numeric fields or having assertions. Both process file input, but the vulnerability mechanisms (assertion failure vs. potential file reading issues) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 involves buffer overflow in a kernel SCSI driver. The target code uses fixed-size buffers with proper bounds checking during file reading. Both involve data copying, but the context (kernel driver vs. user-space file viewer) and vulnerability severity differ greatly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 involves improper bounds checking leading to buffer overflows in image processing. The target code has a buffer size check (sizeof(buf)-1) during fread, but both involve reading data into fixed buffers. However, the target code's buffer handling appears correct, and the vulnerability contexts differ (image processing vs. log file viewing).",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2022-2183_before_subset_100:36db90f3:vulspec": {
    "timestamp": "2026-01-17T02:58:30.871012",
    "cve_id": "CVE-2022-2183",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "36db90f3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a Lisp indentation calculation function in an editor (likely Vim), performing string parsing and cursor manipulation. It does not involve dynamic memory allocation, freeing, or double-free scenarios. The vulnerability context (libguestfs disk image processing) and flaw type (CWE-415 Double Free) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code parses a single line of Lisp code for indentation, handling characters like parentheses, quotes, and comments. It does not parse XML, resolve external entities, or process complex document structures. The vulnerability context (libxml2 XML parsing) and flaw type (CWE-611 XXE) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code calculates visual indentation columns, performing character-by-character analysis. It does not generate files (like PPD), process network protocol attributes, or embed CRLF sequences into output streams. The vulnerability context (CUPS IPP/PPD generation) and flaw type (CWE-93 CRLF Injection) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The only weak similarity is that both involve parsing file/line content. However, the target code parses a known-in-memory string for syntax, performing safe character iteration and arithmetic on integers (indent amount). It does not parse binary file headers, allocate memory based on untrusted dimensions, or risk resource exhaustion (CWE-400). The contexts (image decoding vs. editor indentation) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code performs simple arithmetic on `int` and `colnr_T` (likely an integer) types for indentation width. It does not perform path expansion, allocate buffers for filenames, or have off-by-one errors in buffer size calculations. The vulnerability context (glibc glob path expansion) and flaw type (CWE-122 Heap Buffer Overflow) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code uses local variables and cursor positions on the stack. It does not dynamically allocate or free complex linked structures (like basic blocks), manage pointers to heap memory, or have use-after-free or double-free risks. The vulnerability context (radare2 analysis data structures) and flaw type (CWE-416 Use After Free) are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. A minor similarity exists in parsing structured data (the target parses Lisp tokens, the vulnerability parses network TLVs). However, the target code iterates over a null-terminated string (`*that != NUL`) with simple pointer increments, performing bounds checks via the null terminator. It does not read length fields from untrusted data or access memory out-of-bounds (CWE-125). The contexts (network dissector vs. indentation logic) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not involve any dynamic memory management (`store_release` equivalents), email header processing, or SMTP command handling. It operates on local variables and editor buffer lines. The vulnerability context (Exim MTA) and flaw type (CWE-416 Use After Free) are not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code validates characters (whitespace, parentheses, quotes, comments) but does not parse LDAP queries, perform case folding, or generate SQL. Its input is the current line in an editor buffer, not network queries. The vulnerability context (Samba LDAP server) and flaw type (CWE-20 via failed DN processing) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code initializes local integers (e.g., `parencount = 0`) and cursor positions. It does not parse network packet headers, manage complex dissector state, or have error paths that leave structures uninitialized. The vulnerability context (Linux kernel flow dissector) and flaw type (CWE-665 Improper Initialization leading to info leak) are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-2183_after_subset_100:d8ed21e4:vulspec": {
    "timestamp": "2026-01-17T02:58:44.970864",
    "cve_id": "CVE-2022-2183",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d8ed21e4",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to memory ownership and error handling. The target code is a Lisp indentation calculation function in an editor (likely Vim) that performs string parsing and cursor manipulation with no dynamic memory allocation or deallocation. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in libxml2 involving external entity processing. The target code parses Lisp code for indentation, handling characters like parentheses, quotes, and semicolons locally. There is no XML parsing, external resource fetching, or similar attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection vulnerability in CUPS PPD file generation. The target code calculates indentation levels; it does not generate files, process external input for command execution, or handle CRLF sequences in a security-sensitive context.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-11470 is a resource consumption vulnerability in ImageMagick due to unvalidated image dimensions leading to excessive memory allocation. The target code performs linear string traversal with fixed-size local variables; it does not parse binary headers or allocate memory based on untrusted size fields.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob() due to an off-by-one allocation error. The target code uses safe string traversal functions like `lbr_chartabsize_adv` and does not perform any manual memory allocation or buffer operations that could lead to overflows.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in radare2 involving linked list cleanup of analysis structures. The target code has no dynamic data structures, pointers to freed memory, or similar memory management patterns.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-13033 is an out-of-bounds read in tcpdump due to insufficient validation of length fields. The target code does parse a string (`that`) and uses pointer increments, but it operates within a single line buffer obtained via `ml_get_curline()`. While both involve parsing, the target code's checks for `NUL` termination and use of `col` decrement provide some bounds control, making the vulnerability pattern dissimilar. The risk of OOB read is much lower and not the primary flaw pattern here.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-16943 is a use-after-free in Exim related to BDAT command and header processing with complex memory ownership. The target code has no analogous memory release or reference patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-1140 is an input validation flaw in Samba's LDAP query to SQL translation, involving NULL pointer checks and error handling. The target code validates characters for Lisp syntax but does not translate queries, handle NULL returns from complex functions, or have similar error propagation issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13715 is an uninitialized memory exposure in the Linux kernel flow dissector due to improper state reset on error paths. The target code initializes all local variables (e.g., `amount = -1`, `parencount = 0`) and does not have complex state machines or error paths that skip initialization.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2016-8652_before_subset_100:ddd79b54:vulspec": {
    "timestamp": "2026-01-17T02:59:26.804260",
    "cve_id": "CVE-2016-8652",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ddd79b54",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs memory allocation and copying but does not show any pattern of double freeing or complex ownership transfer. The vulnerability (CWE-415) and the specific trigger (error handling with empty files) are not relevant to the authentication variable expansion logic.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "The target code involves string processing and escaping, but its purpose is to build an expansion table for authentication variables, not to generate configuration files from untrusted network input. The core flaw (CWE-93 - CRLF injection leading to command injection) and attack surface (malicious IPP responses) are not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code is a user-space application function for building a data structure. It does not involve parsing network packets, managing complex protocol state, or dealing with uninitialized memory in the way the kernel's flow dissector does. The vulnerability class (CWE-665) and context are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Both involve string processing and memory allocation. However, the target code uses a simple `t_malloc` (likely a talloc wrapper) and `memcpy` for a fixed-size structure array, with no apparent string length calculations that could lead to an off-by-one heap overflow (CWE-122). The glibc glob vulnerability stemmed from recursive path expansion, which is not happening here.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code does not parse any binary protocol data or read length fields from untrusted input. All operations are on internal `auth_request` structure fields. The out-of-bounds read (CWE-125) vulnerability pattern from parsing network packets is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both the target code and the PgBouncer case are in the domain of authentication systems. Both process user credentials and connection information. However, the key flaw in the target code (if any) is not a NULL pointer dereference due to protocol state violation. The target code carefully checks for NULL pointers (e.g., `auth_request->mech_name == NULL ? \"\" :`). The attack surface (malformed packet sequences) is also different.",
        "case_metadata": {
          "cve_id": "CVE-2015-4054"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code performs arithmetic for array sizing (`*count + auth_count`) but uses fixed, small constants (`auth_count` is static). There is no loop or calculation on untrusted integer inputs that could overflow (CWE-190). The context (kernel IPv6 packet parsing) is entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-7542"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code does not parse XML or any markup language. It does not resolve external entities. The vulnerability type (CWE-611 - XXE) and its associated attack surface are completely irrelevant to this authentication variable expansion function.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Both involve bounds checking and memory buffer operations. The target code uses `memcpy` with a calculated size (`auth_count * sizeof(*tab)`). If `auth_count` were controllable or corrupted, it could lead to a buffer overflow. However, `auth_count` is derived from `N_ELEMENTS` on a static array, making it a compile-time constant, unlike the PHP GD case where the size came from untrusted image data. The relevance is very low.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code contains simple integer arithmetic for memory allocation but no loops whose exit conditions depend on that arithmetic. The vulnerability pattern of integer overflow leading to an infinite loop (CWE-190 -> CWE-835) in a filesystem block mapping context is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2016-8652_after_subset_100:2f7b2112:vulspec": {
    "timestamp": "2026-01-17T02:59:39.125055",
    "cve_id": "CVE-2016-8652",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2f7b2112",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in a file processing function. The target code is an authentication variable expansion table builder that performs memory allocation and string manipulation but shows no pattern of double freeing, complex error handling, or violation of memory ownership semantics. The functional domains are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 (CVE-2017-15400) is a CRLF injection/command injection vulnerability in a PPD file generator. The target code builds a data structure for variable expansion (likely for log messages or configuration) and uses an escape function on inputs. While both involve processing external data, the target code does not generate executable files/commands, and the primary flaw pattern (injection) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 (CVE-2017-13715) is an uninitialized memory exposure in a network packet parser. The target code initializes its table with `memset` and carefully assigns values, showing no signs of leaving fields uninitialized or exposing kernel memory. The domains (authentication vs. network parsing) and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 (CVE-2017-15670) is a heap buffer overflow due to an off-by-one allocation error in a path expansion function. The target code allocates memory using `t_malloc` and `memcpy` with calculated sizes, but there is no evident off-by-one calculation or direct buffer overflow from user input. The similarity is limited to both performing memory allocation.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 (CVE-2017-13033) is an out-of-bounds read in a network protocol dissector due to insufficient length validation. The target code does not parse binary network packets or perform length checks on external data. It operates on structured auth request fields. The flaw pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 (CVE-2015-4054) is a NULL pointer dereference in an authentication state machine. The target code also handles authentication data and includes multiple NULL checks (e.g., for `auth_request->user`, `auth_request->session_id`). However, the target code's pattern is defensive (using ternary operators), while the CVE flaw was a missing state validation leading to a crash. There is a thematic link (authentication) but the specific vulnerability mechanism is different.",
        "case_metadata": {
          "cve_id": "CVE-2015-4054"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CVE-2017-7542) is an integer overflow leading to an infinite loop in an IPv6 header parser. The target code performs simple arithmetic (`*count + auth_count`) for allocation but uses fixed, small constants (`auth_count` is static array size). There is no loop or complex integer math that could overflow. The domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-7542"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability. The target code does not parse XML or any markup language. It processes authentication request structs. No relevance in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 (CVE-2016-8670) is a buffer overflow/underflow in an image processing library due to incorrect bounds checking. The target code does not manipulate image buffers or perform low-level byte operations. It copies structures and assigns string pointers. The core flaw (arithmetic underflow) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 (CVE-2017-18257) is an integer overflow in a filesystem block mapping function leading to an infinite loop. Similar to case 7, the target code lacks the complex block arithmetic and loop structures that could cause this flaw. The functional context is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2019-14464_before_subset_100:25b3cb7e:vulspec": {
    "timestamp": "2026-01-17T02:59:45.418492",
    "cve_id": "CVE-2019-14464",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "25b3cb7e",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a double-free vulnerability in a virtual disk inspection library due to complex ownership and error handling issues. The target code is a music file loader with straightforward memory allocation/deallocation (new/delete). While both handle file formats, the vulnerability patterns (double-free vs. potential buffer overflows/integer issues) and code structures are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XML External Entity (XXE) vulnerability in a parsing library. The target code parses a binary S3M music file format with no XML processing, no external entity resolution, and a completely different threat model (malicious file content vs. external resource inclusion).",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 involves uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared dimensions and actual data. The target code reads S3M file headers containing sample lengths, loop points, and pattern sizes. Similar patterns exist: reading untrusted numeric values from a file (e.g., `smp[s].samplen`, `header->ordnum`) and using them for memory allocation (`new mp_ubyte[header->ordnum]`) or buffer accesses without sufficient validation against file bounds, which could lead to excessive allocation or out-of-bounds reads.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a use-after-free/double-free in a reverse engineering tool due to circular references in linked structures. The target code uses simple dynamic arrays (`new[]`/`delete[]`) with no complex pointer-based data structures (like linked lists or graphs) that could create circular dependencies. Memory management is linear and localized.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a CRLF injection/command injection vulnerability in a printing system during PPD file generation. The target code reads binary data and performs no command generation, shell invocation, or text-based protocol handling that could allow injection attacks.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a use-after-free in an MTA due to complex state management during SMTP command processing. The target code has simpler, linear resource management. While both parse untrusted input (email vs. music file), the memory ownership patterns and error paths are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves improper input validation (CWE-20) leading to path traversal/symlink issues in an archive extractor. The target code also reads untrusted file input but does not perform filesystem operations (extraction, symlink creation). However, both share the broader theme of insufficient validation of attacker-controlled file metadata (e.g., the target code reads file offsets like `samplePtrs[i]` and seeks without full validation).",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is a reachable assertion (CWE-617) due to lack of validation on a numeric field (`number_meta_channels`). The target code reads many numeric fields from the file (e.g., `header->insnum`, `header->patnum`, `smp[s].samplen`) and uses them for array indexing and loop bounds without explicit validation or sanity checks. This could lead to out-of-bounds accesses or excessive resource consumption, similar to the unchecked value leading to an assertion failure.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is an out-of-bounds read (CWE-125) in an image decoder due to insufficient validation of dimension fields before memory operations. The target code exhibits a very similar pattern: it reads values like `smp[s].samplen`, `smp[s].loopstart`, `size` (pattern data) from the file and later uses them for memory accesses (e.g., in `safeRead`, or when reading sample data) without rigorous validation against the actual file size or allocated buffer sizes. This creates a direct analog to the SGI vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an integer overflow (CWE-190) in a filesystem block calculation leading to an infinite loop. The target code performs arithmetic on file-derived integers (e.g., `looplen = f.readDword() - smp[s].loopstart`, bit shifts for 16-bit samples). While integer overflows/wraparounds are possible if values are malicious, the code does not show the same complex loop-with-exit-condition pattern. The relevance is limited to the general risk of integer mishandling.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2019-14464_after_subset_100:f966b138:vulspec": {
    "timestamp": "2026-01-17T03:00:07.656766",
    "cve_id": "CVE-2019-14464",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f966b138",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk inspection library due to complex ownership and error handling issues. The target code is a music module (S3M) loader that performs careful memory allocation and deallocation with explicit checks (MP_OUT_OF_MEMORY). While both handle file formats, the vulnerability patterns (double-free vs. potential integer overflows/out-of-bounds reads) and code structures are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XML External Entity (XXE) injection vulnerability in a parsing library. The target code parses a binary music file format (S3M) with no XML processing, no external entity fetching, and a completely different parsing model (sequential reads of structured binary data). The attack surfaces and flaw patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 involves uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared image dimensions and actual data size. The target code reads S3M file headers containing fields like `samplen`, `loopstart`, and pattern sizes. Similar patterns exist: reading untrusted values from a file header and using them for memory operations (e.g., `samplePtrs[i]`, pattern unpacking) without sufficient validation against the actual file size or reasonable bounds, which could lead to DoS or out-of-bounds reads.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a use-after-free/double-free in a reverse engineering tool due to circular references in linked structures during cleanup. The target code uses simple arrays (`new[]`/`delete[]`) for temporary buffers and does not manipulate complex linked lists or have shared ownership semantics. The memory management patterns and potential flaw triggers are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a CRLF injection/command injection vulnerability in a printing system during PPD file generation. The target code reads binary data and does not generate configuration files, execute commands, or process text-based protocols. The vulnerability class and code patterns are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a use-after-free in an MTA due to incorrect memory ownership tracking during SMTP command processing. The target code's memory management is straightforward (allocate, use, delete) within a single function scope without complex state or callback interactions that could lead to use-after-free. The contexts are too different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 involves improper input validation (CWE-20) leading to path traversal and filesystem issues in an archive extractor. The target code validates some numeric limits (e.g., `header->insnum > MP_MAXINS`, `header->patnum > 256`) but does not perform extensive validation on file offsets read from the untrusted file (e.g., `insOffs`, `patOffs`, `samplePtrs[i]`). Both involve parsing untrusted file metadata, but the consequence domains (filesystem vs. memory corruption) and specific validation flaws are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is a reachable assertion (CWE-617) due to insufficient validation of a numeric header field (`number_meta_channels`). The target code reads many numeric fields from the S3M header (e.g., `header->ordnum`, `header->insnum`, `smp[s].samplen`, `smp[s].loopstart`) and uses them for array indexing, memory allocation, and file seeking. While there are no assertions, similar lack of validation on these fields (e.g., ensuring `insOffs` is within file bounds, `smp[s].samplen` is reasonable) could lead to out-of-bounds reads/writes or excessive resource consumption, sharing the core flaw pattern of trusting untrusted numeric input.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 9 is an out-of-bounds read (CWE-125) in an image decoder due to insufficient validation of image dimensions (`rows`) before memory operations. The target code has highly similar patterns: it reads `smp[s].samplen`, `smp[s].loopstart`, and `looplen` from the file and performs arithmetic (`looplen = f.readDword() - smp[s].loopstart`) and bit shifts (`smp[s].samplen >>= 1`) without robust validation. A malicious `samplen` or `loopstart` could cause integer overflows/wraparounds, negative `looplen`, or excessive memory allocation in `module->loadModuleSample`. The code patterns (reading untrusted sizes, using them in calculations, potential for OOB access) and vulnerability class are very similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an integer overflow (CWE-190) leading to an infinite loop (CWE-835) in a filesystem driver. The target code contains integer arithmetic that could overflow (e.g., `samplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16`, `looplen` calculation) and uses loop conditions based on file data (`while (index<size)`). However, the context and primary risk (kernel driver infinite loop vs. user-space parser memory corruption) differ. The integer handling flaw pattern is relevant, but the manifestation and impact are less directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-23577_before_subset_100:d8fae047:vulspec": {
    "timestamp": "2026-01-17T03:00:10.071316",
    "cve_id": "CVE-2022-23577",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d8fae047",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs simple map lookups and string assignments with basic error checking. It does not involve any dynamic memory management (allocation/freeing), which is the core of CVE-2013-2124 (Double Free). The functional domains (TensorFlow model loading vs. VM disk image inspection) and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code validates collection sizes and returns error statuses. It does not process or generate any file content, nor does it handle CRLF sequences or external input that could lead to injection. CVE-2017-15400 involves command injection via improper neutralization in generated PPD files, which is irrelevant to the map lookup logic here.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Both involve parsing structured data (MetaGraphDef vs. MPC image header). However, the target code only performs key lookups in protobuf maps and validates a list size. It does not parse numeric fields from raw data or perform any arithmetic operations that could lead to integer overflows or assertion failures like in CVE-2017-9499. The similarity is superficial (data parsing context).",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code has no buffer operations, pathname expansion, or memory allocation based on user input size. CVE-2017-15670 is a heap buffer overflow due to an off-by-one error in path expansion calculations. The code patterns and vulnerability types are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code works on in-memory protocol buffer structures, not filesystem paths or archive extraction. It performs no path validation, link resolution, or filesystem operations. CVE-2016-5418's core flaw (improper input validation leading to path traversal) is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Both involve parsing a structured format (SavedModel protobuf vs. Cineon image header). The target code validates that a node_list contains exactly one element, which is a basic sanity check similar to validating image dimensions. However, the target code does not allocate resources based on the parsed data, so the risk of uncontrolled resource consumption (CWE-400) is minimal and not the primary concern. The reference value is low.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code does not allocate or free any dynamic memory structures; it works with STL/Protobuf containers and returns status objects. There are no pointers or manual memory management that could lead to Use-After-Free or Double Free issues as in CVE-2018-12320.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code parses a trusted, serialized protobuf (MetaGraphDef) from a known directory. It does not parse arbitrary, complex external data formats like XML, resolve external entities, or have an expansive attack surface from untrusted network data. CVE-2013-0339 (XXE) is irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code contains no integer arithmetic, loops, or block size calculations. It performs simple comparisons and assignments. The integer overflow leading to an infinite loop (CWE-190, CWE-835) in CVE-2017-18257 has no parallel here.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code does not perform any buffer operations, bounds checking on raw memory, or arithmetic that could underflow. It accesses protobuf fields via safe accessor methods (.value_size(), .value(0)). The out-of-bounds read/write vulnerability (CWE-119) in CVE-2016-8670 is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2022-23577_after_subset_100:460505a0:vulspec": {
    "timestamp": "2026-01-17T03:00:46.988321",
    "cve_id": "CVE-2022-23577",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "460505a0",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory corruption vulnerability in a file processing function. The target code is a simple data lookup and validation function in TensorFlow's SavedModel loader with no dynamic memory allocation, deallocation, or complex error paths that could lead to double-free.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves CRLF injection leading to command injection in a printer configuration system. The target code performs string lookups in protocol buffer structures with no command execution, output generation, or injection vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 involves an assertion failure due to insufficient input validation of numeric fields. The target code validates collection sizes and handles missing keys but doesn't parse numeric input or have assertions that could be triggered by malicious data.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves a heap buffer overflow due to off-by-one calculation in path expansion. The target code performs only string lookups and assignments with no buffer operations, arithmetic calculations, or path manipulation.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves path validation issues leading to symlink/hardlink attacks during archive extraction. The target code reads metadata from a serialized graph structure with no filesystem operations or path resolution.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 involves uncontrolled resource consumption through unvalidated image dimensions. The target code validates collection sizes (node_list().value_size() != 1) but doesn't allocate memory based on untrusted input or process binary data formats.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 involves use-after-free in linked structure cleanup. The target code has no dynamic memory management, linked data structures, or pointer manipulation that could lead to use-after-free vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves XXE (XML External Entity) attacks. The target code processes protocol buffer structures, not XML, and has no entity resolution or external resource fetching mechanisms.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves integer overflow leading to infinite loop in filesystem block mapping. The target code performs simple lookups and string assignments with no arithmetic operations, loops, or block calculations.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 involves buffer overflow due to incorrect bounds checking in image processing. The target code has no buffer operations, array indexing, or bounds checking vulnerabilities - it only accesses protocol buffer fields through safe API calls.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2021-37688_before_subset_100:bbbb56ed:vulspec": {
    "timestamp": "2026-01-17T03:01:12.710413",
    "cve_id": "CVE-2021-37688",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bbbb56ed",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs arithmetic broadcasting with nested loops and pointer arithmetic. CVE-2013-2124 is a double-free vulnerability in a file processing module of libguestfs, involving memory ownership and error handling. The code patterns, vulnerability type (memory corruption vs. logic/arithmetic), and domain (tensor operations vs. VM disk inspection) are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-15400 is an injection vulnerability (CRLF sequences) in a printing system's IPP attribute processing. The target code is a low-level tensor arithmetic broadcasting function with nested loops and pointer manipulation. There is no similarity in vulnerability type (injection vs. potential bounds/arithmetic issues), functionality, or code patterns. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2019-11470 is a resource consumption vulnerability due to lack of validation between declared image dimensions and actual data. The target code also involves dimensions (broadcast_shape) and nested loops. While the core flaw (unvalidated dimensions leading to excessive computation/memory access) is conceptually similar, the manifestation is different (DoS via allocation vs. potential out-of-bounds access in loops). Weak relevance due to the shared theme of dimension validation.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-9499 is a reachable assertion vulnerability due to insufficient validation of a numeric input field. The target code uses parameters (broadcast_shape) without visible validation. The similarity is the potential for invalid parameters to cause unexpected behavior. However, the vulnerability type (assertion crash vs. logic error/buffer overflow) and context (image parsing vs. arithmetic kernel) differ significantly. Very low to weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-13715 is an improper initialization vulnerability in a network packet parser, leading to information disclosure. The target code initializes local pointers and variables within loops. While both involve state management, the target code's state is simple loop counters and pointers, not complex protocol parsing state. The risk profile (info leak vs. memory corruption) and domain are unrelated. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free vulnerability in a reverse engineering tool's data structure cleanup. The target code performs arithmetic operations on raw pointers but does not involve dynamic memory allocation or deallocation. The vulnerability types (memory management bugs vs. potential pointer arithmetic bugs) and code patterns are completely different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-5418 is an input validation vulnerability in an archive library's path handling, leading to symlink/hardlink issues. The target code validates no inputs and performs no filesystem operations. The domains (file extraction vs. numerical computation) and potential flaw types are entirely dissimilar. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-19843 is an out-of-bounds read due to insufficient bounds checking on an array index derived from user input (register operand). The target code uses user-provided `broadcast_shape` array values (`y0`-`y4`) to control loop bounds and pointer arithmetic (`input2_data_ptr += y4`, etc.). If these values are maliciously large, they could lead to out-of-bounds reads/writes. The pattern is similar: user-controlled indices/dimensions used without sufficient validation in array/pointer access. However, the context (assembler vs. tensor math) differs. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2017-15670 is a heap buffer overflow due to an off-by-one error in a memory allocation calculation in a path expansion function. The target code does not perform any dynamic memory allocation; it operates on pre-allocated buffers. The vulnerability mechanism (allocation miscalculation) is not present in the target code. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 6,
        "reasoning": "CVE-2015-5156 is a buffer overflow due to incorrect assumptions about feature support leading to insufficient buffer allocation and lack of bounds checking during packet processing. The target code's primary risk is similar: if the `broadcast_shape` parameters (y0-y4) do not correctly correspond to the actual sizes of the `input1_data`, `input2_data`, and `output_data` buffers, the pointer arithmetic (`+= y4`, `+= y3`) could lead to out-of-bounds reads and writes. Both involve a lack of validation between user/attacker-influenced size parameters and actual buffer bounds during iterative access. The context differs (network driver vs. math kernel), but the core vulnerability pattern is conceptually similar. Moderate relevance.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2021-37688_after_subset_100:78bccf0a:vulspec": {
    "timestamp": "2026-01-17T03:01:35.525472",
    "cve_id": "CVE-2021-37688",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "78bccf0a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs arithmetic broadcasting with nested loops and pointer arithmetic but contains no dynamic memory allocation, deallocation, or ownership transfer logic that would be relevant to a double-free vulnerability (CWE-415). The code patterns and domain are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a low-level arithmetic kernel function for tensor operations. It does not process textual input, protocol data, or generate files, so it has no surface for CRLF injection or command injection (CWE-93). The functional domains are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve processing multi-dimensional data (image dimensions vs. broadcast shapes). The potential similarity lies in the risk of uncontrolled resource consumption if shape parameters (`y0`-`y4`) are maliciously large, leading to excessive loop iterations. However, the target code lacks explicit memory allocation based on these parameters, making a direct overflow less likely. The reference value is limited to the concept of validating multi-dimensional shape inputs.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code does not parse file headers, convert strings to integers, or have assertions. The vulnerability (CWE-617) revolves around input validation and assertion failure, which is not present in this arithmetic loop kernel. The code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The target code involves well-defined loop variables and pointer arithmetic within a single function scope. There is no complex state machine, protocol parsing, or error path that leaves variables uninitialized (CWE-665). The context and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code has no linked data structures, dynamic memory management, or cleanup functions. It operates on simple arrays and pointers provided as arguments. Use-after-free (CWE-416) or double-free patterns are not applicable to this code's structure.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs numerical computations on in-memory arrays. It does not handle filesystem paths, archives, symlinks, or any external resource validation (CWE-20). The domains and potential flaws are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The primary connection is the use of array indexing (`params.broadcast_shape[0-4]`) without explicit bounds checking within the function. If the `broadcast_shape` array has fewer than 5 elements, an out-of-bounds read (CWE-125) could occur when accessing indices 0-4. This mirrors the flaw in CVE-2018-19843 where an array index was used without bounds verification. The relevance is tempered because the target function likely expects a correctly sized array from its caller, but the lack of internal validation is a similar pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code uses fixed loop bounds and pointer arithmetic with known increments. There is no dynamic string expansion, memory allocation based on user input, or off-by-one calculations that could lead to a heap buffer overflow (CWE-122). The code patterns are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. While both involve processing data in chunks (packet fragments vs. tensor slices), the target code's loops are bounded by the `y0`-`y4` parameters and pointer advances are based on these fixed sizes. There is no dynamic accumulation of fragments or buffer allocation that could overflow (CWE-119). The `input1_data_ptr` and `input2_data_ptr` advances are controlled by the loop structure and shape parameters, lacking the unbounded accumulation flaw of the CVE.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2021-3888_before_subset_100:49f50fb5:vulspec": {
    "timestamp": "2026-01-17T03:01:39.828485",
    "cve_id": "CVE-2021-3888",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "49f50fb5",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing file formats and have bounds checking (huff_rec_count > HUFF_RECORD_MAXCNT), but the core flaw differs. CVE-2019-11470 is about uncontrolled memory allocation based on unvalidated dimensions leading to resource exhaustion (CWE-400). The target code performs size validation and has a fixed maximum limit, focusing more on data corruption and allocation failure paths.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability (CWE-415) related to inconsistent state management during error handling. The target code has multiple error return paths but does not involve complex ownership transfer or double-free patterns. Memory is allocated once for `huffcdic->symbols` and freed elsewhere, not within this function.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability (CWE-611) in an XML parser. The target code parses a binary Huffman dictionary format for MOBI e-books. The domains (XML vs. binary compression), attack surfaces, and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection (CWE-93) leading to command injection in a printing system. The target code is a binary data parser with no command generation, output formatting, or text-based protocol handling.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free (CWE-416) in a linked structure cleanup. The target code traverses a linked list (`curr = curr->next`) but does not modify or free the nodes within this function. Its memory management concerns are simple allocation (`malloc`) success/failure.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing file formats and contain loops. CVE-2017-14054 is an excessive iteration flaw (CWE-834) due to a missing EOF check. The target code has a loop (`while (i < huff_rec_count - 1)`) but its iteration count is bounded by `huff_rec_count`, which is validated against `HUFF_RECORD_MAXCNT`. The risk of unbounded iteration is low.",
        "case_metadata": {
          "cve_id": "CVE-2017-14054"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve parsing a file format header and validating numeric fields. CVE-2017-9499 is a reachable assertion (CWE-617) due to insufficient validation of a header field (`number_meta_channels`). The target code validates `huff_rec_count` against `HUFF_RECORD_MAXCNT` and `curr->size` against `HUFF_RECORD_MINSIZE`. The pattern of validating header-provided counts/sizes before use is similar, though the specific vulnerability outcome (assertion crash vs. data corruption/DoS) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve bounds checking. CVE-2016-8670 is a buffer overflow (CWE-119) due to an incorrect check involving arithmetic. The target code performs size checks (`curr->size < HUFF_RECORD_MINSIZE`) but does not show complex arithmetic that could underflow/overflow. The relevance is in the general principle of validating sizes before operations.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow (CWE-122) from an off-by-one allocation error in path expansion. The target code allocates memory based on a validated count (`(huff_rec_count - 1) * sizeof(*huffcdic->symbols)`). There is no obvious off-by-one pattern, and the domain (pathname globbing vs. binary dictionary parsing) is unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. This is the most relevant case. Both involve parsing a file format where a header field (`huff_rec_count` / `hdr.toc_length_decompressed`) dictates subsequent memory allocation and loop iterations. CVE-2018-1000085 is an out-of-bounds read (CWE-125) due to a mismatch between declared and actual data size. The target code validates `huff_rec_count` and ensures the linked list has enough nodes (`curr == NULL` check in loop), which mitigates the analogous risk. The code pattern of trusting a header count, allocating based on it, and then reading that many records is structurally similar, making this a valuable reference for understanding potential pitfalls.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      }
    ]
  },
  "CVE-2021-3888_after_subset_100:2765864b:vulspec": {
    "timestamp": "2026-01-17T03:01:56.934264",
    "cve_id": "CVE-2021-3888",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2765864b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing file formats and have validation checks (dimensions vs record count/size), but the core flaw differs. CVE-2019-11470 is about unbounded memory allocation due to unchecked dimensions leading to resource exhaustion (CWE-400). The target code performs bounds checks (huff_rec_count > HUFF_RECORD_MAXCNT, curr->size < HUFF_RECORD_MINSIZE) and allocates based on a validated count. The similarity is in the domain of file parsing with size validation, but the vulnerability pattern is not identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free (CWE-415) in error handling paths. The target code has multiple error returns but does not involve complex cleanup of the same resource or double-free patterns. Memory is allocated once for `huffcdic->symbols` and freed elsewhere (not shown). The code patterns and flaw type are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability (CWE-611) in an XML parser. The target code parses a binary Huffman dictionary for MOBI e-books. The domains (XML vs. binary compression), attack surfaces, and vulnerability types have no meaningful overlap.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection/command injection (CWE-93) in a printing protocol handler generating PPD files. The target code is a binary data parser with no string formatting, command execution, or protocol handling. No similarity in flaw type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-12320 is a use-after-free/double-free (CWE-416) in a linked list cleanup. The target code iterates through a linked list (`curr = curr->next`) but does not perform any deallocation within the function. The potential similarity is in traversing an external linked list where `curr` could become NULL, but the code checks for this. The core memory corruption flaw is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-14054 involves an excessive iteration loop (CWE-834) without proper EOF checks. The target code has a loop (`while (i < huff_rec_count - 1)`) that is bounded by a previously validated count (`huff_rec_count`). Both involve loops in parsers, but the target's loop bound is validated and not directly read from untrusted data within the loop itself, making the flaw pattern less similar. The relevance is in the pattern of iterating based on parsed data.",
        "case_metadata": {
          "cve_id": "CVE-2017-14054"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2017-9499 is a reachable assertion (CWE-617) due to insufficient validation of a numeric field (`number_meta_channels`). The target code validates numeric fields from the MOBI header (`huff_rec_count > HUFF_RECORD_MAXCNT`, `curr->size < HUFF_RECORD_MINSIZE`). The similarity lies in the pattern of validating parsed integer values against limits to prevent downstream issues. However, the target code's validation seems more robust, and the specific trigger (assertion failure) is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2016-8670 involves improper bounds checking (CWE-119) due to arithmetic issues. The target code performs several bounds checks on sizes and counts derived from parsed data. While no obvious arithmetic flaw is visible, the code pattern is similar: validating untrusted integer values (record count, record size) before using them for memory allocation (`malloc`) and loop control. This is a core security pattern in safe parsers. The relevance is in the defensive validation logic.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow (CWE-122) due to an off-by-one error in allocation. The target code has one allocation `malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols))` based on a validated count. There is no evident off-by-one error in the allocation size calculation. The domains and specific flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2018-1000085 involves an out-of-bounds read (CWE-125) due to a mismatch between a declared size and actual decompressed data size. The target code validates `curr->size` against `HUFF_RECORD_MINSIZE` before parsing. The key similarity is validating a size field from the file/record header before using the associated data buffer. This is a direct parallel: both parsers must ensure that the actual data length meets expectations based on metadata. The target code does this for the HUFF record, and presumably `mobi_parse_huff` and `mobi_parse_cdic` would do further validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      }
    ]
  },
  "CVE-2022-2288_before_subset_100:c73e50b5:vulspec": {
    "timestamp": "2026-01-17T03:02:17.195043",
    "cve_id": "CVE-2022-2288",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c73e50b5",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a command parser for Vim, handling string parsing and command modifier extraction. CVE-2013-2124 involves a double-free in a virtual disk image inspection library (libguestfs) during file content processing and error handling. The domains (text editor vs. VM management), vulnerability types (parsing logic vs. memory management), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code parses Vim ex-command modifiers from a string buffer. CVE-2013-0339 is an XXE vulnerability in an XML parsing library (libxml2). The attack surfaces (command line vs. XML documents), vulnerability types (parsing logic flaws vs. improper entity restriction), and underlying data structures are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The target code performs string parsing and validation. CVE-2019-11470 is a resource exhaustion vulnerability in an image decoder due to lack of validation between declared dimensions and actual data. Both involve parsing input, but the target code's input is a command string with controlled length, not binary file data. The flaw patterns (logic flow vs. integer overflow/validation) and consequences differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing input (command modifiers vs. IPP attributes) where insufficient validation could lead to injection. However, the target code's `skip_vimgrep_pat` and command validation aim to prevent malformed input, whereas CVE-2017-15400's flaw is direct CRLF injection into a generated file. The vulnerability types (logic error vs. injection) and exploitation contexts are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code manipulates string pointers within a buffer but does not perform dynamic memory allocation based on user input in a way comparable to the glob() function's path expansion. CVE-2017-15670 is a heap buffer overflow due to an off-by-one calculation during memory allocation. The code domains and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Both involve parsing structured input (command strings vs. network packets) and require careful bounds checking. The target code uses pointer arithmetic (`eap->cmd`) and functions like `skip_vimgrep_pat` which must ensure they don't read out of bounds. However, CVE-2017-13033 is a specific out-of-bounds read in binary protocol parsing due to trusting a length field, a pattern not evident in the string-parsing logic shown.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code has no dynamic memory allocation or deallocation (free) operations visible in the provided snippet. It works on a pre-existing command string buffer. CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool related to linked list cleanup. The memory management models are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The target code does not show any dynamic memory management (allocation/free). It parses a command string in-place. CVE-2017-16943 is a use-after-free in an MTA related to complex state management during email processing. The systems and flaw types are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Both involve parsing structured input (command syntax vs. network packets) and managing parser state. The target code uses flags and pointers (`cmod`, `eap->cmd`) to track state, similar to how a flow dissector tracks protocol layers. However, CVE-2017-13715's core flaw is leaving a structure uninitialized on an error path, a specific pattern not clearly mirrored here, though the target code must ensure `cmod` is properly set on all exit paths.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Both involve parsing input and assigning values to internal structures (`cmod` fields vs. `image` fields). The target code performs some validation (e.g., checking `tabnr` range). CVE-2017-9499's flaw is a missing bounds check on an input field leading to an assertion failure. The similarity is in the general \"parse and assign\" pattern, but the specific vulnerability (reachable assertion) and context (image metadata vs. command modifiers) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      }
    ]
  },
  "CVE-2022-2288_after_subset_100:da5b1e72:vulspec": {
    "timestamp": "2026-01-17T03:02:42.142912",
    "cve_id": "CVE-2022-2288",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "da5b1e72",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to file content processing. The target code is a command parser in Vim that handles command modifiers and memory movement (mch_memmove). There is no similarity in vulnerability type (double-free vs. potential parsing logic errors), domain (VM disk inspection vs. text editor command parsing), or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in libxml2. The target code parses command-line modifiers in Vim, not XML. The vulnerability types (improper restriction of XML external entities vs. command parsing), domains (XML parsing vs. editor command-line), and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-11470 is an uncontrolled resource consumption (CWE-400) vulnerability in ImageMagick's image dimension parsing. The target code performs string parsing and memory movement for command modifiers. No similarity in vulnerability type, functionality (image processing vs. command parsing), or code patterns (numeric validation vs. string manipulation).",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-15400 is a CRLF injection/command injection vulnerability in CUPS PPD generation. The target code also parses user input (command modifiers) and performs string operations. There is a superficial similarity in parsing untrusted input, but the vulnerability types differ significantly (injection vs. potential buffer handling issues), and the code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob() due to an off-by-one error. The target code uses mch_memmove for overlapping memory regions when handling visual range modifiers. There is a potential connection in the careful handling of memory movements and pointer arithmetic to avoid buffer issues, but the vulnerability context (path expansion vs. command reordering) and specific flaw (off-by-one allocation vs. overlapping copy) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13033 is an out-of-bounds read in tcpdump's VTP parser. The target code parses command strings with bounds checking via STRNCMP and pointer increments. While both involve parsing, the vulnerability type (OOB read vs. potential logic error), domain (network protocol vs. editor command), and code patterns (binary packet parsing vs. string command parsing) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in radare2's basic block analysis. The target code does not dynamically allocate or free memory in the shown snippet; it mainly moves memory and parses strings. No similarity in vulnerability type, memory management patterns, or functionality.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-16943 is a use-after-free in Exim's SMTP header processing. The target Vim code shows no dynamic memory allocation/deallocation patterns that could lead to UAF. The domains (mail transfer agent vs. text editor) and code patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13715 is an uninitialized memory exposure in the Linux kernel's flow dissector. The target code uses CLEAR_POINTER on a struct and initializes flags. While both involve state initialization, the vulnerability type (information disclosure vs. command parsing logic), context (kernel networking vs. userland editor), and severity are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-9499 is a reachable assertion in ImageMagick due to insufficient input validation. The target code does perform input validation (e.g., checking for valid ranges in the 'tab' modifier case) and error handling. There is a conceptual similarity in validating user-provided numeric parameters (like 'tab' index and 'verbose' level) to prevent invalid states, but the manifestation (assertion crash vs. command error) and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      }
    ]
  },
  "CVE-2022-1055_before_subset_100:f42ad556:vulspec": {
    "timestamp": "2026-01-17T03:03:17.191184",
    "cve_id": "CVE-2022-1055",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f42ad556",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in a userspace library (libguestfs) related to file content processing. The target code is a kernel network subsystem function (tc_new_tfilter) managing filter chains and protocol objects. The domain, language (kernel C vs userspace C), and vulnerability pattern (double-free vs potential race/state management) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 (CVE-2015-5156) is a buffer overflow in a kernel virtio network driver due to incorrect feature declaration and buffer allocation. The target code is also in the kernel networking domain but deals with traffic control filter management, not packet data path processing. Both involve kernel code and resource management, but the specific flaw (buffer overflow vs potential use-after-free/race in chain/tp management) and attack surface differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 3 (CVE-2017-13715) is an uninitialized memory issue in the kernel network flow dissector. The target code is also in the kernel networking stack. Both involve complex state management and error paths. The relevance is higher than other cases because both are in the same subsystem and share the context of careful state initialization and cleanup in error conditions (e.g., the `errout` labels and cleanup logic in the target code). However, the specific vulnerability type differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 (CVE-2017-13033) is an out-of-bounds read in a userspace network protocol analyzer (tcpdump). The target code is kernel-space traffic control configuration. Both process network-related data structures, but the environment (kernel vs userspace), vulnerability pattern (OOB read vs potential concurrency/state bugs), and functionality are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 5 (CVE-2016-0723) is a race condition leading to use-after-free in the kernel tty subsystem. The target code (`tc_new_tfilter`) also manages kernel objects (tcf_proto, tcf_chain) with potential for concurrent access (note the `rtnl_lock/unlock` and `replay` logic). Both involve kernel driver interfaces exposed to userspace (ioctl vs netlink). The pattern of protecting object lifetimes with locks/reference counts is central to both. The main difference is the subsystem (tty vs netfilter/traffic control).",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 (CVE-2016-7425) is a buffer overflow in a kernel SCSI driver due to lack of bounds checking on user input. The target code parses netlink attributes but uses safe interfaces like `nlmsg_parse_deprecated` and `nla_get_u32`. Both are kernel drivers, but the vulnerability pattern (buffer overflow vs state management/concurrency) and domain (storage vs networking) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 (CVE-2017-18257) is an integer overflow leading to an infinite loop in a filesystem (F2FS). The target code performs arithmetic (e.g., `prio = TC_H_MAKE`) but not in a loop context vulnerable to overflow. The domains (filesystem vs network traffic control) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 (CVE-2018-12320) is a use-after-free/double-free in a userspace reverse engineering tool due to improper cleanup of linked structures. The target code manages linked chains (`tcf_chain`) and must carefully handle object insertion/deletion (`tcf_chain_tp_insert_unique`, `tcf_chain_tp_delete_empty`). Both involve complex data structure lifecycle management. The relevance is moderated by the environment difference (userspace vs kernel) and the specific data structures.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 (CVE-2017-16943) is a use-after-free in a userspace MTA (Exim) related to BDAT command and header processing. The target code is kernel networking. Both involve C and memory management, but the domain, attack surface (network packets vs SMTP commands), and overall architecture are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 (CVE-2017-15400) is a CRLF injection/command injection in a userspace printing system (CUPS) due to improper neutralization of IPP attributes. The target code is kernel traffic control parsing netlink messages. Both parse user-provided data, but the vulnerability pattern (injection vs memory corruption/race) and environment are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      }
    ]
  },
  "CVE-2022-1055_after_subset_100:11312ba0:vulspec": {
    "timestamp": "2026-01-17T03:03:22.780955",
    "cve_id": "CVE-2022-1055",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "11312ba0",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a user-space library (libguestfs) related to file content processing. The target code is a kernel-space network traffic control filter management function. The domain (virtualization vs. networking), vulnerability type (double-free vs. potential race/state management), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2015-5156 is a buffer overflow in a kernel network driver (virtio_net) due to incorrect feature declaration and buffer allocation. The target code (`tc_new_tfilter`) is also in the kernel networking subsystem and involves complex state management. However, the specific flaw type (buffer overflow vs. potential race/use-after-free in chain/tp management) and trigger conditions (packet processing vs. netlink command handling) are different. Both deal with kernel networking, providing a weak link.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-13715 is an uninitialized memory issue in the kernel's network flow dissector. The target code is also in the kernel networking stack and involves parsing netlink attributes (`nlmsg_parse_deprecated`). Both deal with network protocol/data parsing in the kernel and require careful state initialization and error handling. The vulnerability type (improper initialization) is a common pitfall in functions like `tc_new_tfilter` that have many local variables and complex paths. This provides some reference value for defensive coding.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-13033 is an out-of-bounds read in a user-space packet analyzer (tcpdump) due to insufficient validation of length fields. The target code is kernel-space and performs validation on user-provided netlink attributes (e.g., checking `chain_index`). While both involve parsing network-related data structures, the context, severity, and specific flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. CVE-2016-0723 is a race condition leading to use-after-free in the kernel tty subsystem. The target code `tc_new_tfilter` has concurrency considerations (uses mutex locks like `filter_chain_lock`, and has a `replay` mechanism for `-EAGAIN`). It manages complex object lifecycles (chains, `tcf_proto` blocks) which could be susceptible to race conditions if locks are not held correctly or reference counting is wrong. The pattern of managing kernel objects accessed via user-controlled commands (ioctl vs. netlink) is similar. This case provides valuable reference for concurrency bug patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7425 is a buffer overflow in a kernel SCSI driver due to lack of bounds checking on user-controlled length. The target code deals with netlink messages and attribute parsing, which includes bounds checking via `nlmsg_parse_deprecated`. The domains (storage vs. networking) and primary flaw mechanisms are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-18257 is an integer overflow leading to an infinite loop in a filesystem (F2FS). The target code performs arithmetic (e.g., priority handling `TC_H_MAKE`, `chain_index` checks) but no obvious integer overflow leading to a loop. The domains and specific flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2018-12320 is a use-after-free/double-free in a user-space analysis tool due to improper cleanup of linked structures. The target code manages linked lists of filters/chains (`tcf_chain`, `tcf_proto`) and has cleanup paths (`errout`, `errout_tp`) that must correctly handle object ownership and reference counting to avoid use-after-free or double-free. The pattern of complex cleanup in error paths is highly relevant. The difference lies in the context (user-space vs. kernel-space memory management).",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-16943 is a use-after-free in a user-space MTA (Exim) related to BDAT command and header processing. The target code is kernel networking. While both involve protocol command processing, the environments and memory management models are too dissimilar for meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection in a user-space printing system (CUPS) due to improper neutralization of IPP attributes. The target code parses netlink attributes but does not generate script/output with embedded sequences. The vulnerability class is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      }
    ]
  },
  "CVE-2022-29340_before_subset_100:41b90a71:vulspec": {
    "timestamp": "2026-01-17T03:03:48.991371",
    "cve_id": "CVE-2022-29340",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "41b90a71",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine disk image inspection library. The target code is an MP4/ISO base media file parser. While both handle file parsing, the vulnerability type (double-free vs. potential integer overflows/out-of-bounds reads), domain (VM disk vs. media containers), and code patterns (explicit memory management errors vs. complex box parsing logic) are fundamentally different. The target code shows careful use of `gf_isom_box_del()` with null assignments, suggesting awareness of double-free risks, but the core flaw and context are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is an uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared dimensions and actual data. The target code parses media file \"boxes\" where a box's declared `size` field is used to allocate memory and seek through the file. There is a similarity in parsing untrusted file headers and using declared sizes for memory/file operations. However, the vulnerability manifestation is different (DoS via allocation vs. potential buffer overflow/integer overflow). The target code uses `gf_isom_parse_root_box` which likely validates sizes, but the pattern of trusting external size fields is a shared risk.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is an XXE vulnerability (CWE-611) in an XML parser. The target code parses a binary container format (ISO base media) with no XML or external entity processing. The domains (structured document vs. binary media), attack surfaces (entity references vs. box size/offsets), and vulnerability classes are completely different. No meaningful reference value for the target code's risks.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a CRLF injection/command injection (CWE-93) in a printing system's PPD file generator. The target code is a media file parser that reads data, with no generation of configuration files or injection of control sequences into output streams. The functionality and vulnerability type are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is a reachable assertion (CWE-617) due to insufficient validation of a numeric field (`number_meta_channels`). The target code reads many numeric fields (box sizes, offsets, track counts) but does not show obvious assertions. The relevance lies in the pattern of parsing numeric values from untrusted files without adequate bounds checking (e.g., `mov->moov->mvhd->timeScale` used for `mov->interleavingTime`, or various list counts). However, the specific trigger (assertion failure) and context (image channels vs. media tracks) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 is an integer overflow (CWE-190) in an ISO9660 parser when calculating file positions. The target code is also a parser for an ISO-derived format (ISO base media file format). It performs numerous arithmetic operations on 64-bit box sizes and offsets (e.g., `totSize += a->size`, `mov->current_top_box_start = ...`). There is a clear similarity in the domain (ISO file structure parsing) and the risk of integer overflows/wraparound when manipulating attacker-controlled size and position values. The reference is valuable for identifying similar risks in the target's size calculations.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a buffer boundary violation (CWE-119) due to incorrect bounds checking in an image library. The target code uses a bitstream reader (`gf_bs_available`, `gf_bs_seek`) which should handle bounds. The connection is indirect: both parse binary data and must ensure operations stay within buffer/file boundaries. However, the flaw mechanism (arithmetic underflow leading to negative `remain`) is not visibly present in the target code, which uses higher-level parsing functions.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is an out-of-bounds read (CWE-125) in an archive parser due to mismatched decompressed size vs. allocated buffer. The target code parses compressed or compacted data structures (e.g., `sample_encryption` parsing via `senc_Parse`, `convert_compact_sample_groups`). While not explicitly shown decompressing data, it handles variable-length data within boxes. The pattern of trusting a declared size from the file before verifying it against actual available data is a relevant parallel. The `senc_Parse` function, in particular, could be a similar risk point if it doesn't validate bounds against the box size.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. While the target code also parses length-prefixed structures (boxes), the context is entirely different (network packets vs. media files). The code patterns differ significantly (direct pointer arithmetic in tcpdump vs. abstracted box parsing functions). The general principle of validating lengths before use is applicable, but the specific vulnerability provides little direct reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is an improper initialization (CWE-665) in a network flow dissector leading to uninitialized memory exposure. The target code initializes structures (e.g., `mov->mdat = NULL`) and uses error paths that set pointers to NULL after deletion. There is no obvious pattern of leaving structures partially initialized on error paths in the shown code. The vulnerability class and domain are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-29340_after_subset_100:c0ccd4ff:vulspec": {
    "timestamp": "2026-01-17T03:04:03.550727",
    "cve_id": "CVE-2022-29340",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c0ccd4ff",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine disk image inspection library. The target code is an MP4/ISO file parser with complex box parsing logic. While both handle file formats, the vulnerability type (double-free vs. potential parsing logic flaws), domain (VM inspection vs. media parsing), and code patterns are fundamentally different. The target code shows careful box deletion and error handling, making the double-free pattern from libguestfs not directly applicable.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 involves uncontrolled resource consumption (CWE-400) in an image parser due to lack of validation between declared dimensions and actual data. The target code parses ISO media boxes where size fields (like `a->size`) are critical. Similar patterns exist: both parse structured binary formats where malicious size values could cause excessive memory allocation or processing loops. However, the specific vulnerability mechanism (dimension validation vs. box size validation) differs, and the target code appears to use the size for seeking/positioning more than for direct allocation.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves XML external entity (XXE) injection (CWE-611) in libxml2. The target code parses binary ISO media boxes, not XML. The attack surfaces (XML documents with entities vs. binary media files), vulnerability types (entity expansion vs. binary parsing flaws), and code patterns are completely different. No XML parsing or entity handling exists in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 involves CRLF injection (CWE-93) leading to command injection in CUPS PPD generation. The target code is a media file parser that doesn't generate configuration files, execute commands, or process text-based protocols. The vulnerability type (injection vs. parsing logic errors) and domain (printing system vs. media library) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 involves a reachable assertion (CWE-617) in ImageMagick due to insufficient validation of numeric input (`number_meta_channels`). The target code has similar patterns: it parses numeric fields from binary boxes (like size, track counts) and uses them for memory operations and list indexing. Both could suffer from integer overflow/underflow or out-of-bounds access if values are malicious. The relevance is moderate because while the validation pattern is similar, the specific assertion failure mechanism isn't directly mirrored in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 6 involves integer overflow (CWE-190) in libarchive's ISO9660 parser when calculating file positions. The target code is also an ISO-based media parser that performs similar operations: calculating positions using `totSize += a->size`, seeking with `gf_bs_seek`, and tracking offsets (`current_top_box_start`). Both handle structured binary formats where malicious size fields could trigger integer overflows in position calculations, leading to out-of-bounds memory access or infinite loops. The code patterns and vulnerability type are highly similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 involves buffer boundary issues (CWE-119) in PHP's GD library due to incorrect bounds checking. The target code has buffer operations through `gf_bs_available` and position tracking, but the primary vulnerability pattern (arithmetic underflow leading to negative `remain`) isn't directly visible. Both involve reading from binary streams, but the target code's bitstream abstraction layer may handle bounds differently. Some relevance exists in the general area of buffer/stream validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 8 involves out-of-bounds read (CWE-125) in ClamAV's XAR parser due to mismatched decompressed size vs. allocated buffer. The target code doesn't show decompression logic but has similar validation patterns: checking `gf_bs_available` before reading, validating box structures, and handling incomplete files. Both parse container formats where size fields must be validated against actual available data. The specific decompression mismatch isn't present, but the size validation principle is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 involves out-of-bounds read (CWE-125) in tcpdump's VTP parser due to insufficient length validation. The target code validates box sizes and available bytes, but the patterns differ: network protocol parsing vs. file format parsing. Both need to validate length fields before accessing data, but the target code's use of a bitstream abstraction with `gf_bs_available` provides some built-in protection. Limited similarity in the general validation requirement.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 involves improper initialization (CWE-665) in Linux kernel's flow dissector leading to uninitialized memory exposure. The target code is user-space media parsing with different memory management patterns. While both parse structured data, the vulnerability type (uninitialized state on error paths vs. parsing logic errors) and context (kernel networking vs. user-space file parsing) are substantially different. The target code shows explicit initialization and cleanup patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-29156_before_subset_100:e71b1c15:vulspec": {
    "timestamp": "2026-01-17T03:04:26.719405",
    "cve_id": "CVE-2022-29156",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e71b1c15",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 is a Use-After-Free (CWE-416) due to incomplete linked structure cleanup. The target code is a simple device release function that frees a containing structure via kfree. The patterns are different: the target code shows no evidence of complex pointer manipulation, linked lists, or the cleanup logic that caused the vulnerability. The only similarity is the presence of a `kfree` call.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 2 is a Double Free (CWE-415). The target code performs a single `kfree` in a release function, which is a common pattern and not inherently flawed. The relevance is limited to the general theme of memory deallocation. The specific trigger conditions (error handling paths, inconsistent state management) and code patterns (complex cleanup logic) are not present in the simple target code.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 3 is a buffer overflow (CWE-119) in a network driver due to incorrect feature negotiation and insufficient buffer allocation. The target code is a memory deallocation routine with no buffer operations, network logic, or input validation. The domains and vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow (CWE-119) in a SCSI driver due to insufficient validation of user-controlled length parameters. The target code performs a simple structure free with no input processing, buffer operations, or length checks. The functional domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is a stack buffer overflow (CWE-119) in a USB driver related to DMA and stack allocation. The target code is a kernel object release function performing heap deallocation (`kfree`). The memory region (stack vs. heap), operation (allocation/overflow vs. deallocation), and context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Read (CWE-125) in a network protocol reassembly function. The target code has no data parsing, reassembly logic, or bounds checking. It is a straightforward destructor with no read operations on external data.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000852"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an information leak (CWE-200) due to copying uninitialized memory to userspace. The target code is a kernel-internal release function that frees memory, with no userspace interaction or data copying. The only tangential connection is that both involve kernel memory management, but the specific flaw patterns are opposites (exposing vs. freeing).",
        "case_metadata": {
          "cve_id": "CVE-2018-20855"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a Race Condition leading to Use-After-Free (CWE-362 -> CWE-416). The target code is a release callback, which could be part of an object's lifetime management. If the `clt` object were accessed after this callback runs, a UAF could occur. The relevance is conceptual (object lifetime/freeing), but the target code itself does not show the concurrency or pointer access patterns that characterize the vulnerability. The trigger conditions are not visible in the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow (CWE-120) in a virtual device emulator due to missing bounds checks on guest-provided descriptors. The target code has no input processing, buffer copying, or guest/host interaction. The domains (virtualization I/O vs. kernel object lifecycle) and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an injection vulnerability (CWE-93) in a printing service due to improper neutralization of CRLF sequences. The target code is a kernel memory deallocation function with no string processing, protocol parsing, or command generation. The flaw categories are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      }
    ]
  },
  "CVE-2022-29156_after_subset_100:01ea2643:vulspec": {
    "timestamp": "2026-01-17T03:05:00.386765",
    "cve_id": "CVE-2022-29156",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "01ea2643",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a Use After Free (CWE-416) in a complex linked structure (basic blocks) due to incomplete cleanup and circular references. The target code is a simple device release function that frees a single structure after destroying mutexes. The patterns, complexity, and root cause are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a Double Free (CWE-415) in a file processing function triggered by error handling paths. The target code performs a single `kfree` in a straightforward cleanup path. While both involve memory deallocation, the target code shows no signs of the complex error handling or ownership ambiguity that led to the double-free vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a buffer overflow (CWE-119) in a network driver due to incorrect feature negotiation and insufficient buffer allocation for fragmented packets. The target code performs no data processing, buffer operations, or network-related functions. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow (CWE-119) in a SCSI driver due to insufficient validation of user-controlled length parameters. The target code contains no input parsing, length validation, or buffer operations. The functional context and vulnerability mechanism are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a stack buffer overflow (CWE-119) in a USB driver related to DMA and stack-allocated buffers. The target code is a high-level cleanup routine with no low-level buffer manipulation, USB operations, or stack-specific concerns. No meaningful similarity exists.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an Out-of-bounds Read (CWE-125) in a network protocol reassembly function. The target code performs no data reassembly, packet processing, or bounds checking. The domains (network protocol vs. device lifecycle management) and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000852"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an Information Exposure (CWE-200) via uninitialized memory disclosure in a driver's user-space interface. The target code does not copy data to userspace and only operates on kernel-internal structures. The vulnerability class and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-20855"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 8 is a Race Condition (CWE-362) leading to Use After Free (CWE-416) in a TTY subsystem due to lack of proper synchronization on a pointer. The target code destroys mutexes (`paths_ev_mutex`, `paths_mutex`) which suggests it manages concurrent access to resources (`paths`). While the target code itself is a simple release function, the presence of these mutexes hints that the broader `rtrs_clt_sess` structure may be subject to concurrency issues. However, the provided snippet does not show the actual race or UAF flaw; it only shows cleanup. The relevance is based on the shared context of managing concurrent access with mutexes, but the specific vulnerability pattern is not present in the snippet.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a buffer overflow (CWE-120) in a virtual device emulator due to missing bounds checking on scatter-gather lists. The target code contains no I/O operations, descriptor processing, or size validation. The functional domains and vulnerability mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an Improper Neutralization (CWE-93) leading to command injection in a printing service. The target code performs no input processing, string manipulation, or command execution. The vulnerability class and code context are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      }
    ]
  },
  "CVE-2022-0847_before_subset_100:2918d08d:vulspec": {
    "timestamp": "2026-01-17T03:05:17.474778",
    "cve_id": "CVE-2022-0847",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2918d08d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file content processing. The target code is a Linux kernel pipe buffer management function with no dynamic memory deallocation or error handling paths that could lead to a double-free. The domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free/double-free (CWE-416) in a userspace reverse engineering tool (radare2) related to linked list cleanup. The target kernel code performs memory allocation (`alloc_page`) and pipe buffer management but does not involve complex linked structure deallocation or the specific memory corruption patterns described.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a buffer overflow (CWE-119) in a kernel SCSI driver due to insufficient length validation. The target code involves buffer management within the pipe ring, but the overflow risk is different. The primary concern in `push_pipe` is correctly managing the ring buffer indices (`iter_head & p_mask`) and ensuring `left` doesn't underflow. While both are kernel code dealing with buffers, the specific vulnerability mechanism (user-controlled length vs. internal state calculation) and subsystem differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an integer overflow/wraparound (CWE-190) leading to an infinite loop in a filesystem. The target code uses `size_t` and `ssize_t` for size/offset calculations and has a loop condition (`while (!pipe_full(...))`). There is a potential, though not immediately obvious, for issues if `left` (a signed `ssize_t`) becomes negative after `left -= buf->len`, but the loop would break on `alloc_page` failure. The similarity is limited to the presence of arithmetic and loops.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is improper initialization (CWE-665) leading to information leak in the network stack. The target code initializes `pipe_buffer` struct fields (`ops`, `page`, `offset`, `len`) explicitly. No similarity in vulnerability type or context.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow (CWE-119) in a network driver due to incorrect fragment count assumption. The target code manages a fixed-size ring buffer (`pipe->bufs`) and uses a mask (`p_mask`) for indexing. The relevance is limited to both being kernel code that must ensure operations stay within the bounds of a pre-allocated array. However, the mechanism (ring buffer wrap-around vs. fragment list overflow) and subsystem are different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a buffer copy without size check (CWE-120) in QEMU virtio. The target code copies data into newly allocated pages, but the size (`buf->len`) is derived from the internal `left` variable and capped at `PAGE_SIZE`. The similarity is superficial (both handle data buffers), but the trust model (kernel internal pipe vs. guest-provided descriptors) and vulnerability pattern differ.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 is a race condition (CWE-362) leading to use-after-free in the kernel TTY subsystem. The target code updates `pipe->head` inside a loop without obvious locking. If `push_pipe` can be called concurrently on the same pipe (depends on caller synchronization), a race on `pipe->head`, `pipe->tail`, or the `pipe->bufs` contents could occur, potentially leading to state corruption. This is the most relevant case so far, as both are in the kernel and involve concurrent access to shared structures. However, the specific object (pipe vs. tty) and the exact flaw pattern (UAF vs. general state corruption) are not identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is a use-after-free (CWE-416) in a userspace MTA (Exim). The target kernel code allocates pages and assigns them to pipe buffers; there is no analogous `store_release()` or shared ownership pattern that could lead to a UAF in this snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a NULL pointer dereference (CWE-476) due to a race condition in kernel page migration. The target code checks `alloc_page` for NULL and breaks the loop, preventing a direct NULL dereference. The contexts (memory migration vs. pipe I/O) and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-3070"
        }
      }
    ]
  },
  "CVE-2022-0847_after_subset_100:5e26539c:vulspec": {
    "timestamp": "2026-01-17T03:05:42.136328",
    "cve_id": "CVE-2022-0847",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "5e26539c",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file content processing. The target code is a Linux kernel pipe buffer management function with no memory deallocation logic, focusing on buffer allocation and page management. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free/double-free (CWE-416) in a userspace reverse engineering tool (radare2) related to linked list cleanup. The target kernel code performs controlled allocation into a ring buffer and does not involve freeing memory or complex pointer manipulation of that nature.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is a buffer overflow (CWE-119) in a kernel SCSI driver due to insufficient length validation. The target code also runs in the kernel and involves buffer management, but its primary operations are bounded by the pipe's ring_size and PAGE_SIZE. It lacks the direct user-controlled length input validation flaw that defines CVE-2016-7425.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is an integer overflow (CWE-190) leading to an infinite loop in a filesystem. The target code uses size_t and ssize_t arithmetic (e.g., `left -= PAGE_SIZE - off`), which has potential for integer wrapping issues if `off > PAGE_SIZE`. However, the context (pipe buffer vs. filesystem block mapping) and the specific trigger conditions (ioctl vs. internal pipe operations) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an improper initialization (CWE-665) leading to information leak in the network stack. The target code initializes pipe_buffer structures (ops, flags, page, offset, len) explicitly. While both involve kernel internal structures, the flaw pattern (uninitialized memory on error path) is not evident in the provided push_pipe function.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a buffer overflow (CWE-119) in a network driver due to incorrect feature declaration and fragment handling. The target code manages a ring buffer of pages, with bounds checking via `iter_head & p_mask`. The relevance is limited to the general concept of managing a bounded buffer, but the mechanisms (ring buffer indices vs. scatter-gather lists) and vulnerability root causes are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is a buffer overflow without size checking (CWE-120) in QEMU's virtio emulation. The target code is kernel-side and does not copy data from userspace or descriptors; it allocates new pages. The common theme is \"buffer management,\" but the attack model (guest-host boundary vs. kernel internal pipe) and code patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a race condition leading to use-after-free (CWE-362/416) in the kernel TTY subsystem. The target code shows no locking or reference counting, but it operates on a local pipe buffer likely under some pipe lock (not shown). The core flaw of concurrent pointer access and free is not directly comparable to the sequential allocation logic in push_pipe.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a use-after-free (CWE-416) in a userspace MTA (Exim) due to incorrect memory ownership during header processing. The target kernel code does not free memory and is not in a userspace application. The domains and memory management models are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a NULL pointer dereference (CWE-476) due to a race condition in kernel page migration. The target code checks for page allocation failure (`if (!page) break;`) and does not dereference a NULL pointer. The contexts (memory migration vs. pipe I/O) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-3070"
        }
      }
    ]
  },
  "CVE-2021-3744_before_subset_100:e9284692:vulspec": {
    "timestamp": "2026-01-17T03:06:07.792499",
    "cve_id": "CVE-2021-3744",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e9284692",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in a user-space library (libguestfs) related to file processing. The target code is a kernel-space cryptographic driver function with complex DMA and scatter-gather list management. The memory management models (kernel DMA workareas vs. user-space malloc/free) and error handling patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 (CVE-2016-7425) is a buffer overflow in a kernel SCSI driver due to insufficient validation of user-controlled length parameters. The target code also performs cryptographic operations in the kernel and handles user-provided data (key, IV, AAD). While both involve kernel drivers and data validation, the specific flaw (length validation leading to heap overflow) and the domain (SCSI vs. crypto accelerator) differ significantly. The target code has explicit length checks (e.g., authsize switch, key_len check).",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 (CVE-2017-13715) involves improper initialization in the kernel network stack leading to information disclosure. The target code has extensive initialization of local structures (e.g., `memset(&op, 0, sizeof(op))`) and manages complex state across multiple steps (GHASH, GCTR, finalize). Both are in the kernel and require careful state management. However, the vulnerability type (uninitialized stack variable in a parser vs. potential logic/state error in a crypto sequence) and attack surface differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 (CVE-2017-15400) is a CRLF injection/command injection vulnerability in a user-space printing daemon (CUPS). The target code is a kernel cryptographic function with no command interpretation or text-based protocol parsing. The domains and vulnerability classes are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 5 (CVE-2013-7459) is an out-of-bounds write in a cryptographic library (pycrypto) due to improper handling of an Initialization Vector (IV) parameter for a mode (ECB/CTR) that shouldn't use one. The target code is also a cryptographic implementation (AES-GCM) that meticulously handles IV (`aes->iv`), key, and data lengths. Both involve the core challenge of securely marshaling user-provided cryptographic parameters into internal data structures. The key similarity is the domain: cryptographic parameter validation and buffer copying. The difference is the specific flaw (OOB write due to wrong mode) and environment (user-space lib vs. kernel driver).",
        "case_metadata": {
          "cve_id": "CVE-2013-7459"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 (CVE-2017-18257) is an integer overflow leading to an infinite loop in a filesystem (F2FS) block mapping function. The target code performs cryptographic operations and uses integer variables for lengths (e.g., `aes->aad_len`, `ilen`, `authsize`), but there is no evident complex arithmetic that could wrap around. The primary operations are data movement and hardware command submission, not block index calculations.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 (CVE-2016-8670) is a buffer overflow in an image processing library due to incorrect bounds checking involving arithmetic underflow. The target code performs bounds checking (e.g., `authsize` switch, scatterwalk operations) and uses the `ccp_init_data` and `ccp_prepare_data` functions which likely contain internal length checks. Both involve processing variable-length user data, but the mechanism (GD library buffer management vs. kernel DMA scatter-gather) and the specific arithmetic flaw are not directly comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 (CVE-2015-5156) is a buffer overflow in a kernel virtio driver due to mismatched feature negotiation and insufficient buffer allocation for fragmented packets. The target code is also a kernel driver (CCP crypto accelerator) that manages complex data transfers using scatter-gather lists (`scatterwalk_ffwd`). Both require careful calculation of data segments and buffer sizes. The relevance lies in the kernel driver paradigm and the need to correctly partition user-provided data buffers (AAD, plaintext, ciphertext, tag). The flaw type (feature mismatch leading to overflow) is less relevant.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 (CVE-2018-12320) is a use-after-free/double-free in a reverse engineering tool due to improper cleanup of linked data structures. The target code uses linear, owned DMA workareas (`ccp_dm_workarea`) and data descriptors that are explicitly allocated and freed in a strict, linear cleanup path (`e_tag`, `e_dst`, etc.). There are no shared or linked structures that could cause a UAF scenario.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 10 (CVE-2016-10154) is a kernel crypto API misuse vulnerability in the CIFS driver, where a scatterlist is incorrectly set up to point to stack memory, causing issues with virtually-mapped stacks. The target code is a kernel crypto driver that heavily uses the kernel crypto API patterns, scatterlists (`sg_inp`, `sg_tag`, `sg_outp`), and DMA mappings (`ccp_init_data`, `ccp_init_dm_workarea`). Both involve the critical task of correctly interfacing user/kernel data with the kernel's cryptographic subsystem, managing memory types (system vs. DMA), and ensuring scatterlist integrity. The specific flaw (stack memory in scatterlist) is a potent reminder of the pitfalls in this domain, making this case highly relevant for understanding the attack surface and secure design of the target code.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2021-3744_after_subset_100:dcdc7b28:vulspec": {
    "timestamp": "2026-01-17T03:06:17.424820",
    "cve_id": "CVE-2021-3744",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "dcdc7b28",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 is a double-free vulnerability in a user-space library (libguestfs) related to file content processing. The target code is a kernel-space cryptographic driver function with careful, linear error handling (goto chain) that frees resources only once. The memory management patterns and context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in a SCSI driver due to insufficient validation of user-controlled length parameters. The target code performs cryptographic operations with internal buffer management (ccp_dm_workarea). While both involve DMA/device communication, the flaw pattern (missing bounds check on external input vs. controlled internal data flows) and attack surface (SCSI commands vs. crypto API parameters) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 involves improper initialization leading to information disclosure in a network packet parser. The target code also initializes structures (memset & op) and handles multiple operational steps. The relevance lies in the pattern of complex state management across multiple steps (AAD, GCTR, finalize) where an error or uninitialized field could potentially leak data. However, the vulnerability type (CWE-665 vs. crypto logic) and context differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a CRLF injection/command injection vulnerability in a user-space printing service (CUPS) during PPD file generation. The target code is a kernel crypto driver performing AES-GCM operations with no command or text formatting involved. No meaningful similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 5 is an out-of-bounds write in a cryptographic library (pycrypto) due to improper handling of an Initialization Vector (IV) for a mode (ECB/CTR) that shouldn't use one. The target code is a cryptographic driver implementing AES-GCM, which critically depends on correct IV handling (96-bit IV + 32-bit nonce). Both involve core cryptographic parameter validation (key length, IV length, authsize). The pattern of copying IV data (ccp_set_dm_area) and the potential for misuse if parameters are malformed or modes are confused is highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-7459"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an integer overflow leading to an infinite loop in a filesystem (F2FS). The target code performs arithmetic on lengths (aad_len, src_len, authsize, ilen) for buffer offsets and scatterlist operations. There is a superficial similarity in performing calculations on user-influenced sizes, but the target code's operations (e.g., `scatterwalk_ffwd`, `ilen = aes->src_len - authsize`) are less complex and the consequence (crypto failure vs. denial-of-service loop) is different. The vulnerability type (CWE-190) is not strongly indicated in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a buffer overflow in an image library due to incorrect bounds checking involving arithmetic underflow. The target code manages data via scatterlists and DMA work areas with explicit size parameters. While both involve moving data chunks (AES_BLOCK_SIZE), the target code uses well-bounded loops and the `ccp_prepare_data`/`ccp_process_data` abstraction. The low-level arithmetic flaw pattern is not evident here.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a buffer overflow in a network driver due to incorrect feature declaration leading to insufficient buffer allocation. The target code is also a kernel driver managing data buffers (scatterlists, DMA areas). The relevance is in the pattern of managing data transfer between different memory representations (scatterlist, DMA workarea, SB memory). However, the specific flaw (feature negotiation mismatch) and context (network packets vs. crypto blocks) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a use-after-free/double-free in a reverse engineering tool due to circular linked list references. The target code uses simple linear resource management with a clear goto chain for error cleanup (e_key, e_ctx, etc.). There are no complex pointer structures or reference cycles being managed. The memory safety patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. Case 10 is a buffer misuse vulnerability in a kernel crypto module (CIFS encryption) where a scatterlist points to stack memory, problematic with VMAP_STACK. The target code is also a kernel crypto module (CCP) that extensively uses scatterlists (`sg_inp`, `sg_tag`, `sg_outp`), DMA work areas, and the kernel crypto API patterns. The handling of cryptographic data via scatterlists and the potential for misalignment between memory assumptions and actual physical layout is a relevant area for comparison, though the specific flaw (stack memory in scatterlist) is not present in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-10154"
        }
      }
    ]
  },
  "CVE-2022-1205_before_subset_100:9b4c1879:vulspec": {
    "timestamp": "2026-01-17T03:06:40.923133",
    "cve_id": "CVE-2022-1205",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9b4c1879",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file processing. The target code is a kernel socket release function with complex state-based cleanup. Both involve resource cleanup, but the domain (kernel vs userspace), vulnerability pattern (state machine vs double-free), and context are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow (CWE-119) in a USB network driver related to DMA and stack buffers. The target code is a protocol state machine for socket release with no buffer operations. The only similarity is they are both in the Linux kernel network subsystem, but the flaw nature and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 3 is a use-after-free/double-free (CWE-416) in a linked structure cleanup within radare2. The target code also performs complex cleanup of a socket/connection object (`ax25_cb`) with multiple states and potential references (`sock_hold`, `sock_put`). Both involve the risk of improper object lifecycle management during deallocation in a stateful context, though the specific patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow (CWE-119) in a SCSI driver due to missing length validation. The target code performs control flow and state-based cleanup with no array or buffer operations. The domains (storage vs networking) and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an XML external entity (XXE) vulnerability (CWE-611) in a parsing library. The target code is a kernel socket release routine. There is no functional or vulnerability pattern overlap.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow (CWE-119) in a virtio network driver due to incorrect feature negotiation. The target code is also in the kernel networking layer but deals with connection teardown logic, not packet processing or buffer management. The vulnerability mechanisms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 7 is an infinite loop (CWE-835) in a kernel datagram receive function due to improper handling of a zero-length packet with MSG_PEEK. The target code has a complex switch-case state machine during socket release. While the flaws are different, both are in the kernel networking subsystem and involve careful handling of socket states and flags to avoid unexpected behavior (e.g., the `SOCK_DESTROY` flag check in the target). The relevance is in the domain and the need for robust state handling.",
        "case_metadata": {
          "cve_id": "CVE-2013-0290"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an integer overflow (CWE-190) leading to a heap overflow in a userspace AMQP library. The target code performs arithmetic-free state cleanup. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 9 is a use-after-free (CWE-416) in Exim due to improper memory ownership tracking during message processing. The target code manages the lifetime of a kernel socket (`ax25`) and its associated device (`ax25_dev`), using reference counting (`sock_hold`, `sock_put`, `dev_put_track`). Both involve the critical task of ensuring an object is not freed while still being used, especially during cleanup paths with multiple references. The context differs (kernel vs MTA), but the core memory safety concern is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Case 10 is a race condition (CWE-362) leading to use-after-free (CWE-416) in the kernel tty subsystem due to missing locks/reference counting on a shared pointer (`tty->ldisc`). The target code uses `lock_sock()`/`release_sock()` to protect the socket (`sk`) and its associated `ax25` control block during the teardown state machine. Both are kernel subsystems protecting shared objects during concurrent operations. The pattern of taking a lock, manipulating state, and releasing the lock is central to both. The target code also uses `sock_hold`/`sock_put` for reference counting, analogous to the missing protection in Case 10. The vulnerability type and defensive code patterns are highly relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      }
    ]
  },
  "CVE-2022-1205_after_subset_100:08210d40:vulspec": {
    "timestamp": "2026-01-17T03:07:07.962471",
    "cve_id": "CVE-2022-1205",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "08210d40",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file content processing. The target code is a kernel socket release function with timer cleanup. Both involve resource cleanup, but the domain (userspace vs kernel), vulnerability type (double-free vs potential use-after-free/race), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow (CWE-119) in a USB network driver related to DMA and stack buffers. The target code is a protocol state machine cleanup function. Both are in the Linux kernel, but the vulnerability type (memory corruption vs state/timer management), attack surface (USB device vs local socket), and code logic are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is a use-after-free (CWE-416) leading to double-free in a data structure cleanup function (r_anal_bb_free). The target code (ax25_release) also performs complex cleanup of a socket structure, managing timers and state transitions. Both involve the careful teardown of interconnected resources where improper ordering or missing checks could lead to use-after-free or double-free. The pattern of cleaning up a structured object with multiple components is similar, though the context (kernel networking vs userspace analysis library) differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a buffer overflow (CWE-119) in a SCSI driver due to insufficient length validation. The target code performs no buffer copies or length calculations; it's purely a state-driven cleanup routine. The vulnerability types and code patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is an XML external entity (XXE) vulnerability (CWE-611) in a parsing library. The target code is a kernel networking function. There is no overlap in functionality, vulnerability type, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow (CWE-119) in a network driver due to incorrect feature negotiation and fragment handling. The target code is also in kernel networking and involves socket state. However, the core flaw (buffer size miscalculation vs state/timer cleanup) and the code's operational focus (data path vs control path teardown) are different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is an infinite loop (CWE-835) in a datagram receive function due to improper input validation. The target code is a release function with no loops that depend on external input in a similar way. Both are in the kernel networking subsystem, but the vulnerability pattern (logic flaw causing hang vs resource management flaw causing memory corruption) is different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0290"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an integer overflow (CWE-190) leading to a heap overflow in a protocol library. The target code performs no arithmetic on sizes from untrusted sources. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a use-after-free (CWE-416) in a mail server due to improper memory ownership tracking during a multi-step processing and cleanup routine. The target code similarly manages the lifecycle of a complex object (ax25_cb) with multiple components (timers, device reference) and must ensure cleanup actions are performed in the correct order and state. The pattern of releasing resources that may have shared or lingering references is conceptually similar, though the implementation context differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 10 is a race condition (CWE-362) leading to use-after-free (CWE-416) in a kernel subsystem release path (tty line discipline). The target code is also a kernel release function (ax25_release) that manages resources (timers, device reference) and state. Both functions are called when a file descriptor is closed and must handle concurrent operations safely. The pattern of cleaning up resources without adequate locking or reference counting against concurrent access is highly similar. The specific issue in Case 10 (missing lock on ldisc pointer) is analogous to potential issues in the target code if, for example, the ax25 state or ax25_dev pointer were accessed unsafely. This provides valuable reference for auditing concurrency bugs in release paths.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      }
    ]
  },
  "CVE-2022-0213_before_subset_100:87107975:vulspec": {
    "timestamp": "2026-01-17T03:07:23.450582",
    "cve_id": "CVE-2022-0213",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "87107975",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to file content processing and error handling. The target code is a status line redraw function in a text editor (likely Vim) with no dynamic memory allocation/deallocation in the shown path. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection in CUPS PPD file generation. The target code performs screen rendering and string formatting for a status line, with no command execution, protocol parsing, or injection of control characters into a command stream. The domains and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-11470 is an uncontrolled resource consumption (CWE-400) issue in an image decoder due to lack of validation between declared dimensions and data size. The target code does handle string lengths and buffer bounds (MAXPATHL), but its primary purpose is UI rendering, not parsing untrusted file formats. The risk profile and attack surface (local UI vs. file parsing) are different, though both involve bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE (XML External Entity) vulnerability in libxml2. The target code has no XML parsing, entity resolution, or network resource fetching functionality. The vulnerability classes are completely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13033 is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code performs string manipulation and screen output, using functions like `vim_snprintf` with MAXPATHL bounds and checking string lengths. While both involve ensuring operations stay within bounds, the context (network packet parsing vs. UI string formatting) and specific flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2016-0723 is a race condition leading to use-after-free in the Linux kernel TTY subsystem. The target code uses a `static int busy` flag as a simple recursion guard, which is not a robust synchronization mechanism and could theoretically be susceptible to race conditions in a multi-threaded context (though Vim is historically single-threaded). The similarity is superficial; the target code's flag prevents recursion, not concurrent access from multiple threads.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-7425 is a buffer overflow in a kernel SCSI driver due to insufficient validation of length parameters. The target code uses fixed-size buffers (NameBuff, MAXPATHL) and calculates lengths with `vim_snprintf`, which provides bounds checking. There is a pattern of writing to `p + len` within MAXPATHL, which requires careful length accounting. While both involve buffer management, the target code uses safer string functions and the context is less exposed (local UI vs. kernel driver).",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2016-8670 is a buffer overflow in PHP's GD library due to incorrect bounds checking involving arithmetic underflow. The target code performs arithmetic on lengths and indices (e.g., `this_ru_col - 1`, `len - (this_ru_col - 1)`). If `this_ru_col` could be zero or negative, similar underflow/overflow issues could arise in pointer arithmetic (`p += len - (this_ru_col - 1)`) or loop conditions. The code pattern of calculating offsets and bounds has conceptual similarity, though the specific vulnerability mechanism is not immediately evident in the target.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob due to an off-by-one allocation error. The target code does not perform dynamic memory allocation; it operates on stack buffers and screen memory. While both involve string processing, the memory management model and flaw type are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in radare2 due to improper cleanup of linked structures. The target code has no dynamic data structures, pointers, or manual memory management that could lead to such issues. The code patterns are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      }
    ]
  },
  "CVE-2022-0213_after_subset_100:46ada946:vulspec": {
    "timestamp": "2026-01-17T03:08:01.403891",
    "cve_id": "CVE-2022-0213",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "46ada946",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk inspection library due to memory ownership issues during error handling. The target code is a status line redraw function in a text editor (Vim/Neovim) with no dynamic memory allocation/deallocation in the shown path, focusing on screen buffer operations and string formatting.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in a printing system's PPD file generation. The target code performs status line display rendering, involving string formatting with `vim_snprintf` but no command execution, network input, or CRLF sequence handling that could lead to injection.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is a resource exhaustion vulnerability in an image parser due to unvalidated dimensions leading to huge allocations. The target code has fixed-size buffers (`NameBuff`, `MAXPATHL`) and performs bounded string operations. While both process external data (buffer name), the risk profile and validation patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability in an XML parser. The target code does not parse XML or handle external entities. It deals with displaying status information for an editor window.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 5 is an out-of-bounds read in a network protocol dissector due to insufficient length validation. The target code performs bounds checking (e.g., `len < MAXPATHL - 1`, `MAXPATHL - len` in `vim_snprintf`) and uses safe string functions. Both involve input processing, but the domain (network packets vs. internal editor state) and vulnerability type differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a race condition leading to use-after-free in a kernel TTY subsystem. The target code uses a `static` `busy` flag as a simple recursion/rentrancy guard, which is a form of state synchronization. However, the mechanisms (user-space flag vs. kernel locking), concurrency scope (single-threaded editor redraw vs. multi-process kernel driver), and vulnerability severity are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is a buffer overflow in a kernel SCSI driver due to missing length validation. The target code uses bounded operations with `MAXPATHL` and `vim_snprintf`. Both involve copying data, but the target code's buffers are fixed-size and checks are present, reducing overflow risk.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a buffer handling vulnerability in an image library due to incorrect bounds check (arithmetic underflow). The target code performs arithmetic for string length and display positioning (`this_ru_col`, `clen`, `len`). There is a potential for miscalculation in display logic (e.g., `this_ru_col` derivation, pointer adjustments for multi-byte strings) that could lead to display corruption or, in a worst-case scenario, buffer issues if `screen_puts`/`screen_fill` lack proper bounds. The connection is indirect.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a heap buffer overflow in a library's path expansion due to an off-by-one allocation error. The target code does not perform dynamic memory allocation based on calculated lengths; it uses stack buffers and safe string functions.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a use-after-free/double-free in a reverse engineering tool due to improper linked list cleanup. The target code has no dynamic data structures (like linked lists) being freed in this function. Its state is managed via window pointers and static variables.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      }
    ]
  },
  "CVE-2022-1212_before_subset_100:dc7ada28:vulspec": {
    "timestamp": "2026-01-17T03:08:16.487787",
    "cve_id": "CVE-2022-1212",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "dc7ada28",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free vulnerability in radare2's basic block analysis involving circular linked list cleanup. The target code is mruby's VM bytecode interpreter, which handles stack operations, method dispatch, and exception handling. The memory management patterns (arena-based GC with explicit save/restore) and control structures are fundamentally different. No similar linked list manipulation or deallocation logic exists.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free in libguestfs's file reading function due to error handling path issues. The target mruby VM uses a conservative garbage collector with arena management (mrb_gc_arena_save/restore) and doesn't have manual free() calls. Memory ownership is managed by the GC, not direct malloc/free pairs. The error handling in the VM uses setjmp/longjmp (MRB_TRY/MRB_CATCH) for exceptions, not conditional free() calls.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in libxml2's external entity processing. The target code is a Ruby VM interpreter that executes bytecode, with no XML parsing functionality. The vulnerability patterns (external resource resolution, entity expansion) don't apply to VM instruction dispatch, stack operations, or method calling.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-15670 is a heap buffer overflow in glibc's glob() due to off-by-one allocation. The target mruby VM has potential for integer overflows in array/string operations (e.g., OP_ARRAY, OP_STRING) when processing pool values, but uses different memory patterns. Some similarity exists in bounds calculation for data structures, but the VM's pool access is mostly through validated indices rather than raw pointer arithmetic.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-18609 is an integer overflow leading to buffer overflow in AMQP frame parsing. The target VM has several integer operations (OP_ADD, OP_SUB, OP_MUL) with overflow checks (L_INT_OVERFLOW), and array/string operations that could potentially have similar issues if pool indices or sizes are corrupted. However, the VM uses bounded register access and validated irep structures, reducing direct similarity.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-5418 is a path validation/hardlink issue in libarchive during extraction. The target code is a VM interpreter with no filesystem operations. While the VM has symbol table access (OP_LOADSYM, OP_GETGV) and could have validation issues, the domain (filesystem vs. bytecode execution) and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2018-1000085 is an out-of-bounds read in ClamAV's XAR parser due to decompressed size mismatch. The target VM reads from constant pools (irep->pool) with type checking, which could have similar validation issues if pool indices are corrupted. However, the VM's data structures are more structured than raw buffer parsing, and bounds checking is implicit through array access rather than direct pointer arithmetic.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-11470 is a resource exhaustion issue in ImageMagick's Cineon parser due to unvalidated dimensions. The target VM has array creation operations (OP_ARRAY, OP_HASH) that allocate based on operand values, which could lead to similar DoS if attacker-controlled bytecode specifies large sizes. However, the VM runs pre-compiled bytecode, not direct file parsing, making exploitation less direct.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-16943 is a use-after-free in Exim's header processing during BDAT commands. The target mruby VM uses garbage collection with write barriers (mrb_write_barrier) and arena management, not manual memory management. While there are complex object relationships (procs, environments), the memory model is fundamentally different from malloc/free-based systems.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13033 is an out-of-bounds read in tcpdump's VTP parser due to insufficient TLV length validation. The target VM has similar patterns when reading from symbol tables (syms[b]) and constant pools (pool[b]), where invalid indices could cause OOB reads. However, the VM typically validates through array bounds rather than raw pointer offsets, and the domain (network protocol parsing vs. VM execution) differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2022-1212_after_subset_100:7ab655a2:vulspec": {
    "timestamp": "2026-01-17T03:08:31.964955",
    "cve_id": "CVE-2022-1212",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "7ab655a2",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-12320 is a use-after-free/double-free in a linked structure cleanup within a binary analysis tool. The target code is a Ruby VM bytecode interpreter with complex control flow but no direct linked list management or similar memory ownership patterns. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2013-2124 is a double-free in a file reading utility due to error handling. The target code is a VM interpreter with its own memory management (GC arena) and error handling via exceptions/longjmps. The resource management models (manual malloc/free vs. GC) and flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code does not parse XML or handle external entities. The domain (language VM vs. document parser) and vulnerability class (logic/trust vs. memory/parsing) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-15670 is a heap buffer overflow due to an off-by-one allocation in a path expansion function. The target code performs many array/stack operations (e.g., `regs[a]` accesses) where bounds checking is implicit via VM structure sizes. While both involve buffer management, the context (system library vs. managed VM stack) and flaw mechanism (calculation error vs. missing validation) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-18609 is an integer overflow leading to undersized buffer allocation in a network protocol library. The target code has integer handling (e.g., `OP_LOADL` with `IREP_TT_INT64` and overflow check to `L_INT_OVERFLOW`). The pattern of validating integer values from external data (pool values) before use is conceptually similar, but the execution context (network frame vs. bytecode constant pool) and consequences differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-5418 is a path validation issue in an archive extraction library. The target code does not process filesystem paths. The vulnerability class (input validation/race condition) is not applicable to the VM's core interpreter loop.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2018-1000085 is an out-of-bounds read due to size mismatch between declared and actual decompressed data. The target code reads bytecode and pool values from trusted IR structures. While both involve parsing structured data, the trust model is different (untrusted file format vs. compiled bytecode). However, the general principle of validating sizes/offsets when reading structured data is a relevant security consideration for the VM.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2019-11470 is an uncontrolled resource consumption (memory) due to unvalidated image dimensions. The target VM allocates stack space based on `irep->nregs` and could theoretically be exploited if an attacker can craft a malicious `.irep` with huge `nregs` or other fields leading to excessive allocation. The pattern of allocating resources based on untrusted input without validation is a relevant concern for a VM interpreter, though the specific code shown does not obviously lack such checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-16943 is a use-after-free in an MTA due to complex state management. The target code uses a garbage collector and arenas (`mrb_gc_arena_save/restore`), which is a different memory management paradigm. While the VM manages complex state, the specific flaw pattern of manual free/release errors is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13033 is an out-of-bounds read in a network protocol parser due to insufficient length validation. The target code reads opcodes and operands from the `pc` stream and accesses the `pool` and `syms` arrays with indices (`b`, `c`). If these indices are not properly bounded by `irep->pool_size` or `irep->syms_size`, similar OOB reads could occur. The pattern of indexing into arrays with data-derived indices is present, but the trust level of the bytecode and the presence of bounds checks are not clear from the snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2018-13441_before_subset_100:91f4894b:vulspec": {
    "timestamp": "2026-01-17T03:08:52.070304",
    "cve_id": "CVE-2018-13441",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "91f4894b",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs simple string comparison and output formatting with no dynamic memory allocation or deallocation. CVE-2013-2124 involves a complex double-free vulnerability in file content processing with intricate memory ownership issues. The functional domains (network help system vs. VM disk image inspection) and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code handles simple string commands for a help system, with no parsing of structured data formats, no entity resolution, and no external resource fetching. The attack surfaces and vulnerability mechanisms are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-15670 is a heap buffer overflow in pathname expansion due to an off-by-one allocation error. The target code uses fixed format strings and simple string operations with no path manipulation, pattern expansion, or dynamic buffer allocation based on user input size. The code patterns and vulnerability triggers are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-15400 involves CRLF injection leading to command injection in a printer configuration system. The target code uses nsock_printf to send formatted output over a socket. While both involve output generation, the target code does not generate configuration files, execute commands, or have a CRLF injection vector that could alter protocol semantics. The similarity is very weak.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-13033 is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code operates on a null-terminated string buffer (`buf`) passed as an argument, performing only string comparisons and calling other functions. There is no parsing of binary structures, no length field validation, and no array/index operations that could lead to out-of-bounds reads.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2019-11470 is a resource exhaustion vulnerability in an image decoder due to unchecked dimensions leading to huge allocations. The target code performs trivial string operations and function calls with no memory allocation based on user input. The resource consumption profile and code patterns are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7425 is a buffer overflow in a kernel SCSI driver due to missing validation of a user-controlled length parameter before a copy operation. The target code does not copy user data into fixed-size buffers, does not perform any arithmetic on lengths, and does not interact with hardware or kernel memory. The contexts and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool due to improper cleanup of linked data structures. The target code has no dynamic data structures (like linked lists it manages), no manual memory management (it uses string literals and passes a buffer pointer), and no `free()` operations. The memory safety issue is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-18257 is an integer overflow leading to an infinite loop in a filesystem block mapping function. The target code contains no arithmetic operations, no loops based on calculated values (only a simple iterator over a linked list), and no block or size calculations. The vulnerability class and code constructs are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-12994 is an out-of-bounds read in a BGP protocol parser due to insufficient bounds checking on TLV length fields. Similar to case 5, the target code does not parse binary protocol data with length fields. It treats its input as a null-terminated string for display and lookup. The parsing complexity and vulnerability mechanism are not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      }
    ]
  },
  "CVE-2018-13441_after_subset_100:b40096f9:vulspec": {
    "timestamp": "2026-01-17T03:09:01.458398",
    "cve_id": "CVE-2018-13441",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b40096f9",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory corruption vulnerability in a file processing library. The target code is a simple help command handler that performs string comparisons and prints output. There are no dynamic memory allocations, pointer manipulations, or error paths that could lead to double-free conditions.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parser. The target code handles simple string commands and has no XML parsing functionality, no external entity processing, and no file/network resource loading based on user input.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a heap buffer overflow in path expansion. The target code performs basic string operations with fixed format strings and no path manipulation, pattern expansion, or memory allocation based on user-controlled size calculations.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 involves CRLF injection leading to command injection. The target code uses user-controlled input (`buf`) in format strings for `nsock_printf_nul`, which could potentially be relevant for format string vulnerabilities, but there's no evidence of command execution or CRLF handling. The connection is very indirect.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read in network packet parsing. The target code handles simple command strings with no binary data parsing, no length field validation, and no complex data structure traversal that could lead to bounds violations.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 involves uncontrolled resource consumption through malicious image dimensions. The target code performs trivial string operations with no resource allocation based on user input, no file parsing, and no dimension calculations.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow in a SCSI driver. The target code has no buffer operations, no length validation issues, and handles only string commands with no low-level memory manipulation or device driver functionality.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free/double-free in a reverse engineering tool. The target code contains no dynamic memory management, no pointer manipulation, and no complex data structure cleanup that could lead to memory corruption issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves integer overflow in a filesystem driver. The target code performs only string comparisons and printing with no arithmetic operations, no size calculations, and no loop conditions based on user-controlled values.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in BGP packet parsing. The target code handles simple help commands with no protocol parsing, no TLV processing, and no binary data handling that could lead to bounds checking issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      }
    ]
  },
  "CVE-2021-37661_before_subset_100:dd98f04c:vulspec": {
    "timestamp": "2026-01-17T03:09:42.019079",
    "cve_id": "CVE-2021-37661",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "dd98f04c",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine disk image library due to improper cleanup during error handling. The target code is a TensorFlow kernel constructor performing resource creation and validation. There is no dynamic memory deallocation, pointer manipulation, or similar error-handling paths that could lead to a double-free. The functional domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves CRLF injection (CWE-93) leading to command injection in a printing system's PPD file generation. The target code performs numeric input validation and resource creation. There is no string parsing, command generation, or output of user-controlled data. The vulnerability type and attack surface are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves improper input validation (CWE-20) of archive file paths leading to filesystem issues. The target code also performs input validation (checking epsilon > 0). However, the similarity is superficial. The target validation is a simple numeric bound check to prevent performance issues, not a security boundary check for path traversal or symlink attacks. The context, impact, and flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a use-after-free (CWE-416) in a reverse engineering framework due to improper linked list cleanup. The target code allocates a new resource object and registers it. There is no complex data structure traversal, manual pointer management, or deallocation logic that could lead to a use-after-free or double-free scenario. The memory management patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 involves a reachable assertion (CWE-617) due to insufficient validation of a numeric input field (`number_meta_channels`). The target code validates that `epsilon > 0`. Both involve validating numeric inputs to prevent erroneous states. However, the target's check is a direct inequality to avoid a \"performance issue,\" not a security-critical bound check to prevent a crash or overflow. The trigger condition (assertion vs. error return) and potential impact differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 involves uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code uses input values (`epsilon`, `num_streams`, `max_elements_`) to initialize a `QuantileStreamResource`. If `num_streams` or `max_elements_` were extremely large and unvalidated, it could lead to excessive memory allocation. The code shows validation for `epsilon` but not for `num_streams`. The pattern of allocating resources based on user inputs without validation is similar, but the specific flaw and context (image parsing vs. stream resource creation) differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an information leak (CWE-200) due to copying uninitialized kernel stack memory to userspace. The target code is user-space TensorFlow code performing resource management. There is no interaction with kernel interfaces, copying of structures to userspace, or risk of exposing uninitialized memory. The vulnerability class and environment are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-20855"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 involves XXE (CWE-611) in an XML parser. The target code does not parse any structured data formats like XML. It reads simple scalar numeric inputs. There is no entity expansion, external resource fetching, or similar parsing complexity. The domains are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 involves an integer overflow (CWE-190) in a filesystem block calculation leading to an infinite loop. The target code uses `int64_t` for `num_streams`. If `num_streams` were maliciously large and used in a calculation (e.g., `num_streams * sizeof(something)`), it could overflow. However, the provided code snippet does not show such a calculation. The potential for integer misuse exists if the resource constructor performs arithmetic, but the visible code does not demonstrate this flaw pattern directly.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a use-after-free (CWE-416) in a mail server due to incorrect reference counting during header processing. The target code uses `new` and a `CreateResource` function, suggesting managed resource handling (possibly reference-counted). However, the code path shown is straightforward creation and registration, with no complex ownership transfers or early releases that could cause a use-after-free. The memory management model is likely different and safer.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      }
    ]
  },
  "CVE-2021-37661_after_subset_100:4fde71e8:vulspec": {
    "timestamp": "2026-01-17T03:10:07.067397",
    "cve_id": "CVE-2021-37661",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4fde71e8",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs resource creation and management (QuantileStreamResource) with error checking, but there is no indication of double-free or complex memory ownership issues. The historical case involves a double-free during error handling in file processing, which is a different context and flaw pattern.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code performs basic input validation (epsilon > 0, num_streams >= 0) and resource creation. Case 2 involves CRLF sequence injection and command injection during PPD file generation, which is completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve input validation (target validates epsilon and num_streams; libarchive validates paths). However, the target's validation is simple scalar checks, while the historical case involves complex path validation leading to filesystem race conditions. The vulnerability types (CWE-20 vs. resource management) and contexts are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code creates a new resource and handles the \"ALREADY_EXISTS\" status, but there is no indication of linked data structures, circular references, or use-after-free/double-free during deallocation. The historical case is specifically about improper cleanup of linked structures in a reverse engineering context.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Both involve input validation of numeric parameters. The target code validates `epsilon > 0` and `num_streams >= 0`. Case 5 involves a missing validation of `number_meta_channels` against `MaxPixelChannels`, leading to an assertion failure. The similarity is in the pattern of checking input bounds, but the consequences (assertion failure vs. potential resource creation error) and domains differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve validation of user-provided numeric inputs that could affect resource allocation. The target validates `num_streams` (could influence internal allocation) and `epsilon`. Case 6 involves a lack of validation between image dimensions and file size, leading to uncontrolled memory consumption. The connection is indirect: both check inputs to prevent problematic states, but the flaw patterns (missing validation leading to DoS vs. enforced validation) are opposites.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "No relevance. The target code initializes a new resource object with user-provided parameters. Case 7 involves information exposure through uninitialized memory copied to userspace. There is no similarity in vulnerability type or code pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-20855"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. The target code does not parse complex structured data like XML or handle external entities. The validation is on simple scalar inputs. The vulnerability types are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve integer inputs from userspace (`num_streams` is int64_t). The target validates it is non-negative. Case 9 involves an integer overflow in block size calculation leading to an infinite loop. The similarity is limited to the presence of integer inputs; the target performs a simple bound check, while the historical case has a missing check for arithmetic overflow.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code creates a resource and handles a potential \"ALREADY_EXISTS\" error. Case 10 involves a use-after-free due to improper memory ownership tracking during email header processing. There is no memory deallocation or reference counting shown in the target code snippet that would suggest a similar flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      }
    ]
  },
  "CVE-2022-24793_before_subset_100:bae17b54:vulspec": {
    "timestamp": "2026-01-17T03:10:24.272319",
    "cve_id": "CVE-2022-24793",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bae17b54",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine disk image inspection system. The target code is a DNS query parser performing memory allocation and data copying with no free operations or complex error handling paths that could lead to double-free. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 is an out-of-bounds read (CWE-125) in a network packet parser (tcpdump VTP). The target code also parses network data (DNS) and performs memory copies (pj_memcpy) based on calculated lengths. Both involve parsing untrusted network input with potential for insufficient bounds validation, though the specific validation flaws differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 involves improper bounds restriction (CWE-119) in image processing due to incorrect validation. The target code performs bounds checking via get_name_len and get_name functions before allocation and copying. Both handle external input with length calculations, but the vulnerability mechanisms (arithmetic underflow vs. DNS compression) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is an injection vulnerability (CWE-93) in a printing system's PPD file generation. The target code is a binary DNS parser that copies raw bytes with no string processing, CRLF handling, or command injection vectors. The domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 is a heap buffer overflow (CWE-122) due to off-by-one allocation in path expansion. The target code allocates memory (name_len+4) based on calculated lengths, which could theoretically have similar off-by-one risks. However, the code patterns (string expansion vs. DNS parsing) and vulnerability triggers are significantly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 involves uncontrolled resource consumption (CWE-400) due to unvalidated image dimensions. The target code validates name length via get_name_len before allocation, showing some similarity in validating input sizes before resource allocation. However, DNS parsing has more structured length constraints than image dimensions.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an XXE vulnerability (CWE-611) in an XML parser. The target code parses binary DNS packets with no entity resolution, document structure parsing, or external reference handling. The parsing models (tree-based XML vs. linear DNS) and vulnerability classes are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 involves improper initialization (CWE-665) in a network packet dissector. Both parse network protocols, but the target code initializes struct fields and has clear error returns. Some similarity exists in parsing untrusted network data, but the specific flaw (uninitialized state on error) isn't evident in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 9 is an out-of-bounds read (CWE-125) in another network protocol parser (tcpdump BGP). Like the target DNS parser, it processes network packets with length fields and performs bounds checking. Both handle protocol-specific TLVs/fields where insufficient validation could lead to memory access violations.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 involves integer overflow (CWE-190) in a filesystem block calculation. The target code uses integer variables for lengths but doesn't show complex arithmetic that could overflow. Both process external input with size calculations, but the vulnerability patterns (loop with overflow vs. linear parsing) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-24793_after_subset_100:1ad7c937:vulspec": {
    "timestamp": "2026-01-17T03:10:30.843669",
    "cve_id": "CVE-2022-24793",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1ad7c937",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine disk image library, related to memory ownership and cleanup during error handling. The target code is a DNS query parser performing bounds checking and memory allocation. The vulnerability type, domain, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 is a buffer overflow (CWE-119) in an image processing library due to incorrect bounds checking involving arithmetic. The target code performs bounds checking (`p + 4 > max`) and uses `pj_memcpy` with fixed sizes. The relevance is in the general pattern of validating buffer accesses before memory operations, though the context (image data vs. DNS packets) and specific flaw (underflow) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is an CRLF injection/command injection (CWE-93) in a printing system related to improper neutralization of data in generated files. The target code is a binary DNS parser with no text-based command injection surfaces. The vulnerability types and domains are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 is a heap buffer overflow (CWE-122) due to an off-by-one error in memory allocation in a path expansion function. The target code allocates memory (`pj_pool_alloc`) based on a calculated `name_len`. There is a tangential similarity in performing memory allocation based on parsed input, but the target code's allocation size includes a fixed offset (+4), and the primary vulnerability patterns (off-by-one vs. bounds checking) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code validates buffer boundaries (`p + 4 > max`) and name length via `get_name_len`. The similarity is in validating parsed data against available input size to prevent over-reads, but the vulnerability class (DoS via allocation vs. memory corruption) and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 7 is an XXE vulnerability (CWE-611) in an XML parser. The target code parses binary DNS packets, not text-based XML, and involves no entity resolution. The domains and vulnerability mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is improper initialization (CWE-665) leading to uninitialized memory exposure in a network packet dissector. The target code is also a network packet parser. The weak link is that both handle network data and must manage parser state, but the specific flaw (uninitialized state on error paths) is not evident in the provided target code snippet, which returns early on errors.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is an out-of-bounds read (CWE-125) in a network protocol parser (tcpdump/BGP) due to insufficient bounds checking. The target code is a DNS parser and includes explicit bounds checks (`p + 4 > max`). The relevance is high in terms of domain (binary protocol parsing) and the critical need to validate pointer arithmetic against packet boundaries to prevent OOB reads. The code patterns (pointer advancement, length checks) are similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 is an integer overflow (CWE-190) in a filesystem leading to an infinite loop. The target code uses integer variables for lengths and pointer arithmetic but does not show complex calculations prone to overflow. The only slight similarity is the use of integer values (`name_len`) for memory operations, but the vulnerability pattern and context are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2021-40573_before_subset_100:adf445c0:vulspec": {
    "timestamp": "2026-01-17T03:10:50.158363",
    "cve_id": "CVE-2021-40573",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "adf445c0",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual machine disk image library due to ownership semantics and error handling issues. The target code is a media file parser that reads structured box data. While both involve parsing external data, the vulnerability type (double-free vs. potential integer overflow/underflow), trigger conditions, and code patterns are fundamentally different. The target code's primary risks are related to arithmetic on untrusted size fields, not complex memory ownership during cleanup.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 is an uncontrolled resource consumption (CWE-400) in an image parser due to lack of validation between declared dimensions and actual data. The target code reads multiple size fields (offset_size, length_size, base_offset_size, index_size) from an untrusted bitstream and uses them in arithmetic operations for memory allocation and data reading. Both involve parsing untrusted size fields that control resource consumption. However, the target code uses ISOM_DECREASE_SIZE for some bounds checking, and the primary risk pattern is integer overflow/underflow in arithmetic, not just unbounded allocation.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 3 is an improper bounds restriction (CWE-119) in an image processing library due to incorrect bounds checking that fails to account for arithmetic underflow. The target code performs multiple arithmetic operations using untrusted size fields (e.g., 8*ptr->offset_size) and uses ISOM_DECREASE_SIZE for size tracking. If offset_size, length_size, or base_offset_size are zero, the multiplications could result in zero, potentially causing underflow in subsequent size calculations or reading zero bits, leading to logic errors. The pattern of using untrusted integers in arithmetic for buffer operations is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in an XML parser due to improper restriction of external entity references. The target code parses a binary media format (ISO base media file format) with no XML or entity processing involved. The vulnerability types, attack surfaces, and code patterns are completely different. No reference value for the specific risks in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. Case 5 is an integer overflow/wraparound (CWE-190) in an archive parser when calculating file positions using untrusted values. The target code performs multiple arithmetic operations with untrusted size fields: 8*ptr->offset_size, 8*ptr->length_size, 8*ptr->base_offset_size, 8*ptr->index_size. These multiplications could overflow on 32-bit systems if the size fields are large. Additionally, ISOM_DECREASE_SIZE uses subtraction which could underflow. The code pattern of using untrusted integers in position/size calculations is almost identical to the libarchive vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 6 is an out-of-bounds read (CWE-125) due to insufficient validation between declared and actual decompressed size. The target code reads extent_count and item_count from the bitstream and allocates entries accordingly, but doesn't explicitly validate that the file contains enough data for all entries. The ISOM_DECREASE_SIZE macro provides some size tracking, but if it underflows or if the counts are maliciously large, it could lead to excessive memory consumption or processing of uninitialized data. Both involve parsing untrusted counts that control iteration and memory usage.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 7 is an out-of-bounds read due to insufficient validation of image dimensions. The target code reads item_count and extent_count from untrusted input and uses them to control loop iterations and memory allocations. While there is some size checking via ISOM_DECREASE_SIZE, large count values could still cause excessive resource consumption or incomplete validation leading to out-of-bounds reads when accessing the bitstream. Both involve using untrusted integers to control memory access patterns without complete validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a reachable assertion due to insufficient validation of numeric input fields. The target code reads various size fields (4-bit and 32-bit values) but doesn't appear to validate their ranges (e.g., offset_size, length_size, base_offset_size should be 0-8). If these values are outside expected ranges, the subsequent arithmetic and bitstream reads could behave unexpectedly. However, the vulnerability manifestation (assertion failure vs. integer overflow) and code patterns are different. Some reference value for input validation practices.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a use-after-free/double-free in a reverse engineering framework due to improper linked list cleanup. The target code allocates GF_ItemLocationEntry and GF_ItemExtentEntry structures and adds them to lists, but returns early on allocation failure without cleaning up previously allocated entries, potentially causing memory leaks (though not double-free). The vulnerability types and code patterns are different - the target code's primary risks are arithmetic issues, not complex pointer management during error handling.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is a memory leak in an image parser during error handling. The target code has similar error handling where it returns GF_OUT_OF_MEM on allocation failure without freeing previously allocated entries in the lists, potentially causing memory leaks. However, this is a secondary concern compared to the more critical integer overflow/underflow issues. The code patterns are somewhat similar in error handling paths, but the primary vulnerability classes differ (memory leak vs. integer overflow).",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      }
    ]
  },
  "CVE-2021-40573_after_subset_100:3e680e14:vulspec": {
    "timestamp": "2026-01-17T03:11:20.958242",
    "cve_id": "CVE-2021-40573",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3e680e14",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual machine disk inspection library due to error handling issues. The target code is a media file parser (MP4/ISOBMFF iloc box) with no apparent double-free patterns or similar error handling logic for memory ownership.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 2 is an uncontrolled resource consumption (CWE-400) in an image parser due to lack of validation between declared dimensions and actual data. The target code reads various size fields (offset_size, length_size, etc.) and uses them to calculate read lengths. While not identical, both involve parsing untrusted file fields that control subsequent reads/memory operations without sufficient validation, posing a potential DoS risk if values are extreme.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 is an improper bounds restriction (CWE-119) due to incorrect arithmetic checks. The target code uses `ISOM_DECREASE_SIZE` macros which likely perform size checks before reading. A similar flaw could exist if these checks are insufficient or if integer overflows occur when calculating read sizes (e.g., `8*ptr->offset_size`). The pattern of reading variable-sized fields based on file-controlled values is conceptually similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is an XXE (CWE-611) vulnerability in an XML parser. The target code parses a binary media format (MP4 iloc box) with no XML processing, entity resolution, or similar features. The vulnerability types and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 5 is an integer overflow (CWE-190) in an archive parser when calculating file positions. The target code performs multiple arithmetic operations on file-controlled integers: `8*ptr->offset_size`, `8*ptr->length_size`, `8*ptr->base_offset_size`, `8 * ptr->index_size`. These multiplications could overflow on 32-bit systems if the `*_size` values are large (> 536,870,911), leading to incorrect buffer sizes for subsequent reads. The pattern of using untrusted integers in size calculations is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-5844"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 6 is an out-of-bounds read (CWE-125) due to mismatch between declared and actual decompressed size. The target code reads `extent_offset` and `extent_length` fields controlled by `offset_size` and `length_size`. If these size fields are inconsistent with the actual box structure or file boundaries, similar OOB reads could occur. The pattern of trusting file-provided size values for memory/read operations is comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000085"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 is an out-of-bounds read (CWE-125) due to lack of validation of image dimensions. The target code reads `item_count` and `extent_count` which control loop iterations and memory allocations. If these counts are excessively large, they could cause resource exhaustion or lead to OOB accesses if the box size is insufficient. Both involve parsing untrusted counts that control subsequent processing.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a reachable assertion (CWE-617) due to insufficient validation of a numeric input field. The target code reads various integer fields but does not show explicit assertion checks. However, the underlying issue of missing validation on file-controlled integers (like `offset_size`, which should be 0-8) is similar. A lack of bounds checking could lead to unexpected behavior, though not necessarily an assertion failure.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is a use-after-free/double-free (CWE-416) in a reverse engineering tool due to linked list cleanup issues. The target code uses `gf_list_add` and allocates structures but shows no complex pointer manipulation or linked list traversal that could cause UAF. The memory management patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a memory leak (CWE-401) in an image parser during error handling. The target code has early returns on allocation failure (`GF_OUT_OF_MEM`) but doesn't show cleanup of partially allocated structures (like `location_entry->extent_entries`) in error paths. There's a potential similarity if the function leaks memory when failing mid-parsing, but the code pattern is not prominent.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      }
    ]
  },
  "CVE-2015-7852_before_subset_100:82fc10f1:vulspec": {
    "timestamp": "2026-01-17T03:11:47.952787",
    "cve_id": "CVE-2015-7852",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "82fc10f1",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management flaw in a virtual disk inspection library. The target code is a formatted output function in what appears to be an NTP-related utility (cookedprint). There is no dynamic memory allocation or deallocation in the target code, and the functionality domains are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is an out-of-bounds read in a network protocol parser (tcpdump VTP). The target code also parses input data (name/value pairs) and performs format-specific decoding. While both involve parsing untrusted input, the vulnerability type (OOB read vs. potential format string/buffer issues) and code patterns differ. The target code uses fixed-size stack buffers (bn, bv) with size limits, which is a different risk pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves CRLF injection in a printing system. The target code outputs formatted data but focuses on decoding and converting values, not generating executable configuration files. Both handle external input, but the injection vector and impact are dissimilar. The target code's atoascii() calls might have relevance if they perform insufficient sanitization.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability in an XML parser. The target code parses simple name/value pairs, not hierarchical markup. The attack surfaces and parsing complexities are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Similar to Case 2, this is an out-of-bounds read in a network protocol parser (BGP). The target code's parsing is simpler (delimited strings) but shares the theme of decoding untrusted input based on a format specifier. The fixed-size buffers in the target code (bn, bv) mitigate OOB reads but could lead to truncation or other issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a use-after-free/double-free in a reverse engineering tool's data structure management. The target code uses only stack variables and has no dynamic memory operations, making this memory corruption vulnerability pattern irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a resource exhaustion flaw via unchecked image dimensions. The target code does parse length and data parameters, but there is no obvious unbounded allocation based on input. The primary risks in the target code are buffer overflows or format string issues, not resource exhaustion.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 8 is a buffer overflow in a kernel network driver due to incorrect fragment count handling. The target code has several fixed-size stack buffers (b[12], bn[2*MAXVARLEN], bv[2*MAXVALLEN]) and performs string operations (strlen, snprintf). While not identical, both involve bounds checking concerns. The target code's use of strlen on 'value' before writing `output_raw` into `bv` could be problematic if `bv` is exactly full, though the preceding atoascii call with size limit may mitigate this.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a stack buffer overflow in a USB driver. The target code also uses stack buffers (b, bn, bv) and performs string operations. The pattern of decoding external input into fixed-size buffers is shared. The risk in the target code is more about string termination and length calculation errors (e.g., the bv[len] assignment) than direct overflow from copy operations, but the underlying memory safety concern is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is an uninitialized memory exposure in a network flow dissector. The target code declares many stack variables (name, value, output_raw, lfp, hval, etc.) which are passed to decoder functions (decodets, decodenetnum, decodeuint). If these decoder functions fail and leave variables uninitialized, and those variables are later used, it could be analogous. However, the code shows that on decoder failure, `output_raw` is set to '?' and the raw strings are output instead, likely avoiding use of uninitialized decoded values. The relevance is therefore limited.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2015-7852_after_subset_100:acaf2404:vulspec": {
    "timestamp": "2026-01-17T03:12:12.734330",
    "cve_id": "CVE-2015-7852",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "acaf2404",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to memory ownership and cleanup during error handling. The target code is a formatted output function in NTP that processes network data with buffer bounds checking. The vulnerability types (double-free vs. potential buffer overflow/formatting issues), domains (VM disk inspection vs. network time protocol), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2017-13033 is an out-of-bounds read in tcpdump's VTP parser due to insufficient validation of length fields. The target code also parses network protocol data (NTP mode 6 responses) and performs validation (e.g., decodeuint, decodets). Both involve parsing untrusted network input with switch-case dispatch based on format types. However, the specific flaw (OOB read vs. potential buffer overflow in output) and context (packet dissection vs. control message printing) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-15400 is a CRLF injection/command injection in CUPS IPP attribute processing. The target code formats and outputs data but uses atoascii() for sanitization (as noted in the TALOS-CAN-0063 comment) and does not generate executable content. Both process external input, but the vulnerability class (injection vs. memory safety) and impact are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in libxml2. The target code does not parse XML or handle external entities. Both process input data, but the domain (XML parsing vs. binary/string formatting) and vulnerability mechanism are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2017-12994 is an out-of-bounds read in tcpdump's BGP parser due to insufficient bounds checking on TLV attributes. The target code similarly parses variable-length data fields (name/value pairs) with format-specific decoders (decodets, decodenetnum, decodeuint). Both involve structured network protocol parsing with validation steps. The main difference is the specific protocol (BGP vs. NTP mode 6) and the exact flaw manifestation.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in radare2's basic block analysis due to circular linked list references. The target code has no dynamic memory allocation or pointer-based data structures; it uses stack buffers (bn, bv) and array variables. The vulnerability classes (memory corruption via pointer mishandling vs. buffer management) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-11470 is an uncontrolled resource consumption (CWE-400) in ImageMagick due to lack of validation between declared image dimensions and actual data. The target code includes size limits (MAXVARLEN, MAXVALLEN) in atoascii() calls, showing some validation. Both handle external input with size checks, but the target code's checks are more direct (fixed buffers) versus ImageMagick's allocation based on untrusted fields.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2015-5156 is a buffer overflow in the Linux kernel virtio-net driver due to incorrect fragment count handling. The target code uses fixed-size stack buffers (bn[2*MAXVARLEN], bv[2*MAXVALLEN]) and explicitly mentions avoiding buffer overrun (TALOS-CAN-0063). Both involve buffer size calculations and bounds enforcement, but the context (network driver DMA vs. user-space formatting) and scale differ.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-8068 is a stack buffer overflow in a Linux USB driver due to improper DMA buffer handling. The target code also uses stack buffers (bn, bv) and performs bounds-conscious operations (atoascii with size limits). Both emphasize buffer size management, but the driver context (kernel-space, hardware interaction) vs. user-space formatting reduces direct similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13715 is an uninitialized memory exposure in the Linux kernel flow dissector due to improper state cleanup on error paths. The target code initializes output_raw and other variables, and has error handling (output_raw = '?'). Both involve parsing network data with error conditions, but the target code's error paths set a sentinel value rather than leaving state uninitialized. The vulnerability class (information disclosure vs. formatting error) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2021-41206_before_subset_100:57a82bbc:vulspec": {
    "timestamp": "2026-01-17T03:12:35.003083",
    "cve_id": "CVE-2021-41206",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "57a82bbc",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file processing library (libguestfs) due to improper memory ownership management during error handling. The target code is a GPU-accelerated linear algebra kernel in TensorFlow that performs batched LU decomposition and linear system solving using cuBLAS/cuSOLVER. The memory management patterns, error handling, and domain (numerical computing vs. file parsing) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in CUPS during PPD file generation from untrusted IPP responses. The target code performs mathematical computations on GPU tensors with validated dimensions. There is no parsing of textual protocols, command construction, or CRLF sequence handling. The attack surfaces and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared dimensions and actual data size. The target code validates tensor dimensions early (OP_REQUIRES_ASYNC checks) but does involve memory allocations based on these dimensions (e.g., for pivots, scratch space). There is a superficial similarity in validating input dimensions before allocation, but the context (image parsing vs. batched linear algebra) and specific flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a use-after-free/double-free in a reverse engineering tool due to improper cleanup of linked data structures with circular references. The target code uses RAII-style management with std::unique_ptr and CudaSolver's scoped tensors. Memory ownership is clear, and there are no manual pointer manipulations or complex linked structures that could create dangling references.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a buffer overflow in PHP's GD library due to an integer underflow in bounds checking. The target code performs bounds checking via OP_REQUIRES_ASYNC on tensor dimensions and uses safe memory operations (device.memcpy with calculated sizes based on NumElements()). While both involve size calculations, the target code's calculations are straightforward multiplications of validated dimensions, with no complex arithmetic that could underflow. The domain and flaw pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a path validation issue in libarchive during hardlink extraction, leading to potential symlink attacks. The target code processes numerical data in memory buffers and has no filesystem operations, path handling, or symlink-related logic. The vulnerability classes are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow in a Linux kernel network driver due to incorrect feature negotiation and insufficient buffer allocation for fragmented packets. The target code allocates buffers based on validated tensor dimensions and batch size. While both involve buffer allocation based on input parameters, the target code's allocation logic is simple and direct, without the complex feature negotiation and dynamic fragment counting that caused the vulnerability in the kernel driver.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a reachable assertion in ImageMagick due to insufficient validation of a numeric input field (number_meta_channels). The target code validates its key numeric inputs (dimensions) via OP_REQUIRES_ASYNC. However, it does not validate other derived values (like batch_size, n, nrhs) against implementation limits (e.g., maximum batch size, matrix size limits for batched vs. non-batched solver choice). There is a conceptual similarity in validating input parameters, but the specific flaw (assertion failure vs. potential GPU kernel errors) and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is an out-of-bounds read in ImageMagick due to inconsistent channel count validation between images during complex operations. The target code validates that input and RHS tensors have the same rank and compatible dimensions. However, it does not explicitly validate that the data types (Scalar) and memory layouts are consistent for the batched solver pointer arrays. A mismatch between the expected and actual tensor structure could lead to incorrect pointer arithmetic. The similarity lies in validating consistency between multiple input data structures, but the domain (image channels vs. matrix dimensions) and memory access patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-13302"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in an x86 assembler due to insufficient bounds checking on an array index derived from untrusted input. The target code uses indices (like batch index) that are derived from validated batch_size and loop bounds. There is no array access with untrusted indices without prior validation. The code patterns and vulnerability types are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      }
    ]
  },
  "CVE-2021-41206_after_subset_100:16a5d4e1:vulspec": {
    "timestamp": "2026-01-17T03:12:48.830947",
    "cve_id": "CVE-2021-41206",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "16a5d4e1",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file processing library due to improper memory ownership and cleanup. The target code is a GPU-accelerated linear algebra kernel in TensorFlow that performs LU factorization and solving. The domains (virtual machine inspection vs. numerical computing), vulnerability types (memory corruption vs. potential validation/logic errors), and code patterns are fundamentally different. No direct reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in a printing system due to improper neutralization of IPP attribute values. The target code performs mathematical computations on GPU, handles tensor data, and has no text parsing, command generation, or network protocol handling. The attack surfaces and flaw nature are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code validates tensor dimensions (e.g., `OP_REQUIRES_ASYNC` checks) but does involve memory allocation based on user-provided dimensions (`batch_size`, `n`). There is a conceptual similarity in validating input-controlled allocation sizes, but the context (image parsing vs. batched linear algebra) and specific patterns differ significantly. The target code's allocations are scoped and managed by a solver object, reducing direct risk.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a use-after-free/double-free in a reverse engineering tool due to improper cleanup of linked structures. The target code uses C++ with RAII (`std::unique_ptr`), managed tensors, and asynchronous callbacks. There is no manual memory management of complex linked structures. The vulnerability patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is a buffer overflow due to incorrect bounds checking and arithmetic underflow in an image processing library. The target code performs memory copies (e.g., `device.memcpy`) using counts derived from tensor `NumElements()`. While there is a similarity in performing bulk memory operations based on calculated sizes, the target code's sizes are validated through the tensor shape system and the `OP_REQUIRES` checks. The risk of integer overflow in `input.NumElements() * sizeof(Scalar)` exists but is mitigated by the framework's tensor allocation. The relevance is limited to the general concept of bounds validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 involves improper path validation leading to filesystem issues in an archive library. The target code has no filesystem operations, path handling, or symlink/hardlink logic. The domains are entirely separate.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow in a network driver due to incorrect feature negotiation and fragment handling. The target code is a computational kernel for dense linear algebra on GPUs. While both may involve buffer management, the mechanisms (DMA/scatter-gather vs. CUDA memory copies), concurrency models, and attack vectors (network packets vs. tensor data) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a reachable assertion due to insufficient validation of a numeric input field (`number_meta_channels`). The target code validates numeric inputs (e.g., dimensions via `OP_REQUIRES_ASYNC`) but also passes user-controlled values like `batch_size` and `n` to low-level library calls (cuBLAS/cuSolver). There is a similarity in the need to validate inputs before passing them to external libraries. However, the target's validation is more extensive, and the failure mode (assertion crash vs. potential GPU library error) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 is an out-of-bounds read due to inconsistent channel count validation during image processing. The target code ensures shape consistency between input tensors (`input` and `rhs`) through multiple `OP_REQUIRES_ASYNC` checks. A conceptual similarity exists in validating that operands have compatible dimensions/shapes before processing. However, the specific vulnerability pattern (channel mismatch in complex operations) and domain (image pixels vs. matrix elements) are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-13302"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an out-of-bounds read in an x86 assembler due to insufficient bounds checking on an array index derived from user input. The target code uses array indexing (e.g., `input_copy_reshaped(batch, 0, 0)`) but the indices (`batch`) are derived from validated `batch_size`. There is no user-controlled index into a fixed-size array like `SEG_REG_PREFIXES`. The relevance is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      }
    ]
  },
  "CVE-2020-36406_before_subset_100:6e572c25:vulspec": {
    "timestamp": "2026-01-17T03:13:17.551473",
    "cve_id": "CVE-2020-36406",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "6e572c25",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XML External Entity (XXE) vulnerability (CWE-611) in a parsing library. The target code is a topic publishing function for a message broker/pub-sub system, handling string segmentation and wildcard matching. The vulnerability type, domain, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a Double Free (CWE-415) vulnerability in a file processing function within a disk image inspection tool. The target code performs tree traversal and message assignment without dynamic memory allocation/deallocation in the shown path. The core flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-13033 is an Out-of-bounds Read (CWE-125) in a network protocol dissector due to insufficient length validation. The target code uses `std::string_view` operations with careful bounds checks via `substr` and `find`. The context and vulnerability pattern are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-16943 is a Use-After-Free (CWE-416) in an email server's header processing. The target code manipulates pointers (`Topic *iterator`) within a controlled tree structure and does not show explicit memory release. The memory management models are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is an CRLF Injection/Command Injection (CWE-93) vulnerability in a printer configuration generator. The target code validates topic segments for wildcard characters (`+`, `#`) but does not involve parsing external data into command sequences or neutralization issues. The flaw domain is dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a Use-After-Free/Double Free (CWE-416) in a reverse engineering framework linked to improper cleanup of linked structures. The target code uses `std::map` and pointers but does not exhibit the complex manual linked list management or cleanup logic that leads to the cited vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-13715 is an Improper Initialization (CWE-665) leading to uninitialized memory exposure in a kernel network dissector. The target code initializes variables (e.g., `start`, `stop`) and uses RAII types (`std::string_view`). The context of kernel packet parsing vs. user-space tree traversal is vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-8068 is a Buffer Overflow (CWE-119) in a kernel USB driver due to improper stack buffer handling with DMA. The target code uses high-level C++ containers and views without apparent fixed-size buffer operations or direct hardware interaction. The vulnerability class and environment are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2015-5156 is a Buffer Overflow (CWE-119) in a virtual network driver due to incorrect fragment count handling. The target code's primary operations are string matching and assignment to `std::map`. There is no processing of packet fragments or similar low-level buffer management.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7425 is a Buffer Overflow (CWE-119) in a kernel SCSI driver due to missing validation of user-controlled length fields. The target code's input (`topic`, `message`) is passed by value/view, and the logic focuses on tree navigation rather than copying data based on untrusted size parameters.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2020-36406_after_subset_100:fe0115df:vulspec": {
    "timestamp": "2026-01-17T03:13:46.579903",
    "cve_id": "CVE-2020-36406",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "fe0115df",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XML External Entity (XXE) vulnerability (CWE-611) in a parsing library. The target code is a topic publishing function for a message broker (likely MQTT-like), dealing with string segmentation, wildcard matching, and recursion control. The vulnerability type, domain (parsing vs. pub/sub routing), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a Double Free (CWE-415) vulnerability in a file processing function within a disk image inspection tool. The target code performs iterative tree traversal and map lookups with no dynamic memory allocation or deallocation visible in the provided snippet. The core flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-13033 is an Out-of-bounds Read (CWE-125) in a network protocol dissector due to insufficient length validation. The target code uses `std::string_view::substr` and `find` with careful bounds calculation (`stop - start`). While both parse structured data, the target code's operations are bounds-safe by design using string views, and the vulnerability pattern differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-16943 is a Use After Free (CWE-416) in an email server's header processing. The target code manipulates pointers (`Topic *iterator`) within a tree structure but does not show any `new`/`delete` or `malloc`/`free` operations. The memory ownership model and the flaw's root cause are not comparable to the provided snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is an CRLF Injection/Command Injection (CWE-93) vulnerability in a printer configuration generator. The target code validates for specific wildcard characters ('+', '#') but does not perform neutralization for output contexts like shell commands. The functionality and attack vectors are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a Use After Free/Double Free (CWE-416) in a reverse engineering tool due to improper cleanup of linked data structures. The target code uses `std::map` for children and simple pointer assignment. There is no visible manual memory management or complex pointer graph manipulation that could lead to similar ownership issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13715 is an Improper Initialization (CWE-665) flaw in a network packet parser. The target code shows proper initialization of loop variables (`start`, `stop`) and checks state (`triggered` flag). The weak link is that both involve parsing a segmented data stream (topic path vs. network headers) and require careful state management across segments, but the specific vulnerability type is not mirrored.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-8068 is a Buffer Overflow (CWE-119) in a USB driver due to improper stack buffer handling. The target code uses high-level C++ standard library types (`std::string_view`, `std::map`) with managed bounds, showing no low-level buffer operations or array indexing that could lead to classic buffer overflows.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2015-5156 is a Buffer Overflow (CWE-119) in a network driver due to incorrect fragment count handling. The target code's only loop is over topic segments via `find`, with no array or buffer indexing based on untrusted counts. The domains (kernel driver vs. application-level pub/sub) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-7425 is a Buffer Overflow (CWE-119) in a SCSI driver due to missing validation of a length parameter before a copy operation. The target code does not accept any explicit length parameters from untrusted sources; its input is a `std::string_view` and a `std::pair` of string views. The data flow and risk of classic buffer overflow are not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2022-0492_after_subset_100:e3990621:vulspec": {
    "timestamp": "2026-01-17T03:14:13.062929",
    "cve_id": "CVE-2022-0492",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "e3990621",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file content processing. The target code is a kernel function handling a control file write with capability checks and a string copy. The vulnerability types, domains (userspace vs. kernel), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free/double-free (CWE-416) in a reverse engineering tool's data structure cleanup. The target code performs a controlled string copy into a statically sized buffer with locking. There is no similarity in vulnerability pattern, context, or code structure.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 3 is a race condition leading to use-after-free (CWE-362/416) in the kernel TTY subsystem. While both are in the kernel and involve concurrency (the target uses `spin_lock`), the core flaw is different. The target code's vulnerability potential lies in the `strlcpy` into a fixed-size buffer, not a missing lock or refcount. The reference value for synchronization patterns is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2013-4254"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2010-5313"
        }
      }
    ]
  },
  "CVE-2022-0492_before_subset_100:ed4d2a90:vulspec": {
    "timestamp": "2026-01-17T03:14:15.113969",
    "cve_id": "CVE-2022-0492",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ed4d2a90",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file content processing. The target code is a kernel function performing a simple string copy with locking. The vulnerability types, domains (userspace vs. kernel), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free/double-free (CWE-416) in a userspace reverse engineering tool (radare2) related to linked list cleanup. The target code performs a bounded string copy (`strlcpy`) within a critical section protected by a spinlock. The memory management patterns and context are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 is a race condition leading to use-after-free (CWE-362, CWE-416) in the kernel's tty subsystem. The target code also runs in the kernel and uses locking (`spin_lock`). However, the core flaw is different: CVE-2016-0723 is about missing synchronization on a shared pointer, while the target code correctly uses a lock to protect the `release_agent_path` buffer during the copy. The similarity is limited to the kernel environment and the use of locking primitives.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a heap buffer overflow (CWE-122) in glibc's `glob()` function due to an off-by-one calculation. The target code uses `strlcpy`, which is specifically designed to prevent buffer overflows by guaranteeing null-termination within the destination size. The functional domains (pathname expansion vs. cgroup control file write) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is a buffer overflow (CWE-119) in a kernel SCSI driver due to insufficient validation of a length parameter. The target code involves copying a user-supplied string (`buf`) into a kernel buffer. While both handle user input in the kernel, the target uses `strlcpy` with a fixed size (`sizeof(cgrp->root->release_agent_path)`), which provides a basic bound. The key difference is the lack of explicit length validation in the target code before the copy, though `strlcpy` mitigates overflow. The `BUILD_BUG_ON` ensures the destination is at least `PATH_MAX`, but does not validate the input length `nbytes`. This presents a potential, though less direct, similarity in the \"unchecked user input\" aspect.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow (CWE-119) in a network driver due to incorrect assumptions about fragment counts. The target code is a control file write operation for cgroup configuration. The domains (networking vs. cgroup management) and the nature of the buffer management (scatter-gather lists vs. a simple character array) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is an XML External Entity (XXE) vulnerability (CWE-611) in a userspace parsing library. The target code is a kernel function copying a string. There is no meaningful similarity in vulnerability type, trigger conditions, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a stack buffer overflow (CWE-119) in a USB network driver related to DMA and stack allocation. The target code copies to a field within a `cgroup` structure (likely heap-allocated) and uses a bounded copy function. The contexts and specific overflow mechanisms are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an input validation flaw leading to a NULL pointer dereference (CWE-20, CWE-476) in the kernel's perf subsystem. The target code validates that `cgrp` is not NULL but does not perform deep validation on the content of `buf`. The primary flaw patterns (dereference vs. copy) and subsystems are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-4254"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a race condition (CWE-362) in the KVM virtualization layer between guest levels. The target code uses a spinlock to prevent races on the `release_agent_path` buffer among concurrent writers on the same control file. While both involve kernel synchronization, the scope (intra-host cgroup vs. inter-guest VM), complexity, and consequences are vastly different. The similarity is superficial (use of locking).",
        "case_metadata": {
          "cve_id": "CVE-2010-5313"
        }
      }
    ]
  },
  "CVE-2016-8670_before_subset_100:b472db2f:vulspec": {
    "timestamp": "2026-01-17T03:14:39.721322",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b472db2f",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The target code is from a GD graphics library context (dynamicGetbuf), which directly matches the system and domain of CVE-2016-8670 (PHP's GD library). Both involve buffer handling during image data transfer operations. The key flaw in the case is an arithmetic underflow leading to incorrect bounds checking (`remain == 0` fails for negative values). The target code performs a similar bounds check (`remain >= len`, `remain == 0`). While the exact underflow condition isn't immediately visible in the target snippet, the code pattern (calculating `remain` as `logicalSize - pos`) and the subsequent conditional checks are structurally identical to the vulnerable pattern. The vulnerability type (CWE-119, improper bounds restriction) and the attack surface (image processing API) are a direct match.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability (CWE-415) in libguestfs related to file content processing and error handling. The target code is a simple memory read function (`memcpy`) from a dynamic buffer within a graphics library. There is no memory deallocation, no complex error handling paths, and no ownership semantics involved. The functional domains (image processing vs. VM disk inspection) and the core flaw patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2019-11470 is a resource consumption vulnerability (CWE-400) in an image decoder due to lack of validation between declared dimensions and actual data. The target code performs a bounded read from an already allocated buffer (`dp->data`). It does not allocate memory based on untrusted inputs, nor does it parse file headers. The similarity is limited to both being in the broad domain of image/data processing, but the vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free vulnerability (CWE-416) in a reverse engineering tool related to linked structure cleanup. The target code performs a single, straightforward `memcpy` operation. There are no pointer manipulations, no complex data structures (like linked lists), and no memory deallocation logic. The domains and flaw patterns are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2016-7425 is a buffer overflow (CWE-119) in a kernel driver due to insufficient validation of a user-controlled length. The target code also involves a buffer copy (`memcpy`) with length validation. This provides a weak similarity in the general pattern of \"validate length before copy.\" However, the contexts are vastly different (kernel SCSI driver vs. user-space graphics library), the attack surfaces are unrelated, and the target code's validation logic appears more straightforward, lacking the complex control flow and untrusted input sourcing of the kernel driver case.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-18257 is an integer overflow (CWE-190) leading to an infinite loop in a filesystem. The target code performs an integer subtraction (`dp->logicalSize - dp->pos`) to calculate `remain`. If `dp->pos` could be greater than `logicalSize`, `remain` could become negative, which is not properly handled (only checked for equality with zero). This is a potential integer wrap/underflow issue, creating a weak link to CWE-190. However, the consequence in the target code would be a large positive `remain` value (due to underflow) leading to an out-of-bounds read, not an infinite loop. The domains and specific flaw manifestations are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-15670 is a heap buffer overflow (CWE-122) due to an off-by-one error in allocation. The target code uses `memcpy` with a calculated length `rlen`. If the calculation of `rlen` or the bounds check is incorrect, it could lead to a buffer overflow. This creates a conceptual similarity in the \"incorrect bounds calculation leading to overflow\" pattern. However, the target code's calculation is simpler, and the vulnerability in the case is specifically in a path expansion function, which is a different subsystem.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2014-9904 is an integer overflow (CWE-190) in a parameter validation check leading to incorrect memory allocation. The weak link to the target code is the arithmetic operation (`dp->logicalSize - dp->pos`) which, if not properly guarded, could underflow. However, the target code's operation is subtraction for bounds checking, not multiplication for size calculation, and it does not involve memory allocation. The relevance is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2015-5156 is a buffer overflow (CWE-119) due to insufficient validation of fragment count against a pre-allocated buffer. The target code validates a length (`len`) against available data (`remain`) before a copy operation. This is a similar high-level \"validate before use\" pattern that is incorrectly implemented in the case. The connection is generic to buffer overflow vulnerabilities but lacks specificity in terms of context (network driver vs. image IO) and the nature of the miscalculation (fragment list vs. simple size/position).",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-13715 is an uninitialized memory issue (CWE-665) in a network protocol parser due to improper state cleanup on error paths. The target code is a simple, linear function with no complex state, no protocol parsing, and no error paths that skip initialization. The domains and vulnerability patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2016-8670_after_subset_100:d8811b26:vulspec": {
    "timestamp": "2026-01-17T03:15:00.414601",
    "cve_id": "CVE-2016-8670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d8811b26",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. Both the target code and CVE-2016-8670 involve buffer handling in a GD library context (dynamicGetbuf vs. gd_io_dp.c). The core flaw pattern is identical: performing bounds checking using arithmetic (`dp->logicalSize - dp->pos`) which could underflow/wrap, leading to incorrect `remain` calculation. In the target code, if `dp->pos > dp->logicalSize`, `remain` becomes negative, but the check `if (remain <= 0)` only catches zero or negative, returning EOF. However, the subsequent `memcpy` uses `rlen` (set to `remain` if negative?), but `rlen` is only set if `remain` is positive (in the `else` block, `rlen = remain`). Actually, a closer look shows if `remain` is negative, the code enters the `else` block, sets `rlen = remain` (a negative value), and passes it to `memcpy` as the third parameter (size_t), causing a huge copy and buffer overflow. This is the exact same flaw pattern as CVE-2016-8670: improper validation of arithmetic result leading to buffer overflow.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a file reading function within libguestfs, involving complex memory ownership and error handling. The target code is a simple buffer copy function with no dynamic memory allocation/deallocation, no error handling paths that free resources, and a completely different vulnerability pattern (buffer overflow vs. double-free).",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in a data structure cleanup function. The target code has no memory deallocation, no linked list manipulation, and operates on a simple buffer. The vulnerability classes and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-7425 is a buffer overflow in a kernel driver due to insufficient validation of a user-controlled length. The target code also has a buffer overflow potential due to improper validation of a calculated length (`remain`). Both are CWE-119. However, the trigger and context differ significantly: one is in a SCSI driver handling message transfers, the other is in a graphics library's IO routine. The similarity is in the insufficient validation leading to an out-of-bounds memory operation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-18257 involves an integer overflow (CWE-190) leading to an infinite loop. The target code's flaw also stems from an integer issue (underflow/wrap of `remain`). Both involve integer miscalculations during size/position operations. However, the consequences and code patterns are different: one leads to a logic/loop error, the other leads directly to a buffer overflow in a `memcpy`. The integer handling is the weak link.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-15670 is a heap buffer overflow due to an off-by-one allocation error. The target code also has a buffer overflow potential. Both are CWE-122/119. However, the root causes differ: one is an off-by-one in allocation size calculation, the other is an underflow in a bounds check. The code patterns (memory copy vs. string expansion) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2014-9904 involves an integer overflow in a size check leading to incorrect memory allocation. The target code's flaw also involves an integer issue (underflow) in a size check (`remain`). Both are CWE-190 related. However, the context (audio parameter validation vs. buffer position calculation) and specific integer operation (multiplication overflow vs. subtraction underflow) differ.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2015-5156 is a buffer overflow due to insufficient allocation for network fragments. The target code also has a buffer overflow. Both are CWE-119. The similarity ends there; the root causes are different (incorrect feature assumption vs. arithmetic underflow), and the domains (network driver vs. graphics IO) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13715 is an improper initialization issue leading to information disclosure. The target code's flaw is a buffer overflow due to an arithmetic error. The vulnerability types (CWE-665 vs. CWE-119), consequences, and code patterns (state management in protocol parsing vs. bounds-checked copy) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-39190_before_subset_100:cc8f3659:vulspec": {
    "timestamp": "2026-01-17T03:15:31.895085",
    "cve_id": "CVE-2022-39190",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "cc8f3659",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file content processing. The target code is a kernel function handling network filter verdicts with no dynamic memory allocation or free operations in the shown path. The domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 involves improper initialization (CWE-665) in the Linux kernel's network flow dissector, leading to information disclosure. While both are in the kernel networking domain, the target code's primary operations are chain lookups and validation checks. The specific flaw pattern (uninitialized memory on error path) is not evident in the provided `nft_verdict_init` function, which has clear error returns.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 3 is a CRLF injection (CWE-93) in a userspace printing system (CUPS) related to IPP attribute processing. The target code is a kernel function parsing nested netlink attributes for packet filtering verdicts. There is no text/command generation or injection vector in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in a userspace XML parsing library. The target code is a kernel function handling internal data structure setup for network filtering. The domains (XML parsing vs. netlink verdict processing) and vulnerability patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a resource consumption vulnerability (CWE-400) in an image parsing library due to lack of dimension validation. The target code performs data structure validation and chain lookups but does not parse complex file formats or allocate memory based on untrusted size fields. The core flaw pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 is an integer overflow (CWE-190) in the Linux kernel IPv6 fragmentation handler, leading to an infinite loop. Both are in the Linux kernel networking subsystem. While the target code does not show obvious integer arithmetic, the pattern of parsing nested, untrusted network data (netlink attributes) shares similarities with parsing untrusted packet headers. The specific overflow/loop flaw is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2017-7542"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read (CWE-125) in tcpdump's VTP dissector due to insufficient length validation. The target code uses `nla_parse_nested_deprecated` which should perform bounds checking. Both involve parsing network protocol data, but the target is in-kernel configuration (netlink) while tcpdump is a userspace packet analyzer. The flaw pattern (OOB read) is not directly applicable to the shown code which uses kernel-safe attribute accessors.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an integer overflow (CWE-190) in the F2FS filesystem leading to an infinite loop. Both are in the Linux kernel. The relevance is weak because the domains differ (filesystem vs. networking), and the target code does not contain the complex block arithmetic or loop structures that could lead to a similar overflow/loop condition.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is a buffer overflow (CWE-119) in the kernel virtio-net driver due to incorrect feature declaration and insufficient buffer allocation. The target code is also in the kernel networking stack (Netfilter/nftables). While the specific flaw (fragment count overflow) is not present, the pattern of processing untrusted data (netlink attributes from userspace) to configure kernel state is similar. Both involve validation of user-supplied data that controls kernel object references (network chains in target, packet fragments in case).",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 10 is a NULL pointer dereference (CWE-476) in the kernel CIPSO module due to missing validation of a `skb` parameter in a `setsockopt` path. The target code is also a kernel function (`nft_verdict_init`) that processes user input (via netlink) to configure kernel objects. It includes multiple pointer checks (`IS_ERR(chain)`, `PTR_ERR(chain)`) and validation of nested attributes. The pattern is highly relevant: both are in-kernel subsystems that must rigorously validate all user-controlled inputs and pointer states to avoid crashes or privilege escalation. The target code demonstrates the careful error checking that Case 10 lacked.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      }
    ]
  },
  "CVE-2022-39190_after_subset_100:766ccdf2:vulspec": {
    "timestamp": "2026-01-17T03:15:54.357747",
    "cve_id": "CVE-2022-39190",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "766ccdf2",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file processing. The target code is a kernel function handling network filter verdicts with no dynamic memory allocation or deallocation in the shown path. The domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 2 involves improper initialization (CWE-665) leading to information leak in the kernel's network flow dissector. While both are in the kernel networking domain, the target code's flaw pattern is different (logic/state validation of chain lookups). The core vulnerability mechanism (uninitialized memory) is not present in the provided target code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 3 is a CRLF injection (CWE-93) in a userspace printing system (CUPS). The target code is kernel-level netfilter chain validation with no string parsing, command generation, or output formatting involved. The domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in an XML parsing library. The target code is kernel netfilter code processing network verdict attributes. There is no overlap in functionality, data format, or vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an uncontrolled resource consumption (CWE-400) in an image decoder due to lack of dimension validation. The target code performs logic validation and chain lookups but does not involve parsing complex file formats or allocating resources based on untrusted size fields. The context is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is an integer overflow (CWE-190) in IPv6 header parsing leading to an infinite loop. Both are in the kernel networking stack. The relevance is weak because the target code does not show arithmetic operations on attacker-controlled integers that could overflow. The vulnerability pattern (integer overflow -> infinite loop) is not directly mirrored, though both involve parsing network-related data structures.",
        "case_metadata": {
          "cve_id": "CVE-2017-7542"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read (CWE-125) in a packet analyzer (tcpdump) due to insufficient length validation. The target code uses `nla_parse_nested_deprecated` which performs bounds checking. While both process network data, the target code is in the kernel enforcement path (netfilter) and the shown snippet does not exhibit obvious bounds-checking flaws on array or buffer accesses.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is an integer overflow (CWE-190) in a filesystem leading to an infinite loop. The weak relevance stems from both being kernel code that validates state and could potentially have logic flaws leading to resource exhaustion (e.g., chain->use++ without an upper bound, though not shown as problematic here). However, the specific integer overflow and filesystem context are not present in the target networking code.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 9 is a buffer overflow (CWE-119) in a kernel network driver due to incorrect feature assumptions and insufficient validation. The target code also resides in the kernel networking subsystem (netfilter) and performs validation on user/attacker-controlled data (netlink attributes) to ensure state consistency (e.g., checking chain flags). Both involve validating untrusted input against kernel object state, though the specific flaw pattern (buffer overflow vs. logic/state validation) differs.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is a NULL pointer dereference (CWE-476) in kernel networking code (CIPSO) due to missing validation of a function parameter. The target code also performs kernel-level networking operations and includes multiple pointer checks (IS_ERR, PTR_ERR). The pattern of validating the results of lookup functions (like `nft_chain_lookup_byid`) is conceptually similar to the need for NULL checks in Case 10. Both highlight the importance of rigorous error path validation in kernel networking code that processes user-controlled data.",
        "case_metadata": {
          "cve_id": "CVE-2013-0310"
        }
      }
    ]
  },
  "CVE-2022-0849_before_subset_100:3592b78f:vulspec": {
    "timestamp": "2026-01-17T03:16:02.931366",
    "cve_id": "CVE-2022-0849",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3592b78f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in libguestfs related to file content processing and error handling. The target code is an ESIL analysis function in radare2 focused on binary analysis and reference tracking. The domains (VM disk inspection vs. binary analysis), vulnerability types (double-free vs. potential memory/bounds issues), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. Case 2 (CVE-2018-12320) is a use-after-free/double-free vulnerability in radare2's basic block analysis (libr/anal). The target code is from the same system (radare2) and same core library (analysis subsystem). Both involve complex memory management of analysis data structures, pointer manipulation, and cleanup routines. The vulnerability patterns (improper linked list cleanup, circular references) are directly applicable to the target code's handling of analysis contexts, buffers, and ESIL state.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 (CVE-2016-8670) is a buffer overflow in PHP's GD library due to incorrect bounds checking and arithmetic underflow. The target code performs bounds checking (e.g., `iend > MAX_SCAN_SIZE`) and buffer operations (`buf = malloc((size_t)iend + 2)`). While both involve memory buffer management, the specific vulnerability pattern (arithmetic underflow in image processing) differs significantly from the binary analysis context. Some reference value exists for general buffer safety practices.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 (CVE-2017-15400) is a CRLF injection/command injection vulnerability in CUPS' PPD file generation. The target code performs binary analysis without generating configuration files or processing untrusted text data in a way that would enable injection attacks. The vulnerability types and domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 (CVE-2019-11470) is an uncontrolled resource consumption vulnerability in ImageMagick due to unvalidated image dimensions leading to excessive memory allocation. The target code has some similar patterns: it validates `iend` against `MAX_SCAN_SIZE` before allocation, but also performs arithmetic (`iend = end - start`) that could theoretically underflow. The reference value is limited to general resource validation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 7 (CVE-2018-19843) is an out-of-bounds read in radare2's x86 assembler module. The target code is from the same system (radare2) and shares similar architectural patterns. Both involve low-level binary analysis operations, array accesses without sufficient bounds checking (e.g., accessing `buf[i]` after `i` increments), and complex state management. The vulnerability patterns in radare2's codebase are directly relevant for auditing the target function.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 (CVE-2016-7425) is a buffer overflow in a Linux kernel SCSI driver due to missing length validation. While the target code does involve buffer operations and length calculations, the context (kernel driver vs. user-space analysis tool), domain (storage protocols vs. binary analysis), and specific vulnerability patterns differ significantly. Minimal reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 (CVE-2017-15670) is a heap buffer overflow in glibc's glob() function due to off-by-one allocation error. The target code performs memory allocation with size calculations (`iend + 2`). While both involve memory management, the specific vulnerability pattern (off-by-one in path expansion) and domain (library function vs. analysis algorithm) are quite different. Limited reference value for general bounds checking.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 (CVE-2017-13033) is an out-of-bounds read in tcpdump's VTP parser due to insufficient length validation. The target code reads binary data (`r_io_read_at`) and processes it, but operates in a completely different domain (network protocol parsing vs. binary code analysis). While both involve parsing untrusted binary data, the specific patterns and vulnerability contexts are not closely related.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2022-0849_after_subset_100:a71f1147:vulspec": {
    "timestamp": "2026-01-17T03:16:25.968438",
    "cve_id": "CVE-2022-0849",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a71f1147",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in libguestfs related to file content processing and error handling. The target code is an ESIL analysis function in radare2 focused on instruction emulation and cross-reference analysis. The domains (VM disk inspection vs. binary analysis), vulnerability types (double-free vs. potential memory corruption/use-after-free in analysis), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 2 (CVE-2018-12320) is a use-after-free/double-free in radare2's basic block analysis (r_anal_bb_free). The target code is from the same system (radare2) and same core library (libr/anal). Both involve complex analysis data structures, memory management of analysis results, and control flow tracking. The vulnerability patterns (improper cleanup of linked structures) are highly relevant to the target code which manages analysis contexts, buffers, and ESIL state.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 3 (CVE-2013-0339) is an XML external entity injection in libxml2. The target code performs binary analysis and ESIL emulation in radare2. The domains (XML parsing vs. binary analysis), vulnerability types (XXE vs. memory safety), attack surfaces (malicious XML documents vs. malicious binaries), and code patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 (CVE-2016-8670) is a buffer overflow in PHP's GD library due to incorrect bounds checking. The target code involves buffer operations (malloc/read) but focuses on analysis rather than image processing. Some similarity exists in buffer allocation and reading (r_io_read_at, buf usage), but the vulnerability pattern (arithmetic underflow) and domain are different. The target code has bounds checks (iend > MAX_SCAN_SIZE) but could have similar issues in op.size handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 (CVE-2017-15400) is a CRLF injection/command injection in CUPS PPD generation. The target code performs binary analysis with no command execution or text processing vulnerabilities. Different domains (printing system vs. reverse engineering), vulnerability types (injection vs. memory safety), and code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 (CVE-2019-11470) is a resource exhaustion vulnerability in ImageMagick due to unvalidated image dimensions. The target code has some resource allocation (malloc based on iend) and could potentially be abused if iend is manipulated, but it validates against MAX_SCAN_SIZE. Similarities exist in parsing untrusted input (binary code) and allocating buffers based on parsed values, but the vulnerability pattern and domain differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 7 (CVE-2018-19843) is an out-of-bounds read in radare2's x86 assembler. The target code is from the same system (radare2) and shares similar analysis infrastructure. Both involve low-level code analysis, operand handling, and array bounds safety. The target code has multiple array accesses (op.src[], regs[]) and complex state management that could lead to similar bounds issues, especially during error conditions or with malformed binaries.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 (CVE-2016-7425) is a buffer overflow in a Linux kernel SCSI driver due to missing length validation. The target code has buffer operations but in user-space analysis context. Some similarity in reading data into buffers (r_io_read_at) and processing untrusted input (binary code), but the domain (kernel driver vs. user-space analysis) and specific vulnerability patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 (CVE-2017-15670) is a heap buffer overflow in glibc's glob() due to off-by-one allocation. The target code has memory allocations and could have similar off-by-one errors in buffer calculations (iend + 2 allocation, iend - i bounds). However, the domains (library function vs. analysis engine) and specific vulnerability contexts differ. The target code's loop conditions and size calculations warrant similar scrutiny.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 (CVE-2017-13033) is an out-of-bounds read in tcpdump's VTP parser due to missing length validation. The target code parses binary instructions rather than network packets. While both involve parsing untrusted binary data and bounds checking, the domains (network protocol analysis vs. binary code analysis), data structures, and specific vulnerability patterns are quite different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2018-14665_before_subset_100:a28a3e75:vulspec": {
    "timestamp": "2026-01-17T03:16:46.025109",
    "cve_id": "CVE-2018-14665",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a28a3e75",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 is a double-free vulnerability in libguestfs related to error handling and memory ownership. The target code uses `asprintf` and `free` but does not show double-free patterns. The memory management is straightforward, and there is no complex error path that could lead to freeing the same pointer twice. The core flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in CUPS related to improper neutralization of IPP attribute values. The target code performs file operations (rename, remove) using fixed format strings and user-provided `idstring` only within `asprintf` format specifiers. There is no command execution or CRLF sequence handling involved.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves improper input validation leading to path traversal or symlink issues in libarchive. The target code uses `stat`, `rename`, and `remove` on a constructed file path (`logFileName`). If the `idstring` (used in `asprintf` format) contains path traversal sequences (e.g., `../`), it could potentially affect unintended directories, indicating a possible CWE-22 similarity. However, the primary flaw in the target code is not explicitly about path validation, and the historical case focuses on hardlink/symlink race conditions, which are not present here.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is a heap buffer overflow in glibc's glob due to an off-by-one allocation error. The target code uses `asprintf`, which automatically allocates the correct size, and performs file operations. There is no manual buffer allocation or off-by-one calculation pattern. The vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an uncontrolled resource consumption (CWE-400) in ImageMagick due to lack of validation between declared image dimensions and file size. The target code does not parse file formats or allocate memory based on untrusted size values. It allocates strings for filenames, which is bounded by system constraints. The resource exhaustion vector is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is an XXE (XML External Entity) vulnerability in libxml2. The target code does not parse XML or any structured data formats. It deals with file system operations and string formatting. There is no entity expansion or external resource fetching involved.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a use-after-free in Exim related to memory management during SMTP header processing. The target code has simple memory allocation/deallocation (`asprintf`/`free`) but does not exhibit use-after-free patterns. Pointers are freed after use and not referenced again. The memory ownership is linear and clear.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow in PHP's GD library due to incorrect bounds checking and integer underflow. The target code uses safe string formatting functions (`asprintf`) and does not perform manual buffer arithmetic or size calculations. There are no loops or bounds checks that could lead to similar underflow/overflow.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is a use-after-free/double-free in radare2 due to improper cleanup of linked structures with circular references. The target code does not manage linked data structures. It allocates independent strings and frees them in a straightforward manner. The memory corruption patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a race condition in the KVM subsystem related to virtualization state management and error reporting. The target code is a synchronous function performing file operations; there is no concurrency, parallelism, or shared state that could lead to race conditions. The domain and flaw type are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2010-5313"
        }
      }
    ]
  },
  "CVE-2018-14665_after_subset_100:8a5fd570:vulspec": {
    "timestamp": "2026-01-17T03:17:11.646149",
    "cve_id": "CVE-2018-14665",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8a5fd570",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CVE-2013-2124) is a double-free vulnerability in libguestfs related to error handling and memory ownership. The target code uses `free()` correctly and does not show double-free patterns. The core issue and context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 (CVE-2017-15400) is a CRLF injection leading to command injection in CUPS PPD generation. The target code involves file operations (rename, remove) and string formatting but does not involve parsing protocol data, generating configuration files, or command execution. The vulnerability class is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 (CVE-2016-5418) involves improper input validation leading to path traversal and symlink issues in libarchive. The target code uses user-controlled format strings (`fname`, `backup`) to construct file paths, which is a significant similarity. However, the target code does not perform archive extraction or complex symlink handling, and the specific flaw patterns (hardlink processing) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 (CVE-2017-15670) is a heap buffer overflow in glibc's glob due to an off-by-one allocation error. The target code uses `asprintf`, which handles allocation automatically, reducing the risk of manual buffer size miscalculation. The similarity is the use of user-controlled strings in path/string construction, but the specific vulnerability mechanism (off-by-one in allocation) is not present in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 (CVE-2019-11470) is an uncontrolled resource consumption (memory) issue in ImageMagick due to lack of validation between declared and actual data size. The target code allocates memory for filenames, but the scale is limited by the length of the format strings and `idstring`. There is no validation issue akin to image dimensions. The core problem is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability in libxml2. The target code does not parse XML or any structured data format. The only tangential similarity is processing external input (`fname`, `backup`, `idstring`), but the context and exploitation mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CVE-2017-16943) is a use-after-free in Exim related to memory management during SMTP message processing. The target code uses dynamic memory allocation (`asprintf`, `free`) but shows clear ownership (freeing `suffix` and `oldLog` after use, returning `logFileName` to caller). There is no indication of complex pointer aliasing or use-after-free patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 (CVE-2016-8670) is a buffer overflow in PHP's GD library due to incorrect bounds checking and integer underflow. The target code uses `asprintf` which manages its own buffer sizing, avoiding manual bounds calculations. The vulnerability class (arithmetic error leading to buffer overflow) is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 (CVE-2018-12320) is a use-after-free/double-free in radare2 due to improper cleanup of linked data structures. The target code has simple, linear memory allocations without complex data structures or pointer manipulation. The memory management patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 10 (CVE-2010-5313) is a race condition in the Linux KVM subsystem related to virtualization state management. The target code performs basic file operations (stat, rename, remove) which could theoretically be subject to TOCTOU races, but this is not the primary flaw described. The context (kernel virtualization) and vulnerability type (concurrency) are completely different from the target's user-space, single-threaded file preparation logic.",
        "case_metadata": {
          "cve_id": "CVE-2010-5313"
        }
      }
    ]
  },
  "CVE-2022-0685_before_subset_100:8a3d6071:vulspec": {
    "timestamp": "2026-01-17T03:17:54.514551",
    "cve_id": "CVE-2022-0685",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8a3d6071",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve pathname pattern expansion (globbing) with recursive directory traversal. The target code's `unix_expandpath` function handles wildcards (`*`, `?`, `**`) similar to glibc's `glob()`. Both process user-controlled path patterns, perform memory allocation for expanded paths (`buf = alloc(...)`), and recursively traverse directories. The vulnerability type (buffer overflow due to bounds calculation) is highly relevant to the pattern expansion logic and memory management in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a virtual disk inspection library related to file content reading. The target code is a path expansion function that does not involve complex memory ownership or double-free scenarios. The functional domains (file system path expansion vs. VM disk inspection) and flaw types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code processes file system paths and uses regular expressions for pattern matching, but does not parse XML or handle external entities. The attack surfaces and vulnerability mechanisms are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection in a printing protocol. The target code handles file system paths and uses `STRCPY`/`STRNCPY` operations, but doesn't process network protocols or generate configuration files with injection vulnerabilities. The domains and flaw types are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Both involve filesystem operations during path processing. The target code uses `opendir()`, `readdir()`, and constructs paths with `STRCPY`, which could be vulnerable to path traversal or symlink attacks if input isn't properly sanitized. While the specific hardlink vulnerability isn't present, the general category of filesystem path validation issues is relevant to the target's directory traversal and path concatenation logic.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The target code uses regular expressions (`vim_regcomp`, `vim_regexec`) for pattern matching, similar to Oniguruma's functionality. Both process user-supplied patterns that could trigger engine-specific vulnerabilities. However, the specific out-of-bounds read from integer overflow in pointer arithmetic is less likely in Vim's regex implementation, which appears more constrained.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13715 is a kernel network protocol parsing issue with uninitialized memory. The target code is a user-space file path expansion function. While both parse structured input, the domains (network packets vs. file paths), environments (kernel vs. application), and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Both involve memory management (allocation/freeing). The target code uses `alloc()`/`vim_free()` and could potentially have use-after-free issues if error paths aren't handled correctly. However, the specific double-free via linked list manipulation in a reverse engineering tool is not directly analogous to the simpler memory management in the path expansion function.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve parsing structured input (path patterns vs. network packets) and could have bounds checking issues. The target code uses `STRNCPY` with length calculations and has multi-byte handling, which requires careful bounds management. However, the specific out-of-bounds read in a network protocol dissector is quite different from file path processing, though both share the general theme of input validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2022-0685_after_subset_100:1db61766:vulspec": {
    "timestamp": "2026-01-17T03:18:08.516687",
    "cve_id": "CVE-2022-0685",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1db61766",
    "scores": [
      {
        "score": 8,
        "reasoning": "Strong relevance. Both involve pathname pattern expansion (globbing) with wildcards (*, ?, []) and recursive directory traversal (**). The target code's `unix_expandpath` function shares the core functionality of CVE-2017-15670's `glob()`: expanding shell-style patterns, handling recursion, and managing memory for matched paths. The vulnerability type (buffer overflow due to off-by-one/incorrect bounds) is highly relevant, as the target code performs complex string manipulation and memory allocation (`buf = alloc(...)`). The attack surface (malicious path patterns) is identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a library for inspecting VM disk images, related to file content reading and error handling. The target code is a path expansion function that does not involve reading file contents, complex ownership semantics, or the specific error handling patterns that lead to a double-free. The functional domains are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code processes filesystem paths and directory listings, not XML data or external entities. There is no overlap in functionality, vulnerability type, or attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The only similarity is that both involve parsing external input (file paths vs. image headers). The vulnerability type (CWE-400: Uncontrolled Resource Consumption) has some tangential relevance because the target code's recursive `**` expansion with `stardepth` could theoretically lead to excessive resource use, but this is a controlled recursion limit, not an unbounded allocation based on unvalidated input like in the ImageMagick case. The core flaw patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection vulnerability in a printing protocol handler. The target code performs filesystem operations and pattern matching but does not generate protocol output, process CRLF sequences, or execute commands. The domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Both involve filesystem operations during the processing of external input (path patterns vs. archive entries). CWE-20 (Improper Input Validation) is relevant because the target code validates path components against a regex pattern and checks file existence. However, the specific flaw in libarchive (improper link resolution and path validation leading to filesystem state inconsistency) is not directly mirrored. The target code's use of `stat`/`lstat` and path concatenation could have similar validation pitfalls, but the context is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The connection is through the use of regular expressions. The target code compiles a path pattern into a regex (`vim_regcomp`) and executes it (`vim_regexec`). CVE-2019-19012 is an out-of-bounds read in a regex engine due to integer overflow in pointer arithmetic. While the target code uses a regex engine (likely Vim's own), there is no visible pointer arithmetic or distance calculation in the provided snippet that mirrors the specific flaw. The relevance is limited to the shared component (regex evaluation).",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13715 is an uninitialized memory issue in a network packet dissector. The target code is a user-space filesystem path expansion function. The domains (networking vs. filesystem), data structures, and error handling patterns are completely different. No meaningful overlap.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool's analysis data structure cleanup. The target code manages dynamic memory (`alloc`/`vim_free`) but does not show complex linked data structures or the specific cleanup sequence that leads to a use-after-free. The memory management is relatively straightforward in comparison.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The connection is through insufficient input validation leading to out-of-bounds read (CWE-125). The target code validates path components via regex matching and string functions (`STRCPY`, `STRNCPY`). While bounds checking is crucial (e.g., `STRLEN(path) + BASENAMELEN + 5`), the provided code does not show an obvious length validation flaw akin to the VTP packet parsing. The relevance is generic (importance of input validation) rather than specific to the flaw pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2020-35492_before_subset_100:1cf31f48:vulspec": {
    "timestamp": "2026-01-17T03:18:19.803019",
    "cve_id": "CVE-2020-35492",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1cf31f48",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a file processing function within libguestfs. The target code is a low-level graphics rendering function in a library like Cairo or Pixman, performing pixel composition operations. The domains (virtual machine disk inspection vs. graphics rendering), vulnerability types (memory ownership error vs. potential arithmetic/logic flaw), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 is a resource consumption vulnerability (CWE-400) in an image format decoder due to lack of validation of dimensions. The target code processes pre-defined spans and performs pixel operations; it does not parse external file headers or allocate memory based on untrusted dimensions. The core flaw (unvalidated input leading to excessive allocation) is not present in the target code's logic.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is a buffer bounds vulnerability (CWE-119) in PHP's GD library, related to incorrect bounds checking during image data transfer. The target code also manipulates memory buffers (`r->_buf`, `m`) and performs operations based on span lengths (`len`). While the specific trigger (arithmetic underflow) is not obvious in the target code, the pattern of writing to a buffer (`*m++`, `memset`) based on calculated lengths shares conceptual similarity with buffer handling vulnerabilities. The domain (image/graphics processing) is also related.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is an injection vulnerability (CWE-93) in a printing system's PPD file generator. The target code performs mathematical pixel composition operations with no string processing, command generation, or CRLF sequences involved. The domains and vulnerability classes are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a use-after-free/double-free (CWE-416) in a reverse engineering tool's data structure cleanup. The target code does not perform dynamic memory allocation or deallocation within the shown function; it operates on provided buffers and renderer structures. The memory management patterns and flaw types are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is an uninitialized memory vulnerability (CWE-665) in a network packet dissector. The target code initializes its pointers (`m = r->_buf`) and operates on clearly defined data. While both involve low-level system code, the specific flaw (leaving state uninitialized on error paths) is not evident in the target code's straightforward loop and conditional structure.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate to strong relevance. Case 7 is a buffer overflow (CWE-119) in a kernel driver due to insufficient validation of a length parameter before a memory operation. The target code contains a similar pattern: it calculates a length (`len = spans[1].x - spans[0].x`) and uses it in a memory operation (`memset(m, spans[0].coverage, --len)`). If the `spans` array is malformed or the indices are miscalculated, `len` could be negative or excessively large, leading to a buffer overflow on the `m` buffer. This mirrors the core issue of using an unvalidated, calculated length for a buffer operation. The main difference is the context (SCSI driver vs. graphics renderer).",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 8 is a reachable assertion (CWE-617) due to lack of validation on a numeric input field in an image decoder. The target code does not contain assertions or parse similar numeric metadata from files. However, a tangential similarity exists: both involve processing external input (spans data vs. file header) that could be malformed, though the validation failure modes are different (assertion crash vs. buffer corruption).",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is an out-of-bounds read (CWE-125) due to lack of validation of image dimensions. The target code does not validate the `spans` array indices or the calculated `len` before using it in `memset`. A maliciously crafted `spans` array could cause an out-of-bounds write on the `m` buffer, which is a similar consequence (memory corruption) stemming from insufficient input validation. The vulnerability class (bounds violation) is related, though the primacy of the flaw in the target code is less clear than in Case 7.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 is a buffer overflow (CWE-119) in a network driver due to incorrect assumptions about fragment counts. The target code involves buffer writes but does not deal with packet fragmentation or similar dynamic aggregation. The similarity is only at the high level of \"buffer operation,\" but the mechanisms leading to the overflow (feature negotiation vs. span length calculation) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2020-35492_after_subset_100:c7e13658:vulspec": {
    "timestamp": "2026-01-17T03:18:23.929032",
    "cve_id": "CVE-2020-35492",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "c7e13658",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a Cairo image span renderer performing pixel operations with fixed logic and no dynamic memory allocation/deallocation. CVE-2013-2124 is a double-free vulnerability in libguestfs involving complex error handling and memory ownership. The vulnerability types, code patterns, and functional domains (graphics rendering vs. VM disk inspection) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2019-11470 is a resource consumption vulnerability in ImageMagick due to lack of validation between image dimensions and file data. The target code processes pre-defined spans with length calculations but does not parse file headers or allocate memory based on untrusted input. Both involve image processing but the flaw pattern (unvalidated allocation vs. in-place pixel blending) and attack surface are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-8670 is a buffer bounds vulnerability in PHP's GD wrapper due to incorrect bounds checking and arithmetic underflow. The target code performs bounds-checked operations on span arrays and uses `len` calculations, but these are based on internal span coordinates, not untrusted image data. There is weak relevance in the general area of bounds checking during image operations, but the specific flaw mechanism and context differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-15400 is a CRLF injection/command injection vulnerability in CUPS during PPD file generation. The target code is a pure graphics rendering function with no string processing, file I/O, or command execution. There is essentially no relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free vulnerability in radare2's basic block analysis due to improper linked list cleanup. The target code has no dynamic memory management of complex data structures, no pointers being freed, and operates on simple local variables and renderer state. The vulnerability class is irrelevant to the target's functionality.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-13715 is an uninitialized memory vulnerability in the Linux kernel flow dissector due to improper state cleanup on error paths. The target code initializes local variables and has straightforward error handling (early return on num_spans==0). While both involve processing sequences (packets/spans), the target code lacks the complex state machine and error path that leads to the uninitialized read. Relevance is very low.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7425 is a buffer overflow in a kernel SCSI driver due to insufficient validation of a user-controlled length parameter. The target code does contain length calculations (`len = spans[1].x - spans[0].x`) and uses this `len` for operations (memset). If the span array were maliciously crafted, an integer underflow/overflow in this subtraction could theoretically lead to a buffer overflow in the `memset` operation. This provides moderate relevance regarding the pattern of calculating lengths from untrusted data without validation. However, the target code's context (graphics renderer internal data) is typically more trusted than a driver's IOCTL interface.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-9499 is a reachable assertion vulnerability in ImageMagick due to lack of validation on a numeric input field. The target code does not parse file headers, has no assertions, and does not convert string inputs to numeric values. The only weak link is that both are in the broad domain of image processing, but the flaw mechanism is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7101 is an out-of-bounds read in ImageMagick due to insufficient validation of image dimensions from a file header. The target code uses dimensions (span coordinates) to calculate lengths and access memory. If the coordinate values were malicious (e.g., causing negative `len`), similar memory safety issues could arise. This provides weak-to-moderate relevance regarding the pattern of using arithmetic on untrusted coordinates without sufficient sanity checks. However, the attack surface (internal renderer state vs. file parsing) is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2015-5156 is a buffer overflow in a virtio network driver due to incorrect feature declaration leading to insufficient buffer allocation for fragmented packets. The target code has no network functionality, no packet fragmentation logic, and no dynamic buffer allocation based on feature negotiation. The only tangential similarity is the presence of buffer operations (memset) and length calculations, but the core flaw is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2015-8803_before_subset_100:a189c989:vulspec": {
    "timestamp": "2026-01-17T03:18:46.424928",
    "cve_id": "CVE-2015-8803",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a189c989",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a file processing module of a virtual machine management tool. The target code is a low-level mathematical function (ECC modular reduction) performing arithmetic operations on multi-precision integers. There is no overlap in vulnerability type, domain, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 involves a use-after-free/double-free (CWE-416) in a reverse engineering framework related to linked list cleanup. The target code is a cryptographic arithmetic function with no dynamic memory management (deallocation) or pointer-based data structures. The domains and flaw mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 3 is an XXE vulnerability (CWE-611) in an XML parser. The target code is a numerical algorithm for elliptic curve cryptography. There is no functional or vulnerability pattern overlap.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an out-of-bounds read (CWE-125) in an assembler due to missing bounds checks on an array index. The target code performs arithmetic with careful bounds assertions (`assert (q2 < 2)`). While both involve low-level operations, the vulnerability type (OOB read vs. potential arithmetic/logic error) and context (parsing vs. computation) are different. The target code's primary risk would be a logic or integer overflow bug, not a classic bounds violation on a fixed array.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is a heap buffer overflow (CWE-122) due to an off-by-one allocation error in a path expansion function. The target code performs in-place arithmetic on a passed limb array `rp`. It does not perform its own dynamic memory allocation. The potential for overflow exists but is of a different nature (integer overflow in arithmetic leading to incorrect results, not memory corruption).",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow (CWE-119) in a network driver due to incorrect feature negotiation and fragment count handling. The target code is a mathematical function. The weak link is the concept of insufficient validation of input/state leading to incorrect operations. The target code's `assert` is a form of validation, but the scale and context (crypto math vs. packet processing) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a stack buffer overflow (CWE-119) in a USB driver related to DMA and buffer management. The target code has no interaction with hardware, DMA, or user-controlled buffers of variable size. The arithmetic operations are on fixed-size multi-precision integers.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is a buffer overflow (CWE-119) in a SCSI driver due to missing validation of a length parameter. The target code operates on a fixed-size mathematical representation. The relevance is limited to the abstract principle of validating inputs/limits before operations, but the implementation domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 9 is a NULL pointer dereference (CWE-476) in the Linux kernel's cryptographic MPI library due to improper input validation (CWE-20) of a zero exponent. The target code is also a low-level cryptographic arithmetic function (ECC) within a similar domain. Both involve careful manipulation of multi-precision integers (`mp_limb_t`). The vulnerability pattern (missing validation of edge cases in crypto math leading to a crash or incorrect result) is similar. However, the specific flaw (NULL deref vs. potential arithmetic overflow/wrap-around) and the function's purpose (modular exponentiation vs. modular reduction) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-8650"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 is an improper initialization (CWE-665) leading to information disclosure in a network packet dissector. The target code initializes local variables (`u1`, `u0`) from the input array and manages state carefully within a loop. While both involve state management during parsing/computation, the vulnerability type (uninitialized memory exposure) is not apparent in the target code, which explicitly sets all working variables.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-29207_before_subset_100:bbd20934:vulspec": {
    "timestamp": "2026-01-17T03:19:46.566033",
    "cve_id": "CVE-2022-29207",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "bbd20934",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves CRLF injection and command injection in a printing system's PPD file generation. The target code is a TensorFlow device placement function dealing with memory types, device selection, and resource handles. The domains (printing vs. ML framework), vulnerability types (injection vs. potential logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a double-free vulnerability in a file reading function within a VM disk inspection library. The target code performs device logic based on tensor handle properties and does not involve dynamic memory allocation or deallocation. The core flaw patterns (memory ownership errors vs. device state logic) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a buffer overflow in a network driver due to incorrect feature declaration and fragment count handling. The target code performs conditional branching and device assignment with no array/buffer operations, no network packet processing, and no direct memory bounds checking issues. The vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a reachable assertion due to lack of validation on an input numeric field. The target code does contain input processing (reading a device name from a ResourceHandle) and could theoretically have issues if `device_name` is malformed, leading to a failure in `FindDeviceFromName`. However, the specific flaw pattern (assertion on a channel count) and domain (image processing vs. device management) are very different. The similarity is only in the broad concept of missing validation on external data.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is an uncontrolled resource consumption (DoS) via unvalidated image dimensions leading to huge memory allocation. The target code does not parse file headers or allocate memory based on untrusted size fields. The only tangential similarity is the processing of external data (the ResourceHandle), but the consequence path (device lookup failure vs. memory exhaustion) and code patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow due to incorrect bounds checking and integer underflow in an image library. The target code contains no buffer operations, no arithmetic on sizes, and no loops over data buffers. The code patterns and vulnerability class are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an integer overflow leading to an infinite loop in a filesystem block mapping function. The target code performs simple assignments and condition checks; it contains no loops, no block size calculations, and no integer arithmetic that could overflow. The flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an improper input validation leading to path traversal and filesystem state issues in an archive library. The target code validates device names via `FindDeviceFromName` but operates in a completely different domain (ML runtime vs. filesystem). The attack surfaces (archive files vs. serialized graphs/tensors) and resulting risks are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an improper initialization leading to uninitialized memory exposure in a network packet parser. The target code initializes local pointers and strings but does not parse complex protocol headers or have error paths that skip initialization of sensitive data. The code structure and vulnerability pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a use-after-free/double-free in a linked structure cleanup function within a reverse engineering tool. The target code has no linked data structures, no manual memory management (`free` operations), and its logic revolves around object references managed by the TensorFlow runtime. The memory safety flaw pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      }
    ]
  },
  "CVE-2015-8803_after_subset_100:87964959:vulspec": {
    "timestamp": "2026-01-17T03:19:50.382582",
    "cve_id": "CVE-2015-8803",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "87964959",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a low-level cryptographic modular reduction function (ECC 256-bit) performing arithmetic operations on multi-precision integers. Case 1 (CVE-2013-2124) is a double-free vulnerability in a high-level file processing function within a virtual machine inspection library. The domains (cryptography vs. VM file I/O), vulnerability types (arithmetic/logic errors vs. memory management), and code patterns are fundamentally different. There is almost no reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 2 (CVE-2018-12320) is a use-after-free/double-free in a reverse engineering framework's data structure cleanup code. The target code performs deterministic mathematical computations on limb arrays without dynamic memory allocation or pointer-based data structures within the function. The flaw patterns (linked list management errors vs. integer arithmetic) and attack surfaces are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Case 3 (CVE-2013-0339) is an XML External Entity (XXE) vulnerability in a parsing library. The target code is a mathematical function with no parsing logic, no external input handling, and no entity resolution mechanisms. The relevance is virtually non-existent.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 4 (CVE-2018-19843) is an out-of-bounds read in an assembler due to missing bounds checks on an array index. The target code does perform array accesses (`rp[n]`, `p->m`), but they are carefully bounded by the loop condition `n >= p->size` and the known size of the modulus array. While both involve array indexing, the vulnerability pattern (missing validation of user-controlled index vs. algorithmically controlled indexing) and context (assembly parsing vs. modular arithmetic) are very different. Only a weak similarity in the concept of array access exists.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 5 (CVE-2017-15670) is a heap buffer overflow due to an off-by-one allocation error in a path expansion function. The target code manipulates fixed-size multi-precision integers and does not perform dynamic memory allocation. The core flaw (allocation miscalculation) is not present. A faint similarity exists in the need for precise bounds management, but the mechanisms are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Case 6 (CVE-2015-5156) is a buffer overflow in a network driver due to incorrect assumptions about fragment counts. The target code involves buffer operations (`mpn_submul_1`, `cnd_sub_n`) on fixed-size mathematical arrays. While both involve potential for miscalculated operations on buffers, the target code's operations are purely arithmetic and bounded by the algorithm's structure, not by variable external input like packet fragments. The flaw pattern (resource exhaustion/assumption violation) is somewhat related but implemented in vastly different contexts.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 7 (CVE-2017-8068) is a stack buffer overflow/DMA issue in a USB driver. The target code uses stack variables (u1, u0, t, etc.) for intermediate calculations but does not expose them to external DMA or perform unchecked copies into them. The vulnerability pattern (improper buffer handling for external data transfer) does not align with the internal arithmetic of the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 4,
        "reasoning": "Case 8 (CVE-2016-7425) is a buffer overflow in a SCSI driver due to insufficient validation of a length parameter. The target code does not parse variable-length input from an untrusted source; it operates on a fixed-size representation of a number. The concept of missing validation before a memory operation is a high-level similarity, but the execution (user-controlled length field vs. algorithmically derived loop counters) and consequence (heap corruption vs. mathematical error) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 7,
        "reasoning": "Case 9 (CVE-2016-8650) is a NULL pointer dereference in the Linux kernel's cryptographic MPI library during modular exponentiation. This is the most relevant case. Both the target code and the vulnerable code are low-level cryptographic arithmetic functions (modular reduction vs. modular exponentiation) operating on multi-precision integers (mp_limb_t arrays). Both are susceptible to edge case errors in their algorithms. The specific flaw in Case 9 (missing check for a zero exponent leading to a NULL dereference) is different from the potential flaws in the target code (e.g., carry propagation errors, incorrect bounds in loops), but the domain, data structures, and the critical nature of validating all algorithmic edge cases are strongly similar. This provides valuable reference for reviewing the target code's handling of edge cases like extreme values of `u1` and `u0`.",
        "case_metadata": {
          "cve_id": "CVE-2016-8650"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 10 (CVE-2017-13715) is an uninitialized memory exposure in a network packet parser due to improper state cleanup on error paths. The target code has a clear, linear flow without complex error state recovery. It initializes its working variables (u1, u0) at the start. The flaw pattern (failing to re-initialize state after an error) is not applicable to the straightforward, mathematical algorithm presented.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-29207_after_subset_100:0e7d849d:vulspec": {
    "timestamp": "2026-01-17T03:20:07.046471",
    "cve_id": "CVE-2022-29207",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0e7d849d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection in a printing system's PPD file generation. The target code is a TensorFlow device placement function dealing with tensor handles and resource validation. The domains (printing vs. ML framework), vulnerability types (injection vs. potential logic/validation errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2013-2124 is a double-free memory corruption vulnerability in a file reading function. The target code performs device lookup and resource validation without dynamic memory allocation or deallocation in the shown path. Both involve error handling, but the core flaw (memory ownership) is not present in the target code's logic flow.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-9499 involves insufficient validation of numeric input leading to a reachable assertion. The target code has a validation check (`if (tensor->NumElements() == 0)`), but the context is different (resource handle validation vs. image channel validation). Both highlight the importance of validating external/parsed data, but the vulnerability patterns (assertion crash vs. potential logic error) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-11470 involves uncontrolled resource consumption due to unvalidated image dimensions. The target code validates that a resource handle tensor is not empty. Both involve checking properties of parsed data structures, but the scale and consequence (DoS via memory exhaustion vs. early error return) are different. The code patterns (size validation vs. element count check) are superficially similar but not indicative of the same flaw.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-8670 is a buffer overflow due to incorrect bounds checking and integer underflow in image processing. The target code performs device logic and simple pointer assignments. There is no arithmetic on sizes or buffer indexing that could lead to similar underflow/overflow conditions.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2017-18257 is an integer overflow leading to an infinite loop in a filesystem block mapping function. The target code contains no loops or arithmetic operations on block sizes or indices. The domains and code constructs are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2016-5418 involves improper input validation of archive paths leading to filesystem issues. The target code validates a tensor's element count but does not process file paths or links. The general principle of validating inputs is shared, but the specific vulnerability type and attack surface are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-13715 is an uninitialized memory exposure in a network packet parser. The target code initializes local variables (e.g., `device_name`) and assigns results before use. There is no complex parsing state or error path that leaves variables uninitialized in a similar way.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. CVE-2018-12320 is a use-after-free/double-free in a linked structure cleanup function. The target code manages device pointers and tensor handles but does not show explicit memory deallocation or complex linked data structure manipulation. The potential for pointer misuse exists but follows a very different pattern.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      }
    ]
  },
  "CVE-2019-19045_before_subset_100:415e514a:vulspec": {
    "timestamp": "2026-01-17T03:20:21.869958",
    "cve_id": "CVE-2019-19045",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "415e514a",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a userspace library (libguestfs) related to file content processing. The target code is a kernel driver function for creating a Completion Queue (CQ) in an InfiniBand context. The memory management patterns (kvzalloc/kvfree), error handling paths, and overall domain (kernel vs. userspace, networking vs. VM inspection) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow (CWE-119) in a SCSI driver due to insufficient validation of user-controlled length parameters. The target code also deals with hardware/driver interaction and memory allocation, but its primary operations involve fixed-size structure manipulation (MLX5_SET macros), pre-calculated buffer sizes (inlen), and filling page fragment arrays. There is no obvious user-controlled length parameter being processed without validation in the target code's shown path.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is a buffer overflow in a network driver (virtio-net) due to incorrect feature declaration and insufficient buffer allocation for fragmented packets. The target code is for setting up a hardware queue (CQ) in an InfiniBand driver. While both are kernel drivers, the vulnerability pattern (feature negotiation, packet fragmentation) and the core functionality (network packet processing vs. queue creation) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 involves an integer overflow (CWE-190) in an ALSA component leading to incorrect memory allocation. The target code performs size calculations (`roundup_pow_of_two`, `ilog2`) and uses `kvzalloc` with a calculated `inlen`. While there is a potential for miscalculation in `inlen` (which includes `sizeof(u64) * npages`), the code pattern is different from the specific flawed overflow check in the ALSA case. The similarity lies in the general category of size calculation before allocation.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a buffer copy without size check (CWE-120) in QEMU's virtio-serial emulation, involving scatter-gather lists from an untrusted guest. The target code is a kernel driver function that populates buffers with driver-controlled data (page fragment addresses) to be sent to hardware. There is no processing of untrusted descriptor chains or variable-length data from an external entity in the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a stack buffer overflow/DMA issue in a USB network driver. The target code uses heap allocation (`kvzalloc`) for the `in` buffer and deals with DMA addresses (`dbr_addr`), but the vulnerability context (VMAP_STACK, USB control messages) and the specific flaw (using stack buffer for DMA) are not present. The memory management model is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a race condition (CWE-362) leading to use-after-free (CWE-416) in the TTY subsystem. The target code is a setup function (`mlx5_fpga_conn_create_cq`) that is not inherently prone to concurrent access in the shown snippet. It manages its own resources (CQ, WQ) and does not expose shared state pointers to concurrent operations in a similar way.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an integer overflow (CWE-190) leading to an infinite loop (CWE-835) in a filesystem (F2FS) block mapping function. The target code performs arithmetic (`roundup_pow_of_two`, `ilog2`) but these are on function arguments and structure fields, not on user-controlled file extents. The domain and the consequence (loop vs. allocation) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 is an off-by-one buffer overflow (CWE-119) in an SPI flash controller driver during device tree parsing. The target code does not parse arrays or device tree properties. It uses a fixed-size array (`temp_cqc`) for initial setup but accesses it via safe MLX5_SET macros. The vulnerability patterns are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2016-10764"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. Case 10 is an information exposure (CWE-200) via uninitialized memory in the mlx5_ib driver during QP creation. The target code is from the `mlx5_fpga` driver, which is part of the same broader mlx5 kernel driver family for Mellanox hardware. Both involve the creation of hardware objects (CQ vs. QP) using similar driver patterns and MLX5 kernel APIs. The key similarity is the pattern of preparing a command buffer (`in`) with context data (cqc) to be sent to the hardware via `mlx5_core_create_cq`. While the specific vulnerability (uninitialized stack struct) is not immediately evident in the target code, the code structure, macros (MLX5_SET), and the process of building hardware commands are nearly identical. This provides extremely valuable reference for understanding potential flaw patterns in this specific driver family.",
        "case_metadata": {
          "cve_id": "CVE-2018-20855"
        }
      }
    ]
  },
  "CVE-2019-19045_after_subset_100:9e8ecfa8:vulspec": {
    "timestamp": "2026-01-17T03:20:27.740904",
    "cve_id": "CVE-2019-19045",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9e8ecfa8",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 is a double-free (CWE-415) in a userspace library (libguestfs) related to file content processing. The target code is a kernel driver function for hardware resource (CQ) creation with careful error handling using goto chains and kvfree. The memory management patterns and context are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 2 is a buffer overflow (CWE-119) in a SCSI driver due to insufficient validation of user-controlled length parameters. The target code performs buffer allocation based on a calculated `inlen` and uses kernel utilities like `kvzalloc` and `mlx5_fill_page_frag_array`. While both are kernel drivers, the vulnerability pattern (untrusted input validation leading to overflow) is not evident in the target code's logic for CQ creation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 3 is a buffer overflow (CWE-119) in a network driver due to incorrect feature declaration and insufficient buffer allocation for fragmented packets. The target code deals with internal Completion Queue (CQ) setup for an FPGA connection. It allocates buffers with a calculated size and initializes CQE entries. The context of network packet processing vs. hardware queue management is dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is an integer overflow (CWE-190) in an audio subsystem leading to incorrect memory allocation. The target code uses `roundup_pow_of_two` and `ilog2` on the `cq_size` parameter, which could theoretically be a source of integer issues if `cq_size` is uncontrolled. However, the function is static and `cq_size` likely comes from a trusted caller within the same driver. The pattern is superficially similar (size calculations for allocation) but the risk profile and context differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 5 is a buffer copy without size check (CWE-120) in QEMU virtio-serial emulation, involving untrusted guest descriptors. The target code is a kernel driver for physical hardware (Mellanox FPGA), where data buffers (like `pas`) are filled from internal driver-controlled structures (`conn->cq.wq_ctrl.buf`). The threat model (malicious guest VM vs. internal driver logic) is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2015-5745"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 6 is a stack buffer overflow/DMA issue (CWE-119) in a USB network driver. The target code uses heap allocation (`kvzalloc`) for the `in` buffer and passes it to `mlx5_core_create_cq`. There is no use of stack buffers for DMA or similar problematic patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a race condition leading to use-after-free (CWE-362/416) in the TTY subsystem. The target code is a resource creation function (`mlx5_fpga_conn_create_cq`) that is not obviously re-entrant or susceptible to concurrent access issues in the shown snippet. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is an integer overflow leading to an infinite loop (CWE-190/835) in a filesystem's block mapping logic. The target code performs arithmetic for buffer size and page shifts but does not contain loops dependent on user-controlled integers that could overflow. The functionality domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an off-by-one buffer overflow (CWE-119) in an SPI flash controller driver during device tree parsing. The target code does not parse external device tree data or contain array accesses with explicit bounds checking that could be off-by-one. The code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-10764"
        }
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Case 10 is an information exposure (CWE-200) via uninitialized memory in the mlx5_ib driver (same hardware family and kernel subsystem). The target code is from `mlx5_fpga_conn_create_cq` in the mlx5 FPGA driver. Both are part of the broader mlx5 kernel driver suite for Mellanox devices. The vulnerability pattern involves kernel-to-userspace or hardware communication where uninitialized stack or heap structures could be leaked. The target code uses `kvzalloc` with `GFP_KERNEL` to zero-initialize the `in` buffer, which is a good practice that mitigates this specific flaw. However, the architectural context, driver patterns, and the risk of improper initialization when preparing command buffers (like `temp_cqc`, `cqc`) for hardware are highly similar and provide valuable reference for auditing this code.",
        "case_metadata": {
          "cve_id": "CVE-2018-20855"
        }
      }
    ]
  },
  "CVE-2022-25761_before_subset_100:ca1d4e74:vulspec": {
    "timestamp": "2026-01-17T03:21:19.381223",
    "cve_id": "CVE-2022-25761",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ca1d4e74",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a USB network driver stack buffer overflow and DMA safety issues. The target code is a high-level secure channel setup function in a user-space library (likely OPC UA), dealing with policy, certificates, and connection state. The domains (kernel driver vs. application protocol), vulnerability types (memory corruption vs. potential logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is a double-free in a file processing utility. The target code shows initialization and state setting for a secure channel object. There are no visible dynamic memory allocations, deallocations, or file operations in the provided snippet. The functional domains and potential flaw patterns do not align.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in a linked structure within a binary analysis tool. The target code performs structured initialization and attachment of components (policy, certificate, connection). There is no visible manipulation of pointer-based data structures or complex cleanup that would lead to memory lifecycle issues in this snippet.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability in an XML parser. The target code sets up a cryptographic secure channel. The domains (document parsing vs. secure communications), data formats (XML vs. binary protocols), and vulnerability classes (input validation/entity expansion vs. potential cryptographic or state management flaws) are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is a CRLF injection leading to command injection in a printing system's PPD generator. The target code configures a secure channel object. There is no text-based template generation, command execution, or input validation of untrusted strings visible in the provided code. The attack surfaces are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2018-1000852"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 is a kernel virtio-net driver buffer overflow due to incorrect feature negotiation and fragment handling. The target code is user-space application/library code for secure channel establishment. The level of abstraction, system component (kernel driver vs. user-space library), and vulnerability mechanism are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a buffer overflow in a kernel SCSI driver due to lack of input validation on length fields. The target code performs initialization and binding of components. There is no parsing of untrusted length fields or direct buffer operations in the provided snippet. The contexts are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read in a network packet analyzer (tcpdump) while parsing a specific BGP attribute. The target code sets up a secure channel for communication but does not contain any visible packet dissection or protocol parsing logic with length field validation.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an improper initialization leading to information disclosure in the Linux kernel's flow dissector. The target code explicitly initializes a channel object and sets its state. While both involve initialization, the nature is different: one is a complex state machine for packet parsing prone to error-path leaks, the other is a straightforward application-level object setup. The risk profile and context (kernel vs. user-space) are mismatched.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-25761_after_subset_100:617626c5:vulspec": {
    "timestamp": "2026-01-17T03:21:28.705518",
    "cve_id": "CVE-2022-25761",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "617626c5",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 is a kernel-level USB driver stack buffer overflow (CWE-119). The target code is user-space application code for setting up a secure channel in what appears to be an OPC UA implementation. The domains (kernel driver vs. application protocol), vulnerability types (buffer overflow vs. potential logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a double-free (CWE-415) in a virtual disk image inspection library. The target code shows initialization and state setting for a secure channel object. There is no visible dynamic memory allocation or deallocation in the provided snippet. The functional domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free (CWE-416) in a binary analysis tool related to linked list cleanup. The target code is initializing and configuring a secure channel structure. No complex data structure cleanup or pointer manipulation is shown. The contexts are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in an XML parser. The target code deals with secure channel setup, policy assignment, and connection attachment for a communication protocol. There is no parsing of untrusted data formats like XML in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a CRLF injection/command injection (CWE-93) in a printing system's PPD file generation. The target code involves setting security policies and channel states. There is no generation of configuration files or neutralization of sequences from untrusted input visible.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 6 is an out-of-bounds read (CWE-125) in a protocol implementation (RDP) during fragmented data reassembly. The target code also implements part of a protocol (OPC UA SecureChannel). While both involve protocol state management, the specific vulnerability type (bounds checking on reassembly) is not apparent in the simple setup code shown. The connection is thematic but not specific.",
        "case_metadata": {
          "cve_id": "CVE-2018-1000852"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is a kernel virtio-net driver buffer overflow (CWE-119) from incorrect feature negotiation. The target code is user-space application code for channel initialization. The vulnerability mechanism (incorrect buffer sizing for features) does not align with the high-level API calls shown.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a SCSI driver buffer overflow (CWE-119) from lack of input validation. The target code shows trusted initialization calls (`UA_SecureChannel_init`, `UA_SecureChannel_setSecurityPolicy`). There is no processing of untrusted length fields or direct buffer operations.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an out-of-bounds read (CWE-125) in a packet parser (tcpdump) due to insufficient bounds checking on TLV attributes. The target code does not parse any network packet data; it sets up the channel that would later handle packets. The vulnerability pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-12994"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 is improper initialization (CWE-665) in a network flow dissector leading to uninitialized memory exposure. The target code involves initializing a `UA_SecureChannel` structure and setting its state. There is a thematic connection regarding the importance of correct initialization and state management in security-sensitive code. However, the specific flaw (leaving struct fields uninitialized on error paths) is not visible in this snippet, and the domains (kernel packet dissection vs. application protocol channel) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-0322_before_subset_100:0155b048:vulspec": {
    "timestamp": "2026-01-17T03:21:49.422196",
    "cve_id": "CVE-2022-0322",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0155b048",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free (CWE-415) in a user-space library (libguestfs) for file processing. The target code is a kernel SCTP networking function performing memory chunk construction with no dynamic memory deallocation. The domain, vulnerability type, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 2 involves improper initialization (CWE-665) leading to information leak in the Linux kernel's network flow dissector. While both are in the kernel networking domain, the flaw patterns differ significantly. The target code constructs a message with explicit assignments and no obvious uninitialized data exposure. The relevance is limited to the broader kernel networking context.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free (CWE-416) in a user-space reverse engineering tool (radare2) related to linked list cleanup. The target SCTP code performs controlled chunk assembly with no pointer-based structure deallocation or reuse. The domains and vulnerability mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow (CWE-119) in PHP's image processing due to an integer underflow/overflow in bounds checking. The target code uses arithmetic (`stream_num * sizeof(__u16)`) to calculate a length, which could theoretically overflow if `stream_num` is large, but this is not the core flaw pattern shown. The primary function is structured data serialization, not buffer manipulation with direct bounds checks. Some tangential similarity in integer arithmetic for size calculation exists.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 5 is a buffer overflow (CWE-119) in the Linux kernel's virtio-net driver due to incorrect feature declaration and insufficient buffer allocation. The target code is also in the Linux kernel and involves network protocol (SCTP) message construction. While the specific flaw (fragment handling vs. parameter chunk assembly) differs, both involve calculating buffer sizes and adding data to kernel structures. The pattern of building a data structure with variable-length components is conceptually similar, providing some reference value for kernel network subsystem vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 6 is an injection vulnerability (CWE-93) in a user-space printing system (CUPS) due to improper neutralization of CRLF sequences. The target code is a kernel function that serializes binary structures with no text-based parsing or command generation. No meaningful similarity in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 is a resource consumption vulnerability (CWE-400) in ImageMagick due to lack of validation between declared image dimensions and actual data. The target code performs a multiplication (`stream_num * sizeof(__u16)`) which, if `stream_num` is attacker-controlled and very large, could lead to excessive memory allocation in `sctp_make_reconf`. However, the target code's primary purpose is not dimension parsing, and the vulnerability pattern (unvalidated multiplication leading to large allocation) is only a potential side concern, not the demonstrated core functionality.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 is an out-of-bounds read (CWE-125) in tcpdump's VTP dissector due to insufficient validation of length fields. The target SCTP code adds data to a chunk based on calculated lengths (`outlen`, `inlen`, `stream_len`). If `stream_num` is incorrectly large (causing `stream_len` overflow) or if the `stream_list` buffer is smaller than `stream_len`, it could lead to an out-of-bounds write when calling `sctp_addto_chunk`. The pattern of using a length field to copy data without fully validating the source buffer has some similarity, but the context (kernel vs. user-space analyzer) and exact flaw differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is an integer overflow (CWE-190) in the Linux kernel's F2FS filesystem leading to an infinite loop. The target code contains a critical integer operation: `__u16 stream_len = stream_num * sizeof(__u16);`. If `stream_num` is large enough (>= 32768), this multiplication will overflow a 16-bit `__u16`, resulting in a small `stream_len`. This miscalculation would cause subsequent logic (buffer size calculation in `sctp_make_reconf`, data copying in `sctp_addto_chunk`) to operate on incorrect lengths, potentially leading to buffer overflow or underflow. The vulnerability type (integer overflow in size calculation) and domain (Linux kernel) are highly similar. The main difference is the specific subsystem (networking vs. filesystem).",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 10 is an XXE vulnerability (CWE-611) in libxml2, a user-space XML parsing library. The target code is a kernel networking function that handles binary protocol structures. There is no parsing of markup languages, entity references, or external resources. No relevant similarity in vulnerability type, trigger conditions, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      }
    ]
  },
  "CVE-2022-0322_after_subset_100:a1d80125:vulspec": {
    "timestamp": "2026-01-17T03:21:54.439703",
    "cve_id": "CVE-2022-0322",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a1d80125",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 (CWE-415 Double Free in libguestfs) involves memory ownership and cleanup errors in a user-space library for disk image processing. The target code is a kernel SCTP networking function that constructs a chunk. There is no dynamic memory deallocation or similar error handling patterns in the provided code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 (CWE-665 Improper Initialization in Linux kernel flow dissector) involves uninitialized memory exposure in a network packet parser. The target code initializes all local structures (`outreq`, `inreq`) explicitly before use and does not have conditional paths that skip initialization. The domain (kernel networking) is similar, but the flaw pattern is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 (CWE-416 Use After Free in radare2) involves linked list cleanup in a user-space analysis tool. The target code constructs a new chunk and does not manipulate or free existing complex data structures. The memory management patterns are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 (CWE-119 Buffer Overflow in PHP GD) involves incorrect bounds checking due to arithmetic underflow. The target code performs arithmetic (`stream_num * sizeof(__u16)`) and uses the result for memory operations via `sctp_addto_chunk`. While there is a potential for integer overflow if `stream_num` is large, the code does not show validation of `stream_num`. The similarity is weak because the target code's primary operation is building a message, not processing untrusted input in the same way as an image parser.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 (CWE-119 Buffer Overflow in Linux virtio-net) involves incorrect buffer allocation for network data in a kernel driver. The target code is also in the kernel networking subsystem (SCTP) and involves constructing a network message. The potential similarity lies in ensuring the constructed chunk size (`SCTP_PAD4(outlen) + SCTP_PAD4(inlen)`) correctly accounts for all added data. However, the specific flaw (feature negotiation leading to insufficient fragments) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 (CWE-93 CRLF Injection in CUPS) involves improper neutralization of special sequences in a printing protocol. The target code deals with binary structure construction and network byte order conversion (`htons`, `htonl`), not text-based protocol injection.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 (CWE-400 Resource Consumption in ImageMagick) involves lack of validation between declared image size and actual data. The target code uses caller-provided `stream_num` and `stream_list` without visible validation, which could lead to excessive memory allocation if `stream_num` is maliciously large. This is a tenuous connection, as the primary flaw pattern (unchecked multiplication for allocation size) is common, but the context and consequence (DoS via allocation vs. controlled buffer overflow) differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 8 (CWE-125 Out-of-bounds Read in tcpdump) involves insufficient validation of length fields before memory access in a network protocol parser. The target code is also in networking (SCTP) and writes data to a chunk based on calculated lengths (`outlen`, `inlen`, `stream_len`). While the target code is a *constructor* (writing) and the case is a *parser* (reading), the core relevance is in handling length fields and buffer boundaries. The target code adds data conditionally (`if (stream_len)`), but does not show validation of the `stream_list` input against `stream_len`. This pattern of using unchecked external inputs to determine copy size is similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 9 (CWE-190 Integer Overflow in Linux F2FS) involves an integer overflow leading to an infinite loop. The target code has an integer multiplication (`stream_num * sizeof(__u16)`) which could overflow if `stream_num` is large, affecting the subsequent `outlen`/`inlen` calculations and the chunk size passed to `sctp_make_reconf`. This is a potential similarity. However, the overflow consequence in the target code would likely be an undersized allocation and a buffer overflow during `sctp_addto_chunk`, not an infinite loop. The flaw pattern is related but the manifestation differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 (CWE-611 XXE in libxml2) involves improper restriction of external entity references in an XML parser. The target code is a binary protocol message constructor in the kernel with no relation to parsing, text processing, or external entities.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      }
    ]
  },
  "CVE-2022-23557_before_subset_100:72769e50:vulspec": {
    "timestamp": "2026-01-17T03:22:11.478163",
    "cve_id": "CVE-2022-23557",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "72769e50",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code performs arithmetic and clamping operations on arrays with explicit bounds checking (TFLITE_DCHECK_EQ). Case 1 involves a double-free vulnerability in a file processing module due to complex ownership and error handling issues. The domains (NEON-optimized tensor operations vs. VM disk image inspection) and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in an assembler due to missing bounds check on an array index. The target code uses loops with explicit termination conditions (`i <= bias_size - 16`, `i < bias_size`) and accesses data via pointer arithmetic that is constrained by these loops and the prior assertion. The vulnerability patterns (missing index validation vs. loop-bounded access) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in a data structure cleanup function. The target code performs in-place arithmetic on pre-allocated arrays and does not involve dynamic memory allocation, deallocation, or pointer manipulation of complex structures. The memory management models are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both involve processing data arrays. Case 4's flaw is a lack of validation between declared size and actual data, leading to uncontrolled allocation. The target code has a validation check (`TFLITE_DCHECK_EQ`) ensuring the array size is a multiple of bias size, but it operates on already-allocated buffers. The similarity is superficial; the core flaw (size validation) is present in a very different context and severity.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve buffer operations. Case 5 is a buffer overflow due to incorrect calculation of required buffer size for fragmented packets. The target code's loops could theoretically cause an out-of-bounds access if `bias_size` or `array_size` were maliciously large, but the code is designed for internal use with validated sizes. The similarity is in the category of \"bounds-related issues,\" but the trigger conditions (fragment list processing vs. simple strided loops) and code patterns are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a memory leak in an error path of a multi-pass image scaling function. The target code is a straight-line computation function with no internal memory allocations or complex error paths that could lead to resource leaks. The functional paradigms are incompatible.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 is an input validation flaw leading to path traversal/link issues in an archive extractor. The target code performs mathematical operations on numerical array data and does not process file paths, names, or filesystem links. No meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is a reachable assertion due to lack of validation on an input field. The target code contains a debug assertion (`TFLITE_DCHECK_EQ`) but it checks an arithmetic invariant rather than untrusted input. The target code's parameters (`clamp_min`, `clamp_max`, pointers) are not validated for extreme values, which is a minor similarity, but the context and potential impact (assertion crash vs. potential out-of-bounds write) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. This is the most relevant case. Both involve low-level, performance-optimized buffer/array processing. Case 9's flaw is an incorrect bounds check due to arithmetic underflow. The target code's loop conditions (`i <= bias_size - 16`) could theoretically underflow if `bias_size` is less than 16, but the preceding logic and typical use likely prevent this. The pattern of manually optimized loops with potential edge-case arithmetic errors is similar. However, the specific trigger (underflow in a size check) and domain (image data transfer vs. tensor bias addition) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 10 is a heap buffer overflow due to an off-by-one error in a size calculation for string expansion. The target code uses simple integer arithmetic for loop counters and pointer offsets. While both involve calculating offsets, the target code's pattern is straightforward loop iteration without the complex string parsing and recursive allocation that led to the off-by-one error in glibc's glob.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-23557_after_subset_100:ec40a95f:vulspec": {
    "timestamp": "2026-01-17T03:22:47.640944",
    "cve_id": "CVE-2022-23557",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "ec40a95f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk inspection library due to complex error handling and memory ownership issues. The target code is a performance-optimized, inline arithmetic function in a machine learning library (likely TensorFlow Lite) that performs vector addition and clamping. There is no dynamic memory management, error handling paths, or similar control flow complexity. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 2 is an out-of-bounds read in an assembler due to missing bounds checks on an array index. The target code performs arithmetic on arrays with explicit loops and uses a defensive check (`TFLITE_DCHECK_EQ((array_size % bias_size), 0)`). While both involve array processing, the target code's loops are bounded by `bias_size` and `array_size`, and the vulnerability pattern (missing bounds check on an index used for a small, fixed-size array) does not match the target's pattern of processing contiguous data in chunks.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 is a use-after-free/double-free in a reverse engineering tool due to improper cleanup of linked data structures. The target code contains no dynamic memory allocation or pointer-based data structures. It operates on simple arrays provided as input parameters. The memory safety flaw patterns are not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a resource exhaustion vulnerability due to lack of validation between declared image dimensions and actual data. The target code has a validation check (`array_size % bias_size == 0`), which is a form of input consistency checking. However, the similarity ends there. The target code does not allocate memory based on these parameters; it trusts the caller to provide correctly sized buffers. The core flaw (unbounded allocation) and domain (image parsing vs. numerical computation) are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 is a buffer overflow in a network driver due to incorrect assumptions about feature support leading to insufficient buffer allocation. The target code also relies on an assumption (that `bias_size` is a multiple of the vector processing width, implied by the loop strides of 16 and 4). If `bias_size` were not a multiple of 4 (or 16 for the first loop), the NEON code could read/write out-of-bounds. The `TFLITE_DCHECK` is a runtime check in debug builds but may be absent in release builds. This shares a conceptual similarity with \"incorrect calculation or assumption leading to buffer overflow,\" though the context and specifics differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a memory leak in an image scaling function due to asymmetric resource cleanup in error paths. The target code has no dynamic resource allocation within its scope; it only performs computations on pre-allocated arrays. There are no comparable cleanup or error paths.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 involves improper input validation leading to path traversal or filesystem race conditions during archive extraction. The target code performs pure arithmetic with no filesystem, path, or link operations. The vulnerability categories are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a reachable assertion due to lack of validation on an input numeric field. The target code contains a `TFLITE_DCHECK`, which is an assertion. If `array_size % bias_size != 0`, this assertion could fail. This is a minor similarity. However, the impact (denial-of-service via assertion crash) and context (image parsing vs. core math operation) are very different. Assertions in performance-critical ML code are also more expected and may be disabled in production.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 9 is a buffer overflow/underflow in an image processing library due to incorrect bounds checking involving arithmetic underflow. The target code's loops have potential for off-by-one or incorrect stride errors. For example, the loop condition `i <= bias_size - 16` could underflow if `bias_size < 16`, leading to a very large `i` and out-of-bounds access. The defensive check `(array_size % bias_size) == 0` does not prevent this if `bias_size` is small. The pattern of \"incorrect loop boundary calculation leading to out-of-bounds memory access\" is similar, though the specific arithmetic flaw differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a heap buffer overflow due to an off-by-one error in allocation size calculation. The target code does not perform any memory allocation. While both involve buffer operations, the mechanism (allocation math error vs. loop boundary error) and attack surface are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2019-3812_before_subset_100:65967082:vulspec": {
    "timestamp": "2026-01-17T03:22:56.329013",
    "cve_id": "CVE-2019-3812",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "65967082",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves a buffer overflow (CWE-119) due to insufficient validation of length parameters. The target code reads from an array `s->edid_blob` using an index `s->reg` that increments without any bounds check, which is a classic out-of-bounds read vulnerability pattern. However, the context (I2C slave device emulation vs. SCSI driver) and the specific flaw mechanism (missing upper bound vs. length validation) differ. The core similarity is an unchecked array index leading to potential memory access violations.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a double-free vulnerability (CWE-415) related to error handling and memory ownership in file processing. The target code performs a simple array read and index increment with no dynamic memory allocation, deallocation, or error paths that could lead to double-free issues. The code patterns and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 3 is an integer overflow (CWE-190) leading to an infinite loop in a filesystem block mapping function. The target code involves a simple integer increment (`s->reg++`) but there is no arithmetic operation that could overflow/wrap and cause a loop condition issue. The vulnerability class and context are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow (CWE-119) in a USB driver related to stack buffer and DMA handling. The target code's potential out-of-bounds read from `s->edid_blob` shares the broad CWE-119 classification. However, the specific trigger (unchecked index vs. improper buffer size for USB messages), memory type (likely a fixed-size blob vs. stack), and subsystem are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a race condition (CWE-362) leading to use-after-free (CWE-416) in the TTY subsystem. The target code is a simple, synchronous I2C read function with no concurrency, dynamic memory management, or pointer dereferencing that could lead to a use-after-free. The vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a use-after-free (CWE-416) enabled by improper cleanup of linked structures in a reverse engineering tool. The target code does not involve freeing memory, linked lists, or pointer manipulation. The code structure and flaw are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is an integer overflow (CWE-190) in an audio compression parameter check leading to incorrect memory allocation. The target code has a simple increment but no complex arithmetic, parameter validation, or memory allocation logic that could overflow. The context and flaw mechanism are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to Moderate relevance. Case 8 is an off-by-one error (CWE-119) in array bounds checking in an SPI flash driver. This is conceptually closer to the target code, which lacks *any* bounds check on the array index `s->reg`. Both involve accessing a driver/device data array using an unchecked index. The difference is the specific error (off-by-one vs. unbounded increment) and the subsystem (MTD/SPI vs. I2C).",
        "case_metadata": {
          "cve_id": "CVE-2016-10764"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a buffer overflow (CWE-119) in PHP's GD library due to incorrect bounds checking that fails to account for negative values/underflow. The target code's primary flaw is also a missing bounds check on an array index (`s->reg`). If `s->reg` is a signed integer and can be set to a large value, incrementing it could wrap to negative, leading to an out-of-bounds read. The pattern of an unchecked index leading to out-of-bounds access is similar, though the trigger (direct increment vs. arithmetic on input size) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an injection vulnerability (CWE-93) due to improper neutralization of CRLF sequences in a printing protocol. The target code reads data from a fixed buffer and returns it. There is no string parsing, command generation, or injection vector involved. The vulnerability classes are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      }
    ]
  },
  "CVE-2019-3812_after_subset_100:1a60f570:vulspec": {
    "timestamp": "2026-01-17T03:23:32.174958",
    "cve_id": "CVE-2019-3812",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1a60f570",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 involves a buffer overflow (CWE-119) due to insufficient validation of user-controlled length parameters. The target code performs a buffer read with a modulo operation (`s->reg % sizeof(s->edid_blob)`), which acts as a bounds check, making an overflow unlikely. The core flaw patterns (unchecked user input leading to out-of-bounds access) are different. The target code's pattern is more about potential integer wrap of `s->reg` before the modulo, not a classic length validation flaw.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is a Double Free (CWE-415) in a file content processing function. The target code performs a simple indexed read from a static array and increments a register. There are no dynamic memory allocations, pointer manipulations, or error-handling paths that could lead to double-free or use-after-free scenarios. The code patterns and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 involves an Integer Overflow/Wraparound (CWE-190) leading to an infinite loop. The target code's primary vulnerability concern is the potential integer wrap of the `s->reg` variable. If `s->reg` is a signed integer and increments without check, it could overflow to a negative value. While the modulo operation would then produce a negative index (undefined behavior in C, likely a crash or incorrect read), this is different from the infinite loop outcome in Case 3. However, the root cause category (integer handling flaw) is similar, providing reference value for analyzing the `s->reg++` operation.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a buffer overflow (CWE-119) in a USB driver due to improper DMA buffer handling. The target code reads from a fixed-size array (`edid_blob`) using a modulo-wrapped index. It does not involve DMA, stack buffers, or USB control messages. The \"buffer\" aspect is superficially similar, but the context, attack surface, and specific flaw mechanism (lack of modulo vs. having modulo) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is a Race Condition (CWE-362) leading to Use After Free (CWE-416) in a kernel TTY subsystem. The target code is a simple function that reads from an array based on an internal state variable. There is no concurrency, no dynamic resource (de)allocation, and no pointer aliasing that could lead to a race or UAF. The code patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a Use After Free (CWE-416) caused by improper cleanup of linked data structures in a reverse engineering tool. The target code operates on a simple array and an integer index. It contains no pointers to freed memory, no linked lists, and no dynamic deallocation. The vulnerability class and code structure are irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 involves an Integer Overflow (CWE-190) in a parameter check leading to incorrect memory allocation. The target code's vulnerability is centered on the integer `s->reg`. If `s->reg` is an unsigned integer, continuous increment could cause a wrap-around to 0. While the modulo operation prevents an out-of-bounds read *after* the wrap, the wrap itself might violate the intended state machine (e.g., if `reg` is used elsewhere without modulo). This integer wrap scenario is conceptually similar to the overflow in Case 7, though the consequences differ (state corruption vs. allocation size miscalculation).",
        "case_metadata": {
          "cve_id": "CVE-2014-9904"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Case 8 is an off-by-one buffer overflow (CWE-119) in a driver due to incorrect array bounds checking. The target code uses a modulo operation for bounds checking: `s->reg % sizeof(s->edid_blob)`. This is the *correct* pattern to prevent the type of flaw seen in Case 8. Analyzing this code requires evaluating if this check is sufficient and correctly applied. The relevance is high because the target code demonstrates the *defensive* pattern against the very vulnerability (array index bounds violation) that Case 8 exemplifies. The comparison is valuable for verifying the correctness of the bounds check.",
        "case_metadata": {
          "cve_id": "CVE-2016-10764"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 is a buffer overflow (CWE-119) due to incorrect bounds checking that fails to account for arithmetic underflow/negative values. The target code uses a modulo operator on a potentially wrapping index. If `s->reg` is a signed integer (e.g., `int`), the expression `s->reg % sizeof(...)` in C can produce a *negative* result when `s->reg` is negative, leading to an out-of-bounds read. This is a subtle flaw similar to Case 9's issue with negative values bypassing checks. The pattern of an index calculation that can yield a negative out-of-bounds value is a relevant parallel.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an CRLF injection/command injection (CWE-93) in a printing protocol handler. The target code reads a byte from a data blob and returns it. It does not process textual data, construct commands, or handle network protocols. There is no injection vector or metacharacter neutrality issue. The domains and flaw types are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      }
    ]
  },
  "CVE-2022-23592_before_subset_100:09565ccf:vulspec": {
    "timestamp": "2026-01-17T03:23:34.678260",
    "cve_id": "CVE-2022-23592",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "09565ccf",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection in a printing system (CWE-93). The target code performs forward type inference in a graph node, dealing with internal data structures, vector bounds checking, and type propagation. There is no similarity in vulnerability type, domain, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free (CWE-415) in a file content processing function. The target code does not involve dynamic memory deallocation or ownership transfer. It reads type information from node definitions and calls a type inference function. The patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-9499 involves insufficient input validation leading to a reachable assertion (CWE-617). The target code contains `DCHECK` assertions (e.g., `DCHECK(edge->dst_input() < input_nodes.size())` and `DCHECK(ix < node_t.args_size())`). If these checks are disabled in production, missing validation could lead to out-of-bounds access. However, the domain (image processing vs. graph type inference) and specific trigger conditions are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-5418 involves improper input validation of archive paths leading to filesystem issues (CWE-20, CWE-22). The target code validates indices against container sizes but does not process external file paths or manage filesystem links. The attack surfaces and flaw nature are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2016-8670 involves improper bounds checking leading to buffer overflows (CWE-119), stemming from incorrect validation of a specified quantity. The target code performs bounds checking (`DCHECK(edge->dst_input() < input_nodes.size())`, `DCHECK(ix < node_t.args_size())`) on indices derived from graph edges. If these checks are absent or insufficient in a non-debug build, similar out-of-bounds read/write issues could occur. The pattern of validating an index against a container size is conceptually similar, though the context (image data vs. graph type vectors) differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-18609 is an integer overflow (CWE-190) during frame size calculation in a network protocol library. The target code performs simple arithmetic on indices and sizes but does not involve calculations prone to overflow (like adding header sizes to large values). The code patterns and vulnerability class are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-11470 is an uncontrolled resource consumption issue (CWE-400) due to unvalidated image dimensions. The target code does not parse external file formats or allocate memory based on untrusted size fields. It works with pre-existing graph structures and fixed-size vectors.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18257 is an integer overflow leading to an infinite loop (CWE-190, CWE-835) in a filesystem block mapping function. The target code contains simple loops over `input_nodes` but no complex arithmetic or block size calculations that could overflow. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free (CWE-416) in a linked list cleanup function. The target code does not manually manage dynamic memory for linked structures; it uses STL vectors (`std::vector`) and references. There is no explicit `free` or `delete` operations. The memory safety patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-13033 is an out-of-bounds read (CWE-125) due to insufficient validation of length fields before array access. The target code validates array indices via `DCHECK` but accesses vectors using `at(i)` and `args(ix)`. If the `DCHECK` macros are disabled and the underlying containers (e.g., `node_t.args()`) do not perform bounds checking, an out-of-bounds read could occur. The pattern of validating an index before using it is similar, though the source of the index (network packet vs. graph edge) differs significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2022-23592_after_subset_100:f61b2f58:vulspec": {
    "timestamp": "2026-01-17T03:23:54.833980",
    "cve_id": "CVE-2022-23592",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f61b2f58",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 involves CRLF injection and command injection in a printing system (CWE-93). The target code performs forward type inference in a graph node, with no string parsing, command execution, or network protocol handling. The domains and vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability (CWE-415) in a file reading function. The target code does not perform dynamic memory allocation or deallocation in the shown path; it primarily reads and validates data structures. The core flaw (memory ownership violation) is not present here.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-9499 involves insufficient validation of numeric input leading to a reachable assertion (CWE-617). The target code has a validation check (`ix >= node_t.args_size()`) that prevents an out-of-bounds access, which is a similar defensive pattern. However, the vulnerability type (assertion failure vs. logic error) and context (image parsing vs. graph type inference) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-5418 involves improper input validation of file system paths (CWE-20, CWE-22). The target code deals with internal graph node indices and type descriptors, not pathnames, filesystem operations, or archive extraction. The attack surfaces and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-8670 involves integer underflow/overflow leading to buffer overflows (CWE-119, CWE-190). The target code uses `vector::at(i)` and checks indices against container sizes (`ix >= node_t.args_size()`), which are proper bounds checks. While both involve bounds checking, the target code's checks appear correct, and the context (image buffer vs. graph type vector) is different.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2019-18609 involves integer overflow in frame size calculation leading to buffer overflow (CWE-190). The target code performs bounds checking on indices but does not involve arithmetic on sizes that could overflow. The similarity is limited to the general concept of validating sizes/indices, but the specific integer overflow flaw is not present.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-11470 involves uncontrolled resource consumption (CWE-400) due to unvalidated image dimensions. The target code validates array indices but does not allocate memory based on user-controlled sizes. The resource exhaustion vector is not applicable here.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-18257 involves integer overflow leading to an infinite loop (CWE-190, CWE-835) in a filesystem block mapping function. The target code has simple loops over `input_nodes` with no complex arithmetic or loop exit conditions dependent on user data. The vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free (CWE-416) in a linked structure cleanup. The target code does not manage linked lists or perform manual memory deallocation. It works with STL vectors and references, which manage memory automatically.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-13033 involves an out-of-bounds read (CWE-125) due to insufficient bounds checking on packet data. The target code has a direct analog: it checks `ix >= node_t.args_size()` before accessing `node_t.args(ix)`, which is precisely the bounds check needed to prevent an out-of-bounds read. The core defensive coding pattern is similar, but the context (network packet parsing vs. internal graph type propagation) and the consequence of failure differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      }
    ]
  },
  "CVE-2022-23578_before_subset_100:605f59ae:vulspec": {
    "timestamp": "2026-01-17T03:24:21.772523",
    "cve_id": "CVE-2022-23578",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "605f59ae",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file processing library (libguestfs). The target code is TensorFlow's graph executor initialization, which performs node analysis, kernel creation, and resource setup. There is no shared vulnerability pattern (double-free vs. graph state management), domain (VM disk inspection vs. ML framework), or code structure.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in CUPS during PPD file generation. The target code initializes a computational graph, validates nodes, and sets up execution state. There is no similarity in vulnerability type (injection vs. resource management), attack surface (network protocol vs. internal graph), or functional domain (printing system vs. ML runtime).",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 3 is an integer overflow leading to heap buffer overflow in an AMQP client library. The target code performs graph traversal and resource allocation but does not parse untrusted network data or calculate sizes from external inputs in a similar way. While both involve careful state initialization, the vulnerability mechanisms (integer overflow in frame parsing vs. graph node property validation) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is a use-after-free/double-free in a reverse engineering tool's basic block analysis. The target code allocates and initializes node items and frame info but does not involve complex pointer-linked structures like basic block graphs, nor does it have similar deallocation logic. The vulnerability patterns (memory corruption via circular references vs. graph executor setup) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 is an improper initialization vulnerability in the Linux kernel's network flow dissector, leading to uninitialized memory exposure. The target code also involves careful state initialization (e.g., `pending_ids_`, `frame_info`). Both require ensuring all fields are correctly set, especially across error paths. However, the domain (network packet parsing vs. graph execution) and specific flaw (leaking stack memory vs. incorrect graph state) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 6 is a reachable assertion due to insufficient input validation in ImageMagick. The target code reads node attributes (e.g., `send_device`, `is_constant`, `frame_name`) but does so with `TF_RETURN_IF_ERROR` checks. Both involve parsing and validating external input (graph definition vs. image file), but the vulnerability outcome (assertion crash vs. logic error) and context (image processing vs. runtime initialization) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Case 7 is an uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared dimensions and actual data. The target code allocates resources (e.g., `pending_ids_`, `enter_frame_info_`) based on graph node counts. Both must guard against malicious inputs causing excessive allocation, but the target code's allocations are bounded by the already-validated graph structure, not direct file data.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is an improper input validation leading to path traversal issues in libarchive. The target code processes an internal graph representation, not filesystem paths. There is no similarity in vulnerability type (path validation vs. graph state setup), attack surface (archive files vs. computational graphs), or security impact (filesystem corruption vs. runtime error).",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an integer overflow leading to an infinite loop in a filesystem (F2FS). The target code contains loops over graph nodes but does not perform arithmetic on block sizes or offsets that could overflow. The vulnerability patterns (integer overflow in block mapping vs. iterative graph processing) and domains (filesystem vs. ML executor) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a heap buffer overflow due to an off-by-one error in glibc's glob function. The target code uses standard containers (vectors) and does not perform manual buffer allocation or string expansion with similar boundary calculation errors. The vulnerability mechanisms (off-by-one in string expansion vs. graph node property assignment) are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-23578_after_subset_100:61d020e7:vulspec": {
    "timestamp": "2026-01-17T03:24:26.797627",
    "cve_id": "CVE-2022-23578",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "61d020e7",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to file content processing and error handling. The target code is TensorFlow's graph executor initialization, focusing on node processing, kernel creation, and control flow setup. There is no similarity in vulnerability type (memory corruption vs. graph execution logic), domain, or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection vulnerability in CUPS during PPD file generation. The target code performs graph traversal and node property initialization in a machine learning framework. The domains (printing system vs. ML execution), attack surfaces (network protocol parsing vs. internal graph construction), and flaw types (input sanitization vs. state management) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2019-18609 involves an integer overflow leading to a heap buffer overflow in an AMQP client library during frame size calculation. The target code performs arithmetic for pending counts and array indexing but does not parse untrusted network data or perform size calculations based on external inputs in a similar way. The risk profile (remote code execution via network vs. internal graph validation) and code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free vulnerability in a reverse engineering tool related to linked list cleanup of basic blocks. The target code allocates and initializes node items and frame info objects but does not involve complex pointer-based data structures with manual cleanup or circular references. The memory management model (RAII/containers vs. manual linked list management) is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-13715 is an improper initialization vulnerability in the Linux kernel flow dissector, leading to uninitialized memory exposure. The target code also involves initialization of data structures (NodeItem, FrameInfo, pending counts). However, the context is vastly different (network packet parsing vs. graph node initialization), and the target code does not show signs of leaving critical fields uninitialized during error paths in a comparable manner. There is a superficial similarity in \"initialization\" but not in the specific flaw mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-9499 is a reachable assertion due to insufficient input validation in ImageMagick. The target code reads node attributes (e.g., `parallel_iterations`, `is_constant`) but performs validation (e.g., checking `frame_info->parallel_iterations` consistency) and uses `TF_RETURN_IF_ERROR` for status checking, not assertions. The flaw patterns (assertion on invalid input vs. error status propagation) and domains (image parsing vs. graph execution) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2019-11470 is an uncontrolled resource consumption (memory) vulnerability in an image decoder due to lack of validation between declared dimensions and data size. The target code allocates memory based on graph structure (number of nodes, edges) which is presumably trusted or validated earlier in the pipeline. While both involve allocations, the attack vector (malicious file vs. internal graph) and the lack of obvious dimension-data mismatch checks in the target code reduce relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-5418 is a path validation and symlink race vulnerability in libarchive during filesystem extraction. The target code operates purely in memory on graph structures, with no filesystem operations, path resolution, or symlink handling. The domains and vulnerability classes are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Low relevance. CVE-2017-18257 is an integer overflow leading to an infinite loop in a filesystem block mapping function. The target code calculates `max_pending` and `max_dead` counts and uses them for handle creation. While integer overflows in calculations are a general concern, the target code's calculations are based on node properties from a constructed graph, not directly on untrusted external inputs. The specific loop-with-unreachable-exit condition pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow due to an off-by-one error in memory allocation in glibc's glob function. The target code uses standard containers (vector, unique_ptr) and does not show manual buffer allocation with error-prone size calculations. The code patterns and vulnerability type are not analogous.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2021-37663_before_subset_100:a6665f6b:vulspec": {
    "timestamp": "2026-01-17T03:25:05.425657",
    "cve_id": "CVE-2021-37663",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a6665f6b",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a virtual disk inspection library due to improper memory ownership and error handling. The target code is a TensorFlow quantization kernel performing numerical computations with tensor allocations. There is no dynamic memory deallocation, pointer manipulation, or similar error handling paths that could lead to double-free.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability in a printing system due to improper input neutralization. The target code performs tensor quantization with numerical validation but does not process textual protocol data, generate files with embedded control sequences, or execute commands.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 3 involves uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code also processes multi-dimensional data (tensors) and could potentially be vulnerable to resource exhaustion if input dimensions are extremely large, but the code patterns and validation contexts are different. The target code uses TensorFlow's allocation functions which may have built-in size checks.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 involves a reachable assertion (CWE-617) due to insufficient validation of numeric input fields. The target code performs input validation (OP_REQUIRES) but doesn't use assertions. Both involve validating numeric parameters, but the vulnerability patterns (assertion failure vs. potential quantization errors) and code constructs differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a use-after-free/double-free vulnerability in a reverse engineering framework involving linked structure cleanup. The target code manages tensor objects through TensorFlow's memory management system without manual pointer manipulation or complex data structure cleanup that could lead to use-after-free scenarios.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 involves improper bounds checking (CWE-119) due to arithmetic underflow in image processing. The target code performs tensor operations with potential for index calculation errors (e.g., in the chip operations or loop bounds). While the specific underflow pattern differs, both involve bounds validation in numerical computations on multi-dimensional data structures.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow in a network driver due to incorrect feature declaration and insufficient buffer allocation for fragmented packets. The target code operates on pre-allocated tensors with fixed shapes and doesn't involve dynamic packet reassembly or network protocol processing.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 involves integer overflow (CWE-190) leading to infinite loop in filesystem operations. The target code performs arithmetic operations (pre_dim, post_dim calculations) that could potentially overflow with maliciously large tensor dimensions, though TensorFlow's shape validation might catch these. Both involve arithmetic on user-controlled sizes, but the specific overflow-to-loop pattern differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 involves improper input validation leading to path traversal and symlink issues in archive extraction. The target code processes numerical tensor data only, with no filesystem operations, path resolution, or symlink handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 involves integer overflow (CWE-190) in frame size calculation leading to buffer overflow. The target code performs size calculations (pre_dim, post_dim) based on tensor dimensions that could potentially overflow with malicious inputs, though the arithmetic is simpler (multiplication rather than addition near limits). Both involve calculating buffer/slice sizes from user-controlled dimensions.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      }
    ]
  },
  "CVE-2021-37663_after_subset_100:fffd2732:vulspec": {
    "timestamp": "2026-01-17T03:25:12.182034",
    "cve_id": "CVE-2021-37663",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "fffd2732",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual disk image inspection library due to improper memory ownership and error handling. The target code is a TensorFlow quantization kernel performing numerical validation and tensor allocation with no dynamic memory management or similar error paths.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability (CWE-93) in a printing system due to improper neutralization of protocol data. The target code performs input validation on tensor dimensions and numerical ranges, with no string processing or command execution.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 involves uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code validates tensor dimensions and sizes (e.g., `input_min_range.dim_size(0) == num_slices`), showing some conceptual similarity in validating declared vs. actual sizes, but the context (image parsing vs. tensor quantization) and vulnerability type differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 is a reachable assertion (CWE-617) due to insufficient validation of a numeric input field. The target code performs validation checks (OP_REQUIRES) on input dimensions and element counts, which is a defensive pattern, but the vulnerability mechanism (assertion failure on out-of-bounds value) and context are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a use-after-free/double-free (CWE-416) in a reverse engineering tool due to improper linked list cleanup. The target code has no dynamic memory deallocation or pointer-based data structures; it works with pre-allocated tensors.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 involves improper bounds restriction (CWE-119) due to incorrect arithmetic checking (underflow). The target code performs multiple bounds and size validations (e.g., checking `axis_` against input dimensions, validating tensor sizes). While the vulnerability type (bounds checking) is somewhat relevant, the specific flaw (arithmetic underflow in buffer size calculation) is not present in the shown code, which uses high-level tensor operations.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 7 is a buffer overflow (CWE-119) in a network driver due to incorrect feature declaration and insufficient buffer allocation for fragmented packets. The target code operates on tensor abstractions with allocated shapes and does not involve low-level buffer management or network packet processing.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an integer overflow (CWE-190) leading to an infinite loop in a filesystem. The target code uses integer arithmetic for dimension calculations (e.g., `pre_dim`, `post_dim`), but there is no indication of overflow potential (no large, untrusted integer inputs being multiplied or added without checks). The context and vulnerability pattern are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an improper input validation (CWE-20) leading to path traversal issues in an archive library. The target code validates tensor properties but does not process file paths, archives, or filesystem links.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is an integer overflow (CWE-190) leading to an out-of-bounds write in a network protocol library. The target code performs size validation on tensor dimensions, which is a related defensive practice, but the code does not parse binary protocol frames, calculate buffer sizes from untrusted integers, or have the same vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      }
    ]
  },
  "CVE-2022-2207_before_subset_100:10fb958d:vulspec": {
    "timestamp": "2026-01-17T03:25:35.648152",
    "cve_id": "CVE-2022-2207",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "10fb958d",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file processing library (libguestfs). The target code is a text editor's backspace function (ins_bs) in Vim, dealing with cursor movement, character deletion, and line joining. There is no dynamic memory allocation/deallocation in the provided code snippet, making memory corruption vulnerabilities like double-free irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parser (libxml2). The target code handles user input (backspace operations) in a text editor but does not parse structured data formats like XML, nor does it process external entities. The domains and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free in a reverse engineering framework's data structure cleanup. The target Vim code performs in-buffer text manipulation, cursor management, and state updates. It does not involve complex heap-allocated data structures with pointer-based links (like basic block graphs) that are prone to use-after-free during deallocation.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 4 is a heap buffer overflow in glibc's glob function due to an off-by-one allocation error. The target code manipulates text buffers and cursor positions. While both handle user input and string/data manipulation, the vulnerability root cause (incorrect allocation math for path expansion) is not present. The target code's primary risks would be more related to buffer indexing within existing lines, not during dynamic allocation for pattern matching.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation of image dimensions. The target code is a core editor function for backspacing. It does not parse external file formats with dimension headers, nor does it perform allocations based on untrusted file metadata. The operational context and attack surface are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a buffer overflow in a kernel SCSI driver due to insufficient validation of a length parameter. The target code does process user keystrokes but primarily uses them to control logic flow (e.g., mode) rather than as untrusted length values for memory operations. While both accept user input, the target code's complexity lies in state management and screen updates, not in copying data based on an unvalidated size field.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a race condition leading to use-after-free in the kernel TTY subsystem. The target code is part of Vim's input handling. Both are in the general domain of terminal/input handling. However, the vulnerability mechanism (concurrent ioctl operations causing a pointer to be freed) is not applicable to the single-threaded, synchronous nature of the `ins_bs` function. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free in an MTA (Exim) during email header processing. The target code is a text editor's internal function. Both are complex C programs, but the domains (email parsing vs. text editing) and the specific memory management patterns (ownership of header blocks vs. in-buffer text operations) are entirely different. No meaningful reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is an out-of-bounds read in a regex library due to integer overflow in pointer arithmetic. The target code performs extensive cursor and column arithmetic (e.g., `getvcol`, `want_vcol` calculations, `col` comparisons). While no pointer arithmetic is shown, the complex column and virtual column calculations involving user-controlled positions (cursor movement) could hypothetically lead to similar integer overflow or off-by-one errors in buffer indexing, though not directly demonstrated. This provides a slight reference for auditing similar arithmetic.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 10 is an improper initialization leading to information disclosure in the kernel's network flow dissector. The target code initializes many local variables (e.g., `temp`, `did_backspace`) and manages editor state. While both involve state management, the vulnerability context is vastly different (network packet parsing error paths vs. editor command execution). The risk of leaving sensitive data uninitialized in the target code is low, as it doesn't handle external, attacker-controlled data structures like packet headers.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2022-2207_after_subset_100:d56fe9c3:vulspec": {
    "timestamp": "2026-01-17T03:26:07.563078",
    "cve_id": "CVE-2022-2207",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "d56fe9c3",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file processing library (libguestfs). The target code is a text editor's backspace function (Vim/Neovim) handling cursor movement, character deletion, and line joining. There is no dynamic memory allocation or deallocation in the provided code snippet, making memory corruption vulnerabilities like double-free irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an XXE vulnerability in an XML parser (libxml2). The target code performs text buffer manipulation within an editor. The domains (parsing vs. editing), data structures, and vulnerability patterns (external entity expansion vs. buffer state management) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 is a use-after-free in a reverse engineering framework's analysis data structure cleanup. The target code operates on a text buffer, managing cursor positions and character data, with no apparent dynamic allocation/deallocation of complex linked structures like basic blocks. The flaw patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 4 is a heap buffer overflow in glibc's glob() due to an off-by-one allocation error. The target code manipulates a text buffer and could theoretically have buffer overflow risks if cursor/column calculations are incorrect. However, the specific context (pathname expansion vs. in-editor character operations) and the nature of the flaw (allocation math error) are not directly comparable to the logic shown.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is a resource exhaustion vulnerability in an image decoder due to unvalidated dimensions. The target code handles user input (backspace key) but performs bounded, iterative operations on an existing text buffer. There is no parsing of untrusted file headers or unbounded allocation based on unvalidated data.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 6 is a buffer overflow in a kernel SCSI driver due to lack of validation on user-controlled length fields. The target code does not process external, untrusted data streams with length fields. It handles keystrokes and modifies an internal buffer with bounds likely checked elsewhere (e.g., `ml_get_cursor`). The attack surfaces and data trust models are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 is a race condition leading to use-after-free in the kernel TTY subsystem. The target code is a user-space editor function. While both involve input handling, the concurrency model (kernel-level concurrent ioctl vs. single-threaded or cooperative multitasking in an editor) and the resulting vulnerability class (race condition) are not analogous to the synchronous, sequential logic presented.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free in a mail server (Exim) during complex message state management. The target code shows no evidence of similar memory ownership issues or complex state transitions involving store/release patterns. The code manages cursor and buffer state directly, not through abstract memory pools.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak to moderate relevance. Case 9 is an out-of-bounds read in a regex library due to integer overflow in pointer arithmetic. The target code performs arithmetic on column positions (e.g., `curwin->w_cursor.col`, `vcol`, `want_vcol`). If these values were manipulated incorrectly (e.g., through large files or specific editing sequences), similar integer overflows or underflows could theoretically lead to out-of-bounds buffer accesses when used with functions like `ml_get_cursor()`. The pattern of unsafe arithmetic on indices/offsets is a potential commonality, though the specific trigger (regex search vs. backspace) differs.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is an improper initialization vulnerability in the Linux kernel's network flow dissector, leading to uninitialized memory exposure. The target code initializes its local variables (e.g., `temp = 0`, `did_backspace = FALSE`) and manages well-defined editor state. There is no parsing of layered, untrusted protocol data where error paths could leave structure fields uninitialized.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      }
    ]
  },
  "CVE-2020-7060_before_subset_100:f02d8d13:vulspec": {
    "timestamp": "2026-01-17T03:26:18.008065",
    "cve_id": "CVE-2020-7060",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f02d8d13",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. The target code is a character encoding conversion function with no dynamic memory management (no malloc/free). CVE-2013-2124 is a double-free vulnerability in a different system (libguestfs) related to file content processing and error handling. The code patterns and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-11470 is a resource consumption vulnerability in an image decoder due to unvalidated dimensions leading to large allocations. The target code performs table lookups and arithmetic but does not allocate memory based on untrusted input sizes. The functional domains (image parsing vs. text encoding) and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code processes byte sequences for character encoding conversion and has no entity resolution, network access, or document structure parsing. The attack surfaces and vulnerability classes are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection vulnerability in a printer configuration generator. The target code is a self-contained encoding filter that outputs wide characters via a callback; it does not generate structured files, parse commands, or handle network protocols. The flaw mechanisms are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in a reverse engineering framework related to linked list cleanup. The target code has no dynamic data structures, pointers to freed memory, or complex object lifecycles. The memory management patterns and vulnerability triggers are not present.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-15670 is a heap buffer overflow due to an off-by-one allocation error in path expansion. The target code performs arithmetic and table lookups but does no dynamic buffer allocation based on input length. While both involve arithmetic, the context and consequence (buffer overflow vs. potential incorrect character mapping) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. CVE-2016-8670 is a buffer overflow in PHP's GD image processing due to incorrect bounds checking. The target code is also from the PHP ecosystem (mbstring extension) and involves processing input bytes with arithmetic and table lookups. While the specific vulnerability (arithmetic underflow leading to OOB access) is not directly mirrored, the domain (PHP core library, input byte processing) and potential for similar arithmetic/logic errors (e.g., in index calculations for `big5_ucs_table`) provide a relevant reference for secure coding practices in such converters.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-13715 is an uninitialized memory exposure in a network protocol parser due to improper state cleanup on error paths. The target code also uses a state machine (`filter->status`) to process multi-byte sequences. A flawed state transition or failure to reset state properly could lead to incorrect processing. However, the vulnerability type (information disclosure via uninitialized memory) is not applicable here, as the code does not expose internal memory contents.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-13033 is an out-of-bounds read in a network protocol dissector due to insufficient validation of length fields. The target code reads from a table `big5_ucs_table` using a calculated index `w`. If `w` could be manipulated to be out-of-bounds (negative or >= `big5_ucs_table_size`), it could lead to an OOB read. The code has a bounds check (`if (w >= 0 && w < big5_ucs_table_size)`), but the relevance lies in the similar pattern of index calculation from input bytes followed by a table lookup. The context (text encoding vs. network protocol) differs.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-18257 is an integer overflow leading to an infinite loop in a filesystem. The target code contains integer arithmetic (e.g., `(c1 - 0xa1)*157 + (c - 0x40)`). While an integer overflow/wraparound in these calculations could theoretically produce a negative or incorrect table index `w`, leading to OOB access or incorrect output, the values involved (single-byte inputs) make a true overflow unlikely. The loop-with-unreachable-exit condition aspect is not present. The similarity is limited to the presence of arithmetic operations on untrusted input.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2020-7060_after_subset_100:58da091f:vulspec": {
    "timestamp": "2026-01-17T03:26:57.409968",
    "cve_id": "CVE-2020-7060",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "58da091f",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free memory management flaw in a virtual disk inspection library. The target code is a character encoding conversion filter with no dynamic memory allocation or deallocation. The functional domains and vulnerability patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 2 is about uncontrolled resource consumption (CWE-400) due to unvalidated image dimensions leading to excessive memory allocation. The target code performs bounded table lookups and has no dynamic allocation based on untrusted input sizes. The attack surface and flaw nature are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 involves XML external entity injection (XXE). The target code processes byte sequences for character encoding conversion, with no XML parsing, entity resolution, or external resource fetching capabilities. The vulnerability classes are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is about CRLF injection leading to command injection in a printing system. The target code is a pure data transformation function with no command execution, output to external processes, or CRLF sequence handling. The security contexts are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 involves use-after-free/double-free in a reverse engineering framework's data structure management. The target code has no dynamic memory management, linked structures, or pointer manipulation that could lead to such memory corruption vulnerabilities.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 is a heap buffer overflow due to an off-by-one calculation in path expansion. The target code performs arithmetic for character mapping but uses bounds-checked table lookups (w >= 0 && w < big5_ucs_table_size). While both involve arithmetic, the overflow potential and memory safety context differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 7 involves improper bounds checking in PHP's GD library leading to buffer over-read/over-write (CWE-119). The target code performs similar character encoding conversion with arithmetic operations on input bytes. Both process untrusted input streams and use arithmetic to compute indices/offsets. The pattern of validating computed indices (w >= 0 && w < big5_ucs_table_size) is analogous to bounds checking in image processing. However, the specific vulnerability (arithmetic underflow) and domain (image vs. text encoding) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 involves improper initialization leading to uninitialized memory exposure in a network packet parser. The target code has well-defined state transitions (status 0/1) and doesn't expose uninitialized data. The domains (network protocol vs. character encoding) and vulnerability patterns differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 9 involves out-of-bounds read (CWE-125) due to insufficient validation of length fields in network protocol parsing. The target code validates table indices (w >= 0 && w < big5_ucs_table_size) to prevent out-of-bounds reads. Both involve parsing structured input (byte pairs for Big5/CP950, TLV for VTP) and performing bounds checks. The similarity lies in the pattern of validating computed indices against table sizes. However, the domains and specific validation logic differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 10 involves integer overflow (CWE-190) leading to infinite loop in a filesystem. The target code contains arithmetic operations (e.g., (c1 - 0xa1)*157 + (c - 0x40)) that could theoretically overflow, but they operate on byte-sized inputs (c, c1) making overflow unlikely. Both involve arithmetic on input-derived values, but the scale and consequence (loop vs. table lookup) differ significantly. The target code's operations are bounded by the input byte ranges.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2020-12723_before_subset_100:b4c36711:vulspec": {
    "timestamp": "2026-01-17T03:27:11.519983",
    "cve_id": "CVE-2020-12723",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b4c36711",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is a regular expression compilation/optimization function from Perl (S_study_chunk). Case 1 (CVE-2013-2124) involves a double-free vulnerability in libguestfs's file processing. Both deal with parsing/processing, but the vulnerability type (double-free vs. potential logic/overflow in regex compilation), domain (VM disk image inspection vs. regex engine), and code patterns are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 2 (CVE-2013-0339) is an XXE vulnerability in libxml2. The target code is a regex study function. Both involve parsing complex input (regex patterns vs. XML), but the vulnerability mechanism (external entity expansion) and code patterns (XML parser vs. regex compiler state machine) are completely different. No meaningful reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Case 3 (CVE-2019-11470) is a resource consumption vulnerability in ImageMagick's Cineon decoder due to lack of validation between declared dimensions and actual data. The target regex study code also performs calculations on input-derived values (like min/max lengths) and has bounds checks (e.g., checks for SSize_t_MAX overflow). There's a weak similarity in validating/computing sizes from untrusted input to prevent overflow/DoS, but the domains and specific flaw patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 4 (CVE-2018-12320) is a use-after-free/double-free in radare2's basic block analysis due to improper linked list cleanup. The target code manages complex recursive data structures (regex parse trees) and uses frames for recursion unwinding, but there's no evident similar memory ownership issue or linked list manipulation that could lead to UAF. The code patterns and vulnerability type are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 5 (CVE-2017-16943) is a use-after-free in Exim's header processing. The target code does not show obvious memory deallocation patterns; it's focused on analysis and optimization, not dynamic memory management of message data. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 4,
        "reasoning": "Case 6 (CVE-2017-15670) is a heap buffer overflow in glibc's glob due to off-by-one in allocation calculation. The target code has numerous arithmetic operations on lengths (min, max, delta) with checks for overflow (e.g., comparing against SSize_t_MAX). There's a weak-to-moderate relevance: both involve careful size calculations from input to prevent overflow, but the specific flaw (off-by-one in string length for home directory) is not mirrored in the regex study's integer overflow checks.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 9,
        "reasoning": "Case 7 (CVE-2019-19012) is highly relevant. It's an out-of-bounds read in Oniguruma (a regex library) due to integer overflow in pointer arithmetic during forward search. The target code is Perl's regex study function, part of the same domain (regex engine implementation). Both involve complex state tracking, length calculations (minlenp, deltap), and recursion depth management. The vulnerability patterns (integer overflows in length calculations leading to out-of-bounds access) are very similar, though the exact trigger (distance calculation in forward_search vs. study_chunk's min/max accumulation) differs. The code structure and concerns (preventing overflow, managing recursion) are nearly identical, providing strong reference value.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 8 (CVE-2017-15400) is a CRLF injection/command injection in CUPS' PPD generation. The target code does not generate external files or commands; it analyzes regex patterns internally. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 9 (CVE-2016-5418) is a path validation/hardlink issue in libarchive. The target code does not deal with filesystem paths or archive extraction. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Case 10 (CVE-2018-1140) is an input validation flaw in Samba's LDAP-to-SQL translation leading to NULL pointer dereference. The target code has extensive state management but no similar SQL generation or DN case folding. The error handling patterns differ. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      }
    ]
  },
  "CVE-2020-12723_after_subset_100:b97465c5:vulspec": {
    "timestamp": "2026-01-17T03:27:20.678610",
    "cve_id": "CVE-2020-12723",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b97465c5",
    "scores": [
      {
        "score": 3,
        "reasoning": "The target code is a regex compilation/optimization function in Perl, while CVE-2013-2124 involves double-free in libguestfs file processing. Different domains (regex engine vs. VM disk inspection), different vulnerability types (no memory deallocation in target code), and completely different code patterns. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2013-0339 is an XXE vulnerability in libxml2, while the target code is a regex study function. Different domains (XML parsing vs. regex compilation), different vulnerability types (external entity expansion vs. potential integer overflows or logic errors), and different code patterns. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2019-11470 involves uncontrolled resource consumption in ImageMagick due to unvalidated image dimensions. The target regex code has some integer calculations (minlen, delta) that could potentially overflow, but the domain is different (image parsing vs. regex compilation). Weak relevance due to potential integer handling issues.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2018-12320 is a use-after-free in radare2's basic block analysis. The target code manages regex parse trees but doesn't show similar linked list cleanup patterns or memory deallocation issues. Different domains (binary analysis vs. regex compilation) and different vulnerability patterns. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-16943 is a use-after-free in Exim's SMTP processing. The target code is a regex study function with complex state management but no apparent memory deallocation or use-after-free patterns. Different domains (mail processing vs. regex compilation) and different vulnerability types. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-15670 is a heap buffer overflow in glibc's glob function due to off-by-one error. The target regex code has many integer calculations (min, delta, SSize_t_MAX checks) that could potentially have boundary issues. Moderate relevance due to similar integer overflow/underflow risks in path/pattern processing, though domains differ (path expansion vs. regex compilation).",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. CVE-2019-19012 is an out-of-bounds read in Oniguruma regex library due to integer overflow in pointer arithmetic. The target code is also a regex study/compilation function (S_study_chunk in Perl) with similar integer calculations (minlen, delta, SSize_t_MAX checks), pointer arithmetic (scan, next, tail pointers), and complex state management. Both involve regex engine internals, integer overflow risks in distance/length calculations, and similar code patterns for traversing regex parse trees.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-15400 is a CRLF injection in CUPS PPD generation. The target code is a regex study function with no string injection or output generation patterns. Different domains (printing system vs. regex compilation) and completely different vulnerability types (injection vs. potential integer/logic errors). Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2016-5418 involves path validation issues in libarchive. The target regex code doesn't handle filesystem paths or archive extraction. Different domains (archive processing vs. regex compilation) and different vulnerability types (path traversal vs. potential integer overflows). Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2018-1140 involves improper input validation in Samba's LDAP query processing. The target regex code has some input validation (checking opcodes, bounds) but is in a completely different domain (regex vs. LDAP/SQL). Weak relevance due to general input validation concerns, but specific patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      }
    ]
  },
  "CVE-2021-43814_before_subset_100:905bc903:vulspec": {
    "timestamp": "2026-01-17T03:28:04.279137",
    "cve_id": "CVE-2021-43814",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "905bc903",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 (CVE-2018-12320) is a Use-After-Free/Double-Free in a linked structure cleanup. The target code involves parsing DWARF debug info and uses a hash table (`ht_up_insert`) which could have memory management issues, but the core pattern (circular linked list cleanup) and vulnerability type (CWE-416) are not directly mirrored. The target code's primary risk is more about input validation and memory allocation failure handling.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 2 (CVE-2013-2124) is a Double Free related to error handling and resource cleanup. The target code has a potential resource leak if `ht_up_insert` fails (the `strdup`'d `name` is freed, but the function returns without indicating failure). However, the specific double-free pattern and the context (file parsing in libguestfs) are different. The relevance is in the broader theme of improper cleanup on failure paths.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability. The target code parses DWARF debug information from binary files, not XML. The vulnerability types (CWE-611 vs. potential memory/parsing bugs) and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 4 (CVE-2017-13715) is an uninitialized memory exposure in a network protocol parser. The target code is also a parser, but for a debug info format. While both involve parsing untrusted input, the specific flaw (improper initialization leading to info leak) is not evident in the provided snippet, which uses `memset` to zero attributes. The code patterns and vulnerability root causes are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 (CVE-2017-15670) is a heap buffer overflow due to an off-by-one allocation error in path expansion. The target code does not perform similar string expansion or have obvious off-by-one calculations. The memory operations shown are straightforward copying and hash table insertion.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 6 (CVE-2019-11470) is an uncontrolled resource consumption (CWE-400) due to lack of validation between declared size and actual data. The target code parses attributes from a binary buffer (`buf`, `buf_end`). While not shown in the snippet, the called function `parse_attr_value` and the loop relying on `abbrev->count` must validate that the parsed data stays within `buf_end` bounds. Failure to do so could lead to out-of-bounds reads or infinite loops, a similar parsing validation flaw. The context (parsing file formats) is also similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CVE-2017-15400) is a CRLF injection/command injection in a printing protocol. The target code deals with low-level binary parsing and stores strings in a hash table. There is no injection context or protocol-level command generation.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 8 (CVE-2017-13033) is an out-of-bounds read (CWE-125) in a network protocol dissector due to insufficient validation of length fields. The target code is a dissector/parser for the DWARF debug info format. It operates on a bounded buffer (`buf`, `buf_end`) and calls `parse_attr_value` which must correctly handle the `buf_end` limit. A similar vulnerability could occur if `abbrev->count` is maliciously large, causing the loop to call `parse_attr_value` repeatedly without adequate bounds checks, potentially leading to OOB reads. The code pattern (parsing loop over a buffer with a count) and the vulnerability type are analogous.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 (CVE-2016-8670) is a buffer boundary violation (CWE-119) due to incorrect bounds checking (e.g., underflow). The target code's main risk lies in the `parse_attr_value` function (not shown) correctly validating the remaining buffer length (`buf_end - buf`). If this calculation or subsequent reads/writes within that function are flawed (e.g., integer overflow/underflow, incorrect size validation), it could lead to similar buffer over/under-read/write conditions. The context of parsing binary data from untrusted files is identical.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 (CVE-2016-7425) is a buffer overflow due to insufficient validation of length parameters. While the target code does not show a direct copy with a user-controlled length, the core issue is similar: the `parse_attr_value` function receives a length (`buf_end - buf`) and must trust the `abbrev->defs[i]` to correctly interpret the data within that bound. If the format definitions are corrupted, it could instruct the parser to read/write beyond the buffer, analogous to a buffer overflow. The pattern of parsing untrusted binary data with internal size directives is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2021-43814_after_subset_100:f64e400e:vulspec": {
    "timestamp": "2026-01-17T03:28:04.467372",
    "cve_id": "CVE-2021-43814",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f64e400e",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve radare2/librz, but the vulnerability types differ significantly. CVE-2018-12320 is a Use-After-Free/Double-Free in basic block analysis, while the target code is a DWARF parser focusing on string and offset management. The memory management patterns (linked list cleanup vs. hash table insertion) and attack surfaces (Java binary vs. DWARF debug info) are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The vulnerability type (Double Free) is a memory safety issue, which is a broad category the target code could potentially be susceptible to (e.g., mishandling of the `name` pointer). However, the trigger conditions and code patterns are very different: CVE-2013-2124 involves error path cleanup in a file reading function, while the target code is a structured parser inserting data into a hash table. The reference value is limited to general memory ownership concepts.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XML External Entity (XXE) injection vulnerability, which is a completely different class of flaw (logic/trust boundary) compared to the memory and parsing operations in the target DWARF parsing code. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-13715 involves improper initialization leading to information disclosure in a network parser. The target code also parses binary data (DWARF), but its vulnerability profile is more about buffer bounds, integer handling, and memory allocation (for `strdup`). The \"improper initialization\" aspect is not a prominent feature of the target code's logic.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2017-15670 is a heap buffer overflow due to an off-by-one calculation. The target code performs memory allocation (`strdup`) and could be susceptible to related issues if input sizes are not validated, but the specific pattern (off-by-one in home directory expansion) is not present. The parsing logic is structurally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both involve parsing binary file formats (image vs. debug info) and have a potential attack surface in untrusted file input. CVE-2019-11470 is about uncontrolled resource consumption due to lack of validation between declared size and actual data. The target code lacks validation on the `line_info_offset` and `comp_dir` string length before `strdup`, which could lead to similar resource exhaustion, but the code patterns and data structures are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection vulnerability in a printer protocol handler. The target code is a binary data parser with no injection or output generation context. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2017-13033 is an Out-of-Bounds Read in a binary protocol parser (tcpdump's VTP dissector). The target code is also a binary parser (DWARF) that reads attributes from a buffer (`buf`). Both must carefully manage buffer bounds (`buf_end` checks in `parse_attr_value`). The key similarity is the pattern of parsing untrusted binary data with length fields and complex structures, making bounds checking critical. The reference value is significant for ensuring safe parsing.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. CVE-2016-8670 is a bounds checking vulnerability in an image data processing function in PHP/GD, leading to out-of-bounds read/write. The target code's core function is to parse data from a buffer (`buf`) with a specified end (`buf_end`). The safety critically depends on the correct implementation of `parse_attr_value` and its internal bounds checks. Both involve complex, multi-step parsing of binary data where integer overflows/underflows and offset calculations are key risks. Provides valuable reference for secure parser design.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2016-7425 is a Buffer Overflow in a kernel driver due to insufficient validation of length parameters. The target code does not have an obvious length validation flaw on the surface, but the `parse_attr_value` function (not shown) is responsible for reading variable-length data based on `attr_form`. If it improperly validates lengths or offsets, it could lead to buffer over-reads. The similarity lies in parsing controlled binary data where missing checks can lead to memory corruption. Has reference value for input validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2022-31031_before_subset_100:33011477:vulspec": {
    "timestamp": "2026-01-17T03:28:50.554378",
    "cve_id": "CVE-2022-31031",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "33011477",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a file processing module of libguestfs. The target code is a STUN message parser performing structured binary parsing with length validation, with no dynamic memory allocation or deallocation visible in the provided snippet. The vulnerability types and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an injection vulnerability (CWE-93) due to improper neutralization of CRLF sequences in IPP attribute processing within CUPS. The target code parses binary STUN attributes with length fields, performing bounds checking but no string/content sanitization. The domains (printing protocol vs. network signaling protocol) and flaw nature are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is an out-of-bounds read (CWE-125) in tcpdump's VTP parser due to insufficient validation of length fields before memory access. The target code also parses a network protocol (STUN) with TLV-like attributes and performs length validation (`if (msg_len < len)`). Both involve parsing attacker-controlled network packets and checking length fields to prevent buffer over-reads. The core vulnerability pattern (bounds checking) is similar, though the specific protocols and memory models differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in libxml2 related to external entity processing. The target code parses binary STUN messages, not XML, and has no entity resolution mechanism. The attack surfaces and vulnerability classes are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read (CWE-125) in libxml2 due to improper buffer management during multi-byte character encoding processing. The target code performs arithmetic on length fields but does not involve character encoding or multi-byte sequences. The context and root cause are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 6 is a resource consumption vulnerability (CWE-400) in an image decoder due to lack of validation between declared dimensions and actual data. The target code validates length fields against the received buffer size. Both perform some length validation, but the target code's validation appears more comprehensive (checking `msg_len` and per-attribute `len`). The vulnerability outcome (DoS vs. potential buffer overflow) and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 is a buffer boundary violation (CWE-119) in PHP's GD library due to incorrect bounds checking involving arithmetic (potential underflow). The target code performs arithmetic on length fields (`len = (len + 3) & ~3;`, `msg_len = (pj_uint16_t)(msg_len - len)`) and validates results. Both involve arithmetic operations on attacker-controlled length values and subsequent bounds checks. The pattern of calculating derived lengths and validating them is similar, though the specific arithmetic and potential for integer overflow/underflow requires deeper analysis of the target's data types.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 8 is a use-after-free (CWE-416) in Exim's SMTP header processing. The target code shown does not perform any dynamic memory allocation or release; it operates on a provided buffer. The memory management models and vulnerability types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 is an input validation flaw (CWE-20) leading to path traversal issues in libarchive. The target code validates binary lengths but does not process file system paths or links. The domains and vulnerability patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 10 is a heap buffer overflow (CWE-122) in glibc's glob() due to an off-by-one allocation error. The target code does not dynamically allocate memory based on calculated sizes in the shown snippet. The memory operations and flaw nature are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-31031_after_subset_100:37c404c7:vulspec": {
    "timestamp": "2026-01-17T03:29:12.527739",
    "cve_id": "CVE-2022-31031",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "37c404c7",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a file processing function within a virtual disk inspection library. The target code is a STUN message parser performing network packet validation with no dynamic memory allocation or deallocation. The domains (VM disk inspection vs. network protocol parsing) and flaw types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is an improper neutralization/CRLF injection (CWE-93) in a printing system's PPD file generator. The target code parses binary STUN messages, performing length and type validation. There is no text-based command or output generation, and the attack surfaces (network packets vs. IPP protocol responses) and vulnerability patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Case 3 is an out-of-bounds read (CWE-125) in a network protocol dissector (tcpdump's VTP parser). The target code is also a network protocol parser (STUN) that performs length field validation (`msg_len`, `len`) to prevent reading beyond buffer boundaries (`buf_len`). Both involve parsing TLV-like structures from untrusted network data. The key similarity is bounds checking logic for variable-length attributes/fields. Relevance is moderate because the specific flaw patterns (insufficient validation leading to OOB read) and the domain (network parsing) align, though the protocols differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in an XML parser. The target code parses a binary STUN protocol, does not process markup languages, entities, or external references. The vulnerability classes and code patterns are entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 5 is an out-of-bounds read (CWE-125) in an XML/HTML parser related to character encoding handling. The target code performs structured binary parsing with explicit length checks but does not involve multi-byte character decoding or complex encoding state management. The root cause patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2016-1833"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 6 is an uncontrolled resource consumption issue (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code validates length fields (`msg_len`, attribute `len`) against the actual buffer size (`buf_len`), which is a similar conceptual step: verifying that declared data size matches available data. However, the vulnerability outcome (DoS via allocation vs. parsing errors) and context (image parsing vs. network parsing) reduce relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 is a buffer boundary violation (CWE-119) due to incorrect bounds checking in an image processing library. The target code also performs bounds checking (e.g., `if (msg_len < len)`). The similarity lies in the need to validate derived lengths against available data. However, the specific flaw (arithmetic underflow) and domain (image data vs. network packet) are different, making reference value limited.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a use-after-free (CWE-416) in an MTA related to memory management during message processing. The target code does not dynamically allocate or free memory within the function; it operates on a provided buffer. The memory safety flaw categories are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 9 is an input validation issue (CWE-20) leading to path traversal/link problems in an archive extraction library. The target code validates numeric lengths and types within a binary packet but does not process filesystem paths or links. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a heap buffer overflow (CWE-122) due to an off-by-one error in a path expansion function. The target code performs arithmetic for length alignment (`(len + 3) & ~3`) and subtraction (`msg_len - len`), which requires care to avoid miscalculations, but there is no dynamic memory allocation based on these calculations within the function. The flaw patterns and contexts are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      }
    ]
  },
  "CVE-2022-23579_before_subset_100:9a2770b8:vulspec": {
    "timestamp": "2026-01-17T03:29:18.880312",
    "cve_id": "CVE-2022-23579",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "9a2770b8",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs graph node safety checks for optimization (DependencyOptimizer) and does not involve memory management, double-free, or file parsing. The vulnerability case is about a double-free in a virtual disk image library during file content processing. The domains (graph optimization vs. VM disk access) and flaw types (logic validation vs. memory corruption) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code is a static analysis/optimization function checking node properties in a computational graph. The vulnerability case involves improper input validation leading to path traversal during archive extraction. There is no similarity in functionality (graph analysis vs. filesystem operations), attack surface, or vulnerability pattern (logic condition vs. input validation).",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code validates node properties for safe removal; it does not process external data formats, generate files, or handle CRLF sequences. The vulnerability case is about command injection via CRLF in a printing protocol. The contexts (compiler/runtime optimization vs. printer configuration) and flaw mechanisms are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Both involve validation logic, but the similarity ends there. The target code validates graph structure constraints (e.g., node types, connections) for safe transformations. The vulnerability case is about missing validation of numeric input leading to an assertion failure in an image parser. The core issue (missing bounds check on untrusted data) is not present in the target code, which works on a trusted internal graph representation.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code performs read-only checks and does not modify or free any data structures. The vulnerability case is a use-after-free/double-free during deallocation of linked structures in a binary analysis tool. The operations (inspection vs. deallocation) and vulnerability classes (logic error vs. memory corruption) are not relevant.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both codes perform validation, but the nature is different. The target code validates topological and type constraints within a graph (e.g., IsSwitch, IsRetval). The vulnerability case misses validation of untrusted file metadata (image dimensions) leading to resource exhaustion. The target code's validation is about internal consistency, not sanitizing external input.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "No meaningful relevance. The target code is a simple predicate function with no complex string processing, memory allocation, or buffer operations. The vulnerability case is a heap buffer overflow due to an off-by-one error in a path expansion function. The domains and flaw types are entirely distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. The target code does not parse any external data formats, handle entities, or process untrusted input streams. The vulnerability case is about improper restriction of XML external entities. The functionality (graph optimization vs. XML parsing) and security concern (logic correctness vs. external resource injection) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. The target code contains no dynamic memory allocation or resource management. It only queries a node map and checks conditions. The vulnerability case is a memory leak in an error path of an image conversion utility. The absence of resource acquisition/release in the target code makes this case irrelevant.",
        "case_metadata": {
          "cve_id": "CVE-2019-6128"
        }
      },
      {
        "score": 5,
        "reasoning": "No relevance. The target code performs simple integer comparisons and list traversals with no complex arithmetic, loops, or block mapping logic. The vulnerability case is an integer overflow leading to an infinite loop in a filesystem block mapping function. The operational domains and flaw patterns are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-23579_after_subset_100:38f5da89:vulspec": {
    "timestamp": "2026-01-17T03:29:45.013421",
    "cve_id": "CVE-2022-23579",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "38f5da89",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code performs graph node safety checks for optimization (DependencyOptimizer). Case 1 (CVE-2013-2124) is a double-free vulnerability in a file processing function within libguestfs. The domains (graph optimization vs. VM disk image processing), vulnerability types (logic flaw vs. memory corruption), and code patterns (control flow validation vs. resource cleanup) are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code validates node properties in a computational graph. Case 2 (CVE-2016-5418) involves improper input validation leading to path traversal/symlink issues in a file extraction library (libarchive). The domains (compiler/graph optimization vs. filesystem operations), attack surfaces (internal graph vs. external archive files), and flaw nature (logic condition vs. input sanitization) are unrelated. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "The target code performs validation checks before removing identity nodes. Case 4 (CVE-2017-9499) is a reachable assertion due to insufficient numeric input validation in an image library (ImageMagick). There is a weak similarity in the theme of \"validation before an operation,\" but the context (graph optimization vs. image parsing), flaw specifics (logic conditions vs. assertion on unchecked input), and consequences are vastly different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 3,
        "reasoning": "The target code checks relationships between nodes in a graph. Case 5 (CVE-2018-12320) is a use-after-free/double-free in a linked structure cleanup function in a reverse engineering tool (radare2). There is a weak conceptual link in analyzing and manipulating graph-like structures (basic blocks vs. computation graph nodes). However, the vulnerability type (memory corruption vs. logic flaw), operational context, and code patterns are distinct. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "The target code validates node dependencies and types. Case 6 (CVE-2019-11470) is an uncontrolled resource consumption issue due to lack of validation between declared image dimensions and file size in ImageMagick. The weak similarity is the concept of \"validation before proceeding.\" However, the domain (graph optimization vs. image parsing), the nature of the unchecked data (graph topology vs. image dimensions), and the resulting flaw (incorrect optimization vs. DoS) are different. Weak relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code is a pure logic function with no memory manipulation. Case 7 (CVE-2017-15670) is a heap buffer overflow due to an off-by-one calculation in a path expansion function (glibc). The domains, vulnerability types (logic condition vs. memory corruption), and code patterns (conditional returns vs. pointer arithmetic and allocation) are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code checks internal graph node properties. Case 8 (CVE-2013-0339) is an XXE (XML External Entity) vulnerability in a parsing library (libxml2). The domains (compiler optimization vs. XML parsing), attack surfaces (internal graph vs. external document), and vulnerability types (logic flaw vs. external resource injection) are completely unrelated. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code performs checks and returns a boolean; it does not acquire or release resources. Case 9 (CVE-2019-6128) is a memory leak on error paths in a TIFF conversion utility (libtiff). The core issue of resource management on error paths is absent from the target code. The domains and flaw types are mismatched. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2019-6128"
        }
      },
      {
        "score": 2,
        "reasoning": "The target code performs logical checks with no arithmetic operations. Case 10 (CVE-2017-18257) is an integer overflow leading to an infinite loop in a filesystem driver (Linux kernel F2FS). The domains (user-space graph optimization vs. kernel filesystem), vulnerability types (logic condition vs. integer overflow/DoS), and code patterns (conditional checks vs. block size calculations and loops) are fundamentally different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-3037_before_subset_100:4e5d5047:vulspec": {
    "timestamp": "2026-01-17T03:29:51.482114",
    "cve_id": "CVE-2022-3037",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4e5d5047",
    "scores": [
      {
        "score": 3,
        "reasoning": "Low relevance. Case 1 involves a double-free (CWE-415) in a file content processing module of libguestfs. The target code is a buffer management function in Vim's quickfix feature. While both involve memory management, the specific flaw patterns (double-free vs. potential buffer/index management errors), domains (VM disk inspection vs. editor UI), and trigger conditions are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is about CRLF injection (CWE-93) leading to command injection in CUPS PPD file generation. The target code deals with internal buffer line insertion and deletion for a quickfix window. There is no parsing of external data formats, no command generation, and no injection vector. The functional domains are entirely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is an uncontrolled resource consumption (CWE-400) in an image decoder due to lack of validation between declared dimensions and data size. The target code manages a line buffer based on a linked list (qfline_T). A weak similarity exists in the potential for an infinite loop if `qfp->qf_next` forms a cycle, or if `lnum` and `qfl->qf_count` are mismanaged, leading to resource exhaustion. However, the data source (internal list vs. external file) and flaw mechanism are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an XXE (CWE-611) vulnerability in libxml2. The target code does not parse XML or any external data formats. It processes an internal linked list to populate an editor buffer. There is no entity expansion or external reference handling involved.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 is a use-after-free (CWE-416) in a reverse engineering tool due to improper cleanup of a linked structure (`next` pointer). The target code also traverses a linked list (`qfline_T` via `qf_next`). If this list were corrupted (e.g., a cycle introduced via `qf_next`), the `while` loop could become infinite, resembling a logic error that could lead to DoS. The core issue of mishandling linked list traversal is similar, but the consequence in the target code is more likely a loop rather than a memory corruption exploit.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 6 is a heap buffer overflow (CWE-122) due to an off-by-one error in glibc's glob function. The target code uses `ml_delete` and `qf_buf_add_line` which may involve buffer operations, but the code shown does not contain obvious, direct buffer arithmetic or size calculations prone to off-by-one errors. The domains (pathname expansion vs. editor buffer filling) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Low relevance. Case 7 is a buffer bounds violation (CWE-119) in PHP's GD library due to incorrect bounds checking and integer underflow. The target code's primary risk is logical errors in loop control and list traversal, not direct buffer index calculations on pixel/data buffers. The function `qf_buf_add_line` could have internal bounds issues, but it's not the primary pattern shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a race condition (CWE-362) leading to use-after-free in the Linux kernel TTY subsystem. The target code is a single-threaded UI buffer update function in an editor (Vim). There is no concurrency, no ioctl handling, and no reference-counted object management evident in the provided code.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 9 is an integer overflow (CWE-190) leading to an infinite loop (CWE-835) in a filesystem driver. The target code uses `linenr_T` (likely a signed integer) for line numbers and loops based on `lnum < qfl->qf_count`. If `qfl->qf_count` is extremely large or negative due to an earlier error, it could cause a very long loop or wrap-around, resembling an integer handling issue leading to resource consumption. The similarity is conceptual (loop control via integers) but not in the specific overflow mechanism.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 is a buffer overflow (CWE-119) in a network driver due to incorrect fragment count handling. The target code deals with text lines in an editor buffer, not network packet fragments. There is no sg list, no feature negotiation, and the data structures are completely different (linked lists vs. scatter-gather arrays).",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2022-3037_after_subset_100:252fa8e6:vulspec": {
    "timestamp": "2026-01-17T03:30:43.273481",
    "cve_id": "CVE-2022-3037",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "252fa8e6",
    "scores": [
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 1 involves a double-free vulnerability (CWE-415) in a file processing module due to improper memory ownership and cleanup. The target code is a buffer management function in an editor/IDE context (likely Vim's quickfix feature). While both involve buffer/file operations, the target code's primary operations are line insertion/deletion (`ml_delete`) and does not show explicit dynamic memory allocation/deallocation patterns that would lead to a double-free. The vulnerability type and trigger conditions are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is about CRLF injection (CWE-93) leading to command injection in a printing system's PPD file generation. The target code deals with populating a display buffer with error lines from a quickfix list. There is no indication of command execution, parsing of untrusted data formats, or insufficient neutralization of control sequences. The functional domains and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is an uncontrolled resource consumption (CWE-400) issue in an image parser due to lack of validation between declared dimensions and actual data. The target code iterates over a linked list (`qfl->qf_count`) to add lines to a buffer. There is a potential similarity in iterating based on a count (`lnum < qfl->qf_count`), but the count here likely comes from an internal list size, not from untrusted input parsing. The risk of a similar integer overflow or unbounded loop causing DoS is much lower and the context is different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in an XML parser. The target code does not parse XML or any external file formats. It processes an internal quickfix list structure. There is no entity resolution or external resource fetching involved. The attack surfaces and code patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 5 is a use-after-free (CWE-416) leading to double-free in a linked list cleanup function within a reverse engineering tool. The target code also manipulates linked lists (`qfline_T` with `qf_next` pointers). While the target code's primary function is insertion (`qf_buf_add_line`), not deallocation, the pattern of traversing a linked list (`qfp = qfp->qf_next`) is similar. A potential risk in the target code could arise if the `qfl` list is corrupted or freed concurrently during this traversal, but the code shown does not handle list deallocation. The similarity is in the data structure pattern, not the specific vulnerability.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 6 is a heap buffer overflow (CWE-122) due to an off-by-one error in a path expansion function. The target code uses fixed-size buffers (`dirname[MAXPATHL]`) and calls functions like `qf_buf_add_line`. While buffer overflows are a common concern, the target code does not show obvious miscalculations of buffer sizes or loop boundaries related to user input. The `MAXPATHL` buffer is used but not obviously misused in the shown snippet. The relevance is low as the specific off-by-one pattern is not evident.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is a buffer boundary violation (CWE-119) in an image processing library due to incorrect bounds checking involving arithmetic underflow. The target code performs bounds-checked iteration (`lnum < qfl->qf_count`) and calls `ml_delete`. The primary similarity is the general category of memory safety. However, the target code's operations are on line numbers and buffer lines, not on raw byte buffers where integer underflow/overflow in size calculations is a typical flaw. The connection is tenuous.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 is a race condition (CWE-362) leading to use-after-free in a kernel TTY subsystem. The target code is a user-space function populating a buffer. While concurrency issues could theoretically affect any shared data structure (like the `qfl` list or the `buf`), the code snippet shows no locking or synchronization, and the context (likely Vim's UI thread) may not be highly concurrent. The specific pattern of accessing a pointer (`tty->ldisc`) without a lock is not mirrored here. The relevance is low.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is an integer overflow (CWE-190) leading to an infinite loop (CWE-835) in a filesystem driver. The target code uses `linenr_T` (likely a signed or unsigned long) for `lnum` and compares it against `qfl->qf_count`. If `qfl->qf_count` is extremely large, the loop `while (lnum < qfl->qf_count)` could be long-running, but not necessarily infinite due to overflow. The code does not show arithmetic operations on these counts that could wrap. The similarity is only in the generic concept of loop termination conditions.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 10 is a buffer overflow (CWE-119) in a network driver due to incorrect assumptions about fragment counts. The target code uses fixed-size arrays (`dirname[MAXPATHL]`) and calls functions that may copy data. The general risk of buffer overflows exists if `qf_buf_add_line` or `tv_get_string_chk` produce strings that exceed the `dirname` buffer, but this is not shown. The specific flaw pattern of miscalculating array sizes for a list of fragments is not present. Relevance is low.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      }
    ]
  },
  "CVE-2017-15670_before_subset_100:b358bbd0:vulspec": {
    "timestamp": "2026-01-17T03:30:51.023234",
    "cve_id": "CVE-2017-15670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "b358bbd0",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The target code is the glibc glob() function, which is the exact system and component referenced in CVE-2017-15670. The vulnerability type (heap-based buffer overflow due to off-by-one in memory allocation) directly relates to the complex memory allocation and path construction logic in the provided code, especially around tilde expansion (~) and directory name handling. The attack surface (malicious pattern input) and key flaw (bounds checking during allocation) are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 involves a double-free in libguestfs during file content processing and error handling. The target glob code performs complex memory management but focuses on pattern expansion and path construction, not file content reading. The ownership semantics and error handling patterns are different. The core functionality and attack surface (guest disk images vs. path patterns) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in libxml2's XML parser. The target code is a pathname pattern matcher in glibc. The domains (XML parsing vs. filesystem globbing), vulnerability type (improper restriction of external entities vs. memory corruption/DoS), and code patterns are fundamentally different. No meaningful reference value for the glob implementation.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-12320 is a use-after-free/double-free in radare2's basic block analysis linked structure cleanup. The target glob code manages dynamic arrays (gl_pathv) and allocated strings, not complex linked data structures like basic blocks. The memory management patterns (array reallocation vs. pointer chasing during free) and attack surface (binary analysis vs. path expansion) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. CVE-2019-11470 is an uncontrolled resource consumption (CWE-400) in ImageMagick due to lack of validation between declared image dimensions and actual data. The glob function could potentially be abused for resource exhaustion via deep directory traversal or many matches, but the mechanism is different. The target code does validate patterns and has allocation limits, but the high-level concept of validating input claims against reality is a weak parallel.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2019-19012 is an out-of-bounds read in Oniguruma's regex engine due to integer overflow in pointer arithmetic. The glob function performs string pattern matching but uses different algorithms (wildcard expansion vs. regex execution). While both process user input patterns, the specific flaw (integer overflow in distance calculation) and the low-level pointer manipulation code are not present in the high-level path construction logic shown.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection in CUPS during PPD file generation from IPP attributes. The target code does not generate configuration files, process network protocols, or execute commands. The vulnerability type (injection) and domain (printing system configuration) are completely unrelated to filesystem path expansion.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2016-8670 is a buffer overflow in PHP's GD library due to incorrect bounds checking involving arithmetic underflow. The glob code has numerous buffer copies and size calculations (e.g., using mempcpy, calculating dirlen). While the specific underflow flaw is not evident, the pattern of performing arithmetic on user-influenced sizes (like pattern_len) before allocation carries similar risks. The relevance is limited to the general category of bounds calculation errors.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2016-5418 is a path validation issue in libarchive during hardlink extraction, leading to potential symlink attacks. The glob function reads directory listings but does not create files, links, or perform filesystem modifications. Its purpose is pattern matching, not archive extraction. While both deal with paths, the vulnerability context (creation time vs. read time) and the lack of filesystem modification in glob reduce relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. CVE-2018-1140 is an input validation flaw in Samba's LDAP server where a failed string transformation leads to a NULL pointer dereference. The glob code has extensive input validation and error handling (e.g., checking for NULL returns from getpwnam_r). However, the domain (LDAP query processing vs. path globbing) and the specific flaw pattern (missing NULL check after a string operation) are not directly analogous to the primary concerns in the glob implementation.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      }
    ]
  },
  "CVE-2017-15670_after_subset_100:db73f18e:vulspec": {
    "timestamp": "2026-01-17T03:31:07.107740",
    "cve_id": "CVE-2017-15670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "db73f18e",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The target code is the glibc glob() function, which is the exact same function and module as in CVE-2017-15670. The vulnerability described in the case (heap-based buffer overflow due to off-by-one error in home directory expansion) directly maps to the code paths in the target function that handle tilde expansion (~user), memory allocation for dirname, and bounds calculations (e.g., lines checking `newcount > SIZE_MAX / sizeof (char *) - 2`). The attack surface (pattern input with tilde) and key flaw (incorrect bounds/memory allocation) are identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The case involves a double-free vulnerability in libguestfs related to file content processing and error handling. The target code is a pathname pattern matcher with complex memory management but focuses on allocation, reallocation, and appending to arrays, not double freeing of the same pointer. The functional domains (VM disk inspection vs. filesystem globbing) and core flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The case involves XML external entity (XXE) processing in a parsing library. The target code performs filesystem path expansion with no XML parsing, external entity fetching, or related functionality. The vulnerability type (CWE-611) and attack surface are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The case involves a use-after-free/double-free in a data structure (linked list of basic blocks) during cleanup. The target code manages dynamic arrays of path strings (`gl_pathv`) with realloc and free, but its structure is a contiguous array, not a linked list. While both involve careful memory management in C, the specific flaw pattern (circular references in linked nodes) is not present in the target code's logic.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The case involves uncontrolled resource consumption (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code performs memory allocation based on calculated string lengths (e.g., `dirlen`, `home_len + dirlen`). There is a tangential similarity in performing allocations based on user-influenced input (pattern length) without exhaustive upper-bound validation in all paths, but the core context (image decoding vs. string manipulation) and typical flaw manifestation are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The case involves an out-of-bounds read due to integer overflow in pointer arithmetic. The target code contains numerous size calculations (e.g., `dirlen + 2`, `home_len + dirlen`, `newcount + 2`) and uses `alloca`/`malloc`. While the primary vulnerability in the target code (CVE-2017-15670) was an off-by-one, integer overflows in these calculations are a potential concern. The relevance is moderate because both are C libraries processing untrusted input with complex arithmetic, but the specific code patterns (regex bytecode traversal vs. path string manipulation) differ.",
        "case_metadata": {
          "cve_id": "CVE-2019-19012"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The case involves CRLF injection leading to command injection in a printer configuration generator. The target code processes filesystem paths and expands patterns but does not generate configuration files, parse network protocols, or execute commands. The vulnerability type (CWE-93) is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The case involves improper bounds checking leading to out-of-bounds read/write (CWE-119) due to an arithmetic underflow/overflow check flaw (`remain == 0`). The target code has many buffer size calculations and copies (e.g., using `mempcpy`). It must ensure allocated buffers are large enough for the copied data. The pattern of incorrect bounds validation is similar, though the specific context (image data buffer vs. pathname strings) differs. The relevance is elevated because both are memory safety issues in C stemming from arithmetic on user-controlled sizes.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The case involves improper input validation (CWE-20) leading to path traversal or filesystem state issues during archive extraction. The target code validates and manipulates pathnames (e.g., handling `..`, `/`, `\\`). It includes logic for tilde expansion, directory traversal, and slash appending. There is similarity in processing untrusted path-like strings and the need to avoid security issues like directory traversal. However, the target code is a pattern matcher, not an archive extractor, so the specific flaw of creating files from hardlink entries is not present.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The case involves improper input validation (CWE-20) and error handling leading to a NULL pointer dereference (CWE-476) in an LDAP query translator. The target code has extensive error handling (checking `malloc` returns, `getpwnam_r` results) and uses `__set_errno`. The pattern of failing to check for NULL after a function call is a general C programming pitfall. However, the specific context (LDAP DN case folding failure vs. glob pattern/username lookup) and the consequent exploit path (SQL injection vs. crash or memory error) are very different.",
        "case_metadata": {
          "cve_id": "CVE-2018-1140"
        }
      }
    ]
  },
  "CVE-2021-3521_before_subset_100:3cc580b2:vulspec": {
    "timestamp": "2026-01-17T03:31:17.612598",
    "cve_id": "CVE-2021-3521",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "3cc580b2",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 1 (CWE-415 Double Free) involves memory ownership and cleanup issues during error handling. The target code also performs cleanup (pgpDigParamsFree) but only in the error path, and the pointer is set to NULL on success. The pattern is not identical; the target code's memory management appears more straightforward, lacking the complex double-free chain from inconsistent state.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 2 (CWE-416 Use After Free) involves improper cleanup of linked structures leading to double-free. The target code manages a single `digp` structure, not a linked list. However, both involve parsing external input (packets/binary files) and have conditional cleanup logic. The reference value is in the pattern of parsing loops and managing allocated resources based on input data.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 (CWE-611 XXE) is about XML external entity processing. The target code parses PGP packet structures, which is a binary format, not a markup language. The vulnerability types, attack surfaces, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 (CWE-93 CRLF Injection) involves improper neutralization of control sequences in a text-based protocol (IPP) leading to command injection. The target code parses binary PGP packets and does not generate or interpret text-based commands or files. The domains and flaw types are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 5 (CWE-122 Heap Buffer Overflow) involves an off-by-one error in memory allocation calculations. The target code does not perform complex arithmetic for allocations; it uses helper functions (`decodePkt`, `pgpPrtPkt`). While buffer overflows could be present in those helpers, the shown code pattern does not directly mirror the off-by-one allocation flaw.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 (CWE-400 Resource Consumption) involves lack of validation between declared size and actual data, leading to excessive allocation. The target code parses packets based on length fields (`pktlen`, `pkt.blen`). If `decodePkt` or `pgpPrtPkt` do not properly validate these lengths against the input buffer, a similar resource exhaustion issue could occur. The pattern of trusting length fields from untrusted input is a weak similarity.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 7 (CWE-665 Improper Initialization) involves leaving structures in an undefined state after an error path. The target code initializes `digp` to NULL and `rc` to -1, and only assigns `digp` on successful allocation. The main loop can break on errors, leaving `digp` potentially partially initialized. The pattern of error handling and state cleanup has some conceptual similarity, but the specific uninitialized memory exposure vector is not clearly present.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 (CWE-119 Buffer Overflow) involves insufficient validation of length parameters before memory operations. The target code passes length values (`pend - p`, `pkt.blen`) to parsing functions. If `decodePkt` or `pgpPrtPkt` contain buffer operations without proper bounds checking, a similar issue could exist. The pattern of trusting length fields derived from input data is a weak link.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 (CWE-119 Buffer Overflow) involves incorrect assumptions about feature support leading to insufficient buffer allocation for network fragments. The target code deals with sequential parsing of PGP packets, not parallel fragment reassembly. The code patterns and data structure management are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 (CWE-119 Buffer Overflow) involves incorrect bounds checking due to arithmetic issues (underflow). The target code performs pointer arithmetic (`p += (pkt.body - pkt.head) + pkt.blen`). If `pkt.body` is before `pkt.head` or `pkt.blen` is very large, this could lead to an underflow/wrap-around, causing `p` to move backwards and breaking the loop invariant. This is a potential similarity in flawed pointer arithmetic, though not the primary focus of the shown code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2021-3521_after_subset_100:8520f694:vulspec": {
    "timestamp": "2026-01-17T03:31:46.460075",
    "cve_id": "CVE-2021-3521",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8520f694",
    "scores": [
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 1 (CWE-415 Double Free) involves memory ownership and cleanup issues during error handling. The target code has dynamic memory allocation (`xmalloc`, `xrealloc`) and cleanup (`free`, `pgpDigParamsFree`), but its control flow and error paths (using `break` and final `rc` check) appear designed to prevent double-free scenarios by consistently freeing `all` and conditionally freeing `digp`. The pattern is not identical to the inconsistent state management that caused the double free in libguestfs.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Case 2 (CWE-416 Use After Free) involves improper cleanup of linked structures leading to memory corruption. The target code manages an array of structures (`all`) with dynamic reallocation, not linked lists. However, it does involve complex state (`digp`, `selfsig`, `expect`, `prevtag`) across a loop parsing packets, which could theoretically lead to state confusion and improper freeing if the parsing logic (`decodePkt`, `pgpPrtPkt`) or verification (`pgpVerifySelf`) fails in unexpected ways. The reference value is limited to the general concept of managing allocated objects across complex parsing states.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 3 (CWE-611 XXE) is about improper restriction of XML external entity references during parsing. The target code parses PGP packet structures from a binary buffer, not text-based XML. The vulnerability types, attack surfaces (binary vs. text markup), and parsing models are fundamentally different. No reference value for the specific flaw.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 4 (CWE-93 CRLF Injection) involves improper neutralization of control sequences during text file generation. The target code parses binary PGP data and does not generate text-based configuration files. The functionality and vulnerability class are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 5 (CWE-122 Heap Buffer Overflow due to off-by-one) involves an arithmetic error in memory allocation. The target code performs dynamic allocation (`xmalloc`, `xrealloc`) based on a calculated size (`alloced * sizeof(*all)`). While it's crucial that this calculation is correct and `alloced` doesn't overflow, the code shows a simple doubling strategy. The relevance is only in the general category of dynamic array growth, but the specific off-by-one flaw pattern is not present.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 6 (CWE-400 Uncontrolled Resource Consumption) involves allocating memory based on unvalidated input dimensions. The target code's primary allocation is for the `all` array, whose size is driven by the number of packets parsed (`i`), not directly by unvalidated fields within the packet data. However, the packet parsing functions (`decodePkt`, `pgpPrtPkt`) could potentially consume resources based on packet contents. The connection is indirect and the code patterns are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 7 (CWE-665 Improper Initialization) involves leaving kernel struct fields uninitialized on an error path, leading to information disclosure. The target code initializes its local variables (e.g., `digp = NULL`, `selfsig = NULL`, `rc = -1`). While proper initialization is always important, the specific pattern of complex protocol parsing leaving state uninitialized on specific error returns is not evident in this high-level function. The relevance is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 8 (CWE-119 Buffer Overflow) involves insufficient validation of length parameters before memory operations. The target code does not perform obvious buffer copies directly from the input data (`pkts`). However, it passes the data to parsing functions (`decodePkt`, `pgpPrtPkt`). If those functions lack proper bounds checking relative to `pktlen`/`pend`, similar buffer overflows could occur. The relevance lies in the context of parsing untrusted binary data, but the specific flaw pattern is not visible in this code snippet.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Case 9 (CWE-119 Buffer Overflow in a driver due to incorrect feature assumption) is highly specific to kernel network driver semantics and scatter-gather lists. The target code is user-space PGP parsing logic with completely different data structures and operations. No meaningful similarity in vulnerability patterns.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Case 10 (CWE-119 Buffer Overflow due to arithmetic underflow) involves incorrect bounds checking logic. The target code uses pointer arithmetic (`p += (pkt->body - pkt->head) + pkt->blen`) to advance through the input buffer. Ensuring this calculation does not underflow or overflow, and that `p` remains within `[pkts, pend)`, is critical to prevent out-of-bounds reads/writes in subsequent parsing. This is a relevant general concern for safe parser implementation, but the specific underflow flaw pattern is not shown.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      }
    ]
  },
  "CVE-2022-29779_before_subset_100:410c52ac:vulspec": {
    "timestamp": "2026-01-17T03:32:33.856691",
    "cve_id": "CVE-2022-29779",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "410c52ac",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability (CWE-415) in a virtual machine disk image processing library. The target code is an array splice implementation in a JavaScript-like VM, focusing on index calculations and array element manipulation without dynamic memory deallocation. The vulnerability types, domains, and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 is a use-after-free/double-free (CWE-416) in a reverse engineering framework related to linked list cleanup. The target code performs array operations (copying, deleting, inserting elements) with careful bounds checking and does not involve manual memory management of complex linked structures or pointer invalidation issues.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 3 is a heap buffer overflow (CWE-122) due to an off-by-one allocation error in glibc's glob function. The target code also performs bounds calculations (e.g., `length + delta > NJS_MAX_LENGTH`) and array index manipulations. While both involve careful arithmetic to prevent overflow, the target code's vulnerability profile is more about integer overflows leading to memory allocation issues or OOB accesses within its array structures, not a direct off-by-one buffer overflow.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 4 is an XXE vulnerability (CWE-611) in an XML parser. The target code is a pure array manipulation function with no parsing, external entity handling, or network/data deserialization aspects. The domains and flaw patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 5 is an uncontrolled resource consumption issue (CWE-400) due to lack of validation between declared image dimensions and actual data. The target code validates that `length + delta` does not exceed `NJS_MAX_LENGTH`, which is a form of input validation to prevent excessive memory allocation. However, the context (image parsing vs. array operations) and specific flaw patterns (dimension vs. index calculation) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 6 is a CRLF injection/command injection (CWE-93) in a printing system's PPD file generation. The target code performs no string formatting, command generation, or output neutralization. It deals solely with numerical indices and array values.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 7 is a buffer overflow (CWE-119) in PHP's GD library due to incorrect bounds checking involving arithmetic underflow. The target code contains numerous bounds calculations (`njs_min`, `njs_max`, `length - start`, `length + delta`) and array index operations (`memcpy`, loop conditions). A similar risk exists if integer overflows/underflows occur in these calculations (e.g., `length + delta`, `start + delete`), potentially leading to out-of-bounds memory access. The pattern of careful arithmetic validation is shared, though the specific underflow trigger differs.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 8 is a path validation issue (CWE-20) leading to symlink/hardlink problems in an archive library. The target code has no filesystem, path, or link operations. It operates entirely on in-memory array data structures.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 9 is a reachable assertion (CWE-617) due to insufficient validation of an input numeric field. The target code validates some inputs (e.g., `length + delta > NJS_MAX_LENGTH`) but does not use assertions. The shared concept is validating numeric inputs to prevent invalid states, but the manifestation (assertion crash vs. memory corruption/error return) and context differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 is a buffer overflow (CWE-119) in a kernel driver due to insufficient validation of a user-controlled length parameter. The target code validates user-provided indices (`start`, implicit `delete` count) against the array `length` using `njs_min`/`njs_max`. Both involve validating user input to prevent OOB access. However, the target code operates at a higher abstraction level (array objects) and the potential overflow is more about index arithmetic leading to incorrect `memcpy` or property access bounds, rather than a direct buffer copy based on an unvalidated length.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2022-29779_after_subset_100:f7f8fa13:vulspec": {
    "timestamp": "2026-01-17T03:32:47.699152",
    "cve_id": "CVE-2022-29779",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f7f8fa13",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code is an array splice implementation in a JavaScript-like VM, focusing on array element manipulation and memory management. CVE-2013-2124 is a double-free vulnerability in a virtual disk image inspection library. The vulnerability type (double-free vs. array bounds/type confusion), domain (VM array operations vs. file parsing), and attack surface are completely different. Only very generic concepts of memory management are shared.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool's linked list cleanup. The target code performs array operations (copying, deleting, inserting) with careful length calculations and does not involve freeing or managing linked list nodes. The core flaw patterns (pointer invalidation vs. integer overflow/bounds checking) and functional domains are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-15670 is a heap buffer overflow in glibc's glob() due to an off-by-one allocation error. The target code also performs bounds calculations (e.g., `length + delta`) and has length checks, which is a superficial similarity. However, the vulnerability type (off-by-one allocation in path expansion) and context are vastly different from the array index and length manipulation in the target. The reference value is minimal.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 1,
        "reasoning": "CVE-2013-0339 is an XXE vulnerability in libxml2. The target code is a pure array manipulation function with no XML parsing, external entity resolution, or trust boundary issues. There is no meaningful similarity in vulnerability type, code patterns, or attack surface.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2019-11470 is an uncontrolled resource consumption (CWE-400) issue in an image decoder due to lack of validation between declared dimensions and data size. The target code has a check `(length + delta) > NJS_MAX_LENGTH` to prevent excessive length growth, which is a conceptual similarity in validating computed sizes against a limit to prevent resource exhaustion. However, the specific flaw (integer overflow leading to huge allocation vs. controlled array expansion) and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "CVE-2017-15400 is a CRLF injection/command injection vulnerability in a printing system's PPD file generation. The target code performs internal array operations with no string parsing, output generation, or command injection vectors. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "CVE-2016-8670 is a buffer overflow in PHP's GD library due to incorrect bounds checking involving integer arithmetic that could underflow. The target code involves significant integer arithmetic for indices (`start`, `length`, `delta`, `delete`, `items`) and has bounds checks (e.g., `njs_min`, `njs_max`, the `NJS_MAX_LENGTH` check). The pattern of calculating new lengths and indices and validating them is similar. A potential vulnerability in the target code could be an integer overflow in the `length + delta` calculation before the check, or an off-by-one error in the `memcpy` or loop bounds. This provides moderate reference value for secure integer and bounds handling.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-5418 is a path validation/symlink race issue in libarchive. The target code deals with abstract array indices and values, not filesystem paths, links, or race conditions. No relevance beyond the generic concept of input validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2017-9499 is a reachable assertion due to insufficient validation of an input field against a maximum limit. The target code validates `length + delta` against `NJS_MAX_LENGTH`, which is a similar pattern of validating a computed value against a system limit. However, the vulnerability manifestation (assertion crash vs. memory corruption or logic error) and context are different. Has weak reference value for the validation pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2016-7425 is a buffer overflow in a kernel driver due to insufficient validation of a user-controlled length parameter. The target code validates user-influenced parameters (`start`, `delete` derived from arguments) against the current `length` using `njs_min`/`njs_max`. This is a direct similarity: both involve validating attacker-controlled integer inputs used in memory operations (like `memcpy` or loop bounds in the target). The target's `memcpy(&array->start[start], &args[3], items * sizeof(njs_value_t))` relies on prior validation. A flaw could exist if validation is incomplete (e.g., for `start` when `length` is 0). Provides weak-to-moderate reference value for input validation patterns.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      }
    ]
  },
  "CVE-2022-27376_before_subset_100:74df93de:vulspec": {
    "timestamp": "2026-01-17T03:33:01.847760",
    "cve_id": "CVE-2022-27376",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "74df93de",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 (CWE-415 Double Free in libguestfs) involves memory ownership and cleanup issues in a file processing utility. The target code is a database table opening function in MySQL, focusing on metadata locking, share acquisition, and resource management. The vulnerability types (double free vs. potential use-after-free or logic errors), domains (VM disk inspection vs. DBMS), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 2 (CWE-611 XXE in libxml2) deals with improper restriction of external entity references during XML parsing. The target code handles database table metadata, locking, and share structures. There is no similarity in vulnerability type, attack surface (XML input vs. DB queries/state), or functional domain.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 (CWE-416 Use After Free in Exim) involves improper memory ownership tracking during email header processing. The target code also manages complex resource lifecycles (TABLE, TABLE_SHARE, MDL tickets) and has error paths that could potentially lead to similar issues if cleanup is inconsistent. However, the domain (MTA vs. DBMS) and specific patterns (store_release vs. tdc_release_share/tc_release_table) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 (CWE-416 Use After Free in radare2) involves incomplete cleanup of linked structures (basic blocks) leading to double-free. The target code manages linked lists (thd->open_tables, share's used tables) and has multiple acquisition/release paths for shares and tables. A similar flaw could exist if list pointers are not properly nullified or reference counts are mishandled during error cleanup, but the context and data structures are different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 (CWE-119 Buffer Overflow in Linux SCSI driver) involves insufficient validation of user-controlled length parameters leading to heap corruption. The target code performs validation (e.g., stack overrun, killed flag, read-only transactions) but does not process similar untrusted length fields from network or user input in a way that would lead to buffer overflows. The domains (kernel driver vs. DBMS userland) and flaw patterns are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 6 (CWE-20 Improper Input Validation in libarchive) involves path validation issues during archive extraction leading to symlink/hardlink races. The target code validates table names and paths via the MDL key and share acquisition but does not involve filesystem path resolution in a similar way. The vulnerability class (input validation) is broad, but the specific context and attack surface are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 7 (CWE-93 CRLF Injection in CUPS) involves improper neutralization of control sequences in IPP attributes leading to command injection. The target code does not generate or parse text-based configuration files from untrusted sources in a similar manner. The vulnerability type and domain are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 (CWE-400 Uncontrolled Resource Consumption in ImageMagick) involves lack of validation between declared image dimensions and actual data size, leading to excessive memory allocation. The target code allocates memory for TABLE and TABLE_SHARE structures, but sizes are not directly derived from untrusted input in a comparable way. The resource consumption risk is more indirect (e.g., many open tables).",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 9 (CWE-190 Integer Overflow in Linux F2FS) involves integer overflow in block size calculations leading to an infinite loop. The target code uses integers for lengths and flags but does not perform arithmetic operations on untrusted sizes that could overflow in a similar way. The domain (filesystem block mapping vs. table opening logic) is different.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 10 (CWE-362 Race Condition leading to CWE-416 Use After Free in Linux TTY) involves unprotected access to a shared pointer (tty->ldisc) across concurrent operations. The target code manages shared resources (TABLE_SHARE in TDC) protected by MDL locks and reference counts. While both involve concurrent access to shared state, the synchronization mechanisms (MDL, table cache) are more structured than the simple missing lock in the TTY case. The pattern of accessing a resource after it might have been freed by another thread is conceptually similar, but the implementation context differs greatly.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      }
    ]
  },
  "CVE-2022-27376_after_subset_100:dc71ee81:vulspec": {
    "timestamp": "2026-01-17T03:33:12.286333",
    "cve_id": "CVE-2022-27376",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "dc71ee81",
    "scores": [
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in libguestfs related to file content processing. The target code is MySQL's table opening logic, which involves complex resource management (MDL locks, table shares, TABLE objects) but follows a different pattern. The memory management in the target code uses reference counting (tdc_acquire_share/tc_add_table) and explicit release patterns, not the ad-hoc ownership issues leading to double-free.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in libxml2. The target code does not parse XML or handle external entities. Its attack surface is SQL table metadata and locking, not document parsing.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2017-16943 is a use-after-free in Exim's BDAT command processing. The target code manages complex state (TABLE, TABLE_SHARE, MDL tickets) with potential for lifetime issues (e.g., if a share is flushed while being used). However, the patterns differ: Exim's flaw is in store_release() semantics during error handling, while MySQL uses reference counting and version checks (share->tdc->flushed) to manage object lifetime. The reference counting reduces UAF risk.",
        "case_metadata": {
          "cve_id": "CVE-2017-16943"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. CVE-2018-12320 is a use-after-free/double-free in radare2 due to circular linked list references. The target code has linked lists (thd->open_tables) but uses simpler linear traversal. The primary resource management is via share reference counting and MDL locks, not complex graph structures that could create circular dependencies during free.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2016-7425 is a buffer overflow in a Linux kernel SCSI driver due to missing length validation. The target code does not perform low-level buffer copies from untrusted sources. Its input (table names) is validated earlier in the SQL layer. The memory operations are mostly structure allocations and pointer assignments.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2016-5418 is a path validation/hardlink issue in libarchive. The target code deals with table and database names (paths in a sense), but validation is minimal (checking db.str not null). However, the core flaw is different: libarchive's issue is filesystem race conditions during extraction, while MySQL's open_table works on an already validated metadata namespace. The similarity is only in the broad category of input validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-15400 is a CRLF injection/command injection in CUPS PPD generation. The target code does not generate shell commands or interpret CRLF sequences. It constructs internal data structures (TABLE) and acquires locks.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2019-11470 is an uncontrolled resource consumption (integer overflow leading to huge allocation) in ImageMagick. The target code allocates memory for TABLE and TABLE_SHARE structures, but sizes are fixed or based on internal metadata (not directly from untrusted file data). The `open_table_from_share` could potentially allocate based on file data, but that's several layers down, not in this function.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-18257 is an integer overflow leading to an infinite loop in the Linux kernel F2FS. The target code has loops (e.g., iterating thd->open_tables) but they are bounded by list length. No complex arithmetic on untrusted sizes occurs here. The integer operations are simple assignments and comparisons.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. CVE-2016-0723 is a race condition leading to use-after-free in the Linux kernel tty subsystem. The target code operates in a multi-threaded environment (THD represents a connection) and manages shared resources (TABLE_SHARE in table definition cache). It uses MDL locks to synchronize access. However, there are still potential time-of-check-to-time-of-use (TOCTOU) issues, e.g., checking `share->tdc->flushed` and then using the share. The code has retry logic (`goto retry_share`) to handle some state changes, but subtle races could remain. The relevance is in the general concurrency and state management challenges, though the specific patterns (lockless pointer access vs. MDL locks) differ.",
        "case_metadata": {
          "cve_id": "CVE-2016-0723"
        }
      }
    ]
  },
  "CVE-2022-29208_before_subset_100:2684f15c:vulspec": {
    "timestamp": "2026-01-17T03:33:32.785269",
    "cve_id": "CVE-2022-29208",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "2684f15c",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code involves careful memory management via TensorFlow's OP_REQUIRES_OK and Tensor objects, with no manual memory allocation/deallocation. CVE-2013-2124 is a double-free vulnerability in libguestfs related to manual string handling and error paths. The memory management models and error handling patterns are fundamentally different. Relevance is very low.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2019-11470 is an uncontrolled resource consumption (CWE-400) issue in ImageMagick due to lack of validation between declared image dimensions and file size. The target code validates tensor shapes and checks output element counts (OP_REQUIRES(ctx, output_elements > 0, ...)), but the core vulnerability pattern (unbounded allocation based on unvalidated user input) is not present. Only weak similarity in performing basic validation.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "CVE-2017-15400 is a CRLF injection/command injection (CWE-93) vulnerability in CUPS PPD generation. The target code performs mathematical computations on tensor data and writes float values to an output tensor. There is no string processing, command generation, or CRLF sequence handling. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-5418 is an improper input validation/path traversal issue in libarchive during hardlink extraction. The target code validates tensor indices and shapes but deals with abstract mathematical indices and dimensions, not filesystem paths. The domain and attack surface are completely different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2017-9499 is a reachable assertion (CWE-617) due to insufficient validation of a numeric input field (`number_meta_channels`). The target code includes validation of tensor shapes and checks that calculated indices (`loc`) are within bounds of the output tensor (`OP_REQUIRES(ctx, loc < output_elements, ...)`). There is a weak similarity in validating numeric bounds to prevent out-of-bounds access, but the mechanisms (assertion vs. runtime error) and context (image processing vs. tensor computation) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2017-15670 is a heap buffer overflow (CWE-122) due to an off-by-one error in memory allocation in glibc's glob. The target code has multiple bounds checks to ensure `loc < output_elements` before writing to `output_t(loc)`. This is a defensive pattern against out-of-bounds writes. The relevance is moderate because both involve preventing buffer overflows through bounds checking, but the cause (allocation miscalculation vs. index calculation validation) and domain are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 1,
        "reasoning": "CVE-2013-0339 is an XXE (CWE-611) vulnerability in libxml2. The target code processes tensor data, not XML. There is no parsing of markup languages or external entity resolution. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free (CWE-416) in radare2 due to improper cleanup of linked structures. The target code uses RAII-style Tensor objects managed by TensorFlow's runtime, with no manual pointer manipulation or linked list traversal. The memory management paradigms are entirely different. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2015-8877 is a resource management error/memory leak (CWE-399) in libgd's image scaling. The target code allocates an output tensor via `ctx->allocate_output` and relies on TensorFlow's runtime to manage its lifetime. There is no visible manual resource management that could lead to leaks in the shown code path. Very low relevance.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-19843 is an out-of-bounds read (CWE-125) in radare2 due to insufficient bounds checking on an array index. The target code's primary defensive mechanism is checking the calculated index `loc` against `output_elements` before writing. This is conceptually similar to preventing an out-of-bounds access, though the target code focuses on writes and uses a different validation pattern (explicit check vs. missing check). The relevance is moderate due to the common theme of bounds validation.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      }
    ]
  },
  "CVE-2022-29208_after_subset_100:1c67d758:vulspec": {
    "timestamp": "2026-01-17T03:34:12.569791",
    "cve_id": "CVE-2022-29208",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1c67d758",
    "scores": [
      {
        "score": 2,
        "reasoning": "The target code involves sparse tensor operations with careful bounds checking (OP_REQUIRES) and no dynamic memory allocation/deallocation visible in the snippet. CVE-2013-2124 is a double-free vulnerability in a file processing module with different memory ownership patterns. The functional domains (tensor computation vs. VM disk inspection) and flaw patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 3,
        "reasoning": "CVE-2019-11470 involves uncontrolled resource consumption due to lack of validation between declared image dimensions and actual data. The target code validates tensor shapes (ValidateShapes, OP_REQUIRES on output_elements > 0) and performs bounds checking on computed indices. While both involve input validation, the vulnerability pattern (memory exhaustion vs. buffer overflow prevention) and domain (image parsing vs. tensor math) are only weakly similar.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 1,
        "reasoning": "CVE-2017-15400 involves CRLF injection and command injection in a printing system's PPD generation. The target code performs mathematical computations on tensor data with no string processing, command execution, or protocol handling. No relevance in vulnerability type or code patterns.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2016-5418 involves improper input validation leading to path traversal and filesystem issues in an archive library. The target code validates tensor indices and shapes but operates purely in memory on mathematical structures, with no filesystem or path operations. The core flaw (path validation vs. array bounds checking) is conceptually related to input validation but in completely different contexts.",
        "case_metadata": {
          "cve_id": "CVE-2016-5418"
        }
      },
      {
        "score": 4,
        "reasoning": "CVE-2017-9499 involves a reachable assertion due to insufficient validation of a numeric input field (number_meta_channels). The target code includes multiple validation checks (OP_REQUIRES) on tensor shapes and computed indices. Both emphasize the importance of validating numeric inputs before use, but the manifestation (assertion crash vs. potential buffer overflow) and context (image metadata vs. tensor dimensions) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 6,
        "reasoning": "CVE-2017-15670 is a heap buffer overflow due to an off-by-one error in memory allocation. The target code shows careful bounds checking using OP_REQUIRES to ensure computed indices (loc) are within the output tensor bounds (0 <= loc && loc < output_elements). This pattern directly addresses the type of vulnerability CVE-2016-15670 represents. The relevance is moderate because the defensive code in the target is specifically designed to prevent such out-of-bounds writes, though the domains differ (path expansion vs. tensor indexing).",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 1,
        "reasoning": "CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code performs numerical computation on sparse tensors with no XML parsing, external entity resolution, or network operations. No relevance.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2018-12320 is a use-after-free/double-free in a reverse engineering tool's data structure cleanup. The target code manages tensor objects via library classes (SparseTensor) and does not show explicit manual memory management, allocation, or deallocation. The vulnerability patterns (memory corruption vs. bounds-checked array access) are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 2,
        "reasoning": "CVE-2015-8877 is a memory leak in an image scaling function. The target code allocates an output tensor via ctx->allocate_output and performs computations on it, but no complex, multi-pass allocation of temporary resources is visible. The resource management patterns are different.",
        "case_metadata": {
          "cve_id": "CVE-2015-8877"
        }
      },
      {
        "score": 5,
        "reasoning": "CVE-2018-19843 is an out-of-bounds read due to insufficient bounds checking on an array index (segment register). The target code's core defensive mechanism is bounds checking array indices (via OP_REQUIRES on `loc`). The similarity lies in the fundamental need to validate indices before array access. The relevance is weak to moderate because the target code demonstrates correct bounds checking to prevent the type of flaw CVE-2018-19843 exhibits, but the contexts (assembly operand access vs. tensor index calculation) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2018-19843"
        }
      }
    ]
  },
  "CVE-2022-1350_before_subset_100:8af68de7:vulspec": {
    "timestamp": "2026-01-17T03:34:36.758360",
    "cve_id": "CVE-2022-1350",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "8af68de7",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 is a double-free vulnerability (CWE-415) in libguestfs, involving complex error handling and ownership semantics. The target code performs a simple memory copy and conditional buffer deallocation based on read/write positions. While both involve memory management, the core flaw patterns (double-free vs. potential arithmetic/pointer issues) and trigger conditions are different. The target code's `min` operation and pointer arithmetic are more relevant to bounds checking than to double-free scenarios.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 2 is a CRLF injection/command injection vulnerability (CWE-93) in CUPS related to IPP attribute processing. The target code is a simple status buffer read function with memory copy and pointer arithmetic. There is no similarity in vulnerability type, domain, or code patterns. The target code deals with binary data copying, not string parsing or protocol handling.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 3 is a buffer overflow (CWE-119) in a Linux kernel SCSI driver due to insufficient validation of length parameters. The target code uses `min(max_data, pcs->status.write_pos - pcs->status.read_pos)` to calculate a copy count, which is a bounds check. However, if `write_pos` or `read_pos` are corrupted or miscalculated elsewhere, the subtraction could underflow/wrap, or the pointer arithmetic `pcs->status.buffer + pcs->status.read_pos` could point out of bounds. The pattern of calculating a size before a `memcpy` is similar, but the target code's check appears safer at first glance. The relevance lies in the general category of buffer boundary validation.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a use-after-free (CWE-416) leading to double-free in radare2, involving linked list cleanup. The target code frees a buffer when `read_pos == write_pos` and resets pointers. This could be problematic if the function is called again with stale pointers or if the buffer is accessed after free elsewhere, but the pattern is not a direct match. The primary similarity is the act of freeing memory, but the vulnerability mechanisms (complex structure cleanup vs. simple linear buffer management) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is an XXE vulnerability (CWE-611) in libxml2. The target code is a low-level memory buffer read function with no XML parsing, external entity handling, or similar functionality. Domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 is a buffer overflow (CWE-119) in a USB driver related to DMA and stack buffers. The target code also involves buffer operations (`memcpy`) and pointer arithmetic. The connection is the general risk of buffer overflows if the calculated `count` or the pointer offset is incorrect. However, the driver-specific context (USB, DMA) and the stack vs. heap buffer distinction reduce the direct relevance. The core similarity is the unsafe memory copy pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is a heap buffer overflow (CWE-122) in glibc's glob due to an off-by-one allocation error. The target code does not perform memory allocation; it copies into a pre-allocated `data` buffer. The potential relevance lies in the arithmetic for `count` and pointer offsets. An off-by-one error in managing `write_pos` or `read_pos` elsewhere could lead to similar out-of-bounds access. However, the vulnerability patterns (allocation miscalculation vs. copy bounds calculation) are not identical.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low to weak relevance. Case 8 is a resource exhaustion vulnerability (CWE-400) in ImageMagick due to lack of validation between image dimensions and data size. The target code validates copy size using `min`. The only faint similarity is the concept of validating sizes before operations, but the vulnerability class (DoS via allocation vs. memory corruption) and context are very different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is a buffer overflow (CWE-119) in PHP's GD library due to incorrect bounds checking involving arithmetic underflow (`remain == 0` check failing for negative values). The target code's key operation is `pcs->status.write_pos - pcs->status.read_pos`. If these `uint` values are unsynchronized (e.g., `read_pos > write_pos` due to an earlier error), the subtraction will underflow, producing a very large `count` value, bypassing the `min` check (as `max_data` is also a `uint`). This could lead to a massive buffer overflow in the `memcpy`. The pattern of integer underflow in a size calculation leading to an out-of-bounds copy is highly similar. The main difference is the specific context (image processing vs. generic status buffer).",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is an integer overflow (CWE-190) in the Linux kernel F2FS leading to an infinite loop. The target code uses unsigned integer subtraction (`write_pos - read_pos`). If `read_pos` is greater than `write_pos`, this underflows/wraps around to a large number, which is an integer wraparound issue. This could cause the `min` to select `max_data` incorrectly if `max_data` is also large, or cause an overflow in the pointer arithmetic. While the consequence in the target code is more likely a buffer overflow than an infinite loop, the root cause of integer wrap in a size calculation is similar. The relevance is in the arithmetic vulnerability pattern.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-1350_after_subset_100:4d2a47fa:vulspec": {
    "timestamp": "2026-01-17T03:34:49.860082",
    "cve_id": "CVE-2022-1350",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "4d2a47fa",
    "scores": [
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 1 is a double-free vulnerability (CWE-415) related to improper cleanup and ownership semantics. The target code frees a buffer but also sets the pointer to NULL, which is a correct mitigation against double-free. The core flaw patterns (ownership confusion vs. buffer management) are different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 2 is about CRLF injection (CWE-93) leading to command injection in a printing protocol. The target code performs a memory copy and buffer management with no string parsing, protocol handling, or command generation. The domains and flaw types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 4 is a use-after-free (CWE-416) enabled by incomplete structure cleanup. The target code frees a buffer and nulls the pointer, preventing a classic use-after-free on that buffer. The similarity is limited to both involving memory deallocation, but the specific flaw mechanism (linked list corruption vs. simple buffer release) is different.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 5 is an XXE vulnerability (CWE-611) in an XML parser. The target code has no functionality related to parsing, external entities, or file/network input. The domains and vulnerability classes are entirely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 6 is a buffer overflow (CWE-119) in a USB driver, involving improper buffer handling during DMA. The target code performs a bounded `memcpy` using a calculated `count`. The shared concept is ensuring memory operations stay within buffer bounds. The relevance is weakened because the target code's vulnerability surface (if any) would be in the calculation of `write_pos` and `read_pos`, not direct hardware/DMA issues.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 7 is a heap buffer overflow (CWE-122) due to an off-by-one error in allocation. The target code uses `memcpy` with a `count` that could theoretically be incorrect if `write_pos` or `read_pos` are corrupted, leading to an overflow. The pattern of copying data based on calculated lengths is similar, but the specific off-by-one miscalculation pattern is not evident in the target code.",
        "case_metadata": {
          "cve_id": "CVE-2017-15670"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low to weak relevance. Case 8 is a resource exhaustion vulnerability (CWE-400) due to lack of validation between declared size and actual data. The target code reads from a fixed-size buffer and does not perform any allocation based on untrusted size fields. The only faint similarity is the manipulation of positions (`read_pos`, `write_pos`) which, if maliciously large, could cause issues, but that's not the core flaw of Case 8.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. Case 9 is a buffer overflow (CWE-119) due to incorrect bounds checking where an arithmetic underflow leads to a large `count`. The target code's safety hinges entirely on the `min()` operation and the validity of `write_pos` and `read_pos`. If these unsigned integers underflow (e.g., `read_pos > write_pos`), `count` becomes very large due to unsigned wrap-around, leading to a massive buffer overflow in `memcpy`. This is a highly similar pattern: integer wrap-around in a size calculation leading to an unbounded copy.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is an integer overflow (CWE-190) leading to an infinite loop. The target code uses unsigned integer arithmetic for pointer offsets and `count` calculation. While no loop is present, an integer overflow/wrap-around in `write_pos` or `read_pos` could lead to the miscalculation of `count`, similar to the initial integer issue in Case 10. The consequence in the target code would be a buffer overflow, not an infinite loop, but the root cause class (integer handling) is relevant.",
        "case_metadata": {
          "cve_id": "CVE-2017-18257"
        }
      }
    ]
  },
  "CVE-2022-28463_before_subset_100:1f5082c8:vulspec": {
    "timestamp": "2026-01-17T03:35:10.610196",
    "cve_id": "CVE-2022-28463",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "1f5082c8",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. Both target code (CIN reader) and case (Cineon reader) are ImageMagick coders for similar/related image formats (Cineon/CIN). The core flaw in CVE-2019-11470 is lack of validation between declared image dimensions and actual file data size, leading to uncontrolled resource consumption (CWE-400). The target code performs a check: `if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image)) ThrowReaderException(...)`. This is a direct mitigation for the exact vulnerability pattern. The code patterns (header parsing, dimension assignment, size validation) are nearly identical, making this case a highly valuable reference for understanding the vulnerability class and its fix.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are ImageMagick coders, but the vulnerability type differs significantly. CVE-2017-12667 is a memory leak (CWE-401) in the MAT coder during error handling. The target CIN code shows careful resource cleanup (e.g., `DestroyImageList`, `DestroyQuantumInfo`) and does not exhibit obvious patterns of resource leaks on error paths. The functional domain (MATLAB vs. CIN) and the specific flaw mechanism are not similar.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The case is in PHP's GD library (CWE-119, buffer overflow due to arithmetic underflow). The target code is an ImageMagick CIN parser. While both involve image processing, the system, language (C vs. PHP C extension), vulnerability root cause (arithmetic underflow vs. dimension validation), and code patterns are fundamentally different. No direct reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are ImageMagick coders (SGI vs. CIN). The vulnerability in CVE-2016-7101 is an out-of-bounds read (CWE-125) due to insufficient validation of image dimensions (`iris_info.rows`) before memory operations. The target code validates dimensions against file size (`((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image)`), which is precisely the type of check missing in the SGI case. The attack surface (malicious file with manipulated dimensions) and the defensive coding pattern are very similar, providing strong reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are ImageMagick coders. CVE-2017-9499 is a reachable assertion (CWE-617) due to lack of validation for a numeric field (`number_meta_channels`). The target CIN code does validate numeric inputs (e.g., checking `count != 4` for magic, validating dimensions against file size). However, it does read many numeric fields (offsets, lengths) from the file header (e.g., `cin.file.image_offset`, `cin.file.user_length`) and uses them in calculations and loops. While not identical to the assertion flaw, the pattern of trusting file-supplied integers without extensive validation is a shared risk, offering some reference.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The case is in CUPS, involving CRLF injection (CWE-93) in PPD generation from IPP attributes. The target code is an ImageMagick image parser. The systems, domains (printing vs. image processing), vulnerability types (injection vs. memory/resource issues), and code patterns are completely unrelated. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both are ImageMagick coders (DICOM vs. CIN). CVE-2018-16644 involves improper input validation (CWE-20) of DICOM element sizes, leading to potential excessive memory allocation. The target CIN code reads several length fields from the file (`cin.file.user_length`, `cin.file.image_offset`) and uses them to control reads and allocations (e.g., checking `cin.file.user_length > GetBlobSize(image)`). This is a similar pattern of validating declared lengths against actual file boundaries. The vulnerability type and defensive pattern are relevant, though the specific format structures differ.",
        "case_metadata": {
          "cve_id": "CVE-2018-16644"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The case is a double-free (CWE-415) in libguestfs during file content processing error handling. The target code is an ImageMagick image parser. The systems, domains (VM inspection vs. image parsing), and vulnerability types (memory ownership error vs. validation error) are dissimilar. The target code does not show complex ownership patterns or cleanup functions that could lead to a double-free in a comparable way.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are ImageMagick coders (DIB vs. CIN). CVE-2018-12600 is an out-of-bounds write (CWE-787) due to insufficient validation of image dimensions and integer overflow in size calculation. The target code performs a critical dimension vs. file size check to prevent related issues. The attack vector (malformed file with manipulated header fields), the core risk (invalid dimensions leading to memory corruption), and the necessary mitigation (size validation) are highly similar. This case provides strong reference for understanding the threat model.",
        "case_metadata": {
          "cve_id": "CVE-2018-12600"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are ImageMagick coders (PSD vs. CIN). CVE-2016-7514 is an out-of-bounds read (CWE-125) due to improper validation of bit depth parameters when reading channel pixels. The target CIN code reads pixel data using `ReadBlobStream` and `ImportQuantumPixels` based on calculated `length`. It validates the overall image data size but does not show deep validation of per-channel parameters like bits per pixel against expected ranges, which is a similar validation gap at a different layer. The domain (pixel data decoding) and potential for out-of-bounds access due to file-controlled parameters are similar, providing moderate reference value.",
        "case_metadata": {
          "cve_id": "CVE-2016-7514"
        }
      }
    ]
  },
  "CVE-2022-28463_after_subset_100:f7101349:vulspec": {
    "timestamp": "2026-01-17T03:35:19.397414",
    "cve_id": "CVE-2022-28463",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "f7101349",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. Both involve ImageMagick's image format parsers (CIN vs Cineon). The core flaw in CVE-2019-11470 is lack of validation between declared image dimensions and actual file data size before memory allocation. The target code performs a similar check: `if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image)) ThrowReaderException(...);`. However, this check occurs AFTER `SetImageExtent` (which likely allocates memory). This pattern of validating dimensions after allocation is the same vulnerability pattern. The code structure, library context, and attack vector (malformed header fields) are nearly identical.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Both are ImageMagick coders, but CVE-2017-12667 is a memory leak (CWE-401) in the MAT coder during error handling. The target CIN coder shows extensive error handling with `ThrowReaderException`, but no obvious resource cleanup flaws are visible in the provided snippet. The vulnerability type and code patterns differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-12667"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-8670 is in PHP's GD library, involving buffer handling and arithmetic underflow. The target code is an ImageMagick CIN parser in C. The system, domain, and vulnerability pattern (buffer bounds check flaw) are fundamentally different. No similar arithmetic or buffer size calculations are evident in the provided CIN code.",
        "case_metadata": {
          "cve_id": "CVE-2016-8670"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are ImageMagick coders (SGI vs CIN). CVE-2016-7101 is an out-of-bounds read due to insufficient validation of image dimensions (`iris_info.rows`) before memory operations. The target code reads `cin.image.channel[0].lines_per_image` and `pixels_per_line` and uses them to set `image->rows` and `image->columns`. It validates the product against file size but does not validate each individual dimension for reasonableness (e.g., against MAX_INT or memory limits) before `SetImageExtent`. The pattern of reading untrusted header values and using them for memory operations is very similar.",
        "case_metadata": {
          "cve_id": "CVE-2016-7101"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Both are ImageMagick coders. CVE-2017-9499 is a reachable assertion due to lack of validation on a numeric field (`number_meta_channels`). The target code reads many numeric fields (e.g., `cin.image.number_channels`, `bits_per_pixel`) but does not show explicit validation against maximums like `MaxPixelChannels`. The similarity is in parsing untrusted numeric headers, but the specific flaw (assertion trigger) and the affected field are different. The reference value is limited.",
        "case_metadata": {
          "cve_id": "CVE-2017-9499"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. CVE-2017-15400 is in CUPS, involving CRLF injection in PPD generation. The target is an ImageMagick image parser. The systems, functionality (printing vs image parsing), and vulnerability type (injection vs memory/resource issues) are completely unrelated. No reference value.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both are ImageMagick coders (DCM vs CIN). CVE-2018-16644 involves improper validation of DICOM element sizes against file boundaries. The target code validates `cin.file.user_length` against `GetBlobSize(image)` before reading user data. It also validates the product of dimensions against file size. The pattern of validating declared lengths against available data is similar. However, the DCM vulnerability is more about element chunking, while CIN is about overall image data size.",
        "case_metadata": {
          "cve_id": "CVE-2018-16644"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free in libguestfs during error handling of file reading. The target code is an ImageMagick image parser. The systems and core flaw (memory ownership error) are different. The target code uses structured error throwing (`ThrowReaderException`) which may reduce such risks, but the pattern is not similar.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Both are ImageMagick coders (DIB vs CIN). CVE-2018-12600 is an out-of-bounds write due to insufficient dimension validation and integer overflow. The target code reads dimensions from file and calculates `length = GetBytesPerRow(image->columns, ...)`. If `image->columns` is huge, `GetBytesPerRow` could overflow, leading to a small `length` being used to read a huge row, causing a buffer overflow in `ReadBlobStream` or `ImportQuantumPixels`. The pattern of using untrusted dimensions in size calculations is identical, though the specific calculation differs.",
        "case_metadata": {
          "cve_id": "CVE-2018-12600"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Both are ImageMagick coders (PSD vs CIN). CVE-2016-7514 is an out-of-bounds read due to improper validation of bit depth parameters. The target code reads `cin.image.channel[0].bits_per_pixel` and uses it in `GetBytesPerRow`. If this value is invalid (e.g., 0 or very large), the byte calculation could be wrong, leading to incorrect `length` and potential out-of-bounds read in the pixel reading loop. The pattern of using untrusted header values for buffer size calculations is similar, but the specific parameter and calculation are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7514"
        }
      }
    ]
  },
  "CVE-2020-15569_before_subset_100:0dd5649d:vulspec": {
    "timestamp": "2026-01-17T03:35:57.763179",
    "cve_id": "CVE-2020-15569",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "0dd5649d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The target code exhibits a classic pattern for a Use-After-Free (CWE-416) vulnerability, which is the same primary CWE as Case 1 (CVE-2018-12320). The flaw is triggered by accessing `mixer->isActive()` and `mixer->isDeviceRemoved(player)` after the `mixer` object has potentially been deleted in the preceding `if (mixer) delete mixer;` statement. This pattern of accessing a member of a freed object within a destructor, due to incorrect ordering or missing null checks, is highly similar to the linked structure cleanup issues in the historical case.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 9,
        "reasoning": "The target code has a strong potential for a Double Free (CWE-415) vulnerability, which is the primary CWE of Case 2 (CVE-2013-2124). If the `player` object owns or references the `mixer` object (a common design pattern), deleting `mixer` first and then calling `mixer->removeDevice(player)` within the `player` deletion block could lead to a double free if `removeDevice` attempts to access or modify the already-freed `mixer`. This mirrors the inconsistent state management and improper cleanup during error/deletion paths seen in the historical case.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 3 (CVE-2013-0339) is about XML External Entity (XXE) injection (CWE-611), which is a parsing/input validation issue specific to XML. The target code is a C++ destructor performing straightforward resource cleanup with no parsing, external entity handling, or input processing involved. The vulnerability patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 4 (CVE-2019-11470) is about uncontrolled resource consumption (CWE-400) due to lack of validation on input dimensions leading to excessive memory allocation. The target code does not parse any external input or perform allocations based on untrusted data. Its potential issues are related to the order of operations and object lifetime (UAF/Double Free), not resource exhaustion via malicious input.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 5 (CVE-2017-8068) is a buffer overflow (CWE-119) in a kernel driver due to improper DMA buffer handling. The target code is user-space application code performing object deletion with no array/buffer operations, pointer arithmetic, or direct memory copy functions. The vulnerability class and context are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Case 6 (CVE-2017-15400) is about CRLF injection/command injection (CWE-93) during the generation of configuration files from network input. The target code is a destructor cleaning up internal C++ objects and does not process any string data, generate files, or execute commands. There is no meaningful similarity.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 7 (CVE-2016-7425) is a buffer overflow (CWE-119) in a kernel driver due to insufficient validation of length parameters. The target code contains no loops, memory copies, or operations on buffers whose size depends on external input. The core flaw patterns (bounds checking vs. object lifetime management) are different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. Case 8 (CVE-2015-5156) is a buffer overflow (CWE-119) in a network driver due to incorrect assumptions about fragment counts. Similar to Case 5 and 7, this is a low-level memory corruption issue specific to packet processing. The target code's issues are at the object abstraction level, not the raw memory/buffer level.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak to moderate relevance. Case 9 (CVE-2017-13715) involves improper initialization (CWE-665) leading to uninitialized memory access. While different in primary CWE, there is a tangential similarity: both the target code and the historical case involve code paths where an object's state may be invalid (freed in target code, uninitialized in the case) but is still accessed (`mixer->isActive()` vs. accessing uninitialized struct members). However, the root causes (destructor logic error vs. missing initialization on error path) are distinct.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Case 10 (CVE-2013-0290) is an infinite loop (CWE-835) due to improper input validation in a network socket function. The target code is a linear destructor with no loops or input validation logic. The operational domains and defect patterns are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0290"
        }
      }
    ]
  },
  "CVE-2020-15569_after_subset_100:02d9665f:vulspec": {
    "timestamp": "2026-01-17T03:36:24.998199",
    "cve_id": "CVE-2020-15569",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "02d9665f",
    "scores": [
      {
        "score": 7,
        "reasoning": "Moderate relevance. Both involve destructor/cleanup logic and potential memory management issues (CWE-416 Use After Free vs. potential double-free or use-after-free in target code). The target code conditionally calls `mixer->removeDevice(player)` before deleting `player`, which could lead to similar incomplete cleanup or state issues if `mixer` or `player` are in an inconsistent state. However, the specific circular reference pattern from the CVE is not directly visible.",
        "case_metadata": {
          "cve_id": "CVE-2018-12320"
        }
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The core vulnerability is CWE-415 (Double Free). The target code is a destructor performing conditional cleanup and multiple `delete` operations on member pointers (`player`, `mixer`, `audioDriverName`, `listener`). If the class's copy constructor or assignment operator is improperly implemented (violating the Rule of Three/Five), or if an instance is deleted while another reference exists, it could lead to a double-free scenario identical to the historical case. The pattern of manual resource release in a destructor is a direct match.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XML external entity (XXE) injection vulnerability (CWE-611). The target code is a C++ destructor performing straightforward memory deallocation. There is no parsing logic, no external input processing, and no entity expansion mechanism. The domains (XML parsing vs. audio device management) and flaw patterns are completely dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2019-11470 is a resource consumption vulnerability (CWE-400) due to lack of validation on input dimensions leading to excessive allocation. The target code does not parse any external file formats, does not perform allocations based on untrusted input, and only deallocates existing member pointers. The code patterns and vulnerability types are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2019-11470"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-8068 is a kernel driver buffer overflow (CWE-119) involving USB control messages and DMA. The target code is a user-space C++ class destructor with no buffer operations, no I/O handling, and no low-level memory manipulation. The context and flaw mechanism are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. CVE-2017-15400 is an injection vulnerability (CWE-93) due to improper neutralization of CRLF sequences in generated files. The target code contains no string processing, no file I/O, and no command or data injection pathways. The domains and vulnerability patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2017-15400"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7425 is a buffer overflow (CWE-119) in a kernel SCSI driver due to insufficient validation of length parameters. The target code performs no copy operations, accepts no parameters, and has no arrays or buffers that could overflow. The context is entirely different.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2015-5156 is a kernel network driver buffer overflow (CWE-119) related to packet fragmentation. The target code is a simple destructor with no network packet handling, no buffer management, and no complex data structure processing. No meaningful similarity exists.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-13715 is an uninitialized memory issue (CWE-665) in a network packet dissector. The target code does not parse complex data structures, does not have multiple error paths that could leave state uninitialized, and simply deallocates pointers. The flaw pattern is not applicable.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-0290 is an infinite loop vulnerability (CWE-835) in a network datagram receive function due to improper input validation. The target code has no loops, processes no input, and its execution is deterministic based on member pointer states. The vulnerability mechanism is completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0290"
        }
      }
    ]
  },
  "CVE-2019-9633_before_subset_100:de00fd23:vulspec": {
    "timestamp": "2026-01-17T03:36:27.243321",
    "cve_id": "CVE-2019-9633",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "de00fd23",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 1 involves a double-free vulnerability in a file processing function within a disk image library. The target code is a network socket connection callback in GLib's GIO library, focusing on asynchronous connection management, proxy handling, and error cleanup. The memory management patterns, context (network vs. file I/O), and flaw type (double-free vs. potential state/error handling issues) are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 2 is a buffer overflow in a kernel network driver due to incorrect feature declaration and fragment handling. The target code is a user-space network client callback. While both involve network connectivity, the abstraction level, vulnerability mechanism (buffer overflow vs. logic/state error), and attack surface (kernel driver vs. library API) are distinct. The only similarity is the broad network domain.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 3 is a stack buffer overflow/DMA issue in a USB network driver. The target code is a high-level socket connection manager. Both handle network connections, but the vulnerability context (kernel driver with physical hardware access vs. library socket abstraction), flaw type (memory corruption vs. logic flow), and code patterns are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 4 involves improper initialization leading to information disclosure in a kernel packet parser. The target code has error handling paths where `data->last_error` is set and cleared. There is a tangential similarity in the need for proper state initialization and cleanup during error conditions (e.g., `g_clear_error` calls). However, the domain (kernel packet dissection vs. user-space connection setup) and specific flaw remain different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 5 is an infinite loop due to improper input validation in a kernel datagram receive function. The target code is an asynchronous callback driven by connection completion events. There is no loop logic or MSG_PEEK-like functionality in the target code. The domains and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0290"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 6 is a buffer overflow in a SCSI driver due to lack of bounds checking on user input. The target code does not parse or process variable-length data from untrusted sources in a similar way. It primarily manages connection objects and proxies. Both may involve moving data, but the mechanism and risk level are not comparable.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Case 7 is an out-of-bounds read in a packet dissector due to insufficient validation of length fields. The target code reads a protocol string via `g_proxy_address_get_protocol`, but this is not a variable-length field from raw packet data. The parsing complexity and vulnerability pattern (OOB read vs. logic error) are different.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Case 8 is an XXE vulnerability in an XML parser. The target code handles network socket connections and proxy negotiation. There is no parsing of complex, nested document structures or external entity resolution. The functionality and attack surfaces are completely different.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. Case 9 is an integer overflow leading to a buffer overflow in a network protocol library. The target code also implements a network client. While the target code does not perform arithmetic on frame sizes, it does manage asynchronous connection state and could potentially have state management errors under complex cancellation or error scenarios. The relevance is limited to the broad domain of network client libraries.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Case 10 is a divide-by-zero in the kernel TCP stack due to improper state reset during disconnection. The target code manages connection state transitions (e.g., connection attempts, proxy negotiation, TLS handshake) and has complex error handling and cleanup paths (checking `data` for NULL, canceling attempts, clearing errors). There is a conceptual similarity in the need for robust state management during connection lifecycle events to avoid unexpected conditions (like uninitialized values or use-after-free). However, the specific flaw (divide-by-zero) and context (kernel vs. GLib) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-14106"
        }
      }
    ]
  },
  "CVE-2019-9633_after_subset_100:a842ab8c:vulspec": {
    "timestamp": "2026-01-17T03:36:59.837412",
    "cve_id": "CVE-2019-9633",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "vulspec",
    "cases_count": 10,
    "code_hash": "a842ab8c",
    "scores": [
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-2124 is a double-free vulnerability in a file processing function within a virtual disk inspection library. The target code is a network socket connection callback in GLib's GIO library, dealing with asynchronous I/O, proxy negotiation, and connection state management. The domains (VM disk inspection vs. network I/O), vulnerability types (memory corruption vs. logic/state errors), and code patterns are fundamentally different.",
        "case_metadata": {
          "cve_id": "CVE-2013-2124"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2015-5156 is a buffer overflow in a kernel network driver due to incorrect feature negotiation and buffer allocation. The target code handles high-level socket client connection logic, including proxy setup and TLS handshaking. While both involve networking, the target code operates at the application/library level with managed memory (GLib), not kernel-level buffer management. The flaw patterns (buffer calculation vs. connection state logic) are dissimilar.",
        "case_metadata": {
          "cve_id": "CVE-2015-5156"
        }
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. CVE-2017-8068 is a stack buffer overflow/DMA issue in a USB network driver. The target code is user-space, high-level socket connection management. Both involve network connectivity, but the abstraction levels, memory models (kernel driver DMA vs. GLib object lifecycle), and vulnerability mechanisms (low-level buffer handling vs. asynchronous callback logic) are vastly different.",
        "case_metadata": {
          "cve_id": "CVE-2017-8068"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2017-13715 is an uninitialized memory exposure in a kernel network packet parser. The target code also processes network connections and includes multiple code paths based on proxy protocols and connection results. There is a tangential similarity in handling different network protocol states (proxy vs. MPLS) and potential for error state mismanagement. However, the core flaw (initialization vs. logic flow) and context (kernel vs. user library) differ significantly.",
        "case_metadata": {
          "cve_id": "CVE-2017-13715"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-0290 is an infinite loop in a kernel datagram receive function due to improper input validation of the MSG_PEEK flag. The target code is an asynchronous callback for establishing a connection, with no packet queue processing or loop constructs. The domains (core socket datagram ops vs. connection establishment) and flaw patterns are unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0290"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2016-7425 is a buffer overflow in a SCSI driver due to lack of bounds checking on user-controlled length parameters. The target code contains no direct parsing of untrusted length fields or low-level buffer operations. It deals with object references and connection state. The domains (storage driver vs. network client library) and vulnerability patterns are incompatible.",
        "case_metadata": {
          "cve_id": "CVE-2016-7425"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2017-13033 is an out-of-bounds read in a network protocol dissector (tcpdump) due to insufficient validation of length fields. The target code does not parse protocol frames or read packet data; it manages the connection lifecycle. Both are network-related software, but the target code's functionality is at a much higher abstraction level, far removed from raw packet dissection.",
        "case_metadata": {
          "cve_id": "CVE-2017-13033"
        }
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. CVE-2013-0339 is an XXE vulnerability in an XML parser. The target code handles socket connections and proxy negotiation, with no XML parsing or external entity resolution functionality. The domains and vulnerability types are completely unrelated.",
        "case_metadata": {
          "cve_id": "CVE-2013-0339"
        }
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. CVE-2019-18609 is an integer overflow leading to a buffer overflow in an AMQP client library during frame size calculation. The target code is also a network client library (GLib's GSocketClient) handling asynchronous connections. Both are user-space network libraries managing protocol state. The relevance is weak because the target code shown does not contain obvious integer arithmetic on untrusted data; its primary risks appear to be state management errors (e.g., use-after-free if `attempt` or `data` are mishandled) rather than numeric overflows.",
        "case_metadata": {
          "cve_id": "CVE-2019-18609"
        }
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. CVE-2017-14106 is a divide-by-zero in the kernel TCP stack due to improper state reset during disconnection. The target code manages connection state transitions (success, error, cancellation) and cleans up resources. There is a conceptual similarity in the importance of correctly managing object/connection state across multiple branches (success, error, cancellation) and ensuring all fields are in a valid state for subsequent operations. The target code's careful handling of `attempt->cancellable` and cleanup in multiple paths reflects this concern. However, the implementation level (kernel vs. GLib) and specific flaw (arithmetic vs. logic error) differ.",
        "case_metadata": {
          "cve_id": "CVE-2017-14106"
        }
      }
    ]
  }
}