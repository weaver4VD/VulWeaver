{
  "CVE-2019-19054_after_exclude_100:9c94c0dc:spec": {
    "timestamp": "2026-01-16T21:17:50.041619",
    "cve_id": "CVE-2019-19054",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9c94c0dc",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-IO-001: USB device drivers must validate all required endpoints before operation"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-CONF-002: Device configuration must be fully verified before driver initialization"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Driver state transitions must maintain consistent endpoint references"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2016-6296_before_exclude_100:e9bd78bf:spec": {
    "timestamp": "2026-01-16T21:17:50.053226",
    "cve_id": "CVE-2016-6296",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e9bd78bf",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2020-16166_before_exclude_100:f76bbbf0:spec": {
    "timestamp": "2026-01-16T21:17:50.093134",
    "cve_id": "CVE-2020-16166",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f76bbbf0",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Fixed-size buffers must be protected by explicit bounds checking before string operation..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2020-16166_after_exclude_100:14264f78:spec": {
    "timestamp": "2026-01-16T21:17:50.118414",
    "cve_id": "CVE-2020-16166",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "14264f78",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Fixed-size buffers must be protected by explicit bounds checking before string operation..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-34835_after_exclude_100:db90bcaf:spec": {
    "timestamp": "2026-01-16T21:17:50.149225",
    "cve_id": "CVE-2022-34835",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "db90bcaf",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-34835_before_exclude_100:d4fc605f:spec": {
    "timestamp": "2026-01-16T21:17:50.171714",
    "cve_id": "CVE-2022-34835",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d4fc605f",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-0617_before_exclude_100:bdc389bc:spec": {
    "timestamp": "2026-01-16T21:17:50.192940",
    "cve_id": "CVE-2022-0617",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bdc389bc",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2019-19054_before_exclude_100:ce59bd52:spec": {
    "timestamp": "2026-01-16T21:17:50.201924",
    "cve_id": "CVE-2019-19054",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ce59bd52",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-IO-001: USB device drivers must validate all required endpoints before operation"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-CONF-002: Device configuration must be fully verified before driver initialization"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Driver state transitions must maintain consistent endpoint references"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2016-6296_after_exclude_100:de0ced32:spec": {
    "timestamp": "2026-01-16T21:17:50.424380",
    "cve_id": "CVE-2016-6296",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "de0ced32",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-0617_after_exclude_100:e95e560b:spec": {
    "timestamp": "2026-01-16T21:17:51.121132",
    "cve_id": "CVE-2022-0617",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e95e560b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2018-16842_after_exclude_100:65357456:spec": {
    "timestamp": "2026-01-16T21:22:12.549123",
    "cve_id": "CVE-2018-16842",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "65357456",
    "scores": [
      {
        "score": 7,
        "reasoning": "The specification is about validating return values of encoding conversion operations before buffer operations. The code uses `vsnprintf`, which is a formatted output function that could involve encoding. The return value `len` is checked and used to control a loop, but there's no validation for negative returns (error conditions) from `vsnprintf`. This is moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 9,
        "reasoning": "The code uses a fixed-size buffer `print_buffer[256]`. While `vsnprintf` is used with `sizeof(print_buffer)` to prevent overflow, the subsequent logic that processes the buffer in chunks based on `WARN_TEXTWIDTH` operates on the buffer using pointer arithmetic and length values. There is potential for off-by-one errors or incorrect length calculations (e.g., `len -= cut` might be wrong; should likely be `len -= (cut+1)`). This is highly relevant to bounds checking for fixed buffers.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 5,
        "reasoning": "The specification is about character encoding conversions with complete error handling. The code does not perform explicit character encoding conversions (like UTF-8 to UTF-16). It uses `vsnprintf` which may involve some encoding, but error handling for encoding is not implemented. Low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The code is a logging/warning function, not a protocol message parser. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating size parameters for memory allocation operations. The code does not perform dynamic memory allocation (it uses a stack buffer). Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about consistent type handling in protocol implementations. The code is a utility function for output, not a protocol implementation. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about handling embedded NUL bytes in regular expression parsers. The code does not use regular expressions. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about processing escape sequences in pattern compilers. The code does not compile patterns or process escape sequences. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2018-16842_before_exclude_100:8498ebe7:spec": {
    "timestamp": "2026-01-16T21:22:13.588156",
    "cve_id": "CVE-2018-16842",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8498ebe7",
    "scores": [
      {
        "score": 7,
        "reasoning": "The specification is about validating return values of encoding conversion operations. The code uses `vsnprintf`, which is a formatted output function that could be considered a conversion operation. The return value `len` is used to control a loop, but there is no explicit validation for negative values (which `vsnprintf` can return on error). This is moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 3,
        "reasoning": "The specification is about character encoding conversions with complete error handling. The code performs basic string formatting and output, not character encoding conversion (like UTF-8 to UCS-2). Therefore, relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The code is a local warning/printing utility, not a protocol message parser. It does not process any protocol length fields. Relevance is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating size parameters for memory allocation operations. This function does not perform any dynamic memory allocation (`malloc`, `calloc`, etc.). It uses a stack-allocated fixed buffer. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing consistent type handling in protocol implementations. This is a helper function for formatted output, not a protocol implementation. Relevance is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. This code does not use or parse regular expressions. Relevance is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers processing escape sequences. This code outputs warning messages and performs simple line wrapping, but it is not a pattern compiler. Relevance is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-3078_before_exclude_100:d88bf678:spec": {
    "timestamp": "2026-01-16T21:22:13.744570",
    "cve_id": "CVE-2022-3078",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d88bf678",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code uses kzalloc and vzalloc which zero-initialize memory, and explicitly initializes struct members. This directly aligns with HS-MEM-001's requirement for full initialization before use. The only minor concern is that `ctx->last_duration` is initialized after allocation, but this is still proper initialization.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has error handling paths (kzalloc failure checks) that clean up allocated resources (kfree(e) when ctx allocation fails). However, it doesn't handle all potential failure cases consistently (e.g., if vzalloc fails, the function leaks the previously allocated 'e'). This relates to maintaining consistent object states during error handling.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol handlers validating input. The target code is a media encoder initialization function, not a network protocol handler. There's no network input validation happening here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This specification deals with validating protocol message length fields. The code doesn't process any protocol messages or validate length fields. It only handles buffer sizes for media encoding.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code performs some type handling with cpu_to_be16 for endianness conversion (es_pid, stream_id), which relates to consistent type handling. However, this is minimal and not the main focus of the function, making the relevance weak.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code doesn't involve shared resource state transitions or atomic operations. It's an initialization function that allocates and sets up a private encoder context without concurrency considerations visible in this snippet.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains consistency between multiple allocation structures (e, ctx, encoder_buf) and links them together. When ctx allocation fails, it properly cleans up 'e'. However, as noted in spec_2, there's an inconsistency if vzalloc fails. This relates to maintaining strict consistency between different tracking structures.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2021-46784_after_exclude_100:376a1407:spec": {
    "timestamp": "2026-01-16T21:22:14.654661",
    "cve_id": "CVE-2021-46784",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "376a1407",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes input buffers (inbuf) and performs boundary checks (e.g., checking gopherState->len + llen >= TEMP_BUF_SIZE). However, the validation occurs after potential pointer arithmetic and before memory operations, which aligns with the specification's focus on validating buffer boundaries before access. The check prevents overflow into gopherState->buf.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 7,
        "reasoning": "The code maintains buffer state through gopherState->len and gopherState->buf, ensuring incomplete lines are preserved across calls. The invariants (like not exceeding TEMP_BUF_SIZE) are enforced, though the logic for handling leftover data and new input is moderately consistent.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 6,
        "reasoning": "The code performs boundary checking (e.g., TEMP_BUF_SIZE limit) during line processing, which applies to the Gopher protocol's tab-separated encoding. However, the checking is not uniformly applied to all string operations (e.g., strchr usage without length limits).",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 1,
        "reasoning": "The code does not use regular expressions. It processes lines with strchr and strtok, but embedded NUL bytes are not specifically handled. This specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code uses rfc1738_escape_part and rfc1738_escape_unescaped for escape sequences in selectors, but the specification focuses on pattern compilers, which are not present. Boundary checking during escaping is delegated to those functions.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "The code uses memcpy with calculated lengths (llen) and avoids unsafe string functions like strcpy. However, it uses strchr and strtok on the line buffer without explicit length bounds, which could be problematic if the buffer lacks terminators. Overall, length-aware operations are mostly used for untrusted input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform dynamic memory allocation itself (except xstrdup for escaped_selector, which is safely freed). It uses fixed-size buffers (TEMP_BUF_SIZE). Size parameters are validated against TEMP_BUF_SIZE, but not against broader allocation limits. Weak relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-26878_before_exclude_100:cf94634a:spec": {
    "timestamp": "2026-01-16T21:22:16.005173",
    "cve_id": "CVE-2022-26878",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cf94634a",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about validating userspace-provided array lengths against system constraints. The target code processes a kernel sk_buff, not directly userspace input. The length validation for the skb->data access would have occurred earlier in the network stack.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 6,
        "reasoning": "The code handles protocol packets (HCI) and switches based on packet type. It does not explicitly validate the structural integrity of variable-length components within the packet payload (e.g., HCI event data). The skb_pull operation assumes at least 1 byte is available, which is a minimal check but not comprehensive for variable-length structures.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 2,
        "reasoning": "The specification concerns buffer allocation with worst-case input. This function receives an already allocated sk_buff and processes it; it does not perform any memory allocation itself.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 3,
        "reasoning": "Similar to spec 1, this is about validating protocol length fields. The code reads a 1-byte packet type but does not parse or validate any length fields from the packet data itself. That validation would be the responsibility of hci_recv_frame or functions deeper in the call stack.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "The function does not contain any memory allocation operations (like kmalloc, kzalloc). It only manipulates an existing sk_buff.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The core function of this code is protocol type handling. It reads a packet type byte and ensures consistent handling by setting `hci_skb_pkt_type(skb)` before passing to `hci_recv_frame`. This enforces type consistency across processing stages. A missing or invalid pkt_type could lead to misinterpretation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs a TLV-like operation: it reads a Type (pkt_type) and then assumes the rest is the payload (Value). However, it only validates that the skb contains at least 1 byte for the type (via skb_pull). It does NOT validate the length of the subsequent payload against the skb->len before passing it to hci_recv_frame. A proper TLV length check is missing here.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate TLV length before accessing payload data"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. Similar to spec 7. The code treats the packet as a simple TLV structure but lacks strict boundary validation for the payload (the 'V' part). The skb_pull and subsequent use assume the skb data boundaries are correct, which relies on validation earlier in the stack. The function itself does not enforce these boundaries.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message processing must maintain strict boundary validation for all TLV st..."
      }
    ]
  },
  "CVE-2022-26878_after_exclude_100:f99047cc:spec": {
    "timestamp": "2026-01-16T21:22:16.620184",
    "cve_id": "CVE-2022-26878",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f99047cc",
    "scores": [
      {
        "score": 3,
        "reasoning": "Specification HS-INPUT-001 (array length validation) has very low relevance. The code processes a kernel sk_buff structure from a virtio device, not userspace-provided arrays. The skb->data is accessed without explicit length validation, but this is more about protocol validation than userspace array constraints.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 7,
        "reasoning": "Specification HS-PROTOCOL-002 (structural integrity of variable-length components) has moderate relevance. The code handles Bluetooth protocol packets and should verify the skb contains at least 1 byte before reading pkt_type and that subsequent data matches expected packet structures. However, the code shows minimal validation beyond the initial byte.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "Specification HS-MEM-003 (buffer allocation for worst-case scenarios) has weak relevance. The function receives an already allocated sk_buff and doesn't perform memory allocation itself. The concern would be whether upstream allocation accounted for worst-case Bluetooth packet sizes.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-INPUT-001 (protocol length field validation) has very low relevance. While the code processes protocol packets, it doesn't parse length fields from the packet data itself. It only reads a 1-byte packet type and passes the rest to hci_recv_frame.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Specification HS-MEM-002 (memory allocation parameter validation) has very low relevance. The function doesn't perform memory allocation operations; it only consumes and potentially frees an sk_buff passed as parameter.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 6,
        "reasoning": "Specification HS-INPUT-001 (TLV length validation) has moderate relevance. While Bluetooth packets aren't strictly TLV, the principle applies: the code should validate skb has at least 1 byte before accessing skb->data and that subsequent data matches the expected structure for each packet type. The skb_pull operation assumes sufficient data exists.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate TLV length before accessing payload data"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message processing must maintain strict boundary validation for all TLV st..."
      }
    ]
  },
  "CVE-2022-3078_after_exclude_100:41aa8552:spec": {
    "timestamp": "2026-01-16T21:22:17.087684",
    "cve_id": "CVE-2022-3078",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "41aa8552",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `kzalloc` and `vzalloc` which zero-initialize memory, satisfying HS-MEM-001. However, the `ctx` field `last_duration` is explicitly set to 0 after allocation, and other fields are initialized. This is a direct and correct application of the specification.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (`goto out_kfree_buf`, `goto out_kfree_e`). These paths correctly free resources that were allocated earlier (e.g., `e->encoder_buf`, `e->name`, `e`), maintaining consistent object states and preventing leaks. This is a strong example of the specification's application.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol handlers validating input. The target code is a media encoder initialization function, not a network protocol handler. It does not process network packets or external protocol data.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This specification concerns validating protocol message length fields. The code does not parse or handle any protocol messages with length fields. It deals with internal buffer sizes and initialization arguments.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocations (`kzalloc`, `vzalloc`) with fixed sizes (`sizeof(*e)`, `VIDTV_S302M_BUF_SZ`). While it doesn't validate dynamic size parameters from an untrusted source (which would score higher), it does implicitly validate against allocation limits by checking for NULL returns. The relevance is moderate as the principle of checking allocation success is present.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles data types like `u32`, `be16` (for endianness conversion for `es_pid` and `stream_id`), and function pointers. It ensures consistent handling (e.g., using `cpu_to_be16` for network byte order). This shows attention to type consistency, though it's not a complex multi-stage protocol implementation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This specification is about protecting shared resource state transitions with atomic operations. The target code is an initialization function that allocates and sets up a new encoder object. There is no indication of concurrent access or shared resource modification that requires atomic protection at this stage.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The code meticulously manages the state of allocated resources (the main encoder struct `e`, its private context `ctx`, and buffers). The error paths ensure that if one allocation (like `ctx`) fails, previously allocated resources (`e->encoder_buf`, `e`) are properly freed, maintaining strict consistency and preventing partial allocation states.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-33099_before_exclude_100:11b9a4d8:spec": {
    "timestamp": "2026-01-16T21:22:17.184171",
    "cve_id": "CVE-2022-33099",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "11b9a4d8",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is an error formatting and reporting function (luaG_runerror). It does not parse or process regular expression patterns. The input `fmt` is a format string for printf-style formatting, not a regex pattern. Relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences in a compiler context. It uses a variable argument list and `luaO_pushvfstring` for string formatting, which may interpret format specifiers, but this is not related to pattern compiler escape sequence boundaries. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The function uses `luaO_pushvfstring` to process the format string `fmt` and variable arguments. If `fmt` is derived from untrusted input (e.g., from Lua code), it could be a vector for a format string attack. The internal implementation of `luaO_pushvfstring` should use length-aware operations to be safe. The code itself does not show the low-level string processing.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code does not perform explicit character encoding conversions. The `luaO_pushvfstring` function performs string formatting, which is a different operation. The specification about validating return values before buffer operations is a general good practice but not directly illustrated here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The shown code does not operate on fixed-size buffers directly. It delegates string building to `luaO_pushvfstring`, which likely manages memory dynamically. No explicit bounds checking is visible in this snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. Similar to spec 4, the code does not perform character encoding conversions (e.g., UTF-8 to UTF-16). Error handling is present (the function leads to `luaG_errormsg`), but not for encoding-specific errors.",
        "spec_index": 5,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function calls `luaC_checkGC(L)` which may trigger garbage collection and memory allocation. The specification about initializing memory allocations is a core security practice. While not shown, the subsequent operations (pushing a string, error handling) rely on properly initialized Lua state and objects. The relevance is indirect but important for the function's correct and secure operation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is an error handling function (`luaG_runerror`). Its purpose is to transition the Lua state into an error condition. Specification HS-STATE-002 is directly applicable: this function must ensure the Lua state (`L`) and its associated objects (stack, call info) are left in a consistent and safe state before propagating the error via `luaG_errormsg`. Incorrect state management here could lead to crashes or undefined behavior.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-33099_after_exclude_100:d7b23f89:spec": {
    "timestamp": "2026-01-16T21:22:20.248233",
    "cve_id": "CVE-2022-33099",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d7b23f89",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is an error formatting and reporting function (luaG_runerror). It does not parse or process regular expression patterns. The input `fmt` is a format string for error messages, not a regex pattern. The handling of embedded NUL bytes is not a relevant concern for this specific function's purpose.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve a pattern compiler or the processing of escape sequences. It formats an error message using `luaO_pushvfstring`, which is a string formatting function, not a pattern compiler for regex or similar grammars.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function uses `va_list` and `luaO_pushvfstring` to process a format string (`fmt`) and variable arguments. If `fmt` is derived from untrusted source (e.g., user data), it could be a vector for a format string attack. The function itself does not perform length-aware operations, but it relies on Lua's internal string formatting which should handle memory safely. The primary risk is the trustworthiness of the `fmt` argument.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not perform explicit character encoding conversions. The `luaO_pushvfstring` function performs string formatting, which may involve character data but is not an encoding conversion operation in the sense of UTF-8 to UTF-16, etc. Validation of return values is a general good practice, but not directly tied to the spec's focus on encoding conversion.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code manipulates the Lua stack (`L->top`), which is a dynamically managed structure, not a fixed-size buffer. Bounds checking is inherent to Lua's stack management functions (like `luaO_pushvfstring` and `setobjs2s`), but the specification about fixed-size buffers is not directly applicable.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Similar to spec 4, the function does not perform character encoding conversions. Its error handling path (via `luaG_errormsg`) is critical, but the spec's specific focus on encoding conversion error paths is not relevant here.",
        "spec_index": 5,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function calls `luaC_checkGC(L)` which may trigger garbage collection and memory reallocation. It then creates a new string object (`msg`) via `luaO_pushvfstring`. Ensuring memory is properly initialized is a concern for the internal functions it calls (like the memory allocator and string formatter). The function itself does not allocate raw memory, but it relies on subsystems that must follow this principle.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. This is an error handling function. Its core purpose is to construct an error message and transition the Lua state to an error condition via `luaG_errormsg`. It manipulates the stack (`L->top`) conditionally based on `isLua(ci)`. It is crucial that these manipulations and the final call to `luaG_errormsg` leave the Lua state (`L`) in a consistent and valid state for error recovery. This directly aligns with the specification's requirement for maintaining consistent object states in error handling paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-46784_before_exclude_100:10461dfe:spec": {
    "timestamp": "2026-01-16T21:22:21.283360",
    "cve_id": "CVE-2021-46784",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "10461dfe",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes input buffers (`inbuf`) and performs operations like `memcpy` and `memchr`. It includes a boundary check (`gopherState->len + llen >= TEMP_BUF_SIZE`) to prevent buffer overflow, which aligns with validating buffer boundaries before access. However, the validation is not applied to all buffer accesses (e.g., `line[llen + 1] = '\\0'` could overflow if `llen` equals `TEMP_BUF_SIZE`), making it relevant but not fully compliant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 7,
        "reasoning": "The code maintains a temporary buffer (`gopherState->buf`) to handle incomplete lines across calls, with state variables (`gopherState->len`) tracking buffer usage. It ensures consistency by resetting `gopherState->len` after processing and checking overflow. However, the invariant could be broken if `llen` is miscalculated (e.g., off-by-one errors), so the specification is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "The code performs encoding-specific processing (e.g., HTML quoting via `html_quote`, URL escaping via `rfc1738_escape_part`). While it uses functions like `snprintf` with `TEMP_BUF_SIZE` for boundary checking, it does not uniformly validate all encoding operations (e.g., direct string manipulations like `*selector = '\\0'`). The relevance is weak because boundary checking is inconsistent across encoding steps.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 1,
        "reasoning": "The code does not use regular expressions or process input patterns with embedded NUL bytes. It handles raw buffers with `memchr` for `\\n` and string operations like `strtok`, but NUL bytes are treated as terminators, not embedded data. This specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code processes escape sequences in URLs via `rfc1738_escape_part` and `rfc1738_escape_unescaped`, but it does not compile patterns or maintain strict boundaries during escape processingit relies on external functions. The specification is very low relevance as it targets pattern compilers, not general escape handling.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "The code uses length-aware operations like `memcpy` with calculated lengths (`llen`) and `snprintf` with buffer size limits. It processes potentially untrusted input (Gopher protocol data) and avoids unsafe functions like `strcpy`. However, it uses `strtok` and `strchr` without length checks on substrings, which could be risky. Overall, strong relevance due to predominant use of length-aware methods.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code does not parse protocol message length fields; it processes Gopher data line-by-line based on `\\n` delimiters. The `len` parameter is used but not validated against integer limits (e.g., overflow in `pos - inbuf`). The specification is loosely related as length validation is minimal.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code uses stack-allocated buffers via `LOCAL_ARRAY` with fixed `TEMP_BUF_SIZE`. It validates size parameters in the overflow check (`gopherState->len + llen >= TEMP_BUF_SIZE`) and limits `llen` accordingly. However, it does not perform memory allocation (e.g., `xstrdup` for `escaped_selector` lacks explicit size validation). Moderate relevance due to buffer size checks but limited allocation validation.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-3416_after_exclude_100:978ae066:spec": {
    "timestamp": "2026-01-16T21:22:41.884168",
    "cve_id": "CVE-2021-3416",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "978ae066",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It handles packet data buffers directly, with no pattern matching or regex operations.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It is a simple packet forwarding function for a network device model.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The function receives a buffer `buf` and its `size`. While it passes these to `qemu_send_packet`/`qemu_receive_packet`, which likely handle length, the function itself does not perform string processing. However, the principle of using length-aware operations for untrusted input is relevant to the broader context of network packet handling.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function takes a `size` parameter but does not validate it against integer limits. The `size` likely originates from a network-derived length field (e.g., a packet descriptor). While the function itself doesn't validate, the calling context should, making this specification relevant to the code's ecosystem.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function does not perform explicit memory allocation. It operates on a provided buffer. Memory allocation validation would be the responsibility of the caller or the lower-level packet functions.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code is a simple data path function. It does not parse complex protocol structures with multiple types. However, consistent handling of the buffer as a byte array is implied.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The `size` parameter is a critical network-derived value. Before this function is called, the size should have been validated for range (non-negative, not exceeding buffer capacity) and sign (positive). The function's safe operation depends on this prior validation, making the specification directly applicable to its preconditions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function does not parse protocol options or variable-length fields within the `buf`. It treats the buffer as an opaque blob. Protocol parsing would happen elsewhere before this send function is invoked.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2021-3416_before_exclude_100:ebca20a0:spec": {
    "timestamp": "2026-01-16T21:22:44.072568",
    "cve_id": "CVE-2021-3416",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ebca20a0",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing. It handles packet transmission in a network driver, dealing with raw buffer data, not pattern matching with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It is a network packet transmission function operating on a raw data buffer.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function receives a buffer and a `size` parameter. While it passes these to lower-level functions (`receive`/`send_packet`), it should ensure the `size` is valid and that length-aware operations are used internally. The primary risk is in the called functions, not this specific code block.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function takes a `size` parameter which likely originates from a network-derived length field (e.g., packet descriptor). This code does not validate it, but the specification's principle applies to the caller or the data source feeding this function. The code implicitly trusts the `size`.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function does not perform direct memory allocation. It operates on a provided buffer. Memory allocation validation would be relevant for the code that creates the `buf` or the descriptors that define `size`.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function handles network packet data. While protocol type consistency is a general concern, this low-level driver function is more about data movement than enforcing complex protocol state or type handling across stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The `size` parameter is critical. It is almost certainly derived from a network descriptor or header. This code uses `size` directly without validating its range or sign (e.g., negative, zero, or excessively large values could cause issues in `receive`/`send_packet` or statistic functions). This is a direct security concern for the function's robustness.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function is not parsing a protocol message with variable-length fields. It is sending a fully formed packet. Protocol option parsing would occur before this function is called.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2017-5897_before_exclude_100:0d2019ac:spec": {
    "timestamp": "2026-01-16T21:22:44.348069",
    "cve_id": "CVE-2017-5897",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0d2019ac",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code validates the grehlen (derived from offset and flags) against the skb data length via pskb_may_pull, which checks if sufficient data is available. This is a form of length validation against system/network constraints. However, the validation is not exhaustive for all userspace-provided inputs (the offset and packet data originate from network).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 8,
        "reasoning": "The function handles ICMPv6 error messages for GRE tunnels and verifies structural integrity by checking GRE flags, adjusting grehlen accordingly, and ensuring the skb has enough data. It also processes variable-length components like GRE key and checksum fields.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform buffer allocation; it operates on existing sk_buff. It validates available data but does not allocate buffers based on input scenarios.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 6,
        "reasoning": "The code validates grehlen (derived from offset and flags) against the skb length, which is a form of length field validation. However, offset is from the ICMPv6 packet and could be large; the check ensures it doesn't exceed skb size but may not fully check against platform integer limits (e.g., overflow in grehlen calculation).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "No memory allocation operations are present in this code snippet; it only validates existing skb data.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles various GRE flag combinations and ICMPv6 types/codes consistently, ensuring proper parsing and response. However, type handling is mostly via switch-case; potential type confusion is limited.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Validates GRE header length based on flags, which follows GRE RFC specifications. However, the validation is minimal and may not enforce all RFC constraints (e.g., reserved flag handling).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code processes GRE headers (which are TLV-like with flags indicating optional fields) and performs bounds checking via pskb_may_pull before accessing fields. It also processes IPv6 TLV (encapsulation limit) with bounds checking in ip6_tnl_parse_tlv_enc_lim (called). This aligns well with TLV bounds checking requirements.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-23589_before_exclude_100:e6ea5e07:spec": {
    "timestamp": "2026-01-16T21:22:45.223805",
    "cve_id": "CVE-2022-23589",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e6ea5e07",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs graph optimization for neural network operations (constant folding for convolution). It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or any text/pattern compilation operations. It manipulates computation graph nodes and their connections.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes graph data structures, it does not handle string data or perform length-aware string operations. The operations are on node names and attributes within a controlled graph structure.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates various conditions before proceeding with transformations (checking input sizes, node existence, etc.), but these are logical validations specific to graph optimization rather than general length validation for untrusted input.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Variable-length input processing must enforce length validation before access"
      },
      {
        "score": 1,
        "reasoning": "The code does not implement protocol dissectors or process protocol fields with length specifications. It operates on computational graph structures for neural network optimization.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-004: Protocol dissectors must honor field length specifications"
      },
      {
        "score": 5,
        "reasoning": "The code manipulates graph node structures but does not perform fixed buffer operations or explicit bounds checking on memory buffers. The safety checks are logical (node existence, input validation) rather than memory bounds validation.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code does perform input validation (checking input sizes, node properties, etc.) before processing, which aligns with the general principle of validation before processing. However, this is specific to graph transformation logic rather than general input parsing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "The code validates structural constraints on the computation graph (node types, connections, properties) before transformation, which conceptually aligns with configuration validation. However, it's not parsing configuration data in the traditional sense.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      }
    ]
  },
  "CVE-2022-23589_after_exclude_100:fc3e963d:spec": {
    "timestamp": "2026-01-16T21:22:46.363700",
    "cve_id": "CVE-2022-23589",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fc3e963d",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs graph optimization for neural network operations (constant folding for convolution and multiplication). It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or protocol/format parsing that would require handling escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes graph nodes and their properties, it does not handle string data or untrusted input in a way that requires length-aware string operations. The operations are on tensor shapes and graph structure.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates various conditions (node existence, shape compatibility, etc.) but does not process variable-length input data that requires length validation before access. The validation is about graph structure and tensor properties.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Variable-length input processing must enforce length validation before access"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement protocol dissectors or process protocol fields with length specifications. It's a graph optimization routine for computational graphs.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-004: Protocol dissectors must honor field length specifications"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform fixed buffer operations or memory writes that would require bounds validation. It manipulates graph node references and properties through safe API calls.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code does validate various conditions before processing (checking node existence, shape compatibility, etc.), which is conceptually similar to input validation. However, it's not processing external input data but rather validating internal graph transformation preconditions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "The code validates structural constraints on the computational graph (node types, connections, shapes), which is somewhat analogous to configuration validation. However, it's not parsing configuration data from external sources.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      }
    ]
  },
  "CVE-2017-5897_after_exclude_100:e48373a5:spec": {
    "timestamp": "2026-01-16T21:22:51.165177",
    "cve_id": "CVE-2017-5897",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e48373a5",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code validates user-provided data (network packet) lengths using `pskb_may_pull` before accessing specific offsets. This is a direct validation against system constraints (available skb data). However, the validation is specific to the GRE header structure and not a generic array length check from userspace.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function is a protocol (ICMPv6 error) message handler for GRE over IPv6. It explicitly verifies the structural integrity of the variable-length GRE header by checking flags (GRE_CSUM, GRE_KEY) and pulling the required amount of data from the socket buffer before accessing fields. This is a core security practice for protocol handling.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The code does not perform buffer allocation. It operates on an already allocated `sk_buff` (`skb`) and uses pull operations to ensure data is available. The specification concerns allocators, which is not the focus here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates the effective length of the protocol message (GRE header + optional fields) via `pskb_may_pull` against the available data in the skb. While it doesn't explicitly check against platform integer limits (like SIZE_MAX), the pull operation's failure acts as a practical length validation. The offset and grehlen calculations could theoretically overflow, but are based on small, fixed-size header components.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Similar to spec 3, this code does not contain memory allocation operations (like kmalloc, vmalloc). It works with pre-allocated network buffers.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function handles multiple ICMPv6 message types (ICMPV6_DEST_UNREACH, etc.) and ensures consistent handling by switching on the `type` field. It also processes the GRE header flags consistently to determine the header layout before accessing key or checksum fields. This prevents type confusion vulnerabilities.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The code validates the GRE header length based on its flags, which is loosely defined by RFC 2784/2890. However, the primary validation is for structural integrity to prevent out-of-bounds reads, not strictly enforcing RFC maximums. The ICMPv6 handling follows general protocol semantics but doesn't deeply validate RFC length constraints for those messages.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code includes a specific TLV processing section for `ICMPV6_PARAMPROB` with code `ICMPV6_HDR_FIELD`. It calls `ip6_tnl_parse_tlv_enc_lim(skb, skb->data)` which must perform bounds checking. The subsequent access `tel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli]` relies on that prior bounds check. This is a direct example of TLV processing that must be bounds-checked.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2021-45936_before_exclude_100:5f87b572:spec": {
    "timestamp": "2026-01-16T21:22:53.556432",
    "cve_id": "CVE-2021-45936",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f87b572",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves reading MQTT packets with length fields via MqttPacket_Read and MqttClient_DecodePacket. While the code does not directly show validation of length fields against integer limits, the relevance is moderate because proper protocol parsing should include such validation. The actual validation likely occurs in the called functions, not in this specific code snippet.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "This code does not contain any explicit memory allocation operations. It works with pre-allocated buffers (client->rx_buf) and packet objects. Therefore, the specification about memory allocation size validation has very low relevance to this specific function.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively handles different MQTT packet types (packet_type, wait_type) and uses state machines (MQTT_MSG_BEGIN, WAIT, READ, etc.). It ensures consistent type handling through switch statements, type comparisons, and proper state transitions. The FALL_THROUGH directives and type matching logic directly relate to consistent protocol type processing.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code reads protocol messages and decodes them. While this function doesn't explicitly validate RFC length constraints, it calls MqttPacket_Read and MqttClient_DecodePacket which should perform such validation. The function handles packet reception which is where length validation should occur.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. MQTT uses TLV-like structures in its packet format. The code decodes packets and handles payloads, which implies bounds checking should occur. However, the actual bounds checking is not visible in this function but should be in MqttClient_DecodePacket and MqttClient_HandlePacket.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code initializes local variables but doesn't show memory allocation initialization. It works with existing client structures and buffers. Memory initialization would be more relevant in allocation functions, not in this packet waiting logic.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code maintains state consistency through mms_stat state variable and has multiple error handling paths. It properly resets states on errors (setting *mms_stat = MQTT_MSG_BEGIN) and ensures mutex unlocking in error paths. The goto wait_again mechanism also maintains consistent waiting state.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a network protocol handler that reads packets from the network (MqttPacket_Read) and processes them. It validates inputs through null checks, decodes packets, and handles different packet types. The function's primary purpose is to validate and process network input before further handling.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2021-43845_after_exclude_100:67c4ad2c:spec": {
    "timestamp": "2026-01-16T21:22:55.333853",
    "cve_id": "CVE-2021-43845",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "67c4ad2c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the RTCP XR packet length field (pkt_len) against the input size. It checks if (pkt_len + 1) > (size / 4), which is a validation against platform-specific integer limits (size is pj_size_t). This directly addresses HS-INPUT-001's requirement to validate protocol message length fields.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any memory allocation operations. It only parses and validates an existing packet buffer. Therefore, HS-MEM-002 about memory allocation size validation has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform memory allocation, so HS-MEM-001 about initializing allocated memory before use is not applicable. The code only reads from and writes to existing structures.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The code has multiple early return paths for invalid packets, but doesn't show extensive error handling for maintaining consistent object states. Some state updates occur conditionally (e.g., only if \"now-dlrr >= lrr\"), which shows consideration of state consistency. Moderate relevance to HS-STATE-002.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively validates network protocol input before processing: checks packet type, validates length fields, performs bounds checking for each report block type before accessing them, and ensures pointers don't exceed packet boundaries. This directly implements HS-IO-003's requirement for input validation in network protocol handlers.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The code validates RTCP XR packet length against the actual received size and performs bounds checking for each report block. While not explicitly checking RFC-specified maximum lengths, it enforces that all accesses stay within the received packet boundaries, which addresses the core concern of HS-INPUT-001's length constraint validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code implements TLV-like processing of RTCP XR report blocks (Type-Length-Value structure). It performs complete bounds checking before accessing each block type: checks that (char*)rb_hdr + sizeof(type) <= (char*)pkt + size. This directly implements HS-PROTOCOL-002's requirement for complete bounds checking in TLV processing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2021-43845_before_exclude_100:6d429f15:spec": {
    "timestamp": "2026-01-16T21:22:56.378635",
    "cve_id": "CVE-2021-43845",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6d429f15",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the RTCP XR packet length field (pkt_len) against the input size parameter. It checks if (pkt_len + 1) > (size / 4), which prevents buffer over-read by ensuring the declared length doesn't exceed available data. This directly addresses protocol message length validation against platform-specific limits (the size parameter).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any memory allocation operations. It only parses and processes an existing packet buffer, so memory allocation validation specifications are not applicable to this specific function.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code demonstrates consistent type handling through careful pointer casting and byte order conversions (pj_ntohs, pj_ntohl). However, there's potential for type confusion in the pointer arithmetic where (pj_int32_t*)rb_hdr is compared with (pj_int32_t*)pkt + pkt_len, which assumes 4-byte alignment. This is moderately relevant.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform memory allocation, so initialization of allocated memory is not applicable. It only reads from and writes to existing structures.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function has early returns for invalid packets but maintains consistent state by only updating session data when valid blocks are received. Error paths preserve existing session state. However, there's no comprehensive error handling for all possible malformed inputs.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function validates input before processing through multiple checks: packet type verification, length validation against size, and block length checking. This is a network protocol handler that performs essential input validation to prevent malformed packet processing.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The code validates RTCP XR block lengths (rb_len) and skips blocks with zero length. It also validates the overall packet length against the received size. While it checks basic constraints, it doesn't appear to enforce RFC-specific length constraints for each block type beyond basic bounds checking.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code implements TLV-like processing of RTCP XR blocks with bounds checking. The while loop condition ensures rb_hdr doesn't exceed packet bounds, and rb_len is used to advance to the next block. This prevents buffer over-reads by checking boundaries before accessing block data.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2021-45936_after_exclude_100:527a6dc9:spec": {
    "timestamp": "2026-01-16T21:22:57.252461",
    "cve_id": "CVE-2021-45936",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "527a6dc9",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves reading MQTT packets which contain length fields. The function `MqttPacket_Read` and `MqttClient_DecodePacket` are responsible for parsing these fields. While the code does not explicitly show length validation against platform limits, the specification is moderately relevant as proper validation should occur in the called decoding functions.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The target code does not contain any explicit memory allocation operations. It works with pre-allocated buffers (`client->rx_buf`). Therefore, this specification has very low relevance to this specific code snippet.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code's core logic is about matching and handling different MQTT packet types (`wait_type`, `packet_type`). It uses a state machine (`mms_stat`) and switches between packet processing stages. Ensuring consistent type handling across `MQTT_MSG_BEGIN`, `WAIT`, `READ`, and `READ_PAYLOAD` states is critical to prevent logic errors and state confusion.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code reads protocol messages via `MqttPacket_Read`. RFC-specified length constraints for MQTT packets (e.g., remaining length field) must be validated, but this validation is likely delegated to the `MqttPacket_Read` and `MqttClient_DecodePacket` functions, not visible in this snippet.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. MQTT uses a TLV-like structure (Type, Length, Value). The code calls `MqttClient_DecodePacket` which should perform bounds checking. The relevance is indirect, as the specification targets the decoding logic which is not fully shown here, but the code is part of the TLV processing pipeline.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This code does not perform memory allocation. It uses existing structures and buffers. Initialization of local variables (e.g., `packet_id`, `waitMatchFound`) is done, but this is not about heap memory allocation initialization.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function manages complex state (`mms_stat`) and has multiple error paths (break statements). It must ensure that on errors or early returns (especially in multithreaded contexts with locks), the state (`*mms_stat`) and mutex locks (`readLocked`) are consistently managed. The code shows careful unlocking in error paths, making this specification highly applicable.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. This is a network protocol handler (`MqttClient_WaitType`). It receives data from the network (`MqttPacket_Read`) and must validate this input (packet type, ID, structure) before further processing in `MqttClient_HandlePacket`. The validation logic (matching type/id) is present, though deeper packet structure validation is in called functions.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2021-3746_after_exclude_100:02ce5c3f:spec": {
    "timestamp": "2026-01-16T21:23:12.014420",
    "cve_id": "CVE-2021-3746",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "02ce5c3f",
    "scores": [
      {
        "score": 10,
        "reasoning": "HS-MEM-001 is highly relevant. The code explicitly initializes the entire memory of a reclaimed OBJECT slot to zero using MemorySet before returning it for use. This directly prevents information leakage from previously used memory and ensures a clean, predictable state, which is the core requirement of this specification.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "HS-STATE-002 has moderate relevance. The function maintains a consistent state by finding an empty slot and initializing it before returning. However, the primary error path (returning NULL when no slot is found) does not involve complex object state transitions. The relevance is in the correct initialization of a new object state.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "HS-IO-003 has very low relevance. The code is a memory/object management function with no network protocol handling or input processing from external sources.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-001 has very low relevance. The code does not involve regular expression parsing or processing of input patterns containing NUL bytes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-002 has very low relevance. The code does not involve pattern compilers, escape sequence processing, or protocol-level operations.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-003 has low relevance. While the function uses MemorySet (likely analogous to memset) which is length-aware, it is operating on a fixed-size, internal object structure (`sizeof(*object)`). The input (the index `i`) is trusted and controlled by the loop bounds. There is no processing of untrusted strings.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-001 (Buffer write operations) has moderate to strong relevance. The code performs a buffer write via MemorySet. It correctly validates the \"available space\" implicitly by operating within the bounds of a statically allocated array (`s_objects`) and using the size of the object itself. The primary security issue it prevents is uninitialized memory use, not buffer overflow, but the safe write operation is still relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-002 has very low relevance. The code does not implement a parser with complex state transitions or maintain buffer position invariants. It performs a simple linear scan of an array.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2021-43267_after_exclude_100:6c9deecf:spec": {
    "timestamp": "2026-01-16T21:23:12.948500",
    "cve_id": "CVE-2021-43267",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6c9deecf",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the user-provided `size` and `keylen` against minimum and maximum system constraints (`TIPC_AEAD_KEYLEN_MIN`, `TIPC_AEAD_KEY_SIZE_MAX`) before processing the key data. This directly aligns with the specification's requirement to validate array lengths against system constraints.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 8,
        "reasoning": "The function verifies the structural integrity of the variable-length key component. It checks that the total message size (`size`) matches the sum of the fixed header size and the variable key length (`keylen`), ensuring the message is well-formed and preventing parsing errors or buffer over-reads.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 7,
        "reasoning": "The code allocates memory based on the validated `size` parameter. While it validates `size` against a maximum key length constraint, the allocation uses the full `size`, which includes the fixed header. This accounts for the worst-case input scenario within the validated limit, though the specification's focus is slightly broader.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code validates the protocol's length field (`keylen`, derived from network data) against a defined maximum (`TIPC_AEAD_KEY_SIZE_MAX`). This is a form of integer limit validation, though the specification's emphasis on \"platform-specific\" limits (like SIZE_MAX) is not explicitly seen; the check is against an application-defined maximum.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs a critical validation: it ensures the `size` parameter used for `kmalloc` matches the expected structure size (`keylen + sizeof(struct tipc_aead_key)`). This prevents an allocation size mismatch that could lead to buffer overflows when the `memcpy` operations are performed later, directly fulfilling the specification.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles integer types (converting `keylen` from network byte order with `ntohl`) and uses them consistently in size calculations and comparisons. However, the specification's broader focus on \"consistent type handling across all processing stages\" is only partially addressed, as there is no complex type casting or multi-stage processing shown.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function uses a spinlock (`rx->lock`) to protect the critical section where it checks for existing keys (`rx->skey`, `rx->key_gen`) and, if none exist, atomically updates the key-related state variables (`rx->skey`, `rx->key_gen`, etc.). This is a classic check-and-set operation under lock.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains consistency invariants for the shared `rx` state (key, key generation, mode, nokey flag). The lock protects all transitions. The use of a memory barrier (`mb()`) before releasing the lock ensures the `nokey` flag update is visible in the correct order, further strengthening state consistency across access paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2021-3746_before_exclude_100:9a9e07ec:spec": {
    "timestamp": "2026-01-16T21:23:13.481307",
    "cve_id": "CVE-2021-3746",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9a9e07ec",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code initializes the `object->attributes` structure to zero using `MemorySet` after finding an empty slot. This directly aligns with HS-MEM-001's requirement to fully initialize memory before use, preventing the use of uninitialized data. However, the initialization is conditional on finding a free slot, and the specification is broadly about allocation-time initialization, making it highly relevant but not a perfect match (as this is re-initialization of a pooled object).",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has a simple error path (returning NULL when no empty slot is found). While it maintains consistency by not modifying any state in the error path, the specification HS-STATE-002 about maintaining consistent object states is only moderately relevant. The primary function path does initialize a newly allocated object, which is a state transition, but the error handling is minimal.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "HS-IO-003 is about network protocol handlers validating input. This code is a low-level object management function with no network interaction, making the specification not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-001 concerns regular expression parsers and NUL bytes. The target code does not involve regular expressions or string pattern parsing, so this specification has no relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-002 is about pattern compilers and escape sequences. The code is for finding and initializing an object slot, with no pattern compilation logic, making the specification irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-003 advises length-aware string operations for untrusted input. This code uses `MemorySet` (likely similar to `memset`) with a fixed size (`sizeof(OBJECT_ATTRIBUTES)`), so it is length-aware. However, the input is not \"untrusted\" in the typical sense (it's an internal index), and the function is not primarily for string processing. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-007 (Buffer write operations must validate available space) has weak relevance. The write operation (`MemorySet`) writes to a statically allocated array member (`s_objects[i]`). The index `i` is bounded by the loop limit `MAX_LOADED_OBJECTS`, which should be defined to match the array size, providing implicit validation. However, the specification's core concern about explicit space validation is only loosely related to this controlled, internal structure access.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-002 discusses parser state transitions and buffer position invariants. This function is not a parser; it searches an array and initializes an element. The concept of a \"buffer position invariant\" does not apply, leading to very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2021-43267_before_exclude_100:88fd4eb1:spec": {
    "timestamp": "2026-01-16T21:23:14.940436",
    "cve_id": "CVE-2021-43267",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "88fd4eb1",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code processes a userspace-provided key length (skey->keylen) derived from network data. This length is used in memcpy operations without validation against system constraints (like maximum allowable key size) before processing, making it highly relevant to HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 8,
        "reasoning": "The function handles a variable-length key component within a protocol message. It performs a basic sanity check comparing the total message size with the calculated key size, but this check occurs after copying the key length and algorithm name. More rigorous structural integrity verification of the variable-length key data is needed, making this specification strongly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory based on the incoming message size (kmalloc(size, GFP_ATOMIC)). While there's a later sanity check, the allocation itself doesn't explicitly account for worst-case scenarios or enforce explicit size limits before allocation, presenting a potential denial-of-service risk. This gives moderate to strong relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code extracts a length field (skey->keylen) from network data using ntohl. This length is used in memory operations and size calculations. There is no validation of this integer against platform-specific limits (e.g., maximum positive size_t, integer overflow prevention) before use, making this specification highly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The memory allocation size ('size') comes directly from the network message (msg_data_sz(hdr)). This parameter is not validated against allocation limits (e.g., KMALLOC_MAX_SIZE) or the subsequent usage requirements (e.g., the structure size plus keylen) before the kmalloc call. The later sanity check is insufficient as allocation has already occurred. This is a direct security concern addressed by the specification.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles integer conversion (ntohl) and copies data into a structured format. While there is some type handling (__be32), the specification's broader focus on consistent type handling across all processing stages is only moderately relevant here, as the primary issues are more about length validation and bounds checking.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This code is a textbook example of the need for this specification. It uses a spinlock to protect the check for existing key (rx->skey) and the subsequent state update (rx->skey = skey, etc.). This ensures atomic check-and-set during concurrent initialization of the key resource, making it directly and highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 5,
        "reasoning": "The function modifies multiple shared state fields (rx->key_gen, rx->skey, rx->nokey) under a spinlock. It uses a memory barrier (mb()) to ensure the nokey flag is consistent. This demonstrates an attempt to maintain consistency invariants for shared state, making the specification strongly relevant. The lock protects the transition.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2022-37032_after_exclude_100:0c62c137:spec": {
    "timestamp": "2026-01-16T21:23:15.869625",
    "cve_id": "CVE-2022-37032",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0c62c137",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code performs multiple length validations before accessing data: it checks if pnt + 3 > end before reading action and capability header, and validates hdr->length against the expected minimum size and against the remaining buffer (pnt + hdr->length + 3 > end). This directly aligns with validating field lengths before data access.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 5,
        "reasoning": "The code validates the capability structure for the MP capability type by checking hdr->length against sizeof(struct capability_mp_data) and performs AFI/SAFI conversion and validation. However, for non-MP capabilities, it only logs a warning without strict validation, slightly reducing relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains strict bounds checking throughout parsing: it validates the overall message length via the while loop condition (pnt < end) and performs multiple checks on hdr->length and pointer arithmetic to ensure operations stay within bounds.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 5,
        "reasoning": "The code validates length fields against buffer boundaries but doesn't explicitly reference RFC-specified constraints for capability lengths. The check against sizeof(struct capability_mp_data) is implementation-specific rather than RFC-based.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code implements complete bounds checking for TLV-like capability structures: it validates the capability header length before accessing the capability data via memcpy, ensuring the entire capability fits within the remaining buffer.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "Directly relevant as the code validates hdr->length before using it in pointer arithmetic and before memcpy operations. Multiple length validation points exist throughout the parsing loop.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 5,
        "reasoning": "The code validates message boundaries through end pointer checks and ensures each capability stays within the overall message length. However, it doesn't validate inter-capability padding or alignment which could be part of strict boundary validation.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains separation through pointer arithmetic and bounds checks, but directly copies unvalidated data via memcpy(&mpc, pnt + 3, sizeof(...)) after length validation. The separation between validated and unvalidated regions is enforced but not architecturally distinct.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2022-37032_before_exclude_100:ae622302:spec": {
    "timestamp": "2026-01-16T21:23:16.572104",
    "cve_id": "CVE-2022-37032",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ae622302",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code directly validates the capability length field (hdr->length) before using it to calculate a pointer offset (pnt + hdr->length + 3) and copy data via memcpy. This is a direct implementation of validating field lengths before data access, which is the core of HS-INPUT-001. The check prevents reading beyond the buffer end.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 7,
        "reasoning": "The code validates the capability code (checking for CAPABILITY_CODE_MP) and performs specific structure validation for the MP capability (e.g., converting AFI/SAFI). However, for unrecognized capabilities, it only logs a warning and continues, rather than strictly enforcing validation that might lead to connection termination. This is a moderate application of strict structure validation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 9,
        "reasoning": "The code maintains strict bounds checking throughout the parsing loop. It checks (pnt + 3 > end) for the header, and later (pnt + hdr->length + 3 > end) for the capability data. The loop condition (pnt < end) also ensures the parser stays within bounds. This is a strong example of maintaining bounds checking.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 6,
        "reasoning": "The code validates the length field against the remaining packet buffer (end pointer), which is a practical implementation of length constraints. However, it does not appear to check for RFC-specified minimum/maximum values for hdr->length itself (e.g., is it at least the size of capability_mp_data?). The validation is more about buffer safety than RFC-specific constraints.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code treats each capability as a TLV-like structure (Action, Code, Length, Value). It performs the critical bounds check (pnt + hdr->length + 3 > end) before accessing the Value portion via memcpy. This is a direct and correct implementation of complete bounds checking before field access for a TLV structure.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 9,
        "reasoning": "This is identical to Specification 1. The code validates the capability length field (hdr->length) before using it to advance the pointer and copy data, which is the exact requirement of validating length fields before data access.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 8,
        "reasoning": "The code validates the message boundary via the 'end' pointer and ensures each capability record fits within the remaining length. The loop correctly advances 'pnt' and stops at 'end'. This enforces strict message boundary validation for the capability message as a whole and for each sub-element.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains a clear separation: 'pnt' points to the current unvalidated data, and checks are performed before any access. The 'end' pointer defines the validated boundary of the entire message. Data is only copied (memcpy) after length validation, moving it from the unvalidated network buffer into a local structure for processing.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2022-26490_after_exclude_100:f03c2417:spec": {
    "timestamp": "2026-01-16T21:23:18.308864",
    "cve_id": "CVE-2022-26490",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f03c2417",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the user-provided `transaction->aid_len` against the fixed-size `transaction->aid` array (`sizeof(transaction->aid)`) before using it in `memcpy`. This directly aligns with HS-INPUT-001's requirement to validate array lengths against system constraints. The check prevents buffer overflow of the fixed-size destination array.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 9,
        "reasoning": "The code performs multiple structural integrity checks for the variable-length EVT_TRANSACTION message: it validates the minimum skb length, checks for the expected AID tag (0x81), validates the AID length, checks for the PARAMETERS tag (0x82), and validates the parameters length. This is a direct and comprehensive application of HS-PROTOCOL-002.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory based on the input size (`skb->len - 2`). While it performs subsequent length validations, it does not appear to enforce an explicit, predefined upper bound on the allocation size itself before calling `devm_kzalloc`. This is a weaker link to the specification's \"worst-case input scenarios with explicit size limits\" requirement.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code validates the `transaction->aid_len` against the size of the destination array (`transaction->aid`) *after* allocation but *before* the `memcpy` operation. This aligns with validating size parameters against \"subsequent usage requirements.\" However, it does not show validation against allocation limits (e.g., checking `skb->len` for overflow before subtraction for allocation size), making it strong but not perfect.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code consistently treats the `skb->data` buffer as a sequence of TLV-like components (Tag, Length, Value). It checks for specific tags (0x81, 0x82) and uses the associated lengths to parse the subsequent values. This demonstrates consistent type (tag) handling. However, the specification is broad, and the code's scope is limited to this specific message handler.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "The code shows no evidence of managing shared resource state transitions (e.g., locks, atomic counters). It processes a single incoming skb, performs validation, allocates memory, and passes data onward. HS-TIMING-001 is not relevant to this function's logic.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The code does not manage complex resource allocation state or maintain multiple tracking structures for a single resource. It performs a simple, linear allocation (`devm_kzalloc`) for a transaction structure and frees the input skb. There is no state consistency issue to address here.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-24786_before_exclude_100:11ce9716:spec": {
    "timestamp": "2026-01-16T21:24:02.897027",
    "cve_id": "CVE-2022-24786",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "11ce9716",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the length field from the RTCP header (hdr->length) by converting it from network byte order and using it to calculate rpsi_len. It then checks if the provided buffer length is sufficient (length < rpsi_len + 12). This directly relates to HS-INPUT-001's requirement to validate protocol message length fields. However, it does not explicitly check against platform-specific integer limits (e.g., for overflow when calculating rpsi_len*8), which prevents a perfect score.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any dynamic memory allocation; it operates on a provided buffer. Therefore, HS-MEM-002 about validating allocation size parameters is not directly applicable.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code parses a network protocol (RTCP) and handles type-specific fields (pt, count, length). It validates the packet type (pt) and format (count) before proceeding. This aligns with HS-PROTOCOL-003's goal of consistent type handling. However, the relevance is moderate because the code is a single parsing function, not a full protocol implementation across all stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform any memory allocation. It initializes fields in the output structure `rpsi` by assignment, but this is not about initializing allocated memory blocks. HS-MEM-001 is not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error return paths (PJ_EINVAL, PJ_ETOOSMALL, PJ_ENOTFOUND). It appears to leave the `rpsi` output structure in an uninitialized or partially initialized state on error returns. This could violate HS-STATE-002's requirement for consistent object states in error paths, making it moderately relevant.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a network protocol (RTCP) handler. It performs multiple input validations: checking for NULL pointers, minimum length, correct packet type and format, and derived length consistency. This is a core practice of HS-IO-003, making it highly relevant. The validation is performed before the main parsing logic.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not use or contain any regular expressions. HS-INPUT-001 (as defined here for regex parsers) is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It parses binary RTCP feedback messages. HS-PROTOCOL-002 is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-26490_before_exclude_100:1930cc86:spec": {
    "timestamp": "2026-01-16T21:24:02.938157",
    "cve_id": "CVE-2022-26490",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1930cc86",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the skb->len against a minimum length (NFC_MIN_AID_LENGTH + 2) before processing, which is a direct application of validating user-provided array lengths against system constraints. This is crucial to prevent buffer over-reads.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 9,
        "reasoning": "The code performs structural integrity checks for the variable-length AID and PARAMETERS components. It verifies the presence and correct order of expected tags (0x81, 0x82) and validates lengths before using them for memory operations, directly aligning with the specification.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The allocation uses `skb->len - 2` without an explicit upper bound check. While `skb->len` itself has network-layer constraints, the code does not enforce a specific worst-case limit for this protocol handler, making the relevance moderate.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "The code validates the length field `skb->data[1]` (aid_len) implicitly by using it in a subsequent offset calculation and tag check. However, it does not explicitly validate it against the remaining buffer size before the `memcpy` for the AID, which is a subtle flaw. The check for the PARAMS tag and length is more robust. Overall, the intent and partial implementation align strongly with this spec.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The memory allocation size (`skb->len - 2`) is derived from an input length. The code validates the input buffer has a minimum length but does not explicitly check if the derived size is valid for the `transaction` structure's internal fields (aid, params) or against allocation limits like `kmalloc` max size. This presents a moderate risk.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles specific event types (ST21NFCA_EVT_CONNECTIVITY, ST21NFCA_EVT_TRANSACTION) and ensures the data for the transaction event has the expected tag structure. However, the default case handles unexpected events generically. The relevance is moderate as it enforces type handling for the expected cases.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve shared resource state transitions or atomic operations. It processes a single event/skb in what appears to be a handler context. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve multiple tracking structures for a resource's allocation state. It allocates a transaction structure, uses it, and passes it to `nfc_se_transaction` (which likely consumes/frees it). There's no complex state consistency issue evident.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-24786_after_exclude_100:788752a4:spec": {
    "timestamp": "2026-01-16T21:24:04.653463",
    "cve_id": "CVE-2022-24786",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "788752a4",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates the RTCP length field (hdr->rtcp_common.length) against minimum values (3) and uses it to calculate rpsi_len. It then validates rpsi_len against the input buffer length (length). This directly addresses validating protocol message length fields against integer limits and buffer boundaries, which is the core of HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The code does not perform any dynamic memory allocation. It parses an input buffer into a structure (rpsi) but does not allocate memory for it. Therefore, HS-MEM-002 about validating allocation size parameters is not directly applicable.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code enforces consistent type handling by checking the RTCP packet type (pt) and feedback message type (count/FMT) against expected constants (RTCP_PSFB and 3). It also correctly handles network byte order (ntohs) for the length field. This aligns with HS-PROTOCOL-003's goal of consistent type handling across processing stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform any memory allocation. It writes parsed data into the caller-provided `rpsi` structure, but this is not a memory allocation operation. HS-MEM-001 is about initializing allocated memory, which is not the primary activity here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function has multiple error return paths (PJ_EINVAL, PJ_ETOOSMALL, PJ_ENOTFOUND, PJ_ETOOBIG). While it doesn't manage complex object states, it must ensure the `rpsi` output structure is not left in an inconsistent or partially written state on error. The code only writes to `rpsi` after passing several validation checks, which is a good practice. However, the specification is more broadly about object state consistency.</spec_4_reasoning>\n<spec_6_score>10</spec_6_reasoning>\n<spec_6_reasoning>Highly relevant. This is a network protocol handler (RTCP Feedback RPSI parser). The code performs extensive input validation before processing: checking for NULL pointers, minimum buffer length, protocol type (pt, count), header length, calculated RPSI length, padding length, and bit length consistency. This is a direct and comprehensive application of HS-IO-003.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a network protocol handler (RTCP Feedback RPSI parser). The code performs extensive input validation before processing: checking for NULL pointers, minimum buffer length, protocol type (pt, count), header length, calculated RPSI length, padding length, and bit length consistency. This is a direct and comprehensive application of HS-IO-003.</spec_5_reasoning>\n<spec_7_score>1</spec_7_reasoning>\n<spec_7_reasoning>Very low relevance. The code does not involve regular expression parsing. It parses binary RTCP packets, handling length fields and bit-packed data. HS-INPUT-001's mention of regular expressions and NUL bytes is not applicable to this context.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve regular expression parsing. It parses binary RTCP packets, handling length fields and bit-packed data. HS-INPUT-001's mention of regular expressions and NUL bytes is not applicable to this context.</spec_6_reasoning>\n<spec_8_score>1</spec_8_reasoning>\n<spec_8_reasoning>Very low relevance. The code does not involve pattern compilation or processing of escape sequences. It is a binary protocol parser for RTCP Feedback messages. HS-PROTOCOL-002 is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-40299_after_exclude_100:a35de213:spec": {
    "timestamp": "2026-01-16T21:24:06.415726",
    "cve_id": "CVE-2022-40299",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a35de213",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `omAlloc` to allocate memory for `pi->data.s.body` and `p`. While the memory for `pi->data.s.body` is immediately written to via `myfread` and null-terminated, the allocation for `p` is used with `sprintf` which writes the full content, effectively initializing it. However, there is no explicit guarantee of full initialization (e.g., zeroing) before the write. The relevance is moderate because the specification applies to memory safety, but the code's use is not egregiously unsafe.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error handling paths (e.g., `mkstemp` failure, `fork` failure, `fopen` failure). In some paths, resources like file descriptors and dynamically allocated memory are cleaned up (e.g., `close(f)`, `omFree(filename)`). However, there is an inconsistency: when `pi->language != LANG_SINGULAR`, the code sets `f=NULL` after `close(f)` (which is incorrect as `f` is an int, not a pointer). Also, the `si_unlink(filename)` is not called in that same error path, potentially leaving the temporary file. This directly relates to maintaining consistent state during error handling.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code does not handle network protocols. It deals with local file editing, forking, and executing an editor. No network input validation is present.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not process protocol messages or perform bounds checking on length values from an external protocol. It reads a file length via `ftell` and uses it to allocate memory, but this is local file I/O, not protocol field validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce bounds checking for all length values"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve session setup or security-related protocol fields. It is a local procedure editing function.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Session setup handlers must validate all security-related protocol fields before pr..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It handles strings from environment variables and file content, but not regex patterns with embedded NUL bytes.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It executes an editor and reads/writes file content.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses `strlen` on `pi->data.s.body` when writing to the file, and uses `sprintf` to construct a command string. The input `pi->data.s.body` may be considered trusted (from internal procedure data), but the editor string from environment variables (`EDITOR`/`VISUAL`) is potentially untrusted. The code uses `strchr` to check for spaces, but then uses `sprintf` without length checking, which could lead to buffer overflow if the editor string is maliciously long. However, the buffer is allocated with exact size (`strlen(editor)+strlen(filename)+2`), so it is safe. The use of `execlp` with the unmodified editor string could be problematic if it contains spaces or other shell metacharacters, but the code branches to use `system` when spaces are present. The relevance is moderate because there is string handling of potentially untrusted input (environment variables), but the code has some mitigations.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2016-7132_after_exclude_100:566d15ce:spec": {
    "timestamp": "2026-01-16T21:24:06.474297",
    "cve_id": "CVE-2016-7132",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "566d15ce",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory operations (efree, zval_ptr_dtor, allocation via php_base64_decode) and manages a stack of st_entry structures. While there is some initialization (e.g., stack->done), the code does not show explicit, comprehensive initialization of all allocated memory before use (e.g., the contents of `ent1->data` after popping from the stack are used without being shown to be fully initialized in this snippet). The risk of using uninitialized memory exists, making this specification highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function handles multiple error/edge cases (e.g., checking stack->top, Z_ISUNDEF, incomplete classes). It attempts to maintain consistent state by cleaning up memory (efree, zval_ptr_dtor) and setting stack->done. However, the \"OBJECTS_FIXME\" comment and complex control flows involving object creation and property merging suggest potential state consistency risks, giving this moderate to strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Keyring modification operations must enforce complete permission validation regardless o..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-AUTH-002: Default security behaviors must maintain equivalent protection to explicit configuratio..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Keyring state transitions must maintain consistent permission requirements"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2021-41206_before_exclude_100:427e3588:spec": {
    "timestamp": "2026-01-16T21:24:33.057691",
    "cve_id": "CVE-2021-41206",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "427e3588",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs grouped convolution operations for neural networks, not cryptographic operations on secret values. There is no handling of cryptographic keys or secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a neural network convolution implementation, not an elliptic curve cryptography implementation. There are no curve models or side-channel resistance considerations relevant to this mathematical computation code.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "While the code performs memory operations (tensor shuffling), it's not performing cryptographic processing. The memory operations are for data rearrangement in neural network computations, not for handling cryptographic secrets that require constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 3,
        "reasoning": "The code shows some resource management patterns (tensor allocation, blocking counter), but doesn't demonstrate complex initialization sequences that would require conditional cleanup. The relevance is very low as this is primarily computational code rather than resource management code.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "The code performs neural network operations, not cryptographic key operations. There are no key objects being created or algorithm support verification happening in this convolution implementation.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 1,
        "reasoning": "The code is completely unrelated to DNSSEC key processing or network protocols. This is a neural network convolution operation with no connection to DNS security extensions.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs array/tensor operations including indexing (chip operations) and dimension calculations. While it uses TensorFlow's tensor abstraction which provides bounds checking, the manual dimension calculations (pre_shuffle/post_shuffle) and array indexing could potentially have bounds issues if dimensions are miscalculated.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates the data_format parameter (NHWC format check) and performs some parameter validation implicitly through dimension calculations. However, this is not comprehensive profile-specific parameter validation as specified, and the domain constraints are mathematical/tensor dimensions rather than security profiles.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Profile-specific parameter validation must enforce domain constraints"
      }
    ]
  },
  "CVE-2021-23521_after_exclude_100:0c9ba7e2:spec": {
    "timestamp": "2026-01-16T21:24:36.730559",
    "cve_id": "CVE-2021-23521",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0c9ba7e2",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `std::unique_ptr<InputStream>` for resource management, which guarantees cleanup via RAII when the pointer goes out of scope. This directly aligns with HS-MEM-001's requirement for guaranteed cleanup paths.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Resource allocation must have guaranteed cleanup paths"
      },
      {
        "score": 7,
        "reasoning": "The code performs file operations (delete, create, write) and attempts to maintain consistency by checking for failures and returning error results. However, it lacks transactional safety (e.g., if writing fails after a delete, the original file is lost). This is moderately relevant to maintaining consistent state during failures.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File operations must maintain consistent state during failures"
      },
      {
        "score": 6,
        "reasoning": "Error handling is present via `Result` returns, which helps maintain object state invariants by preventing partial or invalid operations from completing. However, the function's primary focus is on file operations rather than complex object lifecycle management, making relevance moderate.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Error handling must maintain object lifecycle invariants"
      },
      {
        "score": 5,
        "reasoning": "The code attempts resource cleanup by deleting existing files before writing and checking for stream/open failures. However, there is no explicit cleanup of partially written files if the output stream fails during the `out << *in` operation, making the relevance strong but not perfect.",
        "spec_index": 3,
        "spec_preview": "HS-IO-002: File operation failures must ensure complete resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "All exit paths return a `Result`, and the `std::unique_ptr` ensures the input stream is cleaned up. However, as noted, there is a potential inconsistent state if file writing fails after a successful delete, making the relevance strong but not complete.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-003: Function exit paths must maintain consistent resource state"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve explicit buffer allocation or padding calculations. It uses high-level stream operations, so this specification about buffer padding has very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The specification refers to \"Image compression operations\" and \"encoder buffers,\" which are not present in this zip file extraction code. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "While the code reads from a stream into a `String` for symbolic links, it does not perform explicit array writes or buffer allocations that require bounds validation against a known allocated size. The relevance is weak.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      }
    ]
  },
  "CVE-2022-30292_before_exclude_100:e650447d:spec": {
    "timestamp": "2026-01-16T21:24:37.361954",
    "cve_id": "CVE-2022-30292",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e650447d",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform explicit memory allocation. It manipulates Squirrel VM stack objects and thread references, but there is no visible malloc/new or similar allocation that requires initialization before use. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code has two distinct execution paths (success and error). On the error path (sq_call fails), it copies the error state from the child thread to the parent thread (v->_lasterror = _thread(o)->_lasterror). This ensures error state consistency. The success path also maintains consistency by moving the result and cleaning up the child thread's stack.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code is a thread call dispatcher within a scripting language VM. It does not handle network protocols or process network input.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not perform any character encoding conversion operations. It moves objects between VM stacks.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not operate on fixed-size buffers. It uses the Squirrel VM's dynamic stack operations (sq_move, sq_pop).",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not perform character encoding conversions.",
        "spec_index": 5,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not perform explicit buffer allocation. It works with the VM's internal object management.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not handle image compression or encoder buffers. It is a thread invocation function.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2021-41206_after_exclude_100:5388e22d:spec": {
    "timestamp": "2026-01-16T21:24:39.059292",
    "cve_id": "CVE-2021-41206",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5388e22d",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs grouped convolution operations for neural networks, not cryptographic operations on secret values. There is no handling of cryptographic keys or secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a neural network convolution implementation, not an elliptic curve cryptography implementation. There are no cryptographic curves or side-channel resistance considerations relevant to this code.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "While the code involves memory operations for tensor shuffling and convolution, it does not perform cryptographic processing or handle secret data that would require constant-time memory operations to prevent side-channel attacks.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates temporary tensors (input_shuffled, filter_shuffled, output_shuffled) but does not show explicit cleanup logic. There's weak relevance as resource management is present but not the main focus, and the specification about conditional cleanup on initialization success is not directly addressed.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve cryptographic key objects or algorithm support verification. It performs neural network operations with tensor manipulation, not cryptographic key management.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 5,
        "reasoning": "The code is unrelated to DNSSEC key processing or network protocols. It implements a grouped convolution operation for machine learning, not DNS security operations.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs array/tensor operations including dimension calculations, shuffling, and slicing. While there are bounds checks implied through TensorFlow's OP_REQUIRES_OK and tensor dimension access, explicit bounds validation against allocated sizes is not clearly visible in this snippet. The tensor operations could potentially have bounds issues if dimensions are miscalculated.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates the data_format parameter (NHWC format check) and handles padding parameters, which shows some parameter validation. However, this is not profile-specific validation nor comprehensive domain constraint enforcement as specified. The validation is minimal and specific to tensor format requirements.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Profile-specific parameter validation must enforce domain constraints"
      }
    ]
  },
  "CVE-2022-40299_before_exclude_100:8e58a059:spec": {
    "timestamp": "2026-01-16T21:24:40.322078",
    "cve_id": "CVE-2022-40299",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8e58a059",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `omAlloc` and `omStrDup` for memory allocation. While the allocated memory for `pi->data.s.body` is later initialized with `myfread`, the buffer `p` allocated with `omAlloc` is used in a `sprintf` without prior initialization. However, `sprintf` writes the entire content, so the lack of pre-initialization is not a critical issue here. The specification is moderately relevant because it reminds us to ensure allocated memory is properly initialized before use, which the code mostly does.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error handling paths (e.g., fopen fails, fork fails, execlp fails). It generally maintains consistency by closing files (`fclose`), freeing memory (`omFree`), and unlinking temporary files (`si_unlink`). However, there is a potential inconsistency: if `fopen` fails on the second attempt (line starting with `fp=fopen(filename,\"r\")`), the function proceeds to `si_unlink(filename)` and `omFree(filename)` without restoring or cleaning up `pi->data.s.body` (which was freed earlier). The specification is strongly relevant as it highlights the need for consistent state management across all error paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code does not handle network protocols. It deals with local file operations, process forking, and environment variables. Therefore, this specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not process protocol messages. It handles a local procedure body and temporary files. No protocol or length field validation is present. Therefore, this specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce bounds checking for all length values"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve session setup or security-related protocol fields. It is a local function for editing a procedure body. Therefore, this specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Session setup handlers must validate all security-related protocol fields before pr..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It uses string manipulation and file I/O. Therefore, this specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses `strlen` on `pi->data.s.body` to determine the size for `fwrite`. If `pi->data.s.body` is not null-terminated or contains embedded NUL bytes, `strlen` will give an incorrect length, leading to incomplete writing or buffer over-read. This is a classic issue with untrusted input. The specification is highly relevant as it recommends using length-aware operations (e.g., using a known length instead of relying on `strlen`).",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2021-23521_before_exclude_100:a58335b1:spec": {
    "timestamp": "2026-01-16T21:24:41.502027",
    "cve_id": "CVE-2021-23521",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a58335b1",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `std::unique_ptr<InputStream>` for a resource (input stream), which guarantees cleanup via RAII when the function exits. This is a good practice. However, the guarantee is not absolute for all paths if an exception is thrown (though JUCE code may use exceptions sparingly). The cleanup path for the `FileOutputStream` is also managed by its destructor. Moderate relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Resource allocation must have guaranteed cleanup paths"
      },
      {
        "score": 8,
        "reasoning": "The function performs file operations (delete, create directory, write). It checks for failures and returns error results, attempting to leave the system in a consistent state (e.g., not leaving a partially written file if the output stream fails to open). However, it does not use transactional patterns (like write-to-temp-then-rename) which could offer stronger consistency. Strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File operations must maintain consistent state during failures"
      },
      {
        "score": 6,
        "reasoning": "Error handling is present via `Result` returns. Object lifecycle invariants (like the `ZipFile` object state) are not directly impacted by failures in this function, as it mainly operates on external files. The function does not modify the `ZipFile`'s internal state in a way that could become inconsistent on error. Moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Error handling must maintain object lifecycle invariants"
      },
      {
        "score": 8,
        "reasoning": "Similar to spec 2. The code cleans up by deleting an existing file before overwriting, and the `FileOutputStream` destructor will close the file handle. However, if the write operation (`out << *in`) fails mid-stream, the target file may be left in a partially written state. No explicit cleanup of that partial file is performed. Strong relevance, but not perfect.",
        "spec_index": 3,
        "spec_preview": "HS-IO-002: File operation failures must ensure complete resource cleanup"
      },
      {
        "score": 7,
        "reasoning": "All explicit exit paths (return statements) ensure that dynamically allocated resources (`std::unique_ptr`, `FileOutputStream`) are cleaned up via destructors. The state of the external file system might not be fully consistent on all failure paths (partial writes). Moderate to strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-003: Function exit paths must maintain consistent resource state"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve explicit low-level buffer allocation or padding calculations. It uses high-level stream classes. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code is for decompressing zip entries, not image compression. The specification mentions \"Image compression operations\" and \"encoder buffers,\" which are not applicable here. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit array write operations where bounds need to be validated against an allocated size. It uses high-level container access (`entries.getUnchecked(index)`) which is potentially unsafe if `index` is invalid, but that is a pre-condition for the function. The specification focuses on buffer writes, not container access. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      }
    ]
  },
  "CVE-2011-1678_after_exclude_100:555756dc:spec": {
    "timestamp": "2026-01-16T21:24:41.610146",
    "cve_id": "CVE-2011-1678",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "555756dc",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It processes mount options by concatenating strings based on flags, but there is no pattern matching or regex engine that would need to handle embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile or process patterns with escape sequences. It constructs a string of mount options from predefined flag checks, not from user-provided pattern strings that require escape sequence handling.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code uses `strlcat` for string concatenation, which is a length-aware operation that helps prevent buffer overflows. However, the input (`devname`, `mountpoint`, `fstype`, `mount_user`) is not clearly validated as untrusted, and the buffer size (`MTAB_OPTIONS_LEN`) is fixed but used consistently.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code uses `calloc` for `mountent.mnt_opts`, which initializes memory to zero. This is good practice. However, other allocations or structures (like `mountent` fields) are not fully initialized if `calloc` fails (the code checks `if (mountent.mnt_opts)` but doesn't handle the else case for adding options).",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strongly relevant. The code has multiple error handling paths (e.g., after `setreuid`, `sigprocmask`, `lock_mtab`, `setmntent`, `fstat`, `addmntent`). It generally maintains consistency by unlocking resources (`unlock_mtab`), closing files (`endmntent`), and restoring signal masks. However, some early returns (e.g., after `toggle_dac_capability`) might skip cleanup, and the `goto add_mtab_exit` is used to centralize cleanup.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code does not handle network protocols. It updates a local mount table file (`/etc/mtab` or similar). Input validation (e.g., checking `devname`, `mountpoint` for path traversal) is minimal or absent, but this is not network-related.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function manages privileges: it drops root privileges early via `setreuid(geteuid(), -1)` to limit signal vulnerability, and uses `toggle_dac_capability` to manipulate capabilities. However, it does not enforce immediate process termination on privilege separation failures; it returns an error code (`EX_FILEIO`) instead, which may allow continued execution in a privileged state.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses file locking (`lock_mtab`) and signal blocking to protect critical sections when updating the mount table, which provides some atomicity. However, the specification mentions \"security-critical state transitions\" and \"atomic verification,\" which is only partially addressed (e.g., the `ftruncate` on error attempts to restore file size, but race conditions might still exist).",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2011-1678_before_exclude_100:1e7e2d84:spec": {
    "timestamp": "2026-01-16T21:24:43.602456",
    "cve_id": "CVE-2011-1678",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1e7e2d84",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It processes mount options by concatenating strings based on flags, but there is no regex engine or pattern matching that would need to handle embedded NUL bytes. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It constructs a string for mount options using simple string concatenation. The specification is about pattern compilers, which is not present here, making relevance very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The code uses `strlcat` for string concatenation, which is a length-aware operation that helps prevent buffer overflows. This is relevant because the mount options string is built in a fixed-size buffer (`MTAB_OPTIONS_LEN`). However, the input parameters (`devname`, `mountpoint`, `fstype`) are not validated for length before being assigned to `mountent`, which could be a concern if they are untrusted. Moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "The code uses `calloc` to allocate memory for `mountent.mnt_opts`, which initializes the memory to zero. This ensures the buffer is fully initialized before `strlcat` operations, preventing potential information leaks from uninitialized memory. Strong relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The code has multiple error handling paths (e.g., after `lock_mtab`, `setmntent` failures). It generally attempts to clean up resources (like unlocking mtab, freeing memory, restoring signal mask) before exiting, but there are potential issues: if `addmntent` fails, `mountent.mnt_opts` is freed via `SAFE_FREE`, but the mtab is already unlocked and signal mask/DAC capability are restored later. This could leave the mtab in an inconsistent state if errors occur mid-operation. Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "The code does not handle network protocols. It updates a local mount table file. The specification is about network input validation, which is not applicable here, resulting in very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "The code changes privileges by setting the real UID to the effective UID and uses `toggle_dac_capability` to manipulate capabilities. If privilege separation fails (e.g., `setreuid` or `toggle_dac_capability` fails), the function returns an error but does not terminate the process immediately. This could allow continued execution with unexpected privileges. The specification directly addresses this security concern, making it highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 7,
        "reasoning": "The code uses signal blocking (`sigprocmask`) and file locking (`lock_mtab`) to protect critical sections when updating the mtab file. This aims to ensure atomic state transitions for the mtab. However, the atomicity of the entire update operation (file write) depends on the underlying `addmntent` and file system. The specification is relevant but not perfectly matched, as the code does not explicitly verify the state transition atomically beyond locking. Moderate to strong relevance.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2022-2126_after_exclude_100:01f7ac1d:spec": {
    "timestamp": "2026-01-16T21:24:44.267359",
    "cve_id": "CVE-2022-2126",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "01f7ac1d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses fixed-size buffers (tword[MAXWLEN], preword[MAXWLEN * 3], compflags[MAXWLEN]) and performs string operations (STRCPY, STRCAT, mch_memmove) without explicit boundary checks. While some length tracking exists (ts_twordlen, ts_prewordlen), there's no validation that these indices stay within buffer capacity before arithmetic operations or string copies, making buffer overflow risks possible.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 5,
        "reasoning": "The code processes strings (fword, tword, preword) with transformations (character swaps, replacements, insertions) but maintains some boundary awareness through length variables. However, it's not a network protocol handler, so the specification's focus on protocol string processing is only loosely applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      },
      {
        "score": 5,
        "reasoning": "The code performs extensive input transformations (character substitutions, insertions, deletions, swaps, compound word handling) with some validation (checking flags, compound rules). However, it lacks comprehensive validation of transformation requirements against buffer limits before applying modifications, particularly for multi-byte character handling.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-003: Input processing must validate transformation requirements before applying modificatio..."
      },
      {
        "score": 5,
        "reasoning": "The code uses stack-allocated fixed-size buffers rather than dynamic memory allocation. There are no malloc/calloc calls or pointer validations for allocated memory in this function, making this specification less relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Critical memory allocations must be validated before use"
      },
      {
        "score": 2,
        "reasoning": "Since the function uses stack allocation rather than dynamic resource allocation, there are no resource allocation failures to handle. State consistency after failures isn't a primary concern in this code segment.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: System must maintain consistent state after resource allocation failures"
      },
      {
        "score": 5,
        "reasoning": "The code calculates string lengths and indices (ts_twordlen, ts_prewordlen, ts_fidx) and performs arithmetic operations. While it checks against some maximums (MAXWLEN), it doesn't validate against integer overflow risks when calculating buffer positions or string lengths, particularly with multi-byte characters.",
        "spec_index": 5,
        "spec_preview": "HS-LOGIC-001: String length calculations must validate against maximum representable integer values"
      },
      {
        "score": 2,
        "reasoning": "No dynamic memory allocation occurs in this function - all buffers are fixed-size stack arrays. The specification about validating requested size against system limits doesn't apply here.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation must validate requested size against system limits"
      },
      {
        "score": 5,
        "reasoning": "The code performs output transformations (building preword from tword/fword with case changes, compound word construction) and has some size limits (MAXWLEN). However, it doesn't consistently enforce reasonable size limits on output transformations, particularly when concatenating multiple words or handling compound words with repeated operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-003: Input processing must enforce reasonable size limits on output transformations"
      }
    ]
  },
  "CVE-2010-1311_before_exclude_100:91fa0fa4:spec": {
    "timestamp": "2026-01-16T21:24:44.420837",
    "cve_id": "CVE-2010-1311",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "91fa0fa4",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs LZ77-style decompression with match copies from a sliding window. It validates that match_offset does not exceed window boundaries (check: `if (match_offset > window_posn)` and `if (j > (int) qtm->window_size)`). It also checks that the copy length does not exceed remaining window space (`if(i > (int) (qtm->window_size - window_posn)) i = qtm->window_size - window_posn;`). This directly addresses HS-MEM-001's requirement to validate match lengths against remaining window space.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Decompression operations must validate match lengths against remaining window space"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code validates input parameters at the start (`if (!qtm || (out_bytes < 0)) return CL_ENULLARG;` and checks `qtm->error`). However, it does not appear to comprehensively validate all decompression parameters (e.g., internal model states, window size consistency) before full processing, which is the broader intent of HS-INPUT-002 for archive parsers.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all decompression parameters before processing"
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The specification concerns buffer allocation with padding and safety margins. The target code operates on already allocated buffers (`qtm->window`) and does not perform memory allocation. Any allocation would be in calling code, not visible here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. HS-IO-004 specifically addresses \"Image compression operations\" and \"encoder buffers.\" This code is a general-purpose decompressor (QTM) for archive files, not an image encoder. The bounds checking present is for decompression safety, not encoder buffer protection.",
        "spec_index": 3,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The specification is about initializing memory allocations before use. The code uses pre-allocated structures and local variables. Local variables like `i`, `j` are initialized before use, but the core security concern of the spec (uninitialized heap memory) is not directly addressed here as no allocation occurs.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code maintains consistent error state by assigning to `qtm->error` on all error return paths (e.g., `return qtm->error = CL_EFORMAT;`). It also restores and stores the local bitstream state (`QTM_RESTORE_BITS`/`QTM_STORE_BITS`) and other fields (`H, L, C`, etc.) to keep the stream object consistent across calls, which aligns with HS-STATE-002's goal for error paths to maintain consistent object states.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. HS-IO-003 is for network protocol handlers. This code is a decompression routine for file archives, not a network handler. While both require input validation, the context and threat models (network-based attacks vs. file parsing) differ significantly.",
        "spec_index": 6,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. HS-INPUT-001 is specifically for regular expression parsers handling NUL bytes. This code is a decompression algorithm that works on binary data streams; it does not parse regular expressions or treat input as NUL-terminated strings.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      }
    ]
  },
  "CVE-2022-28463_after_exclude_100:d22eea59:spec": {
    "timestamp": "2026-01-16T21:24:44.517659",
    "cve_id": "CVE-2022-28463",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d22eea59",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code performs validation of critical header fields early in the parsing process. It checks the magic number (\"\\200\\052\\137\\327\"), validates that cin.file.image_offset is not too small (>= 712), and checks for proper read counts. This directly aligns with HS-INPUT-001's requirement to validate critical header fields before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 7,
        "reasoning": "The code includes some size validation before memory operations. For example, it checks if cin.file.user_length > GetBlobSize(image) before creating a StringInfo profile. However, it lacks comprehensive pre-validation for all size parameters, such as checking if image->columns * image->rows could cause overflow before memory allocation in SetImageExtent.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "This specification specifically addresses BMP parser requirements, but the target code is for CIN/DPX image format parsing. There is no direct relevance to BMP bit count requirements.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 8,
        "reasoning": "The code validates structural relationships between header fields, such as checking offset relationships (cin.file.image_offset > 2048) and ensuring user_length doesn't exceed file size. It also validates that the image data size ((image->columns * image->rows / 8) <= GetBlobSize(image)) is sufficient before processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 6,
        "reasoning": "The code uses loops with fixed bounds (e.g., for i=0; i < 8) for channel processing, which provides implicit bounds checking. However, it doesn't explicitly validate array indexing against allocated sizes for dynamically allocated structures, and it reads into fixed-size buffers without explicit bounds checking on the source data size.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The code implements comprehensive error handling with proper resource cleanup. It uses ThrowReaderException for error conditions, properly destroys images and quantum_info on failure paths, closes blobs, and frees allocated resources. This aligns well with HS-IO-003 requirements.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "The code initializes the cin structure with memset(&cin,0,sizeof(cin)) before use. It also initializes image properties and uses AcquireImage which should properly initialize the image structure. However, not all buffers (like property[]) are explicitly initialized before use in string copying operations.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code maintains consistent object states in error handling paths. When errors occur, it properly cleans up resources (DestroyImageList, DestroyQuantumInfo, DestroyStringInfo) and returns NULL or appropriate error states. The control flow ensures objects are either fully initialized and valid or properly destroyed.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2010-1311_after_exclude_100:cc1e3461:spec": {
    "timestamp": "2026-01-16T21:24:44.925759",
    "cve_id": "CVE-2010-1311",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cc1e3461",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs decompression with LZ77-style match copying. It explicitly validates that `window_posn + match_length` does not exceed `qtm->window_size` (line ~77), which is a direct implementation of validating match lengths against remaining window space to prevent buffer overflow. This is a core security check for this decompressor.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Decompression operations must validate match lengths against remaining window space"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code validates input parameters early (e.g., checking for NULL `qtm` and negative `out_bytes`). It also performs validation of decompression parameters like `match_offset` against window boundaries (line ~87). However, the specification is broad (\"all decompression parameters\"), and while some are checked, a comprehensive review might be needed for others like model table indices.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all decompression parameters before processing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification concerns buffer allocation with padding and safety margins. The target code does not perform memory allocation; it operates on pre-allocated buffers (`qtm->window`). Its safety relies on correct window size and bounds checking, not on allocation strategy.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is for \"Image compression operations\" and \"encoder buffers\". This code is a general-purpose decompression routine (QTM, likely Quantum compression) for archives, not specifically for images, and it is a decoder, not an encoder.",
        "spec_index": 3,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses stack-allocated local variables and a pre-existing window buffer. While it initializes some local state (e.g., `H`, `L`, `C` from saved context or header), the specification about memory allocation initialization is not directly applicable as no dynamic allocation occurs here.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code consistently sets `qtm->error` on various error paths (e.g., format errors, write failures) before returning. This maintains a consistent error state in the `qtm` object. However, it does not necessarily roll back all object state changes on error (e.g., `window_posn` may have advanced), which slightly reduces the score.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification is for \"Network protocol handlers\". This code is a file/archive decompression routine. While both involve parsing untrusted input, the context and typical threat models differ. The validation it performs (bounds checking) is similar in spirit but not directly for network protocols.",
        "spec_index": 6,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is specifically for \"Regular expression parsers\" handling \"embedded NUL bytes\". This code is a compression decompressor that works on binary data streams, not regular expression parsing. The concepts are unrelated.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      }
    ]
  },
  "CVE-2016-7132_before_exclude_100:ffbb0fdf:spec": {
    "timestamp": "2026-01-16T21:24:45.773268",
    "cve_id": "CVE-2016-7132",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ffbb0fdf",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code shows memory allocation (e.g., `efree(ent1)`, `efree(stack->varname)`) and initialization patterns. While not all allocations are explicitly shown, the handling of `st_entry` structures and their `varname`/`data` fields involves memory management. The relevance is moderate because the specification about full initialization before use is a general secure coding principle applicable to any memory operation, but the code snippet focuses more on cleanup and data structure manipulation than on the initialization of newly allocated memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The code contains multiple error/edge case paths (e.g., checking for `IS_UNDEF`, `stack->top` conditions, non-existent fields) that modify stack state and free memory. It attempts to maintain consistency by adjusting `stack->top` and `stack->done`. However, the specification about \"object states\" is more broadly about system/object consistency, while this code manages a parser stack. The relevance is moderate as error paths do perform cleanup, but the context is limited to a specific parsing function.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 8,
        "reasoning": "This function is part of a WDDX (Web Distributed Data eXchange) deserializer, which processes XML input (a network/data format). It validates element names (`strcmp` checks for expected tags like EL_STRING, EL_ARRAY) before processing. This directly relates to validating input before processing in a network protocol/data format handler. The relevance is strong, though the validation is primarily about tag names rather than deep content validation.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns keyring modification operations and permission validation. The target code is a WDDX deserialization routine with no keyring, cryptographic, or permission-related operations. It deals with data structures, objects, and arrays, not security tokens or key management. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Keyring modification operations must enforce complete permission validation regardless o..."
      },
      {
        "score": 2,
        "reasoning": "The specification is about default security behaviors versus explicit configurations, typically in authentication/access control systems. This code does not manage security policies, configurations, or defaults. It performs data deserialization with specific, hardcoded logic. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-AUTH-002: Default security behaviors must maintain equivalent protection to explicit configuratio..."
      },
      {
        "score": 1,
        "reasoning": "The specification is about keyring state transitions and permission requirements. As with spec 4 and 5, this code has nothing to do with keyrings, cryptographic states, or permission checks. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Keyring state transitions must maintain consistent permission requirements"
      },
      {
        "score": 5,
        "reasoning": "The code handles string data (e.g., `ent1->varname`, `Z_STRVAL(ent1->data)`) and performs operations like `zend_str_tolower`. However, there is no explicit character encoding validation or enforcement of domain-specific size constraints visible. The `php_base64_decode` call could involve size calculations but isn't clearly validating encoding. Relevance is weak, as string processing is present but not the focus of the specification.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 6,
        "reasoning": "The code performs array/object operations (`zend_hash_next_index_insert`, `zend_symtable_str_update`, `add_property_zval`) and accesses hash tables (`target_hash`). While it uses safe-looking API calls, there is no explicit pre-access validation of computed indices shown (e.g., checking hash bounds). The relevance is moderate because the code does involve array/buffer operations, but the specification's focus on index validation is not prominently addressed in the snippet.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2022-2126_before_exclude_100:bf77af48:spec": {
    "timestamp": "2026-01-16T21:24:47.120667",
    "cve_id": "CVE-2022-2126",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bf77af48",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs extensive string manipulations and array indexing (e.g., tword[MAXWLEN], preword[MAXWLEN * 3], stack[MAXWLEN]) while walking a trie structure. There are multiple operations that increment indices (ts_fidx, ts_twordlen, etc.) and copy data without explicit bounds checking against the fixed array sizes. The specification about validating remaining capacity before arithmetic operations is highly relevant to prevent buffer overflows.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 5,
        "reasoning": "The code processes strings (fword, tword, preword) and performs transformations (REP replacements, case changes, swaps). While it does maintain some boundary awareness (e.g., checking for NUL), the specification about \"strict boundary awareness during transformations\" is moderately relevant. The code uses fixed-size buffers but doesn't always explicitly validate that transformations stay within bounds during operations like STRMOVE or mch_memmove.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      },
      {
        "score": 7,
        "reasoning": "The code validates various conditions before applying transformations (e.g., checking flags, compound rules, banned words). However, it doesn't consistently validate transformation requirements against buffer sizes. The specification is moderately to strongly relevant as the code does perform input validation but could be more comprehensive regarding buffer boundaries.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-003: Input processing must validate transformation requirements before applying modificatio..."
      },
      {
        "score": 3,
        "reasoning": "The code uses fixed-size stack arrays and doesn't perform dynamic memory allocation within this function. While there are pointer references to external data structures (slang, etc.), the critical operations use pre-allocated buffers. Therefore, this specification about validating critical memory allocations has low relevance to this specific code segment.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Critical memory allocations must be validated before use"
      },
      {
        "score": 2,
        "reasoning": "The code doesn't involve resource allocation failures within this function - it uses stack arrays and external data structures. State consistency after failures isn't a primary concern in this algorithmic trie-walking code. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: System must maintain consistent state after resource allocation failures"
      },
      {
        "score": 6,
        "reasoning": "The code calculates string lengths using STRLEN and performs arithmetic on indices. While it doesn't explicitly validate against maximum representable integers, the use of fixed-size buffers (MAXWLEN) provides implicit limits. Moderate relevance as length calculations could theoretically overflow but are constrained by buffer sizes.",
        "spec_index": 5,
        "spec_preview": "HS-LOGIC-001: String length calculations must validate against maximum representable integer values"
      },
      {
        "score": 2,
        "reasoning": "No dynamic memory allocation occurs in this function, so validation against system limits isn't applicable. The function works with pre-allocated fixed-size buffers and external data structures.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation must validate requested size against system limits"
      },
      {
        "score": 7,
        "reasoning": "The code performs output transformations (case changes, REP substitutions, compound word formation) into fixed-size buffers. While it has some size limits (MAXWLEN), it doesn't consistently enforce that output transformations won't exceed these limits. The specification is moderately to strongly relevant as the code should ensure transformations don't overflow the pre-allocated buffers.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-003: Input processing must enforce reasonable size limits on output transformations"
      }
    ]
  },
  "CVE-2022-28463_before_exclude_100:a1898d82:spec": {
    "timestamp": "2026-01-16T21:24:53.555512",
    "cve_id": "CVE-2022-28463",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a1898d82",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates critical header fields early, such as the magic number (\"\\200\\052\\137\\327\") and checks `count != 4`. It also validates structural relationships like `cin.file.image_offset` and file size checks later. This directly aligns with validating header fields before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs some size validation (e.g., checking `cin.file.user_length > GetBlobSize(image)` before allocating memory for a profile). However, it does not extensively pre-validate all size parameters before allocations (e.g., `image->columns` and `image->rows` are used without explicit pre-validation against reasonable limits before `SetImageExtent`).",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This specification is specifically for BMP parsers, but the target code is for CIN/DPX image format parsing. The code does not process BMP files or bit count requirements.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code validates structural relationships between header fields, such as checking `cin.file.image_offset > 2048` before reading film information, verifying `offset < cin.file.image_offset`, and ensuring `((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image)` to prevent insufficient data processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses loops with bounds (e.g., `for (i=0; i < 8; i++)` for channels) which are fixed and safe. However, it does not explicitly validate array indexing for dynamically allocated data structures beyond fixed loops. Pixel data reading uses `length` derived from image dimensions, which are validated indirectly.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements error handling with resource cleanup, such as destroying images (`DestroyImageList`) on failure, closing blobs, and using `ThrowReaderException` for errors. However, not all error paths may clean up every resource (e.g., early returns might miss some cleanup).",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code initializes memory with `memset(&cin,0,sizeof(cin))` for the CINInfo structure and uses `AcquireImage` which likely initializes image memory. However, not all buffers (e.g., `property`) are fully initialized before use, though they are used safely via `CopyMagickString`.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code maintains consistent states in error paths by destroying images and returning NULL. However, some error paths might leave partially initialized structures or not roll back all state changes (e.g., after reading partial header data). The use of `ThrowReaderException` helps centralize error handling.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-23568_after_exclude_100:21725540:spec": {
    "timestamp": "2026-01-16T21:25:01.256109",
    "cve_id": "CVE-2022-23568",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "21725540",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor manipulation and grouping operations. It does not involve any cryptographic operations on secret values. The logic is focused on data structure transformation and validation, not cryptography.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or cryptographic operations. It deals with sparse tensor data structures in a machine learning context, not cryptographic curve models.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory operations for tensor manipulation but does not involve cryptographic processing. There is no indication of secret data handling or constant-time requirements for security purposes.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs bounds validation through OP_REQUIRES checks (e.g., checking b > -1 && b < N) and validates tensor shapes before processing. However, these are not \"fixed buffer operations\" in the traditional security sense, but rather tensor dimension validations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements comprehensive input validation before processing, including checking tensor shapes, dimensions, and values. Multiple OP_REQUIRES statements validate input sizes and structural integrity, which aligns with the specification's requirement for complete input size validation.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code enforces structural constraints on sparse tensor data through validation of indices, values, and shape relationships. It checks that the input conforms to expected sparse tensor structure, though this is more about data format validation than configuration parsing.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code performs arithmetic for tensor dimension calculations and indexing, but there's no explicit memory allocation arithmetic shown. The operations involve tensor sizes and indices, but overflow protection is not visibly addressed in the shown code.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations for memory allocation must use overflow-protected calculations w..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates tensor dimensions and shapes, which is conceptually similar to image dimension validation. However, it doesn't explicitly check maximum allocation sizes before processing, and the context is sparse tensors rather than image data specifically.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Image dimension validation must include maximum allocation size checks before processi..."
      }
    ]
  },
  "CVE-2022-23568_before_exclude_100:cd6da450:spec": {
    "timestamp": "2026-01-16T21:25:02.681721",
    "cve_id": "CVE-2022-23568",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cd6da450",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor manipulation and grouping operations. It does not involve any cryptographic operations on secret values. The logic is focused on data structure transformation and validation, not cryptography.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or cryptographic operations. It is a tensor processing routine in what appears to be a machine learning framework (TensorFlow).",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No cryptographic processing occurs in this code. The operations involve tensor manipulation, memory allocation for sparse tensors, and validation checks, but not cryptographic algorithms requiring constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs bounds validation through multiple OP_REQUIRES checks on tensor dimensions and indices. It validates that indices are within expected ranges (b > -1 && b < N) and checks tensor shape compatibility. However, it doesn't use fixed buffers in the traditional C array sense; it uses tensor objects with their own bounds management.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements comprehensive input validation before processing. It validates tensor shapes (IsMatrix, IsVector), dimension compatibility, rank requirements, and performs overflow checking on shape calculations. The validation occurs before any significant processing of the input data.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. While not a configuration parser, the code enforces structural constraints on input sparse tensor data. It validates the relationships between indices, values, and shape tensors, ensuring they form a valid sparse tensor representation before processing.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code explicitly implements overflow-protected calculations using MultiplyWithoutOverflow() when computing new_num_elements from input shape dimensions. It checks for overflow and returns an error if detected. This directly addresses the security concern of integer overflow in memory allocation calculations.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations for memory allocation must use overflow-protected calculations w..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates tensor dimensions and performs overflow checking on shape calculations, which is conceptually similar to image dimension validation. However, it's not specifically for image data, and the maximum allocation size check is implicit through overflow protection rather than explicit maximum size validation.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Image dimension validation must include maximum allocation size checks before processi..."
      }
    ]
  },
  "CVE-2022-30292_after_exclude_100:d4d5c192:spec": {
    "timestamp": "2026-01-16T21:25:06.395159",
    "cve_id": "CVE-2022-30292",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d4d5c192",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code uses `sq_reservestack` which likely involves memory allocation for the thread's stack. While the allocation itself is not directly visible, ensuring the newly reserved stack memory is initialized before use is a relevant security consideration to prevent information leaks. However, the initialization responsibility likely lies within the `sq_reservestack` implementation, not this specific function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code has two primary execution paths: success (`SQ_SUCCEEDED`) and error. In the error path, it copies the error state from the child thread (`v->_lasterror = _thread(o)->_lasterror`) before returning `SQ_ERROR`. This maintains a consistent error state in the calling VM (`v`). The function also ensures consistent state by popping the result from the child thread's stack only on the success path.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is a Squirrel VM function for calling a thread, not a network protocol handler. There is no network input processing involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform any character encoding conversion operations. It manipulates VM stack objects and calls functions within the Squirrel interpreter.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The code does not explicitly operate on fixed-size buffers. It works with a dynamically reservable stack (`sq_reservestack`). However, the loop `for(SQInteger i = 2; i<(nparams+1); i++)` moves parameters between VM stacks, which implies bounds checking should be performed by the `sq_move` function to prevent stack over/underflows. The relevance is indirect.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform any character encoding conversions. Its operations are related to virtual machine stack manipulation and thread execution.",
        "spec_index": 5,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The call to `sq_reservestack(_thread(o), nparams + 3)` suggests an allocation that accounts for the parameters plus some overhead (the \"+3\"). This could be interpreted as accounting for operational padding (e.g., space for the root table and call metadata). However, the specification is primarily about buffer allocation with safety margins, which is a broader concept than this specific stack reservation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve image compression operations or encoder buffers. It is part of a scripting language's thread management functionality.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2009-0689_before_exclude_100:ed7c9583:spec": {
    "timestamp": "2026-01-16T21:25:13.046639",
    "cve_id": "CVE-2009-0689",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ed7c9583",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via MALLOC but only partially initializes the returned Bigint structure (sign and wds are set, but the rest of the allocated memory, including the array portion for 'x', is not explicitly initialized). This directly relates to HS-MEM-001's requirement for full initialization before use to prevent exposure of uninitialized memory contents.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code lacks explicit error handling for the case where MALLOC fails (returns NULL). If allocation fails, the code would proceed to dereference rv, leading to undefined behavior. This relates to maintaining consistent object states on error paths, but the specification's focus is broader than just memory allocation errors.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is a memory allocator utility function for big integers (dtoa library). It does not handle network protocols or process any external input in a network context.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code manages a shared resource (freelist) using a mutex (dtoa_mutex) to protect state transitions. The check of freelist[k] and its update (freelist[k] = rv->next) are performed within the mutex lock, which is a correct implementation of protecting shared state transitions.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function manages a resource (Bigint objects) tracked in a freelist array. It must maintain consistency between the freelist data structure and the actual allocation state. The mutex protects this consistency, but the specification's wording (\"different tracking structures\") suggests a more complex scenario than the single freelist used here.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses a mutex to guarantee thread-safety for concurrent access to the freelist, which is analogous to the requirement for filesystem metadata operations. However, the code does not perform filesystem operations.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 1,
        "reasoning": "Not applicable. The code is a memory allocator function and does not involve regular expression parsing or input pattern handling.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Not applicable. The code does not compile patterns, process escape sequences, or handle protocol-related data.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2009-0689_after_exclude_100:473f8495:spec": {
    "timestamp": "2026-01-16T21:25:16.962448",
    "cve_id": "CVE-2009-0689",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "473f8495",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code partially initializes the allocated Bigint structure (sets sign and wds to 0) but does not explicitly initialize the entire memory block, including the potential padding or the 'x' array of Longs. This could lead to information disclosure if uninitialized memory is used. The specification is highly relevant, but the code shows some, not zero, initialization effort.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has two error paths: one for `k > Kmax` and one for malloc failure. In the malloc failure path, it correctly unlocks the mutex before calling the error function, maintaining the consistency of the shared `freelist` state. The state before the error (mutex locked) is cleaned up.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "Not applicable. This code performs memory allocation from a freelist or system heap. It does not handle network protocols or process network input.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 10,
        "reasoning": "Directly and highly relevant. The code manages a shared resource (the `freelist[]` array) using a mutex (`dtoa_mutex`). All state transitions (checking the freelist, removing an element, adding a new allocation to the structure) are protected within the mutex lock/unlock critical section, ensuring atomicity and thread safety.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 9,
        "reasoning": "Strongly relevant. The code maintains a freelist data structure. Consistency must be kept between the `freelist[k]` pointer and the `next` pointer within each `Bigint` object. The mutex protection ensures that concurrent allocations/deallocations do not corrupt this linked list structure.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. While the specification is about thread-safety for concurrent access (which is implemented here via a mutex), the resource being protected is an in-memory data structure (`freelist`), not filesystem metadata. The core principle of synchronization is similar but the domain is different.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 1,
        "reasoning": "Not applicable. This code is a memory allocator utility function. It does not involve regular expression parsing or processing input patterns containing NUL bytes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Not applicable. This code does not compile patterns, process escape sequences, or deal with any form of text/pattern compilation. It is a low-level memory and object management function.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2020-1971_before_exclude_100:91fcf226:spec": {
    "timestamp": "2026-01-16T21:25:23.283769",
    "cve_id": "CVE-2020-1971",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "91fcf226",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code shows a test setup function calling a macro to add tests. There is no visible memory allocation or initialization of allocated memory in this snippet, making the specification about memory initialization only very loosely related.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function returns 1 (success) unconditionally. There is no visible error handling or state management for objects, but the lack of error checking could be a minor concern, leading to weak relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is for test setup, not a network protocol handler. There is no network input processing, making this specification not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsers or input pattern handling. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 2,
        "reasoning": "The code does not show string processing functions or handling of untrusted input. The macro likely expands to internal test registration, making this specification very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code is not related to protocol message field validation or RFC length constraints. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve TLV (Type-Length-Value) processing or bounds checking. The specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2020-1971_after_exclude_100:fb2f224e:spec": {
    "timestamp": "2026-01-16T21:25:31.606752",
    "cve_id": "CVE-2020-1971",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fb2f224e",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code shows test setup functions adding test cases to a test suite. There are no visible memory allocation operations in this snippet, making the memory initialization specification largely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "While the code doesn't show explicit error handling, test setup functions should properly handle failures. The return value (always 1) suggests potential error handling issues, giving weak relevance to state consistency concerns.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "This is test framework code with no network protocol handling or input processing, making this specification very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "No regular expression parsing is present in this test setup code, making this specification not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "No pattern compilation or escape sequence processing is visible in this test framework code.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While test functions might process strings internally, this specific snippet shows only test registration with no string operations, giving very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "This is test framework code, not protocol message handling code, making RFC length constraint validation irrelevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 2,
        "reasoning": "No TLV (Type-Length-Value) processing or bounds checking operations are visible in this test setup code.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2021-37690_before_exclude_100:1e524034:spec": {
    "timestamp": "2026-01-16T21:25:40.369944",
    "cve_id": "CVE-2021-37690",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1e524034",
    "scores": [
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-001 is about database view security and privilege checks. The target code is a TensorFlow shape inference function for graph nodes, with no database or view-based access concepts.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-STATE-002 mentions security-critical state transitions and privilege context. The code performs shape inference and validation without security state transitions or privilege management.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-PROTOCOL-003 is about SQL protocol implementations and view security. The code is for TensorFlow graph computation with no SQL or database protocols involved.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-001 addresses regular expression parsers and NUL bytes. The code does not use regular expressions or parse pattern strings.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-PROTOCOL-002 discusses pattern compilers and escape sequences. The code performs shape inference without pattern compilation or escape sequence processing.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-MEM-003 mentions string processing with length-aware operations. The code uses StringPiece for type comparison, which is a length-aware wrapper, but this is a minor aspect. The core functionality is shape validation, not string processing of untrusted input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "Specification HS-MEM-001 is about memory allocation and size tracking. The code performs shape inference and validation without explicit memory allocation operations. Memory management is handled by underlying TensorFlow libraries.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 4,
        "reasoning": "Specification HS-STATE-002 (second occurrence) discusses resource management and invariant consistency. The code validates array bounds (index checks) and maintains consistency between inner/outer contexts, which relates to resource state validation. However, this is about computational graph consistency rather than security-critical resource management.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2022-23584_before_exclude_100:2895e83c:spec": {
    "timestamp": "2026-01-16T21:25:40.586190",
    "cve_id": "CVE-2022-23584",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2895e83c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs PNG image decoding, not cryptographic operations on secret values. There is no handling of cryptographic keys, signatures, or other secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code is for PNG image processing and contains no elliptic curve implementations or any cryptographic operations related to curve models. The specification is completely unrelated to the target code's functionality.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "While the code does perform memory operations (buffer allocation and image data processing), it does not involve cryptographic processing. The constant-time requirement specifically applies to cryptographic operations to prevent side-channel attacks, which are not present here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer allocation for image data and includes bounds checking for width and height dimensions. However, the specification specifically mentions \"operational padding requirements with safety margin\" which is more relevant to cryptographic padding schemes than image buffer allocation. There is weak relevance due to the general buffer allocation and bounds checking present.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs PNG image decompression/decoding and includes multiple bounds checks: verifying width and height don't overflow int, checking single dimension limits, and verifying total size limits. It also validates the PNG data during decoding. This directly addresses the security concern of buffer overflows in image processing code.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code handles PNG image format, not cryptographic signatures or ASN.1 structures. There is no signature verification or ASN.1 parsing in this image decoding function.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Cryptographic signature verification must validate all ASN.1 structure lengths against..."
      },
      {
        "score": 5,
        "reasoning": "The code is for PNG image decoding and has no relation to PKCS#1 v1.5 verification, RSA padding, or public exponent handling. This cryptographic specification is completely outside the scope of the image processing code.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: PKCS#1 v1.5 verification must enforce minimum padding requirements regardless of publ..."
      },
      {
        "score": 5,
        "reasoning": "The code processes PNG image format, not X.509 certificates. There is no certificate parsing, structural metadata validation, or any PKI-related functionality in this image decoding function.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: X.509 parsers must validate all structural metadata before processing certificate c..."
      }
    ]
  },
  "CVE-2022-23584_after_exclude_100:ada0b9d9:spec": {
    "timestamp": "2026-01-16T21:25:43.338012",
    "cve_id": "CVE-2022-23584",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ada0b9d9",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs PNG image decoding, not cryptographic operations on secret values. There is no handling of cryptographic keys, signatures, or any data that requires constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is an image processing function (PNG decoder). It does not implement or use elliptic curve cryptography, so side-channel resistance for curve models is completely irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory operations for image data buffering and conversion, but these are not related to cryptographic processing. The specification's focus on maintaining constant-time properties during cryptographic processing does not apply.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates buffers for image data (e.g., `std::unique_ptr<uint16[]> buffer`). While it performs bounds checking on image dimensions to prevent overflow, the specification's emphasis on \"operational padding requirements with safety margin\" is more specific to cryptographic contexts (like padding for encryption blocks) and only loosely related to general buffer allocation safety.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The code implements PNG image decompression and performs strict bounds checking on width, height, and total size (`width >= (1LL << 27)`, `height >= (1LL << 27)`, `total_size >= (1LL << 29)`) to prevent integer overflows and excessive memory allocation. This directly addresses security issues in image decoder buffers.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 1,
        "reasoning": "The code does not perform cryptographic signature verification or parse ASN.1 structures. It decodes PNG image data, which has a different binary structure.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Cryptographic signature verification must validate all ASN.1 structure lengths against..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement PKCS#1 v1.5 verification, RSA, or any public-key cryptography. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: PKCS#1 v1.5 verification must enforce minimum padding requirements regardless of publ..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse X.509 certificates or any related structural metadata. It processes PNG image format data, which is unrelated to the X.509 protocol.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: X.509 parsers must validate all structural metadata before processing certificate c..."
      }
    ]
  },
  "CVE-2020-16287_before_exclude_100:f05d9927:spec": {
    "timestamp": "2026-01-16T21:25:44.056375",
    "cve_id": "CVE-2020-16287",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f05d9927",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code accesses `lprn->ImageBuf` using calculated indices `(y0 + y) * bpl + bx * lprn->nBw`. There is no explicit validation that these indices are within the allocated bounds of `ImageBuf`. This is a direct buffer access operation without bounds checking, making HS-MEM-003 highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Buffer access operations must validate bounds against allocated size before access"
      },
      {
        "score": 8,
        "reasoning": "The code manipulates a device buffer (`ImageBuf`) using derived dimensions (`bpl`, `nBw`, `nBh`, `BlockLine`). It assumes a strict correspondence between logical calculations (like `maxY`) and the physical buffer layout. Any mismatch could lead to out-of-bounds access, making this specification strongly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-IO-004: Device buffer handling must maintain strict correspondence between logical and physical b..."
      },
      {
        "score": 9,
        "reasoning": "The function processes printer input (r, h, bx) to derive coordinates (`y0`, `y`, `x`) for buffer access. These derived coordinates (`y0 + y`, `bx * nBw + x`) are not validated against the physical buffer constraints (e.g., total buffer size). This is a core security issue in the code, making the specification highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-005: Printer input processing must validate all derived coordinates against physical buffer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-43975_after_exclude_100:5d227f0c:spec": {
    "timestamp": "2026-01-16T21:25:44.967165",
    "cve_id": "CVE-2021-43975",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5d227f0c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the `sw.len` and `fw.len` fields against the fixed size of `self->rpc` buffer (`sizeof(self->rpc)`). This directly addresses validating protocol message length fields against a platform-specific limit (the buffer size). However, it does not check for integer overflow/wrap-around in the length calculation `(fw.len + sizeof(u32) - sizeof(u8)) / sizeof(u32)`, which is a related concern under this specification.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs validation (`fw.len > sizeof(self->rpc)`) before using the length in a memory operation (`hw_atl_utils_fw_downld_dwords`). This aligns with validating size parameters against usage requirements. However, there is no explicit dynamic memory allocation in this snippet; the buffer `self->rpc` appears to be a fixed-size member. The relevance is moderate as the principle applies but the context is static buffer validation rather than allocation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles length fields (`sw.len`, `fw.len`) consistently as unsigned integers and uses them in calculations and comparisons. However, the specification about \"consistent type handling across all processing stages\" is broad. The code shows some care (comparing against `0xFFFFU`, using `sizeof(u32)` for division), but potential issues like the signedness of `err` or the integer promotion in the length calculation are not fully evaluated. Moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The length fields (`sw.len`, `fw.len`) are read from hardware registers via `aq_hw_read_reg` and `readx_poll_timeout_atomic`, not from userspace. This specification specifically targets userspace-provided inputs, making it largely irrelevant to this low-level driver code interacting with firmware/hardware.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code acts as a protocol message handler for firmware RPC. It verifies the structural integrity of variable-length components by checking the length fields (`sw.len`, `fw.len`) against a maximum buffer size before proceeding with data download. This is a core part of the function's purpose. The check for `fw.len == 0xFFFFU` as a special case also suggests protocol state handling. Strong relevance, though the verification could be more robust (e.g., minimum length checks).",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The buffer `self->rpc` is a fixed-size array (implied by `sizeof(self->rpc)`). The code validates incoming length fields against this size, which accounts for a worst-case input scenario limited by the buffer size. However, the specification emphasizes \"allocation,\" and this is a static buffer. The relevance is moderate as the security principle of bounding input by buffer size is present.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain any explicit memory allocation operations (like `kmalloc`, `vmalloc`). The buffer `self->rpc` is presumably part of the `self` structure. There is no indication of initialization of this buffer before use in `hw_atl_utils_fw_downld_dwords`. However, the specification is about memory *allocations* being initialized, which is not directly applicable here. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has a clear `err_exit` label for centralized error handling. On error paths (triggered by `goto err_exit`), the function returns an error code (`err`). The state of the `rpc` output parameter is only set on the success path. This maintains a consistent state: on error, `err` is negative and `*rpc` is not modified (as the check `if (rpc)` may not even be reached). This is a good example of consistent error state management. Highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-43975_before_exclude_100:9e360ba2:spec": {
    "timestamp": "2026-01-16T21:25:45.228825",
    "cve_id": "CVE-2021-43975",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9e360ba2",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes a firmware RPC message with a length field (`fw.len`). This length is used in a calculation to determine how many dwords to download (`(fw.len + sizeof(u32) - sizeof(u8)) / sizeof(u32)`). There is no explicit validation that `fw.len` is within safe, platform-specific integer limits before this calculation, which could lead to integer overflow or excessive memory operations. The specification directly addresses this risk.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform a traditional heap/stack memory allocation. However, it writes data into a pre-existing buffer (`self->rpc`). The size parameter derived from `fw.len` influences the amount of data written. While not a direct allocation call, the principle of validating the size parameter against the destination buffer's capacity is relevant, though the connection to \"allocation operations\" is indirect.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code handles a protocol message with a length field and a TID (transaction ID). It ensures consistency by polling until `sw.tid == fw.tid`, which is a form of state synchronization. However, the specification about \"consistent type handling\" is broader (e.g., signed/unsigned, endianness). The code shows some care in type handling (using `u32`), but its primary relevance is in the protocol state consistency check.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The length field `fw.len` originates from firmware/hardware registers, not from userspace. Therefore, this specification regarding \"userspace-provided\" data is not directly applicable. The validation concern is similar but the threat model (trusted vs. untrusted source) is different.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 8,
        "reasoning": "The code is a protocol message handler for variable-length RPC data. It reads a length field (`fw.len`) and uses it to download a variable number of dwords. Before processing the variable-length component, it should verify the structural integrity, primarily by validating that `fw.len` is reasonable and that the subsequent download operation won't exceed buffer boundaries. The lack of such validation is a key security concern this specification targets.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 6,
        "reasoning": "The code operates on a fixed buffer (`self->rpc`). The specification about accounting for worst-case input is relevant because the code should ensure that the calculated download size based on `fw.len` does not exceed the capacity of this fixed buffer. While not about dynamic allocation, the principle of input-size validation against a fixed buffer limit applies.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code writes data into the `self->rpc` buffer via `hw_atl_utils_fw_downld_dwords`. There is no indication that the buffer is fully initialized before this write. However, the specification is about initializing allocated memory *before use* to avoid information leaks. Here, the buffer is being written to, not read from uninitialized, so the specification has very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple error handling paths (via `goto err_exit`). The specification is highly relevant because the function must ensure that on any error exit, the state of relevant objects (like `self->rpc`, `self->rpc_tid`, or the `rpc` output parameter) remains consistent and safe. For example, if an error occurs after partially writing to `self->rpc`, it could leave the object in an inconsistent state.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-37690_after_exclude_100:4ee51824:spec": {
    "timestamp": "2026-01-16T21:25:48.063102",
    "cve_id": "CVE-2021-37690",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4ee51824",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs shape inference for TensorFlow graph nodes, specifically for function sub-nodes (_Arg and _Retval). It does not involve database views, view-based data access, or privilege checks. The specification is about database security and is not applicable to this computational graph processing code.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 3,
        "reasoning": "The code manages shape inference context and handles state transitions between outer and inner contexts. While it maintains consistency in shape propagation, it does not involve security-critical privilege contexts or access control systems. The state management is for computational correctness, not security enforcement.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to SQL protocols, database systems, or view security semantics. It processes TensorFlow graph nodes for shape inference, which is completely unrelated to database query protocols or access control.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 1,
        "reasoning": "The code does not contain any regular expression parsing or pattern matching functionality. It processes node attributes and shape information without using regex patterns or handling NUL bytes in input patterns.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation, escape sequence processing, or lexical analysis. It performs shape inference operations on computational graph nodes without any pattern matching or compiler functionality.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 4,
        "reasoning": "The code processes node attributes and string comparisons (StringPiece comparison with kArgOp/kRetvalOp). While it doesn't directly handle untrusted input strings in a security-critical way, it does work with external node definitions that could potentially be manipulated. However, the string operations are minimal and not the primary security concern.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code manages shape handles and context objects, which involves memory management for shape data structures. It copies shape information between contexts to maintain proper ownership. While not traditional memory allocation, it does involve resource management that must maintain consistency, though not primarily for security against memory corruption attacks.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 6,
        "reasoning": "The code performs resource management operations between inference contexts, copying shape handles and maintaining consistency between outer and inner contexts. It ensures shape information is properly propagated and owned by the correct context. This relates to maintaining invariant consistency in resource management, though the primary focus is on correctness rather than security.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2020-16287_after_exclude_100:2c30c96d:spec": {
    "timestamp": "2026-01-16T21:25:49.416418",
    "cve_id": "CVE-2020-16287",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2c30c96d",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code explicitly includes a bounds check (`if (bx * lprn->nBw + x >= bpl) break;`) to prevent buffer overrun. This is a direct implementation of validating bounds before access, which is the core of HS-MEM-003. The comment even references a specific bug (CVE) that this check avoids, confirming its security relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Buffer access operations must validate bounds against allocated size before access"
      },
      {
        "score": 7,
        "reasoning": "The code deals with a printer device buffer (`ImageBuf`) and carefully calculates offsets using `bpl` (bytes per line) and block dimensions (`nBw`, `nBh`). The bounds check ensures that access does not exceed the logical line length (`bpl`), which helps maintain correspondence between logical block access and the physical buffer layout. This is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-IO-004: Device buffer handling must maintain strict correspondence between logical and physical b..."
      },
      {
        "score": 8,
        "reasoning": "The function validates derived coordinates (specifically the x-offset `bx * lprn->nBw + x`) against the physical buffer constraint `bpl`. This is a direct application of validating derived coordinates against buffer constraints for printer input processing, making it strongly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-005: Printer input processing must validate all derived coordinates against physical buffer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2017-17784_before_exclude_100:aca3d5c6:spec": {
    "timestamp": "2026-01-16T21:25:55.919141",
    "cve_id": "CVE-2017-17784",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "aca3d5c6",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code is a file format parser for GIMP brushes, not a regex parser. While it does process binary data that could contain NUL bytes, the relevance is indirect and weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences. It reads binary brush data. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The specification is highly relevant. The code reads a variable-length brush name from the file (`temp`). It uses `read` with a specific size (`bn_size`), which is a length-aware operation. However, it later converts this buffer to UTF-8 using `gimp_any_to_utf8` with a size of -1, which relies on null-termination. If `temp` is not null-terminated (which it isn't guaranteed to be), this could be a problem, making the specification's guidance crucial.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "The specification is moderately relevant. The code validates header fields like `width`, `height`, and `bytes` against `GIMP_MAX_IMAGE_SIZE` and performs a size calculation check (`G_MAXSIZE / bh.width / bh.height / bh.bytes < 1`) to prevent integer overflow before allocation. This aligns with validating length fields against platform limits, though the fields are not strictly \"protocol message\" fields but file format header fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The specification is highly relevant and directly addressed. The code calculates `size = bh.width * bh.height * bh.bytes` and validates this calculation against `G_MAXSIZE` before calling `g_malloc`. This is a critical security measure to prevent integer overflow and excessive memory allocation. The validation happens before the allocation, matching the specification's requirement.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "The specification is moderately relevant. The code handles different versions (1, 2, 3) and data types (bytes=1, 2, 4, 18) of the brush format. It uses a switch statement and validates the `magic_number` and `header_size` for version 2. This represents a form of consistent type handling across processing stages, though the specification's context of \"protocol implementations\" is broader.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is strongly relevant. The code performs structural validation on the binary file header: it checks magic numbers, version numbers, header sizes, width/height bounds, and byte depth values. It also validates that read operations return the expected number of bytes. This constitutes \"complete structural validation\" of the external input file.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External input processing must enforce complete structural validation including termin..."
      },
      {
        "score": 10,
        "reasoning": "The specification is directly and highly relevant. This code is a file format parser. It strictly validates all header fields (`header_size`, `version`, `width`, `height`, `bytes`, `magic_number`, `spacing`) through range checks, value checks, and consistency checks (e.g., `magic_number == GBRUSH_MAGIC`) before proceeding to read and process the main data payload. This is a textbook example of the specification's requirement.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: File format parsers must strictly validate all header fields before data processing"
      }
    ]
  },
  "CVE-2017-17784_after_exclude_100:3145cc9a:spec": {
    "timestamp": "2026-01-16T21:25:58.673858",
    "cve_id": "CVE-2017-17784",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3145cc9a",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not use regular expressions. It reads binary file headers and data, where NUL bytes are part of the expected data format (e.g., a null-terminated string for the brush name). The code checks for the null terminator in the name field (`temp[bn_size - 1] != '\\0'`), which is related to input validation but not in the context of regex parsing. Relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code is a file loader for GIMP brush files, parsing binary headers and raw pixel data. It does not compile patterns or process escape sequences. The term \"pattern\" appears in a legacy compatibility check for a \"PatternHeader\", but this is a binary structure, not a textual pattern with escape sequences. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The specification is about using length-aware operations for untrusted input. The code reads a file header containing size fields (width, height, bytes) and uses them to calculate a buffer size (`size = bh.width * bh.height * bh.bytes`). It performs a critical validation check (`G_MAXSIZE / bh.width / bh.height / bh.bytes < 1`) to prevent integer overflow before allocation. This is a direct application of length-aware safety for untrusted file input. Strong relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. While this is a file parser, not a network protocol, the principle is identical. The code validates header fields (width, height, bytes) against `GIMP_MAX_IMAGE_SIZE` and performs an integer overflow check using `G_MAXSIZE` before using them to calculate a memory allocation size. This is a direct validation of \"length fields\" from an external source. Moderate to strong relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The specification is about validating size parameters for memory allocation. The code performs a crucial integer overflow check (`G_MAXSIZE / bh.width / bh.height / bh.bytes < 1`) before calculating the `size` for `g_malloc`. This prevents an undersized allocation that could lead to buffer overflow when the subsequent `read` call attempts to fill the buffer. This is a textbook example of the security practice the specification mandates. Highly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "The specification is about consistent type handling in protocols. The code parses a binary file format with different versions. It handles type consistency by validating the `magic_number` and `version` fields, and it converts data (e.g., 16-bit float to 8-bit grayscale) based on the `bh.bytes` field. However, the specification's focus on \"protocol\" and \"all processing stages\" is broader than this single function. The code shows type-aware validation, giving it moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "The specification is about complete structural validation of external input. The code performs extensive validation on the file header: checking for read failures, sanitizing numerical values (width, height, bytes, version, magic_number), validating the calculated name buffer size and its null terminator, and checking the success of data reads. This constitutes a robust structural validation of the external file input. Strong relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External input processing must enforce complete structural validation including termin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about strictly validating all header fields before data processing. The code does exactly this. It reads the `BrushHeader`, performs byte order conversion, and then executes a comprehensive \"Sanitize values\" block that validates `width`, `height`, `bytes`, and checks for integer overflow. Only after this validation does it proceed to allocate memory and read the main brush data. This is a direct and correct implementation of the specification's requirement. Highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: File format parsers must strictly validate all header fields before data processing"
      }
    ]
  },
  "CVE-2021-27212_after_exclude_100:73ddd745:spec": {
    "timestamp": "2026-01-16T21:25:58.788752",
    "cve_id": "CVE-2021-27212",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "73ddd745",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via `slap_sl_malloc` and initializes the `ni.bv_val` buffer in a loop, ensuring it is fully initialized before being assigned to `*is`. However, the `ber_dupbv_x` function's internal behavior is not shown, which could be a risk if it doesn't initialize memory. The direct initialization in the else branch is good.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function returns early with `LDAP_INVALID_SYNTAX` on many error paths, which maintains a consistent error state. However, the `ni` struct is only set on success; on error, the caller's `is` and `tu` parameters might be left partially modified (e.g., `bv_val` pointers advanced but lengths not set), potentially causing inconsistent states.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "This is a network protocol handler (LDAP/GSER parsing) that extensively validates input syntax: checks minimum length, braces, keywords, spaces, quotes, and field formats. It rejects malformed input early, aligning strongly with this specification.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code checks `in->bv_len` against a fixed minimum length but does not validate against platform-specific integer limits (e.g., overflow risks when computing `x.bv_len -= STRLENOF(...)`). The length fields are not integer-typed protocol fields but `ber_len_t` values; however, no explicit bounds checking against `INT_MAX` or similar is performed.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Memory allocation occurs in `slap_sl_malloc(ni.bv_len + 1, ctx)`. `ni.bv_len` is derived from `is->bv_len - numdquotes`, which is bounded by the original input length, but there is no explicit validation against allocation limits (e.g., maximum allowed size). The `+1` could theoretically overflow if `ni.bv_len` is `SIZE_MAX`, but input length checks make this unlikely.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code enforces consistent type handling: it expects a GSER format with specific fields (`issuer`, `thisUpdate`), validates their presence and order, ensures no duplicates, and parses them according to strict syntax rules (quoted strings, date format). All processing stages follow the same parsing logic.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code validates length constraints: minimum overall length, `issuer` field length implicitly via parsing, and `thisUpdate` field length explicitly against `STRLENOF(\"YYYYmmddHHmmssZ\")`. However, it does not enforce maximum length constraints per RFC, only minimums.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Although not TLV (Tag-Length-Value) but GSER, the code performs bounds checking before accessing fields: it checks `x.bv_len` before decrementing, verifies `x.bv_val[0]` before access, and uses `is->bv_len < x.bv_len` in loops. However, some accesses like `is->bv_val[is->bv_len+1]` could exceed bounds if `is->bv_len == x.bv_len`, but the loop condition prevents this.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2021-27212_before_exclude_100:83de7d25:spec": {
    "timestamp": "2026-01-16T21:26:00.633162",
    "cve_id": "CVE-2021-27212",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "83de7d25",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via `slap_sl_malloc` and initializes it in a loop, but the final byte is explicitly set to `'\\0'`. This is good. However, the `ber_dupbv_x` function (not shown) could potentially leave uninitialized memory if it doesn't fully initialize the allocated buffer. Since we must evaluate based on the visible code, the handling of the `ni` buffer after allocation is proper. The score is high because memory initialization is a direct concern in the allocation path.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function has multiple error return paths (LDAP_INVALID_SYNTAX) that maintain a consistent state for the output parameters (`is`, `tu`) by returning early before they are modified. However, the `ni` local variable is only set in the success path at the end. The function's error paths do not leave output parameters in a partially allocated or inconsistent state, showing moderate attention to error state consistency.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "This function is a parser for a GSER (Generic String Encoding Rules) format input, which is a form of network protocol data. It performs extensive validation of the input structure: checking minimum length, braces, keywords, spaces, quotes, and field order. This is a core example of input validation before processing, making it highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code checks that the input length is greater than a minimum constant but does not validate the length field against platform-specific integer limits (like overflow risks when performing arithmetic on `bv_len`). The length is decremented in several places without checking for underflow. The specification is only loosely related as the code does not explicitly handle integer limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code calculates `ni.bv_len = is->bv_len - numdquotes` and uses it for allocation. It validates that `numdquotes <= is->bv_len` implicitly because `numdquotes` is counted from the same buffer and `ni.bv_len` is used as a positive size. However, there is no explicit check against allocation limits (e.g., maximum buffer size) before calling `slap_sl_malloc`. Moderate relevance because size calculation is present but limit checks are absent.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code enforces a strict schema for the GSER format: it expects exactly two fields (\"issuer\" and \"thisUpdate\") in any order, with specific quoting and spacing rules. It uses a state flag (`have`) to ensure both are present and not duplicated. This is a direct example of consistent type/field handling across parsing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification mentions RFC-specified length constraints. The code validates the overall structure length minimally and parses field lengths internally, but there is no explicit enforcement of RFC maximum lengths for the \"issuer\" or \"thisUpdate\" string contents. Weak relevance because general parsing is done, but RFC-specific length limits are not checked.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Although the format is GSER (text-based) not TLV (binary Type-Length-Value), the code performs continuous bounds checking: before each `strncasecmp`, before each array access (`x.bv_val[0]`), and in loop conditions (`x.bv_len`). It ensures `x.bv_len` is positive before decrementing and accessing. This is a text analogue of complete bounds checking before field access, making it highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2018-20020_after_exclude_100:a908594b:spec": {
    "timestamp": "2026-01-16T21:26:11.317088",
    "cve_id": "CVE-2018-20020",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a908594b",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code reads `hdr.nSubrects` from the network and uses it to calculate a buffer size (`hdr.nSubrects * (4 + (BPP / 8))`). It performs a validation check (`hdr.nSubrects > RFB_BUFFER_SIZE / (4 + (BPP / 8))`) to prevent an integer overflow or excessive size that could exceed the buffer. This directly aligns with HS-INPUT-001's requirement to validate protocol message length fields against limits, though the check is against a fixed buffer size rather than a generic platform integer limit.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation; it uses a pre-existing client buffer. However, it validates the size parameter (`hdr.nSubrects`) against the buffer's capacity (`RFB_BUFFER_SIZE`) before reading data into it. This is a form of guarding memory usage against overflow, which is conceptually related to validating size parameters for memory operations, even if not a direct allocation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles network data with potential endianness swapping (`rfbClientSwap32IfLE` on `hdr.nSubrects`). This ensures consistent integer representation. However, it does not show comprehensive type handling across all stages (e.g., the `x, y, w, h` values read from the buffer are treated as unsigned bytes without explicit validation or sign handling), making relevance moderate.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code reads data directly from the network into the `client->buffer` and then parses it. There is no explicit memory allocation and initialization step shown. The buffer is overwritten by `ReadFromRFBServer`, so initialization before use is not the primary concern here. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has early returns (`FALSE`) on read failures, but it does not show complex object state management. The client object's state consistency on error paths is not evident from this snippet. The relevance is weak, as error handling is present but its impact on object state is not detailed.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a network protocol handler (RFB - VNC). It validates the `nSubrects` field from the network input before using it to calculate a read size and to loop. This is a direct application of validating input before processing to prevent buffer overflows and excessive resource consumption.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The function processes an RRE (Rise-and-Run-length Encoding) image rectangle protocol message. It validates a critical header field (`hdr.nSubrects`) against a buffer limit before proceeding to process the sub-rectangle data. This aligns well with validating image format headers, though the check is for buffer safety rather than semantic validity of the image dimensions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec_2, while there is no explicit `malloc`/`calloc`, the act of reading into a fixed-size buffer is guarded by pre-validating the size parameter (`hdr.nSubrects`). This is a direct security measure to prevent buffer overflow. The relevance is strong, though the specification's wording focuses on \"allocation\" which is not literally present.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2022-2580_after_exclude_100:4a232f61:spec": {
    "timestamp": "2026-01-16T21:26:11.597151",
    "cve_id": "CVE-2022-2580",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4a232f61",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes string literals with escape sequences but is not a regular expression parser. It handles embedded NUL bytes indirectly through string termination checks (*p != NUL), but the relevance is moderate as the primary function is string evaluation, not regex parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively processes escape sequences (\\x, \\u, \\U, octal, \\<C-W>, etc.) and must maintain strict boundaries to prevent buffer overflows. The extra variable tracks allocation size, and boundary checks exist (e.g., end >= rettv->vval.v_string + len), but the implementation is complex and error-prone.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code processes potentially untrusted input strings and uses length-aware operations via pointer arithmetic and allocated buffer size (len). However, it relies on NUL termination and calculates length based on input scanning, which could be risky if input boundaries are not strictly enforced.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code processes character encodings via hex/Unicode escape sequences and uses mb_char2bytes for multi-byte encoding. It validates hex digits (vim_isxdigit) but must ensure buffer boundaries are checked before writing to end pointer, especially during multi-byte conversions.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code maintains buffer state through pointers (*arg, p, end) and length calculations. However, the invariants depend on accurate extra length estimation during the initial scan, and errors in estimation could lead to buffer overflows (see the iemsg check).",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code handles encoding-specific processing via mb_char2bytes and MB_COPY_CHAR, but boundary checking is not uniformly enforcedsome paths (e.g., hex escape processing) may write to end without explicit bounds checks beyond the initial allocation.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Memory is allocated via alloc(len) and initialized by writing characters sequentially, with final NUL termination. However, the specification focuses on full initialization, while this code dynamically fills the buffer, leaving no uninitialized gaps if logic is correct.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Error handling paths (e.g., semsg on missing quote) return FAIL, but the code does not always clean up partially allocated memory or reset states. For example, if alloc fails, it returns FAIL without modifying rettv->v_type, potentially leaving inconsistent state.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2018-20020_before_exclude_100:b0a2cd73:spec": {
    "timestamp": "2026-01-16T21:26:14.760290",
    "cve_id": "CVE-2018-20020",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b0a2cd73",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code reads `hdr.nSubrects` from the network and uses it to calculate a buffer size (`hdr.nSubrects * (4 + (BPP / 8))`). This calculation must be validated for integer overflow before being used in the `ReadFromRFBServer` call and loop iteration to prevent buffer overflows or excessive resource consumption. The check present (`hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE`) is a form of length validation but may not cover all platform-specific integer limits (e.g., overflow before the comparison).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. While the code does not perform explicit dynamic memory allocation (it uses a fixed-size `client->buffer`), the principle applies. The size parameter derived from `hdr.nSubrects` is validated against `RFB_BUFFER_SIZE` before the read operation, which guards the fixed buffer. However, the specification focuses on allocation operations, which are not present here.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code handles network data with byte-order swapping (`rfbClientSwap32IfLE`), which is a type consistency measure. However, the specification broadly covers all processing stages, and the code's handling of the `x, y, w, h` fields as `uint8_t` (single bytes) from the network buffer is a critical type handling decision that should be validated against the protocol specification to prevent misinterpretation.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code reads data directly from the network into a buffer (`client->buffer`) and then processes it. There is no explicit memory allocation that needs initialization before use. The buffer is initialized by the `ReadFromRFBServer` call.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function has error return paths (`return FALSE`), but it's unclear what state the `rfbClient` object is left in if an error occurs mid-processing (e.g., after `GotFillRect` is called but before all subrects are processed). The specification is relevant to robust error handling, but the code's simplicity makes the risk less pronounced.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a network protocol handler. It validates the calculated data size against `RFB_BUFFER_SIZE` before reading. However, it should also validate that `rx, ry, rw, rh` and the computed `rx+x, ry+y` coordinates are within expected bounds to prevent out-of-bounds writes in the `GotFillRect` callback. The current validation is insufficient for all inputs.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function parses a CoRRE (RRE) image protocol chunk. It validates the critical header field `nSubrects` by checking the resulting data size against a buffer limit. It should also validate that `w` and `h` from each subrectangle are greater than zero and that `x+w` and `y+h` do not overflow or exceed the declared region (`rw`, `rh`).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. Similar to spec_2, this applies to the pre-validation of the size parameter (`hdr.nSubrects * (4 + (BPP / 8))`) before its use in the `ReadFromRFBServer` call. The code does perform this guard. However, the specification is framed in the context of \"memory allocation,\" whereas this code uses a pre-allocated buffer.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2021-39537_before_exclude_100:019626cb:spec": {
    "timestamp": "2026-01-16T21:26:18.599594",
    "cve_id": "CVE-2021-39537",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "019626cb",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation calls. It uses a `dp` pointer which is presumably managed by `save_string` and `save_char` functions, but the initialization of the memory they write to is not visible in this snippet. Therefore, the relevance is weak and indirect.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 3,
        "reasoning": "The code has no visible error handling paths or object state management. It performs character conversion and output building without any error checks shown. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "This is not a network protocol handler. The function processes a character string for terminfo encoding, not network data. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "The function is a character converter/parser that handles escape sequences (like `\\` and `^`). It does check for the null terminator (`\\0`) in several places (e.g., `case '\\0':`, `c != '\\0'`), which shows some consideration for embedded NULs, though it's not a regular expression parser. Relevance is moderate.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The function's core purpose is to process escape sequences (backslash `\\` and caret `^`) for a pattern compiler (terminfo). It carefully defines boundaries for these sequences, such as incrementing the `sp` pointer and tracking the `len` of the consumed input. This directly aligns with the spec's intent.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The function processes input via a pointer (`sp`) but does not take an explicit length parameter, relying on null-termination. It does increment the pointer carefully within the octal digit parsing loop, which has a risk of overrun if the string is not properly terminated. For untrusted input, this is a concern. The relevance is moderate to strong.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code performs character encoding conversion (via `UChar()` macro) but does not validate the return value of any conversion or the results of `save_string`/`save_char` calls. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 5,
        "reasoning": "The code does not show operations on fixed-size buffers. The `dp` pointer is written to, but the buffer management is hidden inside `save_string` and `save_char`. There is no visible bounds checking here, making the relevance weak and indirect.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      }
    ]
  },
  "CVE-2022-2580_before_exclude_100:5f301891:spec": {
    "timestamp": "2026-01-16T21:26:19.251067",
    "cve_id": "CVE-2022-2580",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f301891",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes string literals with escape sequences but is not a regular expression parser. It handles NUL bytes as string terminators (NUL), not embedded data. The relevance is moderate because it deals with parsing input patterns (string literals) and must correctly handle escape sequences that could produce NUL bytes, but the primary focus is not regex parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively processes escape sequences (\\x, \\u, \\U, octal, \\<, etc.) and must maintain strict boundaries to prevent buffer overflows. The `extra` variable tracks extra space needed, and bounds are checked (e.g., `end >= rettv->vval.v_string + len`). However, the check occurs after potential overflow in `trans_special`, which could be a flaw.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code processes input strings with pointer arithmetic but uses length-aware allocation (`alloc(len)`) and tracks the allocated length (`len`). However, it relies on scanning for delimiters (like `\"`) without explicit length limits, which could be problematic if the input lacks a terminator (though the caller likely ensures NUL-termination).",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code handles character encoding via `mb_char2bytes` and `MB_COPY_CHAR` for multi-byte characters, and validates hex digits (`vim_isxdigit`) before accessing `p[1]`. However, boundary checks are not consistently enforced before every access (e.g., `p[1]` might be checked only after some increments).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code parses input strings and maintains buffer state via pointers (`p`, `end`, `*arg`). It ensures consistency in error paths (e.g., returning `FAIL`). However, the `extra` calculation might mismatch actual needs, and the post-increment check for `end` could be too late.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code includes encoding-specific processing (`mb_char2bytes` for Unicode), but boundary checking is not uniformly applied. For example, `hex2nr(*p)` accesses `*p` after bounds checks via `vim_isxdigit(p[1])`, but other multi-byte operations might not have explicit bounds validation.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Memory allocation (`alloc(len)`) is not explicitly initialized to zero; the code writes data sequentially and null-terminates. However, the allocated memory is fully written before use, so initialization is not a direct security concern. The risk of uninitialized memory exposure is minimal.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Error handling paths (e.g., missing quote, stray '}') return `FAIL` without modifying `rettv` inconsistently. However, if `alloc` fails, `FAIL` is returned but `rettv->v_type` is set to `VAR_STRING` earlier, potentially leaving an inconsistent state if `rettv` was not initialized by the caller.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-39537_after_exclude_100:449bc658:spec": {
    "timestamp": "2026-01-16T21:26:24.590973",
    "cve_id": "CVE-2021-39537",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "449bc658",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not contain explicit memory allocation. It processes characters and writes to a buffer pointer `dp` using `save_string` and `save_char` functions, but the initialization of the allocated memory itself is not visible in this snippet. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has minimal error handling visible (e.g., checking for '\\0'). It does not manage complex object states that need to be rolled back on errors. The functions `save_string` and `save_char` are assumed to handle their own errors. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol handlers. The target function `cvtchar` is a character conversion routine for terminfo, not related to network protocols. It is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This spec is for regular expression parsers. This code is not a regex parser; it's a character converter for terminfo. However, it does process input strings and must handle NUL bytes correctly, which it does via checks like `c != '\\0'`. The relevance is very low due to the domain mismatch.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function's core purpose is processing escape sequences (starting with '\\\\' and '^'). It must maintain strict boundaries to prevent reading beyond the input string (e.g., careful increment of `sp` and checks for '\\0'). A flaw here could lead to out-of-bounds reads.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function processes an input string pointer `sp` without an explicit length parameter, relying on NUL termination. It uses length-aware operations cautiously (e.g., checking for '\\0', not incrementing past it). For untrusted input, this is critical to avoid buffer over-reads. The `while (isdigit(...))` loop could potentially read non-digit characters if not for `isdigit` check, but it still relies on proper termination.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This spec is about encoding conversion operations validating return values. This function performs character conversion/encoding, but it does not call external encoding conversion APIs (like `iconv`). It does validate the state of `sp` implicitly. Relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function writes to an external buffer via `dp`, but the buffer management (fixed-size or dynamic) is hidden inside `save_string`/`save_char`. This function itself does not perform bounds checking on `dp`. The spec only loosely relates as the caller must ensure the buffer is large enough.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      }
    ]
  },
  "CVE-2022-1195_before_exclude_100:d9ef4fdf:spec": {
    "timestamp": "2026-01-16T21:26:25.452378",
    "cve_id": "CVE-2022-1195",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d9ef4fdf",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a kernel-level driver cleanup function (mkiss_close). It does not process userspace-provided array lengths. Its primary operations involve reference counting, synchronization, and resource deallocation, not input validation from userspace.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The function handles the closure and cleanup of a network device and its associated buffers. It does not parse or handle protocol messages with variable-length components. Its operations are related to teardown, not protocol processing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "While the function frees previously allocated buffers (`rbuff`, `xbuff`), it does not perform the allocation itself. The specification is about allocation with size limits, which would be relevant in the buffer creation code (not shown here), not in the cleanup path. The relevance is weak and indirect.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code performs no cryptographic operations. It deals with network device teardown and memory deallocation. This specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 1,
        "reasoning": "Similar to spec 4, this code does not involve any cryptographic implementations or data handling for cryptography. It uses standard kernel memory management functions (`kfree`, `free_netdev`).",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 5,
        "reasoning": "The function uses stack memory only for local pointers (e.g., `struct mkiss *ax`). While it doesn't directly interact with VMAP_STACK, kernel code in general must be aware of stack usage. The weak relevance comes from the general principle that all kernel code should be written with stack constraints in mind, but this specific function is not high-risk in that regard.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The function uses a lock (`disc_data_lock`) to atomically retrieve and clear the `tty->disc_data` pointer, preventing race conditions during the initial phase of cleanup. This is a critical check-and-set operation on a shared resource (the disc_data) under a lock, which aligns directly with the specification's intent for concurrent resource initialization and teardown.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 8,
        "reasoning": "This is strongly relevant. The function manages the shared state of the `mkiss` structure (`ax`). It uses a refcount (`ax->refcnt`) and a completion (`ax->dead`) to ensure all existing users finish before proceeding with destruction. The lock protects the `tty->disc_data` pointer transition. These mechanisms work together to maintain consistency invariants during the state transition from active to closed/freed across all access paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2022-1195_after_exclude_100:f346a2fc:spec": {
    "timestamp": "2026-01-16T21:26:36.036810",
    "cve_id": "CVE-2022-1195",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f346a2fc",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a kernel-level driver close function that manages internal driver state and resources. It does not process userspace-provided array lengths or any direct userspace input. The function deals with internal cleanup after a TTY is closed.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The function is a cleanup routine, not a protocol message handler. It does not parse or process any protocol messages with variable-length components. Its purpose is resource deallocation and state cleanup.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "While the code frees previously allocated buffers (rbuff, xbuff), it does not perform any buffer allocation. The allocation would have occurred elsewhere. The function only handles deallocation during shutdown, so it doesn't directly apply to allocation with size limits.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "The code performs no cryptographic operations. It's a network driver cleanup function that deals with TTY and network device resources, not cryptography.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 1,
        "reasoning": "No cryptographic operations are present in this code. The function handles memory deallocation for network buffers and device structures, but not in a cryptographic context.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses kfree() on kernel buffers, which is generally safe regardless of VMAP_STACK configuration since it's freeing heap memory. However, kernel components should be aware of stack usage patterns, but this specific code doesn't show stack memory handling concerns.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses locking (disc_data_lock) to protect the tty->disc_data pointer during cleanup. It performs atomic operations on shared state (setting tty->disc_data to NULL) under lock protection, which aligns with concurrent resource management principles.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code manages shared state transitions carefully: it uses locking to isolate the disc_data pointer, employs reference counting (refcount_dec_and_test) to ensure no active users remain, and uses completion (wait_for_completion) for synchronization. It maintains consistency invariants during the shutdown sequence.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2021-41204_before_exclude_100:81adf156:spec": {
    "timestamp": "2026-01-16T21:26:37.092007",
    "cve_id": "CVE-2021-41204",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "81adf156",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a constant folding eligibility checker for a computational graph (likely TensorFlow). It does not perform cryptographic operations or handle secret values. Its primary concern is optimization safety, not timing side-channels.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It deals with graph node properties and tensor shapes.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "While the function checks memory size (`max_constant_size_in_bytes`), it is for optimization resource limits, not for ensuring constant-time properties during cryptographic processing. The memory operations referenced are not cryptographic.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process regular expressions or input patterns. It analyzes node attributes in a computational graph.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or the processing of escape sequences. It is a graph analysis function.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function does process input (node properties) and performs validation (e.g., size checks against `max_constant_size_in_bytes`). However, it is not handling string data or using length-aware operations in the sense of the specification, which is about preventing buffer overflows in string functions.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code validates a size parameter (`max_constant_size_in_bytes`) against calculated tensor sizes (`out_shape.num_elements() * DataTypeSize(...)`). This is a form of size validation to prevent creating excessively large constants. However, it does not explicitly check against platform-specific maximums (like `SIZE_MAX`), and the primary goal is optimization control, not security boundary enforcement.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: All size parameters must be validated against platform-specific maximum values before ..."
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The code performs a multiplication (`out_shape.num_elements() * DataTypeSize(...)`) which could potentially overflow if `num_elements()` is large. This is a signed/unsigned conversion edge case relevant to size validation. However, the check is compared against a user-provided limit (`max_constant_size_in_bytes`), not a fundamental input validation boundary, and the security implication is indirect (resource exhaustion rather than memory corruption).",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input size validation must handle both signed/unsigned conversion edge cases"
      }
    ]
  },
  "CVE-2022-1586_before_exclude_100:81845804:spec": {
    "timestamp": "2026-01-16T21:26:40.298938",
    "cve_id": "CVE-2022-1586",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "81845804",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes PCRE2 patterns which could contain embedded NUL bytes in character classes (XCL). The functions like GETCHARINCTEST handle character reading and must properly handle NUL bytes within patterns. Since this is a regex compiler component, proper NUL handling in input patterns is directly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 7,
        "reasoning": "This code compiles character class patterns including escape sequences (through property types like PT_SC, PT_GC). It must maintain strict boundaries when processing Unicode property escapes and character ranges. The boundary validation happens through checks like XCL_END and proper incrementing of the cc pointer.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The code processes input patterns through pointer arithmetic but relies on proper termination markers (XCL_END). While not using traditional string functions, it must ensure it doesn't read beyond pattern boundaries. The relevance is moderate as the code assumes well-formed patterns.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code primarily performs pattern matching logic rather than memory allocation. Any allocations would happen outside this function. Very low relevance as this function doesn't allocate memory itself.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function uses jump lists and backtracking mechanisms. Error conditions could leave the compiler state inconsistent, but the code appears to maintain consistent jump lists through add_jump/set_jumps. Weak relevance as error handling isn't the primary focus.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a regex pattern compiler, not a network protocol handler. The input validation is for pattern syntax, not network data. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code implements a state machine for character class matching with various Unicode property checks. It maintains state through variables like unicode_status and proper transition between different character class types. Moderate relevance as state consistency is important.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: State machine transitions must maintain valid state invariants"
      },
      {
        "score": 9,
        "reasoning": "The code extensively uses array indexing for Unicode character data (ucd_stage1, ucd_stage2, ucd_records). It validates character ranges before using them as indices (e.g., checks against MAX_UTF_CODE_POINT). Strong relevance as index validation is critical for security.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array index operations require validation of all input values"
      }
    ]
  },
  "CVE-2022-29379_before_exclude_100:663392f1:spec": {
    "timestamp": "2026-01-16T21:26:42.518444",
    "cve_id": "CVE-2022-29379",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "663392f1",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It constructs a file path and resolves it with realpath. Embedded NUL bytes in the input strings (dir->start or info->name.start) would be handled by length-aware copying (njs_cpymem), but the primary purpose is not regex processing, making the specification only loosely related.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It performs simple string concatenation for file path construction. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code uses length-aware operations (njs_cpymem) to copy the directory and module name strings, which are potentially untrusted input. It also checks the total length against NJS_MAX_PATH before copying, preventing buffer overflow in the stack-allocated `src` buffer.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages with length fields. It validates the combined path length against a fixed maximum (NJS_MAX_PATH), but this is not related to protocol message parsing or platform-specific integer limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. While the code does not perform dynamic memory allocation (it uses a stack buffer), it does validate the size parameter (`length`) against the buffer size (NJS_MAX_PATH) before usage. This aligns with the spirit of validating size parameters against usage requirements, though not against allocation limits.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 4,
        "reasoning": "The code is not a protocol implementation. It is a utility function for resolving module file paths. Type handling is consistent (using njs_str_t for strings), but the specification's context is not directly applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The stack buffer `src` is initialized in a piecewise fashion via copying and is null-terminated. There is no dynamic memory allocation that needs initialization. The specification's focus on heap allocations is not directly addressed.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function has multiple error return paths (NJS_DECLINED, NJS_ERROR). It must ensure the `info` object state is consistent on these paths. For example, if `realpath` fails, the function returns without touching `info->fd`. However, if `open` fails, `info->path` has already been set by `realpath`. The caller must handle this partial state, which is a relevant error handling consideration.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-41204_after_exclude_100:8f97fba0:spec": {
    "timestamp": "2026-01-16T21:26:42.672301",
    "cve_id": "CVE-2021-41204",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8f97fba0",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a constant folding optimization function in a compiler/execution engine (likely TensorFlow). It determines if a node's computation can be pre-calculated. It does not perform cryptographic operations on secret values. Its focus is on performance optimization, not cryptographic side-channel resistance.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code is unrelated to elliptic curve cryptography or any cryptographic curve model implementations. It is a graph node analysis function for a machine learning framework.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform secure memory operations or cryptographic processing. It checks node properties (statefulness, control flow, data type, shape) to decide if constant folding is safe and efficient.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns containing NUL bytes. It operates on a computational graph structure.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is a predicate function for graph optimization.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code does not directly process strings from untrusted input, it does handle node names and attributes from a graph definition, which could be considered input. However, its primary security concern is not about length-aware string operations but about correctly identifying foldable operations to prevent runtime errors or incorrect optimizations. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code contains a direct and relevant check: it validates the calculated size of a potential constant (num_elements * DataTypeSize) against a maximum size parameter (max_constant_size_in_bytes) before deciding to fold it. This is a form of size validation to prevent creating excessively large constants that could impact memory. It is not explicitly checking against a platform maximum, but against a configurable policy limit, which is moderately relevant.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: All size parameters must be validated against platform-specific maximum values before ..."
      },
      {
        "score": 5,
        "reasoning": "The code performs a size calculation (`out_shape.num_elements() * DataTypeSize(n->output_type(i))`). The variables involved (`num_elements()` likely returns `int64`, `DataTypeSize` likely returns `size_t` or similar, `max_constant_size_in_bytes` is `int64`) are of different signedness. The multiplication and comparison must be done carefully to avoid overflow or signed/unsigned comparison issues, which relates to the specification. The relevance is moderate, as this is a potential edge case in the validation logic itself.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input size validation must handle both signed/unsigned conversion edge cases"
      }
    ]
  },
  "CVE-2022-29379_after_exclude_100:a40cbb37:spec": {
    "timestamp": "2026-01-16T21:26:43.213257",
    "cve_id": "CVE-2022-29379",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a40cbb37",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It constructs a file path and uses realpath() and open(). The specification about embedded NUL bytes in regex patterns is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It handles file path strings, but not in a compiler/escape sequence context as specified.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function uses length-aware operations (njs_cpymem with explicit lengths) for the directory and module name inputs, which could be untrusted. It also checks the total length against NJS_MAX_PATH before copying, preventing buffer overflow in the 'src' array.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages with length fields. It deals with file system paths, not network protocols.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. While there is no dynamic memory allocation in this snippet, the function validates the combined path length against the fixed-size buffer limit (NJS_MAX_PATH) before usage, which is a similar principle of validating size parameters against usage requirements.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 4,
        "reasoning": "The code is not a protocol implementation. It is a utility function for resolving module file paths. Type handling consistency is not a primary concern here.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The local 'src' buffer is written to in a controlled manner and is null-terminated. There is no dynamic allocation that needs initialization. The principle of initialization is followed but is not the core security focus of the code.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function has multiple error return paths (NJS_DECLINED, NJS_ERROR). It must ensure the 'info' object state (fields like fd, path, file) is consistent when errors occur (e.g., realpath or open fails). The current code only sets these fields on the success path, which appears safe, but the specification directly addresses a key concern for this style of function.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-1586_after_exclude_100:b5d4a393:spec": {
    "timestamp": "2026-01-16T21:26:44.847840",
    "cve_id": "CVE-2022-1586",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b5d4a393",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes PCRE2 patterns which can contain embedded NUL bytes in character classes (XCL). The functions like GETCHARINCTEST handle character reading and must properly account for NUL bytes in the pattern stream. This is directly relevant to regex parser input handling.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 7,
        "reasoning": "The code compiles character classes including escape sequences (through property types like PT_SC, PT_GC). It must maintain boundaries when processing these sequences to prevent over-reads, though the primary focus is on Unicode property handling rather than escape sequence parsing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes input patterns via pointer arithmetic (cc++) but relies on sentinel values (XCL_END) rather than explicit length parameters. While not using traditional length-aware functions, it does have boundary checks through the sentinel, providing some protection.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code primarily performs pattern compilation and jump list management without obvious dynamic memory allocations in this segment. Memory initialization concerns would be more relevant in allocator code.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code maintains compiler state and jump lists, but error handling paths aren't prominently visible in this function. Consistency of state during compilation errors would be relevant but not the primary focus.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a regex compilation function, not a network protocol handler. Input validation occurs but for pattern syntax rather than network data.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code implements a stateful compiler with multiple Unicode property checks and conditional jumps. It must maintain valid invariants during character class compilation, especially with the complex Unicode property handling.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: State machine transitions must maintain valid state invariants"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code extensively uses array indexing for Unicode property tables (ucd_stage1, ucd_stage2, ucd_records) and bitmask operations. All indices (like TMP2 for ucd_records access) must be validated to prevent out-of-bounds reads, especially with potentially malicious character values.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array index operations require validation of all input values"
      }
    ]
  },
  "CVE-2019-19069_after_exclude_100:221b5ea5:spec": {
    "timestamp": "2026-01-16T21:26:45.277287",
    "cve_id": "CVE-2019-19069",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "221b5ea5",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process any userspace-provided array lengths. It allocates a fixed-size structure and creates a scatter-gather table from internal buffer data. No user input validation is performed here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The function is not a protocol message handler. It's a DMA buffer attachment callback that works with kernel internal structures, not variable-length protocol components.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code performs a single kzalloc allocation with a fixed size (sizeof(*a)), not based on user input. While buffer allocation is present, it doesn't involve worst-case input scenarios or explicit size limits from untrusted sources.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses mutex_lock/mutex_unlock to protect the shared buffer->attachments list when adding the new attachment node. This protects the shared resource state transition (adding to the list) with proper synchronization.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code maintains consistency between the attachment->priv pointer and the buffer->attachments list. Both track the same resource (the attachment), and the mutex ensures atomic updates to maintain consistency between these tracking structures.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code is not performing filesystem metadata operations. However, it does implement thread-safety for concurrent access to the attachments list using mutex locks, which is conceptually similar to filesystem concurrency patterns.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code has nothing to do with USB request processing. It's a DMA buffer attachment function for a different subsystem (likely related to FastRPC or similar).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is not related to USB/IP protocol implementation. It's a DMA buffer management function in what appears to be a FastRPC driver implementation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2019-19069_before_exclude_100:37675091:spec": {
    "timestamp": "2026-01-16T21:26:56.550362",
    "cve_id": "CVE-2019-19069",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "37675091",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process any userspace-provided array lengths. It allocates a fixed-size internal structure and creates a scatter-gather table from existing buffer data. No user-controlled length inputs are validated here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The function is not a protocol message handler and does not process variable-length protocol components. It's a DMA buffer attachment callback for the DMA-BUF framework.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. While the code performs a kzalloc allocation, it's for a fixed-size internal structure (fastrpc_dma_buf_attachment), not based on user input. The buffer size used for dma_get_sgtable comes from an existing buffer structure, not from an untrusted input scenario.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses mutex_lock/mutex_unlock to protect the shared buffer->attachments list when adding the new attachment node. This protects the shared resource (attachment list) state transition during concurrent access.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code maintains consistency between the attachment's priv pointer and the buffer's attachments list. The attachment is added to the list only after successful initialization, and the priv pointer is set before adding to the list, helping maintain state consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code uses mutex for thread-safety of the attachments list, this is not a filesystem metadata operation. It's a DMA buffer management function in a driver, not a filesystem operation.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code has nothing to do with USB request processing. It's part of a DMA buffer attachment mechanism for a different subsystem (likely related to FastRPC or similar).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is not related to USB/IP protocol implementation. It's a DMA buffer attachment callback function in a kernel driver, unrelated to USB or network protocols.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2016-6207_after_exclude_100:4502dad1:spec": {
    "timestamp": "2026-01-16T21:27:00.631831",
    "cve_id": "CVE-2016-6207",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4502dad1",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code allocates memory but does not initialize it (e.g., the allocated `double` arrays in `ContribRow[u].Weights`). However, HS-MEM-001 is a general principle about preventing information leaks from uninitialized memory. While the code violates this principle, the specification is broadly about initialization before use, not specifically about the security risks shown here (which are more about allocation failures). The relevance is very low because the code's primary security issues are not about uninitialized memory use.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error handling paths (malloc failures, overflow checks). It attempts to maintain consistency by freeing partially allocated structures before returning NULL (e.g., freeing `res->ContribRow[i].Weights` for allocated indices, then freeing `res`). This directly addresses HS-STATE-002's requirement for consistent object states during error recovery.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code performs no network protocol handling or input processing from network sources. It is a pure memory allocation helper function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not involve pattern compilers, escape sequence processing, or lexical analysis.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not perform string processing operations. It deals with memory allocation for numeric weights.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not parse protocol messages or validate length fields from external sources. It operates on function parameters.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant and directly addressed. The code uses `overflow2()` checks to prevent integer overflow before allocation (e.g., `overflow2(line_length, sizeof(ContributionType))` and `overflow2(windows_size, sizeof(double))`). This validates size parameters against allocation limits, which is the core requirement of HS-MEM-002. The checks prevent potential buffer overflows or undersized allocations.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2016-6207_before_exclude_100:3557e3bf:spec": {
    "timestamp": "2026-01-16T21:27:01.641728",
    "cve_id": "CVE-2016-6207",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3557e3bf",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory for `res->ContribRow` and for each `Weights` array but does not initialize the contents of these allocations before returning. This leaves uninitialized memory that could contain sensitive data or cause undefined behavior if used. HS-MEM-001 directly addresses this security issue.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple error handling paths (allocation failures, overflow checks). When an error occurs during the allocation of `Weights` arrays, it properly cleans up previously allocated `Weights` and frees the main structure, maintaining consistent object states. This is a strong example of following HS-STATE-002 principles.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This code performs memory allocation for image processing, not network protocol handling. HS-IO-003 is about network input validation, which is completely unrelated to this function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing at all. It's a memory allocation function for image resizing contributions, making HS-INPUT-001 about regex NUL bytes completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "This specification concerns pattern compilers and escape sequence processing, which has no relation to the memory allocation and image processing code shown. The code doesn't compile or process any patterns.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 2,
        "reasoning": "While the code does process data (allocates arrays based on input parameters), it doesn't use string processing functions. The specification specifically mentions string operations for untrusted input, which doesn't apply here. Weak relevance only because both deal with input parameters.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates size parameters using `overflow2()` checks, which is related to integer overflow prevention. However, HS-INPUT-001 specifically mentions protocol message length fields, while this code deals with image dimensions and window sizes. Some conceptual relevance but different context.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. The code explicitly performs overflow checks using `overflow2()` before allocations (lines 14 and 21), validating that `line_length * sizeof(ContributionType)` and `windows_size * sizeof(double)` don't overflow. This directly implements the security principle of validating size parameters against allocation limits as specified in HS-MEM-002.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2010-0001_before_exclude_100:77239ddb:spec": {
    "timestamp": "2026-01-16T21:27:03.935478",
    "cve_id": "CVE-2010-0001",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "77239ddb",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses several buffers (inbuf, outbuf, tab_prefix, tab_suffix) and performs memory operations like memcpy. While there is some initialization (e.g., tab_suffixof for codes 0-255), the relevance is moderate because the primary security concern is buffer bounds checking rather than full initialization of all allocated memory. The code does not show dynamic memory allocation (like malloc), but static/global arrays are used.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has error handling paths (e.g., read_error(), gzip_error()) that may exit the program. However, it does not clearly show complex object states that need to be maintained consistently across errors. The relevance is moderate because error paths reset or exit, but there's limited state consistency checking (e.g., buffer states after errors).",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a file decompression function (LZW), not a network protocol handler. Input validation occurs (e.g., checking maxbits, corrupt input checks), but it's for file data, not network protocols. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It's an LZW decompression algorithm processing compressed data streams. No relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It's a decompression algorithm. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code processes potentially untrusted input (compressed data) and uses memcpy with calculated lengths. It must ensure bounds checking for inbuf, outbuf, and stack operations. Vulnerabilities like buffer overflows could occur if input validation fails (e.g., code > free_ent checks). The code shows some bounds checks (outpos bounds) but could be vulnerable.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates some input constraints (e.g., maxbits <= BITS, code >= 256 checks), but it's not a network protocol with RFC-specified field lengths. It's a compression format. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code processes variable-length codes (like TLV), but not in a TLV structure. It does bounds checking (e.g., free_ent > maxcode, code > free_ent) and validates before table access, similar to TLV bounds checking. However, it's not a protocol TLV parser.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-21734_before_exclude_100:568e5595:spec": {
    "timestamp": "2026-01-16T21:27:06.660759",
    "cve_id": "CVE-2022-21734",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "568e5595",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs data staging/queue operations (likely TensorFlow) and does not involve any cryptographic operations on secret values. It handles tensors for machine learning workloads, not cryptographic secrets.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or cryptographic operations. It is a data structure operation for tensor storage and retrieval.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No cryptographic processing occurs in this code. Memory operations involve tensor copying but not with constant-time requirements for cryptographic secrets.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code accesses data through a staging map but does not implement view-based security or privilege checks. It's a low-level data structure operation without security context enforcement.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 2,
        "reasoning": "While the code transitions state in a data structure, it doesn't involve security-critical state transitions with privilege contexts. It's a data storage operation without security policy enforcement.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The code has no SQL protocol implementations or database view security semantics. It operates on in-memory tensor data structures.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code performs tensor operations that involve memory allocation, but doesn't explicitly show buffer allocation with padding considerations. There's some memory safety concern with tensor indexing but not the primary focus.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "No image compression operations or encoder buffers are present in this code. It handles general tensor data, not specifically image data or compression.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2022-1508_after_exclude_100:72d278f2:spec": {
    "timestamp": "2026-01-16T21:27:12.433685",
    "cve_id": "CVE-2022-1508",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "72d278f2",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code handles I/O operations with user-provided data via iovec structures. While it doesn't directly parse protocol messages, it does process user-controlled I/O vectors and sizes (like `io_size` from `iov_iter_count(iter)`). The validation of these sizes against system constraints (e.g., via `rw_verify_area`) is relevant but not a direct match for protocol message length validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code uses `io_import_iovec` which likely validates and imports user-provided I/O vectors, checking size parameters. Memory allocation for `iovec` (inline or heap) depends on user input, and validation against limits is crucial to prevent overflow. The `kfree(iovec)` also shows dynamic allocation handling.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "Directly relevant. The code processes userspace-provided I/O vectors (via `io_import_iovec`) which include array lengths (e.g., number of segments, sizes). Validation against system constraints (like maximum I/O size, memory limits) is essential here, and functions like `rw_verify_area` perform some bounds checking.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve pattern compilers, escape sequence processing, or any lexical analysis. It's purely an I/O read implementation for asynchronous I/O.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-1508_before_exclude_100:d6cd235c:spec": {
    "timestamp": "2026-01-16T21:27:12.453301",
    "cve_id": "CVE-2022-1508",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d6cd235c",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code handles I/O operations with user-provided data via iovec structures. While it doesn't explicitly parse protocol message length fields, it does work with `io_size` derived from `iov_iter_count(iter)`. This size is validated against file boundaries via `rw_verify_area`, which provides some length validation against the file's size/platform limits, making it moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses stack-allocated `inline_vecs[UIO_FASTIOV]` and may dynamically allocate via `kfree(iovec)`. However, memory allocation size validation is primarily handled by `io_import_iovec` (not shown), which imports iovecs from userspace. The target code itself doesn't directly perform allocation with size parameters, making relevance weak.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code is part of the io_uring subsystem for asynchronous I/O, not a protocol implementation. It deals with file I/O operations and kernel internal data structures (iovec, kiocb) rather than network protocols or type consistency across protocol stages. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 7,
        "reasoning": "The code processes userspace-provided I/O vectors (iovec arrays) through `io_import_iovec` (called conditionally). This function validates user-provided array lengths against system constraints. The target code handles the results of this validation and manages the iovec memory, giving it moderate to strong relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "This is not a protocol message handler but a kernel I/O routine. While it processes variable-length data through iovec, it doesn't verify structural integrity of protocol components. The integrity checks are more about kernel internal consistency than protocol validation. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "The code uses a fixed-size stack buffer `inline_vecs[UIO_FASTIOV]` for common cases and falls back to dynamic allocation. It doesn't explicitly account for worst-case input scenarios with explicit size limits; that responsibility lies with `io_import_iovec`. Weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "The code performs file I/O operations, not regular expression parsing. There's no pattern matching or handling of embedded NUL bytes in input patterns. Not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code doesn't involve pattern compilers, escape sequence processing, or any text/pattern compilation. It's a low-level I/O read function in the kernel. Not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-1276_before_exclude_100:83cb6276:spec": {
    "timestamp": "2026-01-16T21:27:12.528469",
    "cve_id": "CVE-2022-1276",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "83cb6276",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a code generator/compiler function that handles variable assignments. While it may allocate memory internally (e.g., for symbols or bytecode), the code shown does not directly perform memory allocations that would require initialization before use. The relevance is weak as the specification focuses on memory safety for allocated buffers, which is not the primary concern in this AST processing code.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function includes error handling through codegen_error() calls for invalid assignment targets (NODE_NVAR, unknown lhs). However, it's unclear if object states remain consistent after these errors since the function may partially execute before encountering errors. The moderate relevance comes from the presence of error paths that need to ensure consistent state.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "No network protocol handling is present in this code. The function processes abstract syntax trees for a programming language compiler/interpreter, not network data.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain regular expression parsing functionality. It handles language constructs like variables, constants, and method calls for code generation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "No pattern compilation or escape sequence processing is evident in this code. The function deals with AST node types and generates corresponding bytecode operations.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes symbolic names (nsym(tree)), there's no evidence of string processing of untrusted input in the shown function. The weak relevance comes from potential symbol/string handling elsewhere in the codebase, but not directly in this function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "This is not a protocol parser. The code processes programming language syntax trees, not network packets with field boundaries.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate field boundaries before accessing any packet data"
      },
      {
        "score": 1,
        "reasoning": "No network protocol implementation or message boundary awareness is present in this compiler code generation function.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must maintain strict message boundary awareness du..."
      }
    ]
  },
  "CVE-2022-21734_after_exclude_100:9ef5feba:spec": {
    "timestamp": "2026-01-16T21:27:13.836579",
    "cve_id": "CVE-2022-21734",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9ef5feba",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs data staging/queue operations (likely TensorFlow) and does not involve any cryptographic operations on secret values. It handles tensors for machine learning, not cryptographic secrets.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or any cryptographic operations. It is unrelated to curve models or side-channel resistance.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs basic tensor copying and storage in a map. It does not involve secure memory operations for cryptographic processing or require constant-time properties for such operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 2,
        "reasoning": "The code accesses input tensors and stores them in a staging map. While it involves data access, there is no indication of view-based access control, privilege checks, or database view semantics. It's a low-level tensor operation.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 2,
        "reasoning": "The code performs a state transition by putting data into a staging map, but this is not a security-critical state transition involving privilege context. It's a data structure update in a computational graph.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code has no SQL protocol implementations, database operations, or view security semantics. It is a tensor operation in a machine learning framework.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 3,
        "reasoning": "The code copies a tensor and stores it in a map. While buffer allocation occurs (tensor storage), there's no explicit handling of operational padding requirements or safety margins. The relevance is very weak as this is generic memory management, not security-critical padding.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve image compression operations, encoder buffers, or bounds checking for such operations. It handles general tensor data, not image-specific processing.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2010-0001_after_exclude_100:c2c5ca16:spec": {
    "timestamp": "2026-01-16T21:27:20.200634",
    "cve_id": "CVE-2010-0001",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c2c5ca16",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses stack and buffer operations (e.g., memcpy, array accesses) but does not explicitly show dynamic memory allocation via malloc/calloc. However, it does manipulate buffers (inbuf, outbuf, de_stack) and table arrays (tab_prefix, tab_suffix). While these may be statically allocated or allocated elsewhere, the initialization of tab_suffixof(code) in a loop and buffer shifting show careful initialization practices. The relevance is moderate because the specification about initialization before use is generally applicable to safe buffer handling, but the code does not demonstrate classic heap allocation issues.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The code contains error handling for corrupt input (gzip_error calls) and read errors (read_error). However, after an error like \"corrupt input,\" the function may exit via gzip_error (which likely terminates or longjmps), not returning to a consistent state. The specification about maintaining consistent object states on error paths is moderately relevant because the code has error paths but does not clearly show resource cleanup or state reset before error exit.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "This code is a LZW decompression routine for file processing, not a network protocol handler. It reads from a file descriptor, but the validation is for compressed data format, not network protocol messages. The specification is about network protocol handlers, so relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It decompresses LZW data, handling bit streams and code tables. Embedded NUL bytes in input patterns are not relevant here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It handles LZW codes and bitwise operations, not lexical analysis of escape sequences.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses memcpy with calculated lengths (i) and checks buffer boundaries (e.g., outpos+(i) >= OUTBUFSIZ). It reads input via read_buffer and processes bounded insize. This is relevant to length-aware operations for potentially untrusted input (compressed data), though it's not specifically about string functions like strcpy. The buffer management guards against overflows, making this strongly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates maxbits against BITS to prevent handling unsupported bit lengths, and checks code values (e.g., code >= 256). However, this is not RFC-specific message field validation; it's decompression algorithm validation. The specification about RFC length constraints is loosely related because the code enforces some constraints but not for network protocols.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code does not process TLV (Type-Length-Value) structures. However, it does bounds checking: for example, checking code > free_ent for KwKwK string, ensuring insize bounds, and preventing outbuf overflow. This is analogous to bounds checking before access, but not in a TLV context. Relevance is weak.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-1276_after_exclude_100:2d35ef58:spec": {
    "timestamp": "2026-01-16T21:27:21.581486",
    "cve_id": "CVE-2022-1276",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2d35ef58",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a code generator/compiler function handling variable assignments. While it may involve memory for code generation structures, there is no explicit memory allocation or initialization visible in this snippet. The primary operations are AST traversal and bytecode generation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function includes error handling through `codegen_error()` calls for invalid assignment targets (numbered parameters, unknown lhs). However, the code doesn't show complex object state management that needs consistency after errors. The relevance is moderate as error paths exist but aren't the primary focus.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a compiler code generation function, not a network protocol handler. There's no network input processing or protocol handling in this code.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This code doesn't process regular expressions or handle input patterns with NUL bytes. It's a code generator working with AST nodes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't compile patterns or process escape sequences. It generates bytecode for variable assignments in a programming language.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes symbolic names (via `nsym()`), it doesn't appear to handle untrusted string input directly. The primary operations are on internal AST structures, not external string data.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This is not a protocol parser and doesn't process packet data with fields. It's a compiler code generation function.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate field boundaries before accessing any packet data"
      },
      {
        "score": 5,
        "reasoning": "The code has no network protocol implementation or message boundary handling. It's purely a compiler function for generating assignment bytecode.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must maintain strict message boundary awareness du..."
      }
    ]
  },
  "CVE-2021-41203_before_exclude_100:5e0e47fd:spec": {
    "timestamp": "2026-01-16T21:27:23.831315",
    "cve_id": "CVE-2021-41203",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5e0e47fd",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It reads tensor data from a storage system (likely SSTables) and parses protocol buffers, but does not process regex patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It deals with tensor slice data retrieval and protobuf parsing, not pattern matching engines.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code processes string data from storage (value variable) and parses it as a protocol buffer. While ParseProtoUnlimited likely handles length internally, the code reads from external storage where input could be untrusted, making length-aware operations relevant for security.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code doesn't show explicit fixed buffer operations. Data copying happens in CopyDataFromTensorSliceToTensorSlice, but buffer management details aren't visible. The main security concern would be in the called functions rather than this visible code.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code reads serialized protobuf data from storage and parses it with ParseProtoUnlimited. Input size validation before parsing is important to prevent resource exhaustion or buffer overflows, though the \"Unlimited\" in the function name suggests it might handle arbitrary sizes.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Archive format implementations must validate all size fields against both logical cons..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code deals with tensor data storage in SSTables, not ZIP file processing. There's no compression involved or consistency checking between compressed/uncompressed sizes.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: ZIP format processors must enforce consistency between compressed and uncompressed ..."
      }
    ]
  },
  "CVE-2021-41203_after_exclude_100:cce674a4:spec": {
    "timestamp": "2026-01-16T21:27:27.851699",
    "cve_id": "CVE-2021-41203",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cce674a4",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It deals with reading tensor slices from storage, parsing protocol buffers, and copying data. The specification about embedded NUL bytes in regex patterns is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It focuses on data retrieval and protocol buffer parsing, making this specification about pattern compilers largely irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code uses string operations (e.g., `key` computation, `value` reading) and parses protocol buffers from untrusted storage. While it uses `ParseProtoUnlimited` which handles size, other string operations could benefit from length-aware practices, though the direct risk is mitigated by the structured data flow.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not explicitly use fixed buffers; it works with `std::string` and vectors. However, the `CopyDataFromTensorSliceToTensorSlice` function (not shown) might involve bounds checking, but this is not visible in the provided snippet.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code parses protocol buffers (`ParseProtoUnlimited`) and validates tensor data size against expected elements. This directly relates to input size validation before processing, though `ParseProtoUnlimited` itself may handle size limits internally.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates structural constraints (e.g., tensor shape consistency, data size matching) which is analogous to configuration parsing validation. However, it's specifically for tensor data rather than general configuration.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code reads from a storage format (likely a checkpoint format) and validates size fields (tensor data size vs. expected elements). This parallels archive format validation, though not explicitly for archives.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Archive format implementations must validate all size fields against both logical cons..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not process ZIP files or compressed entries. It deals with tensor slices in a custom storage format, making this specification about ZIP format processors not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: ZIP format processors must enforce consistency between compressed and uncompressed ..."
      }
    ]
  },
  "CVE-2022-2845_after_exclude_100:7cad33e3:spec": {
    "timestamp": "2026-01-16T21:27:39.717258",
    "cve_id": "CVE-2022-2845",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7cad33e3",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It is a display function for a text editor that handles cursor positioning and character rendering. Embedded NUL bytes are not relevant to its operation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It handles multi-byte character display but does not involve pattern compilation logic.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "This is a local display function for a text editor UI. It does not handle network protocols or validate network input.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol messages or length fields. It deals with column positions which are validated against zero but not against platform integer limits in a security-critical way.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "The code does not perform memory allocation. It uses existing buffers and cursor positions, so allocation size validation is not relevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-2845_before_exclude_100:74f179c6:spec": {
    "timestamp": "2026-01-16T21:27:41.786502",
    "cve_id": "CVE-2022-2845",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "74f179c6",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing. It is a display function for a text editor that handles cursor positioning and character rendering. The specification about embedded NUL bytes in regex patterns is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile or process patterns with escape sequences. It handles multi-byte character display and cursor column adjustment. The specification is not relevant to the code's functionality.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses multi-byte character handling (`mb_head_off`) which involves string processing. While the input (text lines) may not be \"untrusted\" in a network security sense, using length-aware operations for multi-byte strings is a secure coding practice to prevent misalignment or buffer over-reads. The code appears to use proper bounds checking via the provided function.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not perform explicit memory allocation. It manipulates cursor positions and displays a character. Memory initialization is not a primary concern for this display logic.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The function saves and restores the cursor column state (`save_col`), which is a form of maintaining consistent state. If an error occurred mid-function (though none are shown), the cursor state would be restored, preventing inconsistency. However, the function lacks explicit error handling paths.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is a user interface display function for a text editor, not a network protocol handler. Input validation for network data is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is about validating network protocol message length fields. The target code does not process network messages or any explicit length fields.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not contain memory allocation operations. It works with existing buffers (lines of text) and cursor positions. Validation of size parameters for allocation is not performed here.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2020-11038_before_exclude_100:fb77763e:spec": {
    "timestamp": "2026-01-16T21:27:42.536940",
    "cve_id": "CVE-2020-11038",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fb77763e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `calloc` which initializes memory to zero, satisfying the requirement to initialize memory before use. This is a direct and correct application of the specification, preventing use of uninitialized memory. However, the code does not subsequently initialize all fields of the allocated structure (some are set later), but `calloc` provides a safe baseline.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code implements a complex error handling path with multiple `goto` labels. It carefully frees resources that were already allocated before the error occurred (e.g., `h264`, `currentSample`, `surfaceData`, `surface`, `yuv`), maintaining consistent state and preventing resource leaks. This is a textbook example of clean error state management.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The function is a constructor for a presentation context, primarily handling memory allocation and initialization. It does not process network protocol input directly. Any network protocol handling would occur elsewhere in the codebase.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "Not applicable. The function does not parse or validate any protocol message length fields. Its parameters are simple integers (x, y, width, height, PresentationId) passed directly, not extracted from a network packet.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs a critical memory size calculation `width * height * 4` for `surfaceData` allocation. It does not explicitly validate this multiplication for integer overflow before passing it to `BufferPool_Take`. This is a potential security issue that the specification directly addresses. The allocation size for `Stream_New` is a fixed 4096, which is less concerning.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function creates and initializes local decoder contexts (H.264, YUV) and a surface. It does not implement protocol parsing where type consistency (e.g., endianness, signed/unsigned) across stages would be a concern.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The key mathematical operation `width * height * 4` is performed. The code does not validate that `width` and `height` are positive, non-zero, or within reasonable bounds to prevent overflow or excessive memory allocation. This is an input range validation issue covered by the specification.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The function does not process any codebooks (e.g., Huffman tables, quantization matrices). It creates video decoding contexts, but no structural validation of codebook data is present in this snippet.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      }
    ]
  },
  "CVE-2020-11038_after_exclude_100:62af2485:spec": {
    "timestamp": "2026-01-16T21:27:42.678663",
    "cve_id": "CVE-2020-11038",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "62af2485",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `calloc` which initializes memory to zero, satisfying HS-MEM-001. However, the allocated `PresentationContext` structure contains pointers to other resources (h264, currentSample, surfaceData, surface, yuv) which are initialized later. If initialization of any of these sub-resources fails, the cleanup path frees the main structure but the partial initialization state is properly handled. The use of `calloc` is good practice, making this specification highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code demonstrates strong error handling with consistent object states. It uses a goto-based cleanup pattern that properly releases resources in reverse order of acquisition when failures occur. Each error path maintains consistency by freeing only resources that were successfully allocated up to that point. This directly aligns with HS-STATE-002 requirements.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "HS-IO-003 focuses on network protocol handlers validating input before processing. This code appears to be part of a video presentation context initialization, not a network protocol handler. While it does process width/height parameters, this isn't network protocol validation in the sense intended by this specification.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "HS-INPUT-001 addresses validation of protocol message length fields against integer limits. The code validates that `s = width * height * 4ULL` doesn't exceed INT32_MAX, which is a form of integer limit validation, but this is for buffer allocation rather than protocol message parsing. The relevance is weak as this isn't strictly about protocol message length fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code directly applies HS-MEM-002 by validating the size parameter before allocation. It checks if `s = width * height * 4ULL` exceeds INT32_MAX before calling BufferPool_Take. This prevents integer overflow and ensures the size is within acceptable limits for subsequent usage, making this specification highly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 4,
        "reasoning": "HS-PROTOCOL-003 focuses on consistent type handling across protocol processing stages. While the code uses consistent types (UINT32 for dimensions, size_t/INT32_MAX for validation), this is more about memory allocation safety than protocol type consistency. The relevance is weak as this isn't primarily protocol processing code.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 9,
        "reasoning": "The code explicitly handles edge cases in mathematical computations. It validates that `width * height * 4ULL` doesn't overflow or exceed INT32_MAX before using the result. This directly addresses HS-LOGIC-001 by validating input ranges and handling potential overflow scenarios explicitly.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 1,
        "reasoning": "HS-INPUT-002 addresses codebook processing and structural constraint validation. This code doesn't involve codebooks, lookup tables, or similar structures that would require structural constraint validation. The specification has virtually no relevance to this video presentation context initialization code.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      }
    ]
  },
  "CVE-2021-3968_after_exclude_100:8c0527b1:spec": {
    "timestamp": "2026-01-16T21:27:48.449637",
    "cve_id": "CVE-2021-3968",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8c0527b1",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It handles visual mode activation in an editor context.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It manages visual mode state and cursor positioning.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 2,
        "reasoning": "While the code does some string/character processing (gchar_cursor()), it's not handling untrusted input in a security-sensitive context. The operations are internal editor state manipulations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code initializes state variables (VIsual_mode, VIsual_active, etc.) but doesn't perform dynamic memory allocation that needs initialization. Some relevance to state initialization but not to memory allocation security.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code manages editor state transitions (visual mode activation) and includes conditional logic that could affect state consistency. However, it's not typical error handling paths but normal operational paths.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve network protocol handling or input validation from external sources. It's purely internal editor functionality.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not process protocol messages or validate length fields. It handles visual mode activation in an editor.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "The code doesn't perform memory allocation operations. It works with existing structures and state variables, not dynamic memory allocation with size parameters.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-41072_after_exclude_100:2bc5ea2c:spec": {
    "timestamp": "2026-01-16T21:27:51.136582",
    "cve_id": "CVE-2021-41072",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2bc5ea2c",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs arithmetic operations (e.g., `bytes += sizeof(*dire)`, `bytes += dire->size + 1`) within a loop that compares `bytes` against `size`. While there is a check `if(dire->size >= SQUASHFS_NAME_LEN)` to prevent overflow in name buffer access, the addition `bytes += dire->size + 1` could theoretically overflow the `int bytes` variable if `dire->size` is very large, though the prior check limits this risk. The relevance is moderate because the code has some boundary validation but not comprehensive type boundary validation before all arithmetic.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code is a filesystem parser (SquashFS) that validates structural fields like `dir_count` against `SQUASHFS_DIR_COUNT`, `dire->size` against `SQUASHFS_NAME_LEN`, and uses `check_name()` for invalid characters. It also validates directory sorting/duplicates via `check_directory()`. This directly aligns with validating structural fields against physical/logical constraints.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs bounds checking for on-disk structures: it checks `dir_count > SQUASHFS_DIR_COUNT`, `dire->size >= SQUASHFS_NAME_LEN`, and ensures `dire->name` is read with `dire->size + 1` bytes. The buffer `buffer` is sized to hold `SQUASHFS_NAME_LEN + 1` characters, and the null-termination `dire->name[dire->size + 1] = '\\0'` is safe due to the prior size check.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code initializes the `dir` struct fields after `malloc`, and `ent` fields are set before use. However, `buffer` is declared but not explicitly initializedit is filled via `read_directory_data` calls. The specification about full initialization before use is only partially addressed; the buffer relies on reads to populate it, which is typical but not a strict initialization guarantee.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code has a `corrupted:` error handling path that calls `squashfs_closedir(dir)` and returns `NULL`. This maintains consistent state by cleaning up allocated memory (`dir` and its internal `dir_ent` list) on error. However, if `squashfs_closedir` fails to handle partially allocated lists, there could be issues, but the pattern shows intent for consistent state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Specification HS-IO-003 is about network protocol handlers, but this code is a filesystem parser, not a network protocol handler. While both involve input validation, the context is entirely different, making the specification not directly applicable.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The buffer is declared with `__attribute__((aligned))`, ensuring platform alignment requirements are respected for structures read from disk. This is important for safe access to `struct squashfs_dir_header` and `struct squashfs_dir_entry` when casting the buffer pointer.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. This specification is for network protocol implementations, while the code is a filesystem parser. Although both involve validating message/structure integrity, the domain (filesystem vs. network) differs significantly, reducing direct relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      }
    ]
  },
  "CVE-2021-3968_before_exclude_100:f29999ed:spec": {
    "timestamp": "2026-01-16T21:27:54.440442",
    "cve_id": "CVE-2021-3968",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f29999ed",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It handles visual mode activation in a text editor, dealing with cursor positions, visual selection states, and redraw logic.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It is focused on UI state management for visual mode selection in an editor.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the code may process strings elsewhere in the codebase, this specific function does not contain string processing operations on untrusted input. It primarily manipulates editor state variables and cursor positions.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The function does not perform explicit memory allocation. It works with existing structures and state variables that are presumably initialized elsewhere in the editor's lifecycle.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function manages state transitions (visual mode activation) and includes conditional logic that could affect consistency. While not classic error handling, state management during mode changes is important for preventing inconsistent UI states.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "No network protocol handling is present in this code. The function is purely for local editor UI state management.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not process protocol messages or validate length fields. It deals with editor cursor positions and visual mode state.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "The function does not perform memory allocation operations. It works with existing window and visual mode structures.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-41072_before_exclude_100:5c5d3f13:spec": {
    "timestamp": "2026-01-16T21:27:54.726164",
    "cve_id": "CVE-2021-41072",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5c5d3f13",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs arithmetic operations like `bytes += sizeof(*dire)` and `bytes += dire->size + 1` within a loop bounded by `size`. While `size` is derived from inode data (`(*i)->data + bytes - 3`), there is no explicit validation that these additions won't cause integer overflow before checking `while(bytes < size)`. The check `if(dir_count > SQUASHFS_DIR_COUNT)` provides some boundary validation, but the arithmetic for `bytes` accumulation lacks overflow checks, making it moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code is a filesystem parser that validates structural fields like `dirh.count` against `SQUASHFS_DIR_COUNT`, `dire->size` against `SQUASHFS_NAME_LEN`, and uses `check_name()` for invalid characters. It also validates that the directory is not empty (`if ((*i)->data == 3)`). These are direct applications of validating structural fields against physical constraints.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs strict bounds checking for on-disk structures: it validates `dir_count` against `SQUASHFS_DIR_COUNT`, `dire->size` against `SQUASHFS_NAME_LEN`, and ensures read operations stay within bounds via `read_directory_data`. This directly aligns with enforcing bounds checking for filesystem structures.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code initializes the `dir` struct fields after malloc, and `buffer` is declared with alignment attribute. However, `dire->name[dire->size + 1] = '\\0'` assumes the read data fits, which is validated earlier. There's no explicit memset of allocated memory, but fields are set individually. The alignment attribute for `buffer` addresses platform alignment, which is more relevant to spec 7.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The error handling path labeled `corrupted:` calls `squashfs_closedir(dir)` to clean up resources and returns NULL, maintaining consistent state. However, if `dir->dirs` was partially populated before an error, `squashfs_closedir` must handle partial lists. The pattern shows attention to error state consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code declares `buffer` with `__attribute__((aligned))`, ensuring proper alignment for `struct squashfs_dir_entry`. This is a direct application of respecting platform alignment requirements for memory operations, especially when casting the buffer to a structure pointer.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      }
    ]
  },
  "CVE-2022-3077_before_exclude_100:194236c8:spec": {
    "timestamp": "2026-01-16T21:27:59.150163",
    "cve_id": "CVE-2022-3077",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "194236c8",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes SMBus protocol messages where `data->block[0]` contains a user-provided length field. It validates this length against `I2C_SMBUS_BLOCK_MAX` in the `I2C_SMBUS_I2C_BLOCK_DATA` case, ensuring it does not exceed the maximum allowed size. However, this validation is specific to one transaction type and occurs after the length field is used in other cases (e.g., `I2C_SMBUS_BLOCK_DATA`). The validation is directly relevant to the specification but is inconsistently applied across all protocol message types.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code uses a pre-allocated DMA buffer (`priv->buffer`) and calculates `dma_size` based on user input (`data->block[0]`). While it validates the size against `I2C_SMBUS_BLOCK_MAX` in some cases, it does not explicitly validate that `dma_size` fits within the statically allocated `priv->buffer` before performing operations like `memcpy`. This relates to validating size parameters against allocation limits, though the buffer is fixed-size, not dynamically allocated.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "The code handles multiple SMBus transaction types (`size` parameter) and uses a `switch` statement to process each. It ensures consistent handling of fields like `read_write`, `command`, and `data` within each case. However, there is potential for inconsistency in descriptor field setup across different branches. The specification is moderately relevant as the code implements a protocol with type-specific processing.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 10,
        "reasoning": "The code explicitly initializes memory before use: it calls `memset(priv->buffer, 0, sizeof(priv->buffer))` to clear the DMA buffer and `memset(desc, 0, sizeof(struct ismt_desc))` to clear the descriptor. This prevents information leakage and ensures predictable state, directly aligning with the specification.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has several error paths (e.g., DMA mapping failure, timeout). In these cases, it returns an error code but may not fully clean up or restore consistent state (e.g., the `priv->head` pointer is updated only at the end on success, but error paths might leave state partially updated). The specification is relevant as error handling could affect object state consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "While the code processes I2C/SMBus protocol inputs, it is not a network protocol handler. It does validate some input parameters (e.g., transaction type, length fields) but not comprehensively. The specification is loosely related because the code handles a communication protocol, but it is not network-based.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "The code uses a ring buffer of descriptors (`priv->hw`) and updates `priv->head` after processing. However, there is no explicit atomic protection (e.g., locks) shown for this shared resource update, which could be a concern in a multi-threaded context. The specification is only slightly relevant as the code may assume single-threaded access or rely on higher-level synchronization.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 4,
        "reasoning": "The code manages descriptor ring state (`priv->head`) and DMA buffer mapping (`dma_addr`). It ensures consistency by unmapping DMA only if mapping was successful and updating the head pointer after completion. However, the specification focuses on strict consistency between different tracking structures, which is not a primary concern here. Relevance is weak.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-3077_after_exclude_100:8248ae0f:spec": {
    "timestamp": "2026-01-16T21:28:03.084293",
    "cve_id": "CVE-2022-3077",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8248ae0f",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates protocol message length fields (like `data->block[0]`) against `I2C_SMBUS_BLOCK_MAX` in multiple switch cases (e.g., `I2C_SMBUS_BLOCK_PROC_CALL`, `I2C_SMBUS_I2C_BLOCK_DATA`). This directly addresses integer limit validation for platform-specific constraints, though the validation is not exhaustive for all possible integer overflow scenarios (e.g., `dma_size` calculations).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code uses a fixed-size buffer (`priv->buffer`) and calculates `dma_size` from user-controlled input (`data->block[0]`). While it validates against `I2C_SMBUS_BLOCK_MAX`, it does not explicitly check if `dma_size` exceeds the allocated buffer size (`sizeof(priv->buffer)`). This relates to validating size parameters against allocation limits, but the buffer is statically allocated, not dynamically.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code handles multiple SMBus transaction types with consistent descriptor initialization and DMA direction settings. However, type handling (e.g., `read_write` enum, `size` parameter) is enforced through switch-case, but there is no validation that input types match expected ranges beyond the default case. Some fields like `desc->tgtaddr_rw` are modified conditionally, which could lead to inconsistency.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 10,
        "reasoning": "The code explicitly initializes memory before use: `memset(priv->buffer, 0, sizeof(priv->buffer))`, `memset(desc, 0, sizeof(struct ismt_desc))`, and `memset(priv->log, 0, ...)`. This ensures no uninitialized data is used, directly complying with the specification.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Error handling paths (e.g., `dma_mapping_error`, timeout) clean up DMA mappings and return errors, but the function updates `priv->head` in all paths (including errors) via the `out` label. This may leave the hardware descriptor ring in an inconsistent state if the descriptor was submitted but failed. The specification about maintaining consistent object states is partially relevant.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 6,
        "reasoning": "The code validates some input parameters (e.g., `data->block[0]` length) before processing, but it is for an I2C/SMBus protocol handler, not a network protocol. The principle of input validation applies, but the specification is network-specific. The validation is present but not exhaustive (e.g., `addr` parameter not validated).",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "The code uses a ring buffer (`priv->hw`) with `priv->head` index, but there is no atomic protection for updating `priv->head` or checking ring state. Concurrent access could cause race conditions. However, the specification about shared resource state transitions is only weakly relevant as the function likely runs in a non-reentrant context (I2C adapter).",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 4,
        "reasoning": "The code manages DMA resources (`dma_addr`) and descriptor ring state (`priv->head`). Consistency is maintained by unmapping DMA in all paths, but the descriptor ring pointer (`priv->head`) is always incremented even on error, which could lead to inconsistency between the hardware ring and software index. The specification about strict consistency between tracking structures is partially relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2021-3905_after_exclude_100:6f93bee1:spec": {
    "timestamp": "2026-01-16T21:28:10.327721",
    "cve_id": "CVE-2021-3905",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6f93bee1",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes IP fragments but does not explicitly validate protocol message length fields (like IP header length or fragment offset) against integer limits. The validation for valid fragments (`ipf_is_valid_v4_frag`/`ipf_is_valid_v6_frag`) may include some checks, but the direct relevance to platform-specific integer limits is weak and not visible in this snippet.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not contain any explicit memory allocation operations. It processes packet batches and may delete packets, but memory allocation validation is not directly relevant here.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "The code handles both IPv4 and IPv6 fragments, enforcing type handling through separate checks (`dl_type == htons(ETH_TYPE_IP)` vs `ETH_TYPE_IPV6`). This shows consistent type handling across processing stages, giving it moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code deals with IP fragment processing, which involves RFC-specified constraints (like fragment offset, length). The validation functions (`ipf_is_valid_v4_frag`/`ipf_is_valid_v6_frag`) likely enforce some RFC rules, but the code snippet itself does not show explicit length constraint validation, making relevance weak.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "While not directly processing TLVs, IP fragment reassembly involves bounds checking for fragment data and offsets. The `ipf_handle_frag` function likely performs bounds checking, but the relevance to TLV-specific processing is only loose.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 6,
        "reasoning": "As part of IP fragment processing, the code should validate field lengths (like IP header length, fragment data length) before accessing data. The validation functions may perform these checks, giving moderate relevance, though not explicitly shown.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 1,
        "reasoning": "The code is for IP fragment reassembly, not BGP protocol processing. BGP capability validation is completely unrelated to this code.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 7,
        "reasoning": "The code performs packet dissection (extracting fragments from batches) and involves fragment handling. Maintaining strict bounds checking during parsing is crucial for IP fragment reassembly to prevent overflows. The lock and validation functions suggest bounds checking is part of the process, giving strong moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      }
    ]
  },
  "CVE-2021-28972_before_exclude_100:8e9c488c:spec": {
    "timestamp": "2026-01-16T21:28:11.770998",
    "cve_id": "CVE-2021-28972",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8e9c488c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expression parsing. It copies a string from a buffer and null-terminates it, but the core issue is not about embedded NULs in patterns.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code performs simple string copying and manipulation, with no pattern compilation or escape sequence processing involved.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code uses `memcpy` with a length (`nbytes`) which is a length-aware operation. However, the relevance is slightly reduced because the code has a critical flaw: it uses `memcpy` *before* checking if `nbytes >= MAX_DRC_NAME_LEN`. The correct, secure pattern is to validate the length first, then use the length-aware copy. The specification's principle directly applies to fixing this code.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 10,
        "reasoning": "Directly and highly relevant. The code validates a userspace-provided length (`nbytes`) against a system constraint (`MAX_DRC_NAME_LEN`). This is the exact security control specified. The check prevents a buffer overflow in the subsequent `memcpy`. The order of operations (check after the fact in the `if` statement) is the flaw, but the intent and required control are perfectly aligned with the spec.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification is about protocol message handlers and variable-length components. While the function handles variable-length input (`buf` with `nbytes`), it is a sysfs store function, not a complex protocol handler. The integrity check it performs is a basic length check, not a structural validation of nested components.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code defines a fixed-size buffer (`drc_name[MAX_DRC_NAME_LEN]`) and performs a length check against it. This embodies the principle of accounting for worst-case input with explicit size limits. The bug is that the check uses `>=` when it should use `>` to account for the null terminator, which is a direct violation of this specification's requirement.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The specification is about validating protocol message length fields against integer limits (e.g., overflow). The code validates `nbytes` (a `size_t`) against a constant, which is a form of bounds checking, but it's not specifically about platform integer limits or parsing length fields from a message. The primary concern here is buffer size, not integer representation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code does not perform dynamic memory allocation; it uses a stack-allocated buffer. However, the specification's broader principle is to validate size parameters against usage requirements. The code's length check (`nbytes >= MAX_DRC_NAME_LEN`) is a validation of the input size parameter against the buffer's usage requirement (it must fit). The flaw (off-by-one and incorrect order) makes this validation insufficient.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-28856_before_exclude_100:1a07d32e:spec": {
    "timestamp": "2026-01-16T21:28:12.256395",
    "cve_id": "CVE-2021-28856",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1a07d32e",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code reads data into a pre-existing struct (`bi`), but it does not perform any memory allocation itself. The specification about initializing memory allocations is only loosely related, as the function assumes the caller has provided a valid struct pointer.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 4,
        "reasoning": "The code has no visible error handling paths (e.g., checks for read failures, invalid values). While consistent state maintenance is a general good practice, the specification is not directly addressed or violated in the shown code snippet.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification is for network protocol handlers. This code is parsing a local image file format (Macintosh bitmap/pixmap) from a buffer, not network data.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is an image format parser reading critical header fields (packing type, pixel size, component count, etc.). The code reads these fields but does not show validation (e.g., checking `bi->pixelsize` is not zero before using it in a division `(bi->rowbytes*8)/bi->pixelsize`). This directly aligns with the security requirement to validate header fields before processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain any memory allocation calls. It reads data into a struct, so guarding allocations with size validation is not applicable here.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "The specification is for BMP parsers. This code is parsing a Macintosh PixMap structure, which is a different format. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "The specification is for regular expression parsers. This code is an image parser and does not process regular expressions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is for pattern compilers processing escape sequences. This code is an image parser and does not compile patterns or process escape sequences.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-28972_after_exclude_100:d00fbe86:spec": {
    "timestamp": "2026-01-16T21:28:13.395809",
    "cve_id": "CVE-2021-28972",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d00fbe86",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expression parsing. It copies a string and processes a newline, but embedded NUL bytes are not a relevant threat model here as `strscpy` will stop at the first NUL. Weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code performs simple string copying and truncation of a newline character, with no pattern compilation or escape sequence processing. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code uses `strscpy`, a length-aware string function, to copy potentially untrusted user input (`buf`) into a fixed-size buffer (`drc_name`). This directly aligns with the specification's requirement for length-aware operations on untrusted input. The check `if (nbytes >= MAX_DRC_NAME_LEN)` also contributes to safe length handling.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates the userspace-provided length `nbytes` against the system constraint `MAX_DRC_NAME_LEN` before processing (`if (nbytes >= MAX_DRC_NAME_LEN)`). This is a direct application of the specification, preventing buffer overflow. It returns 0 instead of an error, which is a minor flaw in error handling.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Moderate/Weak relevance. The code handles a simple string input, not a complex protocol message with variable-length components. While it does check the length and null-terminate the string, the specification's focus on \"structural integrity\" and \"protocol message handlers\" is more specific than this function's scope.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The fixed-size buffer `drc_name` is defined with an explicit size limit `MAX_DRC_NAME_LEN`. The code's validation (`nbytes >= MAX_DRC_NAME_LEN`) ensures the input does not exceed this worst-case buffer size, which aligns with the specification's requirement to account for worst-case input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The specification is about validating protocol message length fields against integer limits (e.g., overflow). The code validates `nbytes` (a `size_t`) against a constant, but this is a simple bound check, not a protection against platform-specific integer wrapping or overflow in a protocol context.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code does not perform dynamic memory allocation; it uses a stack-allocated fixed-size buffer. However, the specification's principle of validating size parameters against usage requirements is partially met by the check against `MAX_DRC_NAME_LEN`. The relevance is indirect because no explicit allocation function is called.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-3905_before_exclude_100:5ca21867:spec": {
    "timestamp": "2026-01-16T21:28:19.811302",
    "cve_id": "CVE-2021-3905",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5ca21867",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code processes IP fragments, which involves parsing network protocol headers. While it does not directly validate message length fields, the functions `ipf_is_valid_v4_frag` and `ipf_is_valid_v6_frag` likely perform some validation of the packet structure, including length checks, before deeper processing. This provides moderate relevance to the specification about validating protocol message length fields.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not contain any explicit memory allocation operations. It operates on pre-allocated packet batches and individual packets. Therefore, this specification about validating size parameters for memory allocation has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code shows consistent type handling by explicitly checking the `dl_type` (Ethernet type) to determine whether to process the packet as IPv4 or IPv6. It uses separate validation functions (`ipf_is_valid_v4_frag` and `ipf_is_valid_v6_frag`) for each protocol, which suggests enforcement of consistent type handling. This is a core part of the function's logic.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The function is part of an IP fragment reassembly module. Validating that fragments conform to RFC specifications (e.g., fragment offset, length, identification) is a critical security concern for such modules to prevent attacks like fragment overlap or resource exhaustion. The validation functions called here are the primary line of defense for this, giving the specification strong relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code deals with IP fragments, not TLV (Type-Length-Value) encoded data. However, the general principle of \"bounds checking before field access\" is relevant to any packet parsing, including IP header and fragment field access within the called functions. The relevance is therefore weak to moderate.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "This is directly relevant to the IP fragment processing logic. Before accessing any data within a fragment (like the offset or more-fragments flag), the parser must validate the packet length to ensure it contains a complete IP header and the fragment fields themselves. This validation is presumably done inside `ipf_is_valid_v*_frag` and `ipf_handle_frag`.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 5,
        "reasoning": "The code is for IP fragment reassembly, not BGP (Border Gateway Protocol) processing. The specification is explicitly about BGP capability validation, which has no relation to this code.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The function `ipf_extract_frags_from_batch` is the entry point for packet dissection (specifically, fragment extraction). Maintaining strict bounds checking throughout the parsing of IP headers and fragment data within `ipf_is_valid_v*_frag` and `ipf_handle_frag` is essential to prevent buffer overreads and other memory safety issues.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      }
    ]
  },
  "CVE-2021-28856_after_exclude_100:b49af4a4:spec": {
    "timestamp": "2026-01-16T21:28:22.347410",
    "cve_id": "CVE-2021-28856",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b49af4a4",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code reads data into a pre-existing struct (`bi`), but it does not perform any memory allocation itself. The specification about initializing memory allocations is only loosely related, as the function assumes the caller has provided a valid struct. There is no explicit initialization of all struct fields, but this is not a classic memory allocation vulnerability.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function performs a series of read operations but lacks explicit error handling (e.g., checking if reads succeed or if values are valid). If an error occurred earlier or during these reads, the struct's state (`bi`) could be partially updated, leading to an inconsistent state. This gives the specification moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This specification is for network protocol handlers. The target code is parsing a local image file format (Macintosh PixMap), not network data. Therefore, it is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The function is an image format parser (PixMap) that reads multiple critical header fields (packing type, pixel size, component count, etc.). However, it performs almost no validation on these fields (e.g., checking `bi->pixelsize` is not zero before using it as a divisor, or that `bi->cmpcount` and `bi->cmpsize` have sane values). This omission is a direct security concern addressed by the specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 3,
        "reasoning": "The code does not contain any memory allocation calls (like malloc). It reads values (e.g., `pack_size`) that could later influence allocation elsewhere, but it does not perform pre-validation of those sizes here. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 2,
        "reasoning": "This specification is for BMP parsers specifically. The target code is parsing a Macintosh PixMap format, which is structurally different from BMP. The specification is not directly applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 1,
        "reasoning": "This specification is for regular expression parsers. The target code does not process regular expressions, making it not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This specification is for pattern compilers processing escape sequences. The target code is an image parser that reads numerical fields from a binary structure. It does not process escape sequences, so the specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2019-19246_after_exclude_100:9502304c:spec": {
    "timestamp": "2026-01-16T21:28:31.627933",
    "cve_id": "CVE-2019-19246",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9502304c",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes a string for case folding in a regex pattern. While it handles a buffer (`sn->s` to `sn->end`) and uses length-aware operations (`p < end`), it does not explicitly show handling of embedded NUL bytes (`\\0`). The relevance is moderate because the code uses pointer and length checks, which is a good practice for handling NUL bytes, but the specification's focus on \"embedded NUL bytes in input patterns\" is not directly addressed in the visible logic for pattern parsing itself.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about processing escape sequences in pattern compilers. The target code is focused on case folding expansion for strings within a regex AST node, not on parsing or compiling escape sequences from the source pattern. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code is highly relevant. It processes a string (`sn->s` to `sn->end`) which could be derived from user input. It consistently uses length-aware operations: it checks `p < end`, uses `enclen` for character length, and passes `p` and `end` to encoding functions (`ONIGENC_GET_CASE_FOLD_CODES_BY_STR`, `ONIGENC_MBC_CASE_FOLD`). This prevents buffer overreads by respecting boundaries.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns parser state for backreferences across alternative branches. This code deals with case folding expansion of a literal string node, not with parsing backreferences or managing the state of subexpressions. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Parser state for backreferences must be consistently maintained across alternative bra..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating backreferences against available subexpressions during parsing/compilation. This function operates on an already parsed node structure and performs case folding, not backreference validation. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Regular expression parsers must validate backreferences against available subexpres..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about preserving/restoring parsing context during alternative pattern parsing. This function creates alternative representations (via `expand_case_fold_string_alt`) for case-folded characters, which involves building an alternative branch in the AST. There is some weak relevance in the concept of managing state (like `prev_node`, `root`) while constructing these alternatives, but it's not about the parsing phase's context.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Alternative pattern parsing must preserve and restore all relevant parsing context"
      },
      {
        "score": 5,
        "reasoning": "The code is strongly relevant. It performs character encoding processing (case folding) using encoding-specific functions (`ONIGENC_GET_CASE_FOLD_CODES_BY_STR`, `ONIGENC_MBC_CASE_FOLD`). It validates buffer boundaries before access by passing the `end` pointer to these functions and using `p < end` checks in the loop, ensuring operations stay within the allocated string buffer.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns maintaining consistent buffer state invariants for parser input operations. The code maintains a buffer pointer (`p`) and its end (`end`), advancing `p` correctly via `len`. It manages node structures during expansion. There is moderate relevance as it maintains buffer state during iteration, but the code is more about tree manipulation than low-level parser input buffering.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2019-19246_before_exclude_100:7304c7cf:spec": {
    "timestamp": "2026-01-16T21:28:31.995159",
    "cve_id": "CVE-2019-19246",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7304c7cf",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes a string (`sn->s` to `sn->end`) character by character using `enclen(reg->enc, p)`. This function likely handles multi-byte encodings and could be affected by embedded NUL bytes if it relies on null-termination internally. However, the loop uses explicit pointer comparisons (`p < end`), suggesting some boundary awareness. Relevance is moderate because the code's vulnerability to NUL bytes depends on the implementation of `enclen` and `ONIGENC_GET_CASE_FOLD_CODES_BY_STR`.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about processing escape sequences in pattern compilers. The target function `expand_case_fold_string` is focused on case-insensitive matching expansion for a string node, not on parsing or compiling escape sequences from a source pattern. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The function operates on a bounded string defined by `start` and `end` pointers. It uses length-aware operations like `enclen` and passes `p` and `end` to `ONIGENC_GET_CASE_FOLD_CODES_BY_STR`. This demonstrates strong relevance to using length-aware operations for input, which is a core security practice for preventing buffer overreads. The score is high but not a perfect 10 because the safety of the called functions (`enclen`, `ONIGENC_GET_CASE_FOLD_CODES_BY_STR`) is assumed.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The specification concerns parser state for backreferences across alternative branches. This function deals with case folding expansion, creating alternative branches for different character case mappings. It does not handle or maintain state for backreferences. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Parser state for backreferences must be consistently maintained across alternative bra..."
      },
      {
        "score": 2,
        "reasoning": "Similar to spec_4, this specification is about validating backreferences. The target code is not involved in backreference processing; it is expanding a string node for case-insensitive matching. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Regular expression parsers must validate backreferences against available subexpres..."
      },
      {
        "score": 5,
        "reasoning": "The function creates alternative representations of a string for case folding (via `expand_case_fold_string_alt`). While it manages a tree of nodes (`root`, `prev_node`, `top_root`), the \"parsing context\" it must preserve is more about the structure of the regex AST being built rather than a general parsing context (like group counts or flags). There is moderate relevance as it handles branching, but the context is specific to node construction, not general parser state.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Alternative pattern parsing must preserve and restore all relevant parsing context"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The function's primary task is character encoding processing for case folding. It repeatedly calls `enclen(reg->enc, p)` and `ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, ..., p, end, items)`. The security of this loop critically depends on these functions correctly validating that `p` and subsequent bytes accessed are within the `[start, end)` buffer. A failure here could lead to buffer overreads. The code structure shows strong awareness of boundaries (`p < end`).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "The function maintains buffer state through the `p` pointer, iterating through the string. It ensures `p` is advanced by `len` (from `enclen`) and checks `p < end`. This maintains the invariant that `p` points within the buffer. The relevance is strong, but the specification's wording (\"Parser input operations\") is slightly broader than this function's specific task of expanding an already parsed string node.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-1620_before_exclude_100:d1c4f390:spec": {
    "timestamp": "2026-01-16T21:28:37.948455",
    "cve_id": "CVE-2022-1620",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d1c4f390",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `vim_regexec` for regular expression matching. If the regex pattern (contained in `rmp`) or the input `name` string contains embedded NUL bytes, it could cause incorrect matching behavior or bypass security checks. The relevance is strong because the specification directly addresses a common vulnerability in regex parsers, though the code doesn't show the pattern compilation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code executes regex patterns but doesn't show pattern compilation. The specification focuses on escape sequence handling during compilation, which is only indirectly relevant to this execution function. Weak relevance since the code may rely on a separate compilation phase.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The function processes string inputs (`name`, `p`) through regex matching. If `name` is untrusted, length-aware operations would prevent buffer overflows. Moderate relevance because while the code doesn't show the internal string handling, the regex engine should use length-aware operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "This specification deals with protocol message length fields and platform integer limits. The code performs filename matching with regex and has no network protocol handling. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code calls `home_replace_save` which likely performs memory allocation. The specification about validating size parameters is moderately relevant to ensure allocation limits aren't exceeded, though the code doesn't show the allocation implementation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "This specification addresses protocol implementations and type consistency. The code performs local filename matching without network protocols. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code accesses strings through regex matching. Buffer bounds validation is crucial when processing potentially untrusted filenames. Moderate relevance because while the function itself doesn't show buffer access, the regex engine must perform bounds checking.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code processes input strings through regex matching. Structural constraints (like valid string format) should be validated before regex execution. Moderate relevance as input validation could prevent regex engine exploitation.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2021-41210_before_exclude_100:763d1061:spec": {
    "timestamp": "2026-01-16T21:28:39.112922",
    "cve_id": "CVE-2021-41210",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "763d1061",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves shape inference for a sparse tensor operation, which indirectly relates to memory allocation planning. The function sets output tensor dimensions, where `c->UnknownDim()` indicates an unspecified size. This could affect downstream memory allocation consistency. However, it's not a direct memory allocation call, so relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 6,
        "reasoning": "The function manages tensor shape resources and maintains consistency between input rank and output shapes. It ensures the output dense_shape vector has the same rank as the input dimension. This relates to resource invariant consistency, though not for low-level system resources.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor shape inference with no regular expression parsing or string pattern handling. No input patterns or NUL bytes are involved.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code has no pattern compilation, escape sequence processing, or string manipulation that would require boundary enforcement.",
        "spec_index": 3,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes tensor dimensions, it doesn't involve string operations or untrusted input parsing. The shape inference operates on dimension values, not strings.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs mathematical shape calculations for sparse tensors, not cryptographic operations. No secret values or timing considerations are present.",
        "spec_index": 5,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code is unrelated to elliptic curve cryptography or any cryptographic implementations. No side-channel resistance considerations apply.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code doesn't perform cryptographic processing, secure memory operations, or require constant-time properties. It's purely shape inference for tensor operations.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      }
    ]
  },
  "CVE-2022-1620_after_exclude_100:a6a0a37b:spec": {
    "timestamp": "2026-01-16T21:28:40.410418",
    "cve_id": "CVE-2022-1620",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a6a0a37b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses vim_regexec() for regular expression matching. If the regex pattern or input name contains embedded NUL bytes, it could cause incorrect matching behavior or security issues like regex injection. The specification directly addresses this risk in regex parsers.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code uses regex matching but doesn't show pattern compilation. The vim_regexec() function likely uses pre-compiled patterns. While escape sequence handling is important for regex security, the connection to this specific code is indirect.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The function processes string inputs (name parameter) but doesn't show length-aware operations. Since it calls vim_regexec() and home_replace_save(), which may process untrusted input, length-aware operations would be relevant for security.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "This specification deals with protocol message length fields and integer limits. The code is a file name matching function with no network protocol handling, making this specification irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code calls home_replace_save() which allocates memory, and vim_free() to free it. While not directly shown, memory allocation validation in these functions would be relevant for security, though the connection is moderate.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "This specification addresses protocol implementations and type handling consistency. The code performs file name matching with no protocol processing, making this specification largely irrelevant.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 7,
        "reasoning": "The code accesses string buffers (name parameter) and passes them to regex functions. Buffer bounds validation before dereferencing is relevant, especially since the input may be untrusted and regex functions could overrun buffers.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code processes input (name parameter) through regex matching. While it doesn't show extensive parsing, validating structural constraints before content processing would be relevant for security, particularly for the regex operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2021-40575_before_exclude_100:1ad0269c:spec": {
    "timestamp": "2026-01-16T21:28:41.726810",
    "cve_id": "CVE-2021-40575",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1ad0269c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocations via gf_realloc and memcpy operations. While allocated memory is used, there are potential issues with initialization. For example, ctx->hdr_store is reallocated and then memcpy is used to copy data into it, which ensures the copied portion is initialized. However, if the realloc size increases, the newly allocated portion beyond the old size may not be fully initialized before use in parsing operations. This is relevant to HS-MEM-001.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error handling paths (e.g., checking gf_filter_pck_new_alloc returns, parsing errors). However, some error paths may not maintain consistent object states. For example, when e==GF_EOS during header parsing, the function returns early without cleaning up all temporary states. Also, if memory allocation fails, the function returns GF_OUT_OF_MEM but some state may already be modified. This relates to HS-STATE-002.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "This code processes media data packets, not network protocols. While it validates some input (like checking for start codes), it doesn't handle network protocol validation. HS-IO-003 is about network protocol handlers, which doesn't directly apply here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "The code performs buffer allocation with gf_realloc for ctx->hdr_store, but doesn't appear to add explicit safety margins or padding. The allocations are sized exactly for the needed data (ctx->hdr_store_size + pck_size). This could be problematic if the parsing logic has off-by-one errors. HS-MEM-003 has moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 2,
        "reasoning": "This code parses MPEG video streams but doesn't perform image compression operations. It's a demultiplexer/parser, not an encoder. HS-IO-004 specifically addresses image compression operations and encoder buffers, which doesn't apply here.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 3,
        "reasoning": "The code processes media packets with size fields but doesn't appear to validate length fields against platform-specific integer limits. However, it's not primarily dealing with protocol message length fields. HS-INPUT-001 has low relevance as this is media parsing, not protocol message handling.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs memory allocations and uses size parameters from packet data. There are checks like \"if (remain<5)\" but potential issues exist: size calculations like \"size -= 3\" could underflow, and \"ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size\" could overflow. The code doesn't explicitly validate these against allocation limits. HS-MEM-002 is highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different start code types (M2V_SEQ_START_CODE, M4V_VOS_START_CODE, etc.) with switch statements, ensuring consistent type handling. However, it's not a protocol implementation in the network sense. HS-PROTOCOL-003 has weak to moderate relevance as the code does enforce consistent handling of media stream types.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2021-41210_after_exclude_100:95979c48:spec": {
    "timestamp": "2026-01-16T21:28:44.554824",
    "cve_id": "CVE-2021-41210",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "95979c48",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves shape inference for a sparse tensor operation, which indirectly relates to memory allocation through tensor dimension calculations. The function sets output shapes based on input dimensions, which influences subsequent memory allocation. However, it does not directly perform allocation or size tracking itself, so relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 6,
        "reasoning": "The code manages tensor shape resources and maintains consistency between input and output shapes. It ensures the output tensor shapes are properly dimensioned relative to inputs, which relates to resource invariant consistency. However, it's not managing system resources like memory handles, so relevance is moderate.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor shape inference with no regular expression parsing or string pattern processing. No input patterns or NUL byte handling is involved, making this specification irrelevant.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code contains no pattern compilation, escape sequence processing, or string manipulation. It's purely numerical dimension calculation for tensor shapes, making this specification completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes input dimensions, it doesn't handle strings or use string processing functions. All operations are on numerical dimensions and shape handles, so this specification has very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor shape inference with no cryptographic operations, secret values, or timing considerations. This specification is completely irrelevant to this mathematical shape calculation code.",
        "spec_index": 5,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code contains no elliptic curve operations, cryptographic implementations, or side-channel resistance considerations. This is purely tensor shape inference code with no cryptographic elements.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs simple dimension calculations with no cryptographic processing, memory operations requiring constant-time properties, or secure memory handling. This specification is completely irrelevant to this mathematical shape inference code.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      }
    ]
  },
  "CVE-2021-40575_after_exclude_100:0cdc46b3:spec": {
    "timestamp": "2026-01-16T21:28:45.617859",
    "cve_id": "CVE-2021-40575",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0cdc46b3",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via gf_realloc and uses memcpy. While allocated memory is initialized before use in most cases (e.g., memcpy writes data), there is a potential issue: when ctx->hdr_store is reallocated, the newly allocated extension bytes are not explicitly initialized before being read in the parsing loop. This could lead to uninitialized memory reads if the parser incorrectly assumes data is valid. However, the code generally ensures data is written before reading, making it highly relevant but not a direct violation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error handling paths (e.g., checking e == GF_EOS, e != GF_OK). It maintains some state consistency (e.g., resetting ctx->resume_from, updating ctx->hdr_store_size), but there are complex branches where state might become inconsistent on errors (e.g., if memory allocation fails, some fields may be partially updated). The specification is moderately relevant as error handling is present but not fully robust across all paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "This specification is about network protocol handlers validating input. The code processes media data (MPEG video) from a filter/packet system, not network protocols. While it does validate data (e.g., checking start codes, buffer sizes), it's not network-specific. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code allocates buffers (e.g., ctx->hdr_store) with size ctx->hdr_store_alloc, but does not explicitly account for operational padding or safety margins. It relies on exact size calculations (e.g., ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size). This could lead to buffer overflows if calculations are off by one. Weak relevance because padding is not considered, but the code does manage buffer growth.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 2,
        "reasoning": "This specification is about image compression operations and encoder buffers. The code is a video demuxer/parser, not an image compression encoder. It does bounds checking (e.g., assert(remain>=size)), but not for compression buffers. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code performs memory allocation with gf_realloc and checks allocation success (e.g., if (!dst_pck) return GF_OUT_OF_MEM). However, it does not validate size parameters against allocation limits (e.g., maximum buffer size) or usage requirements (e.g., ensuring size fits into s32 remain). There is a risk of integer overflow in calculations like ctx->hdr_store_size + pck_size. Moderate relevance because allocations are validated but size checks are incomplete.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "The code handles MPEG video start codes and types (e.g., sc_type, M4V_VOS_START_CODE). It ensures consistent type handling across parsing stages (e.g., using ctx->is_mpg12 to switch logic). However, there are complex branches where type handling might become inconsistent (e.g., forced_sc_type usage). Moderate relevance as type handling is central but not fully enforced in all paths.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2021-4043_after_exclude_100:c7a12f6c:spec": {
    "timestamp": "2026-01-16T21:28:51.839745",
    "cve_id": "CVE-2021-4043",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c7a12f6c",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification \"Memory allocations must be fully initialized before use\" is about preventing the use of uninitialized memory. The target code is a destructor function that frees memory, not one that allocates or initializes it. Therefore, the relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The specification \"Error handling paths must maintain consistent object states\" is highly relevant. The code is a cleanup function responsible for maintaining consistent state by properly freeing all allocated resources (the `entries` array and its `name` members) before freeing the main object `ptr`. This prevents memory leaks and ensures the object is fully destroyed.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Network protocol handlers must validate input before processing\" is not applicable. The target code is a local memory cleanup function for a box structure (likely related to a media container format like MP4/ISOBMFF), with no network input handling involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Buffer access operations must validate bounds before dereferencing\" has moderate relevance. The code loops through `ptr->entries` up to `ptr->nb_entries`. While the code does not explicitly show bounds validation, safe operation depends on `nb_entries` being correct for the allocated `entries` array. A vulnerability could exist if the object's state is corrupted, making this a relevant concern for defensive programming.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Parser input validation must enforce structural constraints before content processing\" has very low relevance. The code is a destructor, not a parser. It processes internal object state for cleanup, not external input.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"XML protocol implementation must maintain strict boundary integrity during parsing\" is not applicable. The code deals with a C structure for a \"GroupIdToNameBox\" (an ISOBMFF box type), not XML parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Binary data parsing must enforce strict bounds checking before array access\" has moderate relevance, similar to spec_4. The function is not a parser itself, but it operates on data that likely originated from parsing binary container data. The safety of the loop depends on the integrity of the `nb_entries` count relative to the allocated `entries` array, which is a core bounds-checking concern for the data structure's lifetime.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Binary data parsing must enforce strict bounds checking before array access"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Cryptographic input processing must validate both format and size constraints\" is not applicable. The code performs memory deallocation and has no relation to cryptographic processing or input validation.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Cryptographic input processing must validate both format and size constraints"
      }
    ]
  },
  "CVE-2021-4043_before_exclude_100:d448c207:spec": {
    "timestamp": "2026-01-16T21:28:55.225328",
    "cve_id": "CVE-2021-4043",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d448c207",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification \"Memory allocations must be fully initialized before use\" is about initialization, but the target code is a destructor/deallocation function (gitn_box_del). It frees memory but does not allocate or initialize any new memory for use. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Error handling paths must maintain consistent object states\" has moderate relevance. The function handles cleanup and could be part of an error-handling path. It ensures that all allocated components (names, entries array, and the main struct) are freed, preventing memory leaks and maintaining a consistent state (freed) for the object. However, it does not handle errors within its own cleanup loop (e.g., if gf_free fails).",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Network protocol handlers must validate input before processing\" is not applicable. The target code is a memory cleanup function for a data structure (likely a box/container), not a network protocol handler.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Buffer access operations must validate bounds before dereferencing\" has moderate relevance. The code accesses `ptr->entries[i]` in a loop based on `ptr->nb_entries`. If `nb_entries` is corrupted or incorrect (e.g., larger than the actual allocated array), this could lead to an out-of-bounds read when accessing `ptr->entries[i].name`. The code does not explicitly validate that `i < allocated_size_of_entries_array`. However, the primary purpose is deallocation, not general buffer access.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Parser input validation must enforce structural constraints before content processing\" has very low relevance. The function is a destructor, not a parser. It processes internal data structure fields for cleanup, not external input.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"XML protocol implementation must maintain strict boundary integrity during parsing\" is not applicable. The code is not related to XML parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Binary data parsing must enforce strict bounds checking before array access\" has moderate relevance, similar to spec_4. The function operates on a data structure that may have been populated from parsed binary data (e.g., a media file format like ISOBMFF/MP4, suggested by \"Box\"). The loop assumes `nb_entries` correctly reflects the allocated array size. Lack of validation before the array access `ptr->entries[i]` could be a security issue if the data is malformed. The relevance is indirect as the function itself is not parsing.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Binary data parsing must enforce strict bounds checking before array access"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Cryptographic input processing must validate both format and size constraints\" is not applicable. The code performs memory deallocation and has no relation to cryptography.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Cryptographic input processing must validate both format and size constraints"
      }
    ]
  },
  "CVE-2022-2453_before_exclude_100:4d8e051f:spec": {
    "timestamp": "2026-01-16T21:28:56.070487",
    "cve_id": "CVE-2022-2453",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4d8e051f",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `memset` to initialize the `sffield` structure before use, which aligns with HS-MEM-001. However, the initialization of `qp_local`, `qp_on`, and `initial_qp` is done via assignment, which is also safe. The relevance is strong because proper initialization prevents information leaks and undefined behavior.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error return paths that propagate errors (`return e;`). However, it's unclear if all object states (like `codec`, `node`, or `field`) remain consistent when an error occurs mid-operation (e.g., during loop iterations). This is moderately relevant as error handling is present but its consistency is not fully assured.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 6,
        "reasoning": "The code reads `NbBits` and `nbFields` from a bitstream without explicit validation of `NbBits` (though `gf_bs_read_int` may have internal checks). `nbFields` is used for memory allocation and loops, so input validation is relevant, but the code's primary focus is decoding, not network protocol handling.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "The code allocates memory via `gf_sg_vrml_mf_alloc` based on `nbFields`, but there's no evident padding or safety margin consideration. This specification is about buffer allocation with operational padding, which is not directly addressed here, making relevance low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code deals with bitstream decoding for 3D graphics (BIFS), not image compression. Specification HS-IO-004 is specific to image compression encoder buffers, so it is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 7,
        "reasoning": "The code reads `NbBits` (5 bits) and then `nbFields` using `NbBits` bits. While `NbBits` is limited to 5 bits (max 31), `nbFields` could still be large and is used for allocation and loops. Validation against platform limits (e.g., maximum allocatable size) is not shown, making this moderately relevant.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code uses `nbFields` for memory allocation (`gf_sg_vrml_mf_alloc`) and loop iterations. There is no explicit validation of `nbFields` against allocation limits or usage requirements (e.g., maximum allowed fields). This is highly relevant as missing validation could lead to excessive memory allocation or loops.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "The code handles different field types (MFNODE vs non-MFNODE) and node types (e.g., QP nodes). Type consistency is somewhat enforced through conditionals and field type checks, but the specification is broad. Relevance is moderate as type handling is present but not comprehensively enforced across all stages.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2022-2453_after_exclude_100:2958a6e3:spec": {
    "timestamp": "2026-01-16T21:28:59.098136",
    "cve_id": "CVE-2022-2453",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2958a6e3",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `memset` to initialize the `sffield` structure before use, which aligns with HS-MEM-001. However, the initialization of `qp_local`, `qp_on`, and `initial_qp` is done via assignment, which is also safe. The relevance is strong because proper initialization prevents information leaks and undefined behavior, though the code does not have complex uninitialized memory issues beyond this basic case.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple error handling paths (goto exit) that attempt to maintain consistent state, such as removing quantization parameters (QP) in error conditions. This directly relates to HS-STATE-002, as the code must ensure that error paths do not leave the decoder in an inconsistent state (e.g., dangling QP nodes). The cleanup logic in the exit block is a key example.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "HS-MEM-003 focuses on buffer allocation with padding and safety margins. The code allocates memory via `gf_sg_vrml_mf_alloc` but does not show explicit padding considerations. This is only loosely related, as the allocation is for a field vector, not a buffer with operational padding needs.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "HS-IO-004 is specific to image compression operations and encoder buffers. This code is for a BIFS decoder handling node fields, not image compression. Therefore, it has very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 6,
        "reasoning": "The code reads a length field (`NbBits` and `nbFields`) from a bitstream. HS-INPUT-001 requires validation against platform integer limits. While there is no explicit validation shown, the use of `NbBits` (5 bits) to read `nbFields` limits it to 32 bits, but overflow risks exist. Moderate relevance as length validation is a security concern for protocol parsing.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code allocates memory based on `nbFields`. HS-MEM-002 requires validating size parameters against allocation limits and usage. The code does not show explicit validation of `nbFields` before allocation, which could lead to excessive memory allocation. This is moderately relevant, as missing validation could cause denial-of-service.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "The code handles different field types (e.g., `GF_SG_VRML_MFNODE`) and node types (e.g., `TAG_MPEG4_QuantizationParameter`). HS-PROTOCOL-003 requires consistent type handling across stages. The code switches behavior based on types and must ensure consistent handling (e.g., QP node vs. regular node). Strong relevance due to type-driven logic and potential for inconsistency.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2022-1289_before_exclude_100:68b960a5:spec": {
    "timestamp": "2026-01-16T21:29:03.445853",
    "cve_id": "CVE-2022-1289",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "68b960a5",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs several mathematical computations and array accesses that depend on input parameters (i, ord, j, k, pat->data indices). It does have some range checks (e.g., checking if ord and i are within bounds), but these validations are not comprehensive. For example, it accesses pat->data[i][...] without verifying that 'i' is within the bounds of the pattern data array, assuming the earlier check (i>=0 && i<e->song.patLen) is sufficient. However, it also accesses arrays like uiColors, fxColors, and volColors using computed indices (e.g., volColors[volColor]) where volColor is clamped between 0 and 127, which is good. The specification is highly relevant because the code should validate all input ranges to prevent out-of-bounds accesses.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 5,
        "reasoning": "The code processes pattern data (a form of codebook) and validates some structural constraints (e.g., ord and i bounds, chanShow[j] check). However, the validation is not thorough for all structural aspects, such as ensuring patCache[j] is valid or that pat->data indices are within allocated dimensions. The specification is moderately relevant because the code does some validation, but not comprehensively for all structural constraints before computation.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      }
    ]
  },
  "CVE-2022-1289_after_exclude_100:76c26c7d:spec": {
    "timestamp": "2026-01-16T21:29:09.525592",
    "cve_id": "CVE-2022-1289",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "76c26c7d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs several mathematical computations and array index accesses (e.g., `pat->data[i][0]`, `e->song.ins[pat->data[i][2]]->type`, `volColors[volColor]`). It includes some range checks for `i`, `ord`, and `pat->data[i][2]` before use, which aligns with the specification's requirement to validate input ranges. However, not all potential edge cases (like `chanVolMax` being zero leading to division by zero in `(pat->data[i][3]*127)/chanVolMax`) are explicitly handled, making it highly relevant but not perfect.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 5,
        "reasoning": "The code processes pattern data (`patCache`) which can be seen as a structured codebook. It validates some structural constraints like checking `ord` and `i` bounds and whether `pat->data[i][2]` is within `e->song.insLen` before accessing instrument type. However, the validation is not comprehensive for all data fields (e.g., effect values), making the relevance moderate.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      },
      {
        "score": 3,
        "reasoning": "The code uses static and stack-allocated buffers (e.g., `id[32]`). While `sprintf` is used with format strings that could potentially overflow if not carefully controlled, the buffers appear sized for the expected data. However, there is no explicit memory allocation (like `malloc`/`new`) that requires initialization, so the specification is only loosely related.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      }
    ]
  },
  "CVE-2022-0943_after_exclude_100:261c012f:spec": {
    "timestamp": "2026-01-16T21:29:12.824660",
    "cve_id": "CVE-2022-0943",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "261c012f",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does involve string processing and uses NUL-terminated strings, but it's primarily handling spell-checking suggestions and user text editing within Vim. There's no regular expression parsing with embedded NUL bytes. The relevance is weak as the specification focuses on regex parsers, which this code doesn't contain.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code doesn't involve pattern compilation or processing escape sequences. It's focused on spell suggestion display and word replacement, not protocol or pattern handling.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code processes strings from user input (via spell checking) and uses some length-aware operations like STRLEN() and vim_strncpy(). However, it also uses non-length-aware functions like STRCPY() and STRCAT() on dynamically allocated buffers, which could be problematic if bounds aren't properly calculated.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code allocates memory with alloc() and vim_strsave(), but doesn't show explicit initialization of the entire allocated buffer. The mch_memmove() and string copy operations initialize parts of buffers, but not necessarily all allocated bytes. This could leave uninitialized memory if calculations are incorrect.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code has multiple error handling paths (goto skip, early returns) that must maintain consistent state. It saves and restores curwin->w_p_spell, handles cursor position restoration, and cleans up allocated memory (spell_find_cleanup(), vim_free(line)). Proper error state management is crucial here.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. This is a local text editor function for spell checking, not a network protocol handler. No network input validation is involved.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes text with multi-byte character support (MB_PTR_BACK, MB_PTR_ADV) and validates buffer boundaries when handling visual selections (checking badlen against STRLEN(line)). However, the specification is about character encoding processing specifically, while this code handles general text editing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does involve parsing-like operations (finding word boundaries) and maintains buffer state, but it's not a formal parser in the security-critical sense. It works with editor buffers rather than untrusted input parsing.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2019-19071_before_exclude_100:26f6f9d4:spec": {
    "timestamp": "2026-01-16T21:29:17.448634",
    "cve_id": "CVE-2019-19071",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "26f6f9d4",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process userspace-provided array lengths. It allocates a fixed-size buffer (MAX_MGMT_PKT_SIZE) for an internally generated beacon frame. Therefore, this specification about validating user-provided lengths is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function calls `rsi_prepare_beacon` which likely constructs a protocol message (beacon). While the code itself doesn't validate variable-length components, the specification's principle applies to the broader beacon preparation process. The direct code shown only handles a pre-allocated buffer.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses `dev_alloc_skb(MAX_MGMT_PKT_SIZE)` which explicitly allocates a buffer for a worst-case scenario (maximum management packet size). This aligns well with the specification's requirement to account for worst-case input with explicit limits.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not parse or validate any protocol message length fields from an external source. It is responsible for sending a beacon, not receiving and interpreting one.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs a critical memory allocation (`dev_alloc_skb`) and must validate the size parameter. While it uses a defined `MAX_MGMT_PKT_SIZE`, the specification emphasizes validating against both allocation limits and subsequent usage. The call to `skb_pull` adjusts the data pointer, so ensuring the original allocation was sufficient for this operation is implied.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code shows basic buffer handling and queue operations. There is no evident complex type handling (e.g., unions, casts) or multiple processing stages where type consistency is a primary concern in this snippet.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function accesses the shared `tx_queue[MGMT_BEACON_Q]` and signals an event. While the queuing operation (`skb_queue_tail`) is likely internally synchronized, the specification about protecting shared resource state transitions is a relevant general concern for code that manipulates shared data structures like packet queues.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function allocates a resource (SKB) and adds it to a tracking structure (the `tx_queue`). The specification about maintaining consistency between allocation state and tracking structures is relevant. A failure after allocation but before queuing could lead to a leak, though the current code flow seems straightforward.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-0943_before_exclude_100:6959df83:spec": {
    "timestamp": "2026-01-16T21:29:18.735503",
    "cve_id": "CVE-2022-0943",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6959df83",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not appear to process regular expression patterns with embedded NUL bytes. It handles spell checking suggestions and user input for word replacement. While it processes strings, the primary concern is not regex parsing with NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It deals with spell suggestions, word replacement, and user interface interactions, not pattern compilation with escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code uses string processing functions like vim_strncpy, STRCAT, and STRCPY with MAXWLEN bounds, but some operations like ml_get_curline() return strings of unknown length. There's potential for buffer overflows if line lengths exceed expected sizes, though some bounds checking exists.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code allocates memory with alloc() and vim_strsave() but doesn't show explicit initialization of all allocated memory. The p buffer is constructed from existing data, but uninitialized memory risks could exist in error paths or edge cases.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code has multiple error handling paths (goto skip, early returns) that must maintain consistent state. It saves and restores curwin->w_p_spell, handles cursor position restoration, and cleans up allocated memory in error paths, which is crucial for security.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. This is a local spell checking function with no network protocol handling. All input comes from local user interface or buffer contents, not network sources.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code processes character data with MB_PTR_BACK and MB_PTR_ADV macros for multi-byte characters and validates buffer boundaries when accessing line buffers. However, it could be more robust in validating all buffer accesses.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code parses words from lines and maintains cursor positions, it's not a traditional parser processing complex input streams. It does maintain some buffer state invariants when manipulating line content during word replacement.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2020-27828_before_exclude_100:4f4351cd:spec": {
    "timestamp": "2026-01-16T21:29:22.171954",
    "cve_id": "CVE-2020-27828",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4f4351cd",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memory allocations (jas_malloc, jas_alloc2) and initializes most fields of the allocated structures. However, there is a potential issue: the `ccp->sampgrdsubstepx` field is assigned twice (line overwritten) while `ccp->sampgrdsubstepy` appears uninitialized. This partial initialization could lead to use of uninitialized memory. Specification HS-MEM-001 is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has extensive error handling with goto error labels that clean up allocated resources (ilyrrates, tvp, cp). It maintains consistent object states by freeing resources in error paths. However, there's a potential issue: if `jas_alloc2` fails at line allocating cp->ccps, the function jumps to error but cp->ccps might be uninitialized (set to 0 earlier), which jpc_enc_cp_destroy might try to free. Overall, strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "This specification deals with network protocol handlers validating input. The target code is for image compression configuration parsing from an option string, not network protocol handling. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification addresses buffer allocation with padding requirements for operational safety. The code allocates memory for structures and arrays but doesn't appear to add explicit padding margins. Only loosely related as general memory allocation occurs.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code performs image compression operations and includes several bounds checks: tile width/height validation, precinct dimensions, code block size limits, layer count limits, etc. However, these checks are for configuration validation rather than encoder buffer bounds during actual compression. Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "This specification deals with network protocol message length fields. The code doesn't handle network protocols or parse message length fields. Not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs memory allocations and validates some size parameters indirectly through bounds checking (e.g., ensuring tile dimensions are non-zero, checking maxrlvls >= 1). However, it doesn't explicitly validate allocation size parameters against allocation limits before calling jas_malloc/jas_alloc2. Strong relevance due to multiple allocations.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles various numeric types (uint_fast32_t, int, etc.) and performs conversions (atoi, jpc_dbltofix). There's some type consistency in assignments and comparisons, but no explicit enforcement of type handling across stages. Weak relevance as the specification focuses on protocol implementations.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2020-27828_after_exclude_100:8302d9cf:spec": {
    "timestamp": "2026-01-16T21:29:26.142300",
    "cve_id": "CVE-2020-27828",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8302d9cf",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memory allocations (jas_malloc, jas_alloc2) and initializes most fields, but there is potential for partial initialization. For example, cp->ccps is allocated and loop-initialized, but the loop may not fully initialize all members if cp->numcmpts is zero. The specification is highly relevant as proper initialization prevents information leaks and undefined behavior.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has extensive error handling via goto error paths that must clean up allocated resources (cp, tvp, ilyrrates). It maintains consistency by freeing resources in error paths and returning NULL. However, there is a risk: if jas_alloc2 fails for cp->ccps after cp allocation, the error path calls jpc_enc_cp_destroy(cp) which may assume cp->ccps is initialized. This could lead to inconsistent state if destroy function doesn't handle NULL ccps.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "The code processes option strings from optstr parameter, but this is not network protocol handling. It's local configuration parsing. While input validation occurs (e.g., checking maxrlvls against JPC_MAXRLVLS), this specification about network protocols has very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code allocates buffers for image components and intermediate layer rates, but doesn't show explicit padding or safety margin calculations. Buffer sizes are based directly on counts (numcmpts, numlyrs-1). This specification about operational padding has weak relevance unless implicit padding requirements exist in the JPEG2000 standard.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 7,
        "reasoning": "The code performs bounds checking for various encoder parameters: precinct dimensions (15), code block dimensions (2-12), code block total size (12), number of layers (16384), etc. However, it doesn't explicitly check all encoder buffers during compression operations - this function is setup/configuration. Moderate relevance as it enforces some bounds but not during actual encoding.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 1,
        "reasoning": "The code doesn't process protocol message length fields. It handles configuration options and image parameters, but not network protocol messages. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code validates size parameters before usage: checks cp->rawsize != 0 to prevent division by zero, validates tile dimensions aren't zero, and checks various limits (maxrlvls, cblk dimensions). However, it doesn't explicitly validate allocation size parameters against allocation limits (like maximum allocatable size). Strong relevance as many security checks are present.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles various numeric types (uint_fast32_t, int, etc.) and converts between them (atoi results assigned to different types). There's some type consistency in validation (e.g., comparing tccp->maxrlvls against JPC_MAXRLVLS), but not comprehensive protocol type handling. Weak relevance as this is configuration code, not protocol implementation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2019-19071_after_exclude_100:a21117be:spec": {
    "timestamp": "2026-01-16T21:29:27.157134",
    "cve_id": "CVE-2019-19071",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a21117be",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process any userspace-provided array lengths. It allocates a fixed-size buffer (MAX_MGMT_PKT_SIZE) and prepares a beacon internally. No user input validation is present or relevant here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function prepares a protocol message (beacon) via `rsi_prepare_beacon`. While the code doesn't explicitly show validation of variable-length components, the specification's guidance on verifying structural integrity is relevant to the overall beacon preparation process. The exact validation would occur inside the called function.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code allocates a buffer of `MAX_MGMT_PKT_SIZE`, which appears to be a fixed worst-case size for a management packet. This aligns with the specification's requirement to account for worst-case input scenarios with explicit size limits.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not parse or validate any protocol message length fields from an incoming packet. It is constructing and sending a beacon, not receiving one.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs a memory allocation (`dev_alloc_skb`) with a size parameter (`MAX_MGMT_PKT_SIZE`). The specification requires validating size parameters against allocation limits and usage needs. While a constant is used here, ensuring this constant is within safe bounds for the allocator and the subsequent `skb_pull` operation (which adjusts data pointer) is a critical security consideration.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code handles a network buffer (skb) and performs pointer arithmetic for alignment. Consistent type handling (e.g., ensuring `dword_align_bytes` calculation and `skb_pull` argument are safe) is relevant to prevent miscalculations that could lead to corruption. However, the code is not processing complex protocol types.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code queues a skb and sets an event. While these involve shared resources (queues, event flags), the code does not show explicit atomic check-and-update operations (e.g., locks, atomic bit operations) for state transitions. This would likely be handled at a higher level in the driver.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code allocates a resource (skb) and adds it to a queue (`skb_queue_tail`). The specification emphasizes consistency between allocation state and tracking structures. A failure to properly link the allocated skb to the queue (or freeing it on error as shown) could lead to memory leaks or state inconsistency. The code shows good practice by freeing the skb on preparation error.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2019-16234_before_exclude_100:a64adb15:spec": {
    "timestamp": "2026-01-16T21:29:30.456776",
    "cve_id": "CVE-2019-16234",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a64adb15",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs several memory allocations (e.g., iwl_trans_alloc, alloc_percpu). While some structures are partially initialized (spin_lock_init, mutex_init), there is no explicit full initialization of all allocated memory fields before potential use. This could leave sensitive fields uninitialized, making it relevant to HS-MEM-001.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error handling paths (goto out_no_pci, goto out_free_ict) that must clean up partially allocated resources (free_percpu, iwl_trans_free) to maintain consistent state. Proper cleanup prevents resource leaks and inconsistent object states.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is PCI device driver initialization code, not network protocol handling. No network protocol input validation occurs here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. This code does not process userspace-provided array lengths. It's kernel-level PCI driver initialization.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. No protocol message handling occurs in this PCI device allocation function.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While buffer allocations exist (alloc_percpu), they are for fixed-size internal structures, not directly tied to worst-case input scenarios from external sources.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. No protocol message length field validation occurs in this device initialization code.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs memory allocations (iwl_trans_alloc, alloc_percpu) but doesn't explicitly validate size parameters against allocation limits. However, these are fixed-size allocations for internal structures, not variable-sized allocations based on external input.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2017-13139_before_exclude_100:3cbe0dc4:spec": {
    "timestamp": "2026-01-16T21:29:32.329448",
    "cve_id": "CVE-2017-13139",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3cbe0dc4",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code performs image file parsing and memory operations but does not involve filesystem operations or inode state management. This is an image decoder reading from a blob/stream, not interacting with filesystem layers.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Filesystem operations must maintain consistent inode state across all layers"
      },
      {
        "score": 2,
        "reasoning": "No POSIX rename operations or filesystem operations are present in this image decoding code. The code reads MNG/PNG/JNG format data from a blob interface.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: POSIX rename operations must properly handle all special cases including self-hardl..."
      },
      {
        "score": 2,
        "reasoning": "No filesystem driver or VFS layer interactions. The code works with image data streams through blob reading functions, not filesystem inode identity.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem drivers must expose consistent inode identity to VFS layer"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. While the code performs some integrity checks (verifying magic numbers, chunk lengths, etc.), it doesn't involve database constraints or generated columns. The validation is specific to image format parsing.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Integrity verification must validate all constraints including NOT NULL on generated c..."
      },
      {
        "score": 3,
        "reasoning": "No database operations or consistency checks. The code maintains MNG object state but this is image format-specific state, not database invariants.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Database consistency checks must maintain invariant validation across all column types"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code performs memory allocation/deallocation (AcquireQuantumMemory, RelinquishMagickMemory) and object copying during image processing. There are potential security issues with buffer management and pointer validity, though not specifically about atomic pointer operations during reinitialization.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Object copy operations must maintain atomic pointer validity during reinitialization"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses file descriptor-like operations through blob reading (ReadBlob, SeekBlob) and maintains some state transitions in parsing, but not strict file descriptor state transition ordering as specified.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File descriptor operations must enforce strict state transition ordering"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code performs image object copying and transformation (magnification, cropping) and must maintain consistent intermediate states during these operations. There are security implications for ensuring memory safety during these transformations.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-003: Object copying must guarantee consistent intermediate states"
      }
    ]
  },
  "CVE-2022-21733_before_exclude_100:ab49d2a1:spec": {
    "timestamp": "2026-01-16T21:29:36.146924",
    "cve_id": "CVE-2022-21733",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ab49d2a1",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs text n-gram generation and data validation. It does not involve any cryptographic operations on secret values, nor does it have timing-sensitive operations related to secrets. The specification is about cryptographic constant-time execution, which is completely unrelated to this text processing code.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is for text n-gram generation in TensorFlow, not elliptic curve cryptography. There are no cryptographic operations, curve models, or side-channel resistance considerations in this code.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory operations for string processing but not for cryptographic purposes. There are no cryptographic processing, secret data handling, or constant-time requirements for memory operations in this context.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The code does allocate resources (tensors) and has validation checks, but it's not about conditional cleanup based on initialization success. The resource allocation happens after input validation, which shows some consideration for proper state management, but this is not the primary focus of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve cryptographic keys, algorithm verification, or key object creation. It's a text processing operation that validates input parameters but not cryptographic algorithms.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 1,
        "reasoning": "The code is unrelated to DNSSEC, key processing, or network protocols. It's a TensorFlow kernel for text n-gram generation with no connection to DNS security operations.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code performs dimension calculations (splits_vec(i) - splits_vec(i-1) for length, and cumulative sums for ngrams_splits_data). While not explicitly image dimensions, these are similar array index calculations that could potentially overflow. The code validates input ranges but doesn't explicitly use overflow-protected arithmetic for these calculations.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code validates numeric inputs before processing: it checks ngram_widths for positive values, validates split indices are within bounds, ensures first split is 0 and last split equals data size. This matches the spirit of HS-INPUT-002, though the code processes tensor data rather than traditional file formats.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: File format parsers must validate all numeric inputs before processing"
      }
    ]
  },
  "CVE-2019-16234_after_exclude_100:a6e8df1a:spec": {
    "timestamp": "2026-01-16T21:29:36.328455",
    "cve_id": "CVE-2019-16234",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a6e8df1a",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memory allocations (alloc_workqueue, alloc_percpu, iwl_trans_alloc). While some structures are initialized (spin_lock_init, mutex_init, init_waitqueue_head), there's no explicit guarantee that all allocated memory is fully initialized before use. The iwl_trans_alloc function (not shown) should ensure full initialization, but this cannot be verified from the provided snippet. The relevance is strong but not perfect as we cannot see all initialization details.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code has multiple error handling paths (goto out_no_pci, goto out_free_trans, goto out_free_ict) that must maintain consistent object states. The error paths properly clean up allocated resources (free_percpu, destroy_workqueue, iwl_trans_free, iwl_pcie_free_ict) in reverse order of allocation, ensuring no resource leaks or inconsistent states.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is PCI device driver initialization code, not network protocol handling. The code deals with hardware initialization, DMA configuration, and interrupt setup, not network protocol processing.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. This is kernel PCI driver code that doesn't process userspace input. All parameters come from kernel structures (pci_dev, pci_device_id, iwl_cfg_trans_params), not userspace arrays.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. This code doesn't handle protocol messages. It's hardware initialization code for a PCI network device driver, focusing on resource allocation and hardware setup rather than protocol processing.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the code performs buffer allocations (workqueue, percpu memory), these are fixed-size allocations for internal data structures, not dependent on variable input scenarios. The allocations use constant sizes or sizeof() operations, not user-controlled inputs.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. This code doesn't process protocol messages with length fields. It reads hardware registers (CSR_HW_REV) and PCI configuration, but these are fixed-size hardware interactions, not variable-length protocol messages.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs memory allocations and should validate size parameters, but most allocations use fixed sizes (sizeof operations). The DMA mask configuration (pci_set_dma_mask) does validate address size parameters against hardware capabilities, falling back from 64-bit to 32-bit if needed. However, this is more about hardware capability validation than memory allocation size validation.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-37706_before_exclude_100:6bc05e7e:spec": {
    "timestamp": "2026-01-16T21:29:43.724622",
    "cve_id": "CVE-2021-37706",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6bc05e7e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code directly processes a length field from a network message (attr->hdr.length) and uses it to calculate a string pointer and length without validating it against buffer boundaries or integer limits. This could lead to out-of-bounds reads if the length is maliciously crafted.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Request processing must initialize all state variables at start of handling"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Connection reuse must guarantee complete state isolation between requests"
      }
    ]
  },
  "CVE-2017-13139_after_exclude_100:25ce6ac9:spec": {
    "timestamp": "2026-01-16T21:29:43.898614",
    "cve_id": "CVE-2017-13139",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "25ce6ac9",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code performs file I/O operations (ReadBlob, SeekBlob, etc.) but doesn't involve filesystem operations that maintain inode state across layers. This is primarily an image decoding routine that reads from a blob/stream, not a filesystem driver.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Filesystem operations must maintain consistent inode state across all layers"
      },
      {
        "score": 2,
        "reasoning": "No POSIX rename operations or hardlink handling in this code. The code deals with image format parsing and decoding, not filesystem operations.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: POSIX rename operations must properly handle all special cases including self-hardl..."
      },
      {
        "score": 2,
        "reasoning": "No filesystem driver or VFS layer interactions. This is user-space image processing code that reads from a blob interface.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem drivers must expose consistent inode identity to VFS layer"
      },
      {
        "score": 5,
        "reasoning": "While the code does some integrity verification (checking chunk lengths, magic numbers), it doesn't involve database constraints or generated columns. The validation is specific to MNG/PNG format parsing.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Integrity verification must validate all constraints including NOT NULL on generated c..."
      },
      {
        "score": 5,
        "reasoning": "No database operations or consistency checks. This is image processing code, not database code.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Database consistency checks must maintain invariant validation across all column types"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs memory allocation and object copying (AcquireQuantumMemory, CopyMagickMemory) and must maintain pointer validity. There are multiple memory management operations that could lead to security issues if not handled properly.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Object copy operations must maintain atomic pointer validity during reinitialization"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs file descriptor-like operations through the blob interface (ReadBlob, SeekBlob) and needs to maintain proper state transitions during parsing. However, it's not strictly about file descriptor state machines.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File descriptor operations must enforce strict state transition ordering"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs extensive image data copying and transformation operations (magnification, cropping, layer insertion) that must maintain consistent intermediate states. There are complex state transitions during MNG chunk processing that could lead to security vulnerabilities if intermediate states are inconsistent.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-003: Object copying must guarantee consistent intermediate states"
      }
    ]
  },
  "CVE-2022-21733_after_exclude_100:e87f2830:spec": {
    "timestamp": "2026-01-16T21:29:48.499865",
    "cve_id": "CVE-2022-21733",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e87f2830",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs text n-gram generation and validation. It does not involve any cryptographic operations on secret values. The operations are data transformations and validations with no timing-sensitive secret handling.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or any cryptographic operations. It's a TensorFlow kernel for text processing, completely unrelated to elliptic curve cryptography.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No cryptographic processing occurs in this code. The memory operations are for string manipulation and array indexing in a machine learning context, not cryptographic operations requiring constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The code allocates output tensors and performs validation before processing, which loosely relates to ensuring operations only proceed with valid state. However, it doesn't involve traditional resource cleanup patterns like file handles or memory that need conditional cleanup based on initialization success.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "No cryptographic key objects are created or used in this code. The code processes text data for n-gram generation, not cryptographic operations.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 1,
        "reasoning": "The code is completely unrelated to DNSSEC key processing. It's a TensorFlow operation for text n-gram generation with no network protocol or DNS components.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs calculations with array indices and lengths (e.g., `splits_vec(i) - splits_vec(i-1)`, `output_start_idx += num_ngrams`). While not explicitly image dimensions, similar arithmetic could potentially overflow with malicious inputs. The validation of split values against input_data_size provides some protection, but not explicit overflow checking.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code validates numeric inputs extensively: checks ngram_widths for positive values, validates split indices are within bounds and properly ordered, and verifies the last split equals data size. This aligns with the principle of validating all numeric inputs before processing, though it's for tensor data rather than traditional file formats.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: File format parsers must validate all numeric inputs before processing"
      }
    ]
  },
  "CVE-2021-37706_after_exclude_100:b6f9c5a7:spec": {
    "timestamp": "2026-01-16T21:29:49.554408",
    "cve_id": "CVE-2021-37706",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b6f9c5a7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `attr->hdr.length` from the message buffer without validating it against platform-specific integer limits before performing arithmetic operations (subtracting 4) and using it as a length for string operations. This could lead to integer overflow/wrap-around or negative values, making it directly relevant to HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code uses `PJ_POOL_ZALLOC_T` for memory allocation, but there is no explicit validation of size parameters before allocation. However, the allocation size is fixed (structure size), not directly derived from untrusted input. The relevance is weak as the primary risk is not in the allocation itself but in subsequent usage of the length field.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification about regular expression parsers and NUL bytes is completely unrelated to the given code, which does not involve regular expressions at all.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification about pattern compilers and escape sequences is completely unrelated to the given code, which performs simple binary decoding and string copying.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes the `attr` structure via `PJ_POOL_ZALLOC_T` (which zero-allocates), ensuring all members are initialized. The `value` local variable is also initialized before use. This aligns with the specification's intent. However, the state being initialized is local to the decoding function, not a persistent request processing state. Moderate to strong relevance.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Request processing must initialize all state variables at start of handling"
      },
      {
        "score": 5,
        "reasoning": "The specification about connection reuse and state isolation between requests is not directly applicable to this code snippet. This function decodes a single attribute from a buffer and is likely called per-message. It does not manage persistent connection state.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Connection reuse must guarantee complete state isolation between requests"
      }
    ]
  },
  "CVE-2022-25636_after_exclude_100:2b63833d:spec": {
    "timestamp": "2026-01-16T21:29:57.748657",
    "cve_id": "CVE-2022-25636",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2b63833d",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code processes a network filter rule (nft_rule) which contains expressions. While not a traditional protocol parser, it must validate the structure of the rule and its expressions before processing them (e.g., checking `expr->ops->offload` exists). This relates to validating structural requirements, but the specification is primarily for network packet parsers.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate minimum structural requirements before processing"
      },
      {
        "score": 1,
        "reasoning": "The code deals with Netfilter rule offloading, not DNS record processing. There is no DNS-related functionality present.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: DNS record processing must enforce strict field boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation (`nft_flow_rule_alloc`, `kzalloc`) and later uses these buffers. While it checks for allocation failure (NULL return), it does not explicitly validate bounds during subsequent operations on the allocated flow rule structure. The risk is moderate as the data source (nft expressions) is internal kernel data, but improper expression handling could lead to out-of-bounds writes within the allocated flow object.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory operations must verify bounds against actual available data"
      },
      {
        "score": 5,
        "reasoning": "The code counts `num_actions` which is an integer derived from untrusted user-space rule data. This count is later used to allocate memory (`nft_flow_rule_alloc`). There is no overflow check on `num_actions` before the allocation, which could lead to undersized allocation if the count wraps around. However, the primary arithmetic risk is indirect.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All arithmetic operations on untrusted size values must include overflow validation be..."
      },
      {
        "score": 1,
        "reasoning": "This specification is specific to DNS domain name length constraints. The target code has no relation to DNS wire format conversion.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: DNS wire format conversion must enforce strict domain name length constraints at al..."
      },
      {
        "score": 5,
        "reasoning": "Similar to HS-MEM-003. The code creates a flow rule buffer and has expressions write their offload data into it via `expr->ops->offload(ctx, flow, expr)`. These operations should validate that writes stay within the bounds of the allocated `flow` memory. The code relies on the correctness of each expression's `offload` method, which is a potential risk point.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer operations must validate both source and destination capacity before memory movem..."
      },
      {
        "score": 2,
        "reasoning": "The code is part of the kernel's Netfilter subsystem and runs in kernel space. It does not implement user-space privilege separation. Errors result in error pointer returns (`ERR_PTR`), not process termination.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "The code transitions the state of network hardware offloading rules. While security-critical in a broad sense (network filtering), the code does not show explicit atomic verification of state transitions. It sequentially processes expressions and builds a flow rule. Concurrency or race condition protection (if needed) would likely be handled at a higher layer.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2022-1769_before_exclude_100:ae6a66e8:spec": {
    "timestamp": "2026-01-16T21:29:59.207411",
    "cve_id": "CVE-2022-1769",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ae6a66e8",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code acquires a file resource (sp->fp) via fgets in a loop. While it has a break condition for NULL return (resource exhaustion/EOF), the function ensures the FILE* is managed by the caller (sp->fp is opened/closed elsewhere). The ga (growarray) memory resource is acquired via ga_init2 and is explicitly released with vim_free before returning NULL, showing a guaranteed release pathway. However, the primary file handle lifecycle is not fully managed within this function, making it highly relevant but not a perfect match.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Resource acquisition must have guaranteed release pathways"
      },
      {
        "score": 1,
        "reasoning": "The code performs file I/O, not USB serial operations. There is no reference counting mechanism present. This specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: USB serial operations must maintain strict reference count symmetry"
      },
      {
        "score": 5,
        "reasoning": "The code reads from a file stream (sp->fp), not a TTY device. While it handles line reading and break checking (line_breakcheck()), it does not implement TTY-specific lifecycle management (e.g., opening, closing, signal handling for terminals). Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-RESOURCE-003: TTY operations must implement complete lifecycle management"
      },
      {
        "score": 5,
        "reasoning": "The code reads source lines and handles NUL bytes as string terminators (buf[ga.ga_len++] = NUL). It does not parse or compile regular expressions. The handling of NUL bytes is related to general string termination, not regex pattern parsing. Weak relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code processes escape sequences for Ctrl-V (^V) to determine if a newline is escaped, which influences line continuation. This is a form of pattern/line parsing that must correctly interpret escape sequences to maintain logical boundaries. However, it's not a pattern compiler in the traditional sense (like regex). Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses fgets with explicit length bounds (ga.ga_maxlen - ga.ga_len) to prevent buffer overflow. It also uses STRLEN on a buffer segment it has just written. While fgets is length-aware, the subsequent operations rely on proper NUL termination. The input could be considered untrusted (external file). Strong relevance, though not all string operations are explicitly length-bounded (e.g., ga_concat).",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve keyrings, security keys, or permission validation. It reads source lines from a file or buffer. Not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Keyring modification operations must enforce complete permission validation regardless o..."
      },
      {
        "score": 5,
        "reasoning": "The code has platform-specific behavior for line endings (CRLF vs LF) and uses a fileformat state (EOL_DOS, EOL_UNIX) that may default or be detected. It issues a warning (W15) for mismatched separators, which is a security-adjacent consistency check. However, this is more about data format validation than security behavior enforcement. Weak relevance.",
        "spec_index": 7,
        "spec_preview": "HS-AUTH-002: Default security behaviors must maintain equivalent protection to explicit configuratio..."
      }
    ]
  },
  "CVE-2022-25636_before_exclude_100:6d5f7016:spec": {
    "timestamp": "2026-01-16T21:30:01.433967",
    "cve_id": "CVE-2022-25636",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6d5f7016",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code processes a network filter rule (nft_rule) and its expressions. While it's not a classic protocol parser, it does parse and process a structured rule. It validates that expressions have the required `offload` operation before calling it, which is a form of structural validation. However, it doesn't explicitly validate the minimum structural integrity of the `rule` or `expr` pointers themselves before the while loops, which could be a concern. Relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate minimum structural requirements before processing"
      },
      {
        "score": 1,
        "reasoning": "The code is related to netfilter rule offloading, not DNS record processing. There is no handling of DNS protocols, records, or field boundaries. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: DNS record processing must enforce strict field boundary validation"
      },
      {
        "score": 7,
        "reasoning": "The code performs memory operations: it allocates memory for `flow` and `ctx` using `nft_flow_rule_alloc` and `kzalloc`. The `nft_flow_rule_alloc` function (not shown) should handle its internal bounds. The code does not directly perform buffer copies or accesses where it validates bounds against available data within this function. However, the calls to `expr->ops->offload` could involve such operations. The relevance is moderate to strong because memory safety is a core concern for any code handling kernel data structures.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory operations must verify bounds against actual available data"
      },
      {
        "score": 5,
        "reasoning": "The code uses `num_actions`, an integer derived from counting expressions, to allocate a flow rule. There is no visible arithmetic overflow validation for `num_actions` before it's passed to `nft_flow_rule_alloc`. If `num_actions` could be influenced by an untrusted source (e.g., a user-space rule), this could be a concern. However, the link between the input and the arithmetic is weak in the shown code. Relevance is weak to moderate.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All arithmetic operations on untrusted size values must include overflow validation be..."
      },
      {
        "score": 1,
        "reasoning": "This specification is specifically about DNS wire format and domain name length constraints. The target code deals with netfilter rules and has no relation to DNS processing. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: DNS wire format conversion must enforce strict domain name length constraints at al..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer operations must validate both source and destination capacity before memory movem..."
      },
      {
        "score": 3,
        "reasoning": "The code is part of the Linux kernel netfilter subsystem. It handles errors by returning error pointers (`ERR_PTR`) and cleaning up memory. It does not deal with user-space process privilege separation or process termination. The concept of \"immediate process termination\" is not applicable in this kernel context for the errors shown (ENOMEM, EOPNOTSUPP). Relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2020-9759_before_exclude_100:3e29e035:spec": {
    "timestamp": "2026-01-16T21:30:02.105916",
    "cve_id": "CVE-2020-9759",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3e29e035",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs dynamic memory allocation via malloc for str_host. While it correctly calculates the required length using snprintf's pattern to compute size, it does not implement a \"growth policy\" as the buffer is fixed-size and not grown. However, bounds checking is performed via the length calculation, making it moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Dynamic buffer operations must implement safe growth policies with bounds checking"
      },
      {
        "score": 5,
        "reasoning": "The code processes IRC protocol messages (numeric 352) and validates the number of arguments via IRC_PROTOCOL_MIN_ARGS and a check for argc < 8. It also conditionally processes additional arguments based on content. This involves some validation of message format before processing, but not exhaustive validation of all format sequences.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Protocol message decoders must validate all format sequences before processing"
      },
      {
        "score": 5,
        "reasoning": "The code uses string operations (strlen, snprintf) with calculated lengths for memory allocation and copying, which implies some length tracking. However, it does not maintain strict length tracking during the decoding of the protocol message itself; it relies on null-terminated argv strings provided by the IRC protocol parser.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Message formatting implementations must maintain strict length tracking during deco..."
      },
      {
        "score": 5,
        "reasoning": "The code does not explicitly validate protocol message length fields against integer limits. It works with argument counts (argc) and string lengths, but no platform-specific integer limit checks are evident. The relevance is low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code validates size parameters for memory allocation: it calculates length for str_host based on string lengths and uses snprintf with that length to prevent overflow. However, it does not explicitly check against allocation limits (e.g., maximum allowable size). It does consider subsequent usage by allocating sufficient space. Strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different types (strings, integers) but does not enforce consistent type handling across stages in a way that would prevent type confusion vulnerabilities. It uses strings and pointers, with some checks for null values. Weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It processes IRC protocol messages with simple string comparisons and assignments. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It deals with IRC message formatting for display but not pattern compilation. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2020-9759_after_exclude_100:600f438f:spec": {
    "timestamp": "2026-01-16T21:30:08.098931",
    "cve_id": "CVE-2020-9759",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "600f438f",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs dynamic memory allocation via `malloc` for `str_host`. The size is calculated safely using `snprintf` with the correct length, which includes bounds checking. However, the specification about \"safe growth policies\" is more about resizable buffers, which this code does not implement. The relevance is moderate because it does involve dynamic buffer creation with proper length calculation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Dynamic buffer operations must implement safe growth policies with bounds checking"
      },
      {
        "score": 5,
        "reasoning": "The code is an IRC protocol message decoder (numeric 352). It validates the number of arguments (`IRC_PROTOCOL_MIN_ARGS` and check `argc < 8`) and performs conditional parsing based on argument counts and content (e.g., checking `argv[8]` for \"*\"). This aligns with validating message format before processing. However, it does not deeply validate all format sequences (like printf-style sequences), which are not present in this context.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Protocol message decoders must validate all format sequences before processing"
      },
      {
        "score": 5,
        "reasoning": "The code uses `argv_eol` for realname extraction, which suggests some length tracking for end-of-line positions. However, the specification emphasizes \"strict length tracking during decoding,\" and the code primarily relies on null-terminated strings and argument counts without explicit length tracking for each field. Relevance is weak to moderate.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Message formatting implementations must maintain strict length tracking during deco..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process any explicit length fields from the protocol message. It works with argument arrays (`argv`) provided by a higher-level parser. Therefore, validation of platform-specific integer limits for length fields is not applicable here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory for `str_host` using `malloc` with a calculated `length`. The calculation (`strlen(argv[4]) + 1 + strlen(argv[5]) + 1`) could theoretically overflow if the lengths are very large, but this is checked implicitly via `snprintf`. The specification directly addresses validating size parameters against allocation limits, which is relevant, though the code does not explicitly check for overflow before allocation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different types of data (strings, integers for flags) from the IRC message. It uses consistent type handling (e.g., `pos_attr` as string, `ptr_nick->realname` as string). However, the specification about \"consistent type handling across all processing stages\" is broad, and the code does not show type conversions or complex type management. Moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expressions at all. It parses IRC protocol messages using string comparisons and argument indexing. Therefore, this specification about embedded NUL bytes in regex patterns is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-1769_after_exclude_100:552a8a06:spec": {
    "timestamp": "2026-01-16T21:30:11.936087",
    "cve_id": "CVE-2022-1769",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "552a8a06",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code manages a dynamically growing buffer (`ga`). While it uses `ga_grow` and `vim_free` for cleanup, the function has multiple early `break` statements. The final cleanup (`vim_free`) only occurs if `have_read` is FALSE. If `ga_grow` fails, the function breaks and returns NULL, but the `ga` structure's data may have been partially allocated and is not freed, potentially leading to a memory leak. This violates the principle of guaranteed release pathways for acquired resources.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Resource acquisition must have guaranteed release pathways"
      },
      {
        "score": 1,
        "reasoning": "The code performs file I/O (`fgets`) and string buffer operations. There is no USB serial communication, reference counting, or any hardware abstraction related to USB. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: USB serial operations must maintain strict reference count symmetry"
      },
      {
        "score": 5,
        "reasoning": "The code reads from a file pointer (`sp->fp`). While this could theoretically be a TTY, the function is a generic line-reading routine with no TTY-specific lifecycle management (e.g., termios configuration, signal handling for VINTR/VQUIT). The `line_breakcheck()` call is a generic interruption check, not TTY lifecycle management. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-RESOURCE-003: TTY operations must implement complete lifecycle management"
      },
      {
        "score": 5,
        "reasoning": "The code processes input lines and handles escape sequences (Ctrl_V) for newline characters. It does not parse or compile regular expressions. The handling of NUL bytes is implicit as the buffer is null-terminated, but the core concern of the specification (regex parsers) is absent.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code processes escape sequences, specifically checking for an odd number of Ctrl_V (^V) characters to determine if a newline is escaped. This involves parsing boundaries within the input buffer. While not a \"pattern compiler\" in the formal sense, the logic for handling escape sequences that affect line termination is directly relevant to the spirit of the specification about maintaining boundaries during escape sequence processing.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code reads potentially untrusted input via `fgets` and processes it in a buffer. It uses length-aware operations: `ga.ga_len`, `ga.ga_maxlen`, and `STRLEN` to manage bounds. The `fgets` call correctly limits reads based on remaining buffer space (`ga.ga_maxlen - ga.ga_len`). This is a good example of using length-aware operations to prevent buffer overflows.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to keyrings, security keys, permission models, or any authentication/authorization system. It is a simple line-reading utility function.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Keyring modification operations must enforce complete permission validation regardless o..."
      },
      {
        "score": 5,
        "reasoning": "The code has a default behavior for handling line separators (EOL_UNKNOWN) which it resolves to EOL_DOS or EOL_UNIX. It also issues a warning (W15) if a DOS-format file lacks CR characters. This touches on the concept of default behavior, but the specification is about security protection levels (e.g., access controls), not text file format detection. The connection is very weak.",
        "spec_index": 7,
        "spec_preview": "HS-AUTH-002: Default security behaviors must maintain equivalent protection to explicit configuratio..."
      }
    ]
  },
  "CVE-2021-38593_before_exclude_100:850347b3:spec": {
    "timestamp": "2026-01-16T21:30:17.127022",
    "cve_id": "CVE-2021-38593",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "850347b3",
    "scores": [
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code allocates a StrokeHandler with size based on path.elementCount()+4. While this accounts for some padding, there's no explicit safety margin calculation or overflow check for the allocation size. The relevance is moderate because buffer allocation is present but not the primary security focus.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This code handles vector path stroking and painting operations, not image compression. No encoder buffers or image compression operations are present in this graphics rendering code.",
        "spec_index": 1,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes geometric path data (coordinates and element types) rather than string data. While external path data could theoretically be malformed, this is not string termination validation. Some bounds checking exists but not for string termination.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is graphics rendering code, not a file format parser. The code processes vector path structures but doesn't parse file chunks or enforce structural invariants at chunk boundaries.",
        "spec_index": 3,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code allocates memory for strokeHandler and uses reset() methods on types and pts members. While not shown in this snippet, proper initialization of allocated memory is important. The code shows patterns where uninitialized memory could potentially be accessed if strokeHandler operations fail.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code has multiple early returns and error conditions. It must maintain consistent state when returning early (e.g., when path.isEmpty() or !d->activeStroker). The manipulation of state()->matrix and subsequent transformChanged() calls require careful error handling to maintain consistency.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is graphics rendering code, not a network protocol handler. While it processes external path data, it doesn't handle network protocols or validate network input.",
        "spec_index": 6,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This specification specifically addresses network protocol message length fields. The code processes geometric path data with element counts, but these are not protocol message length fields, and there's no validation against platform-specific integer limits shown.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      }
    ]
  },
  "CVE-2022-32546_before_exclude_100:10ecc901:spec": {
    "timestamp": "2026-01-16T21:30:20.128615",
    "cve_id": "CVE-2022-32546",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "10ecc901",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses memset to initialize several structures (bounding_box, bounds, page, command) before use, which aligns with the specification. However, not all allocated memory is necessarily initialized (e.g., the 'density' and 'options' strings are acquired but their content is built later). The initialization is good but not fully comprehensive for all allocations.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error handling paths (e.g., after OpenBlob, AcquireUniqueSymbolicLink, GetDelegateInfo failures) that consistently clean up resources (DestroyImage, DestroyString, RelinquishUniqueFileResource). This maintains consistent object states and prevents resource leaks on errors.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol handlers, but the target code is a file format parser (PCL image reader) that processes local files through blob reading. No network protocol handling is present.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code parses PCL format elements like CropBox and MediaBox, validating the count of parsed values (count==4). However, the validation of structural relationships between these header fields and other data is minimal. It checks for basic format but not comprehensive structural validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The code has a buffer 'command' with size MagickPathExtent and checks bounds with \"(size_t) (p-command) < (MagickPathExtent-1)\". However, this check occurs in a loop condition and might not prevent all overflows. Other array operations (like sscanf into buffers) lack explicit bounds validation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function implements extensive error handling with cleanup for file operations, delegate execution, and image reading. Resources (images, strings, unique files) are properly cleaned up on multiple error paths using DestroyImage, DestroyString, and RelinquishUniqueFileResource.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "The code validates critical PCL header fields (CropBox, MediaBox) by parsing them and checking for 4 values. It also checks for DeviceCMYK. However, validation occurs during parsing rather than before all processing, and some fields like page dimensions have fallbacks rather than strict validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't show explicit memory allocation with size parameter validation. Memory allocations appear to be via AcquireString and AcquireImage which are library functions. There's no visible pre-validation of size parameters before these allocations in this function.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2021-38593_after_exclude_100:07cda8ee:spec": {
    "timestamp": "2026-01-16T21:30:22.897762",
    "cve_id": "CVE-2021-38593",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "07cda8ee",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code allocates a StrokeHandler with size based on path.elementCount()+4. While this accounts for some padding (+4), it's not clear if this accounts for \"all operational padding requirements with safety margin\" as the internal needs of StrokeHandler and subsequent operations are not fully visible. Moderate relevance because buffer sizing is present but safety margin adequacy is uncertain.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code performs vector path stroking for graphics rendering, not image compression operations. No encoder buffers or compression logic is present.",
        "spec_index": 1,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes vector graphics paths, not file formats with chunk boundaries. No file parsing or chunk structure validation is occurring.",
        "spec_index": 3,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Memory is allocated for strokeHandler, and its internal arrays (types, pts) are reset before use. However, it's not clear if all allocated memory is fully initialized before use in subsequent operations. The reset() operations suggest initialization, but completeness depends on StrokeHandler implementation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function has multiple early returns and error conditions. It maintains object state consistency by checking d->activeStroker before use, restoring state()->matrix after temporary changes, and calling transformChanged() appropriately. Error paths maintain consistent object states.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is graphics rendering code, not network protocol handling. No network input validation occurs.",
        "spec_index": 6,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code doesn't process protocol messages or validate length fields. This specification is completely unrelated to the graphics stroking functionality.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      }
    ]
  },
  "CVE-2022-31214_before_exclude_100:44b1ab47:spec": {
    "timestamp": "2026-01-16T21:30:25.183475",
    "cve_id": "CVE-2022-31214",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "44b1ab47",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It processes path strings character by character, but does not use regex patterns. The handling of NUL bytes is not a central security concern for this specific path traversal logic.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not process escape sequences or compile patterns. It is a simple directory path construction function with no protocol or pattern compilation involved.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code processes path strings (potentially untrusted input) by iterating through characters and modifying them in-place. It lacks explicit length-aware operations and could be vulnerable to buffer overflows if input strings are not properly bounded. The function should use strnlen or similar length-checking operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs pointer arithmetic and accesses memory through pointers p and q without explicit bounds validation. It assumes src and dst buffers are sufficiently large for the operations. Buffer bounds validation is crucial for security in this context.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code parses path components and should validate structural constraints (like path traversal attempts \"..\" or symlinks) before processing. While it checks if components are directories via stat(), it doesn't validate the overall path structure for security issues.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code has nothing to do with XML protocol implementation or parsing. It deals with filesystem paths, not XML data.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs pointer arithmetic (src + src_prefix_len + 1, dst + dst_prefix_len + 1) without validating that these calculations stay within allocated buffer boundaries. This is a critical security concern for buffer overflow vulnerabilities.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs pathname expansion/construction and should validate pattern syntax and length constraints. It creates directory paths based on source paths and should guard against path traversal attacks and buffer overflows through proper length validation.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2022-31214_after_exclude_100:883392a3:spec": {
    "timestamp": "2026-01-16T21:30:30.421961",
    "cve_id": "CVE-2022-31214",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "883392a3",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It processes path strings by iterating through characters. While it does handle NUL terminators, it's not in the context of a regex parser, making the specification only loosely related.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not process escape sequences or compile patterns. It is a simple directory traversal and creation function, making this specification largely inapplicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The function processes the `src` and `dst` strings, which are likely derived from user input (paths). It modifies these strings in-place by temporarily writing `\\0` characters without using length-aware operations (e.g., `strnlen`). This is a classic case where using length-bounded operations would improve safety against malformed or maliciously crafted input paths.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code uses pointer arithmetic (`p`, `q`, `r`) to traverse and modify the `src` and `dst` buffers. There is no explicit validation that these pointers stay within the bounds of their respective buffers. For example, `*(p - 1)` is dereferenced without checking if `p` is at the beginning of the buffer, which could lead to an out-of-bounds read if the path starts with a '/' immediately after the prefix.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function assumes the input paths have a certain structure (with prefixes). It does not validate the structural constraints of the path (e.g., that `src_prefix_len` is valid, that the path doesn't contain excessive \"..\" components, or that it's a well-formed path) before processing it. This could lead to security issues like directory traversal if the prefixes are incorrectly calculated.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code has nothing to do with XML protocol implementation or parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. This is a specific instance of HS-MEM-001. The function performs pointer arithmetic and length calculations implicitly (e.g., `p = src + src_prefix_len + 1`). There is no validation that `src_prefix_len` or `dst_prefix_len` are within the allocated size of the `src` and `dst` buffers. An incorrect length could cause the pointers to point outside the buffer boundaries, leading to buffer overflows.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function performs a form of pathname expansion by iteratively creating directories. It does not validate the syntax of the path pattern (e.g., for wildcards) or enforce length constraints on the resulting path components. While it's not expanding patterns like globs, it is constructing paths, so basic validation of the input path's syntax and length is a relevant security consideration.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2021-3903_after_exclude_100:124e334d:spec": {
    "timestamp": "2026-01-16T21:30:31.818523",
    "cve_id": "CVE-2021-3903",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "124e334d",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a window/viewport update function for a text editor (likely Vim). It handles cursor positioning and screen scrolling logic. There is no regular expression parsing or processing of input patterns with embedded NUL bytes. The function operates on internal buffer line numbers and window state.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It is focused on calculating which lines should be displayed in a text window based on cursor position, window height, and scroll offset settings.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the function processes buffer lines, it does not appear to handle untrusted input directly in this specific code segment. It uses internal line numbers and structure members. String processing is not a primary activity here, though the broader editor may use such operations elsewhere.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "This is not a protocol implementation. The code manages a text editor's display state, not network or inter-process communication. There are no protocol message length fields to validate.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The function performs calculations with line numbers and window dimensions but does not contain explicit memory allocation operations. Any allocations would be in called functions (not shown). The relevance is very indirect.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "No protocol handling is present. The code uses consistent types (linenr_T for line numbers, int for counts) internally, but this is a general coding practice, not specifically related to protocol type consistency.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "The function updates existing window structure fields but does not perform memory allocation or initialization of newly allocated memory. It modifies members of the curwin structure which is presumably already initialized.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "This function updates multiple state variables (w_topline, w_botline, w_valid flags) and could potentially leave the window in an inconsistent state if errors occur mid-update. However, the code shows no explicit error handling paths; it seems to assume calculations will succeed. There is moderate relevance because maintaining consistent object state is important for any state update function.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-32546_after_exclude_100:b4b2d7c6:spec": {
    "timestamp": "2026-01-16T21:30:32.746847",
    "cve_id": "CVE-2022-32546",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b4b2d7c6",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses several stack-allocated arrays (e.g., command, filename, geometry) with size MagickPathExtent. While they are zero-initialized via memset for `command` and likely via declaration for others, the loop that writes to `command` has a bounds check `((size_t) (p-command) < (MagickPathExtent-1))` which prevents overflow. However, the initialization of other arrays like `filename` and `geometry` before their use is not explicitly shown, and the code relies on proper string termination. This is moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The function has multiple error handling paths (e.g., OpenBlob failure, AcquireUniqueSymbolicLink failure, delegate_info NULL) that consistently clean up resources (DestroyImage, RelinquishUniqueFileResource). However, there is a potential issue: if `ExternalDelegateCommand` fails but returns 0 (status becomes MagickFalse), the code still proceeds to read the image and may throw an exception, but resource cleanup appears consistent. Strong relevance due to systematic cleanup in most paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This specification is about network protocol handlers. The target code reads a PCL image file from local storage via blob/disk and uses an external delegate (GhostPCL). No network protocol handling is present. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code parses PCL file content to extract CropBox and MediaBox fields using sscanf. It validates that `count == 4` before using the parsed bounds. However, it does not validate structural relationships between these boxes (e.g., CropBox within MediaBox) or other header fields. Moderate relevance as it does some validation but not comprehensive structural checks.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The code uses array `command` with explicit bounds checking in the loop. However, the sscanf operations on `command` assume null-terminated strings and could theoretically overflow if the string is not properly terminated, though the bounds check and null assignment reduce risk. Also, other arrays like geometry and filename are used with FormatLocaleString which likely has internal bounds checking via MagickPathExtent. Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "This is a file format processor (PCL) with extensive error handling: checks for file open failures, delegate availability, and external command execution. It performs resource cleanup (DestroyImage, DestroyString, RelinquishUniqueFileResource) in multiple paths. However, there is a minor issue: if `ReadImage` fails after `ExternalDelegateCommand` succeeds, the temporary file `read_info->filename` is cleaned up, but the external command might have left side effects. Strong relevance.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "The code reads PCL headers (CropBox, MediaBox) and validates that it successfully parsed 4 values before using them. It also checks for page width/height being zero and uses defaults. However, it does not validate all critical header fields (e.g., resolution, color space) thoroughly before processing. Strong relevance due to partial validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform dynamic memory allocation directly; it uses AcquireString and CloneImageInfo which likely have internal checks. The size parameters for stack arrays (MagickPathExtent) are compile-time constants, so pre-validation is not needed. Weak relevance because memory allocation is minimal and guarded by library functions.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2021-3903_before_exclude_100:8f1cd212:spec": {
    "timestamp": "2026-01-16T21:30:32.789515",
    "cve_id": "CVE-2021-3903",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8f1cd212",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a window/viewport update function for a text editor (likely Vim). It handles cursor positioning, scrolling, and line calculations. There is no regular expression parsing or pattern handling involved. The specification about embedded NUL bytes in regex patterns is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile or process patterns or escape sequences. It deals with line numbers, window dimensions, and scrolling logic. The specification about pattern compilers and escape sequences is irrelevant to this function.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function performs calculations with line numbers and window properties but does not process string inputs. While it uses pointers and references, there is no evident string manipulation of untrusted data. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "This is not a protocol implementation. The code manages a text buffer viewport, not network messages or protocol length fields. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The function does not perform explicit memory allocation. It works with existing window and buffer structures. There is some arithmetic (e.g., curwin->w_height / 2) but no allocation size validation. Relevance is minimal.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "No protocol handling is present. The code uses consistent types (linenr_T, int, long) for line numbers and counts, but this is standard C programming, not a security concern addressed by the protocol specification.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "No memory allocations occur in this function. It modifies fields of existing structures (curwin) but does not allocate or initialize new memory blocks.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has moderate relevance. It maintains the window state (topline, botline, valid flags) and ensures consistency after scrolling operations. While not classic error handling, it does manage state transitions and conditionally redraws the display. However, it lacks explicit error paths or complex object state management.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-0714_after_exclude_100:37ae4423:spec": {
    "timestamp": "2026-01-16T21:30:37.258777",
    "cve_id": "CVE-2022-0714",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "37ae4423",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. While it processes strings and handles NUL bytes (as seen in replace_push(NUL)), this is for replace stack management, not pattern parsing. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It handles indentation changes and cursor positioning in a text editor context. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code processes strings (e.g., ml_get_curline()) and uses length-aware operations like mb_ptr2len for multi-byte characters. However, it doesn't clearly handle untrusted input; it's editor buffer manipulation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code accesses buffers via pointers (e.g., ptr[new_cursor_col]) and uses bounds checking (e.g., checking for NUL). It validates boundaries before access in loops, but not explicitly for untrusted encoding validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code maintains buffer state invariants when modifying lines (e.g., ml_replace, backspace_until_column). It carefully updates cursor positions and line content, ensuring consistency.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code handles multi-byte characters (has_mbyte) and uses encoding-aware functions (mb_ptr2len, lbr_chartabsize), but boundary checking is context-specific, not uniform encoding processing.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code allocates memory (alloc(i + 1)) and initializes it (ptr[i] = NUL; while loop fills with spaces). However, it doesn't fully initialize all allocations (e.g., orig_line allocation not checked until later).",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code has multiple error handling paths (e.g., checking orig_line == NULL, new_line == NULL) and maintains consistent state by restoring variables (save_p_list, save_State) and cleaning up memory. It ensures editor state consistency after errors.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2019-15504_before_exclude_100:bcf70463:spec": {
    "timestamp": "2026-01-16T21:30:40.870355",
    "cve_id": "CVE-2019-15504",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bcf70463",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages with length fields. It is a USB interface initialization function dealing with driver setup, memory allocation, and endpoint discovery, not network protocol parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification concerns protocol type handling consistency. This code is initializing a data structure and function callbacks for a USB device driver, not implementing a communication protocol with variable types.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code uses kzalloc (which zero-initializes memory) for the main rsi_dev structure, ensuring it is fully initialized before use. This is a direct and correct application of the specification. The tx_buffer allocated with kmalloc is not explicitly initialized, but its content is likely written before being read, which should be verified in the broader context.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code has explicit error handling paths (fail_eps, fail_rx) that clean up allocated resources (kfree) to maintain a consistent state (no memory leaks) before returning an error status. This is a textbook example of good error handling for resource allocation.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is a USB driver initialization routine, not a network protocol handler. It does not process incoming network packets or data from the network.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not receive or process any array lengths from userspace. All parameters are internal kernel structures or hardcoded values.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Similar to spec 1 and 3, this specification is about protocol message handlers. This function is setting up a USB interface and does not parse or handle variable-length protocol messages.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2019-15504_after_exclude_100:bdb78912:spec": {
    "timestamp": "2026-01-16T21:30:43.432919",
    "cve_id": "CVE-2019-15504",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bdb78912",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not process protocol messages with length fields. It is a USB interface initialization function dealing with driver setup, memory allocation, and endpoint discovery, not network protocol parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code performs two key memory allocations (`kzalloc` and `kmalloc`). While it checks for allocation failure (NULL return), it does not validate the size parameter (2048) against any platform-specific allocation limits or ensure it meets subsequent usage requirements (e.g., if the TX buffer size is sufficient for all possible data). The fixed size reduces risk but still requires validation against system constraints.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The code initializes a USB device driver interface, setting function pointers and constants. It does not implement a communication protocol with variable types that need consistent handling across stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code uses `kzalloc` which initializes memory to zero, satisfying this specification for the `rsi_dev` structure. However, the `kmalloc` allocation for `tx_buffer` is not initialized (`kmalloc` does not zero memory), and the buffer is used for data transmission. If not properly written before being read (e.g., on an error path or partial write), uninitialized memory could be leaked or cause undefined behavior.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code has error handling paths (`fail_eps`, `fail_rx`) that free allocated resources (`tx_buffer`) but do not fully clean up the state. For example, on the `fail_eps` path, the `rsi_dev` allocated at the beginning is not freed, leading to a memory leak. The adapter's `rsi_dev` pointer is also set before the checks, leaving a partially initialized state on error.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is a USB driver initialization function, not a network protocol handler. It does not process incoming network packets or user input in the context of network protocols.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not process userspace-provided array lengths. All sizes (e.g., sizeof(*rsi_dev), 2048) are compile-time constants within the kernel driver.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not handle protocol messages or their variable-length components. It sets up a USB device interface and allocates a fixed-size buffer.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2022-0714_before_exclude_100:ac95068c:spec": {
    "timestamp": "2026-01-16T21:30:49.199759",
    "cve_id": "CVE-2022-0714",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ac95068c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It handles indentation changes, cursor positioning, and replace stack manipulation. While it does process strings and uses NUL bytes as terminators (e.g., `ptr[i] = NUL;`), this is for internal string construction, not for parsing regex patterns with embedded NULs.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It deals with text editing operations like shifting lines, inserting spaces, and managing replace stacks. There is no pattern compiler present.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code processes strings (e.g., `ml_get_curline()` returns a line buffer) and uses functions like `mb_ptr2len` which are length-aware for multi-byte characters. However, the input is primarily internal buffer content, not explicitly untrusted. The `ins_str(ptr)` call inserts a dynamically allocated string, which is safe.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2017-13053_after_exclude_100:e48373a5:spec": {
    "timestamp": "2026-01-16T22:44:04.751477",
    "cve_id": "CVE-2017-13053",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e48373a5",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code validates user-provided data (network packet) using `pskb_may_pull` to ensure sufficient data is available before accessing fields. This aligns with validating input against system constraints (available buffer length). However, the specification mentions \"array lengths\" and \"system constraints\" more broadly, while this code specifically checks packet data availability.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function processes GRE protocol headers with variable-length components (GRE flags determine optional CSUM and KEY fields). It uses `pskb_may_pull` twice to verify structural integrity before accessing these variable-length components, which is the core principle of this specification.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code doesn't perform buffer allocation; it validates existing network buffers. The specification focuses on allocation with worst-case scenarios, while this code validates received data against actual buffer boundaries.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates length indirectly through `pskb_may_pull` calls, ensuring the packet contains enough data for the parsed GRE header length. However, it doesn't explicitly validate protocol message length fields against integer limits; it validates buffer availability.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code contains no memory allocation operations; it only validates and accesses existing sk_buff data. The specification is about allocation size validation, which doesn't apply here.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code handles multiple ICMPv6 message types with consistent type handling: it validates GRE header structure, looks up the tunnel, and processes different ICMPv6 types (DEST_UNREACH, TIME_EXCEED, etc.) with appropriate logic for each type/code combination.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates GRE header structure against flags but doesn't explicitly enforce RFC-specified length constraints. The `pskb_may_pull` checks ensure basic buffer boundaries but don't validate against protocol-specific maximums.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes TLV-like structures in the ICMPV6_PARAMPROB case with `ip6_tnl_parse_tlv_enc_lim`. While bounds checking likely occurs in that function, the current code shows TLV processing with offset validation (`teli == be32_to_cpu(info) - 2`). However, the main GRE header processing isn't TLV-based.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2016-10218_before_exclude_100:e6ea5e07:spec": {
    "timestamp": "2026-01-16T22:44:11.492322",
    "cve_id": "CVE-2016-10218",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e6ea5e07",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs graph optimization for neural network operations (constant folding for convolution and multiplication). It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or any protocol/pattern compilation tasks. It manipulates computational graph nodes and their connections.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The code does not process strings or use string manipulation functions. It works with graph node structures, tensor properties, and mathematical operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process variable-length input from untrusted sources. It operates on fixed graph structures and validates tensor shapes through symbolic equality checks, not length validation of input data streams.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Variable-length input processing must enforce length validation before access"
      },
      {
        "score": 5,
        "reasoning": "The code is not a protocol dissector and does not parse protocol fields with length specifications. It's a graph optimization routine for mathematical operations.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-004: Protocol dissectors must honor field length specifications"
      },
      {
        "score": 1,
        "reasoning": "The code does not perform fixed buffer operations or memory writes that require bounds validation. It manipulates graph node references and properties through safe API calls.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code does not parse external input or implement input size validation. It validates internal graph structure properties (tensor shapes, node connections) but not untrusted input streams.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "The code is not a configuration parser and does not enforce structural constraints on configuration data. It validates mathematical operation patterns in a computational graph.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      }
    ]
  },
  "CVE-2019-20637_before_exclude_100:5f87b572:spec": {
    "timestamp": "2026-01-16T22:44:13.780807",
    "cve_id": "CVE-2019-20637",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f87b572",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves reading MQTT packets which contain length fields. The function `MqttPacket_Read` and `MqttClient_DecodePacket` are responsible for parsing incoming network data. Specification HS-INPUT-001 is highly relevant because these functions must validate the packet length field against platform integer limits (e.g., ensuring it doesn't cause integer overflow or underflow) before further processing. The code's reliance on external packet decoding makes this a direct concern.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 4,
        "reasoning": "The target code does not explicitly perform memory allocation. It operates on pre-allocated buffers (`client->rx_buf`). While memory size validation might be relevant to the called functions (e.g., `MqttPacket_Read`), it is not visible in this code snippet. Therefore, the specification has weak relevance to the presented code.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "This code is central to MQTT protocol message processing. It handles different packet types (`packet_type`) and states (`*mms_stat`). Specification HS-PROTOCOL-003 is strongly relevant because the code must ensure consistent handling of packet types across states (BEGIN, WAIT, READ, etc.), especially when matching incoming packets (`wait_type`, `packet_type`) and managing state transitions. Inconsistent handling could lead to logic errors or security issues.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "Similar to spec_1, this is highly relevant. MQTT protocol (RFC 3.1.1, 3.2.2, etc.) defines specific constraints for fields like remaining length, topic length, and packet identifier. The decoding functions (`MqttClient_DecodePacket`) called here must enforce these RFC-specified length constraints. Failure to do so could lead to buffer overflows or other parsing vulnerabilities.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 7,
        "reasoning": "MQTT uses a TLV-like structure for its variable header and payload (e.g., remaining length followed by specific fields). The function `MqttClient_DecodePacket`, which is called, is responsible for parsing these structures. Specification HS-PROTOCOL-002 is moderately to strongly relevant because complete bounds checking (ensuring each field's length doesn't exceed the remaining buffer) must occur before accessing any field data. This is a critical security step for the protocol implementation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 3,
        "reasoning": "The code initializes local variables and resets state (`packet_id = 0`, `*mms_stat = MQTT_MSG_BEGIN`). However, it does not perform memory allocation itself. The specification about initializing allocated memory has very low direct relevance to this control flow and state management function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The function manages complex state via `*mms_stat` and uses `goto wait_again` for retries. Error handling paths (multiple `break` statements on `rc <= 0` or lock errors) must ensure that mutex locks (`readLocked`) are properly released and the state (`*mms_stat`) is reset consistently. The code shows explicit cleanup (`wm_SemUnlock`) in some paths, making state consistency a critical concern.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "This is the core function of a network protocol handler. It calls `MqttPacket_Read` to get data from the network and then processes it. Specification HS-IO-003 is directly applicable: the raw network input must be validated (e.g., for correct packet structure, sane lengths) in `MqttPacket_Read` and `MqttClient_DecodePacket` before any significant processing occurs in `MqttClient_HandlePacket`. The security of the entire client depends on this validation.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2019-20637_after_exclude_100:527a6dc9:spec": {
    "timestamp": "2026-01-16T22:44:16.081910",
    "cve_id": "CVE-2019-20637",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "527a6dc9",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves reading MQTT packets which contain length fields. The function `MqttPacket_Read` and `MqttClient_DecodePacket` are responsible for parsing these fields. While the code does handle packet reading and decoding, it's not directly visible if platform-specific integer limits (like size_t overflow) are validated. The relevance is moderate because the principle of validating message length fields is crucial for this protocol handling code, but the implementation details are abstracted.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The target code does not contain explicit memory allocation operations (like malloc, calloc). It operates on pre-allocated buffers (`client->rx_buf`). Therefore, the specification about validating size parameters for memory allocation has very low direct relevance to this specific code snippet.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The core function of `MqttClient_WaitType` is to wait for and process a specific MQTT packet type. It meticulously handles packet types (`wait_type`, `packet_type`), uses a state machine (`MqttMsgStat`), and ensures consistent handling across different states (BEGIN, WAIT, READ). The switch statement and logic for matching packet types demonstrate enforcement of consistent type handling.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Similar to spec_1, this deals with protocol message validation. The code reads packets and decodes them. Enforcing RFC-specified length constraints (e.g., maximum MQTT packet size, remaining length field limits) would be part of the decoding logic in `MqttPacket_Read` or `MqttClient_DecodePacket`. The relevance is strong as this is a fundamental part of secure protocol implementation, but the validation is not explicitly shown in this high-level function.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "MQTT packets can be considered a form of TLV (Type-Length-Value) structure. The function relies on `MqttClient_DecodePacket` to parse these structures. Complete bounds checking before field access is a critical security requirement for the decoder. The relevance is moderate because while TLV processing is central to the code's purpose, the actual bounds-checking implementation is delegated to the decode function and is not visible here.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform memory allocation. It uses existing structures and buffers. While ensuring those buffers are initialized is important, the specification specifically addresses memory allocation operations. Therefore, the relevance to this code snippet is very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "This specification is strongly relevant. The function manages state (`*mms_stat`) and has multiple error paths (break statements, rc checks). It shows some effort to maintain state consistency: it resets the state to `MQTT_MSG_BEGIN` on completion (unless in non-blocking CONTINUE mode) and uses `goto wait_again` for retry logic. However, a full audit would be needed to ensure all error paths correctly unlock mutexes and reset states, which the code attempts with the `readLocked` flag and cleanup sections.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. `MqttClient_WaitType` is a core network protocol handler. It calls `MqttPacket_Read` to get data from the network and then `MqttClient_DecodePacket` to interpret it. The principle of validating this input (packet type, ID, structure) before further processing is the main purpose of this function. The logic to match `wait_type` and `wait_packet_id` and the call to `MqttClient_HandlePacket` are all part of input validation and processing.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2018-14461_before_exclude_100:6d429f15:spec": {
    "timestamp": "2026-01-16T22:44:33.265585",
    "cve_id": "CVE-2018-14461",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6d429f15",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the RTCP XR packet length field (pkt_len) against the input size (size / 4). This is a direct validation of a protocol message length field against the actual received data size, which aligns with the core principle of HS-INPUT-001. However, the check is not exhaustive against all possible integer overflow/wrap-around scenarios (e.g., when `size` is very large, `size / 4` could overflow if `size` is close to `SIZE_MAX`). The relevance is strong but not perfect.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The target code does not contain any explicit memory allocation operations (e.g., malloc, calloc). It primarily parses an input buffer. Therefore, the specification about validating size parameters for memory allocation has very low direct relevance to this code scenario.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code is a protocol implementation for RTCP XR. It performs type handling through the `switch (rb_hdr->bt)` statement, casting pointers to specific structure types based on the block type. This is a direct application of consistent type handling across processing stages. The casts are performed after validating the block type, which is good practice. The relevance is very high.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform memory allocations; it operates on pre-existing session structures and input packet buffers. While it initializes parts of the `sess->stat` structure (e.g., via `pj_bzero` for `stat_sum`), this is not about initializing newly allocated memory but about updating state. The specification's core concern is not directly applicable.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple early return paths for invalid input (e.g., wrong packet type, invalid length). These error paths leave the session state (`sess`) unchanged, which maintains consistency. However, the function does not have complex error recovery; it simply aborts parsing. The principle of maintaining consistent state on error paths is followed, giving it moderate to strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a network protocol handler for RTCP XR packets. It performs critical input validation before processing: it checks the packet type (`rtcp_xr->common.pt`), validates the high-level packet length (`pkt_len` against `size`), and skips blocks with zero length. This is a direct and strong application of the specification's principle.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code validates the RTCP length field (`pkt_len`) against the received data size. RTCP length is defined in the RFC (RFC 3550, RFC 3611) as a count of 32-bit words minus one. The check `(pkt_len + 1) > (size / 4)` validates this RFC-derived constraint against the actual buffer. This is highly relevant. The check for `rb_len == 0` also prevents processing of malformed blocks.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code implements a TLV-like parser for RTCP XR report blocks. Each block has a type (`bt`) and length (`rb_len`). The loop condition `((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)` ensures the parser stays within the bounds of the main packet. The pointer arithmetic `((pj_int32_t*)rb_hdr + rb_len + 1)` to move to the next block uses the length field, which is a core part of TLV processing. However, it lacks an explicit check that `rb_len` does not cause the pointer to advance beyond the packet boundary (a potential overflow in the pointer arithmetic itself). Despite this minor omission, the implementation's structure directly corresponds to the specification, making it highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2019-17498_after_exclude_100:67c4ad2c:spec": {
    "timestamp": "2026-01-16T22:44:39.661444",
    "cve_id": "CVE-2019-17498",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "67c4ad2c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the RTCP XR packet length field (pkt_len) against the input size parameter. It checks if (pkt_len + 1) > (size / 4), which prevents integer overflow and ensures the length field is within bounds. This directly addresses protocol message length field validation against platform-specific integer limits.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any memory allocation operations. It only parses and validates an existing packet buffer. Therefore, this specification about memory allocation size validation has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform memory allocation, so initialization of allocated memory is not applicable. It only works with existing packet data and session structure fields.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "The code performs extensive input validation before processing the RTCP XR packet. It checks packet type, length fields, and block boundaries before accessing any data. This is a network protocol handler that validates input before processing, making it highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The code validates RTCP XR packet length against the actual received size (size parameter). It also validates individual report block lengths within the packet. This directly addresses RFC-specified length constraints for RTCP XR packets.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code implements TLV-like processing for RTCP XR report blocks. It checks block boundaries ((char*)rb_hdr + sizeof(type) <= (char*)pkt + size) before accessing specific block types. However, not all block types have the same rigorous bounds checking. This shows strong relevance to TLV bounds checking requirements.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2012-3364_after_exclude_100:f03c2417:spec": {
    "timestamp": "2026-01-16T22:44:52.060255",
    "cve_id": "CVE-2012-3364",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f03c2417",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates user-provided array lengths (transaction->aid_len, transaction->params_len) against system constraints (sizeof(transaction->aid), calculated maximum based on allocated size) before processing in memcpy operations.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The protocol handler verifies structural integrity of variable-length components: checks skb length, validates AID and PARAMETERS tags, validates length fields against remaining buffer space, and ensures proper message format.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates protocol length fields (skb->len, transaction->aid_len, transaction->params_len) against various constraints including minimum requirements, maximum buffer sizes, and platform-specific limits like sizeof(transaction->aid).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. Memory allocation (devm_kzalloc) uses skb->len - 2 as size parameter, and the code extensively validates this against subsequent usage requirements through multiple bounds checks on aid_len and params_len.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The protocol implementation enforces consistent type handling by validating tags (NFC_EVT_TRANSACTION_AID_TAG, NFC_EVT_TRANSACTION_PARAMS_TAG) and ensuring proper parsing sequence across all processing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code shows no shared resource state transitions or atomic operations. It processes a single skb in a linear fashion without concurrency control mechanisms.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code allocates a transaction structure and validates it, but doesn't show complex resource allocation state tracking between multiple structures. It's a single allocation with straightforward validation.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2016-10154_after_exclude_100:6c9deecf:spec": {
    "timestamp": "2026-01-16T22:45:00.868066",
    "cve_id": "CVE-2016-10154",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6c9deecf",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the user-provided `size` and derived `keylen` against minimum and maximum constraints (TIPC_AEAD_KEYLEN_MIN, TIPC_AEAD_KEY_SIZE_MAX) before processing the key data. This directly aligns with HS-INPUT-001's requirement to validate array lengths against system constraints.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 9,
        "reasoning": "The function performs structural integrity checks for the variable-length key component. It verifies that the total message size matches the expected size derived from the key length field (`size != keylen + sizeof(struct tipc_aead_key)`), which is a core requirement of HS-PROTOCOL-002.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2018-14467_after_exclude_100:0c62c137:spec": {
    "timestamp": "2026-01-16T22:45:08.234637",
    "cve_id": "CVE-2018-14467",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0c62c137",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the capability length field (hdr->length) before using it to calculate memory access boundaries (pnt + hdr->length + 3). This directly implements the principle of validating field lengths before data access, which is core to HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 8,
        "reasoning": "The code performs structure validation for the MP capability type by checking hdr->length against sizeof(struct capability_mp_data) before memcpy. It also validates the action field. This aligns with the requirement for strict structure validation per capability type.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 9,
        "reasoning": "The code maintains strict bounds checking throughout the parsing loop. It checks (pnt + 3 > end) for the header, and later (pnt + hdr->length + 3 > end) for the full capability data, ensuring operations stay within the packet bounds.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 7,
        "reasoning": "The code validates length fields against minimum expected sizes (e.g., checking hdr->length against sizeof(struct capability_mp_data)). However, it does not explicitly enforce maximum RFC-specified constraints, only that the data fits within the received message.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code implements TLV-style parsing (Type/Length/Value for capabilities) with complete bounds checking. It validates the length field (hdr->length) before using it to access the value data and to advance the pointer (pnt).",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 9,
        "reasoning": "This is a restatement of Specification 1 (HS-INPUT-001). The code validates the capability length field (hdr->length) before performing memcpy and pointer arithmetic, directly adhering to this principle.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 5,
        "reasoning": "The code enforces strict message boundary validation by checking (pnt + hdr->length + 3) > end before processing each capability. This ensures each capability structure fits within the remaining portion of the message.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains separation by using the 'end' pointer to mark the validated boundary of the input buffer. All accesses are checked against 'end'. The memcpy from pnt+3 only occurs after validating hdr->length, ensuring the source region is within bounds.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2017-13043_before_exclude_100:ae622302:spec": {
    "timestamp": "2026-01-16T22:45:10.092440",
    "cve_id": "CVE-2017-13043",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ae622302",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the capability length field (hdr->length) before using it to calculate memory access boundaries (pnt + hdr->length + 3). This directly implements the principle of validating field lengths before data access, which is the core of HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2018-14461_before_exclude_100:11ce9716:spec": {
    "timestamp": "2026-01-16T22:45:18.804732",
    "cve_id": "CVE-2018-14461",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "11ce9716",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code parses an RTCP feedback packet and calculates `rpsi_len` from a network-supplied length field (`hdr->length`). This length is used in a bounds check (`length < rpsi_len + 12`). However, the calculation `(pj_ntohs((pj_uint16_t)hdr->length)-2) * 4` could underflow if `hdr->length` is less than 2, or overflow when multiplied by 4, leading to incorrect validation. This directly relates to validating protocol message length fields against integer limits.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not perform explicit memory allocation. However, it does calculate a size (`rpsi_len`) derived from an untrusted input and uses it for bounds checking and to set the length of a referenced string (`rpsi->rpsi`). If the calculation is incorrect, it could lead to out-of-bounds reads when `pj_strset` accesses the buffer `p`. This indirectly relates to validating size parameters against usage requirements.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates the RTCP packet type (`pt`) and format (`count`/FMT) against expected values (RTP/AVPF profile with Payload Specific FB and FMT=3 for RPSI). This is a direct enforcement of consistent type handling at the protocol parsing stage.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code parses data into a provided `rpsi` structure but does not perform any heap memory allocation itself. The structure fields are written directly from the input buffer. There is no allocation to initialize.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function has multiple error return paths (`PJ_EINVAL`, `PJ_ETOOSMALL`, `PJ_ENOTFOUND`). It must ensure that on these error paths, the state of the output `rpsi` structure is not left partially initialized or in an inconsistent state that could cause issues for the caller. The current code only writes to `rpsi` on the success path, which is good practice.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a network protocol handler for RTCP packets. It performs several critical input validations: checking for NULL pointers, ensuring the buffer is large enough to contain the RTCP header, verifying the packet type and subtype (FMT), and calculating and validating the length of the RPSI data against the provided buffer length (`length`). This is the core security activity of the function.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve regular expression parsing. It parses binary RTCP protocol data.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve pattern compilers or processing of escape sequences. It parses binary RTCP protocol data.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2011-1003_before_exclude_100:ffbb0fdf:spec": {
    "timestamp": "2026-01-16T22:45:51.973787",
    "cve_id": "CVE-2011-1003",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ffbb0fdf",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code shows memory allocation (e.g., `efree(ent1)`) and data structure manipulation. While there is some initialization (like stack operations), there is no explicit evidence that all allocated memory (like `ent1->varname`) is fully initialized before use, which is the core of HS-MEM-001. The relevance is moderate because the principle applies but the code snippet doesn't show the complete allocation/initialization lifecycle.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code contains multiple error handling paths (e.g., early returns when `Z_TYPE(ent1->data) == IS_UNDEF`, checks for non-existent fields). It must ensure consistent state of the `stack` and associated data structures across these paths. There is strong relevance as maintaining consistent object/stack state during error conditions is a central concern in this parsing function.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "This function (`php_wddx_pop_element`) is part of a WDDX (Web Distributed Data eXchange) deserializer, which is a network protocol/data format handler. It processes XML element names (`name`) and data. The code performs validation (string comparisons to known element types) before processing, which aligns directly with HS-IO-003. The relevance is very high as it's a core input processing routine.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about keyring modification operations and permission validation. The target code is a WDDX deserialization function with no relation to keyrings, cryptographic keys, or permission systems. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Keyring modification operations must enforce complete permission validation regardless o..."
      },
      {
        "score": 2,
        "reasoning": "The specification concerns default security behaviors versus explicit configurations, often in authentication/access control contexts. The code deserializes data and calls object `__wakeup` methods, which has security implications (object injection), but the code does not show configuration of security behaviors (default vs explicit). The connection is very weak.",
        "spec_index": 4,
        "spec_preview": "HS-AUTH-002: Default security behaviors must maintain equivalent protection to explicit configuratio..."
      },
      {
        "score": 1,
        "reasoning": "The specification is about keyring state transitions and permission requirements. The code deals with a parser stack state, not a keyring. The concept of \"state transitions\" is loosely analogous to stack operations, but the security context (permissions) is completely absent. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Keyring state transitions must maintain consistent permission requirements"
      },
      {
        "score": 6,
        "reasoning": "The function handles string data (e.g., `ent1->varname`, `Z_STRVAL(ent1->data)`). For the `EL_BINARY` case, it decodes base64 data. The specification about character encoding validation and domain-specific size constraints could apply to validating the decoded binary data or the strings used (e.g., class names). However, the code does not show explicit size or encoding validation. Relevance is moderate as the principle is important for safe deserialization.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 8,
        "reasoning": "The code performs array and hash table operations (`zend_hash_next_index_insert`, `zend_symtable_str_update`, `zend_hash_merge`). These operations require that the target hash table (`target_hash`) is valid and that indices/keys are safe to use. While there is some validation (checking `ent2->type` and `Z_TYPE`), the specification's principle of pre-access validation of computed indices is strongly relevant to preventing out-of-bounds or type confusion issues in these operations.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2016-8670_before_exclude_100:a1898d82:spec": {
    "timestamp": "2026-01-16T22:45:53.371167",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a1898d82",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code is a CIN/DPX image parser that validates critical header fields early (magic number, orientation, channel count, dimensions). It checks the 4-byte magic number and throws an exception if invalid, directly applying the principle of validating critical headers before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs some size validation before memory operations (e.g., checking `cin.file.user_length > GetBlobSize(image)` before allocating a StringInfo profile). However, it lacks explicit pre-validation for other allocations like quantum_info and pixels, which are acquired without prior size checks.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The parser validates structural relationships between header fields, such as checking `cin.file.image_offset > 2048` before reading film/user data, and verifying that `(image->columns * image->rows / 8) <= GetBlobSize(image)` to ensure sufficient image data. This aligns with validating structural integrity.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses loops with bounds (e.g., `for (i=0; i < 8; i++)` for channels) which are safe against the fixed-size array `cin.image.channel[8]`. However, it does not explicitly validate array indexing for dynamically derived values like `cin.image.number_channels` against allocated memory bounds later in processing.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code implements comprehensive error handling with resource cleanup: uses `ThrowReaderException` on errors, properly destroys images (`DestroyImageList`), frees quantum info (`DestroyQuantumInfo`), and closes blobs. Cleanup paths are present for allocation failures and corrupt data.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code initializes the `cin` struct with `memset(&cin,0,sizeof(cin))` before use. However, not all allocated memory (e.g., `pixels` from `GetQuantumPixels`) is explicitly initialized before use, though the image background is set via `SetImageBackgroundColor`.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. Error handling paths maintain consistent object states: on failure, images are destroyed, blobs are closed, and resources are freed. The function returns NULL or destroyed images consistently, avoiding resource leaks and inconsistent states.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2011-1003_after_exclude_100:566d15ce:spec": {
    "timestamp": "2026-01-16T22:45:53.691621",
    "cve_id": "CVE-2011-1003",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "566d15ce",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code shows memory allocation (e.g., `efree(ent1->varname)`) and data structure initialization. However, there's no explicit evidence of newly allocated memory being fully initialized (like zeroing) before use. The relevance is moderate because memory management is present, but the specific requirement for initialization is not clearly demonstrated or violated in the visible code paths.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The code contains multiple early returns and error paths (e.g., when `Z_TYPE(ent1->data) == IS_UNDEF` or when a non-existent field is detected). These paths free memory and adjust stack state, aiming for consistency. However, the overall consistency of object states (especially for the `wddx_stack` and its entries) across all error paths is not fully verifiable from this snippet alone. Moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 8,
        "reasoning": "This function is part of a WDDX (Web Distributed Data eXchange) deserialization handler, which processes XML input (a network/data protocol). The code validates the element `name` against a list of expected tags and performs operations like base64 decoding for `EL_BINARY`. However, it lacks deeper validation of the actual data content (e.g., the decoded base64 string, or the values being inserted into arrays/objects). Strong relevance as it is a protocol handler, but input validation is limited to tag names.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code deals with XML deserialization into PHP data structures (arrays, objects). There is no concept of keyrings, key management, or permission validation. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Keyring modification operations must enforce complete permission validation regardless o..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns security behaviors and explicit configurations, likely in an authentication/access control context. This code is a data parsing function with no security policies, access controls, or configuration comparisons. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-AUTH-002: Default security behaviors must maintain equivalent protection to explicit configuratio..."
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, this is about keyring state and permission requirements. The code has no keyring operations. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Keyring state transitions must maintain consistent permission requirements"
      },
      {
        "score": 5,
        "reasoning": "The code handles character data (e.g., `ent1->varname`, string data in `ent1->data`). It performs a `zend_str_tolower` on a class name, but there is no explicit validation for encoding (e.g., UTF-8) or enforcement of domain-specific size constraints (e.g., maximum length for varname or decoded binary data). Weak relevance because it processes strings but lacks the prescribed validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 5,
        "reasoning": "The code performs array/object property insertion using `zend_symtable_str_update` and `zend_hash_next_index_insert`. These are HashTable operations. While the PHP internal functions likely perform bounds checking, the code does not show explicit pre-access validation of computed indices (e.g., checking if an index is within bounds before insertion). However, the context of stack manipulation (`stack->top` checks) shows some index validation. Moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2016-8670_after_exclude_100:d22eea59:spec": {
    "timestamp": "2026-01-16T22:46:01.452900",
    "cve_id": "CVE-2016-8670",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d22eea59",
    "scores": [
      {
        "score": 9,
        "reasoning": "HS-INPUT-001 is highly relevant. The code validates critical header fields like the magic number (\"\\200\\052\\137\\327\"), checks that `cin.file.image_offset` is not too small (>= 712), and validates structural relationships (e.g., checking offset against file size). This directly aligns with the specification's requirement to validate all critical header fields before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-002 is moderately relevant. The code does some size validation before memory allocation (e.g., checking `cin.file.user_length > GetBlobSize(image)` before creating a StringInfo profile). However, it does not extensively pre-validate all size parameters (like those derived from image dimensions and depth) before internal allocations during pixel processing. The main allocation (AcquireImage, AcquireQuantumInfo) relies on library functions.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "HS-PROTOCOL-003 has very low relevance. This specification is specifically for BMP parsers, but the target code is for reading CIN/DPX image files, not BMP. The code does not process BMP bit count fields.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 9,
        "reasoning": "HS-INPUT-001 (second instance) is highly relevant. The code validates structural relationships between header fields, such as ensuring `cin.file.image_offset` is consistent with file size, checking that `offset` reaches the image data offset, and verifying that the calculated image data size (`image->columns * image->rows / 8`) does not exceed the file size. This is a direct application of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 6,
        "reasoning": "HS-MEM-002 (second instance) has moderate relevance. The code uses loops with bounds (e.g., `for (i=0; i < 8; i++)` for reading channel data) which are safe against the fixed-size array `cin.image.channel[8]`. However, for pixel data processing, it relies on `GetBytesPerRow` and `ReadBlobStream` to handle the buffer `pixels`, whose size is managed by `GetQuantumPixels`. There is no explicit bounds check for the `pixels` array index during the import operation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 8,
        "reasoning": "HS-IO-003 is strongly relevant. The code implements comprehensive error handling using `ThrowReaderException` and `ThrowFileException` for various error conditions (corrupt header, insufficient data, memory allocation failure). It also performs resource cleanup (e.g., `DestroyImageList(image)`, `DestroyQuantumInfo(quantum_info)`, `DestroyStringInfo(profile)`) on error paths and before returning.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 8,
        "reasoning": "HS-MEM-001 is strongly relevant. The code initializes the `cin` structure with `memset(&cin,0,sizeof(cin));` before use. It also initializes `cin.origination.serial` with `memset` before reading into it. This ensures no uninitialized memory is used in subsequent operations or comparisons.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "HS-STATE-002 is strongly relevant. The code maintains consistent object states in error handling paths. For example, if `SetImageExtent` fails, it returns `DestroyImageList(image)`, ensuring no partially initialized image is propagated. Similarly, if pixel reading fails mid-loop, it breaks and proceeds to cleanup, eventually closing the blob and returning the image (which may be partially read but still in a defined state).",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2011-3603_before_exclude_100:1e7e2d84:spec": {
    "timestamp": "2026-01-16T22:46:32.163726",
    "cve_id": "CVE-2011-3603",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1e7e2d84",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing. It processes mount options by concatenating strings based on flags, but there is no regex engine or pattern matching that would need to handle embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not compile or process patterns with escape sequences. It builds a string of mount options using simple string concatenation based on bit flags.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "The code uses `calloc` to allocate memory for `mountent.mnt_opts`, which initializes it to zero. This is good practice. However, the relevance is moderate because the primary security concern here is buffer overflow prevention (handled by `strlcat`), not uninitialized memory use.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error handling paths (e.g., after `lock_mtab`, `setmntent`). It generally attempts to maintain consistency by calling cleanup functions like `unlock_mtab` and `toggle_dac_capability` before returning. However, the `goto add_mtab_exit` label ensures some cleanup, but the order and completeness of state restoration on all error paths could be scrutinized.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code does not handle network protocols. It updates a local mount table file (`/etc/mtab` or similar). Input validation is performed indirectly via the flags parameter and string length checks, but it is not related to network input.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "The code deals with privilege management. It calls `setreuid` to drop privileges and uses `toggle_dac_capability` (likely toggling Linux capabilities like `CAP_DAC_OVERRIDE`). A failure in this privilege separation (e.g., if `setreuid` fails) is logged, but the process does not immediately terminate; it returns an error code (`EX_FILEIO`). This is a deviation from the specification's requirement for immediate termination, making the specification highly relevant for critique.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 8,
        "reasoning": "The code performs security-critical state transitions: changing process privileges (`setreuid`, `toggle_dac_capability`) and locking a shared resource (the mount table). It verifies the success of these operations (e.g., checking `rc` after `setreuid`). However, the atomicity of the entire sequence (privilege drop, signal blocking, capability toggling, file locking) could be a concern, as an interruption between steps might leave the process in an inconsistent state. The use of `sigprocmask` to block signals during critical sections is a relevant but partial mitigation.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2015-1191_before_exclude_100:a58335b1:spec": {
    "timestamp": "2026-01-16T22:46:39.209579",
    "cve_id": "CVE-2015-1191",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a58335b1",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `std::unique_ptr<InputStream>` for resource management, which guarantees cleanup via RAII when the pointer goes out of scope. This directly aligns with HS-MEM-001's principle of having guaranteed cleanup paths for allocated resources.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Resource allocation must have guaranteed cleanup paths"
      },
      {
        "score": 7,
        "reasoning": "The function performs file operations (delete, create, write, symbolic link creation) and attempts to maintain consistency by checking for failures and returning error results. However, it lacks transactional safety (e.g., if writing a file fails mid-stream, a partially written file may remain). The principle of maintaining consistent state during failures is relevant but not fully implemented.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File operations must maintain consistent state during failures"
      },
      {
        "score": 6,
        "reasoning": "Error handling is present via `Result` returns, which helps maintain object lifecycle invariants by preventing invalid state propagation. However, the function's impact on the `ZipFile` object's own state is minimal; the main concern is external file system state. The principle applies moderately.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Error handling must maintain object lifecycle invariants"
      },
      {
        "score": 5,
        "reasoning": "The code attempts cleanup by deleting existing files before overwriting and creating parent directories. However, as noted for spec_2, incomplete file writes or symbolic link creation failures could leave residual resources (partial files). The specification's principle is relevant but not fully satisfied.",
        "spec_index": 3,
        "spec_preview": "HS-IO-002: File operation failures must ensure complete resource cleanup"
      },
      {
        "score": 7,
        "reasoning": "All exit paths return a `Result`, and the `std::unique_ptr` ensures the input stream is cleaned up. However, the consistency of the external file system state is not guaranteed on all failure paths (e.g., partial writes). The principle of maintaining consistent resource state on exit is relevant but partially addressed.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-003: Function exit paths must maintain consistent resource state"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve explicit buffer allocation or operational padding calculations. It uses high-level stream operations. This specification is essentially irrelevant to the given code scenario.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code deals with general zip file extraction, not specifically with image compression operations or encoder buffers. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "There are no explicit array write operations or bounds validation against allocated sizes in this code snippet. It operates on file streams and strings at a high level. This specification is not relevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      }
    ]
  },
  "CVE-2015-1191_after_exclude_100:0c9ba7e2:spec": {
    "timestamp": "2026-01-16T22:46:41.380847",
    "cve_id": "CVE-2015-1191",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0c9ba7e2",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses std::unique_ptr for InputStream, which guarantees cleanup via RAII. However, the FileOutputStream is not managed by a smart pointer and its cleanup on failure paths (e.g., if writing fails) is not explicitly shown, though its destructor likely handles basic cleanup. The principle of guaranteed cleanup is partially followed.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Resource allocation must have guaranteed cleanup paths"
      },
      {
        "score": 7,
        "reasoning": "The function performs file operations (delete, create directory, write). It attempts to maintain consistency by checking for existing files and deleting before writing, and creating parent directories. However, if the write operation (out << *in) fails, the function returns a generic failure but may leave a partially written or empty target file, potentially breaking consistency.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File operations must maintain consistent state during failures"
      },
      {
        "score": 5,
        "reasoning": "Error handling is present via Result returns, but object lifecycle invariants are not a primary focus here. The function manages local resources (streams, file handles) and ensures they are cleaned up on exit, but there's no complex object state beyond local variables.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Error handling must maintain object lifecycle invariants"
      },
      {
        "score": 5,
        "reasoning": "File operation failures are checked (deleteFile, createDirectory, output stream open), and the function returns early on failures. However, complete cleanup (e.g., removing a partially created file if writing fails) is not ensured. The FileOutputStream destructor closes the file, but the file may remain in an inconsistent state.",
        "spec_index": 3,
        "spec_preview": "HS-IO-002: File operation failures must ensure complete resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "All exit paths return a Result, and resources (InputStream, FileOutputStream) are stack-allocated or managed by unique_ptr, so cleanup occurs. However, as noted, partial file writes on failure could leave the filesystem in an inconsistent state, not fully maintaining consistent resource state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-003: Function exit paths must maintain consistent resource state"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve buffer allocation with padding or safety margins. It uses high-level streams and strings, not low-level buffers.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code deals with zip file extraction, not image compression. No encoder buffers or bounds checking for compression operations are present.",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "No array write operations or explicit buffer allocations are visible in this code. It uses safe C++ abstractions like streams and strings.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      }
    ]
  },
  "CVE-2011-3603_after_exclude_100:555756dc:spec": {
    "timestamp": "2026-01-16T22:46:42.316940",
    "cve_id": "CVE-2011-3603",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "555756dc",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing. It processes mount options by concatenating strings based on flags, but there is no regex engine or pattern matching that would need to handle embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile or process patterns with escape sequences. It constructs a mount options string from predefined flag checks, not from user-provided pattern strings requiring escape sequence handling.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2016-5844_before_exclude_100:cd6da450:spec": {
    "timestamp": "2026-01-16T22:47:09.163386",
    "cve_id": "CVE-2016-5844",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cd6da450",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor manipulation and grouping operations. There are no cryptographic operations on secret values present in this code. The specification is about cryptographic constant-time execution, which is completely unrelated to the tensor processing logic.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or cryptographic operations. It's purely focused on tensor data structure manipulation for machine learning operations, making this specification irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "No cryptographic processing occurs in this code. The operations involve tensor indexing, value copying, and sparse tensor management without any cryptographic algorithms or secret data handling that would require constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs bounds validation through OP_REQUIRES checks on tensor dimensions and indices. It validates that indices are within expected ranges (b > -1 && b < N) and checks tensor shape compatibility. However, this is not about fixed buffers but dynamic tensor data structures.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code extensively validates input sizes before processing: checks tensor shapes (IsMatrix, IsVector), validates dimension matching between indices and values, validates rank > 1, and performs overflow checking on shape element multiplication. This aligns with the principle of complete input size validation before processing.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code enforces structural constraints on sparse tensor data: validates matrix/vector shapes, dimension matching, rank requirements, and index validity. While not a configuration parser, it enforces structural constraints on input data similar to the specification's intent.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code explicitly performs overflow-protected calculations using MultiplyWithoutOverflow() when computing new_num_elements from input shape dimensions. It checks for overflow (new_num_elements < 0) and handles it appropriately, which directly aligns with the specification's requirement for overflow-protected calculations in memory-related operations.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations for memory allocation must use overflow-protected calculations w..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code validates tensor dimensions and performs overflow checking on shape element multiplication (similar to maximum allocation size checks), it's not specifically about image dimensions. The code processes general sparse tensors, not images, so the connection is indirect.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Image dimension validation must include maximum allocation size checks before processi..."
      }
    ]
  },
  "CVE-2019-25034_after_exclude_100:473f8495:spec": {
    "timestamp": "2026-01-16T22:47:23.948856",
    "cve_id": "CVE-2019-25034",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "473f8495",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via MALLOC but does not fully initialize the allocated structure (Bigint). It sets `rv->sign` and `rv->wds` to 0, but the memory for `rv->x` (the array of Longs) is left uninitialized. This is a direct violation of HS-MEM-001, making the specification highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has an error handling path when `MALLOC` fails. It unlocks the mutex before calling `zend_error`, which maintains the mutex state consistency. However, the function does not return a value in the error path (it calls `zend_error` which may not return), potentially leaving the caller with an inconsistent expectation. The principle of maintaining consistent states applies, giving it moderate to strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is a memory allocator function (`Balloc`). It does not handle network protocols or process any external network input. The specification is not relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code uses a mutex (`dtoa_mutex`) to protect the shared resource `freelist[k]` and its associated state transitions (checking if `freelist[k]` is non-null and updating it). This is a direct application of protecting shared resource state transitions, making the specification highly relevant. The check and update are performed within the mutex lock, ensuring atomicity.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The code manages a resource (memory blocks for Bigint) tracked by the `freelist` array. When allocating from the freelist, it updates the `freelist[k]` pointer. When allocating new memory, it initializes `rv->k` and `rv->maxwds`. This involves maintaining consistency between the tracking structure (`freelist`) and the allocated object's metadata. The specification's principle applies directly.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "The code uses a mutex to guarantee thread-safety for concurrent access to the `freelist`. While the specification specifically mentions \"filesystem metadata operations,\" the core principle of guaranteeing thread-safety for concurrent access patterns is strongly present in the code. The relevance is moderate because the context (memory allocator vs. filesystem) differs.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsers or process input patterns. The specification is not relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers, escape sequences, or processing of any textual patterns. The specification is not relevant.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-18249_before_exclude_100:ed7c9583:spec": {
    "timestamp": "2026-01-16T22:47:25.880694",
    "cve_id": "CVE-2017-18249",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ed7c9583",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via MALLOC but only partially initializes the returned Bigint structure (setting sign and wds to 0). The fields within the allocated memory block (especially the array portion for `rv->x`) are not initialized before the object is returned, which could lead to the use of uninitialized memory. This directly relates to HS-MEM-001's requirement for full initialization before use.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code lacks explicit error handling for the MALLOC failure case. If MALLOC returns NULL, the function proceeds to dereference rv (rv->k, rv->maxwds), leading to undefined behavior. This creates an inconsistent state on the error path, which is the concern of HS-STATE-002. However, the specification's focus on \"object states\" is more general than this specific memory allocation failure scenario.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is a memory allocator utility function (Balloc) for big integers. It does not involve network protocol handling, input validation from network sources, or any network processing. HS-IO-003 is completely irrelevant to this context.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 10,
        "reasoning": "The code manages a shared resource (freelist array) accessed by multiple threads. It uses a mutex (dtoa_mutex) to protect the check of freelist[k] and the subsequent update (freelist[k] = rv->next) or the allocation path. This is a classic example of protecting shared resource state transitions with a lock, making HS-TIMING-001 highly relevant and directly applicable.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 9,
        "reasoning": "The function manages a free list (freelist) for Bigint objects. When an object is taken from the freelist, the list pointer is updated (freelist[k] = rv->next). The code must ensure consistency between the freelist data structure and the state of the allocated object (which is now marked as in-use). While the mutex protects the update, the specification's principle of maintaining strict consistency between tracking structures (the freelist) and the resource state is strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 6,
        "reasoning": "The code uses a mutex to guarantee thread-safety for concurrent access to the freelist. While HS-FS-003 is specifically about filesystem metadata operations, the core principle of guaranteeing thread-safety for concurrent access patterns is present and implemented here via the mutex lock/unlock. The relevance is moderate because the domain (memory allocator vs. filesystem) is different.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation and list management. It does not parse regular expressions, handle input patterns, or process NUL bytes in any string context. HS-INPUT-001 is completely irrelevant to this code scenario.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code is a memory allocator for big integers. It does not compile patterns, process escape sequences, or deal with any form of pattern compilation. HS-PROTOCOL-002 is completely irrelevant to this code's functionality.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-17787_before_exclude_100:2895e83c:spec": {
    "timestamp": "2026-01-16T22:47:54.361172",
    "cve_id": "CVE-2017-17787",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2895e83c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs PNG image decoding, not cryptographic operations on secret values. There is no handling of cryptographic keys, signatures, or any secret data that requires constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code is for PNG image processing and contains no elliptic curve cryptography implementations or any cryptographic operations related to curve models.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory operations for image buffer allocation and copying, but these are not cryptographic processing operations. There is no indication of secret data manipulation requiring constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer allocation for image data with bounds checking (width/height validation to prevent overflow). While not specifically about cryptographic padding, the principle of safe buffer allocation with bounds checking is relevant to preventing buffer overflows in image processing.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant as the code performs PNG image decompression with explicit bounds checking for width, height, and total size to prevent buffer overflows. It validates decoder buffer sizes before allocation, which directly aligns with the specification's focus on enforcing strict bounds checking for image compression operations.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code handles PNG image data, not cryptographic signatures or ASN.1 structures. There is no signature verification or ASN.1 parsing involved.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Cryptographic signature verification must validate all ASN.1 structure lengths against..."
      },
      {
        "score": 5,
        "reasoning": "The code is for PNG image decoding and contains no PKCS#1 v1.5 verification, RSA operations, or padding validation of any kind.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: PKCS#1 v1.5 verification must enforce minimum padding requirements regardless of publ..."
      },
      {
        "score": 5,
        "reasoning": "The code processes PNG image format, not X.509 certificates. There is no certificate parsing, structural metadata validation, or any PKI-related operations.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: X.509 parsers must validate all structural metadata before processing certificate c..."
      }
    ]
  },
  "CVE-2017-17787_after_exclude_100:ada0b9d9:spec": {
    "timestamp": "2026-01-16T22:47:54.581343",
    "cve_id": "CVE-2017-17787",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ada0b9d9",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs PNG image decoding, not cryptographic operations on secret values. There is no cryptographic processing involved.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is for PNG image processing, not elliptic curve cryptography. No cryptographic curve models are involved.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs image decoding operations, not cryptographic processing that requires constant-time memory operations. No secret data is being processed.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does perform buffer allocation for image data and includes bounds checking for width/height dimensions to prevent overflow. However, it doesn't specifically address cryptographic padding requirements mentioned in the specification.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code performs PNG image decompression with multiple bounds checks: verifying width/height don't overflow int, checking dimensions aren't too large (width/height < 2^27), and ensuring total_size < 2^29. This directly addresses buffer safety for image compression operations.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 1,
        "reasoning": "The code processes PNG image data, not cryptographic signatures or ASN.1 structures. No signature verification is performed.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Cryptographic signature verification must validate all ASN.1 structure lengths against..."
      },
      {
        "score": 1,
        "reasoning": "The code is for PNG image decoding, not PKCS#1 v1.5 verification. No RSA padding or public exponent handling is involved.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: PKCS#1 v1.5 verification must enforce minimum padding requirements regardless of publ..."
      },
      {
        "score": 5,
        "reasoning": "The code processes PNG image format, not X.509 certificates. No certificate parsing or structural metadata validation is performed.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: X.509 parsers must validate all structural metadata before processing certificate c..."
      }
    ]
  },
  "CVE-2018-14461_after_exclude_100:73ddd745:spec": {
    "timestamp": "2026-01-16T23:05:37.455346",
    "cve_id": "CVE-2018-14461",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "73ddd745",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via `slap_sl_malloc` and initializes the `ni.bv_val` buffer by copying characters from `is->bv_val`. The loop ensures each byte written is initialized. However, the allocation size is `ni.bv_len + 1`, and the null terminator is set at `ni.bv_val[dst] = '\\0'`, but the loop may not initialize all bytes if `src` increments past `is->bv_len` due to double quote handling. This is generally safe, but the initialization is data-dependent. The principle of fully initializing allocated memory is relevant and mostly followed.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function returns error codes (LDAP_INVALID_SYNTAX) on various validation failures. However, it does not always maintain consistent object states for output parameters (like `is` and `tu`) on error paths. For example, if an error occurs after partially modifying `is->bv_val` or `is->bv_len`, these output parameters may be left in an inconsistent state. The `ni` variable is only assigned to `*is` on success. The specification is moderately relevant as error handling exists but state consistency could be improved.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "The function is a parser for a GSER format string (likely from a network protocol). It performs extensive input validation: checking minimum length, braces, keywords, spaces, quotes, and field formats. It validates before processing each component. This is highly relevant to network protocol input validation.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "The code does not parse explicit length fields from a binary protocol. It works with a string (`berval`), and length checks are against fixed string literals (e.g., `STRLENOF(\"YYYYmmddHHmmssZ\")`). There are no integer overflow checks on `bv_len` manipulations (e.g., `x.bv_len -= STRLENOF(\"issuer\")` could underflow). However, the specification focuses on validating protocol message length fields against platform integer limits, which is not directly applicable here. Weak relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Memory allocation occurs in one place: `slap_sl_malloc( ni.bv_len + 1, ctx )`. The size `ni.bv_len` is derived from `is->bv_len - numdquotes`, both of which are bounded by the original input length. However, there is no explicit validation against allocation limits (e.g., maximum allowed size). The `+1` operation could theoretically overflow if `ni.bv_len` is `SIZE_MAX`. The code does not check for allocation failure. The specification is moderately relevant as allocation size is calculated from input but lacks explicit limit checks.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "The function parses a structured format with specific fields (`issuer` and `thisUpdate`). It enforces consistent handling: both fields must appear exactly once (checked via `have` flags), both must be quoted strings, and the issuer must have `rdnSequence:` prefix. The parser maintains state (`have`) to ensure all required components are present. This aligns with consistent type handling across processing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code validates length constraints, but they are not RFC-specified in the typical sense (e.g., for `thisUpdate`, it checks `tu->bv_len < STRLENOF(\"YYYYmmddHHmmssZ\")`, which is a format constraint). The issuer length is not validated against any RFC limit. The specification is weakly relevant because length checks exist but are for format correctness rather than RFC-mandated maximum lengths.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code parses a string-based TLV-like format (keywords followed by quoted values). It performs bounds checking before accessing `x.bv_val[]` by checking `x.bv_len` in loops and conditionals (e.g., `for ( ; (x.bv_val[0] == ' ') && x.bv_len; ...)`). Each decrement of `x.bv_len` is preceded by a check that the required substring is present. This is strong relevance to TLV/bounds checking principles.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2017-17787_before_exclude_100:aca3d5c6:spec": {
    "timestamp": "2026-01-16T23:06:42.430158",
    "cve_id": "CVE-2017-17787",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "aca3d5c6",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code is a file format parser for GIMP brushes, reading binary data. It does not involve regular expression parsing. The connection is weak, as both deal with input validation, but the core subject (regex vs. binary file) is different.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequence boundaries. The target code does not compile patterns or process escape sequences; it reads and validates a binary header, then loads raw image data. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The specification mandates length-aware operations for untrusted input. The code reads a `bn_size` from the file header and uses it to allocate and read data with `read(fd, temp, bn_size)`. It checks the read result against `bn_size`. This is a direct application of length-aware input handling for potentially untrusted file data, making it highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires validating length fields against integer limits. The code validates header fields like `width`, `height`, and `bytes` against `GIMP_MAX_IMAGE_SIZE` and checks for integer overflow using `G_MAXSIZE / bh.width / bh.height / bh.bytes < 1`. This is a direct validation of size fields derived from external input, showing strong relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires validating size parameters for allocation and usage. The code calculates `size = bh.width * bh.height * bh.bytes` only after validating these fields to prevent overflow (as noted for spec 4). It then uses this validated `size` for `g_malloc`. This is a direct and correct application of the principle, making it highly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification demands consistent type handling across protocol stages. The code parses a binary protocol (file format) and has logic to handle different versions (v1, v2, v3) and data types (bytes=1,2,4,18), converting them to internal types (GRAY, RGBA). There is some risk of inconsistency (e.g., version fallthrough logic), giving it moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires complete structural validation of external input. The code performs multiple validations: magic numbers, version checks, size field sanity checks, and read operation success checks. It validates the overall structure of the brush file before processing the main data. This aligns strongly with the specification's intent.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External input processing must enforce complete structural validation including termin..."
      },
      {
        "score": 10,
        "reasoning": "The specification mandates strict validation of all header fields before data processing. This is the core security activity of the function. It reads a `BrushHeader`, validates its fields (size, version, width, height, bytes, magic_number) for sanity and safety, and only proceeds to allocate memory and read the main data buffer after these checks. This is a textbook example of the specification's requirement, making it directly and highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: File format parsers must strictly validate all header fields before data processing"
      }
    ]
  },
  "CVE-2017-17787_after_exclude_100:3145cc9a:spec": {
    "timestamp": "2026-01-16T23:06:57.225999",
    "cve_id": "CVE-2017-17787",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3145cc9a",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code is a file format parser for GIMP brushes, not a regex parser. While it does read string data (the brush name) and checks for null termination, the core context (regex parsing) is not relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences; it reads binary data and interprets it as image pixels. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code reads a variable-length brush name from a file. It allocates a buffer based on `bn_size` and reads into it. It performs a length-aware check (`temp[bn_size - 1] != '\\0'`) to ensure the string is null-terminated, which is a core principle of this specification for untrusted input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates header fields like `width`, `height`, and `bytes` against maximum image size (`GIMP_MAX_IMAGE_SIZE`) and checks for integer overflow using `G_MAXSIZE / bh.width / bh.height / bh.bytes < 1`. This aligns with validating length fields against platform limits, though the context is a file format, not a network protocol.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code performs critical size validation before allocation. It checks that `width * height * bytes` does not overflow (`G_MAXSIZE / ... < 1`) and that the values are within sane bounds. This directly matches the requirement to validate size parameters against allocation limits and usage requirements for the subsequent `g_malloc(size)` call.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different versions (1, 2, 3) and data types (bytes=1, 2, 4, 18) of the brush format, ensuring consistent interpretation (e.g., converting version 1, handling float16 for version 3). This relates to enforcing consistent type handling, though the specification's \"protocol\" context is broader than this file parser.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code performs extensive structural validation on external input (the brush file). It validates header magic numbers, version, field ranges, string termination, and read operation success. This embodies the principle of complete structural validation for external input.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External input processing must enforce complete structural validation including termin..."
      },
      {
        "score": 10,
        "reasoning": "This is highly relevant. The code is a file format parser that strictly validates all header fields (`header_size`, `version`, `width`, `height`, `bytes`, `magic_number`, `spacing`) for sanity, range, and consistency before any significant data processing (like allocating and reading the brush buffer). This is a direct application of the specification.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: File format parsers must strictly validate all header fields before data processing"
      }
    ]
  },
  "CVE-2018-20750_before_exclude_100:b0a2cd73:spec": {
    "timestamp": "2026-01-16T23:07:11.464520",
    "cve_id": "CVE-2018-20750",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b0a2cd73",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code reads a protocol message length field `hdr.nSubrects` and uses it in a multiplication `hdr.nSubrects * (4 + (BPP / 8))` to determine the size of data to read. This multiplication must be validated for integer overflow before being used as a buffer size or loop counter. The check `hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE` partially validates against a maximum buffer size but does not check for integer wrap-around or negative values resulting from a maliciously large `nSubrects`. This is a direct application of the specification.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation but uses a fixed-size client buffer. The validation `hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE` is a pre-validation of a size parameter against an allocation limit (the buffer size). This aligns with the principle of guarding memory operations by validating size parameters, even though it's not a dynamic allocation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The protocol implementation reads a header and subrect data. It performs byte-order swapping (`rfbClientSwap32IfLE`) on `hdr.nSubrects` to ensure consistent handling. However, it does not perform similar swapping for the `pix` value read from the server or the subrectangle data in the buffer, which may be multi-byte values. This inconsistency in type handling (endianness) across processing stages is a protocol concern directly addressed by this specification.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain any explicit memory allocation operations (like malloc). It uses a pre-existing client buffer. Therefore, the specification about initializing allocated memory before use has very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error paths (return FALSE). It does not appear to modify complex object states before these error returns. The main \"object\" is the `rfbClient*`, but the function primarily reads data into its buffer. The error handling seems to leave the client in a consistent state (no partial updates), but this is a weak connection as the function's state management is simple.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a network protocol handler for the RFB (VNC) protocol. It reads multiple fields (`hdr.nSubrects`, `pix`, subrectangle data) directly from the network. The validation of `hdr.nSubrects` against `RFB_BUFFER_SIZE` is a critical input validation step performed before processing the bulk of the data. More validation (e.g., on `x, y, w, h` values) could be required, making this highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This function parses a CoRRE (Rise-and-Run-length Rectangle) encoded image rectangle from the RFB protocol. It reads a header containing `nSubrects`. The check on `nSubrects` is a validation of a critical header field performed before processing the subsequent subrectangle data. This is a direct and perfect application of the specification.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec_2, the code guards the use of the fixed-size `client->buffer` by pre-validating the calculated size `hdr.nSubrects * (4 + (BPP / 8))` against `RFB_BUFFER_SIZE`. This is the core principle of the specification, even though the \"allocation\" is static.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2018-14353_before_exclude_100:5f301891:spec": {
    "timestamp": "2026-01-16T23:07:21.418502",
    "cve_id": "CVE-2018-14353",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f301891",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes string literals with escape sequences, not regular expressions. While it handles embedded NUL bytes as string terminators, it's not a regex parser. The specification's core concern (regex patterns with NUL bytes) doesn't directly apply.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code processes potentially untrusted input strings. It uses length-aware operations via pointer arithmetic and the `len` allocation, but relies on scanning for quotes/terminators rather than an external length parameter. The `MB_PTR_ADV` and `MB_COPY_CHAR` macros handle multi-byte characters safely.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes character encodings via escape sequences and multi-byte characters (`mb_char2bytes`). It validates buffer boundaries before access in loops (checking `*p != NUL`), but the hex/unicode parsing loop could advance `p` without checking for NUL after `++p` in the `while` condition.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The parser maintains buffer state invariants by tracking `p`, `end`, `len`, and `extra`. It ensures the output buffer doesn't overflow (with a warning check). The state is updated consistently across escape sequence handling and interpolation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Encoding-specific processing occurs for Unicode/hex escapes and multi-byte characters. Boundary checking is present but not uniform; e.g., the hex/unicode loop checks `vim_isxdigit(p[1])` but may advance `p` near the end of the string.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Memory is allocated via `alloc(len)` and initialized by writing characters sequentially, terminating with NUL. However, the entire buffer isn't necessarily fully initialized before use (unused portions may contain garbage). The specification's focus on complete initialization is partially met.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Error handling paths (e.g., missing quote, stray '}') return `FAIL` early, maintaining consistent states. However, the `trans_special` error path may not fully clean up if `extra != 0` but the buffer check fails. Overall, error paths maintain reasonable state consistency.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2018-20750_after_exclude_100:a908594b:spec": {
    "timestamp": "2026-01-16T23:07:22.937880",
    "cve_id": "CVE-2018-20750",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a908594b",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code reads a protocol message header containing `hdr.nSubrects`, which is a length field. It performs a swap for endianness but does not validate this value against platform-specific integer limits (e.g., maximum positive value, overflow risks) before using it in multiplication for buffer size calculation. This is a direct protocol message length field handling scenario.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code uses a fixed-size buffer (`client->buffer`) and checks if `hdr.nSubrects` would exceed `RFB_BUFFER_SIZE / (4 + (BPP / 8))`. This is a validation of size parameters against allocation limits (the buffer size) and subsequent usage (the read operation). However, it does not explicitly guard against integer overflow in the multiplication `hdr.nSubrects * (4 + (BPP / 8))` before the division check, which is a subtle but important aspect of the specification.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles network data with potential endianness differences (swapping `hdr.nSubrects`). It uses types like `CARDBPP` and `uint8_t*` for pointer arithmetic. There is a risk of type inconsistency if `BPP` (bits per pixel) does not align with `sizeof(CARDBPP)` or if pointer arithmetic on `uint8_t*` is misaligned for the pixel data type. The specification applies to ensuring consistent type handling, which is relevant but not fully addressed.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform dynamic memory allocation; it uses a pre-existing buffer (`client->buffer`). The specification about initializing memory allocations before use is not directly applicable, as there is no explicit allocation in this function. The buffer is assumed to be managed elsewhere.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error paths returning `FALSE`. However, it does not show cleanup of resources or state consistency maintenance (e.g., if `client->GotFillRect` fails or if partial reads occur). The `client` object's state might be left inconsistent. The specification has weak relevance because error handling is present but its completeness is unclear.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The function is a network protocol handler for RFB (VNC). It reads multiple fields from the network (`hdr`, `pix`, subrect data) and uses them in calculations and function calls. Validation of `hdr.nSubrects` is performed against buffer size, but other inputs like `x, y, w, h` from the subrect data are not validated against the bounds of `rx, ry, rw, rh`. This directly relates to validating input before processing.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The function parses a CoRRE (RRE) encoded image rectangle. It reads a header (`rfbRREHeader`) containing a critical field `nSubrects`. Validation of this field is done against buffer size, but not for reasonableness (e.g., non-negative, not excessively large relative to the rectangle dimensions). The specification about validating critical header fields before processing is highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 8,
        "reasoning": "Similar to spec_2, the code guards the buffer access by pre-validating `hdr.nSubrects` against `RFB_BUFFER_SIZE`. This is a form of guarding memory allocation/usage. However, the validation could be more robust by checking for integer overflow in the size calculation first. The principle of pre-validation directly applies.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2018-14353_after_exclude_100:4a232f61:spec": {
    "timestamp": "2026-01-16T23:08:00.094258",
    "cve_id": "CVE-2018-14353",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4a232f61",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes string literals with escape sequences, not regular expression patterns. While it handles embedded NUL bytes as part of string content (via \\x00, \\u0000, etc.), this is not a regular expression parser scenario. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively processes escape sequences (\\x, \\u, \\U, octal, \\<special>, etc.) and must maintain strict boundaries to prevent buffer overflows. The allocation size calculation (extra variable) and boundary checks during trans_special are critical to this specification.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function processes potentially untrusted input strings. It uses length-aware operations through the calculated 'len' and checks boundaries (end >= rettv->vval.v_string + len). However, it relies on scanning for quotes rather than external length parameters.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes character encodings via \\u and \\U sequences using mb_char2bytes. It validates hex digits before processing, but the boundary checking during hex digit consumption (while loop) depends on vim_isxdigit checks rather than explicit buffer length checks.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The parser maintains buffer state through pointer 'p' and calculates allocation based on scanned content. The invariants between the scanning pass (for length calculation) and the copying pass must be consistent to prevent buffer overflows.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The encoding-specific processing for Unicode sequences uses mb_char2bytes which should handle boundaries, but the code doesn't show explicit boundary validation for the mb_char2bytes call. The uniform checking principle applies but isn't fully demonstrated.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Memory is allocated via alloc(len) and fully initialized through the copying loop, terminating with *end = NUL. However, the specification about full initialization before use is only partially relevant as the buffer is written sequentially.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Error handling paths return FAIL, but the function doesn't show complex object state cleanup. The rettv object's v_type is set before allocation success check, which could leave it inconsistent if alloc fails. Some state management exists but isn't comprehensive.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2017-9226_after_exclude_100:449bc658:spec": {
    "timestamp": "2026-01-16T23:08:29.239165",
    "cve_id": "CVE-2017-9226",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "449bc658",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not perform explicit memory allocation. It uses a `dp` pointer which is presumably managed by `save_string` and `save_char` functions, but the initialization of the memory they write to is not visible in this snippet. The relevance is weak because the specification is about initializing allocated memory, which is not the primary focus here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 4,
        "reasoning": "The code has limited error handling visible (e.g., checking for '\\0'). However, it does not manage complex object states or have clear error paths that could leave objects inconsistent. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "The function processes a character string but is not explicitly a network protocol handler. The input validation it performs (like checking for escape sequences and null bytes) is for general string conversion, not network-specific. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 7,
        "reasoning": "The function is a character converter that handles escape sequences (like octal digits) and must correctly process NUL bytes ('\\0') in the input string, as shown in the switch cases. This aligns with the need to handle embedded NUL bytes in input patterns, giving moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The function is a pattern compiler component that processes escape sequences (backslash and caret) for terminfo pushes. It must maintain strict boundaries when interpreting these sequences to prevent overruns or incorrect parsing, which is the core of its logic.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The function processes input via a pointer (`sp`) but does not use explicit length-aware operations (like `strn` functions). It relies on null-termination and careful pointer increments. For untrusted input, this could be risky if the string is not properly terminated, giving moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The function performs character encoding conversion (e.g., octal to decimal, control character handling) but does not show buffer operations dependent on return values of encoding functions. The validation is done on the input characters directly. Relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 4,
        "reasoning": "The code does not show operations on fixed-size buffers. The `dp` pointer is used with `save_string`/`save_char`, but buffer sizes are not visible. The specification's focus on bounds checking for fixed buffers has weak connection to this snippet.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      }
    ]
  },
  "CVE-2014-0131_before_exclude_100:d9ef4fdf:spec": {
    "timestamp": "2026-01-16T23:08:39.655763",
    "cve_id": "CVE-2014-0131",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d9ef4fdf",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a kernel module close/cleanup function. It does not process userspace-provided array lengths. Its primary operations involve reference counting, synchronization, and resource deallocation, not input validation against system constraints.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The function handles teardown of a network device and its associated buffers. It does not parse or handle protocol messages or their variable-length components. The specification is related to message processing, not cleanup.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "The function frees previously allocated buffers (`rbuff`, `xbuff`) but does not perform any buffer allocation. The specification concerns allocation with size limits for worst-case input, which is not relevant to this deallocation path.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code performs no cryptographic operations. It deals with network device teardown, buffer freeing, and reference counting. The specification is completely unrelated to the code's purpose.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 1,
        "reasoning": "The code performs no cryptographic operations or data handling related to cryptography. It is a cleanup routine for a TTY line discipline network driver.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function uses `kfree` on kernel heap buffers, which is generally safe regardless of `VMAP_STACK`. However, the function itself does not explicitly handle stack pointers or have operations whose safety depends on the `VMAP_STACK` configuration. The connection is indirect at best.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function uses a lock (`disc_data_lock`) to atomically retrieve and clear the `tty->disc_data` pointer, preventing concurrent access during teardown initialization. The reference count check (`refcount_dec_and_test`) and subsequent wait (`wait_for_completion`) also manage concurrent resource finalization, aligning with the specification's principle of atomic state management under synchronization.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function meticulously manages shared state transitions: 1) It uses a lock to isolate the `tty->disc_data` pointer. 2) It uses reference counting (`ax->refcnt`) to ensure all existing users finish before proceeding with destruction. 3) It stops the network queue (`netif_stop_queue`) to prevent new operations. 4) It sets `ax->tty = NULL` and frees resources in a specific order. This demonstrates maintaining consistency invariants across access paths during a state transition to \"closed\".",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2017-18249_after_exclude_100:f346a2fc:spec": {
    "timestamp": "2026-01-16T23:08:46.695952",
    "cve_id": "CVE-2017-18249",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f346a2fc",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a kernel module close function handling internal cleanup, not processing userspace-provided array lengths. No direct user input validation occurs here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The function is a cleanup routine, not a protocol message handler. It deals with resource deallocation, not parsing or validating variable-length protocol components.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The function frees previously allocated buffers (rbuff, xbuff) but does not perform any new buffer allocation based on input scenarios. Allocation logic would be elsewhere.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "No cryptographic operations are present in this code. The function handles network device cleanup, not cryptography.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 1,
        "reasoning": "No cryptographic operations or memory-safe cryptographic interfaces are used in this network device cleanup routine.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function uses kfree() on kernel heap buffers, not stack memory. However, proper cleanup of kernel data structures is generally important, but VMAP_STACK implications are not directly addressed here.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses locking (disc_data_lock) to protect the tty->disc_data pointer during cleanup. It ensures atomic check-and-set operations for shared resource (disc_data) under lock, preventing race conditions during close operations.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code manages shared state transitions (tty->disc_data, ax->refcnt) with proper locking and reference counting. It uses refcount_dec_and_test() and wait_for_completion() to ensure all users finish before cleanup, maintaining consistency invariants across access paths during shutdown.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2017-9228_before_exclude_100:81845804:spec": {
    "timestamp": "2026-01-16T23:10:21.157483",
    "cve_id": "CVE-2017-9228",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "81845804",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code is part of a regular expression compiler (PCRE2) that processes character classes. It reads pattern data (cc pointer) which could contain embedded NUL bytes since PCRE2 patterns are binary-safe. The code uses pointer arithmetic and reads characters without explicit NUL termination checks (relies on XCL_END marker), making proper handling of embedded NULs relevant to avoid misinterpretation of pattern boundaries.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 7,
        "reasoning": "This function compiles extended character class matching paths, which involves processing escape sequences in regex patterns (like \\x, \\u, property escapes \\p{...}). While the actual escape sequence parsing likely happens earlier, this code processes the compiled representation and must maintain boundaries when interpreting character codes and property values to prevent over-reading.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: State machine transitions must maintain valid state invariants"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array index operations require validation of all input values"
      }
    ]
  },
  "CVE-2017-9228_after_exclude_100:b5d4a393:spec": {
    "timestamp": "2026-01-16T23:10:37.412760",
    "cve_id": "CVE-2017-9228",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b5d4a393",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code is part of a regular expression compiler (PCRE2) that processes character classes. It reads characters from the pattern input (cc pointer) using macros like GETCHARINCTEST which handle multi-byte characters. While it doesn't explicitly show NUL byte handling, the code's purpose is pattern compilation, making embedded NUL byte handling in input patterns a relevant security concern for the overall system.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 7,
        "reasoning": "The code compiles extended character classes (XCL) from regex patterns, which involve parsing escape sequences and property specifications (like PT_SC, PT_GC). It must maintain strict boundaries when processing these sequences to prevent over-reads. The code uses pointer arithmetic and checks for XCL_END, showing boundary awareness, making the specification moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: State machine transitions must maintain valid state invariants"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array index operations require validation of all input values"
      }
    ]
  },
  "CVE-2016-10154_before_exclude_100:37675091:spec": {
    "timestamp": "2026-01-16T23:10:40.415557",
    "cve_id": "CVE-2016-10154",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "37675091",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process any userspace-provided array lengths. It allocates a fixed-size internal structure and calls a DMA API function. There is no direct validation of user-controlled array sizes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The code is not a protocol message handler. It is a DMA buffer attachment function for a kernel driver. It does not parse or process variable-length protocol components.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code performs a single `kzalloc` for a fixed-size structure (`struct fastrpc_dma_buf_attachment`), which is not directly influenced by user input size. However, the `buffer->size` is used in the DMA call, and if this size came from an untrusted source and was not validated earlier, it could be a concern. The specification's principle of accounting for worst-case input is indirectly related but not the core activity here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code manages a shared resource (the list of attachments `buffer->attachments`). It uses a mutex (`buffer->lock`) to protect the state transition (adding a new attachment node to the list). This aligns with the principle of protecting shared resource state transitions.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function allocates a resource (`struct fastrpc_dma_buf_attachment *a`), initializes it, and adds it to two tracking structures: 1) setting `attachment->priv = a`, and 2) adding `a` to `buffer->attachments` list. Maintaining consistency between these two references is crucial for correct state management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 4,
        "reasoning": "The code is not performing filesystem metadata operations. It is managing DMA buffer attachments in a kernel driver. The concurrency protection (mutex) is for a driver-specific list, not a filesystem structure.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code has nothing to do with USB request processing. It is part of a DMA buffer management routine for a different subsystem (likely related to FastRPC).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code has nothing to do with USB/IP protocol implementation or packet structure validation. It is a DMA buffer attachment function.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2010-1311_after_exclude_100:c2c5ca16:spec": {
    "timestamp": "2026-01-16T23:11:51.915618",
    "cve_id": "CVE-2010-1311",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c2c5ca16",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code initializes arrays like `tab_suffixof` and `tab_prefixof` before use (e.g., loop `for (code = 255 ; code >= 0 ; --code)`). However, there is potential for uninitialized memory use in buffers like `inbuf` and `outbuf` if read/write operations fail or if logic errors occur. The specification is highly relevant as proper initialization prevents information leaks and undefined behavior.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has error handling paths (e.g., `read_error()`, `gzip_error()`), but they may not consistently maintain object states. For example, after `gzip_error()` is called, the function may exit without cleaning up buffers or resetting global state. The specification is moderately relevant because error handling exists but may not ensure consistency.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "The code processes input from a file descriptor, not network protocol data. While input validation occurs (e.g., checking `maxbits > BITS`, validating `code` values), it is not specifically for network protocols. The specification has very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code implements LZW decompression, not regular expression parsing. There is no handling of NUL bytes in patterns. The specification is irrelevant to this code scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It deals with LZW code streams, not textual patterns. The specification is irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "The code uses length-aware operations like `memcpy` with explicit size calculations and checks buffer boundaries (e.g., `outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ`). This is crucial for preventing buffer overflows when processing potentially untrusted compressed input. The specification is highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code validates some length constraints (e.g., `maxbits > BITS`), but it is not processing RFC-defined protocol messages. The validation is specific to LZW header fields, not general protocol message fields. The specification has weak relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code processes LZW codes which are similar to TLV (Type-Length-Value) structures in that they have variable-length codes. Bounds checking is performed (e.g., `code >= free_ent`, `code > free_ent` checks), but not comprehensively before all accesses. The specification has moderate relevance as the principle applies to decompression logic.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2010-1311_before_exclude_100:77239ddb:spec": {
    "timestamp": "2026-01-16T23:11:51.960501",
    "cve_id": "CVE-2010-1311",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "77239ddb",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code initializes data structures like tab_prefix and tab_suffix before use, which aligns with the principle of initializing memory. However, it's not about dynamic memory allocation (malloc), but about stack/global array initialization. The clear_tab_prefixof() call and the loop initializing tab_suffixof for codes 0-255 demonstrate proper initialization before use.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has error handling paths (e.g., read_error(), gzip_error()) that exit the function. While it maintains some state consistency by returning ERROR codes, the error paths often call functions that may exit the program entirely rather than cleaning up and returning gracefully. The state of global variables might not be fully consistent after errors.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 4,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This code implements LZW decompression, not regular expression parsing. There are no regex operations or pattern matching involved. The specification about embedded NUL bytes in regex patterns is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This is a decompression algorithm, not a pattern compiler. There are no escape sequences being processed. The code deals with LZW codes and dictionary management, not pattern compilation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code processes potentially untrusted compressed input and uses length-aware operations: memcpy with calculated lengths, bounds checking on outpos and OUTBUFSIZ, validation of code values against free_ent and maxcode. It carefully manages buffer boundaries when copying from stackp to outbuf.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code validates some constraints (maxbits <= BITS, code >= 256 checks), it's not implementing a network protocol with RFC-specified length constraints. It's a compression format with its own internal constraints, not an RFC protocol.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes variable-length LZW codes (similar to TLV in concept) and performs bounds checking: validating code against free_ent and maxcode before table access, checking outpos against OUTBUFSIZ. However, it's not traditional TLV parsing and some checks come after partial processing (like the code > free_ent check after some operations).",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2019-13219_before_exclude_100:3557e3bf:spec": {
    "timestamp": "2026-01-16T23:11:54.676456",
    "cve_id": "CVE-2019-13219",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3557e3bf",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory (LineContribType, ContribRow array, and Weights arrays) but does not initialize the contents before returning. This leaves the allocated memory with undefined values, which could lead to information disclosure or instability if used uninitialized. The specification about initializing memory before use is directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The error handling path (when overflow_error == 1 or malloc fails for Weights) attempts to clean up previously allocated Weights arrays and frees the main structure but does not free the ContribRow array itself before returning NULL. This creates an inconsistent state (memory leak) and is a direct violation of maintaining consistent object states during error handling.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is a memory allocation helper function for image resizing, not a network protocol handler. There is no network input processing involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation and arithmetic overflow checks. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not compile patterns, process escape sequences, or handle any form of pattern language. It is a low-level memory allocation routine.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 2,
        "reasoning": "The code does not process strings. It handles numeric parameters for memory allocation sizes and performs overflow checks, but string operations are not present.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "While not dealing with network protocol messages, the code validates the `line_length` and `windows_size` parameters against integer overflow before using them in memory allocation calculations (using `overflow2`). This aligns with the core principle of validating size parameters against integer limits before usage, though the context is not network-specific.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 10,
        "reasoning": "This specification is highly relevant. The code explicitly performs overflow checks (`overflow2`) on size calculations (`line_length * sizeof(ContributionType)` and `windows_size * sizeof(double)`) before passing them to `gdMalloc`. This directly validates size parameters against allocation limits and subsequent usage requirements to prevent integer overflow vulnerabilities.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2019-13219_after_exclude_100:4502dad1:spec": {
    "timestamp": "2026-01-16T23:12:02.876337",
    "cve_id": "CVE-2019-13219",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4502dad1",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory for `res->ContribRow` and for each `Weights` array but does not initialize the contents of these allocated memory blocks (e.g., using `memset`). This leaves the memory with indeterminate values, which violates the principle of initializing memory before use. However, the function is an allocator, and initialization might be the responsibility of the caller, making it slightly less direct.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code demonstrates strong error handling that maintains consistent object states. When an allocation fails (for `res->ContribRow[u].Weights`), it properly cleans up all previously allocated `Weights` arrays, frees `res->ContribRow`, and then frees `res` itself before returning NULL. This prevents memory leaks and ensures no partially allocated object is left behind.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is a memory allocation helper function for image resizing. It does not handle network protocols, receive network input, or contain any network-related logic. The specification is completely irrelevant to this context.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation and arithmetic overflow checks. It does not parse or process regular expressions, nor does it handle input patterns containing NUL bytes. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code is not a pattern compiler and does not process escape sequences. It deals with memory allocation for contributions in a graphics library. This specification has no connection to the code scenario.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The function does not process strings. It allocates memory for structures and arrays of doubles. There is no use of string functions (like strcpy, strlen) or untrusted string input involved.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The function validates for arithmetic overflow but does not process protocol messages or their length fields. The parameters `line_length` and `windows_size` are not from a network protocol. The specification's context does not match.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 10,
        "reasoning": "This specification is highly relevant and directly applies. The code explicitly uses `overflow2` to validate size parameters (`line_length * sizeof(ContributionType)` and implicitly `windows_size * sizeof(double)`) against integer overflow before performing memory allocation. This prevents potential buffer overflows or allocation of incorrect sizes, which aligns perfectly with the specification's requirement to validate size parameters against allocation limits and usage requirements.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2010-4650_before_exclude_100:d6cd235c:spec": {
    "timestamp": "2026-01-16T23:13:11.723563",
    "cve_id": "CVE-2010-4650",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d6cd235c",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code handles I/O operations with user-provided data (iovec) and size (io_size). While it validates the read area via `rw_verify_area`, the primary validation of the protocol message length (the size of the read request) against platform-specific integer limits is not the core focus. The relevance is moderate because the code deals with user-controlled sizes but the specification is framed around protocol messages, which is a more specific context.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code uses `io_import_iovec` which likely validates and imports user-provided iovec structures, checking sizes against system constraints. Memory allocation for iovec (inline or heap via kfree) is involved. The specification's principle of validating size parameters against allocation limits and usage is relevant, as improper iovec handling could lead to overflow or excessive allocation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "This is highly relevant. The function processes userspace-provided I/O vectors (iovec array) and the associated length (io_size). The `io_import_iovec` function (called when `rw` is NULL) is responsible for validating these user-provided lengths against system constraints before they are used in `rw_verify_area` and the read operation. This is a core security requirement for this code.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2010-4650_after_exclude_100:72d278f2:spec": {
    "timestamp": "2026-01-16T23:13:16.595285",
    "cve_id": "CVE-2010-4650",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "72d278f2",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code is an I/O read handler for io_uring, which deals with file I/O operations, not protocol message parsing. There is a weak connection because the code handles a user-provided I/O size (`io_size`), but this is validated via `rw_verify_area` for file access bounds, not for protocol-specific integer overflow or platform limits.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns validating memory allocation size parameters. The code uses `io_import_iovec` which likely processes user-provided I/O vectors and may allocate memory. However, the validation details are hidden inside that function. There is a moderate connection because improper handling of user-controlled sizes could lead to allocation issues, but the core logic here focuses on I/O retry and async handling, not explicit size validation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing consistent type handling in protocol implementations. The target code is a kernel I/O subsystem function dealing with file reads, iterators, and async operations. There are no protocol messages or type consistency issues across processing stages as defined in network/serialization protocols.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating userspace-provided array lengths against system constraints. The code handles I/O vectors (via `iovec` and `iter`) which come from userspace. The `io_import_iovec` function (called when `rw` is NULL) is responsible for validating and importing these vectors. This is a core part of the function's safety, making it moderately relevant, though the validation is delegated.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about verifying structural integrity of variable-length components in protocol messages. The code deals with I/O vectors and iterators, which are variable-length in a sense, but they are kernel data structures for file I/O, not protocol messages. The integrity checks are related to I/O state (e.g., `iov_iter_reexpand`, `iov_iter_revert`) rather than protocol structure.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about buffer allocation accounting for worst-case input with explicit limits. The code may allocate buffers for I/O vectors, but the allocation logic is not visible here. The `io_size` is derived from `iov_iter_count(iter)`, which is based on user input, but there's no explicit discussion of worst-case limits or bounding in this snippet. The relevance is weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code performs file read operations, has no regular expression parsing, and does not process pattern strings. This specification is completely irrelevant to the code scenario.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers maintaining strict boundaries when processing escape sequences. The code is a file I/O handler, not a pattern compiler. There is no processing of escape sequences or pattern compilation. This specification is completely irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2016-3179_before_exclude_100:fb77763e:spec": {
    "timestamp": "2026-01-16T23:15:32.884228",
    "cve_id": "CVE-2016-3179",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fb77763e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `calloc` to allocate memory for the `PresentationContext` structure, which fully initializes it to zero. This is a good practice that directly aligns with HS-MEM-001. However, the specification is not perfectly followed for all allocations, as `Stream_New` and `BufferPool_Take` may not guarantee full initialization.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 10,
        "reasoning": "This code is a textbook example of the need for consistent state management in error handling. The function has a complex cleanup path with multiple `goto` labels (`error_yuv`, `error_surface`, etc.) that carefully unwind partially constructed objects in reverse order. This ensures no resources are leaked and the object state is consistent when an error occurs, which is the core principle of HS-STATE-002.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The target code is a constructor/initialization function for a presentation context. It does not contain any network protocol handling or direct input processing from a network source. Therefore, HS-IO-003 is not relevant to this specific code snippet.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This code does not parse or validate any protocol message length fields. The function parameters `x, y, width, height` are passed in but are used directly for size calculations and context creation without validation against integer limits, which is a separate issue covered by other specifications.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The code performs a critical memory size calculation `width * height * 4` for `surfaceData` allocation. There is no validation that this multiplication does not overflow a `UINT32`, nor is there validation that the resulting size is within reasonable allocation limits for the `BufferPool_Take` function. This is a direct violation of HS-MEM-002.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code creates decoder contexts (H.264, YUV) and a surface, but it does not show protocol parsing, serialization, or deserialization where type consistency across stages (e.g., client/server, encode/decode) would be a concern. Therefore, HS-PROTOCOL-003 has very low relevance here.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This specification is directly applicable. The code performs the mathematical computation `width * height * 4`. This operation must be checked for integer overflow before being used as an allocation size. The function also uses `width` and `height` to initialize video contexts; values of zero or extremely large dimensions could cause logical errors. The code lacks these explicit validations.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve processing codebooks (e.g., Huffman tables, quantization matrices). It initializes video decoding contexts and surfaces. Therefore, HS-INPUT-002 is not relevant to this code scenario.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      }
    ]
  },
  "CVE-2019-1010065_after_exclude_100:2bc5ea2c:spec": {
    "timestamp": "2026-01-16T23:16:03.257501",
    "cve_id": "CVE-2019-1010065",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2bc5ea2c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs arithmetic operations like `size = (*i)->data + bytes - 3;` and `bytes += sizeof(*dire);` within a loop. While there is some validation (e.g., checking `dir_count > SQUASHFS_DIR_COUNT`), there is no explicit validation that these additions/subtractions will not overflow the integer types (e.g., `int`, `long long`). This is directly relevant to HS-LOGIC-001.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 5,
        "reasoning": "The code is a filesystem parser (SquashFS). It validates structural fields like `dirh.count` against `SQUASHFS_DIR_COUNT` and `dire->size` against `SQUASHFS_NAME_LEN`. It also checks for invalid characters in names. This aligns strongly with the principle of validating all structural fields against logical/defined constraints.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code performs strict bounds checking for on-disk directory structures: it validates `dir_count` and `dire->size` before using them to calculate read sizes and memory accesses (e.g., `dire->name[dire->size + 1] = '\\0';`). This is a core security activity in the function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory via `malloc` for `dir` and `ent`. While `dir` has its fields initialized immediately after allocation, the `ent` structure's fields are all assigned before use. There is no evidence of uninitialized memory being read. The specification is only weakly relevant as the code appears to follow good practice here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has a `corrupted:` error handling path that calls `squashfs_closedir(dir)` and returns NULL. This likely cleans up allocated resources. However, it's not fully clear from this snippet if `squashfs_closedir` handles a partially constructed `dir` object (e.g., with some `dir_ent` nodes allocated) correctly. The presence of a dedicated cleanup path shows consideration for state consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification is about network protocol handlers. The target code is a filesystem parser, not a network protocol handler. The principle of validating input before processing is followed, but the context (network vs. filesystem) is different, making direct relevance very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code declares a buffer with `__attribute__((aligned))`, which explicitly addresses platform alignment requirements for the `struct squashfs_dir_entry` access. This is a direct, though localized, application of the specification's principle.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec_6, this specification is for network protocol implementations. The code parses a filesystem directory structure, not a network protocol message. While the high-level concept of validating structure applies, the domain mismatch significantly reduces relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      }
    ]
  },
  "CVE-2017-16914_before_exclude_100:194236c8:spec": {
    "timestamp": "2026-01-16T23:17:41.294163",
    "cve_id": "CVE-2017-16914",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "194236c8",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes SMBus/I2C protocol messages where `data->block[0]` acts as a length field for block operations (I2C_SMBUS_BLOCK_DATA, I2C_SMBUS_I2C_BLOCK_DATA). It validates this length against `I2C_SMBUS_BLOCK_MAX` to prevent overflow, which aligns with the specification's requirement to validate protocol message length fields against limits. However, the validation is specific to block data types and not all protocol message length fields (e.g., `desc->wr_len_cmd` is set from `dma_size` without explicit upper bound validation against a hardware descriptor limit).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code uses a fixed-size DMA buffer (`priv->buffer`) and calculates `dma_size` from user-controlled input (`data->block[0]`). It validates `dma_size` against `I2C_SMBUS_BLOCK_MAX` for I2C block operations, which relates to validating size parameters against usage requirements (buffer size). However, there is no explicit check that `dma_size` does not exceed the actual size of `priv->buffer` (which appears to be `ISMT_DMA_BUFFER_SIZE`), and no allocation limits are checked since memory is pre-allocated statically.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 10,
        "reasoning": "The code explicitly initializes memory before use: `memset(priv->buffer, 0, sizeof(priv->buffer))` initializes the DMA buffer, and `memset(desc, 0, sizeof(struct ismt_desc))` initializes the descriptor. This directly aligns with the specification requirement to fully initialize memory allocations before use, preventing information leaks and undefined behavior.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Error handling paths exist (e.g., for DMA mapping errors or timeouts), but the code may not fully maintain consistent object states. For example, on DMA mapping error, it returns `-EIO` without rolling back descriptor state or updating `priv->head`. On timeout, it jumps to `out` and increments `priv->head` even though the operation failed, potentially leaving the hardware in an inconsistent state. This partially relates to maintaining consistent object states in error paths.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 4,
        "reasoning": "The code uses a ring buffer (`priv->hw`) indexed by `priv->head` and updates `priv->head` modulo `ISMT_DESC_ENTRIES` at the end. However, there is no explicit atomic protection (e.g., locks or atomic operations) for this shared resource between concurrent calls, which could lead to race conditions if the function is reentrant. The specification about atomic check-and-update operations for shared resource state transitions is weakly relevant because the code lacks such protection.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2017-16914_after_exclude_100:8248ae0f:spec": {
    "timestamp": "2026-01-16T23:17:45.921583",
    "cve_id": "CVE-2017-16914",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8248ae0f",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes SMBus protocol messages where `data->block[0]` represents a length field. There is validation against `I2C_SMBUS_BLOCK_MAX` in the `I2C_SMBUS_BLOCK_PROC_CALL` and `I2C_SMBUS_I2C_BLOCK_DATA` cases, which is a form of platform-specific limit enforcement. However, the validation in `I2C_SMBUS_I2C_BLOCK_DATA` adjusts the value silently instead of returning an error, which is a weaker form of validation. The relevance is strong but not perfect.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code uses a statically allocated DMA buffer (`priv->buffer`). While not dynamic allocation, the principle of validating size parameters against usage requirements applies. The `dma_size` is derived from user-controlled `data->block[0]` and is used in `memcpy` and `dma_map_single`. There is some validation (e.g., checking against `I2C_SMBUS_BLOCK_MAX`), but the buffer size (`sizeof(priv->buffer)`) is fixed, and there's no explicit check that `dma_size` does not exceed this fixed buffer capacity, creating a potential buffer overflow. This is a moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code implements an I2C/SMBus protocol handler. It uses a `switch (size)` to handle different transaction types, ensuring consistent interpretation of the `size` parameter, `read_write` flag, and `data` union fields across different cases. The `desc->control` flags are set consistently per transaction type. However, there is a potential inconsistency in `I2C_SMBUS_BLOCK_PROC_CALL` where `desc->tgtaddr_rw` is hardcoded to `1` (write) for the initial phase, which might be protocol-correct but is a special case. Moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 10,
        "reasoning": "The code explicitly initializes key data structures before use: `memset(priv->buffer, 0, sizeof(priv->buffer));` and `memset(desc, 0, sizeof(struct ismt_desc));`. This prevents information leaks from kernel memory. This is a direct and perfect application of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has several error paths (e.g., `dma_mapping_error`, `!time_left`, unsupported transaction). On these error paths, it returns an error code but also jumps to `out:` which increments `priv->head` (the ring pointer). This means the ring pointer state is updated even on failure, which might be the intended hardware protocol but could be considered a state inconsistency if the descriptor wasn't processed successfully. The relevance is weak to moderate.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 8,
        "reasoning": "While this is not a network protocol but a hardware bus (I2C) protocol, the principle is analogous. The function acts as a protocol handler for SMBus/I2C transactions. It validates input parameters like `size`, `data->block[0]` length, and checks for valid ranges before processing (e.g., in `I2C_SMBUS_BLOCK_PROC_CALL` and `I2C_SMBUS_I2C_BLOCK_DATA`). However, the validation in `I2C_SMBUS_I2C_BLOCK_DATA` for the lower bound silently corrects the value, which is not strict validation. Strong relevance.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 4,
        "reasoning": "The code manages a hardware descriptor ring buffer indexed by `priv->head`. The update `priv->head++` and `priv->head %= ISMT_DESC_ENTRIES` at the end is not protected by any atomic or locking mechanism visible in this function. If this function can be called concurrently (e.g., from multiple threads), this would be a race condition. However, the typical pattern for such low-level hardware access is that the adapter is called under an i2c lock, providing serialization externally. The specification has weak relevance as the code itself does not implement the protection.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2013-1978_before_exclude_100:1a07d32e:spec": {
    "timestamp": "2026-01-16T23:19:19.710990",
    "cve_id": "CVE-2013-1978",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1a07d32e",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code reads data into a pre-existing struct but does not perform memory allocation itself. The relevance is weak because while the struct fields are being initialized from external input, the specification is primarily about ensuring allocated memory is initialized before use, which is not the core activity here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 4,
        "reasoning": "The code has no visible error handling paths (e.g., checks for read failures, invalid values). While consistent state maintenance is a general good practice, the specification's focus on error handling paths has weak relevance to this straightforward parsing function that lacks such paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification is for network protocol handlers. This code is parsing a local image file format (Macintosh PixMap). The context and threat model are completely different, making it very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. This function is an image format parser (specifically part of a Mac bitmap/PixMap parser) that reads multiple critical header fields (packing type, pixel size, component count, etc.). The secure coding principle of validating all critical header fields before further processing directly applies to this scenario to prevent malformed input from causing crashes or logic errors.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code reads size parameters (like `pack_size`, `plane_bytes`) but does not perform any memory allocation based on them in this function. The guard and pre-validation principle is important, but its direct application to memory allocation is not present here, resulting in weak relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "The specification is for a BMP parser. This code is parsing a Macintosh PixMap format, which is a different specification. While both are image parsers, the specific bit count requirements for BMP do not apply. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "The specification is for regular expression parsers. This code is an image format parser. The domain and typical vulnerabilities (handling NUL bytes in patterns) are completely unrelated, making it very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is for pattern compilers processing escape sequences. This code is an image format parser reading numerical fields from a binary structure. The concepts of escape sequences and boundary checking in compilers are not applicable here, making it very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-12982_after_exclude_100:b49af4a4:spec": {
    "timestamp": "2026-01-16T23:19:33.860894",
    "cve_id": "CVE-2017-12982",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b49af4a4",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code reads data into a pre-existing struct but does not perform memory allocation itself. The relevance is weak because while the struct fields are being initialized from input data, the specification is primarily about ensuring allocated memory is initialized before use, which is not the main activity here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has minimal error handling visible (no checks on dbuf read operations). It could leave the `bi` struct in a partially updated state if an error occurs mid-function. However, the specification's focus on maintaining consistent object states in error paths is only weakly connected as no explicit error paths are shown.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is parsing a local image file format (Mac bitmap/PixMap) from a buffer, not handling network protocols. The specification's context is entirely different.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is an image format parser reading critical header fields (packing type, pixel size, component count, etc.). The specification directly applies because the code must validate these fields (e.g., for reasonableness, against maximum values, to prevent overflows) before using them in calculations like `(bi->rowbytes*8)/bi->pixelsize`. The current code performs some calculations but lacks explicit validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not perform any explicit memory allocation based on the size parameters it reads (e.g., `pack_size`, `plane_bytes`). The specification is about guarding allocations with size validation, which is not occurring here.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is parsing a Mac PixMap format, not a Windows BMP format. While both are image parsers, the specification is explicitly for BMP parsers and its specific bit count requirements do not apply to this different format.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is an image parser, not a regular expression parser. The specification about handling NUL bytes in patterns is completely unrelated to the current scenario.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is an image parser, not a pattern compiler processing escape sequences. The specification's context is entirely different.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2019-16161_after_exclude_100:9502304c:spec": {
    "timestamp": "2026-01-16T23:20:00.752463",
    "cve_id": "CVE-2019-16161",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9502304c",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes a string (sn->s to sn->end) and uses functions like ONIGENC_GET_CASE_FOLD_CODES_BY_STR which take pointer and end boundary. It correctly uses `p` and `end` to manage boundaries, suggesting some handling of embedded NULs if the string is length-delimited. However, the primary focus is case-fold expansion, not general pattern parsing with NULs.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not process escape sequences. It deals with case folding of already parsed string nodes within a regex tree. The specification about escape sequence boundaries in pattern compilers is not directly applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function processes a string with explicit start (`p`) and end (`end`) pointers, uses `enclen` to get character length, and passes these boundaries to encoding functions (ONIGENC_GET_CASE_FOLD_CODES_BY_STR, ONIGENC_MBC_CASE_FOLD). This is a classic example of length-aware operations on potentially untrusted input to prevent overflows.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code handles case-fold expansion for string nodes, creating alternations. It does not deal with backreferences or maintaining parser state for them across branches. The specification is about a different aspect of regex compilation.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Parser state for backreferences must be consistently maintained across alternative bra..."
      },
      {
        "score": 2,
        "reasoning": "Similar to spec_4, this function is not concerned with validating backreferences. Its purpose is to expand case-folded characters into alternative representations.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Regular expression parsers must validate backreferences against available subexpres..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function creates alternative branches (`expand_case_fold_string_alt`) when case folding generates multiple possibilities. It must manage the construction of the node tree (`root`, `prev_node`, `snode`) correctly across these alternatives. However, it's more about tree construction than parsing context like group counts or flags.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Alternative pattern parsing must preserve and restore all relevant parsing context"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The core of the function is character encoding processing for case folding. It repeatedly validates that `p < end` before calling encoding functions (`ONIGENC_GET_CASE_FOLD_CODES_BY_STR`, `ONIGENC_MBC_CASE_FOLD`) which receive the boundary. This is a direct application of validating buffer boundaries before access.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function maintains buffer state invariants through the pointer `p` and the invariant `p < end`. It advances `p` by `len` (the validated length of the current character). The loop and all buffer accesses are controlled by these invariants, which is crucial for safe input processing.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2019-16161_before_exclude_100:7304c7cf:spec": {
    "timestamp": "2026-01-16T23:20:03.838777",
    "cve_id": "CVE-2019-16161",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7304c7cf",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes a string for case folding expansion in a regex engine. While it handles a sequence of bytes (UChar*), it does not explicitly show handling of embedded NUL bytes within the pattern string. The function uses length-aware operations (p and end pointers) which inherently can handle NUL bytes if the input length is correctly provided. However, the specification's direct focus on \"embedded NUL bytes in input patterns\" is not the core scenario here, but the length-aware principle is followed.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about processing escape sequences in pattern compilers. The target function `expand_case_fold_string` is focused on case folding expansion of a literal string node, not on parsing or compiling escape sequences from a pattern source. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function processes a string defined by start (`sn->s`) and end (`sn->end`) pointers, using length-aware operations throughout (e.g., `p < end` loop, `enclen` for character length, `p + len` for bounds). It handles potentially complex, multi-byte encoded data from the regex input, aligning directly with the specification's requirement for length-aware operations on untrusted input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The specification concerns parser state for backreferences across alternative branches. This function deals with case folding expansion, creating alternative branches for different case-folded character representations. However, it manages a syntax tree structure (`Node`) for the regex, not backreference state. The core concern of the spec does not apply.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Parser state for backreferences must be consistently maintained across alternative bra..."
      },
      {
        "score": 2,
        "reasoning": "The specification is about validating backreferences against subexpressions during parsing/compilation. This function performs case folding expansion on an already parsed string node and does not involve backreference validation. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Regular expression parsers must validate backreferences against available subexpres..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function's core task is \"Alternative pattern parsing\" for case-folded characters. It creates alternative branches (via `expand_case_fold_string_alt`) and must correctly build and combine the resulting node trees (`prev_node`, `root`, `top_root`). It carefully manages this parsing/construction context (e.g., handling `prev_node`, `root`, and `snode` state) throughout the loop and when appending remaining strings.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Alternative pattern parsing must preserve and restore all relevant parsing context"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function repeatedly calls `ONIGENC_GET_CASE_FOLD_CODES_BY_STR` and `enclen(reg->enc, p)` which decode characters based on an encoding. It operates within a buffer bounded by `p` and `end`, validating boundaries before each access in the loop condition (`p < end`). This directly implements the specification's requirement to validate buffer boundaries during character encoding processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function is a parser input operation that reads sequentially from a buffer (`p`). It maintains critical invariants: `p` is always advanced by a valid character length (`len`), never exceeds `end`, and the buffer state is consistently managed between the main loop and the leftover string processing (`expand_case_fold_make_rem_string`). This aligns with the specification's focus on maintaining consistent buffer state.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2018-20760_after_exclude_100:0cdc46b3:spec": {
    "timestamp": "2026-01-16T23:20:37.064752",
    "cve_id": "CVE-2018-20760",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0cdc46b3",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `gf_realloc` and `gf_filter_pck_new_alloc` for memory allocation. While the allocated memory is often immediately written to via `memcpy`, there is no explicit full initialization (e.g., zeroing) of the entire allocated buffer before use. The specification is highly relevant as proper initialization is a core secure coding practice to prevent information leaks.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (e.g., checking `e == GF_EOS`, `e != GF_OK`, memory allocation failures). It must ensure that the filter's internal state (ctx) remains consistent across these paths. For example, after a failed `gf_m4v_parse_config`, the code logs an error but must continue without corrupting state. This is a strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code processes media data packets from a filter pipeline, not network protocol data directly. While it parses a bitstream (MPEG video), it is not a network protocol handler. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer allocation via `gf_realloc` for `ctx->hdr_store`. It calculates new size as `ctx->hdr_store_size + pck_size` but does not appear to add an explicit safety margin or padding. The allocation is for operational data aggregation, making the specification moderately relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code is a video demultiplexer/parser, not an image compression encoder. It reads and copies compressed video data but does not perform compression operations. The specification has very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code parses video start codes and frame sizes from a bitstream. While it doesn't handle explicit protocol message length fields, it does work with size values (e.g., `size` from `gf_m4v_parse_frame`). These sizes are used for memory operations and bounds checks (e.g., `assert(remain>=size)`), but validation against integer limits is not explicit. Weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory based on calculated sizes (`ctx->hdr_store_size + pck_size`). It must ensure these sizes are valid and do not overflow, and that the allocated buffer is sufficient for subsequent `memcpy` operations. The use of `s32` and `u32` for sizes requires careful validation. This is a strong relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different video start code types (e.g., `M4V_VOS_START_CODE`, `M4V_VOP_START_CODE`) and processes them through switch statements. It must ensure consistent interpretation of these types across parsing stages (e.g., `sc_type` handling). There is moderate relevance as type consistency is important for correct parsing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2016-5844_after_exclude_100:95979c48:spec": {
    "timestamp": "2026-01-16T23:21:28.311200",
    "cve_id": "CVE-2016-5844",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "95979c48",
    "scores": [
      {
        "score": 6,
        "reasoning": "HS-MEM-001 is moderately relevant. The code performs shape inference, which indirectly relates to memory allocation planning in the TensorFlow runtime. The function sets output tensor dimensions (like `c->Matrix(nvals, rank)`), influencing subsequent memory allocation size tracking. However, it does not directly perform allocation or size tracking itself.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "HS-STATE-002 has weak relevance. The function manages the logical \"resource\" of tensor shape information and must maintain consistency between input and output shape invariants (e.g., output rank derived from input). However, it does not handle low-level resources like file handles or memory buffers.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-001 has very low relevance. The code performs tensor shape inference with no regular expression parsing or pattern handling. Inputs are tensor shapes, not string patterns.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-002 has very low relevance. The code does not involve pattern compilers, escape sequences, or protocol parsing. It is purely a shape inference function for a sparse tensor operation.",
        "spec_index": 3,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-003 (first instance) has very low relevance. While the function processes input (tensor indices), it does not involve string processing or length-aware operations. The specification's focus on untrusted input strings does not apply to this numerical shape inference context.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "HS-TIMING-001 has very low relevance. The code performs deterministic shape inference with no cryptographic operations, secret values, or timing-sensitive processing.",
        "spec_index": 5,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "HS-CRYPTO-002 has very low relevance. The code has no cryptographic functionality, elliptic curve operations, or side-channel resistance considerations.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-003 (second instance) has very low relevance. This specification refers to constant-time properties during cryptographic processing, which is entirely unrelated to this tensor shape inference function.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      }
    ]
  },
  "CVE-2017-8925_before_exclude_100:d448c207:spec": {
    "timestamp": "2026-01-16T23:22:40.795556",
    "cve_id": "CVE-2017-8925",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d448c207",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about initializing memory allocations before use. The target code is a destructor function that frees memory, not allocating or initializing it. The connection is weak, as both deal with memory management but from opposite ends of the lifecycle.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The specification is about network protocol handlers. The target code is a memory cleanup function for a data structure (likely related to a media container format). There is no network input processing involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 7,
        "reasoning": "The specification is about bounds checking before buffer access. The code accesses `ptr->entries[i].name` in a loop based on `ptr->nb_entries`. While it doesn't explicitly validate `ptr->nb_entries` against the actual allocated size of `ptr->entries`, the function assumes the object is well-formed (a common but risky assumption in destructors). The principle of validating bounds before dereferencing is moderately relevant here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 2,
        "reasoning": "The specification is about parser input validation. The target code is a destructor, not a parser. It does not process or validate any input data.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about XML protocol parsing. The target code is not related to XML parsing; it appears to handle a box structure from a media format like ISOBMFF/MP4.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 7,
        "reasoning": "The specification is about bounds checking during binary data parsing. While this function is not a parser, it is cleaning up a data structure that was likely populated by parsing binary data. The loop access to `ptr->entries` array is directly related to the principle of ensuring safe array access based on a count (`nb_entries`). The relevance is moderate.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Binary data parsing must enforce strict bounds checking before array access"
      },
      {
        "score": 1,
        "reasoning": "The specification is about cryptographic input processing. The target code performs memory deallocation and has no relation to cryptography, key validation, or cryptographic operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Cryptographic input processing must validate both format and size constraints"
      }
    ]
  },
  "CVE-2011-1003_after_exclude_100:c7a12f6c:spec": {
    "timestamp": "2026-01-16T23:22:46.023805",
    "cve_id": "CVE-2011-1003",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c7a12f6c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification \"Memory allocations must be fully initialized before use\" is weakly relevant. The target code is a destructor function (gitn_box_del) that frees memory, not a function that allocates or initializes memory for use. The relevance is indirect at best, as proper initialization of the data structure being freed would have occurred elsewhere.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The specification \"Error handling paths must maintain consistent object states\" is strongly relevant. The function is a cleanup/destructor that must handle potential NULL pointers (ptr, ptr->entries) gracefully to avoid undefined behavior and maintain system state consistency during error recovery or normal object lifecycle management.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The specification \"Network protocol handlers must validate input before processing\" has very low relevance. The target code is a memory cleanup function for a box structure (likely multimedia container), not a network protocol handler. There is no network input processing involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Buffer access operations must validate bounds before dereferencing\" has moderate relevance. The code accesses `ptr->entries[i].name` within a loop bounded by `ptr->nb_entries`. While it doesn't explicitly validate that `nb_entries` correctly matches the allocated size of the `entries` array, the loop structure inherently respects the count. The main risk would be if `nb_entries` was corrupted, leading to out-of-bounds access.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Parser input validation must enforce structural constraints before content processing\" has very low relevance. The target code is not parsing input; it is deallocating an already parsed and constructed data structure. The validation should have occurred during the object's creation, not its destruction.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"XML protocol implementation must maintain strict boundary integrity during parsing\" has very low relevance. The code deals with a \"GroupIdToNameBox\" structure, which suggests a multimedia file format (like ISOBMFF/MP4), not XML parsing. There is no XML processing in this function.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Binary data parsing must enforce strict bounds checking before array access\" has moderate relevance. Similar to spec_4, the code is not parsing binary data in this function. However, it is operating on a data structure that was likely populated by parsing binary data. The safe deallocation of the `entries` array depends on the integrity of the `nb_entries` field, which should have been validated during the earlier parsing stage. The loop's bounds checking is implicit but assumes valid state.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Binary data parsing must enforce strict bounds checking before array access"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Cryptographic input processing must validate both format and size constraints\" has very low relevance. The function performs memory deallocation and contains no cryptographic operations, input processing, or validation of cryptographic data.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Cryptographic input processing must validate both format and size constraints"
      }
    ]
  },
  "CVE-2017-14151_before_exclude_100:4f4351cd:spec": {
    "timestamp": "2026-01-16T23:24:02.848337",
    "cve_id": "CVE-2017-14151",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4f4351cd",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memory allocations (jas_malloc, jas_alloc2) and initializes most fields of the allocated structures. However, there is a potential issue where `ccp->sampgrdsubstepx` is assigned twice (line 96) and `ccp->sampgrdsubstepy` is never initialized, leaving it with uninitialized memory. This directly relates to HS-MEM-001's requirement for full initialization before use.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The function has extensive error handling using goto error labels. It consistently cleans up allocated resources (ilyrrates, tvp, cp) in the error path, maintaining consistent object states by freeing memory before returning NULL. This is a strong example of proper error handling as specified by HS-STATE-002.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "This function processes an option string for image encoding configuration, not network protocol handling. While it does parse input (optstr), it's not related to network protocols, making HS-IO-003 only minimally relevant.</spec_2_reasoning>\n<spec_4_score>3</spec_4_score>\n<spec_4_reasoning>The code allocates buffers for image component data and intermediate layer rates but doesn't show explicit padding or safety margin calculations. The allocations appear to be exact sizes needed for the data structures. HS-MEM-003 has weak relevance as padding requirements aren't evident in this image encoding context.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "The code allocates buffers for image component data and intermediate layer rates but doesn't show explicit padding or safety margin calculations. The allocations appear to be exact sizes needed for the data structures. HS-MEM-003 has weak relevance as padding requirements aren't evident in this image encoding context.</spec_3_reasoning>\n<spec_5_score>9</spec_5_score>\n<spec_5_reasoning>This is highly relevant as the function performs extensive bounds checking for image encoding parameters: validates tile dimensions, precinct sizes, code block sizes, resolution levels, guard bits, layer rates, and ensures values are within acceptable ranges. Multiple validation checks align directly with HS-IO-004's requirement for strict bounds checking in image compression operations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant as the function performs extensive bounds checking for image encoding parameters: validates tile dimensions, precinct sizes, code block sizes, resolution levels, guard bits, layer rates, and ensures values are within acceptable ranges. Multiple validation checks align directly with HS-IO-004's requirement for strict bounds checking in image compression operations.</spec_4_reasoning>\n<spec_6_score>1</spec_6_score>\n<spec_6_reasoning>The code doesn't process protocol message length fields. It handles image encoding parameters and configuration options, not network protocol messages. HS-INPUT-001 has virtually no relevance to this code scenario.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 1,
        "reasoning": "The code doesn't process protocol message length fields. It handles image encoding parameters and configuration options, not network protocol messages. HS-INPUT-001 has virtually no relevance to this code scenario.</spec_5_reasoning>\n<spec_7_score>8</spec_7_score>\n<spec_7_reasoning>The code validates size parameters before use, particularly checking cp->rawsize to prevent division by zero. It also validates that allocations succeed before proceeding. However, it doesn't explicitly check for integer overflow in size calculations (like jas_alloc2 multiplication). HS-MEM-002 principles apply strongly but not completely.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code validates size parameters before use, particularly checking cp->rawsize to prevent division by zero. It also validates that allocations succeed before proceeding. However, it doesn't explicitly check for integer overflow in size calculations (like jas_alloc2 multiplication). HS-MEM-002 principles apply strongly but not completely.</spec_6_reasoning>\n<spec_8_score>7</spec_8_reasoning>\n<spec_8_reasoning>The function maintains consistent type handling for image encoding parameters, using appropriate types (uint_fast32_t, uint_fast16_t, etc.) and performing conversions (atoi, jpc_dbltofix) consistently. However, this isn't a network protocol implementation, so HS-PROTOCOL-003 applies moderately to the general principle of consistent type handling.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2019-13219_after_exclude_100:8302d9cf:spec": {
    "timestamp": "2026-01-16T23:24:06.892496",
    "cve_id": "CVE-2019-13219",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8302d9cf",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memory allocations (jas_malloc, jas_alloc2) for structures like cp->ccps and tcp->ilyrrates. While some fields are explicitly initialized (e.g., cp->debug, cp->imgareatlx), the initialization pattern is mixed. Some fields are set to default values, but the specification about full initialization before use is highly relevant, as uninitialized memory could lead to undefined behavior. The code shows awareness by setting many fields, but not all allocations may be fully initialized in all code paths.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The function has extensive error handling using goto error labels. It attempts to maintain consistent object states by cleaning up allocated resources (ilyrrates, tvp, cp) in error paths. However, there are multiple error conditions where resources might not be fully cleaned up if allocations fail mid-way. The specification strongly applies as the code demonstrates error handling patterns but may have subtle inconsistencies.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2017-9610_before_exclude_100:3cbe0dc4:spec": {
    "timestamp": "2026-01-16T23:24:49.976972",
    "cve_id": "CVE-2017-9610",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3cbe0dc4",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is an image decoder (MNG format reader) and does not perform filesystem operations or manage inode states. It reads image data from a blob/stream, processes chunks, and constructs image structures in memory. There is no filesystem layer interaction.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Filesystem operations must maintain consistent inode state across all layers"
      },
      {
        "score": 1,
        "reasoning": "The code has no POSIX rename operations, file renaming, or handling of hardlinks. It is purely an image parsing and decoding routine operating on an already opened blob (file or memory stream).",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: POSIX rename operations must properly handle all special cases including self-hardl..."
      },
      {
        "score": 5,
        "reasoning": "No filesystem driver or VFS layer interaction is present. The code works with ImageMagick's Blob interface for reading data, not with low-level filesystem inode identities.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem drivers must expose consistent inode identity to VFS layer"
      },
      {
        "score": 5,
        "reasoning": "While the code does validate chunk lengths and data integrity (e.g., checking length > PNG_UINT_31_MAX, verifying magic numbers), it does not involve database constraints, generated columns, or SQL-level integrity verification.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Integrity verification must validate all constraints including NOT NULL on generated c..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains some internal state consistency (e.g., object existence, loop counts) but is not related to database consistency checks, column types, or invariant validation across database schemas.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Database consistency checks must maintain invariant validation across all column types"
      },
      {
        "score": 5,
        "reasoning": "The code performs object copying and reinitialization in several places (e.g., image magnification resizing, memory allocation/reallocation for chunks, copying pixel data). It must ensure pointer validity during operations like AcquireQuantumMemory and RelinquishMagickMemory. However, it does not explicitly address atomicity in pointer updates across threads.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Object copy operations must maintain atomic pointer validity during reinitialization"
      },
      {
        "score": 5,
        "reasoning": "The code uses file descriptor-like operations via SeekBlob, ReadBlob, and TellBlob, and must maintain proper seek positions when reading chunk data. There is some state transition in reading loops, but not strict ordering enforcement as in low-level file descriptor state machines.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File descriptor operations must enforce strict state transition ordering"
      },
      {
        "score": 5,
        "reasoning": "During image processing (especially magnification and cropping), the code copies and transforms image data, requiring consistent intermediate states to avoid corruption. For example, when magnifying, it allocates new images and copies rows/columns with interpolation. However, the specification is more about object copying in a broader system context.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-003: Object copying must guarantee consistent intermediate states"
      }
    ]
  },
  "CVE-2017-18249_before_exclude_100:a64adb15:spec": {
    "timestamp": "2026-01-16T23:24:53.058452",
    "cve_id": "CVE-2017-18249",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a64adb15",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via `iwl_trans_alloc` and `alloc_percpu`. While the allocated structures are partially initialized (e.g., spin locks, mutex, waitqueue), there is no explicit guarantee that all fields are fully initialized before use. The `trans_pcie` pointer is dereferenced immediately after allocation. This aligns with the core concern of HS-MEM-001.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple error handling paths (goto out_no_pci, out_free_ict). These paths must ensure consistent state cleanup (freeing allocated memory like `tso_hdr_page`, `trans`, and ICT). The code shows careful cleanup in error paths, making HS-STATE-002 highly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is PCI device driver initialization code, not a network protocol handler. There is no processing of network packets or protocol data in this function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not process any userspace-provided input or array lengths. It handles PCI configuration and internal driver structures.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code does not handle protocol messages or variable-length components. It is hardware initialization code.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "While there are buffer allocations (e.g., `tso_hdr_page`), they are for fixed-size internal structures, not directly driven by external input scenarios. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "No protocol message length fields are processed in this PCI device initialization routine.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation (`iwl_trans_alloc`, `alloc_percpu`) with size parameters derived from `sizeof` operations, which are compile-time constants. There is no dynamic size validation against allocation limits, as the sizes are fixed. However, the principle of ensuring allocation size is appropriate for usage is implicitly followed. Relevance is moderate.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2017-9610_after_exclude_100:25ce6ac9:spec": {
    "timestamp": "2026-01-16T23:24:55.894731",
    "cve_id": "CVE-2017-9610",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "25ce6ac9",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is an image parsing function (MNG format decoder) that reads and processes chunks from a binary file. It does not perform filesystem operations or maintain inode state across layers. The code works with memory buffers and image data structures, not filesystem layers or inodes.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Filesystem operations must maintain consistent inode state across all layers"
      },
      {
        "score": 1,
        "reasoning": "The code does not perform any POSIX rename operations or handle filesystem hardlinks. It's purely an image decoding routine that reads binary data from a blob (file stream) and processes MNG chunk structures.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: POSIX rename operations must properly handle all special cases including self-hardl..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement filesystem drivers or interact with VFS layer. It's a user-space image decoder that reads from a file blob and creates image data structures in memory.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem drivers must expose consistent inode identity to VFS layer"
      },
      {
        "score": 5,
        "reasoning": "While the code does perform some integrity checks (like verifying MNG signature and chunk lengths), it doesn't involve database operations, generated columns, or SQL constraints. The validation is specific to image format parsing.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Integrity verification must validate all constraints including NOT NULL on generated c..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains some internal state consistency (like object existence flags and loop counters) but doesn't involve database operations or column type invariants. The consistency checks are specific to MNG format parsing.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Database consistency checks must maintain invariant validation across all column types"
      },
      {
        "score": 5,
        "reasoning": "The code performs object copying operations during image magnification and layer insertion. It allocates new image structures, copies pixel data, and manages memory. While not exactly about atomic pointer validity during reinitialization, it does involve careful memory management and object state transitions.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Object copy operations must maintain atomic pointer validity during reinitialization"
      },
      {
        "score": 5,
        "reasoning": "The code performs file descriptor operations through ReadBlob, SeekBlob, and TellBlob functions. It enforces some state transitions (like skip_to_iend flag management) and validates read operations. However, it's not a low-level filesystem driver enforcing strict state machines.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File descriptor operations must enforce strict state transition ordering"
      },
      {
        "score": 5,
        "reasoning": "The code extensively copies and transforms image objects during magnification processing. It creates intermediate image structures, copies pixel data between buffers, and ensures consistent states during transformations. This relates to maintaining consistent intermediate states during object copying operations.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-003: Object copying must guarantee consistent intermediate states"
      }
    ]
  },
  "CVE-2018-14461_after_exclude_100:b6f9c5a7:spec": {
    "timestamp": "2026-01-16T23:26:12.098321",
    "cve_id": "CVE-2018-14461",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b6f9c5a7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `attr->hdr.length` directly in a calculation (`attr->hdr.length - 4`) without validating it against platform-specific integer limits (e.g., ensuring it's non-negative, not causing integer overflow/wrap-around, and is within the bounds of the received buffer). This is a direct protocol message length field validation issue.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs a pool allocation (`PJ_POOL_ZALLOC_T`), but the size is determined by the type, not a variable parameter. However, the subsequent usage (string duplication via `pj_strdup`) depends on the untrusted `value.slen`, which is derived from `attr->hdr.length`. This creates an indirect connection to memory allocation validation, but the specification's primary focus on validating size parameters for allocation is not directly applicable here.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code decodes a STUN error code attribute. It must correctly interpret the binary structure (length field, error code bytes, reason string) consistently. The calculation `buf[6] * 100 + buf[7]` assumes a specific, valid encoding of the error code. Inconsistent handling (e.g., of the length field or integer representation) could lead to misinterpretation. The principle of consistent type handling is moderately relevant.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain or call any regular expression parsers. The specification is about a specific input validation issue for regex patterns, which is completely unrelated to this network protocol decoding function.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain or call any pattern compilers or process escape sequences. This specification is irrelevant to the given code which performs binary decoding and string copying.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code processes a string (`value`) from an untrusted network buffer. It uses `pj_strdup`, which likely expects a length-bounded string (`pj_str_t`). While the code calculates `value.slen` from the message length field and performs a basic negative check, it does NOT validate that `value.slen` does not exceed the actual remaining bytes in the `buf` input. This could lead to reading out-of-bounds memory. The specification's call for length-aware operations for untrusted input directly applies.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The function initializes its local `attr` pointer via allocation and the `value` struct. However, the `value.slen` is derived from an untrusted source (`attr->hdr.length`) and only corrected if negative, but not fully validated. The principle of initializing and validating all state variables (especially those derived from input) before use is moderately applicable. The `PJ_POOL_ZALLOC_T` may zero-initialize the struct, which is good.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Request processing must initialize all state variables at start of handling"
      },
      {
        "score": 5,
        "reasoning": "The code is a stateless attribute decoding function. It does not manage connections, sessions, or state between requests. The concept of connection reuse and state isolation is not applicable here.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Connection reuse must guarantee complete state isolation between requests"
      }
    ]
  },
  "CVE-2016-1833_before_exclude_100:ae6a66e8:spec": {
    "timestamp": "2026-01-16T23:27:12.101062",
    "cve_id": "CVE-2016-1833",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ae6a66e8",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code manages dynamic memory (via `ga_init2`, `ga_grow`, `ga_concat`) and file resources (`sp->fp` with `fgets`). While there is a release pathway for the growarray data (`vim_free(ga.ga_data)` on failure), the code's primary focus is reading lines, not comprehensive resource lifecycle management. The file pointer `sp->fp` is acquired elsewhere and released elsewhere, so the guarantee of release is not fully evaluated within this function. The principle of guaranteed release is relevant but only partially addressed.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Resource acquisition must have guaranteed release pathways"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns USB serial operations and reference count symmetry. The target code performs file/string input reading with no USB, serial, or reference counting mechanisms present. It is completely irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: USB serial operations must maintain strict reference count symmetry"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns TTY (teletype) operations and their complete lifecycle management. The code reads from either a buffer or a file pointer (`sp->fp`), with no TTY-specific operations (like `tcsetattr`, handling signals, or terminal I/O). It is irrelevant.",
        "spec_index": 2,
        "spec_preview": "HS-RESOURCE-003: TTY operations must implement complete lifecycle management"
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. This code is a line-reading function, not a regex parser. However, it does process input strings that could contain NUL bytes (since it reads binary-safe using `fgets` and `STRLEN`). The handling of NULs is indirect (they would terminate `STRLEN` measurement), but the code's purpose is not regex parsing. Weak connection.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns pattern compilers and escape sequence boundaries. This code processes escape sequences for newline characters (checking for `Ctrl_V` to see if `\\n` is escaped). It maintains boundaries by tracking buffer length and not overrunning. While not a pattern compiler, it directly handles escape sequence logic for line continuation, making the principle of boundary-aware escape processing moderately relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification mandates length-aware operations for untrusted input. The code uses `ga_grow` to ensure buffer capacity, uses `fgets` with explicit length limits (`ga.ga_maxlen - ga.ga_len`), and tracks length via `ga.ga_len` and `STRLEN`. It carefully avoids buffer overflows when reading from an external file (`sp->fp`), which is potentially untrusted. Highly relevant, though not all string operations are explicitly length-bounded (e.g., `ga_concat` assumes source is NUL-terminated).",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns keyring modification operations and permission validation. The code has no keyring, security, or permission checks. It is completely irrelevant.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Keyring modification operations must enforce complete permission validation regardless o..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns default security behaviors and equivalent protection. The code implements line reading logic with no security configurations, authentication, or policy enforcement. It is irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-AUTH-002: Default security behaviors must maintain equivalent protection to explicit configuratio..."
      }
    ]
  },
  "CVE-2016-1833_after_exclude_100:552a8a06:spec": {
    "timestamp": "2026-01-16T23:27:20.130681",
    "cve_id": "CVE-2016-1833",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "552a8a06",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code manages a dynamically growing buffer (ga) for reading source lines. It acquires memory via ga_grow() and ga_init2(), and has a guaranteed release pathway: if reading succeeds, the buffer is returned to the caller (who presumably manages it later); if reading fails (have_read is FALSE), it explicitly calls vim_free(ga.ga_data) before returning NULL. This demonstrates resource acquisition with guaranteed release.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Resource acquisition must have guaranteed release pathways"
      },
      {
        "score": 1,
        "reasoning": "The code performs file I/O (fgets) and buffer operations for reading source lines from a file or buffer. There is no USB serial operation or reference counting mechanism present. The specification is about a specific hardware interface protocol not relevant here.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: USB serial operations must maintain strict reference count symmetry"
      },
      {
        "score": 5,
        "reasoning": "The code handles reading from a file pointer (fp) or an internal buffer. There is no TTY (teletype) device interaction, terminal control, or TTY-specific lifecycle management (like opening/closing terminal devices, session management). The specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-RESOURCE-003: TTY operations must implement complete lifecycle management"
      },
      {
        "score": 5,
        "reasoning": "The code processes input lines and handles escape sequences (Ctrl_V) and line separators. While it's not a regular expression parser, it does parse and interpret input patterns (source lines) and must handle NUL bytes correctly because it uses string functions (STRLEN) and manages null-terminated strings. The connection is weak but exists in the broader context of input parsing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code explicitly processes escape sequences: it checks for Ctrl_V (escape character) preceding a newline to determine if the newline is escaped. It maintains boundaries by tracking buffer length (ga.ga_len) and ensuring operations stay within the allocated buffer. This aligns with the principle of handling escape sequences with boundary awareness.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code reads input using fgets with explicit length limits (ga.ga_maxlen - ga.ga_len), preventing buffer overflow. It uses ga.ga_len to track current data size and ga_grow to ensure sufficient capacity. While it uses STRLEN on the read data (which is null-terminated by fgets), the overall buffer management is length-aware, especially important as input could be from external files (potentially untrusted).",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code is a source line reading function with no keyring operations, security permission checks, or key management. The specification is about kernel keyring security and is completely unrelated.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Keyring modification operations must enforce complete permission validation regardless o..."
      },
      {
        "score": 5,
        "reasoning": "The code implements a specific file reading and line processing logic. It does not configure security behaviors, authentication, or authorization mechanisms. There is no concept of default vs explicit security configurations here.",
        "spec_index": 7,
        "spec_preview": "HS-AUTH-002: Default security behaviors must maintain equivalent protection to explicit configuratio..."
      }
    ]
  },
  "CVE-2016-7532_before_exclude_100:10ecc901:spec": {
    "timestamp": "2026-01-16T23:27:36.665141",
    "cve_id": "CVE-2016-7532",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "10ecc901",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses several fixed-size character arrays (e.g., command, filename, geometry) and initializes them with memset or FormatLocaleString. However, the loop reading into the 'command' buffer has a bounds check preventing overflow, but the buffer is only null-terminated after the loop or when a specific character is encountered. The initialization before use is generally present, but the pattern of incrementing 'p' and checking bounds is a relevant scenario for memory initialization principles.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error handling paths (e.g., OpenBlob failure, AcquireUniqueSymbolicLink failure, delegate_info NULL). In each error path, it consistently cleans up resources (DestroyImage, RelinquishUniqueFileResource) before returning NULL. This maintains consistent object states and prevents resource leaks.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This code is a file format parser (PCL/PDF) reading from a blob/file, not a network protocol handler. The specification about network protocol input validation does not apply to this local file processing context.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code parses PCL/PDF-like structures (CropBox, MediaBox) from the input stream. It validates the parsed count (must be 4) before using the bounds. However, it does not deeply validate structural relationships between different header fields (e.g., consistency between MediaBox and CropBox). The validation is basic but present.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The primary array indexing is for the 'command' buffer. The check \"(size_t) (p-command) < (MagickPathExtent-1)\" provides explicit bounds validation before continuing the loop. This prevents buffer overflow. Other arrays (filename, geometry) are used with CopyMagickString/FormatLocaleString which likely have internal bounds checks.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a file format processor (PCL). It implements comprehensive error handling with cleanup: closes blobs, destroys images, relinquishes unique file resources, and destroys image info in all error and success paths. The use of ExternalDelegateCommand also involves error status checking.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code reads and validates critical header fields (CropBox, MediaBox) from the PCL/PDF stream. It checks the parsed count (4 values) before using them to calculate width/height. It also validates page width/height before proceeding. However, it does not validate the sanity of the parsed floating-point values (e.g., negative, extremely large).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses stack-allocated fixed-size buffers, not dynamic memory allocation via malloc/calloc. The size parameters for these buffers are compile-time constants (MagickPathExtent). There is no explicit pre-validation of size parameters for dynamic allocations because there are none in this snippet. The specification about guarding memory allocation has limited connection.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2018-1000222_after_exclude_100:b4b2d7c6:spec": {
    "timestamp": "2026-01-16T23:28:31.680160",
    "cve_id": "CVE-2018-1000222",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b4b2d7c6",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses several fixed-size character arrays (e.g., command, filename, geometry, input_filename) sized by MagickPathExtent. While these are not dynamically allocated, the principle of initialization before use is relevant. The code explicitly initializes some buffers with memset (e.g., command, bounding_box, bounds, page) but not all arrays (e.g., filename, geometry, input_filename are not explicitly initialized at declaration). The loop that builds the 'command' string relies on null-termination after writing, which is ensured by setting *p='\\0'. However, the initialization practice is inconsistent, making the specification's principle of full initialization before use highly relevant for security and stability.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The function has multiple error handling paths (e.g., OpenBlob failure, AcquireUniqueSymbolicLink failure, delegate_info NULL check, ExternalDelegateCommand failure, ReadImage failure). In each error path, the code attempts to maintain consistent state by destroying images (DestroyImage), freeing strings (DestroyString), and relinquishing unique file resources (RelinquishUniqueFileResource). This aligns strongly with HS-STATE-002's requirement for consistent object states during error handling. The cleanup appears comprehensive, though a deeper audit would be needed to confirm no resource leaks in all paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code reads a PCL image file from local storage (via OpenBlob). It does not handle network protocols. The specification HS-IO-003 regarding network protocol handlers is not applicable to this function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The function parses PCL/PostScript-like commands from the input file to extract CropBox and MediaBox. It validates the structural relationship by checking if `count == 4` after sscanf, ensuring it has read four values before using bounds. However, it does not validate the semantic relationships between the fields (e.g., that x2 > x1, y2 > y1). The parsing loop also lacks robust validation against command buffer overflows, relying on a size check `(size_t) (p-command) < (MagickPathExtent-1)`. The specification's principle of validating structural relationships is moderately relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The code uses array indexing primarily on the fixed-size 'command' buffer. The loop guard `((size_t) (p-command) < (MagickPathExtent-1))` provides explicit bounds validation before writing, preventing overflow. This directly aligns with HS-MEM-002. However, other arrays (like filename, geometry) are used via string copy functions (CopyMagickString, FormatLocaleString) which internally should have bounds checks. The relevance is moderate because the key buffer operation has explicit validation, but not all array accesses are individually checked.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "This is a file format processor (PCL). It implements extensive error handling with cleanup: on failures, it destroys images, frees strings, and relinquishes unique file resources. The function uses multiple checks (status, NULL pointers) and has a centralized exception mechanism (ThrowReaderException). The cleanup actions are present in both success and error paths. This strongly aligns with HS-IO-003's requirement for complete error handling with resource cleanup.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "The code parses PCL header-like commands (CropBox, MediaBox, DeviceCMYK) to determine page geometry and colorspace. It validates that it successfully read 4 values (count == 4) before using the bounds. However, it does not validate critical fields like resolution values (division by delta.x/delta.y could be problematic if they are zero, but delta is set to DefaultResolution). Also, it proceeds with rendering even if page width/height are zero (later uses PSPageGeometry). The principle of validating critical header fields before processing is moderately relevant, but the validation could be more robust.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The function does not perform explicit dynamic memory allocation via malloc/calloc. Memory for strings (density, options) is allocated via AcquireString, which likely has internal guards. Image structures are acquired via AcquireImage and CloneImageInfo, which are library functions. The code does not show pre-validation of size parameters before these allocations. The specification HS-MEM-002 about guarding allocation with size validation has weak relevance because the allocations are managed by library functions, not directly in this code snippet.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2014-9512_after_exclude_100:883392a3:spec": {
    "timestamp": "2026-01-16T23:29:06.107861",
    "cve_id": "CVE-2014-9512",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "883392a3",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code does not involve regular expression parsing. It processes path strings by iterating through characters, but its handling of NUL bytes is part of its own logic (temporarily setting '\\0' to isolate path components), not parsing regex patterns from untrusted input. The connection is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns pattern compilers and escape sequences, which are not present in the target code. The code builds directories by traversing a path string; it does not compile patterns or process escape sequences. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification recommends length-aware operations for potentially untrusted input. The target code processes `src` and `dst` strings without explicit length checks (e.g., using `strlen` or passed length parameters). It iterates based on encountering '\\0' or '/', which could be problematic if strings are not properly terminated or if input is maliciously crafted (e.g., causing out-of-bounds reads). The principle of using length-aware operations is strongly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires bounds validation before buffer access. The code uses pointer arithmetic (`p = src + src_prefix_len + 1`, `q = dst + dst_prefix_len + 1`) and dereferences `p` and `q` without verifying that these offsets are within the allocated buffers. If `src_prefix_len` or `dst_prefix_len` are too large, or if strings are shorter than expected, this leads to out-of-bounds access. This is highly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The specification advises enforcing structural constraints before content processing. The code assumes `src` and `dst` are valid paths and processes them component-by-component. It does not validate the overall structure (e.g., ensuring no directory traversal sequences like \"..\" or excessive slashes) before calling `stat()` and `mkdir()`. This has moderate relevance, as input validation could prevent path traversal or other issues.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is specific to XML protocol implementation and boundary integrity during XML parsing. The target code does not involve XML or any network protocol parsing. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification requires validating length calculations against allocated size. Similar to spec_4, the code performs pointer arithmetic (`src + src_prefix_len + 1`, `dst + dst_prefix_len + 1`) without checking if these point within the bounds of the source and destination buffers. This could lead to buffer overflows. The principle is highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The specification focuses on pathname expansion with pattern syntax and length constraints. The code does not perform shell-style pattern expansion (like globbing), but it does process pathnames and constructs directory paths. It lacks strict validation of pattern syntax (though not directly applicable) and length constraints (as noted in spec_3 and spec_7). There is moderate to strong relevance regarding path validation and length checks.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2016-3137_after_exclude_100:bdb78912:spec": {
    "timestamp": "2026-01-16T23:30:27.138672",
    "cve_id": "CVE-2016-3137",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bdb78912",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process any protocol messages with length fields. It is a USB interface initialization function dealing with driver setup, memory allocation, and endpoint discovery, not network protocol parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code performs two key memory allocations (`kzalloc` and `kmalloc`). While it checks for allocation failure (NULL return), it does not validate the size parameter (2048 for `tx_buffer`) against any platform-specific allocation limits or ensure it meets the subsequent usage requirements for the USB data transfer operations. This is a direct application of the specification.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code is initializing a data structure and function callbacks for a USB host interface. It does not implement a communication protocol with variable types that need consistent handling across stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. The code uses `kzalloc` (which zero-initializes memory) for the main `rsi_dev` structure, ensuring it is fully initialized before use. This is a direct and correct application of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code has multiple error handling paths (`goto fail_eps`, `goto fail_rx`). The specification requires consistent object states. While the function cleans up the `tx_buffer` on the `fail_rx` path, it's crucial to analyze if `adapter->rsi_dev` is set before all initialization steps are complete and if the `fail_eps` path correctly handles a partially initialized `adapter->rsi_dev`. The presence of structured error handling makes this principle highly applicable.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This function is a USB device driver initialization routine, not a network protocol handler. It does not process incoming network packets.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code does not receive or process any array lengths from userspace. It is kernel-level driver initialization code.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Similar to spec 1 and 6, this function does not handle or parse protocol messages with variable-length components. Its role is driver setup and resource allocation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2016-3137_before_exclude_100:bcf70463:spec": {
    "timestamp": "2026-01-16T23:30:27.480363",
    "cve_id": "CVE-2016-3137",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bcf70463",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not directly process protocol messages with length fields. It is a USB interface initialization function. While USB communication involves data packets, the function itself does not parse or validate message lengths from the network or USB data stream. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code performs memory allocation (`kzalloc`, `kmalloc`) with fixed sizes. While the sizes are hardcoded (e.g., 2048), the specification principle of validating size parameters against allocation limits and usage requirements is a core secure coding practice. The function checks for allocation failure (NULL return) which is a basic validation, aligning with the specification's intent.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code initializes a USB driver interface and sets function callbacks. It does not implement a network or communication protocol with variable types that require consistent handling across stages. The operations are primarily about resource setup and configuration.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 10,
        "reasoning": "Highly relevant and directly applicable. The code uses `kzalloc` which zero-initializes the allocated memory for `rsi_dev`. This ensures the structure is fully initialized before use, preventing information leaks from uninitialized memory. This is a direct and correct application of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code has multiple error handling paths (`goto fail_eps`, `goto fail_rx`). These paths attempt to maintain consistency by freeing previously allocated resources (`kfree(rsi_dev->tx_buffer)`, `kfree(rsi_dev)`). However, it's worth noting that `status` is only set in some failure branches, which could be a minor inconsistency. The overall structure demonstrates attention to cleanup on error.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. This function is a USB device driver initialization routine, not a network protocol handler. It does not process incoming network packets or user input that requires validation in the context of network protocols.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not receive or process array lengths from userspace. It is kernel code initializing a driver for a USB device. All sizes are internal constants (e.g., 2048, 252).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Similar to spec 1 and 3, this function does not handle or parse protocol messages with variable-length components. Its role is driver initialization and resource allocation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2010-1311_before_exclude_100:7e804c61:spec": {
    "timestamp": "2026-01-17T00:12:05.346738",
    "cve_id": "CVE-2010-1311",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7e804c61",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a decompression function (inflate) for zlib/gzip data. It processes binary compression formats, not regular expression patterns. There is no parsing of regular expressions or handling of NUL bytes in patterns.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is a low-level binary data decompressor for DEFLATE format.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code manages internal buffers (window, codes) and uses safety checks on lengths (e.g., checking `state->nlen > 286`). While not explicit allocation, it ensures operational data structures don't exceed bounds. The relevance is moderate as it's about buffer management, not allocation.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code is a decompression operation (inverse of compression) for image/stream compression. It performs extensive bounds checking on input and output buffers (e.g., `copy > have`, `copy > left`, window size checks) to prevent buffer overflows during decoding.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code initializes state variables (e.g., `state->flags = 0`, `state->length = 0`) and uses `zmemcpy` for safe copying. However, it doesn't show memory allocation functions (like malloc). Relevance is moderate as it shows good initialization practices for state variables.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function maintains consistent state via `state->mode` transitions and error handling. On errors (`state->mode = BAD`), it sets error messages and ensures clean exit paths. The `inf_leave` section restores state and updates totals consistently.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code validates compressed data headers (zlib/gzip), checks magic numbers, CRC, block types, and length fields before processing. It acts as a protocol handler for compression formats, validating input integrity early (e.g., header checks, method validation).",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2021-41224_before_exclude_100:946b66a1:spec": {
    "timestamp": "2026-01-17T00:12:15.522799",
    "cve_id": "CVE-2021-41224",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "946b66a1",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor shape validation and sparse tensor operations. It contains no cryptographic operations on secret values, making this specification irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code is a tensor processing operation in a machine learning framework. It does not implement elliptic curve cryptography or any cryptographic curve models.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor validation and sparse operations. It does not involve cryptographic processing or secure memory operations that require constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates tensor shapes before processing (OP_REQUIRES_ASYNC checks), which is conceptually similar to bounds validation. However, it doesn't deal with fixed buffers in the traditional C security sense, but with tensor dimensions.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements comprehensive input validation before processing, checking tensor shapes (IsVector, IsMatrix, IsScalar), ensuring dense_shape is not empty, and validating the structure of all input tensors. This aligns with the principle of complete input size/structure validation before processing.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code enforces structural constraints on input data (tensor shapes must be specific types - vector, matrix, scalar) which is analogous to configuration parsers enforcing structural constraints. The validation happens before any substantive processing.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 5,
        "reasoning": "The code shows no resource allocation or cleanup logic. It only validates inputs and delegates to a functor. There's no initialization of resources that would require conditional cleanup.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "The code contains no cryptographic algorithms, key objects, or algorithm support verification. It's purely a tensor processing operation in a machine learning context.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2010-1311_after_exclude_100:6cbc0133:spec": {
    "timestamp": "2026-01-17T00:12:16.121434",
    "cve_id": "CVE-2010-1311",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6cbc0133",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is an inflate (decompression) function from zlib, not a regular expression parser. It processes compressed data streams, not regular expression patterns. Embedded NUL bytes are not a specific concern in this context as the input is treated as a byte stream, not a null-terminated string.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It is a decompression algorithm handling Huffman codes, length-distance pairs, and raw data blocks. The specification about escape sequences in pattern compilers is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The function processes potentially untrusted compressed input (e.g., from network or file). It uses length-aware operations: it tracks available input (`have`) and output (`left`) bytes, uses `copy = min(state->length, have, left)` logic, and checks boundaries before copies (e.g., in COPY, EXTRA, NAME, COMMENT cases). This prevents buffer overflows.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This is a core decompression (inflate) function. It performs extensive bounds checking: validates window size, length/distance symbols counts (`state->nlen > 286 || state->ndist > 30`), ensures copies do not exceed available input/output, checks distances against window size (`state->offset > state->dmax`), and uses `NEEDBITS` to ensure sufficient bits in buffer. These are essential for safe decompression.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code shows some initialization (e.g., `state->flags = 0`, `strm->adler = state->check = adler32(0L, Z_NULL, 0)`). However, the specification focuses on memory allocations being initialized before use. Memory allocations (like `state->window`) are managed elsewhere (`updatewindow`). This function primarily works with already allocated state.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function uses a state machine (`state->mode`) and has consistent error handling. On errors (setting `state->mode = BAD`), it breaks to `inf_leave` which performs cleanup and returns an error code. The state is preserved for possible recovery. Error paths set `strm->msg` and transition to BAD mode, maintaining a consistent state.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function validates input before processing: checks header checksums, compression method, window size, block types, stored block length consistency, code length counts, and distance offsets. It treats the input as untrusted (e.g., from network protocols like HTTP with gzip compression). Many validation failures lead to `state->mode = BAD` with appropriate error messages.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2021-41224_after_exclude_100:85f799d9:spec": {
    "timestamp": "2026-01-17T00:12:33.356446",
    "cve_id": "CVE-2021-41224",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "85f799d9",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor shape validation and sparse tensor operations. It does not involve any cryptographic operations on secret values, making this specification irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor processing operation in a machine learning framework. It does not implement elliptic curve cryptography or any cryptographic algorithms, so side-channel resistance for curve models is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs input validation and tensor operations but does not involve cryptographic processing or secure memory operations that require constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates tensor shapes and dimensions before processing (e.g., checking dense_shape is a vector, indices is a matrix). While not traditional buffer operations, tensor dimension validation serves a similar purpose to bounds checking. However, it doesn't involve fixed-size buffers in the traditional C array sense.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code extensively validates input tensor shapes and sizes before processing (OP_REQUIRES_ASYNC checks for vector, matrix, scalar shapes, dimension matching, non-empty dense shape). This aligns with the principle of complete input validation before processing.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code enforces structural constraints on input tensors (shape requirements, dimension matching). While not parsing configuration data in the traditional sense, it validates the structure of input data tensors before further processing.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve resource initialization or cleanup patterns. It performs input validation and delegates to a functor, but doesn't show resource allocation or cleanup logic that would require conditional cleanup based on initialization success.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve cryptographic algorithms, key objects, or algorithm support verification. It's a tensor processing operation in a machine learning context.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2022-1031_before_exclude_100:71a24b51:spec": {
    "timestamp": "2026-01-17T00:12:56.804204",
    "cve_id": "CVE-2022-1031",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "71a24b51",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `strdup` to allocate memory for `esil_buf`. While the pointer is checked for NULL, there is no explicit initialization of the allocated memory before it is used in string operations (e.g., `strstr`, pointer arithmetic). The specification about initializing memory before use is relevant, though the memory is immediately populated with a copied string, which is a form of initialization. However, the subsequent pointer manipulation (`*ptr_end = 0`) and backward scanning assume the buffer contains valid string data, which is ensured by `strdup`. The relevance is strong but not perfect because the allocation is directly initialized with source data.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error handling paths (e.g., early returns, goto beach) that free `esil_buf` if allocated. The state of objects like `fcn` and `op` is not modified inconsistently on error paths. However, the function does modify state (e.g., may set variables via `r_anal_function_set_var`) only after successful validation. The principle of maintaining consistent object states applies moderately, as the error paths seem to clean up allocated resources and avoid partial updates.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is part of a binary analysis/RE tool (radare2) and deals with disassembly/analysis of instructions, not network protocol handling. There is no network input processing. The specification is not relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It works with ESIL strings and numeric extraction, but no escape sequence handling.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The code uses `strstr`, `strncmp`, and pointer arithmetic on the `esil_buf` string, which originates from `op->esil` (internal data, but potentially influenced by user input from binary analysis). It does not use length-aware functions like `strnstr` or explicitly track lengths, but it does ensure null-termination and checks boundaries (`addr >= esil_buf + 1`). However, there is a risk of out-of-bounds reads if the string is malformed (e.g., no null terminator). The specification has moderate relevance because the code processes strings without explicit length bounds, though the context is somewhat trusted.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code allocates memory via `strdup`, which allocates based on source string length. There is no additional padding or safety margin calculation. The specification about buffer allocation with padding requirements is weakly relevant, as the code does not perform complex buffer allocation with operational padding.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve image compression operations or encoder buffers. It is unrelated to image processing.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2022-1031_after_exclude_100:49c11c59:spec": {
    "timestamp": "2026-01-17T00:14:04.357248",
    "cve_id": "CVE-2022-1031",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "49c11c59",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `strdup` and `r_str_newf` for memory allocation. While the allocated buffers are used, there is no explicit full initialization (e.g., zeroing) before use. The content is immediately populated from source strings, which is a form of initialization, but the specification about ensuring memory is initialized before use is relevant to prevent information leaks from uninitialized memory. The relevance is strong but not perfect because the data is copied, not left uninitialized.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error handling paths (early returns, goto beach). It generally maintains consistency by freeing `esil_buf` at the end via the `beach` label. However, there are early returns before `esil_buf` is allocated that skip the cleanup, which is fine. The principle of maintaining consistent object states in error paths is moderately relevant, as the function manages dynamically allocated memory and should ensure it is freed correctly.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a static analysis function for extracting arguments from disassembled instructions. It does not handle network protocols or process network input. The specification is about network protocol handlers, which is completely unrelated to this code's purpose.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It performs string manipulation (e.g., `strstr`, `strncmp`) but not regex parsing. The specification about embedded NUL bytes in regex patterns is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It works with ESIL strings and stack variable extraction, not pattern compilation. The specification is irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses string functions like `strstr`, `strncmp`, and `r_str_isnumber` on strings derived from disassembly (`op_esil`). These inputs could be considered untrusted (from binary analysis). The code does not use length-aware operations (e.g., `strnstr`, `strncmp` with bounds), but it does ensure null-termination and uses pointers within the allocated buffer. There is moderate relevance because the principle of safe string handling applies, but the code does not strictly follow length-aware operations.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory via `strdup` and `r_str_newf`, which internally handle buffer sizing. There is no explicit buffer allocation with padding or safety margins. The specification about accounting for padding requirements is weakly relevant because any string allocation must account for the null terminator, which standard functions do. However, the code does not perform low-level buffer allocation with manual size calculations.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform image compression operations or manage encoder buffers. It is part of a binary analysis tool for stack variable extraction. The specification is completely unrelated.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2016-10156_before_exclude_100:905b4d53:spec": {
    "timestamp": "2026-01-17T00:14:05.928904",
    "cve_id": "CVE-2016-10156",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "905b4d53",
    "scores": [
      {
        "score": 9,
        "reasoning": "HS-SEC-001 is highly relevant. The code performs privilege separation (dropping privileges via setuid/setgid). The specification mandates immediate termination on failure. The code partially follows this by exiting only when EXIT_ON_SETUID_FAILURE is defined and the error is EAGAIN. This is a strong but not perfect match, as termination is conditional.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "HS-STATE-002 has moderate relevance. The code performs a security-critical state transition (privilege drop). The specification calls for atomic verification. The code verifies the success of setuid and setgid calls individually and updates the internal state (euid, egid) only after successful calls, which aligns with the principle of verifying the transition. However, it's not a complex multi-step atomic operation.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "HS-CONF-003 has very low relevance. The code snippet is about runtime privilege management, not about a daemon validating its configuration before starting operation. There is no configuration parsing or validation present.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-001 (regex/NUL bytes) has no relevance. The code does not involve regular expression parsing or input pattern handling.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-002 (pattern compilers/escape sequences) has no relevance. The code deals with system calls for privilege management, not with compiling patterns or processing escape sequences.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-003 (length-aware string ops) has no relevance. The code uses sys_error (likely a printf-style function) but does not show string processing of untrusted input. The function arguments are integers.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-001 (network length values) has no relevance. The code does not process network data or validate length values from any external source.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-002 (protocol option parsers) has no relevance. The code is not parsing a network protocol or variable-length fields from a message.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2016-10156_after_exclude_100:eb7952c7:spec": {
    "timestamp": "2026-01-17T00:14:11.134489",
    "cve_id": "CVE-2016-10156",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "eb7952c7",
    "scores": [
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The code performs privilege separation (dropping privileges to a non-privileged user). While it logs an error on failure, it only forces immediate termination via `exit(e)` in a specific, conditional case (`#if defined (EXIT_ON_SETUID_FAILURE)` and `e == EAGAIN`). This partial enforcement aligns strongly with the principle that privilege separation failures must be fatal, but the implementation is not universally strict.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "The code performs a security-critical state transition (changing effective UID/GID). It verifies the success of the `setresuid`/`setuid` and `setresgid`/`setgid` calls. However, the verification is not fully atomic in a transactional sense; if the UID set succeeds but the GID set fails, the process is left in a mixed state (UID changed, GID not changed), and it only logs an error for the GID failure. The principle of atomic verification applies, but the implementation is incomplete.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "This specification is about validating runtime configuration for security-sensitive daemons before they begin operation. The target code is a function for dropping privileges during runtime, not a configuration validation routine. There is no direct relationship to configuration validation.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "This specification concerns regular expression parsers and handling of NUL bytes. The target code performs privilege management and has no string parsing, regular expressions, or input pattern handling.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This specification is about pattern compilers and escape sequence processing. The target code performs privilege management via system calls and has no text pattern compilation, escape sequence processing, or similar functionality.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "This specification mandates length-aware string operations for untrusted input. The target code does not process any strings from external input; it only calls system functions and logs errors using fixed format strings.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This specification is about validating network-derived length values. The target code does not handle network data, parse packets, or process any externally provided length values.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "This specification is about protocol parsers validating variable-length fields. The target code is a privilege management function and does not implement any network protocol parsing logic.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2017-12898_before_exclude_100:010b21f2:spec": {
    "timestamp": "2026-01-17T00:14:14.506934",
    "cve_id": "CVE-2017-12898",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "010b21f2",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expression parsing. The weak connection is that both deal with input validation, but the mechanisms and contexts are entirely different.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code is a binary header validation function for a TPM NVRAM blob, with no pattern compilation or escape sequence processing involved.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The specification is highly relevant. The function validates the input `length` against `sizeof(bh)` before performing any operations on the `data` buffer, which is a form of length-aware operation on potentially untrusted input to prevent buffer over-reads.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is moderately relevant. The code validates the `bh->totlen` field against the provided `length` parameter. However, it does not check for platform-specific integer limits (e.g., overflow when converting from network byte order) before the comparison, which is a key part of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification is weakly relevant. The code performs a basic size validation (`length < sizeof(bh)`), which is related to usage requirements. However, it does not involve any explicit memory allocation operations, which is the core focus of this specification.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is moderately relevant. The code handles network byte order (`ntohl`, `ntohs`) for header fields, which is a form of consistent type handling (endianness) across processing stages. However, the specification's scope is broader, often encompassing complex protocol state machines.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is weakly relevant. The code validates a length field (`totlen`) against an input, which is a general principle of the spec. However, it does not enforce RFC-specified constraints, as the blob header format appears to be an internal/proprietary protocol.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification is highly relevant. The function validates the overall blob length (`totlen`) and ensures there are enough bytes for the header (`sizeof(bh)`) before accessing any fields within the `blobheader` structure. This is classic bounds checking prior to field access, analogous to TLV processing. The only minor gap is that it doesn't validate the `hdrsize` field against `length` before calculating the `*dataoffset`.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2017-12898_after_exclude_100:a71eba38:spec": {
    "timestamp": "2026-01-17T00:14:42.099514",
    "cve_id": "CVE-2017-12898",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a71eba38",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code validates a binary blob header and does not involve regular expression parsing. The connection is very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code performs binary data validation with no pattern compilation or escape sequence processing. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The specification advocates for length-aware operations on untrusted input. The target code validates the input `length` parameter against the header size (`sizeof(bh)`) and the `totlen` field from the data, which is a direct application of this principle to prevent buffer over-reads.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 9,
        "reasoning": "The specification requires validating protocol message length fields against limits. The code validates `bh->totlen` (converted via `ntohl`) against the provided `length` parameter. This is a core check to ensure the claimed data length matches the actual buffer size, preventing out-of-bounds access. The relevance is strong.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating memory allocation size parameters. The target code validates existing data sizes but does not perform any memory allocation itself (e.g., malloc, calloc). The connection is weak, as the principle of size validation is related but not directly applied to allocation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification calls for consistent type handling. The code uses `ntohl`/`ntohs` to convert network-order fields to host order for comparison, ensuring consistent integer interpretation. It also compares a `uint16_t` (`hdrsize`) to a `size_t` (`sizeof(blobheader)`). The relevance is moderate.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing RFC-specified length constraints. While there's no explicit RFC mentioned, the code enforces internal structural constraints: the header size (`hdrsize`) must equal `sizeof(blobheader)`. This is a form of length constraint validation, giving it moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification mandates complete bounds checking before TLV (Type-Length-Value) field access. The code validates the overall `length` before accessing the header struct and validates the internal `totlen` and `hdrsize` fields before using them to calculate offsets (`*dataoffset = hdrsize`). This is a direct and critical application of the principle.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2019-12973_before_exclude_100:d93eea82:spec": {
    "timestamp": "2026-01-17T00:15:39.109419",
    "cve_id": "CVE-2019-12973",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d93eea82",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs quantization calibration operations (finding min/max values, computing ranges). It does not involve any cryptographic operations on secret values. The timing characteristics of this numerical computation are not security-sensitive in a cryptographic context.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve implementations. It is purely a numerical quantization calibration routine for tensor processing.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform cryptographic processing or handle cryptographic secrets. The memory operations are standard tensor manipulations without constant-time requirements.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Weak connection. The code uses std::vector with size determined by 'depth', which is validated against input tensor sizes. While not about cryptographic buffer expansion, there is some relevance to ensuring buffer sizes are properly calculated from validated inputs.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed-size buffers must account for maximum potential expansion during mathematical oper..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates input tensor dimensions (depth) before using them, and allocates memory based on these validated values. The arithmetic operations for range calculations are bounded by the tensor data, though not explicitly validated for overflow beyond the existing bounds checks.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-002: Arithmetic operations affecting memory allocation must be bounded and validated"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates external parameters (input_min, input_max tensor dimensions) against expected sizes before processing. However, it doesn't perform extensive sanitization of the actual float values within these tensors beyond basic usage.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: External parameters affecting memory operations must be sanitized"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses dynamic allocation (std::vector) rather than fixed buffers, but does perform bounds validation on input tensor dimensions before creating the vector. The write operations to the vector are bounded by the validated depth.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements complete input size validation before processing through OP_REQUIRES checks that verify input_min and input_max have the expected size (depth). This prevents processing of malformed or incorrectly sized inputs.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2021-37665_after_exclude_100:bc02801d:spec": {
    "timestamp": "2026-01-17T00:15:51.314202",
    "cve_id": "CVE-2021-37665",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bc02801d",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs quantization calibration (finding min/max values per channel) on tensor data. It does not involve any cryptographic operations on secret values. The operations are data-dependent (finding minimum, maximum, and scales) but this is not a security concern for cryptographic secrets.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It is a tensor quantization operation in a machine learning context.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform cryptographic processing or secure memory operations that require constant-time properties. It is processing tensor data for quantization calibration.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses a fixed-size vector `ranges(depth)` where `depth` is derived from input tensor dimensions. While there's no explicit buffer overflow risk due to using `std::vector`, the specification about accounting for maximum potential expansion during mathematical operations has minimal relevance since the operations are scaling calculations, not buffer expansions.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed-size buffers must account for maximum potential expansion during mathematical oper..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs arithmetic operations and validates input dimensions before processing. The `OP_REQUIRES` checks validate that input sizes match expected dimensions, which relates to bounding and validating operations that could affect memory access patterns. However, there are no explicit memory allocations based on arithmetic results in this code snippet.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-002: Arithmetic operations affecting memory allocation must be bounded and validated"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code validates external parameters (input tensor dimensions) through multiple `OP_REQUIRES` checks before performing memory operations. It ensures input_min, input_max, and input tensors have correct dimensions and relationships, which is a form of input sanitization for memory safety.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: External parameters affecting memory operations must be sanitized"
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. While the code doesn't use fixed buffers (it uses `std::vector`), it does validate bounds through dimension checks before accessing tensor data. The `OP_REQUIRES` checks ensure tensor dimensions are correct before performing operations that access memory, which aligns with the principle of bounds validation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements comprehensive input size validation before processing through multiple `OP_REQUIRES` checks. It validates that: 1) input_min and input_max have correct sizes matching depth, 2) input is not empty, 3) input has correct dimensions (4D, NHWC format), and 4) input channels match depth. This is complete input size validation as specified.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2022-31796_before_exclude_100:5f8d5a93:spec": {
    "timestamp": "2026-01-17T00:16:04.951825",
    "cve_id": "CVE-2022-31796",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f8d5a93",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation based on image dimensions (m_ulPixelWidth, m_ulPixelHeight) and component counts (m_ucCount). Specification HS-LOGIC-001 is strongly relevant because the code should validate that calculations like \"m_ucCount*8\" and \"m_ulPixelWidth * m_ulPixelHeight\" (implicit in upsampler creation) do not overflow and are within safe bounds before allocation.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must validate against maximum safe values before memory a..."
      },
      {
        "score": 5,
        "reasoning": "The code uses values like m_ucCount, m_ulPixelWidth, and m_ulPixelHeight which likely originate from external image data (e.g., JPEG headers). Specification HS-INPUT-002 is moderately relevant as these values should be validated before being used in memory allocation calculations. However, the validation is not shown in this snippet.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: External input must be validated before use in memory operations"
      },
      {
        "score": 9,
        "reasoning": "The code directly performs memory allocations via m_pEnviron->AllocMem() based on calculated sizes (e.g., sizeof(struct Line *) * m_ucCount*8). Specification HS-MEM-003 is highly relevant as the return value of AllocMem() should be checked for NULL to prevent subsequent use of unallocated memory, which is not done here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory allocation must be validated against calculated size requirements"
      },
      {
        "score": 5,
        "reasoning": "The code explicitly initializes allocated memory to zero using memset() for both m_ppDecodingMCU and m_ppUpsampler arrays. This directly aligns with HS-MEM-001's requirement to fully initialize memory before use, preventing use of uninitialized pointers.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 is weakly relevant. The code shows potential error paths (if allocations fail, memset or CreateUpsampler could fail), but it doesn't handle them. However, the primary focus of this spec (maintaining consistent object states during errors) is not directly addressed, and the code structure is simple enough that state corruption might be limited.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-003 is very low relevance. The target code is part of an image decoder's preparation routine and does not contain any network protocol handling logic. The context is file/stream parsing, not network communication.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-001 (image decoder variant) is strongly relevant. The code is clearly part of an image decoder (HierarchicalBitmapRequester). It uses pixel dimensions (m_ulPixelWidth, m_ulPixelHeight) and component data to allocate memory. These dimensions must be validated against a maximum supported value to prevent excessive memory allocation, which is not shown here.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Image decoders must validate pixel allocation calculations against maximum supported dim..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 (image decoder variant) is moderately to strongly relevant. The code uses header-derived values (component count m_ucCount, subsampling factors sx, sy, pixel dimensions). These values must be validated for sanity (e.g., non-zero, within expected range, sx/sy being reasonable like 1,2,4) before being used in calculations and allocations, which is not evident in this function.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Image decoders must validate all header values before memory allocation"
      }
    ]
  },
  "CVE-2017-14151_after_exclude_100:e294828b:spec": {
    "timestamp": "2026-01-17T00:16:09.773285",
    "cve_id": "CVE-2017-14151",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e294828b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation based on image dimensions (m_ulPixelWidth, m_ulPixelHeight) and component counts (m_ucCount). Specification HS-LOGIC-001 is strongly relevant because it requires validation of image dimension calculations before allocation. The code does not show explicit validation of these dimensions against maximum safe values, which could lead to integer overflow in the size calculations (e.g., m_ucCount * 8 * sizeof(struct Line *)).",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must validate against maximum safe values before memory a..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 has weak relevance. While the code uses values like m_ucCount, sx, sy, m_ulPixelWidth, and m_ulPixelHeight for memory operations, these appear to be internal state derived from the image frame/component objects rather than direct external input. The specification focuses on validating external input before use, which is not clearly demonstrated in this code snippet.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: External input must be validated before use in memory operations"
      },
      {
        "score": 9,
        "reasoning": "Specification HS-MEM-003 is highly relevant. The code performs multiple memory allocations via m_pEnviron->AllocMem() but does not check if the allocations succeeded. The calculated sizes involve multiplications (m_ucCount * 8, m_ucCount * sizeof(pointer)) which could overflow. The specification directly requires validating memory allocation against calculated size requirements, which is missing here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory allocation must be validated against calculated size requirements"
      },
      {
        "score": 10,
        "reasoning": "Specification HS-MEM-001 is highly relevant and directly applicable. The code uses memset() to initialize allocated memory to zero after both allocations (m_ppEncodingMCU and m_ppDownsampler). This follows the specification's requirement to fully initialize memory before use, preventing use of uninitialized memory.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 has moderate relevance. The code modifies object state (allocating memory, setting m_bSubsampling) but lacks error handling if allocations fail. If AllocMem() returns NULL, the memset would crash, and the object state would be inconsistent. The specification's principle about maintaining consistent states in error paths applies, though not fully addressed.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Specification HS-IO-003 has very low relevance. The code is part of an image encoding preparation routine (PrepareForEncoding) and deals with internal memory allocation and downsampler creation. There is no network protocol handling or network input processing in this code snippet.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "Specification HS-MEM-001 (for image decoders) is strongly relevant. Although this is encoding preparation, it involves image dimension calculations (m_ulPixelWidth, m_ulPixelHeight) for downsampler creation and memory allocation. The code should validate pixel allocation calculations against maximum supported dimensions to prevent overflow, which aligns with the specification's intent.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Image decoders must validate pixel allocation calculations against maximum supported dim..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 (for image decoders) has weak relevance. The code uses component properties (sx, sy from comp->SubXOf/SubYOf) and image dimensions, which likely originate from image headers. However, this is encoding preparation, not decoding, and the validation of header values before allocation is not shown. The connection exists but is indirect.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Image decoders must validate all header values before memory allocation"
      }
    ]
  },
  "CVE-2022-0407_before_exclude_100:52c00f72:spec": {
    "timestamp": "2026-01-17T00:16:35.196869",
    "cve_id": "CVE-2022-0407",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "52c00f72",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It copies a line of text with optional space trimming. The handling of NUL bytes is not a central concern here, though the code does ensure string termination with NUL.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile patterns or process escape sequences. It performs simple memory copying and whitespace trimming.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code uses length-aware operations (mch_memmove with bd->textlen) for copying text, which is a good practice for handling potentially untrusted input to prevent buffer overflows. The text length is tracked and used for bounds calculations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code initializes memory with vim_memset for startspaces and endspaces regions, and ensures NUL termination. However, the primary text content from bd->textstart is copied without being initialized to a known safe state first, which could be an issue if the source memory contains sensitive data.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function has an error handling path when alloc fails (returns FAIL). It maintains consistency by not modifying y_current->y_array[y_idx] on allocation failure. However, the analysis of broader object state consistency is limited in this isolated function.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is not a network protocol handler. It processes an internal data structure (block_def) for line copying within an editor context.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs boundary validation implicitly by using length values (bd->textlen) for memory operations. The while loop for trimming trailing whitespace uses pointer arithmetic and a check `s > 0` to prevent underflow, which is a form of boundary validation. The use of `mb_head_off` suggests multi-byte character handling, making encoding boundary validation relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code is a simple copy/trim function, not a complex parser. It does maintain buffer state by calculating sizes and ensuring NUL termination, but the specification about \"parser input operations\" and \"buffer state invariants\" is more suited to iterative parsing scenarios.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-0407_after_exclude_100:a076e57e:spec": {
    "timestamp": "2026-01-17T00:17:18.483895",
    "cve_id": "CVE-2022-0407",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a076e57e",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It copies a line of text with optional space trimming. The handling of NUL bytes is not a primary concern here, though the code does ensure string termination with NUL.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not process escape sequences or compile patterns. It performs simple memory copying and space padding.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code uses length-aware operations (mch_memmove with bd->textlen) for copying text. This is a good practice to prevent buffer overflows, especially if the input (bd->textstart) could be untrusted or malformed.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code initializes the newly allocated memory using vim_memset for both startspaces and endspaces sections before use. This ensures no uninitialized memory is accessed.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code has an error check for memory allocation failure (returns FAIL). However, it doesn't show complex object state management. The function appears to maintain consistency by only assigning y_current->y_array[y_idx] on success.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This is not a network protocol handler. It processes internal data structures (block_def).",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses mb_head_off for multi-byte character handling when excluding trailing spaces, which implies some character encoding awareness. However, the primary buffer boundary validation comes from using the length parameter (bd->textlen) in mch_memmove, not a separate validation step.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code is a simple copy function, not a complex parser. It does maintain buffer state by correctly calculating pointers and ensuring NUL termination, but the specification's focus on \"parser input operations\" and \"invariants\" is not a strong match.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2021-29552_before_exclude_100:1c18874c:spec": {
    "timestamp": "2026-01-17T00:17:27.939387",
    "cve_id": "CVE-2021-29552",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1c18874c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs string concatenation operations in a tensor computation kernel. There are no cryptographic operations on secret values, and timing characteristics are not security-critical in this context.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor operation for string segmentation and concatenation, not an elliptic curve implementation. No cryptographic operations or side-channel resistance considerations are present.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "No cryptographic processing or secure memory operations are performed. The code manipulates tensor data for string operations without cryptographic context.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code is a computational kernel operating on tensor data structures. There are no view-based data access mechanisms, privilege checks, or database/view security semantics involved.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "This is a pure computation function without security-critical state transitions, privilege contexts, or authentication mechanisms.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The code implements tensor operations, not SQL protocol implementations. No database access, query processing, or view security semantics are present.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs array write operations (output_flat(output_index).append()) and includes bounds validation through OP_REQUIRES checks that validate segment_id values against num_segments. However, it doesn't explicitly validate that output_index stays within output_flat bounds, which could be a concern.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code extensively validates input parameters: checks segment_id rank, validates dimensions match between input and segment_id, verifies segment_id values are within [0, num_segments), and enforces domain constraints through multiple OP_REQUIRES statements.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Profile-specific parameter validation must enforce domain constraints"
      }
    ]
  },
  "CVE-2016-5844_after_exclude_100:605823e9:spec": {
    "timestamp": "2026-01-17T00:17:39.310513",
    "cve_id": "CVE-2016-5844",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "605823e9",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs string concatenation operations in a tensor computation kernel. There are no cryptographic operations on secret values, and the execution time is data-dependent (appending strings based on conditions), but this is not a security concern for cryptographic secrets.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code is a tensor operation for segment concatenation, not an elliptic curve implementation. No cryptographic operations or curve models are involved.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No secure memory operations or cryptographic processing is present. The code manipulates tensor data for string concatenation without cryptographic context.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "No view-based data access, privilege checks, or database view semantics. This is a computational kernel operating on tensor data structures.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "No security-critical state transitions or privilege context management. The code performs data transformation without security state changes.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "No SQL protocol implementation or database access. The code is a tensor computation kernel unrelated to database security semantics.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code performs array write operations (output_flat(output_index).append()) and includes bounds validation through OP_REQUIRES checks that validate segment_id values against num_segments. However, the validation occurs before the write loop, which is appropriate.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs parameter validation (OP_REQUIRES) for segment_id dimensions and values, enforcing domain constraints like non-empty tensors, valid ranks, and value ranges. This aligns with input validation principles, though not specifically \"profile-specific\".",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Profile-specific parameter validation must enforce domain constraints"
      }
    ]
  },
  "CVE-2013-2124_before_exclude_100:ab5ff0c7:spec": {
    "timestamp": "2026-01-17T00:17:58.296657",
    "cve_id": "CVE-2013-2124",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ab5ff0c7",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about initializing memory allocations before use. The target code is freeing/deallocating memory (reclaim_ramblock), not allocating or using uninitialized memory. The connection is weak as it deals with memory lifecycle but at the opposite end (cleanup vs. initialization/use).",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The specification is about maintaining consistent object states in error handling paths. The target code modifies global state (removing from QLIST, setting mru_block to NULL) before performing the final cleanup (reclaim_ramblock). This is a cleanup path, and the order of operations is critical to keep the global RAM list consistent. Strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The specification is about network protocol handlers validating input. The target code is a low-level memory management function with no network or input processing. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The specification is about bounds checking for image compression encoder buffers. The target code is a generic RAM freeing function with no relation to image compression or bounds checking. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The specification is about maintaining consistent memory state across all execution branches in error handling. This is highly relevant. The function modifies the global RAM list state (QLIST_REMOVE, setting mru_block) before the final memory reclamation. If `reclaim_ramblock` were to fail or if the state changes were not atomic, it could leave the system in an inconsistent state. The commented-out RCU callback suggests concurrency concerns, making state consistency critical.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 1,
        "reasoning": "The specification is about input validation before memory operations. The target code performs a simple NULL check but does not process or validate complex external inputs. The function's primary purpose is internal resource cleanup. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      },
      {
        "score": 1,
        "reasoning": "The specification is about validating protocol message length fields. The target code does not parse any protocol messages or handle length fields. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      }
    ]
  },
  "CVE-2013-2124_after_exclude_100:d0483ac9:spec": {
    "timestamp": "2026-01-17T00:18:20.554007",
    "cve_id": "CVE-2013-2124",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d0483ac9",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is freeing memory, not allocating and initializing it for use. The specification about initializing allocations before use has weak relevance to this deallocation function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. This is a memory management function with no network protocol handling or input processing.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The specification concerns buffer allocation with padding requirements, while this code deals with memory deallocation of already allocated blocks.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The function performs RAM block cleanup, not image compression operations or bounds checking for encoder buffers.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This is essentially a more specific version of HS-STATE-002 applied to memory. The function must ensure consistent memory state when freeing RAM blocks, properly removing them from lists and cleaning up resources across all execution paths.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the function checks if the block pointer is NULL, this is basic parameter validation rather than establishing boundaries before memory operations. The core function is memory deallocation, not input processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function deals with internal memory management, not protocol message parsing or validation of length fields against integer limits.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      }
    ]
  },
  "CVE-2017-9619_before_exclude_100:6a2f429c:spec": {
    "timestamp": "2026-01-17T00:19:01.913965",
    "cve_id": "CVE-2017-9619",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6a2f429c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs a tensor gather operation (data indexing). It does not involve parsing or processing regular expressions, which is the focus of HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not compile patterns or process escape sequences. It is a numerical data manipulation function for machine learning inference.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code performs a non-cryptographic data indexing operation. There is no manipulation of secret values or any cryptographic logic present.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic implementations.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code copies tensor data but is not performing cryptographic processing. The requirement for constant-time properties during memory operations is specific to cryptographic contexts, which do not apply here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code is a low-level tensor operation within a runtime. It does not involve database views, access control, or privilege checks based on ownership.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code performs a simple, stateless data transformation. It does not manage security-critical state or perform privilege context transitions.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2017-9619_after_exclude_100:7bb5027c:spec": {
    "timestamp": "2026-01-17T00:19:04.917548",
    "cve_id": "CVE-2017-9619",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7bb5027c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing. It is a tensor gathering operation for machine learning inference.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It handles numerical tensor data.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes the `positions` tensor, which could be considered untrusted input. It correctly calculates `num_indices` based on the tensor's byte size (`positions->bytes`) and the size of its data type, which is a length-aware operation. However, the primary focus is on numerical bounds checking (positivity) rather than string handling.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs a gather operation for neural network inference. It does not perform any cryptographic operations on secret values.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code does not implement elliptic curve cryptography or any cryptographic primitives.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform cryptographic processing or secure memory operations that require constant-time properties. It is a standard data indexing operation.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve view-based data access, database systems, or privilege checks. It operates on in-memory tensor structures.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code does not manage security-critical state transitions or privilege contexts. It is a pure data processing function.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2016-8670_before_exclude_100:c4a4e548:spec": {
    "timestamp": "2026-01-17T00:19:35.293463",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c4a4e548",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code parses AV1 configuration (similar to image/video format headers). It validates critical header fields (marker, version, reserved bits) early and rejects invalid configurations. This directly aligns with HS-INPUT-001's requirement to validate critical header fields before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs memory allocation for OBU data (a->obu = gf_malloc((size_t)obu_size)) but does not explicitly pre-validate the obu_size parameter against reasonable maximums before allocation. However, it does check if size<obu_size later, which offers some protection. The principle of guarding allocations with size validation applies.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The specification is specifically for BMP parsers and bit count requirements. The target code is for AV1 video format parsing, which is a different protocol with different specifications. No direct connection.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates size fields against remaining data. It tracks a 'size' variable decremented from the input, checks \"if (size<obu_size)\" before processing, and breaks if insufficient data remains. This follows HS-MEM-001's principle of validating size fields against available buffer space.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: File format parsers must validate all size fields against remaining buffer space before ..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. While not an archive parser, the code extracts OBU structures with sizes (obu_size) and validates them against both the declared total size (the 'size' variable) and the available stream data (implicitly via parsing functions). The general principle of validating extracted sizes applies.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all extracted sizes against both declared and available ..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification about buffer allocation padding and safety margins is not directly addressed. The code performs basic allocations (gf_malloc) without evident consideration for operational padding or safety margins beyond size checks.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification concerns image compression encoder buffers. This code is a parser/decoder reading configuration data, not performing compression or managing encoder buffers.",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code allocates memory (a->obu) and immediately initializes it by reading data from the bitstream. The GF_SAFEALLOC for the array entry likely zero-initializes the structure. However, the specification about full initialization before use is only partially addressed, as other allocated structures (cfg via gf_odf_av1_cfg_new) may not be fully detailed.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      }
    ]
  },
  "CVE-2019-25034_after_exclude_100:529ec8c9:spec": {
    "timestamp": "2026-01-17T00:19:47.023807",
    "cve_id": "CVE-2019-25034",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "529ec8c9",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code parses AV1 configuration data (similar to an image/video format parser). It validates critical header fields (marker, version, reserved bits) early in the parsing process and rejects invalid configurations. This directly aligns with HS-INPUT-001's requirement to validate critical header fields before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs memory allocation for OBU data based on the parsed `obu_size`. While there is a check `if (size<obu_size)` later, the allocation `gf_malloc((size_t)obu_size)` occurs before this validation against the remaining `size`. The principle of pre-validating size parameters before allocation applies, but the check order could be improved.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification specifically targets BMP parsers and bit count requirements. The target code is for parsing AV1 (video) configuration, a completely different format and protocol.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a core activity in the function. The code tracks a `size` parameter representing remaining buffer space. It validates parsed OBU sizes against this remaining `size` (`if (size<obu_size)`) before proceeding and subtracting from the total. This directly implements the principle of validating size fields against available buffer space.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: File format parsers must validate all size fields against remaining buffer space before ..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. While not an archive parser, the function parses a serialized configuration structure containing embedded OBU elements. It validates the size of each extracted OBU (`obu_size`) against both the declared remaining data (`size`) and the available data in the bitstream (implied by successful parsing). The core principle of validating extracted sizes applies strongly.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all extracted sizes against both declared and available ..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification concerns allocation padding for operational safety margins. The code performs straightforward allocations (`gf_malloc`) based on parsed sizes without evident consideration for additional padding or safety margins. The connection is weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is about bounds checking for image compression encoder buffers. This code is a parser/decoder for a configuration box, not a compression encoder operation. The context mismatch is significant.",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification requires memory initialization before use. The code allocates memory (`a->obu = gf_malloc(...)`) and then immediately writes data into it via `gf_bs_read_data`, which initializes it. However, the structure `GF_AV1_OBUArrayEntry *a` allocated by `GF_SAFEALLOC` might not be fully zero-initialized (depends on `GF_SAFEALLOC` implementation). The connection exists but is indirect and implementation-dependent.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      }
    ]
  },
  "CVE-2022-3134_before_exclude_100:cad980e4:spec": {
    "timestamp": "2026-01-17T00:20:09.098176",
    "cve_id": "CVE-2022-3134",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cad980e4",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes tag patterns which can be regular expressions (when name starts with '/'). The function `find_tags` is called with the pattern, and embedded NUL bytes could potentially cause issues in pattern parsing. While the direct regex parsing is not shown, the principle of safely handling input patterns is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code deals with tag patterns and escape sequences in tag names/files, but the specification focuses on pattern compilers maintaining strict boundaries. There is some weak relevance as tag processing could involve escape sequences, but it's not the main focus of this function.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The code extensively processes strings (tag names, file names) using functions like STRCMP, vim_strsave, and string manipulation. While some operations appear safe, the principle of using length-aware operations for potentially untrusted input is moderately relevant, especially for tag names that may come from external tag files.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "The code accesses arrays like tagstack with bounds checking (e.g., checking tagstackidx < tagstacklen). There are also buffer operations in string handling. The principle of validating bounds before dereferencing is moderately relevant, though most accesses appear guarded.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code validates input before processing (e.g., checking for empty tag stack, validating indices). The principle of enforcing structural constraints before content processing is moderately relevant, though not specifically for complex parsers.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "The code has no XML processing. This specification is about XML protocol implementation and boundary integrity during XML parsing, which doesn't apply to this tag navigation functionality.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "The code handles error conditions with goto statements and error messages, but doesn't clearly demonstrate atomic setting of both error code and error state. The principle is weakly relevant as error handling is present but not in the atomic manner specified.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Error conditions must atomically set both error code and error state"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't process named group references in regular expressions. This specification is specifically about validating named group references before processing, which doesn't apply to this tag navigation code.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser must validate all named group references before processing"
      }
    ]
  },
  "CVE-2022-3134_after_exclude_100:7b1c1596:spec": {
    "timestamp": "2026-01-17T00:20:54.603691",
    "cve_id": "CVE-2022-3134",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7b1c1596",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes tag patterns which can be regular expressions (when name starts with '/'). It uses the find_tags() function with TAG_REGEXP flag. While the code doesn't explicitly show regex parsing, the specification about handling embedded NUL bytes in regex patterns is relevant since tag patterns come from user input and could contain NUL bytes that might bypass pattern matching or cause issues.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code deals with tag patterns that might contain escape sequences, but there's no explicit pattern compiler shown. The find_tags() function likely processes these patterns, but the code doesn't show low-level escape sequence handling. Some relevance exists for maintaining boundaries when processing tag patterns.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code extensively uses string operations on tag names and matches (vim_strsave, STRCMP, etc.). While Vim has its own string handling, the principle of using length-aware operations for potentially untrusted input applies since tag names come from external tag files and user input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code accesses arrays like tagstack with bounds checking (tagstackidx < tagstacklen). However, there are potential issues like tagstackidx being decremented without sufficient validation in some paths. Buffer access validation is present but not comprehensive throughout.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates structural constraints like checking if tagstack is empty before operations. However, the validation happens after some processing. The principle applies to tag pattern validation and stack state checking.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code doesn't involve XML protocol parsing. It deals with tag navigation in Vim, not XML processing. No XML-related functions or structures are present.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code sets error messages using emsg() and semsg() functions, but doesn't show atomic error state setting. Error handling is scattered with goto statements. Some error conditions set skip_msg flag, but not a comprehensive error state system.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Error conditions must atomically set both error code and error state"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code doesn't process named group references in regular expressions. While it handles tag patterns that could be regexes, there's no evidence of named group reference validation. The specification is too specific to regex named groups.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser must validate all named group references before processing"
      }
    ]
  },
  "CVE-2017-18249_before_exclude_100:ac6bfc52:spec": {
    "timestamp": "2026-01-17T00:20:55.077449",
    "cve_id": "CVE-2017-18249",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ac6bfc52",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs direct memory access via `kmap(page)` and pointer arithmetic (`curr = pptr + ...`). While it operates on page-mapped kernel memory (which is generally aligned), the pointer calculations and bitwise operations on the data (`__be32 *`) must respect natural alignment for safe access. The use of `be32_to_cpu` and `cpu_to_be32` suggests handling of big-endian data, which may have alignment considerations on some architectures. The relevance is strong but not absolute, as the page mapping mechanism provides a base level of alignment safety.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "This code is a filesystem block allocator, not a network protocol implementation. It reads bitmap data from a file's address space. There is no protocol message structure to validate. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      },
      {
        "score": 5,
        "reasoning": "The code processes bitmap data read from storage (a file). This data could be corrupted or misaligned on disk. The code uses careful bitwise arithmetic (`offset & (PAGE_CACHE_BITS - 1)`, `(size + 31) & (PAGE_CACHE_BITS - 1)`) to navigate within the bitmap, which is a form of handling potentially misaligned bit-granular requests. However, it does not explicitly validate that the underlying data from `read_mapping_page` is safe to interpret as an array of `__be32`. The relevance is moderate.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-003: Input processing must handle misaligned data safely"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform its own memory allocation (e.g., `kmalloc`). It uses `kmap` on a page returned by `read_mapping_page`. The initialization concern for this code is whether the bitmap data from the page is valid, not whether allocated memory is initialized. The page content is initialized by the filesystem read operation. The specification has weak connection.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has several exit paths (normal return, early break to \"bitmap full\", goto out/done). It must maintain consistency of system state (e.g., `HFSPLUS_SB(sb).free_blocks`, `sb->s_dirt`, page dirty flag, mutex lock state). The mutex is locked at the start and unlocked in a single `out:` path, which is good. However, the error handling for `read_mapping_page` failures is not shown (it's passed NULL, so it likely panics on error), which is a critical omission. The relevance is moderate.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a filesystem bitmap manipulation function, not a network protocol handler. The \"input\" is parameters and on-disk bitmap data, not network packets. The specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code contains numerous arithmetic operations on `u32` variables (`size`, `offset`, `len`, `start`) and pointer arithmetic. It must ensure calculations like `offset / PAGE_CACHE_BITS`, `curr - pptr`, `start = offset + (curr - pptr) * 32 + i` do not overflow and produce valid indices. The use of `min(size - start, len)` is a good boundary check. The loop conditions and comparisons (`offset >= size`, `start >= size`) provide some validation. The relevance is strong.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 5,
        "reasoning": "This function is a core part of a filesystem parser/allocator. It directly reads and interprets the filesystem's allocation bitmap structure. It must validate that the `offset` and `size` parameters (which likely derive from filesystem metadata) are within the physical constraints of the bitmap. The code does perform checks like `if (start >= size)` and uses `min(size - start, len)`, but a comprehensive validation of the input parameters against the actual bitmap size is not fully visible. The principle is highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      }
    ]
  },
  "CVE-2019-1010065_after_exclude_100:42ea0279:spec": {
    "timestamp": "2026-01-17T00:21:34.155277",
    "cve_id": "CVE-2019-1010065",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "42ea0279",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs direct memory access via kmap and pointer arithmetic on data read from disk (bitmap). It uses `__be32` pointers and accesses them via `curr` and `pptr`. While the code assumes the data is aligned (as it's reading from a page), it does not explicitly validate alignment before dereferencing pointers. The specification about respecting platform alignment is highly relevant, as misaligned access on some architectures can cause faults or performance penalties. The code's reliance on the kernel's page mapping providing proper alignment reduces the direct risk, but the principle is strongly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "This specification is about validating message structure in protocol implementations. The target code is a filesystem bitmap allocator, not a network or communication protocol handler. There is no protocol message parsing involved. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      },
      {
        "score": 5,
        "reasoning": "The code processes a bitmap from disk (an input data structure). It handles data that is read in pages and interprets bits within those pages. While it doesn't explicitly check for \"misaligned data\" in the sense of byte offsets, it does calculate offsets within a page and handles partial u32 boundaries. The principle of safely handling input data that may not be perfectly aligned to the processor's preferred access patterns is moderately relevant.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-003: Input processing must handle misaligned data safely"
      },
      {
        "score": 5,
        "reasoning": "The specification is about initializing memory allocations before use. The code uses `kmap` to map a page from the page cache, which contains data from disk. It does not allocate new memory via kmalloc/vmalloc. The page's content is considered already initialized by the filesystem (the bitmap). The relevance is low, as the scenario is about mapping existing data, not allocating fresh, uninitialized memory.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function has multiple error paths (e.g., `IS_ERR(page)` leading to `goto out`) and a success path that modifies global state (`HFSPLUS_SB(sb).free_blocks`, `sb->s_dirt`). The error paths must ensure that the mutex is unlocked (which it does via `goto out`), but also that the global filesystem state remains consistent if an error occurs partway through modifying the bitmap. The code appears to handle this by only updating the global free block count and dirty flag at the very end, after all bitmap modifications are successfully written. This is a strong example of maintaining consistent state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec_2, this is about network protocol handlers. The target code is a filesystem function. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code contains several arithmetic operations for calculating offsets, pointers, and bounds (e.g., `offset / PAGE_CACHE_BITS`, `curr = pptr + ...`, `start = offset + (curr - pptr) * 32 + i`). It must ensure these calculations do not overflow or result in out-of-bounds pointer values. The use of `size`, `offset`, and `len` parameters requires validation against each other and against the bitmap size. The code shows some validation (e.g., `if (start >= size)`), making the principle of validating arithmetic against boundaries strongly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function is a filesystem parser/allocator that reads and interprets the on-disk bitmap structure. It must validate all structural fields against physical constraints: the `offset` and `size` parameters must be validated against the actual bitmap size, and pointer calculations (`end`, `curr`) must stay within the bounds of the mapped page. The code does this through comparisons like `if (offset >= size) break;` and careful calculation of the `end` pointer based on whether the current page is the last one. The core task of the function aligns directly with this specification.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      }
    ]
  },
  "CVE-2019-25034_before_exclude_100:76d6414d:spec": {
    "timestamp": "2026-01-17T00:21:40.651380",
    "cve_id": "CVE-2019-25034",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "76d6414d",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not show explicit memory allocation. It uses a pre-allocated buffer `pThis->pMsg`. While there is a `memcpy` operation, the specification about initializing memory allocations before use is only weakly relevant because the focus is on copying data into an existing buffer, not on the allocation/initialization phase itself.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code contains error handling (e.g., for invalid octet count, oversize messages) and state transitions (e.g., `eAtStrtFram`, `eInOctetCnt`, `eInMsg`). However, the consistency of the object state across all error paths (like after logging an error) is not fully detailed. The `FINALIZE` macro and `finalize_it` label suggest some cleanup, making the specification moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "This is a network protocol handler (TCP syslog message processing). It validates input extensively: checking for digits, space delimiters, octet count range (`<1`, `>iMaxLine`), and message length against `iMaxLine`. This is a core part of the function, making the specification highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The code validates the octet count length field (`pThis->iOctetsRemain`) against a maximum message size (`iMaxLine`). It also checks for a minimum value (<1). However, it does not explicitly check for platform-specific integer overflow during the calculation `pThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';`, which could be a concern. The validation present is strong but not complete for all integer limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform memory allocation operations within the shown function. It uses a pre-allocated buffer `pThis->pMsg` and validates the copy size (`octatesToCopy`) against the remaining buffer space (`iMaxLine - pThis->iMsg`). This relates to usage requirements but not to the allocation limits themselves, resulting in weak to moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "The protocol handles two framing types (octet-stuffing and octet-counting). The code uses an enumeration (`eFraming`) and state machine to process them. Consistency is generally maintained, but the specification about \"type handling\" is broader (e.g., data type conversions) than the framing type handling shown here, making relevance moderate.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsers. It processes TCP syslog messages by reading characters and octet counts. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It handles raw message framing and content copying. This specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2018-20750_after_exclude_100:e27f20a8:spec": {
    "timestamp": "2026-01-17T00:21:47.674708",
    "cve_id": "CVE-2018-20750",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e27f20a8",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not show explicit memory allocation. It uses a buffer `pThis->pMsg` but does not demonstrate its allocation or initialization. There is a `memcpy` operation, but the focus is on boundary checking rather than initialization of newly allocated memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code contains error handling paths (e.g., for framing errors, oversize messages) that attempt to maintain consistent state by switching framing modes and resetting state variables. However, the `FINALIZE` macro jumps to cleanup without clear state restoration.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code is a network protocol handler (TCP syslog) that validates input extensively: checks for digits, space delimiters, message length limits, and framing modes before processing.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code validates octet count length fields against limits (iMaxLine, 200000000), preventing integer overflow and excessive memory consumption.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code checks message size against iMaxLine, it doesn't show actual memory allocation operations. The validation is for buffer usage rather than allocation parameters.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code maintains consistent framing type handling (octet counting vs. octet stuffing) across state transitions, but doesn't involve complex type systems.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not contain regular expression parsing or handle embedded NUL bytes in patterns. It processes TCP message framing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve pattern compilers or escape sequence processing. It handles TCP message framing and delimiter detection.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-41219_before_exclude_100:3e029333:spec": {
    "timestamp": "2026-01-17T00:22:41.651076",
    "cve_id": "CVE-2021-41219",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3e029333",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs matrix multiplication operations, not cryptographic operations on secret values. There is no handling of cryptographic keys, signatures, or other secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code implements general matrix multiplication functionality, not elliptic curve cryptography. There are no elliptic curve operations or any cryptographic curve models involved.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs standard matrix operations with no cryptographic processing. Memory operations are for general data processing, not cryptographic data that would require constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs arithmetic operations for matrix dimensions (m, k, n calculations) and allocates output tensors. While it doesn't explicitly show overflow protection with size_t, matrix dimension calculations could potentially overflow if dimensions are extremely large, though the code validates shape compatibility.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations for memory allocation must use overflow-protected calculations w..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code validates matrix dimensions and shape compatibility before processing. It checks that inputs are matrices and that inner dimensions match for multiplication. However, it doesn't explicitly check maximum allocation size before creating the output tensor, though the allocate_output method may have internal checks.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image dimension validation must include maximum allocation size checks before processi..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses ctx->allocate_output() for memory allocation, which is likely a wrapper that enforces boundaries. However, the code doesn't show explicit maximum safe allocation boundary checks before calling the allocation function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory allocation wrappers must enforce maximum safe allocation boundaries"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code works with dynamically allocated tensors rather than fixed buffers. It validates matrix dimensions before operations but doesn't show explicit bounds validation for write operations to the output matrix, relying on the tensor allocation size.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements comprehensive input validation before processing: it validates that inputs are matrices, checks dimension compatibility for multiplication, validates non-zero dimensions when needed, and performs these checks before any significant processing or allocation occurs.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2021-41219_after_exclude_100:48c1a440:spec": {
    "timestamp": "2026-01-17T00:22:42.751923",
    "cve_id": "CVE-2021-41219",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "48c1a440",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs matrix multiplication, not cryptographic operations on secret values. There is no handling of cryptographic keys, signatures, or any secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a general matrix multiplication kernel in a machine learning framework (TensorFlow). It has no relation to elliptic curve cryptography or any cryptographic curve models.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory operations for tensor data conversion and matrix multiplication. It does not involve cryptographic processing or secret data manipulation that would require constant-time memory operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 6,
        "reasoning": "The code performs arithmetic operations to calculate matrix dimensions (m, k, n, k2) and validates them. While it checks for negative dimensions, it does not explicitly perform overflow-protected calculations using size_t types for memory allocation size determination, though the allocation uses TensorShape which may have internal protections.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations for memory allocation must use overflow-protected calculations w..."
      },
      {
        "score": 5,
        "reasoning": "The code validates matrix dimensions (checking they are matrices, compatible sizes, and non-negative). While it doesn't explicitly check maximum allocation size before processing, it does validate dimensions before allocating output tensor. The principle of validating input dimensions before processing applies.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image dimension validation must include maximum allocation size checks before processi..."
      },
      {
        "score": 5,
        "reasoning": "The code uses ctx->allocate_output() for memory allocation, which is a TensorFlow API that may have internal bounds checking. However, the code doesn't explicitly enforce maximum safe allocation boundaries itself before calling the allocation function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory allocation wrappers must enforce maximum safe allocation boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code works with dynamically allocated tensors rather than fixed buffers. While it validates tensor dimensions and shapes before operations, it doesn't deal with fixed-size buffers that require explicit bounds validation before writes.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code implements comprehensive input validation before processing: it validates that inputs are matrices, checks matrix dimension compatibility (k == k2), validates dimensions are non-negative, and checks for zero dimensions. This aligns well with the specification's requirement for complete input size validation before processing.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2022-1427_before_exclude_100:37d0f0b0:spec": {
    "timestamp": "2026-01-17T00:23:25.232420",
    "cve_id": "CVE-2022-1427",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "37d0f0b0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code contains multiple array indexing and buffer-like operations (e.g., accessing irep->pool, irep->syms, regs array, e->stack). While some bounds checks exist (e.g., \"if (b < MRB_ENV_LEN(e))\"), not all accesses are explicitly validated. The specification about validating boundary conditions before buffer read operations is highly relevant to this VM code which manipulates various internal data structures.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Buffer read operations must validate boundary conditions before access"
      },
      {
        "score": 5,
        "reasoning": "The code processes VM instructions and arguments, but it's not primarily about input parsing with validation state. Some validation occurs (e.g., type checks, argument counts), but the specification about maintaining consistent validation state throughout input processing is only weakly relevant to this VM execution engine.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsing must maintain consistent validation state throughout processing"
      },
      {
        "score": 1,
        "reasoning": "The code contains no regex parsing operations. This is a VM interpreter for mruby bytecode, not a regex engine. The specification about regex syntax parsing is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Regex syntax parsing must enforce strict boundary validation for all operations"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs numerous array indexing operations (e.g., regs[a], regs[b], e->stack[b], ARY_PTR(ary)[index]). Some bounds checking exists but not universally. The OP_AREF, OP_ASET, and other array operations directly involve array bounds that should be validated.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Array indexing operations must validate bounds against declared array size"
      },
      {
        "score": 3,
        "reasoning": "The code processes structured VM instructions but doesn't primarily handle nested structured text input. While it deals with nested method calls and control structures, the specification about validating nesting levels in structured text input has very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Text processing must validate and sanitize all levels of nesting in structured input"
      },
      {
        "score": 1,
        "reasoning": "The code contains no Unicode algorithm implementations. This is a bytecode VM interpreter, not a text processing or Unicode library. The specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Unicode algorithm implementations must strictly enforce all protocol-level constrai..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code includes arithmetic operations (OP_ADD, OP_SUB, OP_MUL, OP_DIV) with overflow checking (mrb_int_*_overflow). However, the specification mentions bounds checking before memory allocation, while the VM's arithmetic operations are more about numeric overflow than direct memory allocation.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must include bounds checking before memory allocation"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. While the code validates some numeric fields (argument counts, indices), it's not a protocol parser in the network sense. The VM interprets bytecode instructions, so some principles of validating numeric operands apply, but not in a protocol parsing context.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Protocol parsers must validate all numeric fields against operational constraints"
      }
    ]
  },
  "CVE-2022-1427_after_exclude_100:95d321b7:spec": {
    "timestamp": "2026-01-17T00:23:33.353424",
    "cve_id": "CVE-2022-1427",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "95d321b7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code contains multiple array indexing and memory access operations (e.g., `regs[a] = regs[b]`, `e->stack[b]`, `ARY_PTR(rest)+m1`, `argv[m1+o]`). While some bounds checks exist (e.g., `if (b < MRB_ENV_LEN(e))` in OP_GETUPVAR/OP_SETUPVAR), not all array accesses are explicitly validated against their declared sizes. The relevance is strong because buffer/memory boundary validation is a core concern in this VM interpreter code.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Buffer read operations must validate boundary conditions before access"
      },
      {
        "score": 5,
        "reasoning": "The code processes bytecode instructions and arguments (input), but it's not a typical input parsing scenario. Validation state is maintained via the VM's execution state (registers, stack, CI). There's weak relevance because while the VM must maintain consistent state during instruction processing, the specification is more about external input parsing than internal VM execution.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsing must maintain consistent validation state throughout processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain any regex parsing or operations. This specification is about regex syntax parsing with boundary validation, which is completely unrelated to this VM bytecode interpreter.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Regex syntax parsing must enforce strict boundary validation for all operations"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs numerous array indexing operations on VM structures (register array `regs`, environment stack `e->stack`, array object data `ARY_PTR`). Some operations have explicit bounds checks (like in OP_GETUPVAR), but others assume validity. The specification directly applies to ensuring these indexing operations are safe.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Array indexing operations must validate bounds against declared array size"
      },
      {
        "score": 3,
        "reasoning": "The code processes structured bytecode but doesn't involve text processing or nested structured input parsing in the sense meant by this specification (like XML/JSON). There's very low relevance as this is about VM instruction execution, not text-based structured input sanitization.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Text processing must validate and sanitize all levels of nesting in structured input"
      },
      {
        "score": 1,
        "reasoning": "The code contains no Unicode algorithm implementations. This specification is completely unrelated to the VM's bytecode execution and arithmetic/control flow operations.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Unicode algorithm implementations must strictly enforce all protocol-level constrai..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs arithmetic operations (OP_ADD, OP_SUB, OP_MUL, OP_DIV) with overflow checking (e.g., `mrb_int_add_overflow`). It also has integer overflow handling (L_INT_OVERFLOW). However, the specification mentions \"before memory allocation,\" while the VM's arithmetic is primarily on values, not directly tied to allocation size calculations. Still, the principle of bounds checking in arithmetic applies.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must include bounds checking before memory allocation"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code interprets bytecode instructions with numeric fields (opcodes, register indices, literals). Some validation occurs (e.g., checking environment length), but it's not a network/communication protocol parser. The numeric fields are internal VM parameters, not external protocol fields.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Protocol parsers must validate all numeric fields against operational constraints"
      }
    ]
  },
  "CVE-2019-25034_before_exclude_100:5166b9ac:spec": {
    "timestamp": "2026-01-17T00:23:37.767333",
    "cve_id": "CVE-2019-25034",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5166b9ac",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It processes numeric fields from a tar archive header using a custom COPY_BUF macro and decode_num function. While it handles input data, the specification about embedded NUL bytes in regex patterns is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It reads numeric strings from a block buffer. The specification about pattern compilers and escape sequences has very low relevance to this data extraction scenario.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The COPY_BUF macro demonstrates length-aware input processing by checking bounds (dst == buf + UINTMAX_STRSIZE_BOUND -1) to prevent buffer overflow when reading from the block buffer. This aligns with the principle of using length-aware operations for untrusted input, though the input source is a file archive rather than a network stream.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Memory is allocated via xcalloc, which typically zero-initializes memory. This satisfies the initialization requirement. However, the specification's focus is broader than just using calloc; it's moderately relevant as proper initialization is addressed.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "Error handling paths (e.g., after ERROR macros) return false, maintaining a consistent error state. However, the code does not show complex object state cleanup (like freeing partially allocated sparse_map). The principle applies but the example is simple.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code validates numeric input via decode_num, checking against TYPE_MAXIMUM limits. However, it's processing a file archive format, not a network protocol. The validation principle is relevant, but the context (file vs. network) weakens the direct application.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "The code validates a length field (sparse_map_size) via decode_num with TYPE_MAXIMUM(size_t) before using it to allocate memory. This directly corresponds to validating protocol message length fields against platform limits, even though the \"protocol\" here is a file format.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code validates the sparse_map_size (u) against TYPE_MAXIMUM(size_t) before passing it to xcalloc. This checks the size parameter against allocation limits. It also implicitly validates subsequent usage since the allocation size determines the loop bound. Highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2010-1311_after_exclude_100:d7f7d56b:spec": {
    "timestamp": "2026-01-17T00:24:31.565455",
    "cve_id": "CVE-2010-1311",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d7f7d56b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It reads numeric strings from an archive block buffer, but the processing is done via a custom loop (COPY_BUF) and decode_num, not a regex engine. The specification about embedded NUL bytes in regex patterns is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It reads raw byte data from an archive buffer to construct numeric strings. The specification about pattern compilers and escape sequences has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The COPY_BUF macro implements a length-aware string copy operation for potentially untrusted input from the archive. It explicitly checks the destination buffer bounds (UINTMAX_STRSIZE_BOUND) to prevent overflow, which aligns with the core principle of using length-aware operations for untrusted input. However, it's a custom implementation, not a standard library function.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Memory is allocated via xcalloc for sparse_map, which typically zero-initializes memory. This satisfies the initialization requirement. However, the specification's broader context about ensuring all allocated memory is initialized before use is only partially relevant, as the primary focus here is on parsing and numeric conversion.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error return paths (e.g., on numeric overflow, malformed data, unexpected EOF). It returns false, but it's unclear if the caller ensures consistent state of the 'file' object (e.g., partially allocated sparse_map). The specification about maintaining consistent object states in error paths is moderately relevant, as error handling is present but its completeness is uncertain.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code reads from a tar archive, which is a file format, not a network protocol. While it validates input (e.g., via decode_num checks), the specification specifically targets network protocol handlers, making the connection weak.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "The code reads a numeric field (sparse_map_size) from the archive and uses it to allocate memory. It validates this value via decode_num with a maximum limit (TYPE_MAXIMUM(size_t)). This directly corresponds to validating protocol (or here, archive format) message length fields against platform limits, making it highly relevant. The archive acts as a serialization protocol.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code validates the sparse_map_size (via decode_num) before using it in xcalloc. This size is validated against TYPE_MAXIMUM(size_t), which is a platform-specific limit. This directly aligns with validating size parameters against allocation limits. The subsequent usage in the loop also depends on this validated size.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-3559_before_exclude_100:47f906a9:spec": {
    "timestamp": "2026-01-17T00:26:15.617969",
    "cve_id": "CVE-2021-3559",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "47f906a9",
    "scores": [
      {
        "score": 2,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code does not process any network or inter-process protocol messages; it deals with local sysfs paths and internal data structures for mediated devices. No protocol message length fields are present.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The specification is about validating memory allocation size parameters. The code calls `virMediatedDeviceGetMdevTypes` which likely performs memory allocations based on data read from the sysfs filesystem. If the sysfs data is untrusted or malformed, it could lead to excessive allocations. The code itself does not directly perform the allocation with a size parameter, but it relies on a function that does, making the principle moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about enforcing consistent type handling in protocol implementations. The target code is not a protocol implementation. It handles internal C data structures (`virMediatedDeviceTypePtr`), but this is standard type-safe programming, not the cross-stage protocol type consistency the specification addresses.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about handling embedded NUL bytes in regular expression parsers. The target code does not use or contain any regular expression parsing logic.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers processing escape sequences. The target code does not compile patterns or process escape sequences.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification is about using length-aware string operations for untrusted input. The target code's primary input is a `sysfspath` (a string). If this path comes from an untrusted source, it should be validated. However, the code passes it directly to `virMediatedDeviceGetMdevTypes`. The core vulnerability (e.g., path traversal) is not about string buffer overflows in the shown function itself, but the principle of handling untrusted input strings has weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating buffers in USB request processing. The target code is related to mediated devices (mdev), which are a virtualization technology, not USB request processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating packet structure in the USB/IP protocol. The target code has no relation to the USB/IP protocol.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2017-18249_after_exclude_100:f8fc56e6:spec": {
    "timestamp": "2026-01-17T00:26:22.358331",
    "cve_id": "CVE-2017-18249",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f8fc56e6",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code deals with local device management and file system paths, not network protocols or message parsing. The connection is very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code calls `virMediatedDeviceGetMdevTypes` which likely performs memory allocation. The specification about validating size parameters against allocation limits is moderately relevant, as proper validation in that called function is crucial for security, but it's not directly visible in this wrapper function.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about enforcing consistent type handling in protocol implementations. The target code is for local device capability discovery, not a network protocol. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically about regular expression parsers handling NUL bytes. The target code does not involve regular expressions at all. The specification basically doesn't apply.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code deals with mediated device types from the filesystem, not pattern compilation. The specification basically doesn't apply.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification is about using length-aware string operations for untrusted input. The target code receives a `sysfspath` string which could be considered input, but the code does not show any string processing on it. The relevance is weak, as safe handling of this path in called functions is implied but not shown.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically about USB request processing. The target code is for mediated virtual devices (mdev), not USB. The specification basically doesn't apply.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically about the USB/IP protocol. The target code is for local mediated device management and has no relation to USB/IP. The specification basically doesn't apply.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2021-37665_before_exclude_100:c1a59000:spec": {
    "timestamp": "2026-01-17T00:27:07.872476",
    "cve_id": "CVE-2021-37665",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c1a59000",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code performs tensor quantization/requantization operations, not cryptographic operations on secret values. There is no handling of cryptographic keys or secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve operations or cryptographic implementations. It's performing numerical tensor transformations for machine learning quantization, not cryptographic operations of any kind.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates output tensors based on input tensor shapes, which could be considered similar to buffer allocation. However, it doesn't use fixed-size buffers but dynamically allocates based on tensor dimensions. The mathematical operations for scaling factors could potentially cause issues if inputs are malformed, but this is weak relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed-size buffers must account for maximum potential expansion during mathematical oper..."
      },
      {
        "score": 5,
        "reasoning": "The code performs arithmetic operations that affect memory allocation through the ctx->allocate_output calls. It validates tensor dimensions and sizes through OP_REQUIRES checks, which provides some bounds validation. However, the validation is not comprehensive for all arithmetic operations (like the scaling calculations).",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-002: Arithmetic operations affecting memory allocation must be bounded and validated"
      },
      {
        "score": 5,
        "reasoning": "The code processes external parameters (input tensors) that affect memory operations. It performs validation of tensor dimensions and sizes through OP_REQUIRES statements, which serves as input sanitization. The checks for input dimensions matching expected sizes directly relate to sanitizing external parameters affecting memory operations.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: External parameters affecting memory operations must be sanitized"
      },
      {
        "score": 5,
        "reasoning": "While the code doesn't use traditional fixed buffers, it operates on tensor data with specific memory layouts. It performs bounds validation through dimension checks (OP_REQUIRES) before memory operations. The relevance is moderate because the principles of bounds validation apply, though not to traditional fixed buffers.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code implements input size validation before processing through multiple OP_REQUIRES statements. It validates that input tensors have correct dimensions (4D), that input_min_vec and input_max_vec have the correct size matching depth, and performs these checks before any significant processing occurs.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2022-28805_before_exclude_100:3a60e78e:spec": {
    "timestamp": "2026-01-17T00:27:10.261614",
    "cve_id": "CVE-2022-28805",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3a60e78e",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It is parsing Lua source code to handle variable lookups (local vs. global). While it processes a string identifier (`varname`), the specification about embedded NUL bytes in regex patterns is not directly applicable. The connection is weak as both involve string input, but the context and risk are different.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The code does not compile or process pattern escape sequences. It is part of the Lua compiler's semantic analysis for variable resolution. The specification's principle of strict boundary handling during compilation has a weak parallel in ensuring correct symbol table lookups, but the core subject (escape sequences) is absent.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The code processes a variable name (`varname`) from the lexer. If the lexer's `str_checkname` does not use length-aware operations on the source input, it could be a vector for issues. The specification's principle of using length-aware operations for untrusted input has moderate relevance, as the lexer's handling of the source string is foundational to this function's safety.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform explicit memory allocation. It works with existing parser/compiler structures (`expdesc`, `FuncState`). Any memory allocations would be in underlying functions (e.g., `luaK_indexed`). The specification is very low relevance to this specific code snippet.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has an error handling path: if a variable is not found locally/upvalue (`VVOID`), it looks it up in the environment. The `lua_assert` ensures the environment exists. The specification's principle of maintaining consistent object states (here, the `var` expdesc) during fallback logic has weak to moderate relevance. A more complex failure could leave `var` in an inconsistent state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "The code does not handle network protocols. It processes programming language syntax in a compiler front-end. The specification's principle of input validation is broadly important but has very low direct relevance to this code scenario.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "Similar to spec 6, this is about network protocol parsers validating packet field boundaries. This code is a language compiler function validating/processing a lexical token. The high-level concept of \"validate before use\" applies, but the context and mechanisms are entirely different, leading to very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate field boundaries before accessing any packet data"
      },
      {
        "score": 3,
        "reasoning": "The code does not parse network messages or maintain message boundaries. It is part of a recursive descent compiler parsing a programming language. The specification is not applicable to this code scenario.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must maintain strict message boundary awareness du..."
      }
    ]
  },
  "CVE-2021-37665_after_exclude_100:b45c4ecd:spec": {
    "timestamp": "2026-01-17T00:27:19.825809",
    "cve_id": "CVE-2021-37665",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b45c4ecd",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor quantization/requantization operations, not cryptographic operations on secret values. There is no handling of cryptographic keys or secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or any cryptographic curve operations. It's a numerical tensor processing function in a machine learning framework.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "While the code performs memory operations, it doesn't involve cryptographic processing of secret data. The memory operations are for tensor data manipulation, not cryptographic operations requiring constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 3,
        "reasoning": "The code uses vectors and tensors with dynamic sizing based on input dimensions. While there's no fixed-size buffer that could overflow, the code does allocate output tensors based on input shape, which could potentially lead to memory issues if inputs are maliciously large.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed-size buffers must account for maximum potential expansion during mathematical oper..."
      },
      {
        "score": 6,
        "reasoning": "The code performs arithmetic operations (scaling calculations) and validates input dimensions through OP_REQUIRES checks. It validates that input tensors have expected dimensions and sizes, which relates to bounding and validating operations that affect memory allocation indirectly.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-002: Arithmetic operations affecting memory allocation must be bounded and validated"
      },
      {
        "score": 7,
        "reasoning": "The code validates external parameters (tensor dimensions, sizes, and values) through multiple OP_REQUIRES checks. It sanitizes inputs by checking tensor dimensions, element counts, and value constraints before processing, which aligns with the principle of sanitizing external parameters affecting operations.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: External parameters affecting memory operations must be sanitized"
      },
      {
        "score": 4,
        "reasoning": "The code doesn't use fixed buffers but dynamically allocated tensors. However, it does validate tensor shapes and sizes before operations, which is conceptually similar to bounds validation. The relevance is weak since the specification specifically mentions fixed buffers.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "The code implements comprehensive input size validation before processing through multiple OP_REQUIRES statements. It validates tensor dimensions (4D requirement), vector sizes (depth consistency), scalar requirements, and value constraints, which directly aligns with implementing complete input size validation before processing.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2022-28805_after_exclude_100:6e2350b8:spec": {
    "timestamp": "2026-01-17T00:27:47.717801",
    "cve_id": "CVE-2022-28805",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6e2350b8",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It is handling variable name lookup in a Lua interpreter context, not processing input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not involve pattern compilation or processing escape sequences. It is performing variable resolution in a scripting language's compilation phase.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code processes string names (varname) which could be user-provided. While the code uses TString objects (which typically store length), the specific functions like str_checkname and codestring should ensure length-aware operations to prevent buffer overflows if the input is untrusted.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code shows expdesc struct usage but doesn't explicitly show memory allocation. However, functions like singlevaraux might allocate or initialize memory for the var/expdesc structures, so proper initialization is a general concern.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The code has error handling paths (checking if var->k == VVOID) and modifies object states (var, key). It must ensure that after the fallback path (looking up in environment), the state is consistent and valid for subsequent operations like luaK_indexed.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This code is part of a language compiler/interpreter's front-end, not a network protocol handler. There is no network input processing.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The specification is about network protocol parsers validating packet field boundaries. This code is parsing programming language syntax, not network packets.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate field boundaries before accessing any packet data"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code does not implement network protocols or handle message boundaries. It is performing lexical analysis and variable resolution in a scripting language.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must maintain strict message boundary awareness du..."
      }
    ]
  },
  "CVE-2018-14461_before_exclude_100:eee3f3f9:spec": {
    "timestamp": "2026-01-17T00:28:54.178992",
    "cve_id": "CVE-2018-14461",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "eee3f3f9",
    "scores": [
      {
        "score": 9,
        "reasoning": "HS-INPUT-001 is highly relevant. The code validates the `length` field from the protocol message (`REQUEST_AT_LEAST_SIZE`) and performs calculations like `(stuff->length * 4)`. It must ensure this multiplication does not overflow and that the resulting value is within valid bounds for the subsequent pointer arithmetic and data consumption logic. This directly relates to validating integer limits from untrusted input.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "HS-MEM-002 has moderate relevance. While there is no explicit memory allocation in this function, the code performs pointer arithmetic (`from.c8 = (CARD8 *) &stuff[1]`) and iterates through a data buffer based on calculated sizes (`dataLeft`). It must validate that the `length` field and subsequent size calculations do not cause the pointer to access memory outside the bounds of the received request buffer, which is analogous to validating size parameters for safe memory access.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "HS-PROTOCOL-003 is strongly relevant. The function handles a network protocol request, performing byte-swapping (`swaps`, `swapl`) for multi-byte fields based on the request's native byte order. It must ensure consistent interpretation of data types (CARD8, CARD16, CARD32) and structure layout across different architectures. The switch statement handling different notification types with specific `size` values is a core part of this type-safe processing.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "HS-INPUT-001 (regarding regex and NUL bytes) has very low relevance. The target code is a protocol deserialization function for XKB event selection. It does not involve regular expression parsing or string pattern matching at all.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "HS-PROTOCOL-002 (pattern compilers and escape sequences) has very low relevance. The code processes a structured binary protocol request for selecting keyboard events. It does not compile patterns, process escape sequences, or handle textual pattern languages.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "HS-MEM-003 (length-aware string operations) has weak relevance. The function processes binary data, not strings. However, the principle of using length-aware operations (`dataLeft` tracking) to prevent reading beyond the buffer is conceptually similar, but the specification is specifically about string functions.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "HS-MEM-001 (memory initialization) has very low relevance. The function does not perform any memory allocation. It operates on an already received request buffer from the client.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "HS-STATE-002 (error handling and consistent state) has moderate relevance. The function has multiple error return paths (`BadValue`, `BadLength`). While the function itself doesn't seem to manage complex object states, it is part of a larger request processing pipeline. Ensuring that error returns do not leave the server in an inconsistent state regarding event selection for the client is important. The direct impact in this snippet is limited.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2018-14461_after_exclude_100:0e2d8117:spec": {
    "timestamp": "2026-01-17T00:29:06.020267",
    "cve_id": "CVE-2018-14461",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0e2d8117",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates the request length (`client->req_len * 4`) against the expected size of the request structure (`SIZEOF(xkbSelectEventsReq)`) and the size of subsequent data fields. It performs a `REQUEST_AT_LEAST_SIZE` check and later validates `dataLeft` against calculated size requirements for specific event types, directly addressing protocol message length validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not contain any explicit memory allocation operations (like malloc, calloc, realloc). It operates on a buffer (`from.c8`) derived from the client request packet, performing bounds checking but not allocation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code handles multiple data types (BOOL, CARD8, CARD16, CARD32) via a union and performs appropriate byte-swapping operations (`swaps`, `swapl`) based on the event type (`ndx`). This ensures consistent interpretation of network data across different architectures, a core aspect of protocol type handling.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes a structured binary protocol request (XKB). It does not involve parsing or evaluating regular expressions, which is the sole focus of this specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes a structured binary protocol request. It does not involve compiling or interpreting patterns or escape sequences, which are the focus of this specification related to pattern compilers.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses length-aware operations (`dataLeft` tracking) to iterate through the variable-length portion of a client-provided request buffer, which is potentially untrusted. However, it does not process null-terminated strings, which is the typical context for this specification. The principle of bounds-checking untrusted input is present but applied to structured data, not strings.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform any memory allocations that would require initialization. It works with existing request data buffers.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function has multiple error return paths (`BadValue`, `BadLength`) that occur before the main processing function `ProcXkbSelectEvents` is called. The specification's principle applies: the function must ensure a consistent state (likely the client's request buffer and error state) before returning an error. The code sets `client->errorValue` on one error path, which is a form of state maintenance. However, the overall consistency of broader object states is not fully evaluable from this snippet alone.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2019-1010065_before_exclude_100:beca84f8:spec": {
    "timestamp": "2026-01-17T00:29:12.902114",
    "cve_id": "CVE-2019-1010065",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "beca84f8",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code performs arithmetic operations (e.g., pointer arithmetic in `hfs_brec_read`, `be16_to_cpu`, `be32_to_cpu`), but there is no explicit validation of type boundaries before these calculations. The relevance is weak because the specification is about validating arithmetic inputs against type boundaries, which is not prominently demonstrated or violated in this snippet.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 8,
        "reasoning": "This code is a filesystem parser function that reads catalog entries. It validates the `type` field against expected values (HFSPLUS_FOLDER_THREAD, HFSPLUS_FILE_THREAD). This is a direct validation of a structural field, making the specification strongly relevant. However, it does not validate all structural fields (e.g., `parentID`, `nodeName` length) against physical constraints, preventing a perfect score.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 8,
        "reasoning": "The function reads an on-disk structure (`hfsplus_cat_entry`) via `hfs_brec_read`. Strict bounds checking is implied to be handled within `hfs_brec_read` and `hfs_brec_find`. Since this is a core filesystem operation dealing with on-disk data, the specification's principle of enforcing bounds checking is highly relevant. The exact implementation is not visible here, so a score of 8 reflects strong relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expressions or pattern parsing. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code is a filesystem catalog lookup function with no pattern compilation logic. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code deals with a node name (`tmp.thread.nodeName`), which is likely a Unicode string. It passes this string to `hfsplus_cat_build_key_uni`. The specification about using length-aware operations for untrusted input could apply if the nodeName originates from disk (untrusted). However, the code does not show the string processing details, making the connection weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code declares a stack variable `tmp` of type `hfsplus_cat_entry`. It is not explicitly initialized before being passed to `hfs_brec_read`, which writes data into it. The specification about initializing memory before use is weakly relevant because the variable is used as an output buffer, not used uninitialized. However, the principle of ensuring memory is in a safe state before an operation has some connection.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error paths (returns on `err`, returns on bad type). The specification about maintaining consistent object states in error handling is moderately relevant. The function appears to leave the `fd` (find data) structure in a modified state (its `search_key` is updated) even on the error path where a bad thread record is found. This could be a state consistency issue, giving the specification guidance value.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2019-1010065_after_exclude_100:0835b058:spec": {
    "timestamp": "2026-01-17T00:29:34.909226",
    "cve_id": "CVE-2019-1010065",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0835b058",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code performs a simple read operation and a few integer conversions (be16_to_cpu, be32_to_cpu). There are no complex arithmetic operations (like addition, multiplication, or shifts) that could overflow or underflow the variable's type boundaries. The validation present is on data content, not arithmetic results.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. This is a filesystem catalog parser function. It validates a critical structural field (`type`) against expected values (HFSPLUS_FOLDER_THREAD, HFSPLUS_FILE_THREAD) and logs/returns an error if invalid. This is a direct application of validating structural fields against logical/format constraints.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs strict bounds checking on the `nodeName.length` field read from disk, ensuring it does not exceed 255. This prevents potential buffer overflows or corruption when this length is later used (e.g., in `hfsplus_cat_build_key_uni`). This is a core example of bounds checking for on-disk structures.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve regular expressions or pattern matching. It is parsing binary filesystem structures, not text patterns with embedded NUL bytes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve pattern compilers, escape sequences, or any form of text/pattern compilation. It handles binary catalog records.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates the length of a string field (`nodeName.length`) from an untrusted disk source before it is likely used elsewhere. While the code itself doesn't perform string copying, the length check is a prerequisite for safe, length-aware operations in subsequent functions (like `hfsplus_cat_build_key_uni`).",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function uses a stack variable `tmp` and reads data into it. There is no dynamic memory allocation (`malloc`, `kmalloc`) within this code snippet that needs initialization.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function has multiple error return paths (failed read, bad type, bad length). It appears to maintain consistency by returning an error code and not modifying external state further. However, the code snippet is short, and we cannot fully assess if all object states (like `fd` internals) are kept consistent in every path without seeing the called functions (`hfs_brec_read`, `hfs_brec_find`).",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-0481_before_exclude_100:695296a1:spec": {
    "timestamp": "2026-01-17T00:29:36.258878",
    "cve_id": "CVE-2022-0481",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "695296a1",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a hash generation function for a compiler/interpreter (likely mruby), not a regular expression parser. It processes an abstract syntax tree (AST) node structure, not string patterns containing NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The specification concerns pattern compilers and escape sequences. This code is a code generator for hash literals, not a pattern or string literal compiler that processes escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes data (AST nodes), it does not appear to handle raw, untrusted string input directly. Its operations are on controlled internal data structures (tree nodes). The relevance to length-aware string operations for untrusted input is very low.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code manipulates an operand stack (`cursp()`, `pop_n`, `push`). There is weak relevance because improper stack management could lead to use of uninitialized stack slots or memory. However, the specification is broadly about memory initialization, and the code's primary purpose is not allocation.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "This function has multiple control flow paths (while loop, if conditions) and manipulates a stack. It must ensure the stack state (number of items, their meaning) is consistent before and after each `genop_*` call and when returning. An error in this logic could leave the compiler in an inconsistent state. This aligns with the principle of maintaining consistent state in complex operations.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is part of a compiler's code generation phase, not a network protocol handler. It does not process network input.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code is part of a compiler's code generation phase, not a network protocol parser. It does not process packet data or validate field boundaries from an external source.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate field boundaries before accessing any packet data"
      },
      {
        "score": 5,
        "reasoning": "The code is part of a compiler's code generation phase, not a network protocol implementation. Concepts of message boundaries are not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must maintain strict message boundary awareness du..."
      }
    ]
  },
  "CVE-2022-0481_after_exclude_100:5e57a054:spec": {
    "timestamp": "2026-01-17T00:30:51.815601",
    "cve_id": "CVE-2022-0481",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5e57a054",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a hash generation function for a compiler/interpreter (likely mruby). It processes an abstract syntax tree (AST) and generates bytecode operations (OP_HASH, OP_HASHADD, OP_HASHCAT). It does not involve parsing or processing regular expressions, and there is no handling of input patterns containing embedded NUL bytes. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The specification concerns pattern compilers and escape sequence processing. The target code is a code generator for hash literals, not a pattern or string literal compiler. It does not process escape sequences. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "The specification is about using length-aware string operations for untrusted input. The target code manipulates an AST and a code generation scope, performing stack operations (pop_n, push) and generating opcodes. It does not directly process string data from external inputs. There is a weak connection in that the function must correctly manage its internal stack bounds (slimit, GEN_VAL_STACK_MAX), which is a form of boundary checking, but it's not about string processing.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 4,
        "reasoning": "The specification requires memory allocations to be initialized before use. The code does not contain explicit memory allocation calls (like malloc). It operates on pre-existing data structures (s, tree). However, it does read from these structures (e.g., nint(tree->car->car->car)) without showing prior validation or initialization of the tree nodes' contents. This creates a weak connection: if the `tree` structure is malformed or uninitialized, it could lead to undefined behavior. The code's safety depends on the caller providing a valid tree.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The specification states that error handling paths must maintain consistent object states. The function has complex control flow with multiple branches and stack manipulations (pop_n, push). If an error occurred in the called `codegen` functions or due to invalid state, the function's early exit might leave the compiler's value stack in an inconsistent state (e.g., mismatched push/pop counts). The code does not show explicit error handling or rollback logic. This represents a moderate relevance, as maintaining stack consistency is a key principle similar to maintaining object state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The specification is for network protocol handlers validating input. The target code is part of a compiler's code generator, processing an internal AST representation. It does not handle network protocols or external network input. The relevance is extremely low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is for protocol parsers validating packet field boundaries. The target code is a compiler function, not a network protocol parser. It does not parse packets or have fields with boundaries in that context. The relevance is extremely low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate field boundaries before accessing any packet data"
      },
      {
        "score": 1,
        "reasoning": "The specification is for network protocol implementations maintaining message boundary awareness. The target code is a compiler code generation function. It is unrelated to network messaging or protocol parsing. The relevance is extremely low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must maintain strict message boundary awareness du..."
      }
    ]
  },
  "CVE-2022-21740_after_exclude_100:6fa5933f:spec": {
    "timestamp": "2026-01-17T00:30:57.674648",
    "cve_id": "CVE-2022-21740",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6fa5933f",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs no cryptographic operations. It is a statistical counting operation (like a histogram) on visible input data. Timing side-channels are not a concern for this functionality.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code contains no elliptic curve operations or any cryptographic primitives. The specification is completely irrelevant to the target code's purpose.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs no cryptographic processing. The memory operations (array indexing, map updates) are for data aggregation and do not require constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code calculates `num_output_values` based on `max_value`, `maxlength_`, and `minlength_`. While it doesn't explicitly show size_t overflow checks, the principle of safe arithmetic when determining output sizes is relevant. The subsequent `OutputSparse` call likely involves allocation based on this size.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations for memory allocation must use overflow-protected calculations w..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates tensor shapes and relationships (e.g., weights vs. values shape, splits boundaries) which is analogous to dimension validation. However, it does not explicitly check against a maximum allocation size before processing the input data through the main loop, which is the core of this specification.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image dimension validation must include maximum allocation size checks before processi..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code itself does not contain direct memory allocation calls (like `malloc`, `new`). Allocation is deferred to the `OutputSparse` function and the underlying TensorFlow framework. The principle of validating parameters that influence allocation (`num_output_values`) is present, but the enforcement is not visible here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory allocation wrappers must enforce maximum safe allocation boundaries"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code uses array indexing (`splits_values(batch_idx)`, `values_values(idx)`) and map access (`per_batch_counts[batch_idx - 1][value]`). It performs bounds validation on the `splits` tensor indices (checking start is 0, end is `num_values`) which helps prevent out-of-bounds reads. The loop condition `idx >= splits_values(batch_idx)` relies on the validated splits data being non-decreasing, but a strict index-by-index bounds check for `splits_values(batch_idx)` within the loop is not shown.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs multiple input validations before the main processing loop: checking tensor shapes, that `num_batches > 0`, that splits start with 0 and end with `num_values`. This aligns with the specification's principle of complete input size/structure validation before processing. The validation ensures the subsequent loops and indexing operations are safe.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2009-3909_before_exclude_100:505dfc01:spec": {
    "timestamp": "2026-01-17T00:31:02.369459",
    "cve_id": "CVE-2009-3909",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "505dfc01",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor computations (counting values) and does not involve any cryptographic operations on secret values. The specification about constant-time cryptographic execution is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor processing kernel for machine learning, not an elliptic curve implementation. There is no cryptographic functionality.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform cryptographic processing or secure memory operations that require constant-time properties. It is a numerical computation kernel.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs arithmetic operations (e.g., calculating num_batches, num_values, batch indices) and uses them for memory access and loop bounds. While it doesn't explicitly show memory allocation arithmetic, it uses indices and dimensions that could lead to out-of-bounds access if not validated. The validation present (OP_REQUIRES) partially addresses overflow concerns but not comprehensively with size_t overflow protection.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations for memory allocation must use overflow-protected calculations w..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates tensor shapes and dimensions (e.g., checking indices is a 2D matrix, shape elements >=0, batch < num_batches). This is analogous to image dimension validation. However, it lacks explicit maximum allocation size checks before processing the data, which is the core of this specification. The validation focuses on logical consistency rather than preventing excessive resource allocation.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image dimension validation must include maximum allocation size checks before processi..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not directly show memory allocation wrappers. Memory allocation is likely hidden inside TensorFlow's internal structures (like BatchedMap, OutputSparse). The validation of indices and shape values indirectly influences the size of internal allocations but does not explicitly enforce maximum safe allocation boundaries.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory allocation wrappers must enforce maximum safe allocation boundaries"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code performs write operations into a data structure (per_batch_counts[batch][value]) based on user-controlled indices (batch, value). It includes several bounds validation checks (e.g., batch >= num_batches, value < maxlength_) before these writes. This aligns with the principle of strict bounds validation before write operations, although the buffer is not a simple fixed-size array but a map-like structure.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code is an input parser for tensor data. It performs multiple input validations (using OP_REQUIRES) on indices, values, weights, and shape tensors before the main processing loop. These checks validate shape, dimensionality, value ranges, and consistency between different inputs, which is the essence of \"complete input size validation before processing\". However, it could be argued that checks like `num_values <= indices.shape().dim_size(0)` are redundant or placed after some variable derivation, slightly reducing perfect adherence.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2021-3416_before_exclude_100:730a018e:spec": {
    "timestamp": "2026-01-17T00:32:15.469804",
    "cve_id": "CVE-2021-3416",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "730a018e",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code is a network packet forwarding function with no regular expression parsing involved.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code handles raw packet data, not pattern compilation or escape sequence processing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function receives a buffer and size parameter. While it passes these to network functions, it does not perform its own length-aware string processing. The principle of handling size parameters carefully is relevant to the function's context.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about validating protocol message length fields. The target code receives a 'size' parameter but does not validate it against integer limits; it's assumed to be valid from the caller. The code does not parse protocol headers.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about memory allocation size validation. The target code does not perform any memory allocation operations.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function takes a 'size' parameter (potentially derived from network data) and passes it to packet sending/receiving functions. While the function itself does not validate the size, the secure coding principle that network-derived lengths must be validated is highly relevant to the context in which this function is called. The function's safety depends on prior validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 3,
        "reasoning": "The specification is about protocol option parsers validating variable-length fields. The target code does not parse protocol options or variable-length fields; it forwards an entire buffer.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2021-3416_after_exclude_100:bee3fb8a:spec": {
    "timestamp": "2026-01-17T00:32:21.088484",
    "cve_id": "CVE-2021-3416",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bee3fb8a",
    "scores": [
      {
        "score": 1,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code is a simple network packet forwarding function with no regular expression parsing involved.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences; it handles raw packet buffers.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The function receives a buffer and size, and passes them to packet sending/receiving functions. While it uses the provided size parameter (length-aware), the critical validation of whether 'size' is appropriate for the buffer 'buf' or network constraints occurs elsewhere. The code itself is a simple passthrough.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The specification is about validating protocol message length fields. The target code's 'size' parameter is not a protocol-derived length field from within 'buf'; it's an argument passed to the function. The code does not parse or validate any internal protocol headers.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 1,
        "reasoning": "The specification is about memory allocation operations. The target code does not perform any memory allocation (e.g., no malloc, calloc, realloc).",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification about consistent type handling has a weak connection. The code handles a buffer pointer and an integer size, which is consistent. However, the core of the function is a network loopback decision, not a complex protocol implementation with multiple types.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The 'size' parameter represents a length value that likely originates from network data (packet size). The principle of validating network-derived length values for range and sign before use is crucial. While this function receives 'size' as an argument, it should ideally validate it (e.g., is it positive? does it exceed a maximum frame size?) before passing it to qemu_send_packet or qemu_receive_packet. The current code lacks this validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The specification is about protocol option parsers validating variable-length fields. This function is not a parser, but it is part of a network device model. The buffer 'buf' may contain protocol headers with variable-length fields. The function's responsibility is to forward the packet, but the principle of validating lengths against the actual received data ('size') is a related security concern for the broader system, though not directly implemented here.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2020-16287_before_exclude_100:875b9f0b:spec": {
    "timestamp": "2026-01-17T00:33:00.856250",
    "cve_id": "CVE-2020-16287",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "875b9f0b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses stack-allocated arrays `data[DATA_SIZE]` and `plane_data[LINE_SIZE * 3]`. While not dynamic heap allocation, the principle of initialization before use is relevant. The `data` array is populated via `gdev_prn_copy_scan_lines`, and `plane_data` is written to in the transposition loop. However, `memset(end_data, 0, 7)` only partially initializes trailing bytes, not the entire array. This partial initialization aligns with the specification's concern about proper initialization to avoid undefined behavior.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has error handling for the `line_size > DATA_SIZE` case, returning an error. However, the specification focuses on maintaining consistent object states in error paths. The function primarily operates on local stack variables and a printer stream. If an error is returned early, the printer stream state might be inconsistent (partial escape sequences may have been sent). The relevance is weak because the code is not managing complex persistent objects, but stream state consistency could be a concern.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "The code generates printer control commands and raster data for a printer stream (likely a network or serial printer). It does not parse or handle incoming network protocol input. It is a protocol sender, not a handler. Therefore, the specification about validating input before processing has very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The code performs a critical bounds check: `if (line_size > DATA_SIZE)`. This validates the required buffer size (`line_size`) against the fixed allocation size (`DATA_SIZE`) before using the buffer `data`. This directly corresponds to validating size parameters against allocation limits and subsequent usage requirements, even though the allocation is static on the stack.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-29194_before_exclude_100:abf0bbec:spec": {
    "timestamp": "2026-01-17T00:33:24.251754",
    "cve_id": "CVE-2022-29194",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "abf0bbec",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification about view-based data access and privilege checks is weakly relevant. The code deletes a tensor from a session state, which involves resource management and access control, but it does not explicitly involve database views or privilege checks as a view owner. The relevance is indirect at best.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The specification about security-critical state transitions and privilege context has weak relevance. Deleting a session tensor is a state transition, but the code does not show explicit privilege context management. The OP_REQUIRES checks ensure preconditions but do not directly address privilege consistency.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The specification about SQL protocol implementations and view security semantics has very low relevance. The code involves TensorFlow session tensor deletion, not SQL protocols or database view security.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "The specification about NUL-termination for string functions has moderate relevance. The code extracts a string from a tensor scalar (tstring), and tstring in TensorFlow typically handles NUL-termination safely. However, improper string handling could lead to security issues, so the principle has some guidance value.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory buffers passed to string functions must guarantee NUL-termination"
      },
      {
        "score": 5,
        "reasoning": "The specification about buffer allocation and known-safe state has weak relevance. The code does not involve explicit buffer allocation; it uses TensorFlow abstractions. However, ensuring safe state before operations (like checking session_state) aligns with the general principle.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Buffer allocation must maintain invariant of known-safe state"
      },
      {
        "score": 5,
        "reasoning": "The specification about protocol parsers validating buffer boundaries has weak relevance. The code is not a protocol parser, but it does validate inputs (e.g., checking session_state not null) before proceeding, which is a similar validation principle.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Protocol parsers must validate buffer boundaries before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification about conditional resource cleanup on successful initialization has strong relevance. The code deletes a tensor from session state, which is a cleanup operation. It first validates that the session state is initialized (not null) before proceeding, aligning with the principle.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "The specification about algorithm support verification before key object creation has very low relevance. The code does not involve cryptography, key objects, or algorithm verification; it is about tensor deletion in a machine learning framework.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2020-16287_after_exclude_100:f780a580:spec": {
    "timestamp": "2026-01-17T00:33:29.258251",
    "cve_id": "CVE-2020-16287",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f780a580",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The code explicitly initializes the `data` array with `memset(data, 0x00, DATA_SIZE);` to prevent uninitialized memory reads, which is a direct application of HS-MEM-001. The comment even explains the security rationale: \"uninitialised bytes in dp[] can be greater than 7, which breaks spr8[dp[]].\"",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code contains minimal error handling (e.g., a range check for `line_size`). However, there is no complex object state management or cleanup of partial states in error paths shown. The function primarily deals with data transformation and output streaming.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code writes to a printer stream (`prn_stream`), which is a file/device output, not a network protocol handler. There is no input validation from an external network source.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code calculates a length field `cnt_2prn` and sends it in a protocol command. However, this length is derived from a previously validated `line_size` and is not directly parsed from an external message. The specification focuses on validating externally provided length fields against integer limits, which is not the primary scenario here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code performs a critical validation: `if (line_size > DATA_SIZE) { ... return_error(gs_error_rangecheck); }`. This checks that the required buffer size (`line_size`) does not exceed the allocated buffer size (`DATA_SIZE`), which is a direct application of validating size parameters against allocation limits (HS-MEM-002).",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code handles byte data and performs bitwise operations and type casting (e.g., `ulong pword`, `(byte)(pword >> 16)`). While it ensures data is processed correctly for the printer protocol, the specification's focus on \"consistent type handling across all processing stages\" for complex protocol implementations is only tangentially related to this low-level data packing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is about regular expression parsers handling NUL bytes. The target code does not contain any regular expression parsing logic.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code generates printer escape sequences (e.g., `\\033@`, `\\033e`, `\\033[O`). The specification about maintaining strict boundaries when processing escape sequences is more applicable to parsers/compilers that *interpret* such sequences from input. This code *generates* them, so the connection is indirectensuring the generated sequences are correctly formed could be a related concern.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-18120_after_exclude_100:b4e9ea0b:spec": {
    "timestamp": "2026-01-17T00:34:03.954697",
    "cve_id": "CVE-2017-18120",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b4e9ea0b",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about view-based data access and privilege checks for a database view owner. The target code is deleting a tensor from a session state in a machine learning framework (likely TensorFlow). There is no concept of database views, view owners, or associated privilege checks in this context.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The specification mentions security-critical state transitions and privilege context. The code performs a state transition (deleting a tensor from session state), which could be security-critical if the tensor name or data is sensitive. However, there is no explicit discussion or implementation of privilege context (e.g., user permissions, roles) in the code snippet, making the connection weak.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically about SQL protocol implementations and enforcing view security. The target code does not involve SQL, any database protocol, or view semantics. It is an operation on an internal session state for tensors.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires NUL-termination for strings passed to string functions. The code extracts a `tstring` (tensor string) which is likely a `std::string` or similar abstraction in TensorFlow, and passes it to `DeleteTensor`. While the internal implementation of `tstring` and `DeleteTensor` should handle termination correctly, the principle of ensuring string data is properly formed before use is moderately relevant. The code does not show explicit validation of the string content itself.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory buffers passed to string functions must guarantee NUL-termination"
      },
      {
        "score": 5,
        "reasoning": "The specification is about buffer allocation maintaining a known-safe state. The code does not directly allocate buffers. However, it operates on a `Tensor` and a `session_state`, which internally manage memory. The safety of the `DeleteTensor` operation depends on the internal state of `session_state` being valid and consistent. The code performs checks (non-null `session_state`) which aligns with the principle of maintaining safe state before operations, giving it moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Buffer allocation must maintain invariant of known-safe state"
      },
      {
        "score": 5,
        "reasoning": "The specification requires validating buffer boundaries before processing. The code validates that the input tensor `handle` is a scalar (`IsScalar` check) before accessing its data as a string. This is a direct and crucial boundary/type validation to prevent out-of-bounds access or type confusion when calling `handle.scalar<tstring>()()`. This is a strong example of the principle.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Protocol parsers must validate buffer boundaries before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification states resource cleanup should be conditional on successful initialization. The code performs `DeleteTensor`, which is a cleanup operation. It conditionally proceeds only after validating that the `session_state` is not null (a basic initialization/sanity check). It does not check if the tensor named `name` was successfully initialized or exists, but the principle of checking state before cleanup is present.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "The specification is about verifying cryptographic algorithm support before creating a key object. The target code involves session tensor management in a computational graph and has no cryptographic operations, key objects, or algorithm verification.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2013-1792_before_exclude_100:acde4279:spec": {
    "timestamp": "2026-01-17T00:34:16.867101",
    "cve_id": "CVE-2013-1792",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "acde4279",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not perform any cryptographic operations or use scatterlists. It is a kernel networking function for expanding XFRM (IPsec) policies, dealing with policy lookup and validation, not with cryptographic data handling.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 2,
        "reasoning": "The code does not contain cryptographic implementations. It handles policy structures and counters, not cryptographic data or keys. Memory safety concerns here are general (e.g., pointer validation), not specific to approved cryptographic interfaces.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not parse or process regular expressions. It processes XFRM policy structures and network flow keys (`fl`).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not compile patterns or process escape sequences. It is policy logic for IPsec.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not directly process strings. However, it processes an array of pointers (`pols`) with a user/upper-layer-provided count (`*num_pols`). It validates that `*num_pols` is not zero and that the first pointer is not NULL or an error before using it, which is a form of input validation. The loop uses the validated `*num_pols` as a boundary. This relates to the principle of validating input before use, though not for strings specifically.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function receives `num_pols` (a pointer to an integer) which likely originates from userspace or a less privileged context. It performs critical validation: it checks if `*num_pols == 0` and handles it, and uses it as the loop boundary only after this check. It also validates the `pols[0]` pointer before dereferencing it (`pols[0]->xfrm_nr`). This aligns with the core principle of validating userspace-provided parameters before use, though the validation could be more thorough (e.g., ensuring `*num_pols` isn't negative or excessively large).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function handles policy structures which can be seen as protocol messages. It verifies the basic \"structural integrity\" of the first policy object by checking it's not NULL and not an error pointer before accessing its internal field (`xfrm_nr`). It also checks the `action` field within the loop. However, it does not deeply validate variable-length components within the policy structures themselves.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2017-16914_after_exclude_100:99a7709f:spec": {
    "timestamp": "2026-01-17T00:34:45.458059",
    "cve_id": "CVE-2017-16914",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "99a7709f",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not perform any cryptographic operations or use scatterlists. It is a kernel networking function for expanding XFRM (IPsec) policies, dealing with policy lookup and validation, not cryptographic data handling.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 2,
        "reasoning": "The code does not contain cryptographic implementations. It handles policy structures and counters, with no use of cryptographic interfaces or memory-safe data handling for crypto purposes.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 5,
        "reasoning": "The code is a kernel function that processes pointers to policy structures. While it doesn't explicitly handle VMAP_STACK, kernel code in general must be aware of stack memory implications. The function uses pointers passed as parameters, which could potentially point to stack memory, but there's no direct stack array manipulation or clear VMAP_STACK-specific handling shown.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing at all. It's a networking policy management function in the Linux kernel XFRM subsystem.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain pattern compilers or process escape sequences. It deals with IPsec policy structures and flow information.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code does not process strings. It works with policy structures, counters, and flow information. The only potential input validation is checking for NULL or error pointers, but not string operations.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates the `num_pols` input parameter (checking if it's 0) and validates pointers in the `pols` array. It also checks for error pointers using IS_ERR(). While not explicitly validating against system constraints, it performs basic sanity checks on user/upper-layer provided data structures.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code handles policy structures that could be considered protocol messages in a broad sense (XFRM/IPsec policy). It validates the integrity of policy pointers and checks action fields. However, it doesn't deeply verify variable-length components of complex protocol messages.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2022-36043_before_exclude_100:f96fb87c:spec": {
    "timestamp": "2026-01-17T00:34:53.184113",
    "cve_id": "CVE-2022-36043",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f96fb87c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It simply returns a cloned list of fixups from a binary object.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or any protocol/pattern compilation logic. It performs a simple data structure operation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The code does not perform string processing on untrusted input. It operates on internal data structures (RzList, QnxObj) that are part of the binary analysis framework.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code does not process protocol messages, validate length fields, or handle any network/data protocol. It is a helper function for binary analysis relocations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The code calls `rz_list_clone()` which internally performs memory allocation. While the specification about validating size parameters is generally good practice, the code doesn't show the allocation logic itself, making direct relevance minimal.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement a protocol or handle type consistency across processing stages. It simply returns a data structure clone.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform buffer allocation or account for padding requirements. The memory allocation is abstracted within the `rz_list_clone()` function.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve image compression, encoder buffers, or bounds checking for compression operations. It deals with binary relocation data.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2022-36043_after_exclude_100:647ae4ea:spec": {
    "timestamp": "2026-01-17T00:35:03.832434",
    "cve_id": "CVE-2022-36043",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "647ae4ea",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It simply clones a list of memory maps from a binary object.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation, escape sequence processing, or any protocol/format parsing that would require boundary checks on escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the code doesn't directly process strings, it operates on data structures (RzList) that could potentially contain untrusted data. However, the function itself doesn't perform string operations, making the relevance very low.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code does not process protocol messages, validate length fields, or handle any network/communication protocols. It's a simple memory map retrieval function.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code calls `rz_list_clone()` which likely involves memory allocation. While not directly visible, this operation should validate size parameters. The relevance is moderate as memory allocation is implied but not explicitly shown in the code.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement any protocol or have multiple processing stages requiring consistent type handling. It's a simple data accessor function.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform buffer allocation or have padding requirements. It works with existing data structures.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve image compression, encoder buffers, or any I/O operations with bounds checking requirements for compression.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2019-13219_before_exclude_100:5a14ec73:spec": {
    "timestamp": "2026-01-17T00:35:47.336355",
    "cve_id": "CVE-2019-13219",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5a14ec73",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory for `frame_data` and `delta_data` using `g_malloc` without explicit initialization (e.g., zeroing). These buffers are later used in `memcpy` and decoding operations. While the decoder may fill them completely, uninitialized memory could lead to information leaks or instability if the decoder logic has flaws. The specification about initializing memory before use is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error paths (e.g., `wrong_type`, decode failures). In the `wrong_type` error path, it calls `gst_object_unref(flxdec)` which may affect object state consistency if the object is referenced elsewhere. Other error returns (like after `GST_ELEMENT_ERROR` for decode failure) do not clean up adapter state or allocated buffers, potentially leaving the object in an inconsistent state. This is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "While this is a media decoder, not a network protocol handler, it processes input data chunks from a buffer adapter. It performs some validation (checking magic type, checking chunk sizes), but the validation is limited. The principle of validating input before processing applies moderately, as the code does check `flxh->type` and ensures `avail` is sufficient before processing chunks.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code reads length fields from the input (e.g., `flxfh.size` from `FlxFrameChunk`). It validates `avail < flxfh.size` before processing, but does not check for integer overflow when calculating `flxfh.size - FlxFrameChunkSize` or when using `flxfh.size` in operations. This is moderately relevant as length validation is present but incomplete.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates `frame_data` and `delta_data` based on `flxdec->size = width * height`. It does not validate that this multiplication does not overflow, nor does it check if the resulting size is within reasonable allocation limits. This is a direct memory allocation based on input parameters, making the specification strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different FLX file types (FLI, FLC, FLX) and different chunk types (`FLX_FRAME_TYPE` vs others). It uses `switch` on `flxfh.id` and checks `flxh->type` for magic values. However, there is no strict enforcement that all types are handled consistently across all stages (e.g., endianness fixes, frame timing). The specification is highly relevant for media format decoders.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates `flxdec->size * 4` for output buffer, assuming 4 bytes per pixel. It does not appear to add any safety margin or account for padding. This is a weak connection because the allocation seems directly tied to the image dimensions without extra padding, but the specification is more about network/communication buffers.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "This is a decompression/decoding operation for FLX animation format. The function `flx_decode_chunks` (not shown) likely performs bounds checking. The current code validates chunk sizes before decoding, but does not explicitly show strict bounds checking for encoder/decoder buffers. Weak relevance since it's a decoder, not an encoder, but similar principles apply.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2010-1311_after_exclude_100:406a0451:spec": {
    "timestamp": "2026-01-17T00:36:15.743185",
    "cve_id": "CVE-2010-1311",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "406a0451",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via g_malloc for frame_data and delta_data but does not explicitly initialize it before use. The flx_decode_chunks function likely writes to frame_data, but if the decode fails or the frame is delta-based, uninitialized memory could be read, leading to information leaks or undefined behavior. This directly relates to HS-MEM-001.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error paths (wrong_type, decode failure). When an error occurs (e.g., wrong_type), the function returns GST_FLOW_ERROR but does not clearly show if the flxdec object state (like adapter, allocated memory) is cleaned up or reset. This could leave the object in an inconsistent state for subsequent operations, relevant to HS-STATE-002.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code reads length fields from the file header (flxh->size, flxh->width, flxh->height) and chunk header (flxfh.size). It uses these to calculate buffer sizes (flxdec->size = width * height) and check data availability. However, it does not explicitly validate these against integer overflow or platform limits before allocation/use, which is a key concern of HS-INPUT-001.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code calculates allocation size as width * height (for frame_data/delta_data) and later allocates out buffer as size * 4. It does not validate that these multiplications do not overflow, nor does it check against reasonable allocation limits. This is a direct and critical memory allocation safety issue addressed by HS-MEM-002.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different FLX file types (FLI, FLC, FLX) and chunk types (FLX_FRAME_TYPE). It uses endianness fixes and switches based on type. However, it doesn't show extensive validation to ensure type values are within expected ranges before using them in control flow (e.g., the switch on flxfh.id). This relates to consistent type handling.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates buffers based on calculated size (width*height and *4). There's no evident consideration for operational padding or safety margins. This specification is more relevant to low-level buffer management where alignment/padding is critical (e.g., network packets, encrypted data). The connection here is weak.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "This is a video decompression/decoding operation, not compression/encoding. The specification specifically mentions \"encoder buffers\" and \"image compression operations\". While bounds checking during decoding is important, the spec's focus on compression makes it only very loosely applicable to this decode scenario.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2019-1010065_before_exclude_100:0ec1dbb2:spec": {
    "timestamp": "2026-01-17T00:36:44.034425",
    "cve_id": "CVE-2019-1010065",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0ec1dbb2",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `cdf_grow_info` for dynamic memory allocation. While the newly allocated memory for the info array is used, there is no explicit full initialization shown (e.g., zeroing). However, the code does assign values to specific fields (`pi_id`, `pi_type`, `pi_str`, `pi_val`). For unknown types, it uses `memset` to zero `pi_val`. This is a partial but not guaranteed full initialization of the entire allocated structure, making the specification highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple error handling paths (via `goto out`). The `out` label consistently frees the `*info` pointer, sets it to NULL, and resets `*count` and `*maxcount` to 0. This maintains a consistent state (cleaned-up) for the output parameters on error, which is the core principle of this specification. It is strongly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 10,
        "reasoning": "The code performs multiple critical validations of length fields against limits. It checks `offs > UINT32_MAX / 4` to prevent overflow. It validates `sh.sh_len > CDF_SHLEN_LIMIT`. It uses `cdf_check_stream_offset` to ensure reads stay within bounds. It checks `sh.sh_properties > CDF_PROP_LIMIT`. This is a direct and perfect example of validating message/segment length fields, making it highly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "While the code doesn't show the internal logic of `cdf_grow_info`, it uses this function to manage an array based on `sh.sh_properties`. Before calling it, the code validates `sh.sh_properties` against `CDF_PROP_LIMIT`. This is a validation against an allocation limit. The subsequent loop also validates that data reads (`o4 + l > left`) stay within the bounds of the allocated/available section, which relates to usage requirements. Strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code's core function is to interpret property types from a data stream. It reads a `pi_type` field and uses a switch statement on `(pi_type & CDF_TYPEMASK)` to determine how to process the subsequent data (e.g., as int16, int32, string). It explicitly handles unexpected types (`CDF_ARRAY|CDF_BYREF|CDF_RESERVED` and `default`) by jumping to `unknown`. This enforces consistent type handling, making the specification strongly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "The code does not contain any regular expression parsing logic. It is parsing binary property information from a structured file format. This specification is completely irrelevant to the target code.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It is parsing binary data structures. This specification is completely irrelevant to the target code.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2018-20750_after_exclude_100:d8e939a3:spec": {
    "timestamp": "2026-01-17T00:36:44.608985",
    "cve_id": "CVE-2018-20750",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d8e939a3",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `cdf_grow_info` to allocate memory for `inp`. While the allocation itself is not directly shown, the subsequent code initializes the `pi_id` and `pi_type` fields for each property. However, the `pi_val` union is only initialized in the `unknown` default case via `memset`. For other types (like CDF_SIGNED16, CDF_LENGTH32_STRING, etc.), the union fields are written via `cdf_copy_info` or direct assignment, which constitutes initialization before use. The principle of initializing memory before use is relevant and partially followed, but not all code paths may guarantee full initialization of all fields before they are potentially read.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has a clear error handling path labeled `out`. On error, it frees the `*info` pointer, sets it to NULL, and resets `*count` and `*maxcount` to 0. This maintains a consistent state (all pointers NULL, counts zero) for the caller, preventing use of partially allocated data. This is a strong example of consistent state maintenance in error paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is parsing a Compound Document File (CDF) structure from a byte stream, which is a file format, not a network protocol. While the code validates input lengths and offsets (which is similar to network protocol validation), the specification is specifically about network protocol handlers. The relevance is therefore low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code validates multiple length fields from the input data against limits before using them for calculations or memory operations. Examples: 1) It checks `offs > UINT32_MAX / 4` to prevent overflow. 2) It validates `sh.sh_len` against `CDF_SHLEN_LIMIT`. 3) It validates `sh.sh_properties` against `CDF_PROP_LIMIT`. 4) It validates `nelements` against `CDF_ELEMENT_LIMIT`. These are direct applications of validating message length fields against platform-specific limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not directly show the memory allocation call (`cdf_grow_info` is a wrapper). However, it performs critical validation *before* any potential allocation or usage that relies on size parameters. It validates `sh.sh_properties` (which influences how many `cdf_property_info_t` structures are needed) and `nelements` (which can cause the info array to grow). This validation against limits (`CDF_PROP_LIMIT`, `CDF_ELEMENT_LIMIT`) is a direct application of the principle to validate size parameters against usage requirements, preventing excessive allocation or buffer overflows in subsequent loops.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code's core function is to interpret and process typed data from a file format (a protocol of sorts). It reads a `pi_type` field and uses a switch statement to handle different data types (CDF_SIGNED16, CDF_STRING, etc.) consistently. It validates the type (checking for CDF_VECTOR, CDF_ARRAY flags) and ensures the necessary data is present before processing. This is a strong example of enforcing consistent type handling across the parsing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It parses structured binary data (CDF file format). The specification about embedded NUL bytes in regex patterns is completely unrelated to this context.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilation or processing escape sequences. It is a binary file format parser. This specification has no relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2016-1834_before_exclude_100:a999a87b:spec": {
    "timestamp": "2026-01-17T00:36:46.350808",
    "cve_id": "CVE-2016-1834",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a999a87b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification about regular expression parsers and NUL bytes is weakly relevant. The code is an XML parser, not a regex parser. While input handling is a common theme, the specific issue of embedded NUL bytes in patterns does not directly apply to this XML scanning logic.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The specification about pattern compilers and escape sequences has weak relevance. This code parses XML tokens directly from a character stream and does not compile patterns or process escape sequences in the sense described (like regex escapes). It handles quotes for attribute values but does not interpret escape sequences within them.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code does not process protocol message length fields. It is a recursive descent XML parser that reads tokens sequentially from a scanner, with no explicit length fields being validated.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code calls alloc_node and alloc_attr, which presumably perform memory allocation. While the specification's principle of validating size parameters applies generally, the code does not show the allocation logic, so relevance is indirect.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The XML parser must enforce consistent handling of node types, attributes, content, and CDATA sections across all stages. The code shows logic for differentiating between elements, comments, PIs, and CDATA, and enforces syntactic consistency (e.g., matching end tags).",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The scanner functions (like pj_scan_get_until_ch) must validate buffer boundaries before accessing memory. The parser's safety heavily depends on these underlying scanning operations correctly managing the input buffer to prevent out-of-bounds reads.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The parser performs numerous input operations (advancing the scanner, reading until delimiters) and must maintain consistent buffer state invariants (e.g., scanner->curptr validity). Errors in state management could lead to security issues like infinite loops or incorrect parsing.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2016-1838_after_exclude_100:df331759:spec": {
    "timestamp": "2026-01-17T00:37:52.743136",
    "cve_id": "CVE-2016-1838",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "df331759",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code is an XML parser that uses string scanning functions (e.g., pj_scan_get_until_chr). While it processes input patterns (XML tags/attributes), it does not appear to use regular expressions. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The code is an XML parser that scans for literal characters (like '<', '>', quotes) but does not compile patterns or process escape sequences (e.g., \\n, \\t) within the XML content. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted XML input using scanner functions that operate on buffers with explicit lengths (e.g., pj_scan_get_until_chr). It must ensure length-aware operations to prevent buffer overreads. The scanner interface appears to be length-aware, but the correctness depends on its implementation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The XML parser does not parse explicit length fields; it parses text-based XML delimiters. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code allocates nodes and attributes via alloc_node/alloc_attr (not shown). While it should validate size parameters, the primary risk is from parsing logic (e.g., recursion depth, attribute counts) rather than direct size parameters. Part of the specification (allocation limits) has guidance value.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements an XML protocol parser and must enforce consistent type handling (e.g., node names, attributes, content) across all stages (parsing, attribute extraction, CDATA). Inconsistencies could lead to security issues like injection or parsing bypass.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code processes character data (XML tags, attributes, content) and must validate buffer boundaries before access to prevent overreads. Functions like pj_scan_get_until_chr and manual pointer advances (e.g., scanner->curptr+1) require careful boundary checks to avoid memory safety issues.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code is a parser that performs input operations (scanning, advancing) and must maintain consistent buffer state invariants (e.g., scanner->curptr within bounds). Errors in buffer state management could lead to crashes or infinite loops.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2021-37641_before_exclude_100:6a818a38:spec": {
    "timestamp": "2026-01-17T00:38:07.195454",
    "cve_id": "CVE-2021-37641",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6a818a38",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation and indexing operations in a machine learning context. There are no cryptographic operations on secret values present.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is unrelated to elliptic curve cryptography or any cryptographic curve implementations. It handles tensor data structures for ML operations.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No cryptographic processing is occurring in this code. The operations involve tensor splitting and value copying without cryptographic context.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code performs bounds validation through OP_REQUIRES checks (e.g., validating indices, checking params_dense_values_in.dims() > 0) before write operations in WriteSplits and WriteValues. However, it's not strictly about fixed buffers but tensor operations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code validates input dimensions and indices before processing (OP_REQUIRES_OK for ValidateIndices, checking dims() > 0). However, it's not comprehensive input size validation in the cryptographic/parser sense, but rather tensor shape validation.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code enforces some structural constraints through validation functions (ValidateIndices) and dimension checks, but this is specific to tensor data structures rather than general configuration parsing.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 1,
        "reasoning": "No privilege separation or process termination mechanisms are present in this tensor computation code.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 1,
        "reasoning": "No security-critical state transitions or atomic verification mechanisms are present in this tensor manipulation code.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2016-5844_after_exclude_100:e43270b3:spec": {
    "timestamp": "2026-01-17T00:38:30.400592",
    "cve_id": "CVE-2016-5844",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e43270b3",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation and data copying operations. It does not involve any cryptographic operations on secret values. The specification about constant-time cryptographic execution is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor computation kernel for a machine learning framework (likely TensorFlow). It does not implement elliptic curve cryptography or any cryptographic operations requiring side-channel resistance.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory operations for tensor data copying, but these are not cryptographic processing operations. The requirement for constant-time properties during cryptographic processing does not apply to this general-purpose tensor manipulation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 7,
        "reasoning": "The code performs buffer operations with tensor data. While it validates tensor dimensions (e.g., checking dims() > 0, dim_size(0) - 1), it doesn't show explicit bounds validation before write operations in the visible code. The WriteValues and WriteSplits functions (not shown) would need to implement proper bounds checking. The principle of bounds validation before writes is moderately relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "The code performs input validation before processing: checking that params_nested_splits_in is non-empty, validating tensor dimensions, and calling ValidateIndices. This aligns with the principle of complete input size validation before processing, though the validation shown is not exhaustive of all possible size-related issues.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 6,
        "reasoning": "The code validates structural constraints on input tensors (dimensions, non-empty splits, etc.) through OP_REQUIRES calls. This is similar to configuration parsers enforcing structural constraints, though the context is tensor data rather than configuration data. The principle has moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 1,
        "reasoning": "The code is a computational kernel performing tensor operations. It does not involve privilege separation or process termination mechanisms. This security specification about privilege separation failures is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 1,
        "reasoning": "The code performs sequential tensor computations without apparent security-critical state transitions requiring atomic verification. This is a data processing function rather than a state machine with security-critical transitions.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2019-20840_before_exclude_100:99dfb093:spec": {
    "timestamp": "2026-01-17T00:38:35.282207",
    "cve_id": "CVE-2019-20840",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "99dfb093",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification about initializing memory allocations before use has weak relevance. The code does allocate memory via `gf_strdup`, but the primary vulnerability is not about uninitialized memory use. The `str` buffer is written to before being read, so initialization is not the core issue.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function lacks error handling for the `gf_strdup` call, which could fail and return NULL. If it fails, the function still returns `GF_OK`, leaving the `p->content_script_types` in an inconsistent state (potentially NULL when not expected). However, the main security flaw is a buffer overflow, not a complex object state inconsistency.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function reads data from a bitstream (`bs`), which is a form of input. The specification about validating input before processing is highly applicable. The code reads bytes into a fixed-size buffer without checking if the input length exceeds the buffer capacity, leading to a buffer overflow.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The principle of guarding memory operations with size validation directly applies. The code writes to a fixed-size stack buffer `str[1024]` based on input from the stream. It does not validate that the number of bytes read (`i`) will be less than 1024 before writing, which is a classic buffer overflow vulnerability. The `ISOM_DECREASE_SIZE` call happens after the overflow.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is explicitly for BMP parsers and bit count requirements. This code is for a DIMSScriptTypesBox in the ISOBMFF/MP4 family, which is unrelated to the BMP image format.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This specification directly describes the vulnerability in the code. The function performs buffer write operations (`str[i] = gf_bs_read_u8(bs)`) in a loop without validating that `i` is less than the allocated space (1024) before each write. This is a direct violation of the specification.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code is a parser that reads from a bitstream. The `while` loop reads bytes and increments `i` without maintaining a proper invariant between the buffer position (`i`) and the buffer's total capacity. This lack of invariant is what allows the buffer position to exceed the buffer size, leading to corruption. The connection is clear, though the specification's wording is broad.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2018-20750_after_exclude_100:9c97c7ac:spec": {
    "timestamp": "2026-01-17T00:38:43.962794",
    "cve_id": "CVE-2018-20750",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9c97c7ac",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The code allocates memory with `gf_malloc` and immediately initializes it by reading data from the bitstream and null-terminating it. This directly aligns with HS-MEM-001's requirement to initialize memory before use, preventing exposure of uninitialized memory contents.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function has an error handling path for a failed memory allocation (`return GF_OUT_OF_MEM`). However, it does not address the state of the `p` object if the allocation fails after the pointer has been assigned (though it's set to NULL on failure). The main principle of maintaining consistent states in error paths applies.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function reads data from a bitstream (`GF_BitStream *bs`), which could be considered a form of input/data protocol. However, it lacks validation of the input `s->size` parameter before using it for memory allocation and reading, which is a core principle of the specification. The connection is indirect as it's not explicitly a network protocol handler.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is for a DIMS script types box parser (likely multimedia container format), not an image format parser. The principle of validating header fields before processing is good practice but not directly applicable to this specific scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is specifically for a BMP image parser and its bit count requirements. The target code parses a completely different multimedia box format and has no relation to BMP or bit counts.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs a buffer write operation via `gf_bs_read_data` into the newly allocated `p->content_script_types` buffer. It writes exactly `s->size` bytes, which matches the allocated size (`s->size+1`), and then writes a null terminator. While the space exists due to the +1 allocation, the lack of validation of `s->size` itself (as per spec 5) means the \"available space\" is not securely guaranteed. The principle directly applies.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function reads data from a bitstream, advancing its internal position. It should ensure that reading `s->size` bytes does not exceed the bitstream's available data, but this invariant is not checked. The specification's principle of maintaining buffer position invariants during parsing has some connection, but the spec is framed around parser state transitions, which is a broader concept than this simple read operation.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2015-8863_before_exclude_100:7fee5302:spec": {
    "timestamp": "2026-01-17T00:39:32.303412",
    "cve_id": "CVE-2015-8863",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7fee5302",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs equation parsing for tensor operations (likely Einsum). It does not involve any cryptographic operations on secret values. The logic is purely about mapping labels and counting dimensions.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It is a mathematical utility function for tensor labeling.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No cryptographic processing or secure memory operations (like zeroing secrets) are present. The function manipulates containers for labels and counts.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code parses an equation string, but it's not using regular expressions. It calls `ParseEinsumEquation`. While it processes a string input, the specification about embedded NUL bytes in regex patterns is not directly applicable, though string parsing in general could be related.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile patterns or process escape sequences. It maps characters to integer labels. The specification is about pattern compilers, which is not relevant here.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function receives a `string& equation` as input. While it uses C++ `string` which is length-aware, the specification about using length-aware operations for untrusted input is a general secure coding principle. The relevance is weak because the code does not show explicit, unsafe length calculations (like C-style `strlen`), but it processes external input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No file operations or file position calculations are present in this code snippet.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 5,
        "reasoning": "This is not an archive parser, and there are no file position validations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      }
    ]
  },
  "CVE-2021-41201_after_exclude_100:ed1dec54:spec": {
    "timestamp": "2026-01-17T00:39:53.134223",
    "cve_id": "CVE-2021-41201",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ed1dec54",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs equation parsing for tensor operations (likely Einsum). It does not involve any cryptographic operations on secret values. The logic is purely about parsing labels and computing counts, with no timing-sensitive secret data handling.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It is a mathematical equation parser for tensor dimensions.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No secure memory operations or cryptographic processing are present. The code uses standard containers (vectors, hash maps) for label mapping and counting without any constant-time requirements.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "While the code parses an input string (equation), it is not a regular expression parser. The ParseEinsumEquation function likely splits the equation string based on specific syntax (like \"->\" for output). Embedded NUL bytes could potentially cause issues if the string is not length-aware, but the specification is about regex parsers specifically, making the relevance very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile patterns or process escape sequences. It maps characters in the input string to integer labels. There is no indication of pattern compilation with escape sequence handling.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes the input `equation` string, which could be untrusted. It passes it to `ParseEinsumEquation`. If the underlying string operations are not length-aware (e.g., relying on null-termination), vulnerabilities could arise. However, the target code shown does not directly manipulate the string; the risk depends on the implementation of `ParseEinsumEquation` and `MapToLabels`. There is a weak connection.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs no file operations, file position calculations, or integer size calculations related to file positions. It deals with array indices and counts within in-memory data structures.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 5,
        "reasoning": "The code is not an archive parser and does not validate file positions against any archive boundaries. It processes a mathematical equation string for tensor operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      }
    ]
  },
  "CVE-2010-1311_before_exclude_100:324c9804:spec": {
    "timestamp": "2026-01-17T00:40:12.391182",
    "cve_id": "CVE-2010-1311",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "324c9804",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code uses `_TIFFmemset` to initialize the LZW code table after a CLEAR code, which is a form of memory initialization. However, this is not about allocation initialization but re-initialization of existing buffers. The relevance is moderate because the principle of initializing data structures before use applies, but it's not about heap allocation safety.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The function has multiple error handling paths (e.g., corrupted table detection, insufficient data) that return 0. It must ensure decoder state variables (`sp->lzw_nbits`, `sp->dec_oldcodep`, etc.) are left in a consistent state before returning, which it appears to do by updating them at the end. Strong relevance as error handling must maintain object state.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2018-8905_after_exclude_100:22de8fb5:spec": {
    "timestamp": "2026-01-17T00:40:22.529589",
    "cve_id": "CVE-2018-8905",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "22de8fb5",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code uses `_TIFFmemset` to initialize a portion of the `dec_codetab` array after a CODE_CLEAR, which aligns with the principle of initializing memory before use. However, the initialization is not applied to all allocations or the entire table at the start, and the relevance is moderate as the main memory structures (like the code table) are managed within the decoder state, not dynamically allocated in this function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The function has multiple error handling paths (e.g., corrupted LZW table, insufficient data) that return 0, but it also updates decoder state variables (like `sp->lzw_nbits`, `sp->dec_restart`) before returning. The state may be partially updated on some error paths (e.g., after detecting a long string that doesn't fit, it sets `sp->dec_restart` and `sp->dec_codep` then breaks, but still updates other state at the end). This could lead to inconsistent state, making the specification strongly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "The code is an image decompression function (LZW decoder) processing raw byte data from a TIFF file, not a network protocol handler. Input validation occurs (e.g., checking code values, lengths), but the specification is about network protocols, so relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It decodes LZW-compressed data, handling codes and string tables. No regex or NUL byte handling in patterns is present.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It's a LZW decompression algorithm operating on codes and a dictionary.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function processes potentially untrusted input (TIFF file data) and uses length-aware operations: it checks `codep->length` against `occ` to prevent overflows, uses bounds checks on `free_entp` against `dec_codetab` array, and ensures `occ` is non-negative. However, it uses pointer arithmetic and loops without explicit length limits on all string copies (e.g., the `do-while` loops copying from `codep->next` rely on the table integrity). Moderate relevance as length checks are present but not exhaustive.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform buffer allocation; it operates on provided buffers (`op0`, `occ0`). However, it ensures `occ` fits in a long and checks `codep->length > occ` to avoid overrunning the output buffer. There's no explicit safety margin or padding consideration, so relevance is weak.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "This is an image compression/decompression operation (LZW decoder) that strictly enforces bounds checking: validates `code` against CODE_CLEAR and CODE_EOI, checks `free_entp` against `dec_codetab` bounds, ensures `codep->length` does not exceed output buffer `occ`, and validates `codep->length > 0`. It also checks for corrupted tables. Highly relevant as it directly applies to image compression buffer safety.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2021-43860_before_exclude_100:3cc7359b:spec": {
    "timestamp": "2026-01-17T00:40:25.618639",
    "cve_id": "CVE-2021-43860",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3cc7359b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes a bundle file (likely a binary format) but does not explicitly validate protocol message length fields. While the bundle loading function may internally parse structured data, the target code itself does not directly handle such length fields, making the relevance weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      }
    ]
  },
  "CVE-2021-43860_after_exclude_100:7b338a1f:spec": {
    "timestamp": "2026-01-17T00:41:21.124423",
    "cve_id": "CVE-2021-43860",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7b338a1f",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code processes a Flatpak bundle file, which involves parsing its metadata and structure. While file parsing could be considered a form of protocol handling, the code does not explicitly show validation of length fields from the bundle file's headers or metadata. There is a weak connection because the `flatpak_bundle_load` function likely reads structured data, but the code snippet does not reveal any direct length field validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns validating memory allocation size parameters. The code uses GLib's automatic memory management (g_autoptr, g_autofree) and does not show explicit memory allocation calls like malloc or g_malloc. However, functions like `flatpak_bundle_load` and `ostree_repo_copy_config` internally perform allocations. The relevance is weak because the allocation logic is hidden, but improper size validation in those functions could lead to vulnerabilities.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires consistent type handling in protocol implementations. The code deals with a bundle file format (a protocol of sorts) and extracts metadata, refs, checksums, etc. It uses GVariant for metadata and checks for its existence. There is moderate relevance because ensuring type consistency (e.g., that metadata fields are of expected types) is important for security, but the code snippet does not show deep type validation logic.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code does not use regular expressions at all. It parses a bundle file, but there is no indication of regex processing. Therefore, the relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns pattern compilers and escape sequence boundaries. The code does not involve pattern compilation (like regex or glob patterns). It focuses on loading and deploying Flatpak bundles. Thus, the relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification advises using length-aware string operations for untrusted input. The code handles file paths, origin strings, and metadata from a bundle file (which could be untrusted). It uses GLib functions, which often rely on null-terminated strings. There is weak relevance because the code does not explicitly show length-aware operations (e.g., g_strlcpy), but vulnerabilities could arise if internal functions do not handle strings safely.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires validating external string data for proper termination. The code processes strings from a bundle file (external data) such as origin, basename, and metadata. It likely passes these to GLib functions that expect null-terminated strings. There is moderate relevance because ensuring these strings are properly terminated is important, but the validation is likely delegated to functions like `flatpak_bundle_load`.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "The specification states file format parsers must enforce structural invariants at chunk boundaries. The code explicitly calls `flatpak_bundle_load` to parse a bundle file and later checks for metadata existence. This is directly relevant because parsing a file format (Flatpak bundle) requires validating its structure. The code shows some validation (checking fp_metadata is not NULL), but the deeper structural checks are inside the load function. Therefore, relevance is moderate to strong.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      }
    ]
  },
  "CVE-2019-11222_before_exclude_100:2226e343:spec": {
    "timestamp": "2026-01-17T00:42:18.130996",
    "cve_id": "CVE-2019-11222",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2226e343",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via `g_malloc(size)` but does not explicitly initialize the allocated buffer (`bits`) before reading data into it using `next_int()`. While the subsequent read loop writes to the buffer, the specification about initializing memory before use is relevant, especially if the read loop could fail or be interrupted, leaving uninitialized memory. However, the buffer is immediately written to in a controlled loop, so the risk is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function uses a macro `RETURN` that frees `bits` and returns on error paths, maintaining a consistent state (no memory leak). However, other state variables like `ww`, `hh`, `hx`, `hy` are not reset on error, but they are local and not exposed. The error handling is consistent for memory, but not all object states are fully managed, making it moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code reads from a file stream (`fstream`), not a network protocol. Network-specific validation does not apply here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "The code uses `fgets(line, MAX_SIZE, fstream)` and checks if `strlen(line) == MAX_SIZE-1` to detect overflow, which is a form of output buffer bounds validation. However, `sscanf` is used without explicit length validation on `name_and_type`, which could overflow if the input line is malformed. The relevance is moderate due to the mix of safe and potentially unsafe practices.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code uses `sscanf` with format strings like `\"#define %s %d\"` where `%s` writes to `name_and_type` (size `MAX_SIZE`). While `fgets` limits input line length, `sscanf` does not enforce length limits on `%s`, posing a potential overflow risk. The specification about strict length validation is weakly relevant because the input is bounded by `fgets`, but not fully validated for `sscanf`.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a formatting state machine; it sequentially parses lines with simple conditionals. No complex state or position tracking is present, so the specification has very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Formatting state machines must maintain consistent position tracking"
      },
      {
        "score": 9,
        "reasoning": "The code parses a bitmap file format (XBM-like). It validates critical header fields (`ww` and `hh`) before processing data (`if (!ww || !hh) RETURN (FALSE);`). This directly aligns with the specification about validating header fields before processing. However, it does not validate other fields like size calculations for overflow, so not perfect.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code calculates `size = bytes_per_line * hh` and allocates with `g_malloc(size)`. It validates `ww` and `hh` are non-zero before calculation, but does not check for integer overflow in `bytes_per_line` or `size`. The specification about pre-validating size parameters is highly relevant, though not fully implemented.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2019-11222_after_exclude_100:142011d4:spec": {
    "timestamp": "2026-01-17T00:42:29.958771",
    "cve_id": "CVE-2019-11222",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "142011d4",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via `g_malloc(size)` but does not explicitly initialize the allocated buffer (`bits`) before reading data into it. The subsequent loops write to the buffer, so it's not used uninitialized. However, the specification about full initialization before use is relevant because the allocation is not zero-initialized (like `g_malloc0` would be), and any uninitialized gaps (e.g., due to padding logic) could remain. The principle applies, but the risk is moderate as writes cover the intended size.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code uses a macro `RETURN(code)` that frees `bits` and returns. This ensures cleanup on error paths, maintaining a consistent state (no memory leak). However, other object states (like output parameters `width`, `height`, `data`, `x_hot`, `y_hot`) are only set on success; on error they are left unchanged, which is acceptable. The error handling is consistent, so the specification is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "The code reads from a file stream (`fstream`), not a network protocol. Network-specific validation (like protocol handlers) does not apply. There is input validation, but the specification is about network protocols, so relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code uses `fgets(line, MAX_SIZE, fstream)` to read lines, which bounds input to `MAX_SIZE`. However, it checks `strlen(line) == MAX_SIZE-1` to detect possible truncation, which is a form of output buffer validation for the string. The specification is about string formatting operations (like `sprintf`), not `fgets`. Weak relevance because the code does similar bounds checking but not for formatting functions.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code uses `sscanf` with format strings like `\"#define %s %d\"` and `\"static short %s = {\"`. The `%s` can overflow `name_and_type` array if the input token is longer than `MAX_SIZE`. No explicit length validation in the format template (e.g., `%MAX_SIZEs`). This is a potential issue, but the specification is about numeric format templates specifically, not string templates. Low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a formatting state machine with position tracking. It reads lines sequentially and parses them. No state machine is evident. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Formatting state machines must maintain consistent position tracking"
      },
      {
        "score": 9,
        "reasoning": "The code parses a bitmap file format (XBM-like). It validates critical header fields: width and height are checked for positive values (`if (value <= 0)`), and both must be set (`if (!ww || !hh)`) before processing data. Also checks for overflow in size calculation. This directly matches the specification's requirement for image format parsers. Highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code performs size calculation `size = bytes_per_line * hh` and checks for overflow (`if (size / bytes_per_line != hh)`) before allocating memory with `g_malloc(size)`. This is a direct application of pre-validation of size parameters to guard memory allocation. Highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2022-27382_before_exclude_100:922e32b0:spec": {
    "timestamp": "2026-01-17T00:43:00.856263",
    "cve_id": "CVE-2022-27382",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "922e32b0",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It deals with SQL item equality and query optimization.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It is focused on creating pushable equality conditions for SQL queries.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code does process items, it does not directly handle string data or use length-aware operations on untrusted input. Its primary operations are cloning items and creating equality expressions within a controlled SQL context.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation via `new (thd->mem_root)` and must ensure the allocated `Item_func_eq` objects are properly initialized. Failure to initialize could lead to undefined behavior. However, the initialization is handled by the constructor call.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (e.g., checking if `left_item_clone` or `right_item_clone` is NULL, checking if `eq` allocation fails). It must ensure that object states remain consistent when returning `true` (error) or `false` (success). For example, it sets the `IMMUTABLE_FL` flag only on a specific success path.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code does not handle network protocols or validate external input. It operates on internal SQL item structures during query optimization.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform buffer allocation with padding requirements. Memory allocation is done via the MySQL memory root for `Item` objects, which is managed by the system.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve image compression, encoder buffers, or bounds checking for such operations. It is unrelated to multimedia processing.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2018-20750_after_exclude_100:850c669c:spec": {
    "timestamp": "2026-01-17T00:43:26.648865",
    "cve_id": "CVE-2018-20750",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "850c669c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It deals with SQL item equality and query optimization.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It creates equality expressions for SQL query optimization.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 2,
        "reasoning": "While the code does process items, it does not handle string operations on potentially untrusted input. The focus is on cloning and comparing SQL expression items.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "The code performs memory allocations via `new` operator and should ensure proper initialization. However, it doesn't show explicit initialization of all allocated memory before use, which could be relevant for security.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error handling paths (returning true/false) and should maintain consistent object states when errors occur. This is relevant as improper error handling could leave objects in inconsistent states.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve network protocol handling or input validation from network sources. It's part of SQL query processing internals.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "While the code allocates memory, it doesn't involve buffer operations with padding requirements. The allocations are for SQL expression objects, not buffers with specific padding needs.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve image compression operations, encoder buffers, or bounds checking for compression operations. It's unrelated to image processing.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2013-4166_before_exclude_100:365db432:spec": {
    "timestamp": "2026-01-17T00:44:17.289790",
    "cve_id": "CVE-2013-4166",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "365db432",
    "scores": [
      {
        "score": 2,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code adds a recipient key ID to an array during GPG operations. There is no protocol message parsing or length field validation in this function.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2013-4166_after_exclude_100:a3837e47:spec": {
    "timestamp": "2026-01-17T00:44:29.692686",
    "cve_id": "CVE-2013-4166",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a3837e47",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not process protocol message length fields. It handles a key identifier string for GPG operations, not protocol parsing with integer length fields.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak connection. The code uses g_strdup and g_strdup_printf for memory allocation, but the input (keyid) is not validated for length before allocation. However, the primary risk is not a size parameter overflow but potential unbounded string duplication. The specification's focus on allocation limits and usage requirements is only tangentially related.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a protocol with typed fields. It handles a string key identifier in a single, consistent way (adding brackets for email-like strings).",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It uses strchr and string formatting functions.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain a pattern compiler or process escape sequences.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function processes an input string (`keyid`) which is potentially untrusted (e.g., from user input or external data). It uses `strchr` and `g_strdup_printf`/`g_strdup`, which are not length-aware. If `keyid` is not null-terminated or is extremely long, it could lead to issues like buffer over-reads or excessive memory consumption. The specification's principle of using length-aware operations for untrusted input directly applies, though the code currently does not follow it.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not validate protocol message fields against RFC-specified lengths. It processes a GPG key identifier, which does not have a standard RFC length constraint in this context.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code does not process TLV (Type-Length-Value) encoded data. It handles a simple string.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-27383_after_exclude_100:521b53e3:spec": {
    "timestamp": "2026-01-17T00:45:24.056838",
    "cve_id": "CVE-2022-27383",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "521b53e3",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It performs a simple string comparison and concatenation. Embedded NUL bytes are not relevant to this context.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not process escape sequences or compile patterns. It handles a simple filename extension check and append operation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code uses `memcpy` with explicit length (`dl->length`) for copying the main string, which is a length-aware operation. However, it uses `strcpy` to append the extension, which is not length-aware. The principle of using length-aware operations for potentially untrusted input (like `dl->str`) directly applies to this scenario.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code allocates memory via `alloc_root` but does not fully initialize the entire buffer before use. It copies `dl->str` and then appends `SO_EXT`, leaving the final null terminator to be written by `strcpy`. The principle of initialization is related, but the risk is mitigated by the subsequent writes.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The function has a simple error path (if the condition fails, it does nothing). While it maintains the state of the `dl` object consistently (either unchanged or fully updated), the specification about complex error handling paths is not a central concern here.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "The code does not handle network protocols. It processes a local filename string. Input validation is present but not in a network context.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages or enforce RFC-specified constraints. It deals with a filename and a file extension.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 3,
        "reasoning": "The code does not process TLV (Type-Length-Value) structures. It performs bounds checking (`dl->length < so_ext_len`) but not in a TLV context.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-27383_before_exclude_100:1656af0e:spec": {
    "timestamp": "2026-01-17T00:45:29.637623",
    "cve_id": "CVE-2022-27383",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1656af0e",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code processes a filename string to potentially append a file extension. While it involves string input, it does not use regular expressions, making the connection weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code performs simple string manipulation (appending a suffix) and does not compile patterns or process escape sequences, resulting in weak relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code uses `memcpy` with a known length (`dl->length`) and `strcpy` for a known constant suffix (`SO_EXT`). However, the `my_strcasecmp` call uses pointer arithmetic that depends on `dl->length` being greater than `so_ext_len`; if `dl->length` is less than or equal to `so_ext_len`, it would read out-of-bounds. This is a classic case where length-aware operations and bounds checking for untrusted input are critical.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Memory is allocated via `alloc_root`. The code immediately initializes it with `memcpy` and `strcpy`, so it is not left uninitialized. However, the specification's principle of ensuring memory is initialized before use is followed here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function modifies the `dl` object's `str` and `length` fields. If an error occurred (e.g., allocation failure from `alloc_root`), the object state could be left inconsistent. However, `alloc_root` typically does not return NULL on failure in many implementations (it may terminate), so error paths are not explicitly handled, making the connection partial.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code processes a local filename string for a dynamic library, not network protocol input. The principle of validating input before processing is broadly applicable but not specific to this context.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The specification is about RFC-specified length constraints for protocol messages. The code handles a filename and its length, but it's not a network protocol field, and there is no RFC involved. The general concept of length validation is tangentially related.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification is about TLV (Type-Length-Value) processing and bounds checking. The code does not process TLV structures. However, it does perform an operation that requires ensuring `dl->length` is sufficient before the `my_strcasecmp` call, which is a form of bounds checking. The connection is indirect.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-2980_before_exclude_100:7cc390cd:spec": {
    "timestamp": "2026-01-17T00:45:55.282731",
    "cve_id": "CVE-2022-2980",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7cc390cd",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not contain any regular expression parsing logic. It handles mouse events, window management, visual mode operations, and text insertion/selection. There is no processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation or escape sequence processing. It deals with mouse button events, cursor movement, and editor operations like yank/put. No pattern parsing is present.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-2980_after_exclude_100:5b7c0477:spec": {
    "timestamp": "2026-01-17T00:46:05.327595",
    "cve_id": "CVE-2022-2980",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5b7c0477",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a mouse event handler in Vim, dealing with GUI interactions, cursor movement, and visual mode operations. There is no regular expression parsing or processing of input patterns with embedded NUL bytes. The specification is about regex parsers, which is irrelevant to this mouse handling function.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It handles mouse events, keyboard modifiers, and buffer/window operations. The specification is about pattern compilers, which is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the function processes some input (mouse events, key presses), it primarily uses safe system calls (like safe_vgetc) and does not directly handle untrusted string data. There is no significant string processing of user-provided data that would require length-aware operations. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 4,
        "reasoning": "The function uses static and local variables, some of which are initialized. However, there is no dynamic memory allocation (malloc/calloc) within this function. Memory safety concerns are minimal here. The specification about initializing memory allocations is weakly relevant as the code does not perform such allocations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple return paths and error handling (e.g., returning FALSE under certain conditions). It maintains some state consistency (e.g., got_click, do_always flags). However, it does not manage complex objects with invariants. The relevance is moderate but not strong.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This is a mouse and keyboard input handler for a text editor, not a network protocol handler. There is no network communication or protocol parsing involved. The specification is completely irrelevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not process character encodings or validate buffer boundaries in that context. It does handle mouse coordinates and window boundaries, but not in the sense of character encoding buffers. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "The function reads input events (mouse/keyboard) but is not a parser for structured data. It uses input buffering (stuffcharReadbuff) and checks for key events, but does not maintain complex buffer state invariants like a parser would. The relevance is low.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-30592_before_exclude_100:9d4f4a5b:spec": {
    "timestamp": "2026-01-17T00:46:14.758415",
    "cve_id": "CVE-2022-30592",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d4f4a5b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code validates input parameters (max_table_size, dyn_table_size, max_risked_streams) by passing them to lsqpack_enc_init, but there is no explicit validation against platform-specific integer limits (e.g., SIZE_MAX, overflow risks). The relevance is weak because the principle of validating numeric inputs applies, but the code does not show explicit bounds checking against architectural limits.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes an encoder with size parameters, but does not show explicit validation of these parameters against allocation limits or usage requirements before passing them to lsqpack_enc_init. The function could fail internally, but pre-validation is not visible. Weak relevance as the concept applies but is not demonstrated in the code snippet.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "The code handles protocol settings for QPACK (HTTP/3) and uses consistent types (unsigned int) for size parameters. However, the code snippet does not show cross-stage type handling (e.g., serialization/deserialization). Moderate relevance because it's a protocol function ensuring settings are applied once, but limited view of full protocol processing.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code uses a fixed-size buffer (qeh_tsu_buf) whose size is passed to lsqpack_enc_init, but there is no visible calculation of padding or safety margins. The buffer size might be predetermined. Very low relevance as the specification focuses on allocation with padding, which is not evident here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 2,
        "reasoning": "The code initializes a QPACK encoder (header compression), not image compression. The specification is about image compression bounds checking, which is unrelated to the HTTP/3 QPACK context. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code does not show dynamic memory allocation; it uses a pre-existing struct and a fixed buffer. Memory initialization is not a visible issue here. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code maintains state consistency through flags (QEH_INITIALIZED, QEH_HAVE_SETTINGS) and returns errors early if settings are already set. Error paths return -1 without corrupting state. Strong relevance because the function ensures state transitions are controlled and error handling preserves object integrity.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The function validates the qeh state (flags) and checks for duplicate settings before processing. However, it does not validate the content of the size parameters (e.g., sanity checks). Moderate to strong relevance because input validation is performed for the object state, though parameter value validation is limited.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2022-30592_after_exclude_100:2e7490ac:spec": {
    "timestamp": "2026-01-17T00:47:03.310052",
    "cve_id": "CVE-2022-30592",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2e7490ac",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code validates some input parameters (e.g., checking if settings already set) but does not explicitly validate protocol message length fields against platform-specific integer limits. The function receives size parameters (max_table_size, dyn_table_size) but passes them directly to lsqpack_enc_init without bounds checking for integer overflow/wraparound. Weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code handles size parameters for QPACK encoder initialization. While it adjusts dyn_table_size if below minimum, it doesn't validate max_table_size or dyn_table_size against allocation limits or usage requirements before passing to lsqpack_enc_init. The lsqpack_enc_init function likely performs some validation, but this isn't shown. Moderate relevance as the principle applies.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code uses consistent types for QPACK encoder settings (unsigned integers) and maintains state flags consistently. However, the specification about \"consistent type handling across all processing stages\" is broader than what's visible in this single function. Weak to moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code uses a fixed-size buffer (qeh_tsu_buf) whose size is passed to lsqpack_enc_init, but there's no visible calculation for operational padding or safety margins. The buffer size might be predetermined. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The specification specifically addresses \"image compression operations\" while this code deals with QPACK (header compression for HTTP/3). Different domain. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't show memory allocation - it works with an already initialized qeh structure (assert checks QEH_INITIALIZED). Memory initialization would occur elsewhere. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code maintains consistent state through the qeh_flags field (checking QEH_HAVE_SETTINGS, setting it after successful initialization). Error paths return -1 without modifying state. Strong relevance as the principle is directly applied.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The function validates some input (checking if settings already set) and adjusts dyn_table_size, but doesn't comprehensively validate all parameters before passing to lsqpack_enc_init. The principle of validating input before processing applies. Moderate to strong relevance.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2022-23588_before_exclude_100:4d379eee:spec": {
    "timestamp": "2026-01-17T00:47:04.351348",
    "cve_id": "CVE-2022-23588",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4d379eee",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It processes TensorFlow node graphs, constant tensors, and performs constant folding. There is no pattern matching or regex handling that would need to handle embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It deals with tensor protobufs, node definitions, and tensor values, not textual patterns or escape sequence processing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code processes input from node definitions and tensor protobufs which could be considered untrusted (from external graphs). It uses proper tensor parsing with FromProto() and checks data types/shapes, but doesn't explicitly use length-aware string operations. Some guidance about validating untrusted serialized data applies.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This is constant folding optimization code in TensorFlow, not cryptographic operations. There are no secret values being processed, and timing attacks are not a concern for this graph optimization functionality.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code performs tensor computation and constant folding, not elliptic curve cryptography. No cryptographic operations or curve models are involved.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. While the code does memory operations (allocating/deleting tensors), it's not performing cryptographic processing that would require constant-time properties. The memory cleanup uses RAII patterns but not for side-channel resistance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The code tracks total_inputs_size and manages memory allocation/deallocation for Tensor objects. It uses RAII cleanup (inputs_cleanup) and properly deletes allocated tensors. The size tracking for inputs could relate to memory allocation consistency, though not the primary focus.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code demonstrates resource management through RAII cleanup (inputs_cleanup) that ensures proper tensor deletion. It maintains invariant consistency by checking node properties (IsReallyConstant), validating attributes, and handling both successful and error paths with proper resource cleanup. The pattern of acquiring resources and guaranteeing cleanup aligns with resource management principles.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2022-23588_after_exclude_100:7bc52655:spec": {
    "timestamp": "2026-01-17T00:47:39.160153",
    "cve_id": "CVE-2022-23588",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7bc52655",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing. It processes TensorFlow node definitions and tensor data, focusing on constant folding optimization rather than pattern matching with regular expressions.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile or process patterns with escape sequences. It deals with tensor protobuf deserialization and node evaluation, not with lexical analysis of pattern strings.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code processes tensor data from potentially untrusted graph definitions. While it uses Tensor::FromProto which should handle serialized data safely, there's no explicit length-aware string processing shown. The relevance is indirect as improper handling of tensor proto data could lead to memory safety issues.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is a constant folding optimization routine in a machine learning framework, not a cryptographic operation. No secret values are being processed, and timing attacks are not a concern for this functionality.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code performs tensor operations and graph optimization, not elliptic curve cryptography. No cryptographic curves or side-channel resistance considerations apply.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the code does memory operations (allocating tensors), it's not performing cryptographic processing that would require constant-time properties. This is general tensor manipulation code.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code tracks total_inputs_size and performs memory allocation for Tensor objects. It maintains cleanup via RAII patterns and checks tensor sizes. However, it doesn't show complex size tracking mechanisms beyond basic accumulation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code demonstrates careful resource management through the inputs_cleanup RAII pattern that ensures proper cleanup of allocated tensors. It maintains invariant consistency by checking tensor properties (dtype validity, non-reference types) before processing and ensuring outputs are properly sized and initialized.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2016-5844_before_exclude_100:9d3d92f0:spec": {
    "timestamp": "2026-01-17T00:47:54.741768",
    "cve_id": "CVE-2016-5844",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d3d92f0",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor reshaping operations for sparse tensors. It involves no cryptographic operations on secret values. The calculations are purely mathematical (multiplication, division) for shape transformation and are not time-sensitive in a cryptographic sense.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It is a numerical tensor manipulation function within a machine learning framework.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs standard memory allocation and tensor data copying. While it manages memory, it does not involve cryptographic processing or require constant-time properties for security against side-channel attacks.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code allocates output tensors (`context->allocate_output`) based on calculated sizes (`nnz`, `output_rank`). It must correctly track and allocate the required memory size. However, the specification's focus on \"consistent size tracking\" is more about preventing internal allocator corruption than the high-level size calculations done here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function manages tensor resources (indices, shape) and must maintain invariants like `output_shape.num_elements() == dense_size`. The validation (`OP_REQUIRES`) ensures the reshape operation's preconditions and postconditions are consistent, which aligns with maintaining \"invariant consistency\" for the resource (the sparse tensor).",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code processes integer vectors and matrices from input tensors, not external string data. Validation is performed on tensor shapes and values, but not on null-terminated strings.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse file formats. It operates on in-memory tensor data structures.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The core function of this code is calculating new image/tensor dimensions (`output_shape`) from target dimensions. It performs arithmetic operations (`product *= size`, `dense_size / product`, `product * missing`) to infer missing dimensions and validate shape compatibility. These calculations must be protected from integer overflow, which is not explicitly checked in the provided code (e.g., `product *= size` could overflow). This directly relates to the specification's requirement for overflow-protected arithmetic in dimension calculations.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      }
    ]
  },
  "CVE-2016-5844_after_exclude_100:94edc9da:spec": {
    "timestamp": "2026-01-17T00:47:58.006188",
    "cve_id": "CVE-2016-5844",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "94edc9da",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor reshaping operations, not cryptographic operations on secret values. There is no handling of cryptographic keys, encryption, decryption, or any secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor manipulation function in a machine learning framework (likely TensorFlow). It has no relation to elliptic curve cryptography, curve models, or side-channel resistance for cryptographic implementations.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation and tensor operations but not cryptographic processing. The specification specifically addresses maintaining constant-time properties during cryptographic operations, which does not apply here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation via `context->allocate_output()` and tracks tensor sizes/shapes. While not a general memory allocator, it does involve size tracking for tensor outputs. However, the specification is more about low-level memory allocators rather than tensor framework allocation.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "The code manages tensor resources and maintains consistency invariants through multiple validation checks (OP_REQUIRES). It ensures shape compatibility, validates dimensions, and maintains consistency between input and output tensors, which aligns with the principle of maintaining invariant consistency in resource management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code processes tensor data structures, not external string data. While it validates tensor shapes and dimensions, these are internal data structures with known formats, not null-terminated strings from external sources that require termination validation.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "The code reshapes sparse tensors but does not parse file formats or handle chunk boundaries. It operates on in-memory tensor representations with defined structures, not file format parsing that requires boundary enforcement.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs multiple image/tensor dimension calculations including product computations (`product *= size`), division operations (`dense_size / product`), and multiplication checks (`product * missing == dense_size`). These operations on user-controlled shape values require overflow protection to prevent security vulnerabilities, though the current code doesn't explicitly implement overflow checks.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      }
    ]
  },
  "CVE-2021-37666_after_exclude_100:4314d287:spec": {
    "timestamp": "2026-01-17T00:48:38.083446",
    "cve_id": "CVE-2021-37666",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4314d287",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation and data structure transformation (ragged tensor unbatching). It does not involve any cryptographic operations on secret values. The specification is about constant-time execution for cryptography, which is completely unrelated to this numerical computing code.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or any cryptographic operations. It's focused on tensor processing within a machine learning framework (likely TensorFlow). The specification about side-channel resistance for elliptic curves is irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "While the code involves memory operations (tensor allocation and manipulation), it is not performing cryptographic processing. The specification specifically addresses secure memory operations during cryptographic processing, which doesn't apply here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement view-based data access or perform privilege checks. It's processing tensor data structures without any security context or privilege model. The specification is about database/view security semantics.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "There are no security-critical state transitions or privilege contexts in this code. It's purely a computational function for transforming tensor representations without any security state management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code has no SQL protocol implementations or database access. It's processing ragged tensors in a numerical computing context, completely unrelated to SQL or database security semantics.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code performs dimension calculations (output_size = unbatched_ragged_input.size()) and tensor shape operations. While not specifically about image dimensions, the principle of careful dimension calculation applies. However, there's no explicit overflow protection visible in the arithmetic operations shown.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code validates numeric inputs (ragged_nested_splits_len > 0 check) and performs bounds checking. It validates the split argument (num_components >= 0) and handles tensor inputs. While not specifically about file format parsers, the principle of validating all numeric inputs before processing directly applies to this tensor processing code.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: File format parsers must validate all numeric inputs before processing"
      }
    ]
  },
  "CVE-2017-14151_before_exclude_100:0714d6ff:spec": {
    "timestamp": "2026-01-17T00:48:39.614293",
    "cve_id": "CVE-2017-14151",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0714d6ff",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code performs tensor manipulation and data structure transformation (ragged tensor unbatching). It does not involve any cryptographic operations on secret values. The specification is about cryptographic constant-time execution, which is irrelevant to this numerical computation code.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or any cryptographic operations. It's purely tensor processing code for machine learning operations.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 2,
        "reasoning": "While the code involves memory operations (tensor allocation and manipulation), it's not performing cryptographic processing. The specification specifically addresses cryptographic memory operations requiring constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement view-based data access or privilege checks. It's processing tensor data structures without any security context or access control mechanisms.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "No security-critical state transitions or privilege contexts are involved in this tensor manipulation code. It's purely data transformation without security state management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code has no SQL protocol implementations or database access. It's tensor processing code for machine learning frameworks.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code performs dimension calculations (num_components = batched_splits_top_vec.size() - 1) and array indexing operations that could be vulnerable to overflow or underflow. The specification about overflow-protected arithmetic directly applies to this type of numerical computation in tensor dimension handling.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code processes numeric inputs from tensors (ragged_nested_splits_in, batched_splits_top_vec) and performs calculations on them. While not strictly a file format parser, it's parsing and validating tensor data structures which should follow similar principles of validating numeric inputs before processing to prevent issues like out-of-bounds access or invalid calculations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: File format parsers must validate all numeric inputs before processing"
      }
    ]
  },
  "CVE-2021-37683_before_exclude_100:ede52c55:spec": {
    "timestamp": "2026-01-17T00:49:12.805980",
    "cve_id": "CVE-2021-37683",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ede52c55",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor division operations in a machine learning inference context. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code handles tensor data types (float32, int32, uint8) and performs arithmetic operations. It does not involve pattern compilers or processing of escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the code processes tensor data which could be considered input, it uses TensorFlow Lite's safe access functions (GetInputSafe, GetOutputSafe) which provide bounds checking. However, the specification focuses on string processing functions specifically, which this code does not use.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code performs tensor operations but does not explicitly handle memory allocation or size tracking. Memory management would be handled by the TensorFlow Lite framework at a lower level.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 4,
        "reasoning": "The code manages tensor resources and ensures type consistency through validation checks. It maintains invariant consistency by validating tensor types before processing, though this is more about type safety than general resource management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor arithmetic operations without any view-based data access, privilege checks, or security context management.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code performs mathematical operations on tensors and does not involve security-critical state transitions or privilege context management.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code implements tensor division for machine learning inference and has no relation to SQL protocols, view security semantics, or database access.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      }
    ]
  },
  "CVE-2018-20544_after_exclude_100:6aa5b49c:spec": {
    "timestamp": "2026-01-17T00:49:32.447771",
    "cve_id": "CVE-2018-20544",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6aa5b49c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing. It is a tensor division operation in a machine learning inference engine. There is no processing of input patterns containing NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or the processing of escape sequences. It performs arithmetic operations on tensor data.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation. It accesses pre-allocated tensor buffers. The size tracking for the loop is derived from the tensor's byte size, which is consistent, but this is not the core focus of the specification regarding allocation operations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "The code manages the resource of tensor data and ensures a critical invariant: the divisor (input2) must be non-zero for integer and quantized types. The `TF_LITE_ENSURE` check maintains this consistency, preventing division by zero errors. This aligns with the principle of maintaining invariant consistency for a resource (the divisor data).",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve view-based data access, privilege checks, or different user/owner contexts. It operates within a single execution context on tensor data.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve security-critical state transitions or privilege contexts. It performs a mathematical computation.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve SQL protocols, view security, or database access semantics.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      }
    ]
  },
  "CVE-2022-2923_before_exclude_100:3cdb12a7:spec": {
    "timestamp": "2026-01-17T00:49:53.040494",
    "cve_id": "CVE-2022-2923",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3cdb12a7",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It processes a byte array representing a trie structure for spell checking. While it does check for NUL bytes (c == 0) as part of the tree traversal, this is not related to parsing regex patterns with embedded NULs.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It is building a soundfolded trie from an existing case-folded tree. The specification about pattern compilers and escape sequences is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes byte arrays (sl_fbyts, sl_fidxs) from a slang_T structure. While these are likely internal data, the principle of using length-aware operations is relevant. The code checks `n + 1 < slang->sl_fbyts_len` before accessing `byts[n + 1]`, demonstrating some length awareness. However, it does not consistently check `arridx[depth]` or `n` against array bounds before using them to index `byts` and `idxs`.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code processes character data from the `sl_fbyts` array. It includes one explicit boundary check (`n + 1 < slang->sl_fbyts_len`), but lacks comprehensive validation before all array accesses (e.g., `byts[arridx[depth]]`, `idxs[n]`). The principle of validating buffer boundaries before access is moderately relevant but not fully implemented.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "The code maintains state via arrays (`arridx`, `curi`, `wordcount`) and a `depth` variable while traversing a tree structure. The principle of maintaining consistent buffer state invariants is relevant to this iterative, stateful parsing algorithm. However, the specification is framed around \"parser input operations,\" which is a partial fit for this tree traversal logic.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "The code performs processing on a byte array which could involve character data. The specification about \"encoding-specific processing\" is only weakly relevant, as the code's primary function is trie traversal and soundfolding, not direct encoding transformation. The single boundary check present is a form of uniform checking, but it's not the focus.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code performs numerous array accesses on `byts` and `idxs` using indices (`arridx[depth]`, `n`) derived from traversal logic. It validates one specific bound (`sl_fbyts_len`) in a loop condition, but lacks general pre-validation for other indices (e.g., ensuring `arridx[depth]` and `n` are within the allocated sizes of `byts` and `idxs`). The core secure coding principle of bounds checking before dereferencing directly applies.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code traverses a pre-compiled tree structure, so it assumes the input data (`sl_fbyts`, `sl_fidxs`) has a valid structure. It does not appear to enforce structural constraints (like valid tree links) before processing content. The principle is relevant in a general sense for any parser, but the code's trust in its internal data structures makes the relevance weaker.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2021-4192_before_exclude_100:5166a6db:spec": {
    "timestamp": "2026-01-17T00:50:21.755351",
    "cve_id": "CVE-2021-4192",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5166a6db",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a visual selection matching function, not a regular expression parser. It does not parse or handle input patterns containing embedded NUL bytes. Its primary operations involve comparing line numbers and column positions within a buffer.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns containing escape sequences. It performs geometric comparisons for visual block and character-wise selection modes within an editor buffer.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the function processes string data (`rex.line`, `rex.input`), it is operating on internal editor buffer lines, not directly on untrusted external input. The relevance to length-aware operations for untrusted input is weak, as the context is internal state validation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs several bounds checks (e.g., `lnum < top.lnum || lnum > bot.lnum`, column comparisons in 'v' and Ctrl_V modes) to ensure positions are within a valid visual range before proceeding. This aligns with the principle of validating bounds before access, though the \"buffer\" here is a logical selection range, not a memory buffer.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The function validates structural constraints (e.g., active visual mode, line number within range) before performing detailed column position processing. This is a form of input validation, but the \"input\" is internal editor state, not parsed data from an external source.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to XML protocol implementation or parsing. It is a function for determining if a regex match falls within a visual selection in a text editor.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "The code does not parse any file format or validate header fields. It works with editor buffers and visual selection state.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The code uses array-like indexing (line numbers, column positions) and performs explicit validation (`lnum` between `top.lnum` and `bot.lnum`, column checks). This is conceptually similar to bounds validation against a logical \"allocated size\" (the visual selection range). The relevance is moderate as it's about logical bounds, not memory arrays.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      }
    ]
  },
  "CVE-2022-2923_after_exclude_100:ba985900:spec": {
    "timestamp": "2026-01-17T00:50:34.410476",
    "cve_id": "CVE-2022-2923",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ba985900",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It processes a trie structure for spell checking and sound folding. While it does handle NUL bytes as word terminators within the byte array, this is a controlled, internal data structure (slang->sl_fbyts) and not user-provided regular expression patterns. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It traverses a pre-built byte/idx array representing a case-folded word tree. The specification about pattern compilers and escape sequences has very low relevance to this scenario.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code processes the `sl_fbyts` array, which is potentially complex data. It uses explicit length checks (`slang->sl_fbyts_len`) in a loop to avoid reading out of bounds when skipping consecutive NUL bytes. This demonstrates length-aware operations, giving it strong relevance. However, the input is not clearly marked as \"untrusted,\" slightly reducing the score.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "The code validates buffer boundaries before access. The check `n + 1 < slang->sl_fbyts_len` before accessing `byts[n + 1]` is a direct example of boundary validation. This is a core part of the function's safety. The relevance is moderate to strong, though the data is more about character sequences than multi-byte character encoding.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 6,
        "reasoning": "The code maintains state via arrays like `arridx`, `curi`, and `wordcount` while iterating through the trie. It carefully updates indices and depths to ensure consistent traversal. This relates to maintaining \"consistent buffer state invariants\" during a parsing operation, showing moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 5,
        "reasoning": "The function processes a specific structure (trie) with its own encoding (bytes and indices). The boundary check (`sl_fbyts_len`) is uniform for the main array access. However, the specification emphasizes \"encoding-specific processing\" (like UTF-8), which is not the primary focus here. The connection is weak to moderate.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 8,
        "reasoning": "This is highly relevant. The code performs explicit bounds checking before dereferencing array elements. The primary example is `while (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)`. This prevents reading past the end of the `byts` array, which is a direct application of the specification's principle.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code assumes the input trie structure (`sl_fbyts`, `sl_fidxs`) is well-formed. It validates that the pointers are not NULL at the start but does not appear to perform deep structural validation (e.g., that indices point within valid ranges) before the main content processing loop. The relevance is weak to moderate.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2021-4192_after_exclude_100:30952c97:spec": {
    "timestamp": "2026-01-17T00:50:47.188530",
    "cve_id": "CVE-2021-4192",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "30952c97",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a visual selection matching function, not a regular expression parser. It does not process input patterns containing embedded NUL bytes. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile or process patterns with escape sequences. It operates on buffer positions and visual selection coordinates. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "There is weak relevance. The function accesses `rex.line` and uses pointer arithmetic (`rex.input = rex.line + col`). While it's not directly processing untrusted input strings, it does perform string/line operations where length awareness could be a concern, but this is not the primary focus of the code.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs several bounds checks (e.g., `if (lnum < top.lnum || lnum > bot.lnum)` and column comparisons). It validates positions before using them to index into lines, which aligns with the principle of validating bounds before dereferencing, though the primary data structures are positions within a buffer rather than traditional arrays.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function validates structural constraints (line numbers, column positions) of a visual selection before determining if a match occurs. This is a form of input validation, but the \"input\" is an internal editor state, not parsed external data.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code has nothing to do with XML protocol implementation or parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is not a file format parser and does not process header fields.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses column numbers (`col`) as indices into the string `rex.line`. It performs checks like `col < top.col` and `col >= bot.col` which are forms of bounds validation. The variable `col` is derived from pointer arithmetic (`rex.input - rex.line`), and its use in indexing (`rex.line + col`) should be safe if the earlier position calculations are correct. However, explicit validation against the allocated size of `rex.line` is not present.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      }
    ]
  },
  "CVE-2022-0392_before_exclude_100:85b55fe3:spec": {
    "timestamp": "2026-01-17T00:52:09.104383",
    "cve_id": "CVE-2022-0392",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "85b55fe3",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code processes bracketed paste input, not regular expressions. While it does handle NUL bytes as part of the input stream (checking for NUL to break loops), this is not the core focus of the specification, leading to weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code processes a paste stream and looks for a terminal escape sequence (\"PE\"), but it's not compiling patterns or processing escape sequences in the way a compiler or regex engine would. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The specification is highly relevant. The function processes potentially untrusted paste input into buffers (`buf`). It uses length-aware operations: it tracks `idx` against `NUMBUFLEN`, uses `STRNCMP` with `idx` for comparison, and passes `idx` to downstream functions like `put_on_cmdline` and `ins_char_bytes`. This is a core security practice in the code.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about initializing memory allocations before use. The code uses a stack buffer `buf` and the `gap` dynamic array. While `buf` is not explicitly initialized to zero, it is written to in a controlled manner using `idx`. The `ga_grow` function may involve allocation, but its initialization is not shown here. Relevance is very low as memory initialization is not a primary concern or visible pattern in this snippet.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The specification has moderate relevance. The function modifies global state (`no_mapping`, `allow_keys`, `p_paste`) and has multiple exit paths (break conditions, early returns). It does restore `allow_keys` and conditionally restores `p_paste` on all exit paths, showing some consistency. However, the error handling for `ga_grow` or `stop_arrow` failures is not robust (state changes may still occur). The principle applies but is partially implemented.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-0392_after_exclude_100:359324be:spec": {
    "timestamp": "2026-01-17T00:52:09.336175",
    "cve_id": "CVE-2022-0392",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "359324be",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code processes bracketed paste input, which is not a regex parser. While it does handle NUL bytes as part of the input stream (e.g., checking for NUL to break loops), this is not the core functionality described by the spec. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code is a paste handler that reads raw input characters and looks for a terminal end sequence (\"PE\"). It does not compile patterns or process escape sequences in the sense meant by the spec. The connection is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The specification is highly relevant. The function processes input from an external source (terminal paste) into a fixed-size buffer `buf`. It uses length-aware operations: it tracks an `idx` to prevent overflow (buffer size is NUMBUFLEN + MB_MAXBYTES), uses `STRNCMP` for comparison, and passes `idx` to functions like `put_on_cmdline` and `ins_char_bytes`. This directly aligns with the principle of using length-aware operations for potentially untrusted input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The specification is about initializing memory allocations before use. The code uses a stack buffer `buf` and local variables. While `buf` contents are built incrementally and null-terminated, there is no dynamic memory allocation (like `malloc`) within this function that needs initialization. The `gap` parameter involves external memory management. The spec's core concern does not directly apply here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The specification has moderate relevance. The function modifies global/state variables (`no_mapping`, `allow_keys`, `p_paste`) and restores them before returning, even on early breaks (e.g., due to `got_int` or `Ctrl_C`). This maintains consistent state across error/early exit paths. However, the spec's focus on \"object states\" is broader than the simple state restoration shown here.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2008-4618_before_exclude_100:57747098:spec": {
    "timestamp": "2026-01-17T00:52:17.382853",
    "cve_id": "CVE-2008-4618",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "57747098",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve any dynamic memory allocation. It uses a static string constant, which is fully initialized at compile time.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function is an error handling path (for invalid parameter length). It calls another function to abort the connection, which should maintain a consistent protocol state. However, the code itself is very simple and just passes the error along.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function is a network protocol handler (SCTP) that is specifically triggered by a validation failure (invalid parameter length). It is part of the input validation framework.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 10,
        "reasoning": "Directly relevant. The function's name and purpose are to handle violations of \"parameter length\". It enforces RFC-specified length constraints by aborting the connection when they are violated.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 10,
        "reasoning": "Directly relevant. SCTP uses TLV (Type-Length-Value) parameters extensively. This function is the consequence of failed bounds checking during TLV processing, leading to an abort.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 9,
        "reasoning": "Strongly relevant. The function is invoked when a protocol parser (SCTP) finds that a parameter does not meet the minimum structural requirement of having a valid length. It is a key part of the validation process.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate minimum structural requirements before processing"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code is for the SCTP protocol, not DNS. While the principle of field boundary validation is similar, the specification is explicitly about DNS record processing.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: DNS record processing must enforce strict field boundary validation"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The core issue being handled is a bounds violation (invalid parameter length). This function is the security consequence triggered when bounds checking fails, preventing access to out-of-bounds memory.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Memory operations must verify bounds against actual available data"
      }
    ]
  },
  "CVE-2019-15166_after_exclude_100:0ec448a3:spec": {
    "timestamp": "2026-01-17T00:52:36.386656",
    "cve_id": "CVE-2019-15166",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0ec448a3",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve any dynamic memory allocation. It only declares a static constant string and calls a function. Therefore, HS-MEM-001 about initializing memory allocations is not relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function is part of an error handling path (violation handler) and calls another function to abort the violation. It could be relevant to maintaining a consistent association state during error handling, but the code shown is too high-level to evaluate the actual state management. Weak relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function `sctp_sf_violation_chunklen` is a network protocol handler for SCTP that is specifically triggered when a chunk has an invalid length. This directly aligns with the specification's requirement to validate input before processing.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 10,
        "reasoning": "Directly and highly relevant. The function's name and purpose are to handle violations of \"chunk length.\" This is a core part of enforcing RFC-specified length constraints for SCTP protocol message fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 10,
        "reasoning": "Directly and highly relevant. SCTP chunks are a form of Type-Length-Value (TLV). This function is invoked when bounds checking (specifically for length) has failed, indicating that the TLV processing logic must include such checks.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "Strongly relevant. Validating chunk length is a fundamental structural requirement for SCTP protocol parsing. This function is the error handler for when that minimum structural validation fails.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate minimum structural requirements before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is specifically about DNS record processing, while the target code is for the SCTP protocol. The general principle of field boundary validation is relevant (see spec 5), but this specific specification does not apply.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: DNS record processing must enforce strict field boundary validation"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The violation being handled is fundamentally a failure of bounds checking (invalid chunk length). Before accessing chunk data, the protocol must verify bounds against the actual available packet data, which this error path indicates was not done correctly.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Memory operations must verify bounds against actual available data"
      }
    ]
  },
  "CVE-2022-27007_before_exclude_100:e2b27a57:spec": {
    "timestamp": "2026-01-17T00:52:37.741181",
    "cve_id": "CVE-2022-27007",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e2b27a57",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It is a function frame management routine for a VM, dealing with stack frames and value copying.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or any form of text/pattern compilation. It manipulates VM internal data structures.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code copies memory (values) in loops, it uses pointer arithmetic with calculated bounds (`start < end`). It is not directly processing untrusted strings, but the principle of bounded operations is somewhat relevant for safe memory copying within the frame. However, the context is internal VM state, not external input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse or validate protocol messages or their length fields. It operates on internal VM structures whose sizes are derived from the VM's own state.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs critical pointer arithmetic based on calculated counts (`value_count`, `function->u.lambda->temp`, etc.). While not calling an allocator directly, it computes offsets into a memory region. If these counts were malformed or corrupted, it could lead to pointer miscalculation and out-of-bounds memory access. The principle of validating size/offset parameters against the available buffer is moderately relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a network or data protocol. It manages internal VM types (njs_value_t), but the specification refers to protocol type handling across stages, which is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes a new stack frame (`*frame = *vm->active_frame`) and then explicitly copies values into it. It also has a check `if (!njs_is_valid(p)) { njs_set_undefined(p); }` to ensure arguments are initialized (to undefined) if not valid. This aligns closely with the principle of ensuring memory/objects are fully initialized before use to avoid operating on uninitialized data.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function appears to always return `NJS_OK`. There is no visible error handling path within this snippet. However, the function is responsible for setting up a complex frame state. If an error occurred earlier (e.g., in parameter calculation not shown), or if this function were to fail, the consistency of the VM's `active_frame` and the new `frame` state could be compromised. The general principle of maintaining consistent state is moderately relevant for functions that manipulate core VM state.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2017-14151_after_exclude_100:980ab81e:spec": {
    "timestamp": "2026-01-17T00:53:42.571757",
    "cve_id": "CVE-2017-14151",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "980ab81e",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a function frame save routine in a VM, dealing with stack frame manipulation and value copying. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code handles internal VM frame structures, not pattern compilation, escape sequences, or protocol/pattern processing. The specification is about pattern compilers, which is unrelated.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code copies values (njs_value_t) in loops, it uses pointer arithmetic with calculated counts (value_count, function->args_count). It is not directly processing untrusted strings with length-aware operations, but the principle of bounded copying based on calculated sizes is present, though in a very specific internal context.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code does not parse protocol messages or validate length fields. It operates on internal VM structures where sizes are derived from internal function metadata (active frame, function object).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs pointer arithmetic to allocate space within a frame (using `new` and `value` pointers). It calculates sizes based on `value_count` and `function->u.lambda->temp`. There is an implicit need to ensure these calculations do not overflow and that the allocated frame space is sufficient. This relates to validating size parameters for memory layout, though not for explicit allocation functions like malloc.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code ensures values moved into the new frame are valid (checking `njs_is_valid(p)` and setting to undefined otherwise). This maintains consistent type/value states within the VM, which loosely aligns with consistent type handling, but it's for internal VM state management, not a network protocol.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes the new `native` frame structure fields (size, free, free_size) and copies values from the old frame to the new one. It also conditionally initializes arguments to undefined if not valid. This demonstrates initialization of memory (the frame) before use, which is the core principle of the specification.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function returns a status code (NJS_OK). If an error occurred earlier (not shown in this snippet), the function might need to ensure the frame state is not partially corrupted. The code itself is a sequence of assignments and copies; an error mid-way could leave the new frame in an inconsistent state. The relevance is moderate as error handling paths are not visible here, but the operation is stateful.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2015-1345_before_exclude_100:d38f01a1:spec": {
    "timestamp": "2026-01-17T00:54:07.850011",
    "cve_id": "CVE-2015-1345",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d38f01a1",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a string search function (Boyer-Moore variant) for a keyword set, not a regular expression parser. While it processes input text (`text`, `size`), the specification about handling embedded NUL bytes in patterns is not directly applicable. The function uses length-aware operations (`size` parameter), but the core concern of the specification (regex pattern parsing with NULs) is irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequence processing. The target code is a runtime search execution function (`bmexec_trans`), not a pattern compiler. It operates on a pre-compiled keyword set (`kwset_t`). Therefore, the specification's principles about compilation-stage boundary checking do not apply.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function is a string processing function that takes a size parameter (`size`) for the input text (`text`). It uses this size for bounds checking (e.g., `if (len > size)`, `ep = text + size`, loops conditioned on `tp <= ep`). It carefully avoids out-of-bounds pointers, as noted in the comment. This directly aligns with using length-aware operations for potentially untrusted input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about validating protocol message length fields. The target code does not parse any protocol messages or length fields. It receives a buffer and its size directly. While it validates `len` against `size`, this is a simple input validation, not related to platform-specific integer limits or protocol semantics.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "The specification concerns memory allocation operations. The target function `bmexec_trans` performs no memory allocation. It only reads from pre-allocated structures (`kwset`, `text`). Therefore, the specification does not apply.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about protocol implementations and consistent type handling across stages. The code is a low-level string search algorithm, not a protocol implementation. It deals with character types and pointers, but not in the context of a multi-stage protocol processing pipeline where type consistency is a high-level concern.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The core principle of validating boundaries before access is present in the code (e.g., checking `len > size`, calculating `ep` as the boundary, and using it in loop conditions). However, the specification is framed for \"protocol parsers\" and \"packet data,\" which is not the context of this string search function. The guidance value is indirect.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate field boundaries before accessing any packet data"
      },
      {
        "score": 5,
        "reasoning": "The specification is for network protocol implementations requiring message boundary awareness. The target code operates on a contiguous buffer (`text`) of a given `size`. It is not parsing discrete network messages within a stream, so the concept of \"message boundary awareness\" during parsing is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must maintain strict message boundary awareness du..."
      }
    ]
  },
  "CVE-2015-1345_after_exclude_100:1bab76cc:spec": {
    "timestamp": "2026-01-17T00:54:20.140784",
    "cve_id": "CVE-2015-1345",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1bab76cc",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a string search function (Boyer-Moore variant) for a keyword set, not a regular expression parser. It processes raw text input (`text`, `size`) but does not interpret it as a pattern containing special syntax like embedded NUL bytes. The relevance is weak because the specification is about pattern parsing, while this code searches for fixed patterns within data.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequence processing. The target function is a runtime search execution engine, not a compiler. It operates on pre-compiled keyword sets (`kwset_t`). There is no processing of escape sequences here, leading to very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The specification is about validating protocol message length fields. This code is a string search algorithm, not a network protocol parser. It receives a `size` parameter but does not treat it as a \"field\" from a message; it's a basic input boundary. The connection is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about memory allocation validation. This function does not perform any memory allocation operations (`malloc`, `calloc`, `realloc`). It only performs searches on already allocated memory. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate field boundaries before accessing any packet data"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must maintain strict message boundary awareness du..."
      }
    ]
  },
  "CVE-2022-3235_before_exclude_100:698b769b:spec": {
    "timestamp": "2026-01-17T00:54:42.924541",
    "cve_id": "CVE-2022-3235",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "698b769b",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes command line input which may include search patterns (for '/' and '?' commands). While it doesn't directly implement a regex parser, it handles user input that could contain embedded NUL bytes. The code uses length-aware operations (ccline.cmdlen) and stores input in a buffer, making it moderately relevant to handling embedded NULs in patterns.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code processes escape sequences (e.g., Ctrl-V for literal input, backslash handling in exmode), but it's not primarily a pattern compiler. It maintains some boundaries when processing these sequences, but the specification is more focused on formal pattern compilers, making the relevance weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively uses length-aware operations with ccline.cmdlen and ccline.cmdpos to track command line buffer state. It processes potentially untrusted user input and maintains buffer boundaries through careful position tracking and bounds checking.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code initializes structures (CLEAR_FIELD, ExpandInit) and has some memory allocation paths. However, the main focus is command line processing rather than memory allocation patterns. Some initialization is present but not the primary concern.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code has multiple error handling paths (goto theend, cleanup routines) and maintains consistent state through save/restore mechanisms (save_cmdline/restore_cmdline). It carefully manages state transitions and cleanup in error conditions.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This is command line input processing, not network protocol handling. The code validates user keyboard input but doesn't deal with network protocols at all.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code handles multi-byte character encoding (has_mbyte checks) and validates buffer boundaries before access using cmdpos/cmdlen. It includes character size calculations and boundary checks when moving cursor positions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code maintains strict buffer state invariants through ccline structure (cmdbuff, cmdlen, cmdpos). It consistently validates positions before buffer access and maintains synchronization between byte positions and display positions.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-3235_after_exclude_100:f9181bd3:spec": {
    "timestamp": "2026-01-17T00:54:53.023242",
    "cve_id": "CVE-2022-3235",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f9181bd3",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code handles command line input which could include search patterns (for '/' and '?' commands). While it doesn't directly implement a regex parser, it processes user input that may later be used in pattern matching. The code uses length-aware operations (ccline.cmdlen) and handles NUL bytes via character processing, but the relevance is indirect as this is the input collection layer, not the regex parser itself.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code processes escape sequences (like Ctrl-V for literal input and ESC handling) and maintains some boundaries through cmdpos/cmdlen tracking. However, this is for command line editing, not specifically for pattern compilation. The escape sequence handling is more about editing commands than pattern escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code extensively uses length-aware string operations through ccline.cmdlen and cmdpos variables. It processes potentially untrusted user input in the command line, carefully tracking buffer boundaries when inserting, deleting, and moving characters. The put_on_cmdline function (called indirectly) would need to respect these boundaries.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "The code initializes the ccline structure using CLEAR_FIELD() when clear_ccline is true, and initializes various state variables. However, not all allocations may be fully initialized (like lookfor pointer initially NULL). Memory management appears careful but not perfectly aligned with the specification's emphasis.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code maintains consistent state through extensive error handling with goto statements (theend, returncmd). It saves and restores state (save_ccline, save_State), cleans up resources (ExpandCleanup), and ensures proper state transitions even when errors occur or when escaping command mode.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "This is a local command line input handler, not a network protocol handler. The code processes keyboard and mouse input locally, with no network protocol processing involved. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively validates buffer boundaries before access using ccline.cmdpos and ccline.cmdlen. It handles multi-byte characters with mb_ptr2len and mb_head_off, carefully tracking character boundaries. The cursor movement and editing operations all respect these boundaries to prevent buffer overflows.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code maintains strict buffer state invariants through ccline.cmdbuff, cmdlen, and cmdpos. All parser input operations (character insertion, deletion, cursor movement) consistently update these variables together. The code ensures cmdpos never exceeds cmdlen, and the buffer is always properly null-terminated.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-0351_before_exclude_100:fff3c14e:spec": {
    "timestamp": "2026-01-17T00:55:17.557025",
    "cve_id": "CVE-2022-0351",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fff3c14e",
    "scores": [
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code processes input strings (e.g., string literals, variable names) but is not a regular expression parser. However, it must handle NUL bytes correctly when evaluating string constants and variable names to avoid misinterpretation of input boundaries.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code evaluates expressions but does not compile patterns or process escape sequences in a way that requires strict boundary maintenance like a pattern compiler would. String literal evaluation may involve escapes, but it's not the primary focus.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code extensively processes strings from untrusted input (e.g., eval_string, eval_lit_string, variable names). It uses length-aware operations like get_name_len and STRNCMP, and must ensure bounds are respected when handling input buffers.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code initializes rettv->v_type to VAR_UNKNOWN before use, and clear_tv is called on error paths. However, not all allocated memory (e.g., get_reg_contents) may be fully initialized, and the focus is more on type initialization than memory filling.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code has multiple error handling paths (e.g., after semsg/emsg calls) that call clear_tv(rettv) to maintain consistent state. It also resets rettv->v_type on failure returns, ensuring object states are cleaned up.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is an expression evaluator, not a network protocol handler. It validates syntax but does not process network input or protocol messages.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not process protocol message length fields. It handles expression parsing with length checks (e.g., get_name_len), but not in a network protocol context with integer limit validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not perform explicit memory allocations in this function (except via vim_free for alias). Memory allocations happen in called functions (e.g., get_reg_contents, eval_string), but size parameter validation is not visible here.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-0351_after_exclude_100:faf60c84:spec": {
    "timestamp": "2026-01-17T00:55:50.906025",
    "cve_id": "CVE-2022-0351",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "faf60c84",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code processes input strings (e.g., string literals, variable names) but is not specifically a regular expression parser. However, it does handle input patterns for evaluation and could be affected by embedded NUL bytes in string parsing paths (e.g., eval_string, eval_lit_string). Relevance is moderate because the principle of handling embedded NULs applies to string processing in general, but the code is not primarily a regex engine.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not appear to be a pattern compiler processing escape sequences. It evaluates expressions, including string literals, but escape sequence handling would be in helper functions like eval_string, not directly visible here. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes rettv->v_type to VAR_UNKNOWN before use, showing awareness of initialization. Memory allocations (e.g., for strings) likely occur in called functions. Moderate relevance as initialization is present, but full memory allocation patterns are not fully visible.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (e.g., after semsg/emsg calls) that clear or maintain consistent state (e.g., clear_tv(rettv) on failure). It ensures rettv is properly managed across returns. Strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is an expression evaluator, not a network protocol handler. No network input validation is present. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No network protocol message length fields are processed here. The code deals with expression parsing, not protocol handling. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Memory allocations are not directly visible, but length parameters (e.g., len from get_name_len) are used and could influence allocations in downstream functions. The code validates recursion depth to prevent stack overflow, showing awareness of limits. Moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2016-3136_before_exclude_100:aeef0137:spec": {
    "timestamp": "2026-01-17T00:55:55.455946",
    "cve_id": "CVE-2016-3136",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "aeef0137",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a USB device disconnect handler, not a protocol message parser. It does not process any protocol messages with length fields, making this specification about integer limit validation for protocol messages irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function frees resources (URBs, hardware structures) but does not perform any memory allocation. The specification about validating size parameters during allocation is not applicable to this cleanup code path.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles USB device disconnection and resource cleanup, not protocol processing. There are no protocol types or processing stages involved in this function.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This is a kernel driver disconnect callback, not a function processing userspace input. No array lengths from userspace are being validated or processed in this code.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The function performs USB device cleanup operations, not protocol message handling. There are no variable-length protocol components being processed or verified.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "While the function deals with USB resources, it is freeing them rather than allocating buffers for input processing. The specification about buffer allocation for worst-case input scenarios doesn't apply to this cleanup routine.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant as the code is part of a USB device driver disconnect handler. While it doesn't explicitly validate endpoints, it properly cleans up USB resources (URBs) and manages the USB device lifecycle, which is a core concern for USB driver security and stability.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: USB device drivers must validate all required endpoints before operation"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function is part of device driver lifecycle management (disconnection phase). While not performing configuration verification itself, proper cleanup during disconnection is important for system stability and security, preventing resource leaks or use-after-free issues.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-002: Device configuration must be fully verified before driver initialization"
      }
    ]
  },
  "CVE-2016-3136_after_exclude_100:65256516:spec": {
    "timestamp": "2026-01-17T00:56:27.945727",
    "cve_id": "CVE-2016-3136",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "65256516",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a USB device disconnect handler, not a protocol message parser. It does not process any protocol messages with length fields, making this specification about integer limit validation for protocol messages irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The function performs cleanup (freeing memory/URBs) but does not contain any memory allocation operations. It is deallocating resources, not allocating them, so validation of size parameters for allocation is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "The code handles device teardown, not protocol processing. There are no protocol stages or type handling operations present in this disconnect routine.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "This is a kernel driver disconnect callback, not a function processing userspace input. No array lengths from userspace are being validated or processed here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "The function does not handle protocol messages or their variable-length components. It's a cleanup routine for USB device disconnection.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 3,
        "reasoning": "While the function deals with USB buffers (URBs), it is freeing them, not allocating buffers based on input. The allocation would have occurred elsewhere during device initialization/operation.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "This specification is highly relevant as the code is part of a USB device driver. Although this specific function handles disconnection, proper USB driver operation requires endpoint validation during initialization (which would have occurred before this disconnect is called). The function interacts with USB URBs and anchors, which are tied to validated endpoints.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: USB device drivers must validate all required endpoints before operation"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The function is part of device lifecycle management (teardown phase). While it doesn't perform configuration verification itself, it relies on proper configuration that should have been verified during driver initialization. The cleanup assumes valid device state established during proper initialization.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-002: Device configuration must be fully verified before driver initialization"
      }
    ]
  },
  "CVE-2011-1003_before_exclude_100:7670ee9b:spec": {
    "timestamp": "2026-01-17T00:56:48.662757",
    "cve_id": "CVE-2011-1003",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7670ee9b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses R_NEWS0 which zero-initializes memory, and R_NEW0 which also zero-initializes. However, there are potential paths where memory may not be fully initialized before use, such as when reading into the `file` buffer where only 256 bytes are read but the buffer isn't explicitly initialized beforehand. The zero-initialization functions help, but not all allocations use them.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error handling paths (goto next, early returns) that attempt to free resources. However, there are inconsistencies: in the target_libs initialization block, if deps allocation fails, target_lib_names is freed but target_libs itself is not freed. Also, the goto next label frees depArray and extras which might already be freed earlier in the loop, potentially causing double-free issues.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code processes dyld cache files from local buffers, not network protocols. No network protocol handling is present.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "The code reads binary structures (ut16, ut32, ut64) from buffers using r_buf_fread_at and r_buf_read_at. While these functions likely handle alignment internally, the code doesn't explicitly check or ensure alignment when accessing structure fields that might require specific alignment.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 2,
        "reasoning": "The code parses dyld cache file format structures but doesn't implement a network protocol. Some validation of binary structures occurs (checking magic bytes), but this is file format validation, not protocol message validation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      },
      {
        "score": 5,
        "reasoning": "The code reads binary data from buffers and handles potentially misaligned or malformed data through checks like pa == UT64_MAX and verifying read operations succeed. However, it could be more robust in validating structure fields before use.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Input processing must handle misaligned data safely"
      },
      {
        "score": 5,
        "reasoning": "Error paths attempt to maintain consistent memory state by freeing allocated resources. However, there are issues: 1) The goto next label frees depArray and extras which might be NULL or already freed, 2) Early returns don't always free all allocated resources (target_libs leak in one path), 3) The loop structure with multiple allocation/free points makes consistent state maintenance challenging.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "The code validates input boundaries in several places: checking r_buf_fread_at return value, verifying pa != UT64_MAX before reading, and ensuring buffer reads succeed. However, it reads path strings without explicit length validation (uses fixed 256 buffer), and doesn't fully validate all structure fields from the binary input before using them as offsets or indices.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2022-1244_after_exclude_100:a656ee43:spec": {
    "timestamp": "2026-01-17T00:57:08.424712",
    "cve_id": "CVE-2022-1244",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a656ee43",
    "scores": [
      {
        "score": 8,
        "reasoning": "HS-MEM-001: Memory allocations must be fully initialized before use. The code uses R_NEWS0 which zero-initializes memory, and careful initialization of structures like `RDyldBinImage` is performed. However, there are potential issues: `deps` array is allocated with R_NEWS0 but only used when `target_libs` is set; `depArray` and `extras` are allocated in conditional blocks but freed in a `next:` label that may execute even when they weren't allocated (though they're set to NULL initially). This creates a risk of using uninitialized memory if execution paths aren't perfectly aligned.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "HS-STATE-002: Error handling paths must maintain consistent object states. The code has multiple error handling paths (goto next, early returns) that attempt to free resources. However, there are inconsistencies: in the early return when `target_lib_names` allocation fails, `bins` is freed but `target_libs` (a string from environment) is not freed. The `next:` label frees `depArray` and `extras` even when they might not have been allocated in that iteration, potentially causing double-free issues if pointers weren't reset to NULL.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "HS-IO-003: Network protocol handlers must validate input before processing. This specification is about network protocols, but the code processes dyld cache files from disk, not network data. There's no network protocol handling in this function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "HS-MEM-001: Memory operations must respect platform alignment requirements. The code reads binary structures from buffer with `r_buf_fread_at` and `r_buf_read_at` which should handle alignment properly. However, direct casting of buffer data to structures like `cache_img_t*` via `read_cache_images` could potentially cause alignment issues if the buffer data isn't properly aligned. The code assumes the dyld cache file structures are properly aligned.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 2,
        "reasoning": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing. This is about protocol message validation, but the code parses dyld cache file format, not a network protocol. While similar principles apply (validating file structure), this specification specifically addresses network protocols.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-003: Input processing must handle misaligned data safely. The code reads binary structures from potentially untrusted dyld cache files. It performs some validation (checking magic bytes, bounds checking with `r_buf_read_at`), but there's limited validation of offsets and counts before using them. For example, `hdr->imagesCount` is used without validation to allocate memory and as loop bounds, which could lead to excessive memory allocation or out-of-bounds reads if the file is malformed.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Input processing must handle misaligned data safely"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches. This is highly relevant as the code has complex error handling with multiple allocation points and cleanup paths. Issues include: 1) Early returns don't always free all allocated resources (e.g., `target_libs` environment string), 2) The `next:` label unconditionally frees `depArray` and `extras` which might not have been allocated in that iteration, 3) Multiple allocations in nested conditionals create complex cleanup requirements.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations. The code reads from a buffer with some bounds checking using radare2's buffer API, but there are potential issues: 1) `img[j].pathFileOffset` is used without validation in `r_buf_read_at`, 2) Loop bounds like `hdr->imagesCount` aren't validated against buffer size, 3) `cache->accel->depListOffset` and count are used without apparent validation. The code assumes the dyld cache file is well-formed.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2022-23581_before_exclude_100:daadf916:spec": {
    "timestamp": "2026-01-17T00:57:23.658780",
    "cve_id": "CVE-2022-23581",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "daadf916",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves memory management through TensorVector outputs and manual cleanup via a cleanup lambda that deletes tensor pointers. While it tracks and cleans up allocated memory, it's not a classic allocator with explicit size tracking. The relevance is moderate as the principle of consistent cleanup applies.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 7,
        "reasoning": "The function manages resources (tensor outputs) and ensures invariant consistency by validating node properties, input counts, constant status, and shape compatibility. It maintains program state correctness through systematic checks, showing strong alignment with resource/invariant management principles.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing at all. It deals with tensor shape evaluation and validation in a computational graph context.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It focuses on tensor operations and shape validation.",
        "spec_index": 3,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes tensor data (which could be considered input), it doesn't use string operations or explicitly handle untrusted input in a length-aware manner. The connection is very weak.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor evaluation and shape validation, not cryptographic operations. No secret values are involved.",
        "spec_index": 5,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve elliptic curve implementations or cryptographic operations of any kind.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory cleanup but not in a cryptographic context. No constant-time properties are required or implemented for cryptographic processing.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      }
    ]
  },
  "CVE-2022-23581_after_exclude_100:1847dee9:spec": {
    "timestamp": "2026-01-17T00:57:23.815161",
    "cve_id": "CVE-2022-23581",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1847dee9",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves memory allocation indirectly through TensorVector outputs and tensor operations. While it doesn't directly show explicit allocation functions, the management of tensor outputs and shape data requires careful size tracking. However, the specification focuses on explicit memory allocation operations, making this moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 7,
        "reasoning": "The code performs resource management through TensorVector with cleanup via MakeCleanup, ensuring proper resource release. It also validates tensor properties and shapes to maintain consistency. This aligns with the principle of maintaining invariant consistency in resource management operations.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing at all. It focuses on tensor shape validation and constant folding in a computational graph context, with no pattern matching or regex operations.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It deals with tensor operations, shape validation, and graph optimization, not with pattern compilation or text processing with escape sequences.",
        "spec_index": 3,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes tensor data which could potentially come from untrusted sources, it doesn't use string processing functions. The operations are on tensor buffers with explicit element counts (NumElements()), providing some length awareness, but this is not the primary focus of string processing security.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor shape evaluation and validation, not cryptographic operations. There are no secret values being processed, and timing considerations are irrelevant to this constant folding optimization logic.",
        "spec_index": 5,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic implementations. It's part of a graph optimization pass in a machine learning framework.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform cryptographic processing or require constant-time memory operations. It's focused on tensor shape validation and graph optimization, with no security-sensitive data handling that would require side-channel protection.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      }
    ]
  },
  "CVE-2018-14461_before_exclude_100:a7d01948:spec": {
    "timestamp": "2026-01-17T00:58:17.351705",
    "cve_id": "CVE-2018-14461",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a7d01948",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not use regular expressions. It processes terminal escape sequences and key codes via character-by-character comparison (STRNCMP) and manual parsing. While it handles NUL bytes as part of input strings (e.g., checking for NUL in key_name[0]), this is not related to regular expression pattern parsing. Relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function's core purpose is to parse terminal escape sequences (e.g., CSI sequences starting with ESC '['). It must maintain strict boundaries when interpreting these sequences to avoid misinterpreting data or causing buffer overreads. The code carefully checks lengths (slen, len) and returns -1 for partial sequences, demonstrating boundary awareness.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function processes potentially untrusted input (terminal input) and extensively uses length-aware operations. It compares input using STRNCMP with explicit length bounds, checks `len` against `slen` and `modslen` to avoid overreads, and returns early if input is insufficient. This directly aligns with the specification.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code uses stack-allocated arrays (e.g., `string[MAX_KEY_CODE_LEN + 1]`) and local variables, which are automatically initialized in this context. There are no dynamic memory allocations (malloc/calloc) within this function that would require explicit initialization before use.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function has several error return paths (return -1, return 0, return KEYLEN_REMOVED). While it maintains consistency for its own local state, the specification about \"object states\" is more relevant to larger stateful objects or data structures. The function's error handling is simple and doesn't involve complex object state management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Although this is terminal input handling rather than network protocol, the principles are identical: it processes structured sequences from an external source. The code validates input length before processing (e.g., checking `len >= 3` for GUI CSI sequences, validating digit counts for mouse codes), which is the core requirement of the specification.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function uses `put_string_in_typebuf` to write output, but we cannot see its implementation. However, the function itself constructs `string` with a fixed size `MAX_KEY_CODE_LEN + 1` and tracks `new_slen` to ensure it doesn't exceed bounds before passing to the output function. This demonstrates buffer bounds awareness, though not a classic string formatting operation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses `atoi` on a substring (`modifiers_start`) to convert numbers, but it first validates that the substring exists within the parsed sequence (via length checks). However, it doesn't explicitly validate that the numeric string length won't cause overflow in the conversion. The connection to \"output buffer capacity\" is weak, but the need for strict length validation during numeric parsing is present.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      }
    ]
  },
  "CVE-2018-14461_after_exclude_100:9fddf57c:spec": {
    "timestamp": "2026-01-17T00:58:27.540852",
    "cve_id": "CVE-2018-14461",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9fddf57c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes terminal input sequences but does not appear to use regular expressions. It uses string comparison (STRNCMP) and character-by-character parsing. While it handles NUL-terminated strings (e.g., `tp[len] = NUL;`), this is for internal temporary termination, not parsing embedded NUL bytes in patterns. Relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 7,
        "reasoning": "The code extensively processes escape sequences (e.g., ESC, CSI) from terminal input, checking boundaries and partial sequences. It validates sequence lengths and returns early if incomplete. This aligns with the principle of maintaining strict boundaries when processing escape sequences, though it's not a \"pattern compiler\" per se. Moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "The code consistently uses length-aware operations (e.g., `len`, `slen`, `buflen`) when processing input buffers (`buf` or `typebuf.tb_buf`). It checks lengths before comparisons and accesses (e.g., `if (len < slen)`). This is a core security practice for untrusted input. Strong relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code uses stack-allocated arrays (e.g., `string[MAX_KEY_CODE_LEN + 1]`) and local variables. There are no dynamic memory allocations visible in this function. Initialization of locals is done (e.g., `int slen = 0;`). Very low relevance as the specification targets allocators.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function returns error codes (-1) and early exits, but it primarily processes input without complex object states. Some state (e.g., `mouse_col`, `mouse_row`) is set conditionally. Error paths seem to maintain consistency, but the specification is more about object lifecycle. Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 8,
        "reasoning": "The code validates terminal protocol input (ESC sequences, mouse reports, etc.) before processing. It checks lengths, valid characters, and partial sequences. This is essentially a network/terminal protocol handler. Strong relevance, though the input is from terminal/pty, not network sockets directly.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The function constructs output in `string` array with fixed size `MAX_KEY_CODE_LEN + 1`. It uses `new_slen` to track length and appears to stay within bounds. However, there is no explicit check that `new_slen < sizeof(string)` before writes. Still, the principle of validating buffer bounds is highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code uses `atoi` on a substring (`modifiers_start`) without explicit length validation, though the preceding loop ensures digits/semicolons. It doesn't use format templates like `snprintf`. Numeric conversion is minimal. Weak relevance.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      }
    ]
  },
  "CVE-2022-27448_before_exclude_100:9eefa01e:spec": {
    "timestamp": "2026-01-17T00:58:39.959888",
    "cve_id": "CVE-2022-27448",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9eefa01e",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs memory allocation via `new (thd->mem_root) Item_temptable_rowid(tbl)` and uses `create_tmp_table` which likely involves internal allocations. While there is some initialization (e.g., `bzero` for `group`), the specification about fully initializing memory before use is moderately relevant. The code does not show explicit, comprehensive initialization of all allocated memory regions, but the context suggests standard MySQL internal handling.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error handling paths (e.g., `DBUG_RETURN(1)` after failed allocations or pushes). It must ensure that object states (like `tmp_tables`, `thd->variables.big_tables`) remain consistent when errors occur. The restoration of `save_big_tables` on success is good, but error paths could leave resources or flags in inconsistent states, making this specification strongly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is part of a multi-update table initialization routine in MySQL, dealing with internal query execution structures. It does not handle network protocols or validate external network input directly, so this specification is essentially irrelevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It manipulates SQL query structures and temporary tables, so this specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It focuses on SQL update execution planning, so this specification is irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "The code uses string operations like `strlen(field_name.str)` on `table->alias.c_ptr()`. While the alias is likely internal, it could theoretically be influenced via SQL. However, the code does not prominently process untrusted input strings with length-aware functions, making relevance very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates temporary tables via `create_tmp_table` with parameters like `field_count` and `func_count`. Buffer allocation and padding considerations are handled internally by MySQL. There is weak relevance because the code relies on library functions to account for padding, but no explicit safety margin logic is visible.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform image compression or manage encoder buffers. It is unrelated to image processing, so this specification is irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2022-27448_after_exclude_100:28b1d3f4:spec": {
    "timestamp": "2026-01-17T00:58:55.892405",
    "cve_id": "CVE-2022-27448",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "28b1d3f4",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code contains memory allocation via `new (thd->mem_root) Item_temptable_rowid(tbl)` and uses `create_tmp_table` which likely involves memory allocation. While the allocated `Item_temptable_rowid` is immediately followed by `fix_fields` which may initialize it, the specification about full initialization before use is highly relevant for any memory allocation patterns in the function. The `bzero` call for `group` struct shows explicit initialization awareness.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple early return paths via `DBUG_RETURN(1)` on error conditions (e.g., memory allocation failure, push_back failure, tmp_table creation failure). These error paths must ensure that any partially modified state (like `table->file->extra(HA_EXTRA_IGNORE_DUP_KEY)`, `keep_current_rowid` flags, or `thd->variables.big_tables` temporary modification) is properly cleaned up or reverted to maintain consistent object states. The temporary modification of `thd->variables.big_tables` is restored only on the success path.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve regular expression parsing. It handles SQL UPDATE operations, table joins, and temporary table creation. No pattern matching or regex processing is present.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not contain pattern compilers or processing of escape sequences. It is focused on database query execution internals.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. While the code does process strings (e.g., `field_name.str= tbl->alias.c_ptr()` and `strlen(field_name.str)`), these are internal database object aliases, not directly untrusted user input. The principle of length-aware operations could apply indirectly if alias strings originate from user SQL, but it's not the primary focus of this function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function creates temporary tables via `create_tmp_table` with parameters like `field_count` and `func_count`. Buffer allocation for these temporary structures must account for operational requirements. The `calc_group_buffer(tmp_param, &group)` call suggests buffer size calculations are performed, which should include safety margins. However, the exact padding and safety margin handling is not visible in this snippet.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform image compression operations. It is entirely focused on SQL query processing and temporary table management for multi-table UPDATE operations.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2010-4650_before_exclude_100:78a697ce:spec": {
    "timestamp": "2026-01-17T00:58:57.107939",
    "cve_id": "CVE-2010-4650",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "78a697ce",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code handles ESP (Encapsulating Security Payload) packet output, which involves constructing protocol messages. While it does process length fields (esp->tailen, esp->tfclen, esp->plen), the validation of these fields against RFC-specified constraints (like maximum packet size) is not explicitly shown in this function. The function assumes these values are already validated or safe. Therefore, the principle of validating length constraints is moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code does not process TLV (Type-Length-Value) structures. It handles fixed-format ESP trailer data. Bounds checking is performed implicitly through operations like skb_tailroom and skb_cow_data, but not in the context of TLV parsing. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing at all. It is a network packet processing function for IPSec ESP. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is a low-level networking function. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function processes network packet data (sk_buff) which can be considered untrusted input from the network. It uses length-aware operations (e.g., checking tailen against skb_tailroom, using skb_cow_data with a specified length). However, it doesn't primarily deal with string data. The principle of using length-aware operations for buffer manipulation is moderately to strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The function uses length fields (tailen, tfclen, plen) to calculate buffer sizes and offsets. While it doesn't explicitly show validation against integer overflow or platform limits (like SIZE_MAX), the use of safe operations like skb_cow_data and ALIGN with L1_CACHE_BYTES provides some inherent bounds management. The relevance is moderate.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation operations indirectly through skb_page_frag_refill and skb_cow_data. It validates that there is sufficient space (tailroom) before attempting to use existing buffers, and it handles allocation failure (e.g., the goto cow path). The allocsize is aligned, which relates to usage requirements. The principle of validating size parameters for allocation and usage is strongly relevant to this code's logic for handling sk_buff data expansion.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles a specific protocol (IPSec ESP) and maintains consistency in how it constructs the ESP trailer (esp_output_fill_trailer) and updates sk_buff metadata (len, data_len, truesize). However, the specification about \"consistent type handling across all processing stages\" is broad and more applicable to higher-level protocol state machines or data structure interpretation. The connection here is weak to moderate.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2022-27666_after_exclude_100:21ec494b:spec": {
    "timestamp": "2026-01-17T01:00:04.186293",
    "cve_id": "CVE-2022-27666",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "21ec494b",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code processes ESP (Encapsulating Security Payload) protocol data, which involves length fields (esp->tailen, esp->tfclen, esp->plen). There is some validation of size constraints (e.g., checking if allocsz > ESP_SKB_FRAG_MAXSIZE), but the relevance is moderate because the validation appears to be more about buffer management and performance (cow path) than strict RFC-specified length constraint enforcement for protocol fields. The primary focus is on sk_buff manipulation rather than protocol message parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code does not explicitly process TLV (Type-Length-Value) structures. It handles ESP trailer data which has a structured format, but the bounds checking is done via skb operations (skb_tailroom, skb_cow_data) rather than explicit TLV parsing. The relevance is weak as the specification is about TLV processing, while this code is primarily concerned with buffer allocation and appending trailer data.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing at all. It is a networking function for ESP output processing in the Linux kernel. Therefore, the specification is completely irrelevant.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is a low-level networking function dealing with packet buffers and encryption payloads. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 4,
        "reasoning": "The code does not directly process strings. It manipulates sk_buff data structures and raw memory buffers (e.g., using esp_output_fill_trailer). While there is potential for untrusted input (network packets), the operations are not string-based. The weak connection is that the code must handle variable-length data safely, but not using string functions.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "The code uses several length fields (tailen, allocsz) and performs calculations (ALIGN, addition) that could potentially overflow or exceed limits. There is some validation (allocsz > ESP_SKB_FRAG_MAXSIZE) and use of safe operations like skb_cow_data. The relevance is moderate because the code does handle protocol message length fields (esp->plen, tfclen) and must ensure they are valid for buffer operations, but it's not the primary focus of the function.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The function performs multiple memory allocation validations: it checks if allocsz exceeds ESP_SKB_FRAG_MAXSIZE, validates tailen against skb_tailroom, and uses skb_page_frag_refill with size validation. The cow path uses skb_cow_data which also handles allocation. The code carefully manages memory sizes for both performance and security, making this specification strongly applicable.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles ESP protocol data, but the specification about consistent type handling across all processing stages is only weakly relevant. The function uses various integer types (u8, int, unsigned int) and ensures consistent handling through calculations and casts (e.g., esph_offset calculation). However, the primary concern is buffer management rather than protocol type consistency. There is some relevance in ensuring the ESP header pointer is correctly maintained after reallocation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2016-1833_before_exclude_100:e491ddc3:spec": {
    "timestamp": "2026-01-17T01:00:04.386298",
    "cve_id": "CVE-2016-1833",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e491ddc3",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not use regular expressions; it parses SMTP command parameters character by character. The connection is weak, as both involve input parsing, but the core concern (regex engines) does not apply.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences. It validates UTF-8 and text characters. The weak connection is general \"boundary awareness\" during parsing, but the specific context does not match.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted SMTP input. It uses length-aware operations: `uni_utf8_get_char_n` takes a size limit, and the loop checks `p < parser->end`. The final string duplication `i_strdup_until` uses explicit boundaries. This directly aligns with using length-aware operations for safety.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates length against `max_size` (a configurable limit). However, it does not validate protocol message length *fields* (like a size from a packet header) against integer limits. The check `(uoff_t)(p - parser->cur) > max_size` is a simple bounds check, not specifically about platform integer overflows from parsed fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code calls `i_strdup_until` for allocation. While it uses bounded input, there's no explicit validation of the allocation size against a separate allocation limit before the call. The principle of validating size parameters is related, but not directly demonstrated in a critical way here. The allocation size is derived from a bounded pointer difference.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs buffer length calculations: `p - parser->cur` and `(size_t)(p - parser->end)`. It validates `p < parser->end` before character reads, ensuring remaining capacity. The UTF-8 function call uses the calculated remaining size. This directly aligns with validating remaining capacity before arithmetic/use.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The specification about protocol string processing maintaining strict boundary awareness directly applies. The code meticulously tracks buffer boundaries (`parser->cur`, `parser->end`, `p`), uses pointer arithmetic with length checks, and ensures the duplicated parameter string is bounded by `mp`. This is a textbook example of boundary-aware protocol string processing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      }
    ]
  },
  "CVE-2016-1833_after_exclude_100:6e310f5b:spec": {
    "timestamp": "2026-01-17T01:00:10.664542",
    "cve_id": "CVE-2016-1833",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6e310f5b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not use regular expressions; it parses SMTP command parameters character by character. The connection is weak, as both involve input parsing, but the mechanisms and specific risks (embedded NULs in regex patterns) are not present.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences. It performs linear parsing of UTF-8 and text characters. The weak connection is the general principle of strict boundary awareness during input processing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted SMTP input. It uses length-aware operations: `uni_utf8_get_char_n` takes a size limit, and the loop checks `p < parser->end`. It also validates the total parameter length against `max_size`. This directly aligns with using length-aware operations for safety.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code does not parse length fields from the protocol; it enforces a configured maximum size (`max_size`) for parameters. The connection is very low, as the core concept of integer overflow validation for parsed fields is not present.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code calls `i_strdup_until` for duplication, which likely handles allocation. The `max_size` check before allocation indirectly validates size against a limit. However, the specification focuses on explicit validation of size parameters to allocation functions, which is not directly visible in this snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code handles two data types: raw bytes (for `auth_response`) and UTF-8 characters. It maintains consistent handling by using different parsing paths (`if (parser->auth_response)`). It validates UTF-8 sequences and enforces character set rules (`smtp_char_is_textstr`), ensuring type consistency across processing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code calculates `p - parser->cur` and compares it to `max_size`. It also calculates `p - parser->end` as a size for `uni_utf8_get_char_n`. While it uses pointer comparisons (`p < parser->end`) to ensure bounds, there is no explicit check for integer overflow in the subtraction `(p - parser->cur)` before the comparison, though the context suggests `p` is between `cur` and `end`.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code is a protocol string processor for SMTP. It maintains strict boundary awareness: the loop condition `p < parser->end`, the use of `p - parser->end` as a size limit for UTF-8 decoding, and trimming within the buffer (`mp > parser->cur`). This directly embodies the principle of maintaining strict boundaries during transformations.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      }
    ]
  },
  "CVE-2017-14151_before_exclude_100:67321b7f:spec": {
    "timestamp": "2026-01-17T01:00:23.956262",
    "cve_id": "CVE-2017-14151",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "67321b7f",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The code is a BMP image parser that extensively validates header fields (magic number, biSize, biWidth, biHeight, biPlanes, biBitCnt, biClrUsed, etc.) before proceeding with image processing. It performs multiple sanity checks on critical header values.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code performs pre-validation of size parameters to prevent integer overflows before memory allocation would occur in ReadImage function. It checks width, height, and bit count combinations to ensure they don't cause overflows in rowbytes calculation and other operations.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. The code explicitly validates biBitCnt values against BMP specification requirements (1, 4, 8, 16, 24, 32 bits) and rejects invalid values. It also handles special cases for different bit depths throughout the parsing logic.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. While the code initializes some local variables (like memset(masks, 0, sizeof(masks))), the main memory allocation for image data happens in ReadImage function which is not shown. The visible code doesn't show memory allocation initialization patterns.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses consistent error handling with goto cleanup pattern that ensures file handles are closed (fclose(fd)) and exceptions are set before returning. The image object is initialized even in error paths via at_bitmap_init.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This specification is for network protocol handlers, but the target code is a local file parser (BMP image file). While input validation principles are similar, the context is completely different (file I/O vs network protocols).",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates various integer fields against platform limits (e.g., checking biWidth against 0x7fffffff, checking for -2147483648 overflow case). However, this is for file format parsing, not specifically for protocol message length fields.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code performs extensive validation of size parameters before they would be used for memory allocation. It checks for integer overflows in widthbitcount calculations and widthheight combinations, and validates against both allocation limits and usage requirements for rowbytes calculation.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2017-14151_after_exclude_100:d357ba72:spec": {
    "timestamp": "2026-01-17T01:00:43.520002",
    "cve_id": "CVE-2017-14151",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d357ba72",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The code is a BMP image parser that extensively validates header fields (magic number, biSize, biWidth, biHeight, biPlanes, biBitCnt, biClrUsed, etc.) before processing the image data. It performs multiple sanity checks on critical header values to prevent malformed input from causing issues.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. While the code doesn't directly show memory allocation (it's in ReadImage), it performs pre-validation of size parameters (biWidth, biHeight, biBitCnt) to prevent integer overflows that could lead to excessive memory allocation. The overflow check using division and the rowbytes calculation with overflow protection demonstrate this principle.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. The code explicitly validates biBitCnt against allowed values (1, 2, 4, 8, 16, 24, 32) using a switch statement and rejects invalid values. This directly enforces bit count requirements per BMP specification.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code shows initialization of local arrays (buffer, ColorMap) and structures, but doesn't demonstrate memory allocation that needs initialization. The main memory allocation for image data happens in ReadImage which isn't shown, so we can't evaluate initialization practices.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses goto cleanup pattern for error handling, which helps maintain consistent state by centralizing cleanup. However, the image object is initialized early and returned even on error (though at_bitmap_init(0,0,0,1) creates empty bitmap), showing some attention to consistent state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This specification is for network protocol handlers, but the code is a file-based BMP parser reading from local filesystem via fopen/fread. While input validation principles are similar, the context is different.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Although this mentions \"protocol message length fields\" (network context), the code validates BMP header fields against integer limits, particularly checking biWidth and biHeight against 0x7fffffff to prevent overflows. The principle of validating size fields against platform limits applies.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs extensive validation of size parameters (biWidth, biHeight, biBitCnt) against both allocation limits (through overflow checks) and usage requirements (rowbytes calculation). It checks for integer overflows in widthbitcount and widthheight calculations that could affect subsequent memory allocation and usage.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2012-5854_after_exclude_100:2e8ef557:spec": {
    "timestamp": "2026-01-17T01:01:32.747933",
    "cve_id": "CVE-2012-5854",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2e8ef557",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes HTTP headers but does not explicitly handle protocol message length fields. The `len` variable is derived from `size * nmemb` (a common libcurl callback pattern), but there is no validation against integer overflow or platform-specific limits before its use. This is a weak connection.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-1286_before_exclude_100:20fe80b3:spec": {
    "timestamp": "2026-01-17T01:01:35.677547",
    "cve_id": "CVE-2022-1286",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "20fe80b3",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It is a method removal function operating on symbol identifiers in a class's method table.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It deals with method table manipulation in a Ruby-like interpreter.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the function processes a method identifier (mid), it is a symbol, not a string from untrusted input. The core operation (mt_del) is a table lookup/removal, not string processing. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse protocol messages or validate length fields. It is an internal interpreter function for modifying a class's method table.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function does not perform explicit memory allocation. However, the underlying `mt_del` operation might involve memory deallocation or table resizing, but this is not visible in the provided code snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a network or data protocol. It is part of a language runtime's internal API. The principle of consistent type handling is a general good practice but is not a specific focus of this short code.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform memory allocation. It calls a deletion function (`mt_del`) and potentially an error reporting function (`mrb_name_error`).",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function has a clear error path: if the method is not found (`mt_del` fails), it calls `mrb_name_error`. The specification about maintaining consistent object states in error paths is highly applicable. The function must ensure the class (`c`) and its method table (`h`) remain in a valid state whether the deletion succeeds or the error is raised.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2018-18820_before_exclude_100:b66cb773:spec": {
    "timestamp": "2026-01-17T01:01:40.714547",
    "cve_id": "CVE-2018-18820",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b66cb773",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process explicit protocol message length fields. It handles HTTP-style headers by comparing fixed strings and extracting values, but there is no validation of integer limits for the extracted `limit` value from `sscanf`. The relevance is weak because the specification is about validating length fields against platform limits, which is not a primary activity here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform any memory allocation operations. It uses fixed-size buffers (e.g., `url->errormsg`) and string functions. The specification about validating size parameters for memory allocation is very low relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles data from a network stream (HTTP headers) and performs type conversions (e.g., `sscanf` to read an unsigned int). There is a moderate relevance because ensuring consistent type handling (e.g., ensuring the string-to-integer conversion is safe and the integer is used appropriately) is important, but the code's primary focus is not a full protocol implementation with multiple complex types.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It uses simple string comparison (`strncasecmp`) and search (`strchr`). This specification is basically not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain pattern compilers or process escape sequences. It performs simple string operations. This specification is basically not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes network input (`ptr`) which is potentially untrusted. It uses length-aware operations like `strncasecmp` with explicit lengths, which is good. However, it also uses `sscanf` and `snprintf` without explicitly ensuring the source pointer offset (`(char *)ptr+url->timelimit_header_len`) is within bounds. The principle of using length-aware operations for untrusted input is strongly relevant, though the implementation could be more robust.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code processes HTTP header fields. While RFCs specify constraints for header values, the code does not explicitly enforce any length constraints (e.g., on the value extracted for `icecast-auth-message` before copying it into `url->errormsg` with `snprintf`). The connection is weak because the specification is about enforcing RFC length constraints, which is not done, though it is a relevant concern for protocol message handling.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code does not process TLV (Type-Length-Value) encoded data. It processes plain HTTP headers. The specification about TLV processing bounds checking has very low relevance to this code scenario.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-1286_after_exclude_100:a9525670:spec": {
    "timestamp": "2026-01-17T01:01:56.529720",
    "cve_id": "CVE-2022-1286",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a9525670",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It is a method removal function operating on symbol identifiers and method tables.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation, escape sequence processing, or any protocol/format parsing that would require boundary checking for escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the function processes a method identifier (mid), it's a symbol rather than a string from untrusted input. The core operation (mt_del) works on internal data structures, not directly on string data that requires length-aware operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol messages, parse length fields, or handle any network/communication protocols that would require validation of integer limits in length fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 4,
        "reasoning": "The function indirectly deals with memory through method table operations (mt_del), but doesn't perform explicit memory allocation. There's weak relevance as the underlying mt_del implementation might need to handle memory, but it's not visible in this code snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code handles method removal in a programming language runtime, not a communication protocol. While it deals with type consistency (method symbols, class objects), it's not in the context of protocol processing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "The code does not perform memory allocation operations that would require initialization before use. It works with existing data structures (method tables, classes).",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The function must maintain consistent object states during error handling. If mt_del fails, it calls mrb_name_error, but before that it must ensure the class/method table state remains consistent. The mrb_mc_clear_by_class call after successful deletion also relates to state consistency maintenance.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-37635_before_exclude_100:8467130e:spec": {
    "timestamp": "2026-01-17T01:03:05.866681",
    "cve_id": "CVE-2021-37635",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8467130e",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor reduction operations (likely mathematical computations like sum, mean, max). There is no cryptographic operation on secret values. The timing of operations depends on data values and tensor sparsity, but this is not a security concern for cryptographic secrets in this context.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve operations or any cryptographic implementations. It is purely a numerical tensor computation kernel.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No cryptographic processing is present. Memory operations involve copying tensor data and performing reductions, but constant-time properties are not required for this numerical computation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve view-based data access, database views, or privilege checks. It operates on tensor data structures within a computational kernel.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "No security-critical state transitions or privilege contexts are involved. This is a pure computation function without security state management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "No SQL protocols or database access are present. The code manipulates in-memory tensor structures, not database views.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs array write operations via `out_flat(idx) = reduced_val()` where `idx` is computed from coordinates. While there is bounds checking in `CoordinatesToFlatIndex` via `CHECK_EQ`, and the output tensor is allocated with known size, the validation relies on correct computation of strides and indices. A potential issue could arise if `shape_vec` access or stride calculations overflow or produce invalid indices, though the code appears to work within allocated tensor bounds.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates inputs via `ValidateInputs(shape_t, reduction_axes_t)` and uses `OP_REQUIRES_OK` for error checking. It processes parameters like reduction axes and tensor shapes, which should enforce domain constraints (e.g., valid axes within tensor rank). However, the specification mentions \"profile-specific\" validation, which is not clearly applicable here beyond general input validation.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Profile-specific parameter validation must enforce domain constraints"
      }
    ]
  },
  "CVE-2021-37635_after_exclude_100:08839409:spec": {
    "timestamp": "2026-01-17T01:03:08.552787",
    "cve_id": "CVE-2021-37635",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "08839409",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor reduction operations (likely mathematical computations like sum, max, etc.) and does not involve any cryptographic operations on secret values. The timing characteristics of the operations are not security-critical in this context.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor computation kernel with no elliptic curve operations or cryptographic implementations of any kind. Side-channel resistance for curve models is completely irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs standard memory operations for tensor data processing but does not involve cryptographic processing. Constant-time properties for memory operations are not a concern here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code manipulates tensor data structures and performs mathematical reductions. It does not involve database views, access control, or privilege checks based on user roles or ownership.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The code manages computational state for a tensor operation, not security-critical system state transitions. There is no concept of privilege context or security state being maintained.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The code is a computational kernel for tensor operations, not a SQL protocol implementation. It does not handle database queries, views, or enforce any security semantics for data access.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 8,
        "reasoning": "The code performs array write operations (out_flat(idx) = reduced_val()) and includes explicit bounds checking before the write. It validates that the computed index is within the bounds of the output array (idx >= 0 && idx < out_flat.size()). This directly aligns with the principle of validating bounds against allocated size.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The code validates input tensors (OP_REQUIRES_OK(ctx, ValidateInputs(...))) and performs checks on intermediate values (e.g., group size matching strides). While not explicitly \"profile-specific,\" it enforces domain constraints on parameters like indices, shapes, and intermediate coordinates, which relates to the general principle of input validation.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Profile-specific parameter validation must enforce domain constraints"
      }
    ]
  },
  "CVE-2015-5745_before_exclude_100:baf6c1e3:spec": {
    "timestamp": "2026-01-17T01:03:11.610528",
    "cve_id": "CVE-2015-5745",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "baf6c1e3",
    "scores": [
      {
        "score": 8,
        "reasoning": "The function receives a `len` parameter which is used to copy data into a buffer (`elem.in_sg[0].iov_base`). This length should be validated against the size of the destination buffer to prevent buffer overflow. While the specification mentions \"protocol message length fields,\" the core principle of validating input length against limits before use is directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation. It uses a pre-existing buffer from a popped queue element (`elem.in_sg[0].iov_base`). The relevance is weak because the specification focuses on allocation operations, but the underlying need to ensure the buffer size is sufficient for the copy operation is related.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code handles a simple memory copy operation for a control message. There is no indication of complex protocol processing with multiple types that require consistency checks across stages. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "The `len` parameter is a userspace-provided (or externally provided) input that determines how much data is copied. It must be validated against the size constraint of the destination IOV buffer (`elem.in_sg[0].iov_len`) before the `memcpy` to prevent a buffer overflow. This is highly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 6,
        "reasoning": "The function handles a \"control message\" which could be considered a protocol component. The specification's principle of verifying integrity before processing applies. The code should verify that the provided `len` does not exceed the structural capacity of the destination buffer, which is a form of integrity check. Relevance is moderate.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform buffer allocation. The buffer is provided by the virtqueue element. The weak connection is that the system design should ensure the allocated buffers in the queue can handle worst-case message sizes, but this is not enforced in this function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "The code performs a binary memory copy and does not involve parsing or processing regular expressions. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code performs a binary memory copy and does not involve pattern compilation, escape sequences, or lexical analysis. This specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-16914_after_exclude_100:faf5d439:spec": {
    "timestamp": "2026-01-17T01:03:27.914587",
    "cve_id": "CVE-2017-16914",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "faf5d439",
    "scores": [
      {
        "score": 8,
        "reasoning": "The function receives a `len` parameter which is used to copy data from `buf` into the guest's input scatter-gather list. This `len` could originate from an untrusted source (e.g., a guest-provided control message). The code has a TODO comment about detecting a buffer that's too short, indicating a missing validation of `len` against the actual size of the destination buffers (`elem.in_sg`). This directly relates to validating a length field against platform/usage constraints before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function does not perform memory allocation itself. It uses pre-allocated virtqueue elements. The relevance is weak because the specification focuses on validating size parameters for allocation operations, which are not present here. However, the principle of validating size parameters before usage (like copying into pre-allocated buffers) is tangentially related.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 4,
        "reasoning": "The function handles a control message protocol. Weak relevance because the specification about consistent type handling across processing stages is a high-level principle. The code shows a single stage of processing (copying data into a virtqueue element), so cross-stage consistency isn't directly evaluable here.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "This is highly relevant, similar to spec_1. The `len` parameter is effectively a userspace (guest)-provided array length or data length. It must be validated against the system constraint, which is the total size of the destination buffers in `elem.in_sg`, before the `iov_from_buf` operation to prevent buffer overflow. The TODO comment explicitly acknowledges this missing validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The function is a protocol message handler for control messages. The specification requires verifying the structural integrity of variable-length components. Here, the component is the data of length `len`. Integrity verification would include ensuring the provided `len` does not exceed the capacity of the destination buffers, which is not done.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The function does not perform buffer allocation. However, the principle of accounting for worst-case input (a very large `len`) is relevant to the missing bounds check when using the pre-allocated buffers in the virtqueue element. The connection is indirect as the allocation likely happened elsewhere.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is specifically about regular expression parsers handling NUL bytes. The target code does not involve regular expression parsing at all.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is specifically about pattern compilers processing escape sequences. The target code is a simple data copy function for a virtio control channel and does not involve pattern compilation or escape sequence processing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-43057_before_exclude_100:60af4d04:spec": {
    "timestamp": "2026-01-17T01:04:33.067193",
    "cve_id": "CVE-2021-43057",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "60af4d04",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs a security check (PTRACE permission) which is a form of privilege control. A failure in this check should prevent the ptrace operation, which is a security boundary. While the function returns an error code rather than enforcing \"immediate process termination,\" the core principle of enforcing privilege separation is directly relevant. The relevance is strong but not a perfect match for the specification's prescribed action.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "The code verifies a state transition (initiating a ptrace relationship). The `avc_has_perm` call performs a security state check. However, there is no indication in this snippet that the verification is atomic with respect to other operations or system state changes. The connection to the principle of verification exists but is weak regarding the atomicity requirement.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "The code is a security hook for a specific kernel operation (ptrace), not a daemon. It does not involve parsing, loading, or validating a runtime configuration file or parameters. The specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "The code performs an access control check. It does not parse any protocol messages or handle any length fields. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain any memory allocation operations. It only calls a function to check permissions. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a network or data protocol. It is a Linux Security Module (LSM) hook for the ptrace system call. The specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process any network-derived data or values. It operates on task/process security identifiers (SIDs). The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain a protocol option parser or handle variable-length fields. It is a simple permission check function. The specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2021-43057_after_exclude_100:1e146b4b:spec": {
    "timestamp": "2026-01-17T01:04:36.739521",
    "cve_id": "CVE-2021-43057",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1e146b4b",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs a security check (ptrace permission) which is a form of privilege control. A failure in this check should prevent the ptrace operation, which is a security enforcement. However, the specification mandates \"immediate process termination\" for failures, which is a more severe consequence than simply returning an error code. The code's relevance is moderate because it enforces separation but not to the extreme degree specified.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "The code verifies a security-critical state transition (one process attempting to trace another). The avc_has_perm function performs an access check. The relevance is strong as the core concept applies, but the specification emphasizes \"atomic verification,\" which involves more complex transactional integrity. The code's check is a single, presumably atomic, function call, so it aligns with the principle.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "The code is a security hook within the kernel, not a daemon. It does not involve loading or validating a runtime configuration file. The connection is very weak.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "The code performs a mandatory access control check. It does not parse any protocol messages or handle any length fields. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform any memory allocation operations. It only calls a permission checking function. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code is part of the SELinux LSM protocol for access control. It handles object types (process SIDs, security class) consistently in its check. There is a very weak connection in that it enforces a security \"protocol,\" but it does not deal with network or data serialization protocols which the specification targets.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This is a duplicate of HS-INPUT-001. The code does not process network-derived data. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain a protocol option parser or handle variable-length fields. It is a simple function call with fixed parameters. The specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2020-15890_before_exclude_100:2b0014b6:spec": {
    "timestamp": "2026-01-17T01:04:38.752338",
    "cve_id": "CVE-2020-15890",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2b0014b6",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a stack traversal function for finding error handlers in a Lua interpreter. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code performs stack frame navigation and error handler lookup. It does not involve pattern compilation, escape sequence processing, or any string pattern matching logic.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The function operates on internal interpreter stack frames and control structures. It does not process string inputs or perform length-aware string operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code performs bounds checking when traversing stack frames (e.g., `frame > bot` comparison, `frame >= restorestack(L, -cframe_nres(cf))`). It validates stack boundaries before dereferencing frame pointers, which is the core principle of HS-MEM-001 for buffer access operations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 1,
        "reasoning": "The code navigates internal interpreter state to find error handlers. It does not parse external input or enforce structural constraints on parser input.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 1,
        "reasoning": "The code is part of a Lua interpreter's error handling mechanism. It does not involve XML protocol parsing or boundary integrity maintenance during XML processing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 1,
        "reasoning": "The code reads and navigates existing interpreter state. It does not perform memory allocation or initialization of new memory regions.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The entire function is dedicated to error handling path navigation. It searches for error handlers while maintaining consistent interpreter state during stack unwinding, ensuring proper error propagation through different frame types (Lua, C, vararg, continuation, etc.). This directly aligns with HS-STATE-002's requirement for consistent object states in error handling paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2020-15890_after_exclude_100:1d293a72:spec": {
    "timestamp": "2026-01-17T01:04:54.007277",
    "cve_id": "CVE-2020-15890",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1d293a72",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a low-level stack traversal function for error handling in a Lua interpreter. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation, escape sequence processing, or any string pattern matching logic. It operates on call frames and stack pointers.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The function performs stack pointer arithmetic and frame type checking. It does not process strings or use string operations on untrusted input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "The code performs bounds checking (e.g., `frame > bot`) before dereferencing stack pointers and uses assertions (`lua_assert(0)`). It validates stack boundaries during traversal, which aligns with the principle of validating bounds before access.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 2,
        "reasoning": "While the code validates frame types and stack boundaries, it is not a parser processing structured input (like JSON, XML). Its validation is specific to internal interpreter state, not external input parsing.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to XML protocol implementation, parsing, or boundary integrity for markup languages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 3,
        "reasoning": "The function reads and traverses existing stack frames; it does not perform memory allocation or initialization of new memory regions. Memory safety here depends on prior correct initialization.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "This function's entire purpose is error handling path managementsearching for an error handler function in the call stack while maintaining consistent interpreter state (unwinding frames correctly, preserving stack integrity). It directly implements error handling logic that must maintain state consistency.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2011-1178_before_exclude_100:cc9176e7:spec": {
    "timestamp": "2026-01-17T01:06:25.330945",
    "cve_id": "CVE-2011-1178",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cc9176e7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs pixel offset calculations via pointer arithmetic (`from += step`) and loop conditions (`from < end`). While it uses the `end` boundary for the main loop, it does not explicitly validate that `from + step` remains within the buffer before dereferencing `*from` on line `if (data != *from || from == end)`. This is a direct buffer boundary check scenario relevant to HS-MEM-001.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Pixel offset calculations must validate against buffer boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code involves arithmetic operations for run-length calculation (`(from - start) / step + 0xc1` and `from - start >= max_run`). While it uses pointer differences within the same buffer, which in C are well-defined, the operations rely on `step` being positive and correctly set. An overflow or negative step could cause issues, making the principle of validating arithmetic operations moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must validate all arithmetic operations for overflow conditions"
      },
      {
        "score": 5,
        "reasoning": "This specification is about validating derived values against image dimensions in file decoders. The target function is an encoder (pcx_write_rle) that writes data, not a decoder. It does not parse image dimensions or validate against them, so relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: File decoders must validate all derived values against image dimensions"
      },
      {
        "score": 5,
        "reasoning": "This specification concerns string operations and length fields. The code deals with pixel data encoding, not string manipulation. There are no length fields or string buffers involved, so relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String operations must validate length fields against remaining buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "The specification is about external format parsers implementing length validation chains. This function is an encoder for the PCX format, not a parser. However, it does process input data with a defined boundary (`end`), which loosely relates to length validation, but the connection is weak.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: External format parsers must implement complete length validation chains"
      },
      {
        "score": 5,
        "reasoning": "This specification is for image format parsers validating header fields before processing. The target function is an encoder/writer that does not parse any headers; it processes raw pixel data. Therefore, it basically doesn't apply.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "This specification is about guarding memory allocation with pre-validation of size parameters. The function does not perform any dynamic memory allocation (it writes to a file). Therefore, it is not relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "This specification is specifically for BMP parsers enforcing bit count requirements. The target code is for PCX encoding, not BMP parsing. Therefore, it does not apply at all.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      }
    ]
  },
  "CVE-2016-10050_after_exclude_100:cb3879ce:spec": {
    "timestamp": "2026-01-17T01:06:38.389151",
    "cve_id": "CVE-2016-10050",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cb3879ce",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs pixel offset calculations via pointer arithmetic (`from += step`) and loop conditions (`from < end`). It validates against the buffer boundary `end`, making the specification highly relevant. However, the validation is primarily for reading (`from < end`), and the write operations to the file are not buffer writes, slightly reducing directness.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Pixel offset calculations must validate against buffer boundaries"
      },
      {
        "score": 7,
        "reasoning": "The code involves arithmetic operations for calculating run length (`(from - start) / step + 0xc1`). While it uses pointer differences within a bounded buffer, which mitigates overflow risk, the specification about validating arithmetic for overflow is moderately relevant as a general principle for safe image processing.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must validate all arithmetic operations for overflow conditions"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns validating derived values against image dimensions in file decoders. This code is an encoder (writing RLE data) and does not parse or decode image dimensions, making the relevance very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: File decoders must validate all derived values against image dimensions"
      },
      {
        "score": 3,
        "reasoning": "The specification is about string operations and length fields. This code processes raw pixel bytes, not strings, and does not use length fields. The connection is very weak.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String operations must validate length fields against remaining buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "The specification about complete length validation chains for external format parsers has weak relevance. This is an encoder function, not a parser. However, it does handle length calculations (`from - start`) and validates against `max_run`, which loosely aligns with the principle of length validation.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: External format parsers must implement complete length validation chains"
      },
      {
        "score": 5,
        "reasoning": "The specification is for image format parsers validating header fields before processing. This code is part of an encoder/writer and does not parse any headers. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns memory allocation with size parameter validation. This code does not perform any dynamic memory allocation (it writes to a file). It is basically not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for BMP parsers and bit count requirements. This code is for PCX format encoding, not BMP parsing. It does not apply.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      }
    ]
  },
  "CVE-2022-0382_before_exclude_100:c56f925f:spec": {
    "timestamp": "2026-01-17T01:06:57.074987",
    "cve_id": "CVE-2022-0382",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c56f925f",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates `dlen` against `TIPC_MAX_USER_MSG_SIZE` early in the function. This is a direct check of a user-provided length field against a protocol-specific maximum, which aligns with the core principle of HS-INPUT-001. However, the specification mentions \"platform-specific integer limits\" (like overflow/underflow), which is not explicitly checked here. The relevance is strong but not perfect.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code involves building messages into sk_buffs (`tipc_msg_build`) which internally performs memory allocation. The function checks the MTU and message length, which indirectly relates to size parameter validation for subsequent usage (preventing buffer overflows). However, the specification's focus on direct validation of allocation size parameters against allocation limits is not the primary visible activity here. The connection is weak to moderate.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code heavily deals with protocol message handling, specifically for the TIPC protocol. It validates the address type (`atype`) from the user, uses it to branch logic (unicast, multicast, anycast), and consistently sets corresponding fields in the message header (`msg_set_type`, `msg_set_lookup_scope`, etc.) based on that type. This demonstrates enforcement of consistent type handling across processing stages, making it highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code is a network socket send function for a custom protocol (TIPC) and does not involve regular expression parsing at all. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code is a network socket send function and does not involve compiling patterns or processing escape sequences. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes user input via `struct msghdr *m`. While it uses `msghdr` which can contain data pointers and lengths, the function itself does not show explicit string processing (e.g., `strcpy`, `strlen`). The data is handled via `tipc_msg_build`. The principle of using length-aware operations is generally good practice for any data handling, but there is no clear string-specific operation shown. Relevance is very low to low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This is very similar to Specification 1 (HS-INPUT-001) but more specific to \"RFC-specified length constraints\". The code validates `dlen` against `TIPC_MAX_USER_MSG_SIZE`, which is a protocol-specific (TIPC) length constraint, analogous to an RFC constraint. This is a direct and relevant check. The score is high, though the constraint is for TIPC, not a formal IETF RFC.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code processes a structured message header and user data. While it performs bounds checking via the `dlen` vs. `TIPC_MAX_USER_MSG_SIZE` and MTU checks, it does not explicitly show parsing of a Tag-Length-Value (TLV) structure. The principle of bounds checking before field access is partially present (e.g., validating `ua` and `atype` before use), but the direct connection to TLV processing is weak.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-0382_after_exclude_100:28dc77bf:spec": {
    "timestamp": "2026-01-17T01:07:06.080154",
    "cve_id": "CVE-2022-0382",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "28dc77bf",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the user-provided message length `dlen` against `TIPC_MAX_USER_MSG_SIZE` at the beginning. This is a direct check of a protocol message length field against a defined limit, which aligns with the core principle of HS-INPUT-001. It prevents sending messages that are too large for the protocol's internal handling. The relevance is strong, though the check is against a protocol-specific constant rather than a platform-specific integer limit (like `INT_MAX` or `SIZE_MAX`).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain explicit memory allocation operations within the shown function. Memory allocation is likely deferred to `tipc_msg_build` and `tipc_msg_skb_clone`. Therefore, the direct application of this specification to the visible code is weak. The principle of validating size parameters before allocation is important for the functions it calls, but not directly evaluated here.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing. This specification is about a specific class of vulnerability in regex engines and is completely irrelevant to the given network socket message sending code.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. This specification is irrelevant to the given code which deals with message construction and transmission.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function receives user input via the `struct msghdr *m` parameter, which contains a message buffer of length `dlen`. The call to `tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts)` passes this length, implying the downstream function should use length-aware operations when copying data from the user buffer. The relevance is moderate because the principle of handling untrusted input safely is central, but the actual length-aware string operations (if any) are not visible in this high-level function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This is very similar to Specification 1 (HS-INPUT-001) and is also highly relevant. The initial check `if (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))` is a direct enforcement of a protocol-specific length constraint (likely defined by the TIPC protocol specification/RFC). This prevents buffer overflows or resource exhaustion in subsequent processing stages.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code does not show explicit TLV (Type-Length-Value) parsing. It constructs a message header with fixed fields (`msg_set_*` functions) and appends a user payload. While bounds checking is crucial when *reading* and parsing incoming TLV messages, this function is primarily concerned with *constructing and sending* messages. The principle of bounds checking is always important, but the direct application to this specific code scenario is weak.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2011-3601_before_exclude_100:4c97e0ce:spec": {
    "timestamp": "2026-01-17T01:07:09.184829",
    "cve_id": "CVE-2011-3601",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4c97e0ce",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It deals with memory slot address translation and validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is focused on memory management and address translation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 4,
        "reasoning": "While the code processes input (address and size), it does not primarily involve string operations. The validation of `add_size` and address ranges is present, but the core specification about length-aware string functions is not directly applicable.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code validates several input parameters (`group_id`, `slot_id`, `add_size` via `memslot_validate_virt`) against limits (`info->num_memslots_groups`, `info->num_memslots`). This aligns with the principle of validating message/input fields, though it's not specifically about protocol message length fields or platform integer limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code does not perform memory allocation directly, but it validates parameters (`add_size`) before use (in `memslot_validate_virt`), which is related to validating size parameters against usage requirements. The connection to allocation limits is indirect.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code ensures type consistency (e.g., using `unsigned long` for `h_virt`, casting to `void*`) and validates that indices (`group_id`, `slot_id`) are within bounds for array access. This loosely relates to consistent type handling, but the specification is more focused on protocol-level type enforcement.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code does not involve memory release or deallocation operations. It retrieves and validates a virtual address but does not free memory.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code does not process file content. It handles in-memory address translation and validation within a memory slot structure.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      }
    ]
  },
  "CVE-2011-3601_after_exclude_100:30ecb4a2:spec": {
    "timestamp": "2026-01-17T01:08:03.078746",
    "cve_id": "CVE-2011-3601",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "30ecb4a2",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It processes memory slot addresses and performs validation, but there is no pattern matching or regex handling.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns or escape sequences. It is focused on memory address translation and validation within a virtual memory slot system.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs bounds checking (e.g., validating group_id, slot_id, and using memslot_validate_virt for add_size). While not directly about string functions, the principle of validating size/offset parameters for untrusted input (like `addr` and `add_size`) is present.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code validates `group_id` and `slot_id` against array bounds (`info->num_memslots_groups`, `info->num_memslots`). It also validates the generation and calls `memslot_validate_virt` with `add_size`. This aligns with the principle of validating input length/offset fields against operational limits, though not specifically about protocol message length fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function validates size/offset parameters (`add_size`) during virtual address calculation and calls `memslot_validate_virt` to ensure the requested memory range is within the slot's bounds. This is analogous to validating size parameters against usage requirements before memory access, even though no explicit allocation occurs here.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code ensures type consistency in a limited sense (e.g., using `QXLPHYSICAL` for `addr`, casting to `void*`). However, it is not a full protocol implementation with multiple stages of type processing. The main checks are for bounds and generation, not deep type consistency.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code retrieves a virtual address but does not perform any memory release or deallocation operations. Ownership semantics are not relevant to this function.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not process file content. It handles memory address translation and validation within a memory slot management system, with no file I/O involved.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      }
    ]
  },
  "CVE-2013-1978_before_exclude_100:6bcc844a:spec": {
    "timestamp": "2026-01-17T01:08:22.895882",
    "cve_id": "CVE-2013-1978",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6bcc844a",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The GIF parser validates numeric fields like width, height, offset_x, offset_y against boundaries (offset_x + width <= gif->width, offset_y + height <= gif->height). It also validates colour_table_size derived from flags. However, it uses unsigned int for calculations which prevents some signedness issues, but could benefit from more comprehensive overflow checks (e.g., offset_x + width could overflow before comparison).",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code processes image data with bounded loops (for y in height, while x in width) and uses burst_bytes limiting to remaining x. The LZW decoding loop is controlled by image dimensions, preventing unbounded iteration. However, the lzw_decode function's internal bounds should be verified to ensure it respects input limits.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The parser validates intermediate states through multiple checks: verifying GIF_IMAGE_SEPARATOR, checking data sufficiency before proceeding, and validating disposal method states. However, state validation could be more comprehensive (e.g., ensuring decoded_frame is valid when used).",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code initializes colour_table entries fully (including alpha channel). Frame buffers are cleared with memset when needed. However, there's no explicit initialization of all allocated memory (e.g., frame_data from bitmap_get_buffer may not be initialized if the callback doesn't guarantee it).",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Error handling uses goto gif_decode_frame_exit to maintain consistent state, restores buffer_position on exit, and ensures proper cleanup. Multiple error paths maintain object consistency. However, some early returns (like GIF_INSUFFICIENT_MEMORY) bypass the exit label and might skip state restoration.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While this is an image decoder (not network protocol), it validates input data through bounds checking and format validation. The principles apply but the specification is specifically for network protocols, making it less directly applicable.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates length fields like width/height against gif->width/height, and checks gif_bytes against required minimums. However, it doesn't explicitly validate against platform integer limits (e.g., width * height * sizeof(int) could overflow). The specification is more about protocol messages than image dimensions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates colour_table_size against available data (gif_bytes < 3 * colour_table_size). However, it doesn't validate allocation sizes for frame_data (delegated to bitmap_get_buffer) or check for integer overflows in size calculations (e.g., width * height * sizeof(int)).",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2013-1978_after_exclude_100:efc03026:spec": {
    "timestamp": "2026-01-17T01:08:40.389266",
    "cve_id": "CVE-2013-1978",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "efc03026",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The GIF parser validates numeric fields like width, height, offset_x, offset_y against image boundaries (offset_x + width > gif->width, offset_y + height > gif->height). It also validates colour_table_size derived from flags. However, it uses unsigned int for calculations which prevents some signedness issues, but range validation is present.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code implements bounded iteration when processing LZW-compressed image data. The outer loop iterates 'height' times, and inner while loop processes 'width' pixels per row. The burst_bytes mechanism ensures processing stays within row bounds. However, the loops depend on validated width/height values.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The parser validates intermediate states through multiple checks: frame display status, frame range, already decoded status, data sufficiency checks, and boundary validation. Error handling uses goto to maintain state consistency. However, the state machine isn't explicitly defined but implicit in the parsing flow.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Memory initialization occurs in several places: memset() clears frame_data with transparent colour, colour_table entries are fully initialized with RGBA values. However, the code relies on external bitmap_get_buffer for frame_data allocation/initialization, which isn't shown.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Error handling maintains consistent state through goto gif_decode_frame_exit label which restores buffer_position and updates frame metadata. Multiple error paths ensure object states remain valid. The function carefully manages gif->decoded_frame state throughout.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While this is a parser that processes input data (GIF format), it's not specifically a network protocol handler. The validation principles (checking data boundaries, offsets, sizes) are similar, but the context is file format parsing rather than network protocol handling.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code validates length fields like width, height, and data sizes against available buffer (gif_bytes checks), but doesn't explicitly check against platform-specific integer limits (e.g., multiplication overflow for width * height * sizeof(int)). Some calculations could potentially overflow.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code validates size parameters indirectly through boundary checks (offset_x + width, offset_y + height) and data sufficiency checks (gif_bytes < required). However, memory allocation happens externally via bitmap_get_buffer, so allocation size validation isn't visible in this function. Usage requirements are validated through the boundary checks.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-3416_before_exclude_100:7997e511:spec": {
    "timestamp": "2026-01-17T01:08:54.037399",
    "cve_id": "CVE-2021-3416",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7997e511",
    "scores": [
      {
        "score": 4,
        "reasoning": "Specification HS-INPUT-001 regarding regular expression parsers and embedded NUL bytes is not relevant to this network device driver code which handles DMA descriptors and packet transmission. The code does not involve regular expression parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-PROTOCOL-002 about pattern compilers and escape sequences has very low relevance. This code processes network packet descriptors and transmits data, not parsing escape sequences in patterns.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Specification HS-MEM-003 about using length-aware operations for untrusted input has strong relevance. The code reads data from DMA memory using address_space_read with explicit length parameters (tx_desc_get_length(desc)), which is a length-aware operation. However, the length validation occurs before the read operation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "Specification HS-INPUT-001 about validating protocol message length fields has moderate relevance. The code validates tx_desc_get_length(desc) against gem_get_max_buf_len to prevent buffer overflow, which is similar to validating length fields, though not exactly protocol messages.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Specification HS-MEM-002 about validating size parameters has moderate relevance. The code validates tx_desc_get_length(desc) against available buffer space (gem_get_max_buf_len(s, true) - (p - s->tx_packet)) before reading data, which is a form of size validation against usage requirements.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-003 about consistent type handling has weak relevance. The code uses consistent types (uint32_t for descriptors, unsigned for total_bytes) but this is more about general type safety rather than protocol-specific type consistency.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 9,
        "reasoning": "Specification HS-INPUT-001 about validating network-derived length values has strong relevance. The code directly validates tx_desc_get_length(desc) from DMA descriptors (which could be considered network-derived) for range checking against maximum buffer size and for zero values before use in memory operations.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 7,
        "reasoning": "Specification HS-PROTOCOL-002 about validating variable-length fields has moderate relevance. The code validates descriptor length fields against remaining buffer space, which is conceptually similar to validating variable-length fields against remaining message length, though in a different context.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2012-3364_after_exclude_100:19e24b34:spec": {
    "timestamp": "2026-01-17T01:09:01.799250",
    "cve_id": "CVE-2012-3364",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "19e24b34",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code is a network packet transmission function that reads DMA descriptors and packet data. There is no regular expression parsing involved, making the connection very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code handles network packet transmission and DMA descriptor processing, with no pattern compilation or escape sequence logic present.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates the length field from the TX descriptor (`tx_desc_get_length(desc)`) against the remaining space in the packet buffer (`gem_get_max_buf_len(s, true) - (p - s->tx_packet)`). This is a form of range validation for a network-derived length, though it's not explicitly checking against platform integer limits like `SIZE_MAX`.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "While the code validates a length against available buffer space (a usage requirement), it does not involve explicit dynamic memory allocation. The buffer `s->tx_packet` appears to be a fixed-size pre-allocated buffer. The connection to memory allocation operations is indirect.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code processes DMA descriptor fields (buffer address, length, control flags) consistently. It reads them, validates them, and uses them for memory operations and flow control. This relates to consistent type handling in a data structure protocol (the descriptor format).",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code reads a length value (`tx_desc_get_length(desc)`) from a DMA descriptor, which is effectively network/guest-derived data. It performs critical validation: checking it's not zero, and checking it doesn't exceed the remaining buffer space. This prevents buffer overflow. Sign validation is less relevant as the length is likely an unsigned type.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "The code processes a linked list of variable-length packet fragments via DMA descriptors. It validates the length of each fragment against the remaining total buffer space before reading the data. This is analogous to validating a variable-length field against the remaining message capacity, though the \"message\" here is the reassembled packet buffer.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2011-3603_before_exclude_100:9d93cf84:spec": {
    "timestamp": "2026-01-17T01:09:36.319118",
    "cve_id": "CVE-2011-3603",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d93cf84",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process any protocol messages with length fields. It creates a Unix domain socket server and binds it to a filesystem path. The specification about validating message length fields against integer limits is not applicable here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform any explicit memory allocation operations (like malloc, new, or container resizes with size parameters). Memory allocation is implicit in STL container operations, but the specification focuses on validating size parameters for allocation, which is not a direct concern in this code snippet.</spec_1_reasoning>\n<spec_3_score>3</spec_3_reasoning>\n<spec_3_reasoning>The code does not implement a protocol with typed messages or data structures that require consistent type handling across stages. It sets up a socket server endpoint.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a protocol with typed messages or data structures that require consistent type handling across stages. It sets up a socket server endpoint.</spec_2_reasoning>\n<spec_4_score>8</spec_4_reasoning>\n<spec_4_reasoning>Highly relevant. The code uses `strcpy(local.sun_path, pipePath.c_str());` to copy a string into a fixed-size buffer (`sun_path`). This is a classic buffer overflow vulnerability if `pipePath` exceeds the buffer size (`sizeof(local.sun_path)`). The specification directly calls for validating available space before writing, which is not done here.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code uses `strcpy(local.sun_path, pipePath.c_str());` to copy a string into a fixed-size buffer (`sun_path`). This is a classic buffer overflow vulnerability if `pipePath` exceeds the buffer size (`sizeof(local.sun_path)`). The specification directly calls for validating available space before writing, which is not done here.</spec_3_reasoning>\n<spec_5_score>3</spec_5_reasoning>\n<spec_5_reasoning>The code does not generate protocol messages into output buffers. It configures a socket.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before writing"
      },
      {
        "score": 5,
        "reasoning": "The code does not generate protocol messages into output buffers. It configures a socket.</spec_4_reasoning>\n<spec_6_score>3</spec_6_reasoning>\n<spec_6_reasoning>The code does not write marker segments or perform similar structured data writing that requires boundary validation. The buffer write concern is covered by HS-MEM-001.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: All protocol message generation must validate output buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "The code does not write marker segments or perform similar structured data writing that requires boundary validation. The buffer write concern is covered by HS-MEM-001.</spec_5_reasoning>\n<spec_7_score>3</spec_7_reasoning>\n<spec_7_reasoning>The code does not involve process forking. It is part of a socket handler setup routine.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Marker segment writers must enforce strict boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve process forking. It is part of a socket handler setup routine.</spec_6_reasoning>\n<spec_8_score>9</spec_8_reasoning>\n<spec_8_reasoning>Strong relevance. The code creates a Unix domain socket (a type of network socket) bound to a filesystem path. The specification about protecting sockets from rogue processes applies directly. The code does set file permissions (`chmod`) to user-only access on non-Windows platforms, which is a relevant protection measure. However, the vulnerability in `strcpy` (HS-MEM-001) could potentially be exploited to subvert this protection, and the permission setting is platform-specific.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Process forking must ensure complete resource isolation by closing or marking all non-sh..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: Network sockets must be protected from unintended access by rogue processes"
      }
    ]
  },
  "CVE-2010-4345_after_exclude_100:fe35bf74:spec": {
    "timestamp": "2026-01-17T01:10:07.198685",
    "cve_id": "CVE-2010-4345",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fe35bf74",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process any protocol messages with length fields. It creates a Unix domain socket server, binds it to a filesystem path, and starts listening. The specification about validating message length fields is not applicable to this context.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation operations (like malloc, new, or container resizes with user-controlled sizes). Memory management is handled by standard library containers (set, map, string) with fixed, small data (file descriptors and a path string).",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code is not implementing a network protocol that involves parsing or generating structured messages with types. It sets up a communication endpoint. The specification about consistent type handling in protocol processing does not apply.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "The code uses `strncpy` to copy the pipe path into the `sun_path` buffer of a `sockaddr_un` structure. This is a buffer write operation. While `strncpy` limits the number of characters copied, it does not guarantee null-termination if the source string is too long, which could lead to issues later. The code does not explicitly validate the length of `pipePath` against `sizeof(local.sun_path)` before the copy, making this specification highly relevant. A better practice would be to check the length and ensure proper termination.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before writing"
      },
      {
        "score": 3,
        "reasoning": "The code does not generate protocol messages into an output buffer. It configures and binds a socket. The specification is not relevant to this scenario.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: All protocol message generation must validate output buffer capacity"
      },
      {
        "score": 3,
        "reasoning": "The code does not write marker segments or perform any similar structured data serialization. The specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Marker segment writers must enforce strict boundary validation"
      },
      {
        "score": 4,
        "reasoning": "The code does not involve process forking. However, it creates a file descriptor (`fd`) for a socket. If this code were part of a larger program that later forks, the principle of isolating resources (like this file descriptor) could become relevant, but it is not addressed here. The connection is weak and indirect.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Process forking must ensure complete resource isolation by closing or marking all non-sh..."
      },
      {
        "score": 9,
        "reasoning": "This specification is strongly relevant. The code creates a Unix domain socket, which is a network-like IPC mechanism accessible via the filesystem. The call to `chmod` (on non-WIN32 systems) sets permissions to `S_IRUSR | S_IWUSR | S_IXUSR` (read, write, execute for the owner only). This is a direct action to protect the socket file from unintended access by rogue processes (other users). However, it does not set permissions for a group if needed, and the `umask` of the process could affect the final permissions. The principle of the specification is directly applied.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: Network sockets must be protected from unintended access by rogue processes"
      }
    ]
  },
  "CVE-2019-17498_after_exclude_100:5d32c165:spec": {
    "timestamp": "2026-01-17T01:10:32.378283",
    "cve_id": "CVE-2019-17498",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5d32c165",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code extensively parses network status votes/consensus with various integer fields (vote_seconds, dist_seconds, dir_port, or_port, consensus_method, object_size). While it validates ranges (0-INT_MAX, 0-65535, 1-INT_MAX), it doesn't explicitly check against platform-specific integer limits like SIZE_MAX or address space limits. However, it does validate `tok->object_size >= INT_MAX` before memory allocation, showing some awareness. Direct relevance is strong but not complete.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code performs memory allocation based on parsed sizes (e.g., `sig->signature = tor_memdup(tok->object_body, tok->object_size)`). It validates `tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING` before allocation, and checks other parsed values against reasonable limits. This directly aligns with validating size parameters against allocation limits and usage requirements.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "The code strictly enforces type consistency: validates `ns_type` against parsed `ns->type`, checks flavor consistency (`flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS`), verifies voter identity digests match certificates, and ensures signature algorithms aren't duplicated. This is a core protocol parsing function where type handling is critical.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 10,
        "reasoning": "This is a network protocol parser that validates structural requirements before processing: checks token existence (K_VOTE_STATUS, K_VALID_AFTER, etc.), validates minimum argument counts (`tok->n_args >= 6` for K_DIR_SOURCE), verifies ordering of known_flags and params, and checks for required elements like dir-source. Directly applies to specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate minimum structural requirements before processing"
      },
      {
        "score": 5,
        "reasoning": "The code parses Tor network status documents, not DNS records. There's no DNS record processing or field boundary validation related to DNS. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: DNS record processing must enforce strict field boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code uses `base16_decode` with length checks (`strlen() == HEX_DIGEST_LEN`), validates object sizes before memory operations, and uses tokenization with bounds. However, it relies on `strlen()` and string operations without always verifying NUL termination. Strong relevance but not perfect.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory operations must verify bounds against actual available data"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't use regular expressions. It tokenizes using fixed token tables and parses structured data. No regex parsing or NUL byte handling in patterns.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't compile patterns or process escape sequences. It parses network status documents using tokenization and simple string parsing. No pattern compiler involved.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2012-3517_before_exclude_100:298c3182:spec": {
    "timestamp": "2026-01-17T01:10:35.600334",
    "cve_id": "CVE-2012-3517",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "298c3182",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code extensively parses network status votes/consensus documents which contain various length fields (e.g., digest lengths, object sizes, token counts). It validates hex digest lengths against HEX_DIGEST_LEN and performs bounds checking on parsed integers (e.g., tor_parse_long with min/max bounds). However, the validation against platform-specific integer limits (like SIZE_T_CEILING) is only partially present (seen in check for tok->object_size >= SIZE_T_CEILING). Direct relevance is strong but not complete across all length fields.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code performs multiple memory allocations (tor_malloc_zero, tor_strdup, smartlist_add with string duplication) and validates size parameters before use. For example, it checks tok->object_size against INT_MAX and SIZE_T_CEILING before tor_memdup. It also validates digest lengths before base16_decode operations. The code demonstrates awareness of allocation limits and usage requirements, making this highly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code strictly enforces consistent type handling for networkstatus_type_t (vote, consensus, opinion) and consensus_flavor_t. It validates ns_type matches parsed type, checks flavor consistency, and ensures data structures (like voter info) are correctly populated based on document type. All processing stages maintain type consistency with appropriate error handling.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 10,
        "reasoning": "The parser validates minimum structural requirements extensively before processing: checks for required tokens (K_VOTE_STATUS, K_VALID_AFTER, etc.), validates token argument counts (tok->n_args), verifies digest formats, ensures proper ordering of elements, and checks for required sections (dir-source elements). This is a core aspect of the function's error handling.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate minimum structural requirements before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not process DNS records. It parses Tor network status documents containing router descriptors, signatures, and voting information. There is no DNS-specific field boundary validation involved.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: DNS record processing must enforce strict field boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code performs bounds checking for memory operations: validates string lengths before base16_decode, checks object_size before memdup, ensures digest buffers are appropriately sized. However, some operations (like memcpy of digests) assume fixed sizes without runtime validation of source data boundaries, though the source is typically validated earlier.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory operations must verify bounds against actual available data"
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expressions. It uses tokenization functions (tokenize_string) and string parsing utilities, but no regex patterns with embedded NUL byte handling are involved.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It uses escaped() for logging but doesn't compile patterns. String parsing is done via simple comparison and tokenization.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2018-14461_before_exclude_100:32a4bcbb:spec": {
    "timestamp": "2026-01-17T01:10:48.760407",
    "cve_id": "CVE-2018-14461",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "32a4bcbb",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code directly processes a network protocol (RTCP) packet containing a length field (the byte at offset 8). It uses this field to determine the length of a reason string without validating that the provided length is consistent with the actual packet size (`size`). This is a classic case of insufficient validation of a protocol message length field against the actual received data, which could lead to out-of-bounds read. Specification HS-INPUT-001 is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code does not perform memory allocation but does perform a memory copy (`pj_memcpy`) into a fixed-size buffer (`peer_sdes_buf_`). The principle of validating size parameters against usage requirements (the buffer size) is relevant. The code uses `PJ_MIN` to bound the copy length, which is a form of validation, but the primary source length (`*((pj_uint8_t*)pkt+8)`) is untrusted and not validated against the remaining packet size. This relates to the core principle of the specification.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code handles raw packet data by casting pointers to `pj_uint8_t*` and directly accessing bytes. There is a risk of type confusion or misinterpretation if the packet structure is not as expected. Ensuring consistent and safe type handling when parsing the protocol is a relevant concern, though the example is specific to length and data extraction.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use or contain any regular expressions. This specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. This specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes a string (the reason field) from untrusted network input. It uses a length-aware memory copy (`pj_memcpy`) with a calculated length, which is good. However, the critical flaw is that the length used (`*((pj_uint8_t*)pkt+8)`) is taken directly from the packet and is not validated against the actual available data (`size`), which could lead to reading beyond packet boundaries. This directly violates the principle of using length-aware operations safely for untrusted input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The function appears to operate on a session object, but there is no indication of shared buffer access or concurrency in this snippet (no locks, mutexes, or atomic operations). The specification is not relevant to the shown code.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared buffer access must be protected by appropriate synchronization primitives"
      },
      {
        "score": 5,
        "reasoning": "The code does not show state machines, terminal states, or concurrent operations. It is a simple parsing and logging function. This specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Terminal state transitions must maintain consistency invariants during concurrent oper..."
      }
    ]
  },
  "CVE-2021-43804_after_exclude_100:ce32e76d:spec": {
    "timestamp": "2026-01-17T01:11:08.254174",
    "cve_id": "CVE-2021-43804",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ce32e76d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates a length field from the RTCP packet (reason length at offset 8) against buffer size and packet size. This directly relates to validating protocol message length fields, though it's not checking against platform-specific integer limits like integer overflow/wrap-around before the PJ_MIN operations.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code doesn't perform memory allocation but does copy data into a fixed-size buffer (peer_sdes_buf_). It validates the copy size against the buffer size, which aligns with the spirit of validating size parameters for memory operations, but no actual allocation occurs.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes RTCP BYE packets and must handle the packet structure consistently. However, the specification about \"consistent type handling across all processing stages\" is broader than what's shown in this single parsing function.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not use regular expressions at all. It's parsing binary RTCP packets, not processing regex patterns with embedded NUL bytes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve pattern compilers or escape sequence processing. It's parsing binary network protocol data.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code uses length-aware operations (PJ_MIN to bound slen, then pj_memcpy with explicit length) when processing potentially untrusted network input. This directly follows the principle of using length-aware string operations for security.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function appears to operate on a session-specific buffer (peer_sdes_buf_ within sess->stat), and there's no indication of shared buffer access requiring synchronization in this parsing code.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared buffer access must be protected by appropriate synchronization primitives"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code parses an RTCP BYE message but doesn't show terminal state transitions or concurrency handling. It's a simple parsing function without visible state machine transitions.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Terminal state transitions must maintain consistency invariants during concurrent oper..."
      }
    ]
  },
  "CVE-2021-46784_before_exclude_100:3e2a008b:spec": {
    "timestamp": "2026-01-17T01:11:53.817081",
    "cve_id": "CVE-2021-46784",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3e2a008b",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code processes input character data line-by-line from `inbuf` with explicit boundary checks (`llen = TEMP_BUF_SIZE - gopherState->len - 1`) before copying to `gopherState->buf` and `line`. This directly aligns with validating buffer boundaries before access.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 8,
        "reasoning": "The parser maintains buffer state invariants through `gopherState->len` and `gopherState->overflowed`. It carefully manages partial line buffering across calls and resets `gopherState->len` after processing a complete line, ensuring consistent buffer state.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 7,
        "reasoning": "The code performs encoding-specific processing (Gopher protocol parsing with TAB separators, CR/LF handling) and includes boundary checking when copying data to fixed-size buffers (`TEMP_BUF_SIZE`). However, some string operations (like `strchr`, `strtok`) on parsed fields don't explicitly validate boundaries after modification.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expressions. It processes Gopher protocol lines with simple string operations like `strchr` and `strtok`, not regex patterns.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code processes escape sequences via `rfc1738_escape_part` and `rfc1738_escape_unescaped`, but these are URL encoding functions, not pattern compilers. Boundary checking is present in buffer copies but not specifically focused on escape sequence processing.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code extensively uses length-aware operations: `memcpy` with calculated `llen`, boundary checks against `TEMP_BUF_SIZE`, and `snprintf` with explicit buffer size. This is crucial as input comes from network (potentially untrusted).",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code does not parse protocol message length fields. It processes Gopher content as a stream of lines without explicit length fields in the protocol data being validated.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses stack-allocated buffers via `LOCAL_ARRAY` (fixed size `TEMP_BUF_SIZE`) rather than dynamic allocation. However, it validates that copied data fits within these buffers, which relates to validating size parameters against usage requirements.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-46784_after_exclude_100:2f6dc6bc:spec": {
    "timestamp": "2026-01-17T01:12:31.099421",
    "cve_id": "CVE-2021-46784",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2f6dc6bc",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes input buffer `inbuf` with length `len`. It uses `memchr` and pointer arithmetic (`pos < inbuf + len`) to stay within bounds. However, there is a potential issue at `line[llen + 1] = '\\0';` where `llen` could equal `TEMP_BUF_SIZE-1`, causing an out-of-bounds write of one byte. This directly relates to validating buffer boundaries before access.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code maintains a temporary buffer `gopherState->buf` and its length `gopherState->len` to handle incomplete lines across calls. It checks `gopherState->len + llen >= TEMP_BUF_SIZE` to prevent overflow and adjusts `llen` accordingly. This is a clear effort to maintain consistent buffer state invariants during parsing input operations.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code performs encoding-specific processing (Gopher protocol to HTML conversion) and includes boundary checking (e.g., the overflow check). However, the boundary checking is not uniformly applied to all buffer accesses (e.g., the `line[llen + 1]` assignment flaw). The principle of uniform boundary checking is relevant but not fully implemented.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Encoding-specific processing must enforce uniform boundary checking"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code does not use regular expressions. It uses string functions like `strchr`, `strtok`, and `memcpy` for parsing. The specification about embedded NUL bytes in regex patterns is not applicable to this code scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not contain a pattern compiler. It does process escape sequences via `rfc1738_escape_part` and `rfc1738_escape_unescaped`, but these are library calls for URL encoding, not a pattern compilation phase with strict boundary management as implied by the specification.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted Gopher server input. It primarily uses length-aware operations like `memcpy` with calculated lengths (`llen`) and `memchr`. However, it also uses non-length-aware functions like `strchr` and `strtok` on the copied `line` buffer after null-termination, which could be problematic if the source data lacks expected delimiters, though the prior `memcpy` bounds are controlled.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not parse protocol message length fields from the input stream. The `len` parameter is provided by the caller, and there is no validation of it against integer limits. The specification is about validating received length fields, which is not present in this function.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses `xstrdup` for `escaped_selector` and a `LOCAL_ARRAY` for `line`. It does not directly perform memory allocation with size parameters that need validation against allocation limits. However, the `TEMP_BUF_SIZE` is a fixed allocation limit, and the code validates the copied data length against it (`gopherState->len + llen >= TEMP_BUF_SIZE`), which relates to validating size against usage requirements.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2018-20760_before_exclude_100:d297b14e:spec": {
    "timestamp": "2026-01-17T01:13:23.670963",
    "cve_id": "CVE-2018-20760",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d297b14e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses gf_malloc for memory allocation (e.g., for esd->URLString) but does not show explicit initialization of the entire allocated buffer before use. While strcpy is used immediately after, which writes to the buffer, the specification about full initialization before use is relevant, especially for other potential allocation patterns in similar code.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error paths (e.g., early returns GF_BAD_PARAM, GF_NOT_SUPPORTED). It must ensure that resources (like allocated memory or file handles) are properly cleaned up and object states remain consistent when errors occur. The code shows some cleanup (gf_isom_sample_del), but a comprehensive review of all error paths is needed.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This function generates SDP lines for a media file and does not directly handle network protocol input. It processes internal file structures (GF_ISOFile) rather than external network data, so the specification about validating network input before processing has very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not parse or handle protocol message length fields from external sources. It works with internal media samples and descriptors, so this specification basically doesn't apply.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory based on string lengths (e.g., strlen(sdpLine)+1). While it doesn't show explicit validation against allocation limits, the sizes are derived from controlled data (base64-encoded strings). However, the risk exists if the base64 output or other calculated sizes become excessively large, making the principle of validating size parameters moderately relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The function handles different media types (OD, Scene, Audio, Visual) and ensures ISMA compliance by checking codec types. It enforces some consistency (e.g., only one MPEG-4 visual/audio for ISMA). However, this is more about media profile compliance than low-level protocol type handling, leading to weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code uses fixed-size buffers (buf64[5000], sdpLine[5100]) for base64 encoding and SDP line formatting. It must ensure that the encoded data fits within these buffers. The function gf_base64_encode is called with a limit (2000), but the buffer sizes are fixed and may not account for all operational padding requirements with a safety margin, creating a potential buffer overflow risk. Relevance is weak but present.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code performs base64 encoding, not image compression. It does not involve encoder buffers for image compression operations, so this specification is completely irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2019-19333_before_exclude_100:17fc5fb0:spec": {
    "timestamp": "2026-01-17T01:13:39.532160",
    "cve_id": "CVE-2019-19333",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "17fc5fb0",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor operations (addition, division, etc.) and does not involve any cryptographic operations on secret values. The timing of operations is not critical for security in this context.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor computation kernel with no elliptic curve operations or cryptographic implementations of any kind.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "No cryptographic processing is present. Memory operations are related to tensor data manipulation, not secret data requiring constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code performs bounds checking before writing/accessing data. The `FastBoundsCheck` validates indices against tensor dimensions before accessing `rhs_ref.coeff(idx)`, preventing out-of-bounds writes/reads. This aligns with the principle of validating available space before writing.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before writing"
      },
      {
        "score": 5,
        "reasoning": "While the code validates tensor shapes and indices, it is not dealing with protocol message generation or output buffer capacity in a network/communication protocol context. The allocation for `output_values` uses `ctx->allocate_output` which handles capacity internally.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: All protocol message generation must validate output buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "The code validates tensor boundaries (dimensions) but does not involve marker segments or specific protocol parsing. The relevance is weak as the specification is for a specific protocol context (e.g., image/video formats).",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Marker segment writers must enforce strict boundary validation"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code extensively validates input ranges: tensor shapes, indices matching dimensions, non-zero shape elements, broadcast compatibility, and explicit bounds checking for each index access. It also handles the edge case of division by zero explicitly (`if (op_is_div)`).",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates structural constraints (tensor shapes, indices, dimensions) before computation, similar to validating \"codebook\" structures. However, it is not specifically about codebook processing, so the connection is partial.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      }
    ]
  },
  "CVE-2018-20760_after_exclude_100:9fdcdd99:spec": {
    "timestamp": "2026-01-17T01:13:42.285747",
    "cve_id": "CVE-2018-20760",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9fdcdd99",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses gf_malloc for memory allocation (for esd->URLString) but does not show explicit initialization of the entire allocated buffer before use. While strcpy is used immediately after, ensuring the string portion is initialized, the specification about full initialization is relevant for general secure coding practice, though the immediate strcpy mitigates the risk in this specific instance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error paths (e.g., returning GF_BAD_PARAM, GF_NOT_SUPPORTED). It modifies the 'iod' object (adding ESDs, setting URLString) before potential failure points. If an error occurs after partial modifications (e.g., memory allocation failure for URLString), the object state might be left inconsistent. The code does not clearly rollback changes on errors, making this specification moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "The code generates SDP lines and IOD data for hinting, but it does not directly handle network protocol input. It processes internal file structures (GF_ISOFile) and track data. Input validation is done via API calls (e.g., gf_isom_get_track_count), but not network protocol validation. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol message length fields from external sources. It handles internal size values (like samp->dataLength, size64) for base64 encoding and buffer allocation. While integer limits could be relevant for large data, the specification is about network protocol message length fields, which are not present. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code allocates memory based on string length (strlen(sdpLine)+1) for esd->URLString. It does not explicitly validate if this size is within safe allocation limits or against usage requirements (though the string is generated internally). The buffer buf64 (5000 bytes) is used for base64 encoding with a fixed size, which could overflow if size64 exceeds 5000. The gf_base64_encode call uses limit 2000, but buf64 is 5000, showing some consideration but not rigorous validation. Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different stream types (OD, scene, audio, visual) and ensures ISMA compliance by checking objectTypeIndication. It maintains consistent type handling for IOD generation. However, this is more about media type consistency than low-level protocol type handling. Weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code uses fixed-size buffers (buf64[5000], sdpLine[5100]) for base64 encoding and SDP line formatting. It ensures base64 output fits by passing size limit (2000) to gf_base64_encode, but the buffer is larger (5000). However, sprintf into sdpLine could overflow if the formatted string exceeds 5100 bytes (though risk is low given controlled inputs). The specification about padding and safety margin is weakly relevant as buffers are fixed-size with some bounds checking.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform image compression operations. It deals with MP4 file hinting, SDP generation, and base64 encoding. No encoder buffers for image compression are involved. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2019-19333_after_exclude_100:90260a88:spec": {
    "timestamp": "2026-01-17T01:13:54.973987",
    "cve_id": "CVE-2019-19333",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "90260a88",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor operations with no cryptographic operations on secret values. It's a numerical computation kernel for tensor operations, not cryptographic processing.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or cryptographic operations. It's performing tensor arithmetic operations in a machine learning framework.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No cryptographic processing or secure memory operations are present. The code handles tensor data without constant-time requirements.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 8,
        "reasoning": "The code performs bounds checking before array access (FastBoundsCheck) and validates indices before writing to output buffers. It also validates tensor dimensions and shapes before operations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before writing"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates tensor dimensions and allocates output buffers with proper size checking (ctx->allocate_output), though not exactly protocol message buffers.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: All protocol message generation must validate output buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates tensor boundaries and indices, but doesn't deal with marker segments or structured protocol data specifically.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Marker segment writers must enforce strict boundary validation"
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code extensively validates input ranges (indices bounds checking), handles edge cases (division by zero check), validates tensor shapes and dimensions, and checks for invalid indices.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates structural constraints (tensor shapes, dimensions, indices) before computation, similar to codebook structural validation principles.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      }
    ]
  },
  "CVE-2016-7532_before_exclude_100:ca7f2f65:spec": {
    "timestamp": "2026-01-17T01:14:35.268909",
    "cve_id": "CVE-2016-7532",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ca7f2f65",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses memset to initialize several structures (bounding_box, bounds, page, command) before use, which aligns with the principle of initializing memory. However, it also declares arrays like 'filename' and 'input_filename' without explicit initialization before certain uses (e.g., as arguments to functions like CopyMagickString). The initialization is generally good but not fully comprehensive for all declared variables, making it highly relevant but not perfect.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code demonstrates strong error handling with consistent object state maintenance. For example, when status checks fail (e.g., OpenBlob, AcquireUniqueSymbolicLink), it properly cleans up resources (DestroyImage, ThrowFileException) before returning NULL. Multiple cleanup paths ensure resources like images, strings, and unique files are released, maintaining consistency.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This specification is about network protocol handlers validating input before processing. The target code reads a PCL image file from local storage via blob operations and delegates to GhostPCL. There is no network protocol handling involved, making it very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code parses PCL file format elements (CropBox, MediaBox) using sscanf on command buffers. It validates structural relationships implicitly by checking if count == 4 after parsing. However, validation is limited to format parsing; it doesn't deeply verify all structural relationships between header fields (e.g., bounds consistency). Moderate relevance as it performs some validation but not comprehensively.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The code uses arrays like 'command' with a fixed size MaxTextExtent. Bounds are checked with ((size_t) (p-command) < (MaxTextExtent-1)) during character accumulation, preventing overflow. However, this check is only in the loop; other array uses (e.g., FormatLocaleString) rely on MaxTextExtent but don't have explicit runtime bounds validation. Partial relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The code implements comprehensive error handling with resource cleanup for file format processing. It cleans up images (DestroyImage), strings (DestroyString), unique files (RelinquishUniqueFileResource), and image info (DestroyImageInfo) across multiple error paths (e.g., delegate_info NULL, ReadImage failure). This aligns strongly with the specification.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "As an image format parser for PCL, the code validates critical header-like fields (CropBox, MediaBox) by parsing them and checking count == 4. It also checks page width/height before proceeding. However, validation is not exhaustive (e.g., no sanity checks on parsed float values). Highly relevant but not complete.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation with functions like malloc; it uses stack arrays and library functions (e.g., AcquireString) for dynamic allocation. There is no pre-validation of size parameters for allocations (e.g., MaxTextExtent is a compile-time constant). Weak relevance because memory allocation is present but not the main focus, and pre-validation is minimal.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2016-5844_before_exclude_100:04f04d4a:spec": {
    "timestamp": "2026-01-17T01:15:25.997576",
    "cve_id": "CVE-2016-5844",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "04f04d4a",
    "scores": [
      {
        "score": 1,
        "reasoning": "The specification is about view-based data access and privilege checks in a database context. The target code is a TensorFlow shape inference function for a transpose operation, dealing with tensor dimensions and indices. There is no concept of database views, ownership, or privilege checks.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The specification mentions security-critical state transitions and privilege context. The code performs shape inference and validation (e.g., checking permutation indices are within bounds), which is a form of state validation. However, it does not involve security privileges, access control, or user contexts. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The specification is explicitly about SQL protocol implementations and view security. The target code is a numerical computing shape function with no relation to SQL, databases, or view semantics.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about memory allocation and size tracking. The code uses `std::vector` which manages its own memory, and resizes it based on the `rank` variable. There is a weak connection because the code ensures the vector size matches the derived rank, but it does not perform low-level memory allocation or explicit size tracking itself.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "The specification is about resource management and invariant consistency. The code validates several invariants: that the input rank matches the permutation length, that permutation indices are within bounds, and handles unknown shapes gracefully. This maintains the consistency of the shape inference state. The connection is moderate as the principle of validating invariants applies.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 1,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not parse regular expressions or process string patterns in any way. It works with tensor shapes and integer permutation arrays.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The specification is about pattern compilers and escape sequences. The code does not compile patterns, process escape sequences, or deal with string parsing at all.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification is about using length-aware string operations for untrusted input. The code processes a tensor (`perm`) which could be considered untrusted input. It uses the known `rank` to bound the iteration when extracting data (`AsInt64`). However, it does not process strings; it processes integer arrays. The connection is weak but present in the principle of bounding operations based on known size.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2016-5844_after_exclude_100:9d14bbe4:spec": {
    "timestamp": "2026-01-17T01:15:27.925737",
    "cve_id": "CVE-2016-5844",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d14bbe4",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a TensorFlow shape inference function for a transpose operation. It does not involve view-based data access, database views, or privilege checks. The specification is about database security and is completely unrelated.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code performs shape inference and validation. It does not handle security-critical state transitions, privilege contexts, or resource management invariants in the sense implied by the specification (which appears to be about system/privilege state).",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code is not related to SQL protocols, database access, or view security semantics. It is a mathematical tensor shape calculation function.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code resizes a `std::vector` based on a calculated `rank`. While this involves memory allocation and size tracking, the specification's focus on \"consistent size tracking\" likely pertains to lower-level allocator security or avoiding size mismatches that lead to overflows. This code uses safe C++ STL containers, so the connection is indirect and the risk is low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function validates the `perm` tensor's values are within the valid range (`-rank < in_idx < rank`). This maintains the invariant that output dimensions map to valid input dimensions. However, the specification's context of \"resource management operations\" is broader and more systemic than this simple index validation.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain or call any regular expression parsers. It parses integer tensors, not string patterns.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain or call any pattern compilers or process escape sequences. It handles integer data from tensors.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Moderate/Weak relevance. The code processes the `perm` tensor, which is potentially untrusted user input. It uses length-aware operations: it validates the tensor's number of elements (`rank`) against the input rank and uses this known `rank` to safely iterate and access the `data` vector. The `AsInt64` helper (not shown) presumably also uses the length `rank`. This aligns with the principle of using length-aware operations for untrusted input, though the data is integers, not strings.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2022-32546_after_exclude_100:f3001301:spec": {
    "timestamp": "2026-01-17T01:15:30.706561",
    "cve_id": "CVE-2022-32546",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f3001301",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses several fixed-size character arrays (e.g., command, filename, geometry) and performs string operations like `*p++=(char) c;` and `sscanf`. While some buffers are zero-initialized via `memset`, the loop that fills the `command` buffer only checks `(size_t) (p-command) < (MaxTextExtent-1)` before continuing, but does not guarantee null-termination before the `LocaleNCompare` calls if the buffer isn't full. This relates to the need for proper initialization before use, though the risk is more about bounds than uninitialized memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error handling paths (e.g., `OpenBlob` failure, `AcquireUniqueSymbolicLink` failure, `delegate_info` NULL). It generally attempts to clean up resources (`DestroyImage`, `DestroyString`, `RelinquishUniqueFileResource`). However, there are early returns without cleanup (e.g., if `delegate_info` is NULL, `image` is destroyed but `input_filename` symbolic link may not be cleaned up). Consistency could be improved.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This specification is about network protocol handlers. The target code reads a PCL image file from local storage via `OpenBlob` and processes it, with no network protocol handling involved. Therefore, it is not relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2018-20750_before_exclude_100:153036c0:spec": {
    "timestamp": "2026-01-17T01:15:43.021526",
    "cve_id": "CVE-2018-20750",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "153036c0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs arithmetic operations (e.g., `bytes += (*i)->offset;`, `size = (*i)->data + bytes - 3;`, `bytes += dire->size + 1;`) that involve values read from the filesystem. While there is some validation (e.g., checking `dir_count > SQUASHFS_DIR_COUNT` and `dire->size >= SQUASHFS_NAME_LEN`), there is no explicit validation that these arithmetic operations will not overflow the boundaries of their types (e.g., integer overflow for `bytes`, `size`). This is directly relevant to HS-LOGIC-001.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 9,
        "reasoning": "The code is a filesystem parser (SquashFS) and validates several structural fields: it checks `dir_count > SQUASHFS_DIR_COUNT` and `dire->size >= SQUASHFS_NAME_LEN`. However, it could do more (e.g., validate `start` against disk size, validate `dirh.start_block`). The principle of validating structural fields against physical/logical constraints is strongly applied.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 5,
        "reasoning": "The code performs bounds checking for on-disk structures: it validates `dir_count` and `dire->size`. It also uses `memcpy` with a calculated size (`dire->size + 1`) after validation, which is a form of bounds checking. The loop condition `while(bytes < size)` also acts as a bound. This aligns strongly with HS-IO-003 for filesystem operations.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "The code initializes the `dir` struct members after allocation, and the `buffer` is used via `memcpy` and assignment. However, `buffer` is not explicitly initialized before use, but it is written to via `SQUASHFS_SWAP_DIR_ENTRY` and `memcpy`. The `dire->name` null-termination is done. The relevance is weak because the main concern of HS-MEM-001 is about ensuring all allocated memory is initialized to a known state before use to prevent information leaks, which is not a primary focus here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has an error handling path labeled `corrupted:`. In that path, it frees `dir->dirs` and `dir` before returning NULL. This maintains a consistent state (no memory leak). However, if `realloc` fails, it calls `EXIT_UNSQUASH` which likely terminates the program, so there's no state to maintain. The principle is moderately relevant.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "HS-IO-003 is about network protocol handlers validating input. The target code is a filesystem parser, not a network protocol handler. The underlying principle of input validation is similar, but the context and specific threats (network vs. filesystem) differ significantly. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code declares `buffer` with the `__attribute__((aligned))`, which explicitly ensures the buffer meets platform alignment requirements. This is a direct and perfect match for HS-MEM-001 regarding alignment, as misaligned access could cause crashes on some architectures.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-002 is about network protocol implementations validating message structure. The code is a filesystem parser, not a network protocol. While both involve parsing structured data, the domain, attack vectors, and specific validation requirements are different. Relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      }
    ]
  },
  "CVE-2017-14164_after_exclude_100:667fbade:spec": {
    "timestamp": "2026-01-17T01:16:34.200841",
    "cve_id": "CVE-2017-14164",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "667fbade",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs arithmetic operations (e.g., `bytes += (*i)->offset;`, `size = (*i)->data + bytes - 3;`, `bytes += dire->size + 1;`) that involve values read from the filesystem. While there is some validation (e.g., checking `dir_count > SQUASHFS_DIR_COUNT` and `dire->size >= SQUASHFS_NAME_LEN`), the arithmetic operations themselves are not explicitly validated for overflow or underflow before calculation, which could lead to security issues. The specification directly applies.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 9,
        "reasoning": "The code is a filesystem parser (SquashFS) and validates several structural fields: it checks `dir_count` against `SQUASHFS_DIR_COUNT` and `dire->size` against `SQUASHFS_NAME_LEN`. It also validates the directory entry name via `check_name()`. These are validations against logical/structural constraints, making the specification highly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 9,
        "reasoning": "The code performs strict bounds checking for on-disk structures: it validates `dir_count` and `dire->size` to prevent buffer overflows. The `memcpy` uses `dire->size + 1` as length, which is validated beforehand. The specification is directly applicable to this filesystem operation code.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "The code initializes the `dir` struct after malloc, setting fields like `dir_count`, `cur_entry`, etc. However, the `dir->dirs` pointer is initially set to NULL and later reallocated. The `buffer` array is not explicitly initialized but is written to via `SQUASHFS_SWAP_DIR_ENTRY` and `memcpy`. The specification has weak relevance because while some initialization occurs, it's not the primary focus or flaw in the code.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has an error handling path labeled `corrupted:` that frees `dir->dirs` and `dir` before returning NULL. This maintains consistency by cleaning up allocated memory. However, it does not handle all possible error paths (e.g., `realloc` failure calls `EXIT_UNSQUASH` which likely exits the program). The specification is moderately relevant as error handling is present but not fully consistent.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol handlers, but the target code is a filesystem parser. There is no network input processing. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code declares `buffer` with `__attribute__((aligned))`, which explicitly respects platform alignment requirements for the structure. This is a direct and correct application of the specification, making it highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol implementations validating message structure. The target code is a filesystem parser, not a network protocol handler. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      }
    ]
  },
  "CVE-2021-24045_before_exclude_100:e1c91f37:spec": {
    "timestamp": "2026-01-17T01:16:47.934079",
    "cve_id": "CVE-2021-24045",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e1c91f37",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code evaluates unary operators on literals (numbers, booleans, null, undefined) and does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code performs simple arithmetic and type operations on literal values. It does not compile patterns or process escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The code does not process strings from potentially untrusted input. It only creates literal strings for the `typeof` operator based on known literal kinds.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code performs basic arithmetic and logical operations, not cryptographic operations on secret values. Timing side-channels are not a concern here.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code does not implement elliptic curve cryptography or any cryptographic operations requiring side-channel resistance.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform secure memory operations or cryptographic processing. It manipulates literal values in a compiler IR builder.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code creates literal objects via a builder (`getLiteralNumber`, `getLiteralString`, etc.), which may involve memory allocation. However, the specification focuses on consistent size tracking for security, which is not the primary concern or visible in this high-level logic.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The function manages the creation of literal resources (numbers, strings, etc.) and must maintain consistency (e.g., returning the correct literal type for each operand kind). This loosely relates to maintaining invariant consistency in resource management, but the specification is broader and more system-level.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2021-24045_after_exclude_100:df16f281:spec": {
    "timestamp": "2026-01-17T01:16:51.971286",
    "cve_id": "CVE-2021-24045",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "df16f281",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code evaluates unary operators on literals and does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code performs constant folding for unary operators and does not involve pattern compilers or processing of escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The code operates on typed literals within a compiler IR and does not process untrusted string inputs or use string processing functions.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code performs arithmetic and logical operations on constants and does not involve cryptographic operations or secret values.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is unrelated to elliptic curve implementations or cryptographic side-channel resistance.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform secure memory operations or cryptographic processing requiring constant-time properties.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve memory allocation operations or size tracking; it only creates literal values via a builder.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 2,
        "reasoning": "The code maintains consistency in evaluating unary operators, which is a weak connection to resource management and invariant consistency. However, it does not manage external resources like files or network connections.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2019-20637_before_exclude_100:e9d4ec47:spec": {
    "timestamp": "2026-01-17T01:17:08.919050",
    "cve_id": "CVE-2019-20637",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e9d4ec47",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It searches for a colon character using strchr and processes HTTP header flags. Embedded NUL bytes are not relevant to this string search operation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It performs simple string lookup and flag checking for HTTP headers.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code uses strchr on fm->hd[u].b without checking for null termination or length boundaries. If this input is untrusted (e.g., from network), using length-aware operations would prevent buffer over-read vulnerabilities.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol message length fields. It checks HTTP header filtering flags and searches for colon characters in header strings.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "The code does not perform memory allocation operations. It only accesses existing structures and checks flags.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes HTTP protocol headers and checks filtering flags. While not about type handling per se, it does involve protocol parsing logic that should maintain consistency in how headers are interpreted.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code accesses fm->hd[u].b without validating buffer boundaries. Before using strchr, it should ensure the string is properly bounded to prevent reading beyond allocated memory, especially with untrusted input.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code parses HTTP header input and should maintain consistent buffer state. The use of strchr on potentially untrusted buffers without boundary checks could violate buffer state invariants if the string is not properly terminated.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-38150_after_exclude_100:e69db6cc:spec": {
    "timestamp": "2026-01-17T01:17:25.141025",
    "cve_id": "CVE-2022-38150",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e69db6cc",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It performs string searching with strchr and header flag lookup. Embedded NUL bytes are not specifically handled, but this is not a regex context.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It is a simple HTTP header filtering function that checks flags.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform memory allocation operations. It only accesses existing structures and performs checks.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "The code accesses the header string fm->hd[u].b without explicit boundary validation before passing it to strchr. If the string is not properly terminated, this could lead to out-of-bounds reads. Buffer boundary validation is missing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-25139_before_exclude_100:4a0c2f43:spec": {
    "timestamp": "2026-01-17T01:18:20.175043",
    "cve_id": "CVE-2022-25139",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4a0c2f43",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is an async/await fulfillment handler in a VM, dealing with stack frames, context switching, and function calls. It does not parse or process regular expressions, and there is no handling of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or the processing of escape sequences. It is focused on VM execution flow and async context management.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "There is no string processing of untrusted input in this function. The operations are on VM internal structures like frames, values, and contexts.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The function does not parse protocol messages or validate length fields. It handles internal VM state for async operations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "While the function itself does not perform memory allocation, it calls `njs_async_context_free` which likely involves memory deallocation. The relevance is very indirect and weak.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The function manages VM state and ensures consistent handling of async contexts, promises (capability), and error values. It maintains type consistency for values (e.g., checking if a value `njs_is_error`). This has moderate relevance to enforcing consistent type handling.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error handling paths (`failed` label, checks for `NJS_ERROR`, `njs_is_memory_error`). It must ensure consistent object state when errors occur, such as properly calling the promise's reject function and freeing the async context (`ctx`) in both success and error paths to avoid leaks or inconsistent state.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2017-18249_before_exclude_100:492c4252:spec": {
    "timestamp": "2026-01-17T01:18:28.209192",
    "cve_id": "CVE-2017-18249",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "492c4252",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process userspace-provided array lengths. It is a cleanup function for a network device, dealing with internal resource deallocation and state management, not input validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The code does not handle protocol messages. It is a close/cleanup routine that unregisters a network device and frees internal buffers, with no parsing of variable-length data structures.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "The code frees buffers (`kfree`) but does not allocate them. The specification about allocation with worst-case input scenarios is not relevant to this deallocation and shutdown path.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "The code is for a TTY line discipline (sixpack) and network device, not USB request processing. The specification is completely unrelated to the code's context and functionality.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 1,
        "reasoning": "The code is for a TTY line discipline (sixpack) and network device, not USB/IP protocol. The specification is completely unrelated to the code's context and functionality.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      },
      {
        "score": 1,
        "reasoning": "The code manages the shutdown state of a network device, not USB request state transitions. The specification is completely unrelated to the code's context and functionality.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: USB request state transitions must maintain consistent buffer-length relationships"
      },
      {
        "score": 8,
        "reasoning": "The code uses a lock (`write_lock_irq`) to atomically check and set `tty->disc_data` to NULL, which is a critical step in preventing concurrent access during cleanup. This aligns with the principle of atomic check-and-set under lock for resource state management.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 9,
        "reasoning": "The code demonstrates careful shared state transition management. It uses a lock to atomically clear `tty->disc_data`, employs refcounting (`refcount_dec_and_test`) and a completion (`wait_for_completion`) to ensure all users finish, and stops the network queue to prevent access to freed buffers. This maintains consistency invariants across access paths during shutdown.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2014-0196_after_exclude_100:0b994407:spec": {
    "timestamp": "2026-01-17T01:18:29.352579",
    "cve_id": "CVE-2014-0196",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0b994407",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a network driver close function, not processing userspace-provided array lengths. It deals with internal cleanup of kernel structures (timers, buffers, netdev). The specification about validating userspace array lengths against system constraints is weakly connected to this scenario.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code does not handle protocol messages or variable-length components. It's a cleanup routine that frees allocated buffers and unregisters network devices. The protocol validation specification has weak relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "While the code frees buffers (sp->rbuff, sp->xbuff), it doesn't show their allocation. The specification about accounting for worst-case input scenarios during allocation has some weak relevance since buffer management is involved, but the actual allocation logic isn't visible here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code has no USB-related functionality. It's part of a sixpack network protocol driver (serial line IP). USB request processing specification is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "This is not USB/IP protocol code. The sixpack protocol is a serial line encapsulation protocol, not USB/IP. The specification is completely irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      },
      {
        "score": 5,
        "reasoning": "No USB request state management is present in this code. The function manages network device cleanup, not USB request state transitions.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: USB request state transitions must maintain consistent buffer-length relationships"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code uses write_lock_irq() to protect the tty->disc_data pointer during cleanup, ensuring atomic access to this shared resource. The refcount check and wait_for_completion() also help manage concurrent access during shutdown.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code maintains consistency invariants for shared state: 1) Uses locking to protect tty->disc_data, 2) Uses refcounting (sp->refcnt) to ensure all users finish before cleanup, 3) Uses completion (sp->dead) for synchronization, 4) Stops network queue before cleanup to prevent race conditions with buffer access.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2017-18249_after_exclude_100:af4cfa76:spec": {
    "timestamp": "2026-01-17T01:18:38.896835",
    "cve_id": "CVE-2017-18249",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "af4cfa76",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It handles async/await fulfillment in a JavaScript-like VM, focusing on frame and context switching.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or protocol parsing. It manages execution context and function calls within a VM.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the code may process values (including strings), it does not show explicit string operations like copying or concatenation. The primary operations are value assignments and function calls within controlled VM structures.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code does not parse protocol messages or validate length fields. It operates on internal VM structures (frames, contexts) without external protocol handling.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code does not directly show memory allocation, but it manipulates VM levels and frames, which could involve allocation elsewhere. Proper validation of sizes for these structures is important for security, but not directly visible here.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code handles JavaScript-like values and async contexts, requiring consistent type handling (e.g., checking if a value is an error). However, it's not a full protocol implementation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code assigns values to VM structures (e.g., *njs_scope_value(...) = *value), which is initialization, but not memory allocation. Full initialization of allocated memory is a broader concern not directly addressed.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code has multiple error handling paths (failed label, ret checks) that must maintain consistent VM state (restoring levels, frames, freeing contexts). For example, it restores vm->levels and frames after operations and ensures njs_async_context_free is called on both success and error paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2010-1311_before_exclude_100:612eefe8:spec": {
    "timestamp": "2026-01-17T01:19:12.479339",
    "cve_id": "CVE-2010-1311",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "612eefe8",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about handling embedded NUL bytes in regular expression patterns. The target code does not parse regular expressions or process input patterns; it constructs segment metadata from a binary structure. The connection is very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences. It is a binary parsing function with no such logic.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses `r_str_newf` to create a string, which is a format string function, not a length-aware string operation (like `strncpy`). The input data comes from the binary's internal structures (`segment_entries`), which may be considered untrusted if the binary file is user-supplied. There is a weak connection because string formatting could have risks, but the specification specifically advocates for length-aware operations, which are not present.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code reads fields from a binary structure (`se->offset`, `se->length`, `bin->alignment`) and performs arithmetic (`(ut64)se->offset * bin->alignment`) to calculate a physical address. This resembles validating/using length/offset fields from a protocol or file format. There is a moderate relevance because integer overflows in this calculation should be prevented, aligning with the spirit of validating integer fields against limits, though not explicitly done here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory for `RBinSection` using `R_NEW0`. While it checks if `bs` is NULL, it does not validate the size parameters (like `bs->size` or `bs->vsize`) derived from untrusted binary data against allocation limits before they might be used later. This is directly relevant to the specification's requirement to validate size parameters against allocation and usage limits.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code processes binary segment entries and translates flags into permissions and names. It must handle the data types (e.g., flags, offsets) consistently. There is moderate relevance because inconsistent type handling (e.g., sign extension, integer width) in the translation could cause issues, though the specification is more focused on network protocols.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code uses `R_NEW0` which zero-initializes the allocated memory for `RBinSection`. This directly and fully complies with the specification that memory allocations must be fully initialized before use.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "In the error path where `R_NEW0` fails (returns NULL), the function returns the partially populated `segments` list. This leaves the function's output in an inconsistent state (a list that may have some segments but is missing the current one, and `bin->segments` is not set). This directly relates to the specification about maintaining consistent object states in error handling paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-44512_after_exclude_100:5d54dcda:spec": {
    "timestamp": "2026-01-17T01:20:08.478549",
    "cve_id": "CVE-2021-44512",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5d54dcda",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It processes command-line arguments using getopt, which is not a regex parser. The specification about embedded NUL bytes in regex patterns is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not contain a pattern compiler or process escape sequences. It handles simple command-line option strings. The specification is not relevant to this scenario.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The code uses xstrdup(optarg) which copies null-terminated strings. While optarg originates from argv (user input), the code does not use explicit length-aware operations. However, the risk is limited as argv strings are provided by the system. There is moderate relevance as the principle of careful handling of user input applies.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code does not parse protocol messages with length fields. It processes command-line arguments and sets configuration values. The specification about validating protocol length fields is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code uses xstrdup (which likely wraps malloc/strdup) and atoi for integer conversion. atoi does not validate input and can overflow. The port numbers converted via atoi are later used, which could lead to issues if values exceed valid port ranges or integer limits. This aligns with the need to validate size/range parameters.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 4,
        "reasoning": "The code is a configuration setup routine, not a full protocol implementation. It does parse command-line arguments to set various typed settings (strings, integers, booleans). There is weak relevance regarding consistent type handling when converting optarg strings to different types (e.g., via atoi).",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes a global settings structure (tmate_settings) via command-line arguments. It does not show the allocation of tmate_settings itself. If the struct was allocated earlier and not fully initialized, using its members could be risky. There is weak relevance regarding ensuring struct fields are initialized before use, especially since default values (like tmate_host) are conditionally set later.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The code has several error paths (usage() return, tmate_fatal calls on mkdir/chmod/check failures). It must ensure that error handling maintains consistent state (e.g., not leaving partially created directories or inconsistent settings). The calls to tmate_fatal likely terminate the program, which simplifies state consistency. Moderate relevance as error handling is present and should be reviewed for state consistency.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-1382_after_exclude_100:e17fa7c7:spec": {
    "timestamp": "2026-01-17T01:20:09.552249",
    "cve_id": "CVE-2022-1382",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e17fa7c7",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about handling embedded NUL bytes in regular expression patterns. The target code does not parse regular expressions or user-provided patterns; it processes internal binary structures (segment entries) from a NE file. The connection is very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The specification concerns pattern compilers and escape sequence boundaries. The target code does not compile patterns or process escape sequences. It is parsing fixed binary structures. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification advises using length-aware string operations for untrusted input. The code uses `r_str_newf` to create a segment name, which is a formatted string built from internal binary data. While the input data (the NE file) could be considered untrusted, the code does not perform typical string processing like copying or comparing. The relevance is weak.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields. The code processes binary structures (`NE_image_segment_entry`) which contain fields like `length` and `offset`. These fields are used to calculate memory offsets and sizes (`bs->size`, `bs->paddr`). While not a network protocol, the principle of validating these fields against reasonable limits (e.g., to prevent integer overflows in the `bs->paddr` calculation) is moderately relevant for security.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires validating size parameters for memory allocation and usage. The code uses `bs->size = se->length` and `bs->paddr = (ut64)se->offset * bin->alignment`. The values `se->length`, `se->offset`, and `bin->alignment` come from an untrusted file and are used without validation. An excessively large `se->offset` or `bin->alignment` could cause an integer overflow in the `paddr` calculation, leading to incorrect pointer arithmetic later. This is a direct security concern. The relevance is strong.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about consistent type handling in protocols. The code deals with binary structures and performs type conversions (e.g., `(ut64)se->offset`). Ensuring these conversions are safe and consistent (e.g., that `se->offset` is a 16-bit value as per the NE format) is a weak form of this principle. The connection is moderate but not central.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification mandates that memory allocations be fully initialized before use. The code uses `R_NEW0 (RBinSection)`, which is a macro that allocates and zero-initializes memory. This is a good practice that directly follows the specification to prevent information leaks from uninitialized memory. The relevance is highly direct.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The specification requires error handling paths to maintain consistent object states. The code has an error path: if `R_NEW0` fails (returns NULL), it returns the partially populated `segments` list. This leaves the `bin->segments` pointer unassigned (the assignment happens later), which is consistent in this case. However, returning a partial list on allocation failure might leave the caller with an incomplete state. The principle of managing state on error is strongly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2011-3603_before_exclude_100:d39935c0:spec": {
    "timestamp": "2026-01-17T01:20:11.665541",
    "cve_id": "CVE-2011-3603",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d39935c0",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain any regular expression parsing logic. Input is processed via `getopt` for command-line arguments, which handles NUL bytes differently (as argument terminators). The specification's core concern is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It parses simple command-line switches. The specification's focus on pattern compilers and escape sequence boundaries is irrelevant to this code scenario.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The code uses `xstrdup(optarg)` and `atoi(optarg)` on user-provided command-line arguments (`argv`), which is a form of untrusted input. While `getopt` ensures `optarg` is null-terminated, `atoi` does not perform bounds checking and is not length-aware, which could lead to issues. The principle of careful handling of untrusted input is moderately relevant.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 4,
        "reasoning": "The code does not parse protocol messages with length fields. It handles command-line arguments for configuration. The specification's focus on protocol message length validation is not directly applicable, though the general concept of validating numeric input (like port numbers) is weakly connected.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code uses `xstrdup` (which likely wraps `malloc`/`strdup`) and `atoi`. While the allocation size is derived from string length, there is no visible validation of the numeric arguments (e.g., port numbers from `atoi(optarg)`) against reasonable limits before use. The principle of validating size/ numeric parameters is moderately relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code configures settings for a subsequent protocol server (`tmate_ssh_server_main`). It does not implement the protocol itself. Ensuring consistent type handling (e.g., port numbers as integers) is a weak concern here, as the main protocol logic is elsewhere.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes a settings struct (`tmate_settings`) via command-line arguments. It's unclear if all fields are initialized before use (e.g., if `tmate_settings` is pre-zeroed). The `atoi` calls could leave values undefined on conversion failure. The principle of ensuring memory/struct fields are initialized is weakly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has several error paths: `mkdir`/`chmod` failures call `tmate_fatal`, and `usage()` is called on invalid options. The `tmate_fatal` function likely terminates the program, so object state consistency may not be a concern. However, the general need for clean error handling is moderately relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2011-1003_before_exclude_100:4bd4b3af:spec": {
    "timestamp": "2026-01-17T01:20:19.010217",
    "cve_id": "CVE-2011-1003",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4bd4b3af",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process any protocol messages or validate length fields. It parses a Mach-O file buffer, which is a binary format, not a network protocol. The specification about validating protocol message lengths against integer limits is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs memory allocations (e.g., `R_NEW0`, `r_list_new`) and parses data structures from a buffer (`r_cf_value_dict_parse`). While there is some size validation in the `prelink_range->range.size` check, the core parsing functions (like `MACH0_(new_buf)` and `r_cf_value_dict_parse`) likely handle size parameters internally. The principle of validating size parameters against allocation limits and usage requirements is strongly relevant to this file parsing context.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 10,
        "reasoning": "This specification is highly relevant. The function has a complex error handling path labeled `beach`. It must ensure consistent object states (like freeing allocated buffers and objects) when failures occur at different points. The code shows careful cleanup (`R_FREE`, `r_buf_free`, `MACH0_(mach0_free)`) in the error path, but there is a potential flaw: at the `beach` label, it accesses `obj->cache_buf` after a failure path where `obj` itself may be NULL (e.g., if `R_NEW0` fails). This directly relates to the specification's requirement for maintaining consistent object states in error paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2011-1003_after_exclude_100:4512c917:spec": {
    "timestamp": "2026-01-17T01:20:55.794465",
    "cve_id": "CVE-2011-1003",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4512c917",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages or validate length fields. It parses a Mach-O file buffer, which is a binary format, not a network protocol. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code performs memory allocations (e.g., R_NEW0) and parses data structures (e.g., r_cf_value_dict_parse) based on sizes derived from the binary file (prelink_range->range.size). While there is some validation (checking if size > 0), the code does not explicitly validate these size parameters against platform allocation limits or subsequent usage requirements before operations like parsing, which could lead to issues. The principle of validating size parameters is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code does not implement a network or communication protocol. It handles a static binary file format (Mach-O kernel cache). The specification about consistent type handling across protocol stages is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use or contain any regular expression parsers. The specification is completely irrelevant to this code scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain pattern compilers or process escape sequences. The specification is completely irrelevant to this code scenario.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes a binary buffer (RBuffer *buf/fbuf) which could be considered untrusted input from a file. However, it primarily uses buffer offset/size operations and structured parsing functions (like MACH0_(new_buf) and r_cf_value_dict_parse) rather than traditional C string functions. The general principle of being careful with untrusted input has weak relevance, but the specific guidance on length-aware string operations is not directly applicable.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code uses R_NEW0 which zero-initializes memory for the RKernelCacheObj. This is good practice. However, other allocated structures (like main_mach0 from MACH0_(new_buf)) may or may not be fully initialized internally. The principle of initializing memory before use is strongly relevant, as failure to do so could lead to information leaks or undefined behavior when the structures are used later.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (goto beach) where it must free allocated resources (R_FREE, r_buf_free, MACH0_(mach0_free)) and ensure object states (like obj->cache_buf) are consistent before returning failure. The cleanup logic attempts to maintain consistency, making the specification on error handling paths highly relevant. However, the scenario is not extremely complex.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-37848_before_exclude_100:27abcad5:spec": {
    "timestamp": "2026-01-17T01:21:55.441837",
    "cve_id": "CVE-2021-37848",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "27abcad5",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code receives a user-provided password buffer and its length. While the length parameter is used in digest and PBKDF2 operations, there is no explicit validation against system constraints (e.g., maximum password length) before processing. This directly relates to the specification's requirement to validate user-provided lengths.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The code does not handle protocol messages or variable-length components in a protocol context. It processes a password buffer and compares hashes, which is a local authentication function, not a network protocol handler.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol message length fields. The `length` parameter is a simple size_t for a password buffer, not a field extracted from a protocol message.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via `calloc` using `hash_len * 2`. It validates the allocation success but does not explicitly validate that `hash_len` is within reasonable bounds before the multiplication (to prevent integer overflow) or against system allocation limits. This relates directly to validating size parameters.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles two different cryptographic paths (PBKDF2 and digest). It maintains consistency within each branch (e.g., using `hash_len` appropriately). However, the specification focuses on protocol type handling, which is not the primary concern here. There is weak relevance due to the dual-mode cryptographic logic.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsers. It processes password data directly for hashing/comparison.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is a password verification function using cryptographic hashing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-37848_after_exclude_100:3e487a76:spec": {
    "timestamp": "2026-01-17T01:22:04.856904",
    "cve_id": "CVE-2021-37848",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3e487a76",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code receives a user-provided password buffer and its length. While it uses the `length` parameter directly in cryptographic operations (`digest_digest`, `pkcs5_pbkdf2_hmac_sha1`), there is no explicit validation shown against system constraints (e.g., maximum allowable password length) before processing. This is a direct input validation concern.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The code does not handle protocol messages or variable-length components in a communication protocol. It processes a local password buffer and compares it against a stored credential. The specification's focus on protocol message structural integrity is not relevant.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 6,
        "reasoning": "The code allocates buffers based on a derived `hash_len`. While `hash_len` comes from a trusted source (digest algorithm or PBKDF2 constant), the principle of accounting for worst-case scenarios is partially relevant. However, there is no explicit input-driven size calculation that would require such a check here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 3,
        "reasoning": "Similar to spec_2, this code does not parse protocol messages with length fields. The `length` parameter is a simple size_t, and the check for integer limits is typically handled by the caller or the system's memory allocation for the buffer itself, not within this function's visible logic.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation (`calloc`) using `hash_len * 2`. While `hash_len` is derived from cryptographic constants or digest info (likely safe), the specification's principle of validating size parameters against allocation limits is relevant. The code does not show explicit validation that `hash_len * 2 * sizeof(unsigned char)` does not overflow or exceed reasonable limits.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles two different cryptographic paths (PBKDF2 and digest). It maintains consistency by using `hash_len` and separate logic blocks. The specification about consistent type handling across processing stages has weak relevance, as the types (unsigned char buffers) are consistent, but the dual-mode logic could introduce subtle inconsistencies if not carefully managed.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsers. It handles binary password data and cryptographic hashes. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It performs password verification using cryptographic functions. This specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2018-18313_before_exclude_100:27578fbc:spec": {
    "timestamp": "2026-01-17T01:22:31.450949",
    "cve_id": "CVE-2018-18313",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "27578fbc",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses regular expressions via vim_regcomp() and vim_regexec() with patterns that come from user input (like search patterns, include patterns, define patterns). While the code doesn't explicitly show handling of embedded NUL bytes, the relevance is strong because regex processing is central to the function's operation and user-provided patterns could contain NUL bytes that might affect parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code compiles regex patterns using vim_regcomp() with magic characters. Escape sequences in user-provided patterns (like ptr, inc_opt, def patterns) need proper handling. The specification is moderately relevant as pattern compilation is a key part of the function, though the code doesn't show explicit escape sequence boundary checking.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code extensively processes strings from various sources (file lines, user patterns, file names) using functions like STRNCPY, sprintf, vim_fgets, and direct pointer arithmetic. Many operations use length-aware functions (like STRNCPY with explicit bounds), but some string operations could be vulnerable if inputs contain unexpected NUL bytes or lack proper length validation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code uses alloc() and lalloc_clear() for memory allocation. lalloc_clear() with TRUE parameter initializes memory to zero, but regular alloc() does not. The files array is cleared, but other allocations like pat and file_line might not be fully initialized. Moderate relevance as memory initialization is present but not consistent.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (goto fpip_end) that clean up resources (free memory, close files, free regex programs). It maintains consistent state by freeing allocated resources before returning. Strong relevance as error handling is comprehensive and maintains object state consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code processes file contents and patterns but does not handle network protocols. It reads from local files using mch_fopen() and vim_fgets(). Very low relevance as this is file processing, not network protocol handling.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code has many buffer accesses and pointer operations (line parsing, string copying, array indexing). It uses bounds checking in some places (like checking i < max_path_depth) but not consistently. Functions like sprintf into pat buffer use calculated length, but other operations might risk buffer overflows. Highly relevant as buffer bounds validation is critical for security.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code parses file lines for include patterns and define patterns. It validates input structure by checking regex matches and scanning for file names. However, it doesn't show extensive structural constraint enforcement before content processing. Moderate relevance as input validation occurs but may not be comprehensive.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2018-18313_after_exclude_100:3d64fc56:spec": {
    "timestamp": "2026-01-17T01:22:39.111040",
    "cve_id": "CVE-2018-18313",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3d64fc56",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses regular expression compilation (vim_regcomp) with user-provided patterns from 'inc_opt', 'p_def', and 'curbuf->b_p_def'. While it doesn't explicitly show handling of embedded NUL bytes, the patterns come from Vim options which could potentially contain them. The relevance is strong because regex processing is central to the function's operation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 7,
        "reasoning": "The code compiles regex patterns with magic_isset() flag handling. While escape sequence processing occurs within vim_regcomp (not shown), the code's use of regex patterns from configuration options makes boundary maintenance during escape sequence processing moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively processes strings from files and patterns, using length-aware operations like STRNCPY with explicit bounds, MB_STRNICMP with length parameter, and vim_fgets with buffer size. It handles potentially untrusted input from included files.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses lalloc_clear for initialization and explicitly sets structure fields, but there are potential paths where memory might not be fully initialized before use in the file stack management logic.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code has multiple error handling paths (goto fpip_end) that must maintain consistent states. It properly frees allocated memory and closes files in cleanup paths, ensuring resource management consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This function processes local files and patterns, not network protocols. The specification about network protocol handlers doesn't apply to this code scenario.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs extensive buffer access operations with bounds checking, including array indexing (files[i]), pointer arithmetic with bounds validation (p > line check), and buffer size limits in string operations.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code validates input patterns and file content before processing, checking for NULL pointers, empty strings, and validating line boundaries. It enforces structural constraints like path depth limits before content processing.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2014-9652_before_exclude_100:bb8824b9:spec": {
    "timestamp": "2026-01-17T01:22:44.153121",
    "cve_id": "CVE-2014-9652",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bb8824b9",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves tensor data copying via reader->CopySliceData, which likely performs memory writes. While there is validation of tensor shapes and slices, the specification about \"strict bounds validation before write operations\" is moderately relevant. The code validates shapes match between parsed and saved tensors, which indirectly provides bounds checking, but the direct buffer operations within CopySliceData are not visible in this code snippet.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code validates input tensor sizes (e.g., checking file_pattern_t has exactly 1 element) and validates tensor shapes during parsing. However, the complete input size validation for the tensor data being read from checkpoint files is delegated to the TensorSliceReader implementation, making this partially relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 8,
        "reasoning": "The code parses shape_and_slice specifications (checkpoint::ParseShapeAndSlice) and enforces structural constraints by verifying parsed_shape matches saved_shape. This directly relates to configuration/input parsing with structural validation.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 4,
        "reasoning": "While the code involves tensor shape calculations and slice operations, there's no explicit file position calculation visible. The file reading operations are abstracted within TensorSliceReader. Weak relevance as overflow prevention in shape/size calculations might be indirectly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 5,
        "reasoning": "The code reads from checkpoint files via TensorSliceReader, but boundary validation for archive/file positions is hidden within the reader implementation. The code validates tensor shapes match, which provides some boundary checking, but not directly at the file position level.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code uses TensorSliceReader objects (cached or allocated) and checks reader status. However, the specification about maintaining consistent state during position calculation failures is mostly handled internally by the reader, with limited visibility in this code.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Archive parsing state must remain consistent during position calculation failures"
      },
      {
        "score": 3,
        "reasoning": "The code doesn't involve explicit structure pointer dereferences with type verification. It works with Tensor objects and reader interfaces where type checking is done via DataType comparisons. Very low relevance to this specific code pattern.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: All structure pointer dereferences must be preceded by explicit type verification"
      },
      {
        "score": 5,
        "reasoning": "The code uses OpKernelContext and TensorSliceReader objects that maintain shared state. It validates data type consistency between saved tensors and expected output types. Moderate relevance as it ensures type consistency during the restore operation lifecycle.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared context objects must maintain type consistency throughout their lifecycle"
      }
    ]
  },
  "CVE-2021-37639_after_exclude_100:647fe65c:spec": {
    "timestamp": "2026-01-17T01:23:35.917673",
    "cve_id": "CVE-2021-37639",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "647fe65c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve fixed-size buffer operations. Memory allocation is dynamic via `context->allocate_output()`, and data copying uses the reader's `CopySliceData` method. While bounds validation occurs (e.g., checking tensor shapes match), it's not about preventing writes to fixed buffers.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code validates input sizes early: it checks that `file_pattern_t` is a scalar (size==1) and that `tensor_name_t` has enough elements (`size > restore_index`). This aligns with the principle of input size validation before processing. However, the specification is broad, and the validation here is specific to tensor element counts, not general input parsing.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "The code parses a `shape_spec` string using `checkpoint::ParseShapeAndSlice`, which must enforce structural constraints (e.g., valid format for shape and slice). It also validates the parsed shape matches the saved shape. This relates to configuration/input parsing constraints, though the scope is limited to a specific shape-and-slice format.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit file position calculations. It uses a `TensorSliceReader` abstraction to read data, and there are no visible integer operations for file offsets. The risk of integer overflow in position calculations is not apparent in this code snippet.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 5,
        "reasoning": "The code does not directly parse archive files or validate file positions against archive boundaries. It relies on the `TensorSliceReader` implementation to handle file reads. The boundary checks are abstracted away, so this specification is not directly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      },
      {
        "score": 5,
        "reasoning": "There is no visible archive parsing state management in this function. The `TensorSliceReader` may have internal state, but this function does not handle state consistency during position calculation failures (failures are handled via `OP_REQUIRES` and status checks).",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Archive parsing state must remain consistent during position calculation failures"
      },
      {
        "score": 5,
        "reasoning": "The code dereferences pointers like `reader` after validation (`CHECK_NOTNULL(reader)`). However, there is no explicit type verification of structures beyond checking tensor data types (`type == context->expected_output_dtype(...)`). The relevance is weak because pointer validation is present, but type verification is limited to data types, not structure layouts.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: All structure pointer dereferences must be preceded by explicit type verification"
      },
      {
        "score": 5,
        "reasoning": "The function uses shared context objects (`OpKernelContext* context`) and a reader cache (`context->slice_reader_cache()`). It ensures type consistency by validating the restored tensor's data type matches the expected output dtype. The context and cached readers must maintain consistent types throughout their lifecycle, which is directly addressed here.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared context objects must maintain type consistency throughout their lifecycle"
      }
    ]
  },
  "CVE-2018-20760_before_exclude_100:6e04d51e:spec": {
    "timestamp": "2026-01-17T01:23:57.422696",
    "cve_id": "CVE-2018-20760",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6e04d51e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses GF_SAFEALLOC for memory allocation, which likely zero-initializes the memory. However, the specification about full initialization before use is highly relevant because the code immediately initializes many fields of the allocated `TrackWriter` structure after allocation, ensuring it's in a consistent state. This is a direct application of the principle.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error paths (memory allocation failures) that return `GF_OUT_OF_MEM`. In these cases, it's critical that object states (like the `writers` list and the `movie` structure) remain consistent. The `goto exit` path calls `CleanWriters(writers)` to clean up, which is good error handling. However, there's a potential issue: if `gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC)` succeeds but the subsequent `gf_isom_box_new` for `stco` fails, the function returns `GF_OUT_OF_MEM` without cleaning up the already-allocated `writer->stsc`. This could leave the `writer` object in an inconsistent state if it's already been added to the `writers` list. The error handling path does not fully maintain consistent object states in all branches.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is setting up internal track writers for a media file (MP4/ISO base media file format). It does not handle network protocols or process network input. The operations are on file structures in memory.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code allocates memory for structures (`TrackWriter`, `stsc`, `stco` boxes) but does not involve buffer allocation with operational padding requirements or safety margins for things like cryptographic operations or specific data transformations. The allocations are for fixed-size control structures.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function sets up metadata and control structures for writing media samples. It does not perform image compression operations or manage encoder buffers. It deals with sample tables, chunk offsets, and timing information.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not parse or validate protocol message length fields. It works with internal movie/track structures where counts (like `trackCount`, `sampleCount`) are obtained from already-parsed data structures.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The principle of validating size parameters applies indirectly. The code uses safe allocation (`GF_SAFEALLOC`) and checks for NULL returns, which is a form of validation against allocation limits. However, it doesn't explicitly validate size parameters for subsequent usage (e.g., it doesn't check if `sampleCount` or other counts are within reasonable bounds before using them in calculations like `mw->total_samples += ...`). The relevance is moderate because memory allocation validation is present, but comprehensive size checks for usage are not evident.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code handles different box types (`GF_ISOM_BOX_TYPE_STCO` vs `GF_ISOM_BOX_TYPE_CO64`) for chunk offsets, ensuring the correct type is created based on the existing box type. This is an example of consistent type handling. However, the specification is about protocol implementations, and while the ISO base media file format is a container specification, it's not a network protocol. The principle of consistent type handling across processing stages is applicable here as the code propagates type information from the source track to the writer structures.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2018-20760_after_exclude_100:b15f3320:spec": {
    "timestamp": "2026-01-17T01:24:17.695696",
    "cve_id": "CVE-2018-20760",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b15f3320",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses GF_SAFEALLOC for memory allocation, which likely performs allocation but may not guarantee full initialization. The writer structure has several fields explicitly initialized after allocation, but not all fields (like pointers in the struct not shown) may be set. This aligns with the principle of initializing memory before use, though the initialization appears mostly complete for the fields used.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The function has multiple error return paths (GF_ISOM_INVALID_FILE, GF_OUT_OF_MEM). The exit label calls CleanWriters to clean up allocated resources, maintaining consistent state. However, there's a potential issue: if gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC) succeeds but the subsequent gf_isom_box_new for stco fails, the function returns GF_OUT_OF_MEM without cleaning up the allocated stsc box, creating a memory leak and inconsistent state.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code processes media file structures (MP4/ISO base media file format) but does not handle network protocols. It reads from local file structures, not network input.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory for data structures but doesn't involve buffer operations with padding requirements or safety margins. It's working with media sample data structures rather than buffers needing operational padding.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code sets up track writers for media processing but doesn't perform image compression operations or manage encoder buffers. It handles media container structures, not compression algorithms.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 2,
        "reasoning": "The code validates media file structures (checking stbl, SampleSize, ChunkOffset, SampleToChunk) but doesn't process protocol message length fields. It works with media sample counts and offsets, not network protocol messages.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation via GF_SAFEALLOC and gf_isom_box_new. While it doesn't explicitly validate size parameters, these allocation functions likely have internal checks. The relevance is moderate as the principle of validating allocation sizes applies, but the implementation details are hidden in library functions.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different box types (STCO vs CO64 for chunk offsets) and maintains consistent type handling through conditional logic. It also checks media types (SMHD for audio) for ordering. This shows attention to type consistency, though it's for media format processing rather than network protocols.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2011-3601_before_exclude_100:fda9a67c:spec": {
    "timestamp": "2026-01-17T01:24:27.094874",
    "cve_id": "CVE-2011-3601",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fda9a67c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes a TLS NewSessionTicket message containing length fields (ticket_lifetime_hint, ticket length). It validates that the total message length (n) is at least 6 bytes and later checks that ticklen + 6 == n. However, it does not explicitly validate ticklen against platform-specific integer limits (e.g., for overflow in ticklen + 6, or for excessive size before allocation). The validation is present but incomplete for integer limits.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code allocates memory based on ticklen using OPENSSL_malloc(ticklen) without checking if ticklen is within reasonable allocation limits or if it matches subsequent usage (memcpy). This is a direct violation of secure allocation practices, as a maliciously large ticklen could cause excessive memory allocation or integer overflow in the allocation size.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles a specific TLS message type (NewSessionTicket) and processes its fields (lifetime hint, ticket length, ticket data). While it performs some length checks, there is no evident type confusion or inconsistent type handling across stages. The specification is weakly relevant as the code deals with a single message type in a relatively straightforward manner.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code validates that the message length n is at least 6 and that ticklen + 6 == n, which enforces basic length constraints for the TLS NewSessionTicket structure. However, it does not enforce RFC-specified constraints on ticket_lifetime_hint or maximum ticket length, making the validation incomplete but partially relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code processes a TLV-like structure (ticket_lifetime_hint as 4-byte integer, ticket length as 2-byte integer, ticket as variable data). It performs bounds checking by verifying ticklen + 6 == n before accessing the ticket data with memcpy. However, the check occurs after reading ticklen, which is good, but does not prevent integer overflow in ticklen + 6. Overall, it implements bounds checking but with a potential flaw.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or handling of embedded NUL bytes in patterns. It processes binary TLS messages, not text patterns. This specification is irrelevant to the code scenario.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It deals with binary protocol parsing, not text-based pattern compilation. This specification is irrelevant.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses memcpy with an explicit length (ticklen) to copy ticket data, which is length-aware. However, the ticket data is potentially untrusted (from network input), and the length is validated against the total message size. The relevance is moderate because the code uses length-aware operations but does not involve string processing functions (like strcpy).",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2015-1791_after_exclude_100:5dd7052e:spec": {
    "timestamp": "2026-01-17T01:24:33.370926",
    "cve_id": "CVE-2015-1791",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5dd7052e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes a TLS NewSessionTicket message which contains length fields (ticket_lifetime_hint and ticket_length). It validates that the total message length `n` is at least 6 bytes and later checks `ticklen + 6 != n`. However, it does not explicitly validate `ticklen` or the derived pointer `p` against platform-specific integer limits (e.g., for overflow in pointer arithmetic or memory allocation), making this specification strongly relevant but not fully addressed.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code performs memory allocation via `OPENSSL_malloc(ticklen)` where `ticklen` is derived from untrusted network input. While it checks if the allocation fails, it does not validate `ticklen` against reasonable allocation limits before the allocation call. This is a direct violation of the specification's requirement to validate size parameters against allocation limits, making it highly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification about consistent type handling across processing stages is weakly relevant. The code uses consistent types (e.g., `int`, `long`, `unsigned char*`) for message processing, but there is no evident type confusion or inconsistency issue in the shown code segment. The main risks here are length and bounds validation, not type handling.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code validates the TLS NewSessionTicket message structure against basic length constraints (n >= 6, ticklen + 6 == n). However, it does not enforce RFC 5077-specified constraints on ticket length (e.g., maximum ticket size) or lifetime hint values. The validation is present but incomplete, making the specification strongly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code processes a TLV-like structure (lifetime hint + ticket length + ticket data). It performs bounds checking (`ticklen + 6 != n`) before accessing the ticket data via `memcpy`. However, the check occurs after pointer advancement (`n2l`, `n2s`), and there is no validation that `ticklen` is non-negative or that `p + ticklen` doesn't overflow/wrap. This is a core TLV processing issue, making the specification highly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The specification regarding regular expression parsers and embedded NUL bytes is completely irrelevant to this code, which deals with TLS session ticket processing and does not involve regular expressions.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification about pattern compilers and escape sequences is completely irrelevant to this code, which involves binary protocol parsing, not pattern compilation or text processing with escape sequences.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification about string processing functions and length-aware operations is very low relevance. The code uses `memcpy` with an explicit length (`ticklen`), which is length-aware. However, the input is not a string but binary ticket data. The weak connection is that `ticklen` is untrusted and used in a copy operation, but the core issue is bounds checking, not string-specific handling.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2018-20750_before_exclude_100:10274b2d:spec": {
    "timestamp": "2026-01-17T01:25:23.760944",
    "cve_id": "CVE-2018-20750",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "10274b2d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates `ph.catalog_entries` from the image header before using it to calculate a size for memory allocation. It checks if `s->catalog_size > INT_MAX / 4`, which is a validation against platform-specific integer limits to prevent integer overflow. This directly aligns with the principle of validating length fields.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs a memory allocation (`g_malloc`) based on a size calculated from user-controlled input (`ph.catalog_entries`). It validates the size parameter (`s->catalog_size > INT_MAX / 4`) against an allocation limit to prevent an overflow that would cause an undersized buffer. This is a core example of the specification's requirement.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code handles data read from a disk image (a form of protocol). It uses `le32_to_cpu` to convert fields from little-endian to host byte order, enforcing consistent integer type handling. However, the specification is broad, and this is a specific, correct application of part of its principles.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve regular expression parsing. It parses a binary file format header. The specification about embedded NUL bytes in regex patterns is completely unrelated to this context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve pattern compilers or the processing of escape sequences. It is parsing a fixed binary structure.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The code uses `memcmp` on a fixed-size magic field, which is safe. It does not process variable-length strings from untrusted input. The principle of using length-aware operations is good general advice but is not directly applicable to the primary operations in this function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code allocates memory (`s->catalog_bitmap`) and immediately initializes it by reading data from the disk image file (`bdrv_pread`). This ensures the memory is initialized before subsequent use (e.g., the `le32_to_cpus` loop). The initialization is from an external source, which aligns with the spirit of the rule, though the rule often emphasizes zero-initialization to avoid information leaks.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function has a clear `fail:` error handling path. This path ensures consistency by freeing the `s->catalog_bitmap` if it was allocated, preventing a memory leak and maintaining a consistent state for the `BDRVParallelsState` object before returning an error. This is a direct and correct application of the specification.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2013-2124_after_exclude_100:a2f73e08:spec": {
    "timestamp": "2026-01-17T01:25:43.944203",
    "cve_id": "CVE-2013-2124",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a2f73e08",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the `catalog_entries` field from the image header against `INT_MAX / 4` before using it to calculate an allocation size. This is a direct validation of a protocol message length field (from the disk image format) against a platform-specific integer limit to prevent overflow, which aligns with HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code performs a crucial validation (`s->catalog_size > INT_MAX / 4`) before the memory allocation `g_malloc(s->catalog_size * 4)`. This checks the size parameter against an allocation limit (to prevent integer overflow) and ensures the subsequent `bdrv_pread` call using the same calculated size is safe. This is a strong, direct application of HS-MEM-002.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles data from a disk image protocol. It consistently uses `le32_to_cpu` to convert little-endian fields from the header to host CPU order, and later converts the entire catalog array. This enforces consistent type handling (endianness) across processing stages, which is the core principle of HS-PROTOCOL-003.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain any regular expression parsing logic. HS-INPUT-001 (in this specific formulation) is about regex parsers and NUL bytes, which is completely irrelevant to this disk image opening function.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. HS-PROTOCOL-002 is not applicable to this scenario.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes untrusted input (the disk image), it does not use typical string processing functions like `strcpy`. It uses `memcmp` with a fixed length (16) for magic number comparison and `bdrv_pread` with a calculated size for the catalog. The relevance to \"string processing functions\" is very low, though the principle of bounded operations is followed.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The memory allocated for `s->catalog_bitmap` is immediately populated with data from disk via `bdrv_pread`, which initializes it. However, it is not \"fully initialized\" in the sense of being zeroed or filled with a known pattern before use; its contents are defined entirely by the (potentially untrusted) disk image. The specification has a weak connection, as the memory is written to before being read, but not necessarily *initialized* in a secure manner.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function has a clear `fail:` label for error handling. In the failure path, it ensures `s->catalog_bitmap` is freed with `g_free()` only if it was allocated, preventing a memory leak and maintaining a consistent state (the pointer is NULL after `g_free`). This is a direct and correct application of HS-STATE-002.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2016-1838_before_exclude_100:b484ad34:spec": {
    "timestamp": "2026-01-17T01:26:19.979040",
    "cve_id": "CVE-2016-1838",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b484ad34",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a simple character scanner, not a regular expression parser. While it processes input, the specification about handling embedded NUL bytes in regex patterns is not directly applicable. The code does check for NUL (chr == 0) but in a different context (end-of-string vs. embedded NUL).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile patterns or process escape sequences. It simply reads characters and optionally skips whitespace. The specification about pattern compilers and escape sequence boundaries has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function processes a string (scanner->curptr) but does not use explicit length-aware operations. It relies on null-termination (checking for chr == 0). For untrusted input, this could be problematic if the string is not properly terminated, leading to potential reads beyond buffer boundaries. The principle of using length-aware operations for untrusted input applies.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse protocol messages or validate length fields. It is a low-level character scanning utility. The specification is not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs no memory allocation. It only increments a pointer and reads a character. The specification does not apply.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code is part of a larger scanning/parsing framework (protocol). It handles character data, but the specification about enforcing consistent type handling across all processing stages is a high-level architectural concern, not directly addressed in this single function.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function reads from `scanner->curptr` without explicit validation that the pointer points to a properly terminated string. It checks for a NUL character (`if (!chr)`), which is a termination check, but this check occurs *after* dereferencing the pointer. If `scanner->curptr` points to an invalid memory location or a non-terminated buffer, the initial dereference (`*scanner->curptr`) is unsafe. The specification's principle of validating termination before processing is directly applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "The code is not a file format parser and does not handle chunk boundaries. It operates on a simple character buffer. The specification has very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      }
    ]
  },
  "CVE-2022-1734_before_exclude_100:460c66d9:spec": {
    "timestamp": "2026-01-17T01:26:51.759492",
    "cve_id": "CVE-2022-1734",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "460c66d9",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a device unregistration and cleanup function. It does not process any userspace-provided array inputs, so validating array lengths against system constraints is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "The function handles device teardown, not protocol message parsing. There are no variable-length components being processed, so verifying their structural integrity is irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 3,
        "reasoning": "The function runs in kernel context and manages device resources. While it could be part of a larger security-sensitive system, the code itself does not implement or enforce privilege separation, nor does it terminate any process.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 4,
        "reasoning": "The function performs a state transition (unregistering a device). However, it does not appear to perform atomic verification of security-critical state (e.g., checking if the device is in a safe state to unregister). The relevance is weak but slightly higher than others as it touches on state management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 3,
        "reasoning": "The function uses a configuration field (`priv->config.reset_n_io`) but only to check if a GPIO is valid before freeing it. It does not validate runtime configuration for security-sensitive operation before use, as the operation is cleanup.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 2,
        "reasoning": "This is not a protocol parser. The function does not process network packets or validate packet lengths. It is a device driver cleanup routine.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate packet length before accessing header fields"
      },
      {
        "score": 2,
        "reasoning": "This is not a network protocol implementation. The function deals with device unregistration and resource deallocation, not with parsing or validating protocol headers.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce complete header validation before pro..."
      }
    ]
  },
  "CVE-2016-1838_after_exclude_100:5f922726:spec": {
    "timestamp": "2026-01-17T01:26:58.994670",
    "cve_id": "CVE-2016-1838",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f922726",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a simple character scanner, not a regular expression parser. While it processes input, it does not parse or compile regex patterns, making the specification about embedded NUL bytes in regex patterns only weakly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It reads raw characters from a buffer, so the specification about pattern compilers and escape sequence boundaries has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The function processes a string buffer (`scanner->curptr`) and checks against `scanner->end` to prevent reading out-of-bounds. This is a length-aware operation crucial for handling potentially untrusted input safely.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse protocol messages or validate length fields. It operates on a simple character buffer with a start and end pointer, making this specification about protocol integer limits basically inapplicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function performs no memory allocation. It only reads from and updates pointers within a pre-allocated buffer, so the specification about validating allocation size parameters does not apply.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code is a low-level scanner utility, not a full protocol implementation. It handles characters as integers, but there is no complex type handling or multiple processing stages involved, resulting in very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function explicitly validates input termination by checking if the current pointer (`s`) has reached the buffer end (`scanner->end`) or if the character is NUL (`!*s`). This is a direct practice of validating external string data before processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "The code is not a file format parser and does not process chunks or enforce structural invariants at boundaries. It reads a linear character stream, making this specification basically inapplicable.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      }
    ]
  },
  "CVE-2022-1734_after_exclude_100:54191ceb:spec": {
    "timestamp": "2026-01-17T01:27:09.485048",
    "cve_id": "CVE-2022-1734",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "54191ceb",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a device cleanup/unregister function. It does not process any userspace-provided array inputs or lengths. The function operates on internal kernel data structures (priv, ndev) that are already established. Therefore, this specification about validating user-provided array lengths is not relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The function is not a protocol message handler. It performs cleanup operations like unregistering a device, aborting firmware downloads, freeing GPIOs, and deallocating memory. There are no variable-length protocol components being parsed or processed here.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The function does not perform any new buffer allocations. It only frees previously allocated resources (kfree, nci_free_device, gpio_free). The specification about allocating buffers for worst-case input scenarios does not apply to this deallocation routine.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code does not deal with privilege separation or process termination. It is a kernel-level driver function managing the lifecycle of a Near Field Communication (NFC) device driver instance. There is no user process context or privilege enforcement involved in this cleanup path.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "While the function changes the state of the device (unregistering, aborting operations), these are driver teardown operations, not security-critical state transitions that require atomic verification in the sense of access control or authentication. The check for `fw_download_in_progress` is a simple flag check, not an atomic state verification for security purposes.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "The function is not a security-sensitive daemon starting up, nor is it validating a runtime configuration. It is the oppositea teardown function that releases resources based on a configuration (priv->config) that was presumably validated when the device was initialized.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate packet length before accessing header fields"
      },
      {
        "score": 2,
        "reasoning": "This is not a network protocol implementation. It is a device driver's cleanup function within the Linux kernel's NFC subsystem. There is no header validation or network packet processing occurring in this code snippet.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce complete header validation before pro..."
      }
    ]
  },
  "CVE-2021-37687_before_exclude_100:3bcf798b:spec": {
    "timestamp": "2026-01-17T01:28:42.043661",
    "cve_id": "CVE-2021-37687",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3bcf798b",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a tensor dispatch function for a gather operation, not a regular expression parser. There is no handling of input patterns or NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It dispatches based on tensor data types.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the function processes tensors which could contain string data (kTfLiteString case), the primary operation is type dispatch. The GatherNdString function called for strings might need length-aware operations, but this is not the main focus of the shown code. Weak connection.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code performs a simple type switch and tensor operation (gather). It is not a cryptographic operation and does not handle secret values.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is unrelated to elliptic curve cryptography or any cryptographic implementations.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform secure memory operations or cryptographic processing. It is a data manipulation function in a machine learning framework.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve view-based data access, privilege checks, or database/view ownership concepts.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code does not manage security-critical state transitions or privilege contexts. It manages tensor data types and dispatches computation.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2021-37687_after_exclude_100:75e79344:spec": {
    "timestamp": "2026-01-17T01:28:44.654319",
    "cve_id": "CVE-2021-37687",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "75e79344",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing. It is a tensor operation (GatherNd) that processes numerical indices and parameter tensors. There is no pattern matching or handling of NUL bytes in strings.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is a numerical data indexing function within a machine learning inference framework.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes input data (indices tensor), it uses length-aware operations by calculating `num_indices` from `indices->bytes / sizeof(IndicesT)` and using this bound in the loop. However, the specification focuses on string processing for untrusted input, while this code handles numerical tensors in a controlled ML context, making the relevance weak.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor indexing operations, not cryptographic operations. There are no secret values being processed, and timing attacks are not a concern for this functionality.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic implementations. It is a tensor manipulation function in a machine learning framework.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform cryptographic processing or require constant-time memory operations. It is a standard data indexing operation without security-critical timing requirements.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve view-based data access, privilege checks, or database/view security concepts. It operates on tensor data structures without any access control mechanisms.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve security-critical state transitions or privilege context management. It is a pure data processing function without any security state or privilege considerations.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2017-9226_before_exclude_100:3bd5372d:spec": {
    "timestamp": "2026-01-17T01:29:01.774477",
    "cve_id": "CVE-2017-9226",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3bd5372d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code is part of a PCRE2 regex compiler/engine that processes input patterns. While it doesn't directly parse raw pattern strings, it operates on compiled opcode sequences derived from patterns. If the initial parser doesn't properly handle embedded NUL bytes, this function could receive malformed opcode sequences, leading to incorrect length calculations or out-of-bounds reads. The relevance is strong but indirect.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 7,
        "reasoning": "The function processes regex opcodes which are the result of compiling escape sequences and other pattern elements. It must maintain strict boundaries when walking through the opcode sequence (via `cc` pointer) to avoid reading beyond `ccend`. The switch statement with calculated jumps (`cc += ...`) requires careful bounds checking, which relates to the principle of maintaining strict boundaries during sequence processing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function processes a bytecode sequence (`cc` to `ccend`) and must use length-aware operations. It carefully increments the `cc` pointer based on opcode sizes and uses `cc < ccend` as the loop condition. Failure to properly calculate opcode sizes or validate boundaries could lead to out-of-bounds reads, especially with untrusted compiled regex patterns.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This specification concerns RFC-specified length constraints for protocol messages. The code processes internal regex opcode sequences, not network protocol messages. There are no RFC length constraints involved.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function processes a TLV-like structure where opcodes have variable lengths. It implements bounds checking through the `cc < ccend` loop condition and calculates offsets for each opcode type. Complete bounds checking is essential before accessing opcode parameters (like `GET(cc, 1)` or `cc[1]`) to prevent buffer overreads.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 3,
        "reasoning": "Low relevance. While the function calculates a length value (sum of private machine words), it doesn't process protocol message length fields. The length calculation is for internal memory allocation, not for validating external protocol inputs against platform limits.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function calculates a `length` value that likely influences subsequent memory allocation for regex execution. While it doesn't perform allocation directly, incorrect length calculation could lead to undersized buffers. The code should ensure the calculated length doesn't overflow or exceed reasonable limits, though this isn't explicitly shown.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification concerns protocol type handling consistency. The code does handle different opcode types consistently via the switch statement, ensuring each opcode is processed according to its defined structure. However, this is about internal data structure processing rather than protocol implementation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2017-9226_after_exclude_100:0e13ffdb:spec": {
    "timestamp": "2026-01-17T01:29:14.249060",
    "cve_id": "CVE-2017-9226",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0e13ffdb",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code is part of a PCRE2 regex compiler/engine, specifically calculating data length for recursion. It processes a regex pattern (cc to ccend). While it doesn't directly parse user input strings, it operates on the compiled regex bytecode derived from a pattern. If the pattern compilation stage did not properly handle embedded NUL bytes, it could affect the interpretation of the bytecode stream this function walks. The relevance is strong because the function's correctness depends on the integrity of the bytecode derived from the input pattern.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The function processes a sequence of regex opcodes, which are the result of compiling a pattern containing escape sequences. It uses macros like GET, GET2, and LINK_SIZE to read values from the bytecode. While it doesn't process raw escape sequences itself, it must correctly interpret the compiled bytecode fields. Inadequate bounds checking when reading these fields (e.g., via GET) could lead to out-of-bounds reads if the bytecode is malformed, relating to the principle of maintaining strict boundaries during processing. The relevance is moderate to strong.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function is a classic example of walking a bytecode array with explicit bounds checking. It uses a pointer (`cc`) and an end pointer (`ccend`) to iterate, and a switch on opcodes to determine how many bytes to advance (`cc += ...`). This is precisely length-aware operation on a potentially untrusted input (the compiled regex bytecode). Failure to correctly advance the pointer for each opcode could lead to out-of-bounds reads or infinite loops. This is highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message field lengths against RFC constraints. This code is processing an internal regex bytecode structure, not a network protocol message. There is no RFC involved. The connection is very weak, limited to the abstract concept of validating lengths.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The function's operation is analogous to TLV (Type-Length-Value) processing. Each opcode (Type) has a specific structure and length. The code uses the opcode to determine how to read associated data (e.g., GET2 for offsets, LINK_SIZE for jump distances) and how much to advance the pointer. Complete bounds checking is implied by the `cc < ccend` loop condition and correct interpretation of each opcode's length. This is strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns validating protocol message length fields against integer limits. This code does read length fields (e.g., via GET, GET2) from the bytecode, but these are used as offsets for pointer arithmetic within the already bounded `cc` to `ccend` range. While integer overflows in these calculations could be a concern, the primary focus of the code is not on validating these fields against platform maxima but on using them for internal navigation. Relevance is low.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function calculates a `length` (sum of private machine words) which is likely used later to allocate memory. It does not perform the allocation itself. Therefore, it indirectly provides a size parameter that must be validated by the caller. The function's calculation must be accurate to prevent buffer overflows or underflows in subsequent allocations. This gives the specification moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The function implements consistent type handling for a specific \"protocol\" (the regex bytecode format). It uses a large switch statement to dispatch processing based on the opcode type (`*cc`), ensuring each type is handled according to its defined structure. Inconsistent handling (e.g., misidentifying an opcode) could cause misinterpretation of the bytecode stream. The principle applies directly, though the context is not a network protocol.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2016-9425_before_exclude_100:2a41e03d:spec": {
    "timestamp": "2026-01-17T01:29:34.919813",
    "cve_id": "CVE-2016-9425",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2a41e03d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code contains multiple memory allocations based on calculated sizes (e.g., patternsByteSize = sizeof(*patterns) * 27720, malloc(m->argument_count * sizeof(CharsString))). While some allocations use fixed constants, others depend on variable counts. The code does not explicitly validate these size calculations for arithmetic overflow before calling malloc, making this specification highly relevant. The _lou_outOfMemory() function is called on allocation failure, but overflow checks are missing.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: All size calculations must be validated for arithmetic overflow before memory allocati..."
      },
      {
        "score": 7,
        "reasoning": "The code has several cleanup sections (e.g., CTO_Match_cleanup, CTO_BackMatch_cleanup) that free allocated memory on partial failures. However, the state consistency during partial allocation failures is not fully guaranteed - for example, when allocateSpaceInTranslationTable fails after patterns allocation, cleanup frees patterns but doesn't roll back other potential state changes. The macro expansion logic also has complex state management that may not maintain consistency on errors.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Resource cleanup must maintain consistent state during partial allocation failures"
      },
      {
        "score": 8,
        "reasoning": "The code has extensive error handling with many return 0 paths. However, object lifecycle invariants may not be consistently maintained - for example, when compileRule fails during macro expansion, it returns 0 but doesn't clean up the temporary FileInfo structure or allocated arguments array. The table and displayTable pointers are passed through multiple layers, and error paths don't always ensure they remain in valid states.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Error handling paths must maintain object lifecycle invariants"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Pointer arithmetic operations must validate bounds against buffer limits"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: Input parameters must be validated against operational constraints"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-STATE-005: State transitions must maintain consistent boundary conditions"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate position boundaries before memory access"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Form input processing must enforce structural invariants for position markers"
      }
    ]
  },
  "CVE-2022-1720_before_exclude_100:da32cf28:spec": {
    "timestamp": "2026-01-17T01:30:22.467437",
    "cve_id": "CVE-2022-1720",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "da32cf28",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not perform any explicit memory allocation. It retrieves pointers to existing line buffers via `ml_get_curline()` and `ml_get_pos()`. While these returned buffers should be initialized, the code itself is not responsible for the allocation or initialization. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error/early return paths (e.g., when `VIsual.lnum != curwin->w_cursor.lnum`). It calls `clearopbeep(cap->oap)` on one path and `reset_VIsual_and_resel()` on the success path. Ensuring consistent state (like the visual selection) across these paths is relevant. However, the function is relatively simple and the state management is localized, making the relevance moderate.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a text selection function within an editor (likely Vim). It does not handle network protocols or process network input. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not parse or process regular expressions. It handles visual mode text selection. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile patterns or process escape sequences. It calculates lengths of selected text. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function retrieves a string pointer and calculates its length. It uses `STRLEN` and pointer arithmetic. For multi-byte characters, it adjusts the length using `mb_ptr2len` to include all bytes of the last character, which is a form of length-aware operation. While the input is not \"untrusted\" in a network sense, it is external data (file/buffer content), and correct length calculation is crucial to prevent buffer over-reads. The principle is strongly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process protocol messages or validate length fields from an external source. The length calculated is derived from cursor positions within the editor's buffer. Relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform memory allocation. It calculates a length (`*lenp`) which is used later, but there is no validation of this length against allocation limits or usage requirements within this function. The connection is very weak, though the calculated length could theoretically be used unsafely elsewhere.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-31783_after_exclude_100:a5fb14e7:spec": {
    "timestamp": "2026-01-17T01:30:39.709453",
    "cve_id": "CVE-2022-31783",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a5fb14e7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code contains multiple memory allocations (e.g., malloc for patterns, arguments) and array bounds checks (e.g., checking against MAXSTRING, EMPHMODECHARSSIZE). While some size validations exist (like checking len + ruleChars.length > EMPHMODECHARSSIZE), there is no explicit validation for arithmetic overflow in size calculations before allocations like `malloc(m->argument_count * sizeof(CharsString))` or `malloc(sizeof(char) * (emphClass.length + 1))`. The specification is highly relevant as secure memory allocation practices are critical here.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: All size calculations must be validated for arithmetic overflow before memory allocati..."
      },
      {
        "score": 7,
        "reasoning": "The code has several cleanup paths (e.g., CTO_Match_cleanup, CTO_BackMatch_cleanup) where resources (like patterns buffer) are freed on error. However, there are complex nested allocations (e.g., macro argument processing with tmpFile) where partial failure handling might not maintain consistent state. The specification is relevant because error handling must ensure no resource leaks or inconsistent states.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Resource cleanup must maintain consistent state during partial allocation failures"
      },
      {
        "score": 6,
        "reasoning": "Error handling is present throughout (compileError returns 0), but object lifecycle management (like table reallocation via allocateSpaceInTranslationTable) may not always maintain invariants. The code comments note that allocateSpaceInTranslationTable may move the table, requiring re-fetching of pointers. This shows awareness, but complex error paths could break invariants. Moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Error handling paths must maintain object lifecycle invariants"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Pointer arithmetic operations must validate bounds against buffer limits"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: Input parameters must be validated against operational constraints"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-STATE-005: State transitions must maintain consistent boundary conditions"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate position boundaries before memory access"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Form input processing must enforce structural invariants for position markers"
      }
    ]
  },
  "CVE-2022-1720_after_exclude_100:eff0974f:spec": {
    "timestamp": "2026-01-17T01:30:42.096469",
    "cve_id": "CVE-2022-1720",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "eff0974f",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not perform any explicit memory allocation. It retrieves pointers to existing memory (ml_get_curline, ml_get_pos) and calculates lengths. There is no initialization of newly allocated memory, so the specification has weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple early return paths (FAIL, OK). It resets the visual selection state (reset_VIsual_and_resel()) only on the successful path at the very end. If an error occurs early (e.g., VIsual.lnum mismatch), the function returns FAIL without resetting the visual state, potentially leaving the editor in an inconsistent state. This is a moderate relevance to error handling and state consistency.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a text selection function in an editor (likely Vim), not a network protocol handler. There is no network input processing.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code handles text selection, not regular expression parsing. It checks for NUL bytes in the context of string length calculation, not within regex patterns.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile or process patterns containing escape sequences. It is a visual text retrieval routine.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function is fundamentally about string processing (extracting a selected substring). It calculates a length (*lenp) based on column positions and then adjusts it for multi-byte characters using a length-aware function (*mb_ptr2len). This demonstrates an awareness of the need for correct length calculation, especially for multi-byte encodings, which is a core principle of the specification. The input (editor buffer content) could be considered untrusted in a security context.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process protocol messages or their length fields. It deals with internal editor coordinates and string lengths.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No memory allocation operations (malloc, calloc, realloc, etc.) are performed in this function. The specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-2982_before_exclude_100:f1fa44d6:spec": {
    "timestamp": "2026-01-17T01:32:17.930937",
    "cve_id": "CVE-2022-2982",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f1fa44d6",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code allocates a dictionary (`dict_alloc_lock(VAR_FIXED)`) but does not show explicit full initialization of the entire allocated memory block. However, it immediately populates the dictionary with specific keys and values using `dict_add_number`, which likely initializes the relevant parts. The relevance is moderate because while memory is allocated, the pattern of use (immediate population) reduces direct risk, but the principle of ensuring all allocated memory is initialized before use still applies.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error handling paths (e.g., if `dict_alloc_lock` returns NULL, if `call_callback` fails). It must ensure object states (like reference counts for `d` and `qftf_list`) remain consistent across these paths. For example, `++d->dv_refcount` is done before the callback, and `dict_unref(d)` is called later, but if the callback fails or returns an unexpected type, the state of `qftf_list` and reference counts must be handled correctly. The code shows some care (e.g., incrementing refcount for the returned list), making this highly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve network protocol handling. It processes a callback for a quickfix text function, which is internal to the application. Therefore, this specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It deals with calling a user callback and managing dictionaries/lists. Therefore, this specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing escape sequences. It is about callback invocation and data structure manipulation. Therefore, this specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code does not directly process strings from potentially untrusted input. It passes structured data (a dictionary) to a user callback. However, if the callback's implementation or the data it returns involves string processing, the principle could apply indirectly, but the target code itself does not show such operations. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve protocol message length fields. It uses integer parameters (`start_idx`, `end_idx`) as indices, but these are not validated against platform-specific integer limits in the shown code. However, the specification is about network protocols, which are not present, so it is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation via `dict_alloc_lock`. While it does not explicitly show validation of size parameters (the allocation size is likely fixed for a dictionary), the principle of validating allocation parameters against limits is a general secure coding practice. The relevance is weak because the allocation is for a fixed-size internal structure, not directly influenced by untrusted input size parameters, but failure handling is present (checking for NULL).",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-2982_after_exclude_100:ace8a404:spec": {
    "timestamp": "2026-01-17T01:32:27.253723",
    "cve_id": "CVE-2022-2982",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ace8a404",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code uses dict_alloc_lock(VAR_FIXED) for memory allocation. While the allocation itself is checked for NULL, there is no explicit full initialization of the entire allocated memory block before use. However, the code immediately populates the dictionary with specific entries using dict_add_number, which effectively initializes the relevant parts. The relevance is moderate because the principle of initializing memory applies, but the code's pattern of immediate structured initialization mitigates the typical risk.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has clear error handling paths. When dict_alloc_lock fails, it sets `recursive = FALSE` before returning NULL, maintaining the consistent state of the `recursive` static variable. This prevents the function from being permanently locked in a recursive state after an allocation failure. This is a direct and correct application of the specification's principle.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is a callback handler for a user-supplied function to get display text. It does not involve network protocol handling, message parsing, or network input. The specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain any regular expression parsing logic. It deals with dictionary creation, callback invocation, and list management. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain any pattern compilation logic or processing of escape sequences. It is focused on data structure manipulation and function calls. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code does not directly process strings from potentially untrusted input. It creates a dictionary with numerical values and passes it to a callback. The primary risk is in the user-supplied callback function (`quickfixtextfunc`), which is outside the scope of this function's string operations. The connection is very weak, as the principle of safe string handling could be relevant to the broader context of the callback's implementation, but not to this specific code snippet.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse any protocol messages or validate length fields. The parameters `start_idx` and `end_idx` are used directly as dictionary values without bounds checking, but they are not message length fields in a network protocol context. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs one memory allocation via `dict_alloc_lock(VAR_FIXED)`. The size parameter is a fixed constant (`VAR_FIXED`), implying a predefined, presumably safe size. There is no validation of this size against allocation limits or usage requirements, but the use of a fixed constant suggests the size is inherently validated by the system's design. The relevance is weak because while memory allocation is present, the validation aspect is handled architecturally rather than explicitly in the code.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-41133_before_exclude_100:79bf04ee:spec": {
    "timestamp": "2026-01-17T01:34:04.898056",
    "cve_id": "CVE-2021-41133",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "79bf04ee",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code implements a seccomp filter to restrict syscalls, which is a form of privilege reduction/sandboxing, not privilege separation. It does not involve splitting a process into privileged/unprivileged parts or enforcing termination if separation fails. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 3,
        "reasoning": "The code configures a security-critical state (the seccomp filter) before applying it. However, the verification (adding rules, exporting BPF) is not atomic with the state transition (loading the filter via bwrap). The filter is built and exported, but its activation is delegated to an external tool. There is a weak connection to state transition verification.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "The function validates runtime configuration (run_flags, arch) to decide which syscalls to block (e.g., devel vs non-devel mode, multiarch support). It performs checks before constructing and exporting the seccomp filter, which acts as a security-sensitive configuration for the sandbox. This aligns moderately with the principle of validating configuration before operation.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It deals with syscall numbers, architectures, and seccomp rules. No relevance to embedded NUL bytes in regex patterns.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing escape sequences. It works with syscall tables and seccomp library calls. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses string comparison (strcmp) on the `arch` input parameter. While `arch` is likely trusted (from internal Flatpak configuration), it is still an input. However, there is no complex string processing or obvious use of length-aware functions for untrusted input. Weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse protocol messages with length fields. It handles syscall numbers and architecture IDs. There is a very low connection to validating integer limits in protocol fields.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses static arrays (syscall_blocklist, etc.) and does not perform dynamic memory allocation based on user input. The only potential allocation is inside `seccomp_init` and `seccomp_arch_add` (libseccomp internal). The function validates inputs (arch string, flags) before passing them to libseccomp, but does not explicitly validate size parameters for allocation. Weak relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2016-1834_before_exclude_100:c1d3b404:spec": {
    "timestamp": "2026-01-17T01:34:08.829814",
    "cve_id": "CVE-2016-1834",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c1d3b404",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code is a string scanner that processes binary data to find strings, not a regex parser. While it does handle NUL bytes as string terminators, this is not the core focus of the specification, leading to weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 6,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The code does process escape sequences (e.g., \"\\n\", \"\\t\") when encoding characters into a temporary buffer. It has logic to handle escape codes and maintain buffer boundaries (checking `i + 32 < sizeof(tmp)`). This shows moderate relevance as the principle of boundary checking during escape sequence processing applies.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "The specification mandates length-aware operations for untrusted input. The code extensively uses length-aware functions like `r_utf8_decode(buf + needle - from, to - needle, ...)` and `r_buf_read_at(bf->buf, from, buf, len)`. It validates the `len` range and checks `needle < to` in loops. This is highly relevant to the core string scanning logic.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The code validates the `len` variable derived from `to - from` against `ST32_MAX` and checks if it's positive. This is a form of length validation, but the context is not protocol message parsing but a binary string scan range. The relevance is weak to moderate.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The specification requires validating size parameters for allocation and usage. The code validates `len` before calling `calloc(len, 1)`. It also checks if the allocation succeeded and if `min` is non-zero. Furthermore, it calculates an `outlen = len * 4` for a secondary buffer, which could overflow if `len` is large, though `len` is previously bounded by `ST32_MAX`. The principle is strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The specification demands consistent type handling across protocol stages. The code deals with string type detection (ASCII, UTF-8, WIDE, WIDE32) and has logic to switch between them. However, this is not about a network protocol but internal binary data interpretation. The connection is very weak.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires memory allocations to be initialized before use. The code uses `calloc(len, 1)` which zero-initializes the buffer. However, it also allocates `ut8 *out = calloc(len, 4)` which is initialized. The `RBinString *bs = R_NEW0(RBinString)` also likely zero-initializes. The principle is followed, giving moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The specification requires error handling paths to maintain consistent object states. The code has several error checks (e.g., `if (!buf || !min)`, charset encoding failures) that free resources and return. However, in the charset encoding failure path, it frees `ch` but does not free the original `buf` before returning (though the function later frees `buf` at the end, but this early return leaks `buf`). There are also other early breaks that might skip cleanup. The principle is relevant but not perfectly implemented.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-41133_after_exclude_100:3f3bca8a:spec": {
    "timestamp": "2026-01-17T01:34:14.479126",
    "cve_id": "CVE-2021-41133",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3f3bca8a",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code implements a seccomp filter to restrict syscalls, which is a form of privilege separation. While it doesn't enforce immediate process termination directly, it configures the kernel to block or return errors for unauthorized syscalls (SCMP_ACT_ERRNO). This is a strong enforcement mechanism that prevents privilege escalation, aligning with the core principle of the specification.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 3,
        "reasoning": "The code configures a security filter (seccomp) but does not involve complex state transitions that require atomic verification. The filter is built and applied in a single-threaded setup function. There is no clear state machine or transition that needs atomic checks, making this specification only tangentially relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "The function validates runtime configuration (e.g., `run_flags`, `arch`, `allowed_personality`) before constructing and applying the seccomp filter. It checks for multiarch and devel modes, and validates syscall arguments. This aligns with the principle of validating configuration before enforcing security policies, though it's not a daemon in the traditional sense.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It deals with syscall filtering, architecture checks, and seccomp rule creation. There is no pattern matching or regex processing, making this specification irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It works with syscall numbers, architectures, and seccomp rules. This specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses string comparisons (e.g., `strcmp(arch, \"i386\")`) but the input `arch` is likely trusted (from internal configuration). There is no obvious processing of untrusted strings where length-aware operations would be critical. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process protocol messages or length fields. It handles syscall numbers, error codes, and seccomp structures. This specification is not relevant to the code's functionality.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses static arrays (e.g., `syscall_blocklist[]`) and does not perform dynamic memory allocation based on untrusted size parameters. Memory allocation is managed by glib/standard libraries (e.g., `seccomp_init`). There is no explicit validation of allocation sizes, making this specification largely irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-41225_before_exclude_100:41ddb217:spec": {
    "timestamp": "2026-01-17T01:34:17.145718",
    "cve_id": "CVE-2021-41225",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "41ddb217",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is part of a TensorFlow graph optimization routine (AutoParallel) for distributing computation across GPUs. It involves graph node analysis and transformation but does not handle process execution, privilege separation, or any mechanism that would enforce immediate process termination. The specification is about system-level security enforcement, which is not relevant to this high-level machine learning framework logic.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 3,
        "reasoning": "The code performs state transitions on a computational graph (adding division nodes, categorizing nodes as shared/replica). While state consistency is important for correct graph execution, these are not security-critical state transitions (like authentication or authorization changes). The specification focuses on atomic verification for security-critical transitions, which does not apply here.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "The code validates its input (GrapplerItem) by checking for empty fetch nodes and variables, which is a form of configuration validation. However, this is not for a \"security-sensitive daemon\" but a graph optimization component. The validation is basic and not focused on security parameters, making the relevance weak.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns view-based data access and privilege checks in database contexts. This code manipulates a TensorFlow graph structure for parallelization and has no concept of data views, view owners, or privilege checks for data access. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The specification is about maintaining consistent privilege context during security-critical state transitions. This code deals with graph node states (replica vs. shared) for performance optimization, not with user/process privileges or security contexts. The connection is very weak.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The specification is specific to SQL protocol implementations and enforcing view security. This code is for TensorFlow graph computation and does not involve SQL, database protocols, or any form of query-based data access control. No relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "The code uses standard C++ containers (std::map, std::set, std::vector) and does not perform explicit low-level memory allocation (like malloc/new where size tracking is critical). While memory is allocated by these containers, the specification is aimed at manual memory management vulnerabilities, resulting in low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "The code performs resource management by categorizing graph nodes into \"replica_nodes_\" and \"shared_nodes_\" sets, which affects how computational resources (GPUs) are used. It must maintain invariants (e.g., a node shouldn't be in both sets) for correct parallel execution. This aligns partially with the principle of maintaining invariant consistency during resource management, though not in a security-critical sense.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2016-1834_after_exclude_100:48398ba7:spec": {
    "timestamp": "2026-01-17T01:34:17.767407",
    "cve_id": "CVE-2016-1834",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "48398ba7",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code is a string scanner that processes binary data to find strings. While it does handle NUL bytes as string terminators, it is not a regex parser. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 6,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The code processes escape sequences (e.g., \\n, \\t) when encoding characters into a temporary buffer. It checks buffer boundaries (i+32 < sizeof(tmp)) to prevent overflow. This shows moderate relevance to safe escape sequence handling.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "The specification is highly relevant. The code processes potentially untrusted binary data (from a file buffer) and extensively uses length-aware operations: r_buf_read_at with a length, r_utf8_decode with remaining length, and loop conditions checking against buffer boundaries (needle < to). This directly aligns with the specification.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields. The code validates the input range (from, to) and calculates len, checking it's positive and not exceeding ST32_MAX. This is a form of length validation, but the context is file/offset scanning, not a network protocol. Relevance is weak to moderate.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The specification is strongly relevant. The code allocates memory based on the calculated `len` (buf = calloc(len, 1)). It validates `len` is positive and within ST32_MAX before allocation. It also checks if the allocation succeeded and if `min` is non-zero. This aligns with validating size parameters against limits and usage needs.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about protocol implementations and consistent type handling. The code deals with string type detection (ASCII, UTF-8, WIDE, WIDE32) and processes them differently. While there is type handling, it's for local string encoding, not a communication protocol. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 7,
        "reasoning": "The specification is moderately relevant. The code uses `calloc` for the main buffer `buf`, which initializes memory to zero. However, the temporary buffer `tmp` is not fully initialized before use; it is written to incrementally. The `RBinString` structure is allocated with `R_NEW0` which zero-initializes. The principle applies partially.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The specification is about error handling paths maintaining consistent object states. The code has several error returns (e.g., invalid range, allocation failure) that free buffers (buf) and return -1. However, the early return on `if (!buf || !min)` frees `buf` but doesn't clean up other potential resources like `pj`. Consistency is attempted but not perfect. Moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-41225_after_exclude_100:ce69d021:spec": {
    "timestamp": "2026-01-17T01:35:52.544444",
    "cve_id": "CVE-2021-41225",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ce69d021",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification \"Privilege separation failures must enforce immediate process termination\" is not relevant. The code is a TensorFlow graph optimizer (AutoParallel) for distributing computation across GPUs. It involves graph manipulation, node replication, and resource management, but does not handle process privileges, user permissions, or any security boundary that would require privilege separation or termination on failure.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 4,
        "reasoning": "The specification \"Security-critical state transitions require atomic verification\" has weak relevance. While the code manages state (graph nodes, replication sets), these are computational graph states for performance optimization, not security-critical states like authentication, authorization, or system security mode transitions. The operations are not atomic, but atomicity is not a security requirement in this context.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Security-sensitive daemons must validate runtime configuration before operation\" has weak to moderate relevance. The `Initialize` function validates its input (`GrapplerItem`), checking for empty fetch nodes and variables. This is configuration validation, but the component is a graph optimizer, not a security-sensitive daemon (like an authentication service or network listener). The validation is for correctness, not security.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 2,
        "reasoning": "The specification \"View-based data access must perform privilege checks as the view owner\" is very low relevance. The code does not implement database views, data access control, or any privilege model. It manipulates TensorFlow graph nodes and their connections for parallel execution, with no concept of data views or ownership-based access checks.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 3,
        "reasoning": "The specification \"Security-critical state transitions must maintain consistent privilege context\" is very low relevance. Similar to spec_2, the state transitions here are about graph structure (adding division nodes, marking nodes for replication). There is no privilege context (user roles, permissions) involved in these transitions.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The specification \"SQL protocol implementations must enforce view security semantics for all data access\" is completely irrelevant. The code is part of a machine learning framework (TensorFlow) and does not implement SQL protocols, database access, or any relational database security features.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 6,
        "reasoning": "The specification \"Memory allocation operations must maintain consistent size tracking\" has moderate relevance. The code does not explicitly perform memory allocation (like `malloc` or `new`), but it manages collections (`std::set`, `std::map`, `std::vector`) that dynamically allocate memory. Ensuring these data structures are correctly populated and tracked (e.g., `all_nodes_`, `replica_nodes_`) is important for correctness and could prevent issues like use-after-free or double-free if the graph nodes are later manipulated. However, this is more about memory safety than a direct application of the specification.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 7,
        "reasoning": "The specification \"Resource management operations must maintain invariant consistency\" has moderate to strong relevance. The code manages computational resources (graph nodes, GPU distribution). Key invariants are maintained: separating nodes into `replica_nodes_` and `shared_nodes_` based on rules (variables, init ops, input nodes), ensuring no overlap. The function also maintains consistency between `all_nodes_`, `graph_`, and the derived sets. Violating these invariants could lead to incorrect parallel execution or runtime errors, though not necessarily a security vulnerability in the traditional sense.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2021-32037_before_exclude_100:c8c14734:spec": {
    "timestamp": "2026-01-17T01:35:55.339062",
    "cve_id": "CVE-2021-32037",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c8c14734",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code implements random sampling using a storage engine's random cursor (`getRandomCursor`). While the primary purpose is statistical sampling rather than cryptographic randomness, the specification about using cryptographically strong sources for security-sensitive random number generation is relevant. If this sampling mechanism were used for security purposes (e.g., generating tokens, selecting random secrets), its strength would be critical. The code itself does not evaluate the cryptographic quality of the random source, making this a strong but indirect relevance.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Security-sensitive random number generation must use cryptographically strong sources"
      },
      {
        "score": 1,
        "reasoning": "The code deals with query execution and data sampling from a database collection. There is no generation, validation, or handling of authentication session identifiers. The specification is about maintaining cryptographic strength for session IDs, which is completely unrelated to the functionality shown.",
        "spec_index": 1,
        "spec_preview": "HS-AUTH-003: Authentication session identifiers must maintain guaranteed cryptographic strength"
      },
      {
        "score": 7,
        "reasoning": "The code contains several invariant checks and conditional fallbacks (e.g., checking collection locks, verifying conditions for optimization paths, handling empty collections). It ensures that state transitions (like choosing between trial and backup execution plans) maintain correctness under error conditions (e.g., when `numRecords` is zero or `bucketUnpacker` is not set). This aligns with the principle of maintaining invariant properties during error handling, though not exclusively for \"security\" state transitions.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Security state transitions must maintain invariant properties during error conditions"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing or processing. It is focused on database query planning and execution for random sampling. The specification about handling NUL bytes in regex patterns is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is centered on database operations and sampling algorithms. This specification is irrelevant to the provided code.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The code does not perform string processing on potentially untrusted input. It works with internal data structures, numeric calculations, and query plan stages. The specification about length-aware string operations does not apply.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve buffer allocation or memory padding calculations. It deals with high-level database abstractions like cursors, stages, and executors. The specification is not relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform image compression or any encoder/decoder buffer operations. It is unrelated to image processing or bounds checking for compression buffers.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2019-19012_before_exclude_100:f3e15106:spec": {
    "timestamp": "2026-01-17T01:36:02.811854",
    "cve_id": "CVE-2019-19012",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f3e15106",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not perform any memory allocation. It operates on existing string objects passed as operands, reading their byte arrays. Therefore, the specification about initializing memory allocations is not relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple return paths (success/failure) and modifies operand stack pointers (op, op1). While it doesn't have complex error states, it must ensure the operand stack is left in a consistent state on all paths. The \"make_false\" and \"make_true\" calls set a result, but the overall state management of the string objects being manipulated is moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is a string search function within an interpreter (likely PostScript), not a network protocol handler. It does not process network input.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The function searches for a pattern string within another string. It uses `memcmp` with a specified `size`. If the pattern string contains embedded NUL bytes, the search logic should handle them correctly because `size` determines the comparison length, not a NUL terminator. This is directly relevant to the specification's core concept.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code performs a simple byte-by-byte search and comparison. It is not a pattern compiler and does not process escape sequences.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function is a string search routine that operates on potentially untrusted input (string operands). It correctly uses length-aware operations: it checks `r_size` for both strings, calculates a `count` based on sizes, and uses `memcmp` with an explicit `size` parameter for comparison. This avoids reliance on NUL terminators and respects buffer boundaries.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates that the pattern size is not larger than the source string size, which is a basic size constraint. However, it does not perform character encoding validation (it treats data as raw bytes). The connection to \"domain-specific size constraints\" is weak.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 5,
        "reasoning": "This is strongly relevant. The code performs array/buffer operations on `ptr` and `pat`. It validates indices implicitly by calculating `count = r_size(op1) - size` and using it as a loop bound. It also ensures `size > r_size(op1)` leads to an early exit. The pointer arithmetic `ptr += incr` and accesses `*ptr`, `pat[0]`, and the `memcmp` range are all guarded by this pre-validation of the effective search window.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2020-15900_after_exclude_100:08bdebeb:spec": {
    "timestamp": "2026-01-17T01:36:03.628228",
    "cve_id": "CVE-2020-15900",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "08bdebeb",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not perform memory allocation. It operates on existing string objects (op and op1) which are assumed to be already initialized. The specification about initializing memory allocations before use has weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has error handling paths (e.g., when no match is found, it calls make_false and returns). However, the analysis of whether object states remain consistent is not trivial. The function modifies the operand stack (push, assignments to op[-1], op[-3]) and object attributes in both success and failure paths. There is moderate relevance as the specification's principle of maintaining consistent states applies to any function that manipulates data structures.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a string search function within an interpreter (likely PostScript). It is not a network protocol handler. The specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code performs a byte-by-byte string search (memcmp). If the pattern or the searched string contains embedded NUL bytes, the function uses the `size` parameter for length, so NUL bytes are handled correctly as part of the data. This is directly relevant to the specification's concern about handling embedded NULs in patterns.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile patterns or process escape sequences. It is a simple search implementation. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function processes string operands. It correctly uses length-aware operations: it checks `size` (pattern length) against the source string length, uses `r_size` to get lengths, and uses `memcmp` with an explicit size. It does not rely on NUL-terminated strings, making it safe for untrusted input containing NUL bytes. The main principle of the specification directly applies.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform character encoding validation. It treats strings as byte arrays. The specification has very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 5,
        "reasoning": "This is directly and highly relevant. The function performs array/buffer operations on `ptr`, `pat`, and uses computed indices/counts (e.g., `ptr += incr`, `ptr + size`, `count--`). It validates these accesses implicitly by first checking that `size > r_size(op1)` and calculating `count = r_size(op1) - size`. The loop condition `while (count--)` ensures the search stays within the calculated bounds. The accesses `pat[0]` and `memcmp(ptr, pat, size)` are safe because `size` is validated to be <= the source string size, and `pat` points to a string of at least `size` bytes. This is a core requirement of the specification.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2021-32037_after_exclude_100:926d3652:spec": {
    "timestamp": "2026-01-17T01:36:05.026822",
    "cve_id": "CVE-2021-32037",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "926d3652",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code implements random sampling using a storage engine's random cursor (getRandomCursor). While not explicitly generating cryptographic random numbers, the specification about using cryptographically strong sources for security-sensitive random number generation is relevant. If this random sampling is used for security-sensitive operations (like generating tokens or IDs), the quality of randomness matters. The code delegates to the storage engine, so relevance depends on the underlying implementation.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Security-sensitive random number generation must use cryptographically strong sources"
      },
      {
        "score": 2,
        "reasoning": "The code deals with query execution and sampling from collections, not authentication or session management. There is no generation or handling of authentication session identifiers.",
        "spec_index": 1,
        "spec_preview": "HS-AUTH-003: Authentication session identifiers must maintain guaranteed cryptographic strength"
      },
      {
        "score": 7,
        "reasoning": "The code uses invariants (invariant(opCtx->lockState()->isCollectionLockedForMode(...))) to enforce preconditions and has multiple conditional return paths. It must maintain correct state transitions (e.g., lock states, plan executor creation) during error conditions. The TrialStage mechanism for switching plans also involves state management.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Security state transitions must maintain invariant properties during error conditions"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or processing. It focuses on database query execution and sampling algorithms.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code does not directly process strings, it handles potentially untrusted input (sampleSize, numRecords) in calculations. However, it uses arithmetic and comparisons, not string operations. The relevance is very indirect.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit buffer allocation. It creates plan executors and stages using smart pointers and standard containers. Any buffer allocation would be internal to the storage engine or lower-level components, not visible here.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve image compression, encoder buffers, or any multimedia processing. It is purely database query execution logic.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2021-32037_before_exclude_100:89306182:spec": {
    "timestamp": "2026-01-17T01:37:38.480968",
    "cve_id": "CVE-2021-32037",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "89306182",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code implements random sampling using a storage engine's random cursor (`getRandomCursor`). While the primary purpose is statistical sampling rather than cryptographic randomness, the specification about using cryptographically strong sources for security-sensitive random number generation is relevant. If this sampling mechanism were used for security-sensitive operations (like generating tokens or IDs), the quality of the random source would be critical. The code itself doesn't evaluate the cryptographic strength of the underlying cursor, making this a strong but not direct relevance.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Security-sensitive random number generation must use cryptographically strong sources"
      },
      {
        "score": 2,
        "reasoning": "The code deals with query execution and sampling from collections, not authentication or session management. There is no generation, validation, or handling of authentication session identifiers. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-AUTH-003: Authentication session identifiers must maintain guaranteed cryptographic strength"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Security state transitions must maintain invariant properties during error conditions"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or processing. It is focused on database query execution plans and random sampling. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or string pattern compilation. It is unrelated to the specification.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code primarily works with numeric calculations, plan stages, and cursors. There is no evident string processing of potentially untrusted input. While query parameters could ultimately influence values like `sampleSize`, the immediate code does not perform length-aware string operations. The connection is very weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates objects like `WorkingSet` and various plan stages using `std::make_unique`. There is no manual buffer allocation or explicit padding calculations. The specification about buffer allocation with safety margins is not directly applicable, though memory safety principles indirectly apply to all C++ code.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform image compression, encoder/decoder operations, or any related bounds checking for media buffers. The specification is completely unrelated to the code's domain.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2021-32037_after_exclude_100:7ecfc28c:spec": {
    "timestamp": "2026-01-17T01:37:45.661256",
    "cve_id": "CVE-2021-32037",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7ecfc28c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code implements random sampling using a storage engine's random cursor (`getRandomCursor`). Specification HS-SEC-001 is strongly relevant because the function's core purpose is to create a random sampling executor. The security of the random sampling depends on the underlying storage engine's implementation. If the random cursor does not use a cryptographically strong source, it could introduce vulnerabilities in features relying on unbiased, unpredictable sampling. The code does not directly implement the RNG but depends on an external component, which must be evaluated for cryptographic strength.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Security-sensitive random number generation must use cryptographically strong sources"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-AUTH-003 is very low relevance. The code deals with database query execution for random sampling from a collection. There is no authentication, session management, or generation/validation of session identifiers in this code snippet.",
        "spec_index": 1,
        "spec_preview": "HS-AUTH-003: Authentication session identifiers must maintain guaranteed cryptographic strength"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 has moderate relevance. The function uses an `invariant` to check lock state and has multiple conditional branches that return early or create different execution plans (TrialStage). While not explicitly about security state transitions, the principle of maintaining invariants and consistent state during error/edge conditions (e.g., failed cursor creation, sharded vs. non-sharded, timeseries logic) is present. The function must ensure the system remains in a valid state regardless of which path is taken.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Security state transitions must maintain invariant properties during error conditions"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-001 is not relevant. The code does not process regular expressions or parse input patterns containing NUL bytes. It handles numeric parameters and collection metadata.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-002 is not relevant. The code does not involve pattern compilers, escape sequence processing, or protocol parsing. It is focused on query planning and execution.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 (first part) has very low relevance. The code primarily works with numeric calculations, object pointers, and plan stages. There is no obvious string processing of untrusted input in this specific function. Any string handling would be in deeper layers not shown here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 (second part) has very low relevance. The code does not perform explicit buffer allocation. Memory management is handled via standard library types (std::unique_ptr, std::make_unique) and the query execution engine. There is no visible calculation of buffer sizes or padding.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-004 is not relevant. The code does not perform image compression, encoder/decoder operations, or related buffer bounds checking. It is a database query execution function.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2022-21654_before_exclude_100:9ca1d454:spec": {
    "timestamp": "2026-01-17T01:37:59.792584",
    "cve_id": "CVE-2022-21654",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9ca1d454",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code involves X.509 certificate processing (X509_digest), but it is not performing ASN.1 parsing or signature verification. The specification about validating ASN.1 structure lengths is related to a deeper parsing level than what this function does. The connection is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Cryptographic signature verification must validate all ASN.1 structure lengths against..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement or call PKCS#1 v1.5 verification. It is updating a digest for session ID generation, not verifying RSA signatures. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: PKCS#1 v1.5 verification must enforce minimum padding requirements regardless of publ..."
      },
      {
        "score": 5,
        "reasoning": "The code uses an X.509 certificate object (ca_cert_) to compute a digest. While it assumes the certificate object is valid, it does not perform the structural validation itself. The specification has weak relevance as proper validation should have occurred before this point.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: X.509 parsers must validate all structural metadata before processing certificate c..."
      },
      {
        "score": 5,
        "reasoning": "The code uses a ScopedEVP_MD_CTX (likely RAII) and does not explicitly manage resource cleanup. The specification about conditional cleanup is not directly relevant to the shown code flow.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "The code uses a fixed hash algorithm (EVP_sha256) and does not create key objects. The specification about verifying algorithm support before key creation is not directly applicable.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 5,
        "reasoning": "The code is related to X.509 certificates and TLS session IDs, not DNSSEC. The specification is completely unrelated to the code scenario.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 5,
        "reasoning": "The code's purpose is to incorporate cryptographic parameters (CA cert, certificate hashes, SPKI hashes) into a session ID digest to ensure clients are validated against correct settings. This aligns with the principle of validating/using correct parameters for authentication (session resumption). The main action is hashing these parameters, which is a critical step for the authentication operation of session validation.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-001: Cryptographic parameters must be fully validated before use in authentication operati..."
      },
      {
        "score": 5,
        "reasoning": "The function is part of a TLS/SSL protocol implementation, ensuring that session resumption respects validation settings. It enforces a validation step (hashing configuration) as part of the protocol's state management. However, it does not directly enforce steps like signature verification.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must enforce all cryptographic validation steps specified ..."
      }
    ]
  },
  "CVE-2021-40576_before_exclude_100:c055b948:spec": {
    "timestamp": "2026-01-17T01:38:36.241813",
    "cve_id": "CVE-2021-40576",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c055b948",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code dereferences pointers (hmhd, trak->Media, etc.) without explicit validation that all intermediate allocations and initializations were successful. While not a direct memory allocation function, the principle of ensuring objects are fully initialized/valid before use is moderately relevant. The code checks `hmhd->type` after casting, assuming the structure is properly initialized.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function has multiple error paths (e.g., when hmhd is NULL or subType is NULL). The code attempts to handle the NULL hmhd case but does so after already dereferencing `hmhd->type` on line 3, which would cause a crash. This is an inconsistent state and error handling flaw. The logic flow is problematic.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code processes a local media track box structure, not network protocol input. There is no network handling in this function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve regular expression parsing or pattern matching. It deals with media box structures.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve pattern compilers or processing of escape sequences. It is a media format inspection function.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function does not process strings. It works with binary structures and integer types. The principle of length-aware operations does not apply here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not parse protocol message length fields. It retrieves a hint format subtype from a media header box. While there may be length fields in the broader context, this specific function does not validate them.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function does not perform memory allocation. However, it accesses list elements (gf_list_get) without checking if the list is empty, which could lead to accessing invalid memory. This relates indirectly to validating parameters before usage, but is not about allocation size parameters.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-21654_after_exclude_100:3c5382e4:spec": {
    "timestamp": "2026-01-17T01:38:39.647779",
    "cve_id": "CVE-2022-21654",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3c5382e4",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code involves X.509 certificate processing (X509_digest) but does not perform ASN.1 parsing or signature verification itself. The specification about validating ASN.1 structure lengths is only weakly relevant as the code uses high-level OpenSSL functions rather than parsing raw ASN.1 data.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Cryptographic signature verification must validate all ASN.1 structure lengths against..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement PKCS#1 v1.5 verification or RSA padding checks. It focuses on certificate validation configuration hashing for session IDs, not cryptographic signature verification.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: PKCS#1 v1.5 verification must enforce minimum padding requirements regardless of publ..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: X.509 parsers must validate all structural metadata before processing certificate c..."
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The code uses bssl::ScopedEVP_MD_CTX which likely handles cleanup automatically via RAII. There's no explicit resource initialization or cleanup logic visible in this function.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code uses EVP_DigestUpdate and X509_digest with hardcoded SHA256, but doesn't create key objects or verify algorithm support dynamically. The cryptographic operations are simple hashing, not asymmetric cryptography.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 5,
        "reasoning": "No relevance. The code has nothing to do with DNSSEC key processing or maintaining object state across code paths for DNSSEC operations.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function updates a digest for session ID generation based on certificate validation parameters (CA cert, hash lists, trust settings, CRL, etc.). This ensures session resumption respects security configurations. The principle of validating cryptographic parameters before use in authentication applies to ensuring these settings are properly incorporated.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-001: Cryptographic parameters must be fully validated before use in authentication operati..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code implements part of a TLS/SSL protocol stack (session resumption validation) and enforces that session IDs incorporate all relevant validation settings. This helps ensure cryptographic validation steps are properly accounted for during session resumption, though it doesn't implement the validation steps themselves.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must enforce all cryptographic validation steps specified ..."
      }
    ]
  },
  "CVE-2021-40576_after_exclude_100:32f1717d:spec": {
    "timestamp": "2026-01-17T01:39:11.183393",
    "cve_id": "CVE-2021-40576",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "32f1717d",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation operations. It primarily accesses and validates existing data structures. While uninitialized pointers (like `hmhd->subType`) could be accessed, this is more about pointer validation than memory initialization after allocation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This code processes local media file structures (MP4/ISOBMFF boxes), not network protocols. No network input validation is involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not use regular expressions or parse input patterns containing NUL bytes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not compile patterns or process escape sequences.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the code processes data structures that could come from untrusted files, it does not use string processing functions. It works with box types and pointers, not string operations.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code validates box types but does not process protocol message length fields or check against integer limits.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform memory allocation operations. It accesses existing data structures but doesn't allocate new memory or validate size parameters for allocation.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2016-6295_before_exclude_100:4ca91b0b:spec": {
    "timestamp": "2026-01-17T01:39:30.835305",
    "cve_id": "CVE-2016-6295",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4ca91b0b",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs memory operations (e.g., `memcpy` for object handlers, `zend_hash_init`). While it doesn't show explicit memory allocation like `malloc`, the initialization of handlers and hash tables is present. The relevance is moderate because the specification about initializing memory allocations is a general good practice that applies to any code dealing with memory structures, but the code shown is primarily about module initialization and registration, not core data processing with uninitialized memory risks.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code includes error handling setup (disabling logging, registering log handlers) and defines error constants. It ensures consistent state by initializing the SNMP library and setting up class properties. The relevance is moderate to strong because the module initialization must maintain a consistent state even if parts fail (e.g., log handler registration), though the code doesn't show complex state transitions or cleanup on error paths in detail.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is SNMP module initialization code. SNMP is a network protocol. The specification about validating input before processing is highly relevant because the SNMP functions (not shown here, but registered via `php_snmp_class_methods`) will handle network data. The initialization sets up the environment for these handlers, making the principle directly applicable. However, the validation logic itself is not visible in this snippet.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve file parsing or accessing file offsets. It is initializing a PHP extension module, registering classes and constants. The specification is about file boundary checks, which is not relevant to this scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File parsing must validate all offsets against file boundaries before access"
      },
      {
        "score": 2,
        "reasoning": "The code does not contain a parser or any logic that could lead to an infinite loop. It is a linear initialization routine. The specification about parser state and progress validation is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Parser state must include progress validation to prevent infinite loops"
      },
      {
        "score": 2,
        "reasoning": "Similar to spec_4, this code does not perform file operations. It deals with module initialization, class registration, and constant definition. The specification about validating file positions is irrelevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File operations must validate all derived positions against file size"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsers or processing of input patterns containing NUL bytes. It is setting up SNMP functionality and related PHP classes. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not contain a pattern compiler or process escape sequences. It initializes the Net-SNMP library and registers PHP internal structures. This specification is not relevant to the provided code.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2016-6295_after_exclude_100:29800a11:spec": {
    "timestamp": "2026-01-17T01:39:38.332887",
    "cve_id": "CVE-2016-6295",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "29800a11",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs memory operations (memcpy) and initializes data structures (zend_hash_init). While it does initialize handlers and properties, it's not directly about initializing raw memory allocations to prevent information leaks or use of uninitialized memory. The relevance is moderate as the principle of initialization applies to the object handlers and property hash table setup.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code registers a destructor (php_snmp_session_destructor) and sets up error handling by disabling logging and using exit statuses. It also defines error constants. This relates to maintaining consistent state during error conditions, though the actual error handling implementation is not fully visible in this initialization code. The principle of consistent state management during errors is relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 8,
        "reasoning": "This is SNMP module initialization code. SNMP is a network protocol, and the module will handle network communications. While this specific code shows initialization and constant registration, the overall module must validate input before processing network requests. The specification directly applies to the purpose of this code module.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve file parsing or file boundary validation. It's initializing an SNMP module with class definitions and constants. Very low relevance to file operations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File parsing must validate all offsets against file boundaries before access"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve parsing or state machines that could enter infinite loops. It's straightforward initialization code without loops or complex state transitions. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Parser state must include progress validation to prevent infinite loops"
      },
      {
        "score": 2,
        "reasoning": "Similar to spec 4, this code does not perform file operations or position validation against file sizes. It's module initialization code unrelated to file handling.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File operations must validate all derived positions against file size"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or handling of NUL bytes in patterns. It's initializing SNMP constants and class definitions. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It's setting up SNMP module infrastructure, not compiling patterns or processing escape sequences. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-2175_before_exclude_100:24b0fcd1:spec": {
    "timestamp": "2026-01-17T01:40:11.858468",
    "cve_id": "CVE-2022-2175",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "24b0fcd1",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It handles command line input and register insertion in an editor context. The input is processed via plain_vgetc() for single characters, not pattern strings with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code processes escape sequences (like ESC and Ctrl+R) in a command line context, which is a form of pattern/escape handling. However, it's not a pattern compiler in the traditional sense (like regex). The principle of maintaining boundaries when interpreting control characters has some conceptual connection.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code processes user input (via plain_vgetc()) and pastes it via cmdline_paste(). While it reads character by character, the pasted content could be untrusted. The specification's principle of using length-aware operations for untrusted input is a relevant secure coding practice for any input handling, though the exact mechanism here is character-oriented.</spec_1_reasoning>\n<spec_4_score>2</spec_2_reasoning>\n<spec_4_reasoning>Very low relevance. The code snippet does not show explicit dynamic memory allocation. It manipulates command line state (ccline) but does not demonstrate allocation or initialization of new memory buffers within this function.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code snippet does not show explicit dynamic memory allocation. It manipulates command line state (ccline) but does not demonstrate allocation or initialization of new memory buffers within this function.</spec_3_reasoning>\n<spec_5_score>7</spec_5_score>\n<spec_5_reasoning>Moderate to strong relevance. The code has multiple error handling paths (beep_flush() on recursive condition, aborting() check). It must ensure the command line state (ccline, no_mapping, allow_keys) remains consistent when errors occur or when escaping. The specification's principle directly applies to maintaining state consistency in error paths.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The code has multiple error handling paths (beep_flush() on recursive condition, aborting() check). It must ensure the command line state (ccline, no_mapping, allow_keys) remains consistent when errors occur or when escaping. The specification's principle directly applies to maintaining state consistency in error paths.</spec_4_reasoning>\n<spec_6_score>2</spec_6_score>\n<spec_6_reasoning>Very low relevance. This is a local command line input function for an editor, not a network protocol handler. There is no network input processing in this code.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This is a local command line input function for an editor, not a network protocol handler. There is no network input processing in this code.</spec_5_reasoning>\n<spec_7_score>1</spec_7_score>\n<spec_7_reasoning>Very low relevance. The code does not process protocol messages or length fields. It handles individual keystrokes and command line state.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not process protocol messages or length fields. It handles individual keystrokes and command line state.</spec_6_reasoning>\n<spec_8_score>2</spec_8_score>\n<spec_8_reasoning>Very low relevance. Similar to spec 4, the code does not show explicit memory allocation operations where size parameters need validation. Its operations are on existing command line buffers and character input.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-2175_after_exclude_100:0a9cd4ff:spec": {
    "timestamp": "2026-01-17T01:40:19.507189",
    "cve_id": "CVE-2022-2175",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0a9cd4ff",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It handles command-line input for inserting register contents. The specification about embedded NUL bytes in regex patterns is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The code processes some escape-like sequences (Ctrl-R, Ctrl-O, ESC) but these are for command-line editing, not pattern compilation or escape sequence processing in the sense of a pattern compiler. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The code processes user input (via `plain_vgetc()`) and pastes it into the command line. While it uses character-by-character input, the subsequent paste operation (`cmdline_paste`) likely involves string handling. Using length-aware operations for the pasted content (which could be from a register containing untrusted data) is a relevant secure coding principle.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code snippet does not show explicit memory allocation. It manipulates command-line state variables and calls functions that may allocate memory internally, but the initialization principle is not directly visible or a primary concern in this specific function.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error/abort paths (e.g., beep on recursive call, password mode check, serious error via `aborting()`). It attempts to maintain state consistency by resetting `new_cmdpos` and handling the `gotesc` flag. This aligns with the principle of maintaining consistent object states during error handling.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "This is a local command-line input handler, not a network protocol handler. The principle of validating input before processing is generally good, but the specification is specifically about network protocols, making it largely irrelevant to this code.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol messages or length fields. It deals with interactive keyboard input for a text editor's command line. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Similar to spec 4, this code snippet does not contain visible memory allocation calls. Any allocations would be in called functions (like `cmdline_paste` or `get_expr_register`). Therefore, the specification's direct relevance to this code block is very low.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2019-1010065_after_exclude_100:c379cc8a:spec": {
    "timestamp": "2026-01-17T01:41:00.442055",
    "cve_id": "CVE-2019-1010065",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c379cc8a",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory with `cli_malloc` but does not initialize it before reading data into it with `fread`. This is a direct violation of the principle that memory must be initialized before use, as uninitialized memory could contain sensitive data or cause undefined behavior if the read fails partially. The specification is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The function has multiple error handling paths (OOM, fread failure). In the fread failure path, it correctly frees the allocated memory before returning NULL, maintaining a consistent state. However, the success path also transforms the string in-place, which is consistent. The specification strongly applies to evaluating this error handling.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The specification is about network protocol handlers. This code reads from a file (FILE *f), not a network protocol. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. This code processes a string from a file, performing a simple byte-packing operation. It is not related to regex parsing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. This code does not compile patterns or process escape sequences. It reads raw data and transforms it.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 10,
        "reasoning": "This specification is directly applicable. The function processes input (from a file) of a specified `len`. It uses length-aware operations: it bounds `len` to 400, allocates `len+1`, and reads exactly `len` bytes. The subsequent loop that transforms the string also correctly uses `len` as its bound. This is a textbook example of length-aware operations for potentially untrusted input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This is a more specific version of Spec 2, focusing on memory state. The function has two main branches: success and failure (OOM or read error). In the OOM case, no memory is allocated. In the read error case, the allocated memory is freed. In the success case, memory is used and a valid pointer is returned. Memory state is consistent across all branches, making this specification highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "The function performs input validation by checking `len` and establishing a boundary (`if (len>400) len=400;`) before performing the critical memory allocation (`name = cli_malloc(len+1);`) and file read operation. This directly aligns with the specification's requirement to establish clear boundaries before memory operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2019-1010065_before_exclude_100:939e9692:spec": {
    "timestamp": "2026-01-17T01:41:09.269174",
    "cve_id": "CVE-2019-1010065",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "939e9692",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory with `cli_malloc` but does not initialize it before reading data into it with `fread`. This is acceptable because `fread` will write to the buffer. However, after processing, the second half of the buffer (from `i/2` to `len-1`) contains uninitialized data from the original read, which is then left unused but still part of the allocated block. The specification about initializing memory before use is relevant, but the primary risk is not severe here as the uninitialized data is not directly used after the transformation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification is about network protocol handlers. This code reads from a file (`FILE* f`), not a network protocol. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. This code processes a string from a file with a specific transformation but does not involve regular expressions. It does handle NUL bytes implicitly (the input may contain them, and the transformation could create them), but that's not the primary focus. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. This code does not compile patterns or process escape sequences. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes input from a file (potentially untrusted) and uses length-aware operations: it limits `len` to 400, allocates based on `len`, reads exactly `len` bytes, and loops based on `len`. However, the transformation `name[i/2] = name[i]` assumes the input is a 2-byte sequence per character (e.g., UTF-16LE) but does not validate this structure. If `len` is odd, the loop may access `name[len-1]` (safe) but the final `name[i/2]='\\0'` might calculate an index incorrectly? Actually, `i` increments by 2, so if `len` is odd, the last iteration `i` equals `len-1`, then `i` becomes `len+1`, exiting the loop. `i/2` at the end is `(len+1)/2`, which could be one byte beyond the midpoint. This is length-aware but the logic may be off for odd lengths. The principle is highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The function has multiple execution branches: success, allocation failure, and read failure. In the allocation failure path, it returns NULL (no memory to free). In the read failure path, it frees the allocated memory before returning NULL, preventing a leak. This maintains consistent memory state across branches. The score is 10 because it directly applies and the code follows it correctly.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "The code validates input by checking `len` and capping it at 400 before any memory allocation or read operation. This establishes a clear boundary for the subsequent memory operations (`cli_malloc(len)` and `fread`). However, it does not validate `ptr` (file offset) before seeking, which could lead to invalid seeks or reads beyond file boundaries. The principle is strongly relevant, but the validation is incomplete.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2016-3136_before_exclude_100:174364e6:spec": {
    "timestamp": "2026-01-17T01:41:16.839533",
    "cve_id": "CVE-2016-3136",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "174364e6",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not directly parse protocol messages with length fields. It is a USB HID probe function that initializes a device driver. While HID communication involves messages, this specific function handles device initialization, not the parsing of individual protocol data units where length validation would occur.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code is a device probe routine, not a protocol implementation that processes data with variable types. It deals with kernel structures (hid_device, usb_device) and kernel APIs, where type consistency is enforced by the compiler and kernel framework.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The function does not process userspace-provided array lengths. It receives kernel-level `hid_device` and `hid_device_id` pointers from the kernel's device matching mechanism. There is no direct userspace input being processed here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. Similar to spec 1 and 3, this function does not act as a protocol message handler. Its primary role is device initialization and starting the HID hardware. Any protocol handling would occur elsewhere in the driver (e.g., in the `elo_work` function or HID callbacks).",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The only buffer allocation is for the fixed-size `struct elo_priv`. There is no allocation based on variable or user-controlled input in this function. The \"worst-case input scenario\" consideration does not apply to this static allocation.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The function manages shared resources: it allocates a private structure (`priv`), assigns it to the HID device via `hid_set_drvdata`, and starts hardware. The state transitions (allocation -> assignment -> hardware start) must be consistent. The error path (`err_free`) ensures cleanup if transitions fail, but there's a potential issue: if `queue_delayed_work` fails or races with cleanup in an error path not shown, resource state could become inconsistent. The current code shows partial protection through the `ret` check flow.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. This is a key concern for the function. It allocates a resource (`priv`), associates it with the HID device (`hid_set_drvdata`), and with a USB device (`usb_get_dev`). The error handling path (`err_free`) must maintain strict consistency: if `hid_parse` or `hid_hw_start` fails, it frees `priv`. However, it does NOT call `usb_put_dev(priv->usbdev)` to balance the `usb_get_dev`, creating a resource leak and inconsistency between the allocated memory and the reference-counted USB device. This is a direct violation of maintaining consistency between tracking structures.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2016-3136_after_exclude_100:4f63d3d6:spec": {
    "timestamp": "2026-01-17T01:41:51.459585",
    "cve_id": "CVE-2016-3136",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4f63d3d6",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not parse protocol messages with length fields. It's a probe function for a HID device driver, dealing with device initialization, not processing incoming data packets. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not implement a protocol with variable types that need consistent handling. It deals with kernel APIs and structures in a straightforward manner.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The function is a kernel probe routine, not processing userspace-provided array lengths. Inputs come from the kernel's device and bus infrastructure.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not contain protocol message handlers for variable-length components. It initializes a device driver.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The buffer allocation (`priv`) is for a fixed-size structure, not for input data. The principle of accounting for worst-case scenarios is not directly applicable here, though it's a general good practice.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The function manages resource state (allocated `priv`, `usb_get_dev`). While not explicitly using atomic operations, the control flow ensures clean-up on error paths (`err_free`). However, in a concurrent scenario (e.g., if probe could be called multiple times for the same device), lack of protection for shared resources (like a global `wq`) could be an issue, making the specification's principle relevant.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. This is highly applicable. The function allocates multiple resources (`priv` memory, a reference to `usbdev` via `usb_get_dev`, schedules delayed work) and must maintain consistency. The `err_free` cleanup path correctly releases all acquired resources if earlier steps fail, ensuring state consistency. This is a core part of the function's logic.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2013-2206_before_exclude_100:e972aa77:spec": {
    "timestamp": "2026-01-17T01:42:18.241502",
    "cve_id": "CVE-2013-2206",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e972aa77",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates the user-provided `optlen` against a minimum size (`sizeof(struct sctp_authkey)`). However, it does not validate against a maximum system constraint before using it for memory allocation, which is the core of the specification. The principle of validating user-provided lengths before processing is directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code handles a variable-length structure (`sctp_authkey` with a key payload). It performs a basic integrity check by verifying `sca_keylength` does not exceed the total `optlen`. This aligns with the specification's principle of verifying variable-length components, though the context is a socket option, not a network protocol message.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code allocates a buffer (`kmalloc`) based directly on the user-controlled `optlen` without imposing an explicit upper bound. This is a classic example of failing to account for worst-case input scenarios, which could lead to excessive memory allocation or integer overflow in the allocator. The specification's principle directly addresses this risk.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates a length field (`authkey->sca_keylength`) against the total buffer size (`optlen`). This is a form of integer validation, though it's not specifically checking for platform-specific integer limits (like overflow when adding header size to length). The general principle of validating length fields is present.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is the most direct specification. The code uses the user-provided `optlen` for memory allocation (`kmalloc`) and later for usage (`copy_from_user`, `sca_keylength` check). It validates `optlen` against a minimum but not against a maximum allocation limit or for potential integer wrap-around, failing to fully meet this specification's requirements.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification concerns consistent type handling across protocol stages. The target code is a socket option handler that copies and validates a single structure. There is no complex protocol parsing or multiple processing stages with type conversion issues evident here.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is explicitly about USB request processing. The target code handles an SCTP (Stream Control Transmission Protocol) socket option, which is a network protocol, not USB.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is explicitly about USB/IP protocol implementation. The target code is part of the SCTP kernel implementation and has no relation to USB or the USB/IP protocol.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2021-37647_before_exclude_100:a1540d10:spec": {
    "timestamp": "2026-01-17T01:42:36.810998",
    "cve_id": "CVE-2021-37647",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a1540d10",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor validation and dataset creation, not cryptographic operations on secret values. No timing-sensitive operations on secrets are present.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code deals with sparse tensor processing in a machine learning context, not elliptic curve cryptography or any cryptographic curve models.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No cryptographic processing or secure memory operations are performed in this tensor manipulation code.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code performs input validation (OP_REQUIRES) before creating objects, which aligns with the principle of conditional resource creation based on successful validation. However, it's not specifically about cleanup after failed initialization.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "No cryptographic algorithms or key objects are involved in this tensor processing code.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to DNSSEC, key processing, or network protocols.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 7,
        "reasoning": "Strong relevance. The code performs bounds validation through shape checking (TensorShapeUtils::IsMatrix, IsVector) and index validation in the loop. While not traditional fixed buffers, tensor dimensions act as bounds that must be validated before access operations.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code implements comprehensive input validation before processing: checking tensor shapes, validating indices ordering, and verifying dimensions. This directly aligns with the principle of complete input size validation before processing.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2021-37647_after_exclude_100:ca4249ec:spec": {
    "timestamp": "2026-01-17T01:42:54.994171",
    "cve_id": "CVE-2021-37647",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ca4249ec",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor validation and dataset creation, not cryptographic operations on secret values. There are no timing-sensitive comparisons or cryptographic algorithms present.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code deals with sparse tensor operations in a machine learning context, not elliptic curve cryptography or any cryptographic curve models.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation and validation, not cryptographic processing that requires constant-time memory operations. No secret data is being processed.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 3,
        "reasoning": "Weak connection. The code validates inputs before creating resources (Dataset object), which aligns with the principle of conditional resource creation on successful validation. However, this is not about cleanup after failed initialization.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "The code validates tensor shapes and values before creating a SparseTensor, but this is not about cryptographic algorithm support verification or key object creation.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 1,
        "reasoning": "The code is unrelated to DNSSEC key processing or maintaining cryptographic object state across code paths.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code performs bounds validation by checking tensor shapes and dimensions before processing. It validates that indices is a matrix, values is a vector, and checks index ordering. However, it doesn't deal with fixed buffers in the traditional C array sense.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code implements comprehensive input validation before processing: checking tensor shapes, dimensions, element counts, and index ordering. It validates that indices should be a matrix, values should be a vector, dense_shape should be a vector, and performs consistency checks between indices and values sizes.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2013-2206_after_exclude_100:d5ff394f:spec": {
    "timestamp": "2026-01-17T01:42:57.208964",
    "cve_id": "CVE-2013-2206",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d5ff394f",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates the user-provided `optlen` against a minimum size (`sizeof(struct sctp_authkey)`) before processing. This directly aligns with validating userspace-provided lengths against system/structural constraints.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code validates that the variable-length key data (`sca_keylength`) fits within the allocated buffer (`optlen - sizeof(struct sctp_authkey)`). This is a form of structural integrity check for a variable-length component within the `sctp_authkey` structure.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code allocates memory based directly on the user-provided `optlen` without an explicit, predefined upper bound. While it later validates an internal field against this allocation, it does not account for a worst-case scenario with an explicit, safe maximum limit before the `kmalloc`, which is the core of this specification.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The specification's principle of validating length fields applies. The code validates `sca_keylength` against the buffer size derived from `optlen`. However, `optlen` itself is a signed `int` from userspace, and its validation against platform-specific integer limits (e.g., for overflow in the `kmalloc(optlen, GFP_KERNEL)` call) is not explicitly shown, which is a key part of this spec.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs a critical validation: it checks that the `sca_keylength` field does not exceed the allocated buffer size (`optlen - sizeof(struct sctp_authkey)`). This validates the size parameter (`sca_keylength`) against subsequent usage requirements (copying/processing the key).",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification focuses on consistent type handling across protocol stages. The target code is a socket option handler that deals with a single, well-defined structure (`sctp_authkey`). There is no evident type conversion or multi-stage protocol processing where type consistency could be an issue.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is explicitly about USB request processing. The target code is for the SCTP network protocol socket options and has no relation to USB.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is explicitly about USB/IP protocol implementation. The target code is for the SCTP network protocol and is unrelated to USB/IP.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2021-4166_before_exclude_100:529be57c:spec": {
    "timestamp": "2026-01-17T01:43:32.494701",
    "cve_id": "CVE-2021-4166",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "529be57c",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not contain any regular expression parsing logic. It handles file arguments and window/tab management in an editor context. There is no processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It focuses on window layout management, buffer handling, and file opening operations.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses string operations like `fullpathcmp()` which compares file paths. While not directly processing untrusted input in a network sense, it handles file names from the argument list which could be influenced externally. However, the code doesn't show explicit length-aware operations on these strings.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code allocates memory with `alloc_clear(opened_len)` which clears/initializes the memory. This follows good practice for memory initialization. The `opened` array is then used throughout the function, so proper initialization is important.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code has extensive error handling with checks for window/tab validity after autocommands, buffer state validation, and cleanup paths. It maintains consistent states through reference counting (`al_refcount`), proper cleanup with `alist_unlink()`, and state restoration at function exit.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is not network protocol code. It handles editor commands and file operations locally. No network input validation is present.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code doesn't process network protocol messages with length fields. It works with editor argument lists and window management.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code performs memory allocation with `alloc_clear(opened_len)` where `opened_len = ARGCOUNT`. While not explicitly shown, there should be validation that `ARGCOUNT` is reasonable before allocation. The code checks `ARGCOUNT <= 0` early, but doesn't show upper bound validation. The allocation size is used to create an array that's indexed by `i`, so proper size validation is important.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-4166_after_exclude_100:e1cc4773:spec": {
    "timestamp": "2026-01-17T01:44:01.026728",
    "cve_id": "CVE-2021-4166",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e1cc4773",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It handles window and buffer management in Vim, dealing with file arguments and tab/window layout. There is no pattern matching or regex processing that would need to handle embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not contain pattern compilation or escape sequence processing. It focuses on UI management, window operations, and file loading. No lexical analysis or pattern compilation is present.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2016-7515_before_exclude_100:d34c5448:spec": {
    "timestamp": "2026-01-17T01:44:49.281771",
    "cve_id": "CVE-2016-7515",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d34c5448",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code reads pixel data into a buffer but does not perform memory allocation itself. The `GetAuthenticPixels` function likely allocates memory, but the code shown does not initialize the allocated memory before use. However, the primary operation is reading and setting pixel values, not allocation/initialization, making relevance weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function returns MagickFalse on pixel retrieval failure and uses exception handling. However, after partial pixel processing (especially in the depth <= 1 branch with bit-level operations), if an error occurs later, the image state might be partially modified. The SyncAuthenticPixels call at the end is critical for consistency. Moderate relevance because error paths exist but their full consistency impact isn't fully visible.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "The code parses PSD image data from a memory buffer, not network protocol data. Network protocol validation principles do not directly apply. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "This is a PSD image format parser function. It processes pixel data based on parameters like channels, type, packet_size, and image->depth. While it doesn't validate headers directly, it relies on previously validated fields (packet_size, depth, columns). The function's correct operation depends on prior validation of these critical fields. Strong relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 3,
        "reasoning": "The function does not perform memory allocation directly; it uses GetAuthenticPixels. Size parameters (like image->columns) are used in loops but not explicitly validated against allocation size here. Weak relevance as allocation guarding is not visible in this snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "Specification is specifically for BMP parsers. This code is for PSD format parsing. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 8,
        "reasoning": "As an image parser, it must ensure structural relationships are valid (e.g., packet_size matching depth, channels, and type). The function uses these fields to interpret pixel data. If relationships are invalid, buffer over-reads or misinterpretation could occur. Strong relevance, though validation likely happened earlier.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 9,
        "reasoning": "The code indexes the pixel buffer `p` and the pixel queue `q` in loops based on `image->columns` and `packet_size`. While it doesn't explicitly check bounds against the allocated buffer size, it relies on `packet_size` to read bytes and uses `GetAuthenticPixels` for the destination. However, if `pixels` input buffer is too small, buffer over-read occurs. Explicit bounds validation is highly relevant for security.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      }
    ]
  },
  "CVE-2016-7515_after_exclude_100:46c3d522:spec": {
    "timestamp": "2026-01-17T01:45:02.578967",
    "cve_id": "CVE-2016-7515",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "46c3d522",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses `GetAuthenticPixels` and `GetAuthenticIndexQueue` which likely perform memory allocation. However, the code does not show explicit initialization of the allocated memory before use. The pixel data is written via `SetPSDPixel` and `q++`, but this is assignment, not initialization of the entire allocated buffer. The relevance is weak because the specification is about ensuring all allocated memory is initialized, but the code's handling is indirect through library functions.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function returns `MagickFalse` if `GetAuthenticPixels` fails, and returns the result of `SyncAuthenticPixels`. There is some error handling, but it's not clear if object states (like `image` internal state) are consistently maintained on all error paths (e.g., if `SetPSDPixel` fails). Moderate relevance because error handling exists but its completeness is uncertain.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a PSD image parser reading pixel data from a buffer, not a network protocol handler. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The function reads PSD channel pixels, which is part of image format parsing. It relies on parameters like `channels`, `type`, `packet_size`, and `image->depth` which should have been validated earlier (e.g., header fields). The code itself does not validate these, but the specification principle strongly applies to the overall context of this parser function.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Memory allocation is hidden inside `GetAuthenticPixels`. The function uses `image->columns` in loops but does not explicitly validate it before allocation. Weak relevance because the allocation is not directly visible, but size parameters like `image->columns` could affect allocation size.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for BMP parsers, but this is a PSD parser. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "As part of a PSD file parser, this function processes pixel data based on structural parameters (channels, type, packet_size, depth). It assumes these are valid and consistent. The specification strongly applies because validation of structural relationships (e.g., between channels, depth, and pixel data size) should occur before reaching this function.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The code indexes `pixels` buffer via pointer `p` and uses `x` to iterate up to `image->columns`. There is no explicit bounds check against the allocated size of the `pixels` buffer (passed as parameter). However, the loop uses `packet_size` to advance `p`, which could lead to out-of-bounds reads if `pixels` is too small. Moderate relevance because array indexing occurs but without explicit bounds validation.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      }
    ]
  },
  "CVE-2017-16913_after_exclude_100:4624827d:spec": {
    "timestamp": "2026-01-17T01:45:17.504877",
    "cve_id": "CVE-2017-16913",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4624827d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `smap->map.max_entries` to calculate allocation size. This value is likely provided or influenced by userspace. Specification HS-INPUT-001 is strongly relevant because this length must be validated before use to prevent integer overflow in `elem_size * smap->map.max_entries` or excessive memory allocation. The code shows the allocation but not the prior validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-002 deals with protocol message handlers and variable-length components. The target code is a kernel memory allocation function for a BPF map data structure, not a protocol message handler. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 is highly relevant. The code performs buffer allocation (`bpf_map_area_alloc`) based on a calculated size. It must ensure the calculation (`elem_size * max_entries`) does not overflow and that the resulting size is within acceptable system limits, which is the core concern of this specification. The absence of explicit overflow check is a potential issue.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 is strongly relevant. The function manages two related resources: the allocated memory area (`smap->elems`) and a freelist (`smap->freelist`) populated from that area. It must maintain consistency between them. The error handling (`goto free_elems`) ensures that if freelist initialization fails, the memory is freed, preventing an inconsistent state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-FS-003 is about filesystem metadata operations and thread-safety. The target code performs memory allocation and freelist initialization for a BPF map, which is unrelated to filesystem operations. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-001 (duplicate ID, but content about regex and NUL bytes) is not relevant. The code does not involve regular expression parsing or string processing where NUL bytes would be a concern.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-002 (duplicate ID, but content about pattern compilers and escape sequences) is not relevant. The code is for memory pre-allocation in the kernel and does not involve compiling patterns or processing escape sequences.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-16913_before_exclude_100:54bb4956:spec": {
    "timestamp": "2026-01-17T01:45:22.314071",
    "cve_id": "CVE-2017-16913",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "54bb4956",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `smap->map.max_entries` to calculate allocation size. This value is likely provided or influenced by userspace. Specification HS-INPUT-001 is strongly relevant because the code must validate that `max_entries` is within safe bounds before multiplication with `elem_size` to prevent integer overflow or excessive memory allocation. The current code does not show this validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "Specification HS-PROTOCOL-002 deals with verifying structural integrity of variable-length components in protocol messages. The target code is a memory allocation and freelist initialization routine for a kernel data structure (BPF stack map), not a protocol message handler. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 4,
        "reasoning": "Specification HS-TIMING-001 concerns atomic operations for shared resource state transitions. The target code shows a function that allocates memory and initializes a freelist, likely during map creation. There is no evident handling of concurrent access to shared resources within this function itself. The relevance is weak, as concurrency protection would typically be managed by the caller or other parts of the subsystem.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "This specification has strong relevance. The function manages two related resources: the allocated memory area (`smap->elems`) and the freelist (`smap->freelist`). It must maintain consistency between them. The error handling path (`goto free_elems`) ensures that if the freelist initialization fails, the memory is freed, preventing an inconsistent state where one structure exists without the other. This aligns with the principle of strict consistency between tracking structures.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-FS-003 is about thread-safety for filesystem metadata operations. The target code is for BPF map memory management in the kernel and has no relation to filesystem operations. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "This specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expressions, string parsing, or input patterns. It is a memory allocation function. The specification basically doesn't apply.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-002 (duplicate ID, but different content) concerns pattern compilers and escape sequences. The target code is a memory allocation and initialization routine for a kernel data structure. It does not compile patterns or process escape sequences. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2011-3603_before_exclude_100:603fdf83:spec": {
    "timestamp": "2026-01-17T01:46:01.473442",
    "cve_id": "CVE-2011-3603",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "603fdf83",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not contain any regular expression parsing logic. It processes command-line arguments and environment variables for container execution, but does not involve pattern matching with regex that would need to handle embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It handles command-line arguments, environment variables, and container configuration, but there is no evidence of pattern compilation mechanisms.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The code uses `strtoll` on an environment variable (`LISTEN_FDS`) without prior length validation. While the input source (environment) is somewhat trusted, it's still external input. The use of `xstrdup` on `argv` elements also assumes null-terminated strings without explicit length checks, which could be problematic if arguments contain embedded NULs (though unlikely from argv). This shows moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "The code configures process capabilities and sets `no_new_privileges` based on user input (`exec_options`). If privilege separation fails (e.g., capability dropping fails), the code does not explicitly enforce immediate terminationit returns an error to the caller. The relevance is moderate as privilege management is present but termination enforcement is not visible in this function.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "The code performs security-critical state transitions (setting capabilities, SELinux labels, AppArmor profiles) based on user-controlled options. However, there is no visible atomic verification mechanism (e.g., checking all security attributes together before commit). Weak to moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 8,
        "reasoning": "The function validates and processes runtime configuration for container execution (cgroup, capabilities, security profiles, environment variables). It acts as a security-sensitive component (container executor) and must validate the configuration before passing it to `libcrun_container_exec_with_options`. Strong relevance.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 4,
        "reasoning": "The code does not parse protocol messages with length fields. It handles command-line arguments and environment variables, but not network or inter-process protocols with explicit length fields. Weak relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation via `xmalloc0` for `process` and `process->args`. It uses `argc` directly for allocation size without explicit validation against allocation limits or usage requirements (e.g., ensuring `argc` is reasonable). While `xmalloc0` may have internal checks, the code does not validate `argc` before using it in arithmetic `(argc + 1) * sizeof(...)`. Moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2011-3603_after_exclude_100:36eea24d:spec": {
    "timestamp": "2026-01-17T01:46:41.602957",
    "cve_id": "CVE-2011-3603",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "36eea24d",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expression parsing. It processes command-line arguments and environment variables, but not in a regex context. The connection is very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code is a container execution function that handles command arguments, environment setup, and process configuration. There is no pattern compilation or escape sequence processing evident in the code.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses `xstrdup` on `argv` elements, which are C strings. While `argv` is typically trusted (from the program's own invocation), the principle of using length-aware operations for untrusted input is moderately relevant. The code does not perform explicit length validation on these strings before operations like duplication, but the risk context is lower here than for network input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code configures process capabilities (`exec_options.cap`), user (`exec_options.user`), and the `no_new_privileges` flag. These are privilege-related settings for a containerized process. While the specification about enforcing immediate termination on privilege separation failures is not directly implemented here, the code is responsible for setting up the security context where such separation should occur, giving it moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "The code transitions the security state by applying user, capabilities, and security module (SELinux, AppArmor) labels to a new process. The specification about atomic verification of state transitions is a high-level security principle. The code performs these assignments but does not show explicit atomic verification steps, resulting in weak to moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "The function `crun_command_exec` acts as a security-sensitive daemon component (container runtime) that validates and applies a runtime configuration from command-line options (`exec_options`) and environment variables (`LISTEN_FDS`) before executing a container process. This aligns strongly with the principle of validating runtime configuration before operation.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields. The target code does not process network protocols. It handles an environment variable (`LISTEN_FDS`) with `strtoll`, which could involve integer conversion, but this is not a protocol message length field. The connection is weak.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation via `xmalloc0` for the `process` struct and its `args` array. The size for `args` is calculated as `(argc + 1) * sizeof(*process->args)`. While `argc` is a trusted value from the program's invocation, the principle of validating size parameters against allocation limits is relevant. The use of a safe wrapper (`xmalloc0`) is good, but the code does not show explicit validation against arbitrary large values, which is a common secure coding concern.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2020-21050_before_exclude_100:31483f89:spec": {
    "timestamp": "2026-01-17T01:46:49.879068",
    "cve_id": "CVE-2020-21050",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "31483f89",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates PNG signature and critical header fields (IHDR chunk size, width/height bounds via cMaxPNGSize, fcTL field bounds) before processing. This directly aligns with validating critical header fields before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Memory allocations (frameRaw.p, frameRaw.rows) are preceded by validation of w and h against cMaxPNGSize, and later w0/h0 are also validated. This guards allocation by pre-validating size parameters.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. Specification is specifically for BMP parser and bit count requirements. The target code is for APNG/PNG decoding, not BMP.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code allocates buffers (frameRaw.p for imagesize), there's no explicit mention of accounting for operational padding or safety margins. The allocation is based directly on w*4*h calculation.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Specification focuses on image compression operations and encoder buffers. The target code is a decoder, not an encoder, and doesn't involve compression operations in the context meant by this spec.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates parameters like w, h, w0, h0, x0, y0, dop, bop against limits (cMaxPNGSize, dop>2, bop>1). While not strictly \"compression parameters\", these are decoding parameters that are validated against implementation limits.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All compression parameters must be validated against implementation limits before proc..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code enforces multiple format constraints: PNG signature, chunk sizes, width/height bounds, frame boundaries (x0+w0<=w, y0+h0<=h), disposal/blend operation values. This strictly enforces APNG/PNG specification constraints.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Image decoders must strictly enforce format specification constraints"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. Array accesses in loops (e.g., frameRaw.rows[j], f[4*x+3]) are guarded by bounds checking through loop conditions (j<h, x<w0, y<h0). The w0 and h0 values are validated against allocated buffer dimensions.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Array accesses must be guarded by bounds checking against allocated size"
      }
    ]
  },
  "CVE-2016-10050_after_exclude_100:16fe56d7:spec": {
    "timestamp": "2026-01-17T01:47:10.894186",
    "cve_id": "CVE-2016-10050",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "16fe56d7",
    "scores": [
      {
        "score": 9,
        "reasoning": "Specification HS-INPUT-001 (Image format parsers must validate all critical header fields before processing) is highly relevant. The code validates the PNG signature, IHDR chunk size, and critical fields like width, height, x0, y0, dispose op (dop), blend op (bop) against limits (cMaxPNGSize) and logical constraints (e.g., x0 + w0 > w). This directly aligns with the specification's requirement.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 8,
        "reasoning": "Specification HS-MEM-002 (Memory allocation must be guarded by pre-validation of size parameters) is strongly relevant. The code performs size validation (w > cMaxPNGSize || h > cMaxPNGSize) before allocating memory for frameRaw.p and frameRaw.rows. This guards against excessive memory allocation due to malicious or corrupted image dimensions.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-PROTOCOL-003 (BMP parser must enforce minimum bit count requirements per specification) has very low relevance. The target code is for APNG (Animated PNG) decoding, not BMP parsing. The specification is format-specific and does not apply to this code scenario.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 (Buffer allocation must account for all operational padding requirements with safety margin) has weak relevance. The code allocates buffers based on calculated `imagesize = h * rowbytes` and `rowbytes = w * 4`. While it accounts for the pixel format (4 bytes per pixel), there's no explicit mention of additional padding or safety margins beyond the basic size calculation. The relevance is indirect.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-004 (Image compression operations must enforce strict bounds checking for all encoder buffers) has weak relevance. The code is primarily a decoder, not an encoder. While it processes compressed data chunks (IDAT, fdAT), its bounds checking is more focused on header validation and memory allocation sizes rather than encoder buffer bounds during compression.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-001 (All compression parameters must be validated against implementation limits before processing) has moderate relevance. The code validates several parameters from the fcTL chunk (delay_num, delay_den, dop, bop) against allowed ranges (dop > 2, bop > 1). It also validates geometric parameters (w0, h0, x0, y0). These are critical for safe processing, though they are not strictly \"compression parameters\" in the traditional sense (like quality settings) but are animation control parameters within the compressed stream.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All compression parameters must be validated against implementation limits before proc..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-002 (Image decoders must strictly enforce format specification constraints) is highly relevant. The code enforces numerous APNG/PNG specification constraints: signature check, chunk type validation (using isAbc for ancillary chunks), handling of fcTL, acTL, IDAT, fdAT chunks in the correct sequence, and validating field values (like dop, bop ranges, and frame dimensions relative to the overall image). This is a core activity of the decoder.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Image decoders must strictly enforce format specification constraints"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 (Array accesses must be guarded by bounds checking against allocated size) is strongly relevant. The code uses loops with explicit bounds (j < h, y < h0, x < w0) when accessing `frameRaw.rows[j]` and the pixel data `f[4 * x + ...]`. The dimensions (w0, h0) are validated against `cMaxPNGSize` and against the main image bounds (x0 + w0 > w, y0 + h0 > h) before these loops execute, providing a guard against out-of-bounds access.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Array accesses must be guarded by bounds checking against allocated size"
      }
    ]
  },
  "CVE-2019-19221_before_exclude_100:3b688cbd:spec": {
    "timestamp": "2026-01-17T01:47:18.658432",
    "cve_id": "CVE-2019-19221",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3b688cbd",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs arithmetic operations like line count adjustments (e.g., `line2 -= nmatch_tl`), pointer arithmetic, and buffer length calculations. While there are some validations (e.g., checking `i <= 0` for counts), the specification about validating divisors and shift operands is only moderately relevant because the code doesn't involve division or bit-shifting operations explicitly. However, buffer length calculations and line number arithmetic do require validation to prevent overflows or underflows, which aligns partially with the specification's principle.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate divisor and shift operands to prevent undefined be..."
      },
      {
        "score": 2,
        "reasoning": "This specification is about image format parsers validating mathematical operation inputs from file data. The target code is a text substitution function in Vim (ex_substitute) that processes regular expressions and user commands, not image files. There is no parsing of image formats or file data-derived mathematical operations, making this specification very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image format parsers must validate all mathematical operation inputs derived from file..."
      },
      {
        "score": 5,
        "reasoning": "The code involves iterating over lines (lnum) and matches within lines, with state transitions like `matchcol`, `prev_matchcol`, and `nmatch`. It maintains consistency in multi-line matching and substitution loops. However, the specification focuses on mathematical consistency invariants for iterators, which is only weakly relevant here because the iterator state is more about text positions and match tracking rather than mathematical invariants.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Iterator state transitions must maintain mathematical consistency invariants"
      },
      {
        "score": 7,
        "reasoning": "Buffer length calculations are present (e.g., `needed_len` for `new_start` buffer, `new_start_len` allocation). The code validates capacity before arithmetic operations by checking `needed_len > (int)new_start_len` and reallocating if necessary. This aligns with the specification's principle of validating remaining capacity, though the context is string buffers rather than general buffer operations. Moderate to strong relevance.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 8,
        "reasoning": "The code processes substitute patterns and strings with delimiters, handles escape characters, and maintains boundaries during transformations (e.g., skipping regexp delimiters, handling backslashes, and line breaks). It uses functions like `skip_regexp_ex` and `skip_substitute` to maintain boundary awareness. This strongly relates to protocol string processing with strict boundary awareness, though the \"protocol\" here is the substitute command syntax.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      },
      {
        "score": 8,
        "reasoning": "Input validation is performed throughout: checking delimiter validity, regexp compilation, confirming substitution counts are positive, and validating user input during interactive confirmation. The code validates transformation requirements (e.g., checking buffer modifiability, regexp validity) before applying changes. This aligns well with the specification's focus on validating input before modifications.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Input processing must validate transformation requirements before applying modificatio..."
      },
      {
        "score": 6,
        "reasoning": "The code has multiple execution paths based on flags (do_ask, do_all, do_count), error handling, and user interruptions. It includes assertions and checks for state consistency (e.g., `got_quit`, `aborting()`). However, the specification about protocol state assertions accounting for all valid execution paths is only moderately relevant because this is not a network protocol but a text substitution operation with complex control flow.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Protocol state assertions must account for all valid execution paths"
      },
      {
        "score": 3,
        "reasoning": "The specification deals with backward compatibility handling in protocols. The code has some backward compatibility quirks (e.g., Vi compatibility for cursor position, handling of '%' for previous substitution), but it's not about maintaining protocol invariants in a networking sense. Weak relevance as the connection is tangential.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Backward compatibility handling must maintain protocol invariants"
      }
    ]
  },
  "CVE-2022-0413_after_exclude_100:0a71d1ed:spec": {
    "timestamp": "2026-01-17T01:48:38.800374",
    "cve_id": "CVE-2022-0413",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0a71d1ed",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs arithmetic operations (e.g., line count adjustments, pointer arithmetic, buffer length calculations). While it does some validation (e.g., checking line ranges), it doesn't explicitly validate all divisors or shift operands. The relevance is moderate because the specification's principle of validating arithmetic inputs applies to buffer and line calculations present in the code.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate divisor and shift operands to prevent undefined be..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code is a text substitution function in an editor (Vim), not an image format parser. No image data or file format parsing is involved.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image format parsers must validate all mathematical operation inputs derived from file..."
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The function maintains state during iteration over lines and matches (e.g., lnum, line2, matchcol, prev_matchcol, nmatch). It must ensure consistency when lines are added/deleted during substitution. The code handles multi-line matches and buffer modifications, requiring careful state maintenance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Iterator state transitions must maintain mathematical consistency invariants"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code performs buffer length calculations when building the new substitution string (new_start_len, needed_len). It allocates memory based on these calculations and copies data. While it checks allocation success, explicit validation of remaining capacity relative to source buffers is less prominent. The core principle of validating capacity before operations applies directly.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function processes substitute patterns and replacement strings with delimiters, handles escape sequences, and transforms text with strict boundary awareness. It must correctly parse the command string, handle multi-line patterns and substitutions, and maintain buffer boundaries during in-place editing. This directly aligns with protocol/string processing boundary requirements.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates input before applying transformations: checks regexp delimiters, validates line ranges, confirms buffer is modifiable, compiles regex patterns, and handles user confirmation. It also validates substitution string syntax (e.g., \\= expressions). The principle of validating transformation requirements is clearly applied.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Input processing must validate transformation requirements before applying modificatio..."
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The function has multiple execution paths (skip mode, count mode, interactive confirmation, multi-line matches, error conditions). It must maintain consistent state across these paths. Protocol state assertions in this context relate to ensuring the editor buffer and cursor state remain valid regardless of which path is taken.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Protocol state assertions must account for all valid execution paths"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code maintains some backward compatibility with vi behavior (e.g., handling of % for previous substitution, empty match handling, cursor positioning). However, this is not a network protocol but an editor command. The principle of maintaining invariants during compatibility handling has some application but is not the primary focus.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Backward compatibility handling must maintain protocol invariants"
      }
    ]
  },
  "CVE-2018-20750_before_exclude_100:365c8d6f:spec": {
    "timestamp": "2026-01-17T01:48:51.006028",
    "cve_id": "CVE-2018-20750",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "365c8d6f",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain a regular expression parser. It processes whitespace (spaces and tabs) for retabulation. While it handles NUL bytes as string terminators (ptr[col] == NUL), it is not parsing regex patterns with embedded NULs. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function processes input lines (via `ml_get`) and constructs new lines. It uses `STRLEN` and manual length calculations (`old_len - col + start_col + len + 1`) for memory allocation and `mch_memmove` for copying, which are length-aware operations. However, the input is from the buffer's own lines, not directly \"untrusted\" in a network sense, but the principle of using length-aware operations applies.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code allocates memory (`alloc`) for `new_line` and initializes its content via `mch_memmove` and a loop writing spaces/tabs. It does not leave the allocated buffer uninitialized. The `new_line` pointer itself is initialized to `(char_u *)1`. The specification's principle of initializing memory is followed, though not the central focus.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The function has multiple error/exit paths (e.g., `got_int`, allocation failure, `u_save` failure). It attempts to maintain state by restoring `curwin->w_p_list` and calling `u_clearline()`. However, the cleanup for allocated resources (like `new_vts_array`, `new_ts_str`) under early returns or errors is not fully clear in all paths, which relates to maintaining consistent object states.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This is a text buffer editing function, not a network protocol handler. There is no network input validation.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The code processes multi-byte characters (`has_mbyte`, `mb_ptr2len`) and uses `chartabsize` which considers column position. It advances `col` and `vcol` based on character size, ensuring it does not overrun the buffer. It validates boundaries by checking for `NUL`. The principle of validating buffer boundaries before access is directly applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code parses lines character-by-character, maintaining `col`, `vcol`, `start_col`, and `start_vcol` as state invariants for the buffer position. It updates the buffer via `ml_replace`. The specification about maintaining consistent buffer state invariants during parsing operations applies, though the context is simple whitespace parsing, not a complex parser.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-0572_after_exclude_100:3a9d7420:spec": {
    "timestamp": "2026-01-17T01:49:42.233592",
    "cve_id": "CVE-2022-0572",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3a9d7420",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code is a text retabbing function that processes whitespace (spaces and tabs) in buffer lines. It does not involve regular expression parsing at all. The connection is very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences. It manipulates literal whitespace characters. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The specification about using length-aware operations for untrusted input has moderate relevance. The function processes buffer lines which could be considered input. It uses `STRLEN()` and manual column counting with checks for NUL termination and `MAXCOL`. However, it doesn't primarily use standard C string functions on untrusted data; it operates on internal buffer data.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "The specification about initializing memory allocations has moderate relevance. The code allocates `new_line` with `alloc()` and then initializes its contents via `mch_memmove` and a loop writing spaces/tabs. It does not leave the allocated buffer uninitialized. However, the initialization is not a security-focused \"zeroing\" but functional filling.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The specification about error handling paths maintaining consistent object states is strongly relevant. The function has multiple early returns on error (e.g., `tabstop_set` failure, invalid argument). It modifies global state (`curwin->w_p_list`) at the start and restores it at the end. It also conditionally updates buffer properties (`b_p_ts`, `b_p_vts_array`) and calls `redraw_curbuf_later` and `changed_lines`. The control flow must ensure state consistency across all error paths.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "The specification is about network protocol handlers validating input. This code is a local text buffer manipulation function, not a network protocol handler. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 7,
        "reasoning": "The specification about character encoding processing validating buffer boundaries has moderate relevance. The code handles multi-byte characters via `has_mbyte` and `(*mb_ptr2len)`. It increments `col` based on the character length, and loops until `ptr[col] == NUL`. There is a risk of incorrect `mb_ptr2len` causing out-of-bounds reads if the string is not properly formed, though the buffer data is assumed to be valid. The `vcol >= MAXCOL` check also acts as a boundary guard.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "The specification about parser input operations maintaining consistent buffer state invariants has weak relevance. The code parses whitespace sequences within a line to retab them. It modifies the buffer in-place via `ml_replace`. It maintains invariants like `start_col`, `start_vcol`, and updates `ptr` and `col` after replacement. However, it's not a general-purpose parser for complex syntax, and the \"buffer state invariants\" are more about the editing buffer's consistency than a parsing buffer.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-23589_before_exclude_100:c9737e0c:spec": {
    "timestamp": "2026-01-17T01:50:20.544587",
    "cve_id": "CVE-2022-23589",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c9737e0c",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing. It performs graph node analysis and tensor parsing, but does not process pattern strings with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile patterns or process escape sequences. It works with node definitions and tensor identifiers in a computational graph.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes input strings (node names), it uses library functions (ParseTensorName) rather than direct string manipulation. The relevance is very low as the code doesn't show explicit length-aware operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code checks `node.input_size() > 0` before accessing `node.input(0)`, which is a basic length validation. However, this is minimal validation and not the main focus of the specification for untrusted input processing.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Variable-length input processing must enforce length validation before access"
      },
      {
        "score": 2,
        "reasoning": "The code does not implement protocol dissection or honor field length specifications. It analyzes graph node properties and relationships.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-004: Protocol dissectors must honor field length specifications"
      },
      {
        "score": 2,
        "reasoning": "The code does not perform fixed buffer operations or explicit bounds validation for buffer writes. It works with object properties and graph structures.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code performs basic input validation (`node.input_size() > 0`) but doesn't implement comprehensive input size validation before processing. The validation is minimal and specific to the immediate use case.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "The code analyzes graph structure and enforces some constraints (checking node types, input existence). It has weak relevance as it performs structural validation of computational graph nodes, though not configuration parsing in the traditional sense.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      }
    ]
  },
  "CVE-2022-23589_after_exclude_100:e19e1ddd:spec": {
    "timestamp": "2026-01-17T01:50:20.916123",
    "cve_id": "CVE-2022-23589",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e19e1ddd",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It parses a tensor name string but uses a dedicated `ParseTensorName` function whose internal implementation is not shown. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or protocol/pattern compilation. It performs simple node graph analysis. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Variable-length input processing must enforce length validation before access"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve protocol dissection or honoring field length specifications from network/data formats. It works on an internal graph representation. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-004: Protocol dissectors must honor field length specifications"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve fixed buffer operations or write operations to buffers. It performs read-only checks on graph nodes and their properties. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      }
    ]
  },
  "CVE-2022-34494_before_exclude_100:9bd73982:spec": {
    "timestamp": "2026-01-17T01:50:25.718708",
    "cve_id": "CVE-2022-34494",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9bd73982",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process any userspace-provided array lengths. It allocates a fixed-size structure (struct virtio_rpmsg_channel) and registers a device. There is no direct user input handling or array length validation in this function.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The code does not handle protocol messages or variable-length components. It is a device initialization function that sets up a control device for rpmsg over virtio. No protocol parsing or structural verification is performed here.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "The buffer allocation (kzalloc) uses a fixed size (sizeof(*vch)). There is no input-dependent or worst-case scenario allocation. The size is determined at compile-time, not by external input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 4,
        "reasoning": "The code does not process any protocol message length fields. It is initializing a kernel data structure and registering a device, not parsing network packets or messages with length fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code performs memory allocation (kzalloc) and checks for failure (if (!vch)), which is a basic validation. However, the size parameter is a compile-time constant (sizeof(*vch)), not a dynamic or user-provided value, so the more advanced aspects of the specification (validating against allocation limits and usage requirements) do not apply.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a protocol with type handling. It sets function pointers and device attributes in a static initialization routine. There are no variable types or processing stages that require consistency enforcement.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is related to virtio and rpmsg (virtual device communication), not USB request processing. The function does not handle USB buffers or length fields for data transfer.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is for virtio-based rpmsg, not USB/IP protocol. It registers a control device and does not validate packet structures, as no packet processing occurs in this function.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2022-34494_after_exclude_100:5a30992a:spec": {
    "timestamp": "2026-01-17T01:50:27.907521",
    "cve_id": "CVE-2022-34494",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5a30992a",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process any userspace-provided array lengths. It allocates a fixed-size structure (struct virtio_rpmsg_channel) and registers a control device. The specification about validating userspace array lengths is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The code does not handle protocol messages or their variable-length components. It is a device setup function for a virtio-based rpmsg control device. The specification's focus on protocol message handlers is not relevant here.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "The code performs a single allocation (kzalloc) for a fixed-size structure (sizeof(*vch)). There is no input-dependent or worst-case scenario allocation based on external data. The specification's guidance on accounting for worst-case input is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 4,
        "reasoning": "The code does not parse or validate any protocol message length fields. It is initializing a kernel data structure and registering a device. The specification is not relevant to this context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code validates the result of kzalloc (checking for NULL) which is a basic memory allocation validation. However, the size parameter is a compile-time constant (sizeof(*vch)), so there is no validation against dynamic input or complex usage requirements as the specification emphasizes. Relevance is weak.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a protocol with multiple processing stages or variable type handling. It sets up a device structure with fixed assignments. The specification's focus on protocol type consistency is not relevant.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code is related to virtio and rpmsg, not USB request processing. The specification is specific to USB and has no connection to this code scenario.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "The code is for a virtio rpmsg control device, not a USB/IP protocol implementation. The specification is completely unrelated to the target code's domain.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2010-4650_before_exclude_100:b20b2f37:spec": {
    "timestamp": "2026-01-17T01:51:24.656516",
    "cve_id": "CVE-2010-4650",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b20b2f37",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not process any userspace-provided array lengths. It simply sets a bit in a kernel data structure (fuse_inode->state). No input validation is performed or needed here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code is not a protocol message handler. It is a simple inline function that marks an inode as \"bad\" by setting an internal flag. No variable-length components or protocol structures are involved.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code performs no buffer allocation. It only manipulates an existing bit in a state field. There is no input processing or memory allocation based on user data.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code has no regular expression parsing functionality. It does not process input patterns or handle NUL bytes in any way.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code is not a pattern compiler and does not process escape sequences. It is a simple state manipulation function for FUSE inodes.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code does not use string processing functions. It operates on a kernel data structure using bit manipulation (set_bit). No untrusted input is processed here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function modifies shared resource state (inode state) and should be protected against concurrent access. While set_bit() is typically atomic for single bits, the overall state transition (marking inode as bad) might need higher-level synchronization depending on the calling context. The specification principle of protecting state transitions applies.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The function updates resource state (FUSE_I_BAD flag) which should maintain consistency with other kernel structures tracking inode state. However, this single function only sets one flag and doesn't show coordination with other tracking structures. The principle of maintaining state consistency is relevant but not fully demonstrated in this isolated code.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2017-18216_after_exclude_100:dc708239:spec": {
    "timestamp": "2026-01-17T01:51:49.673169",
    "cve_id": "CVE-2017-18216",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dc708239",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not process any userspace-provided array lengths. It operates on internal kernel structures (inode) and performs simple state manipulation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "The code is not a protocol message handler and does not process variable-length components. It's a simple internal function to mark a fuse inode as bad.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain any regular expression parsing logic. It's completely unrelated to pattern matching or input parsing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not process any patterns or escape sequences. It's a simple kernel function for managing inode state.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code does not process strings or use string functions. It works with kernel data structures directly.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function modifies shared resource state (inode) and uses atomic operations (set_bit) to update state flags. This is exactly about protecting shared resource state transitions.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function maintains consistency between different tracking structures by removing the inode from the hash table and setting a bad state flag, ensuring the inode tracking remains consistent.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-2553_before_exclude_100:4c396010:spec": {
    "timestamp": "2026-01-17T01:51:53.367275",
    "cve_id": "CVE-2022-2553",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4c396010",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not contain any regular expression parsing logic. It deals with configuration file reading, authentication, and initialization. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequence processing. The target code performs file I/O, configuration validation, and library initialization but does not compile patterns or process escape sequences. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The specification advocates for length-aware string operations for untrusted input. The code uses `snprintf` with explicit size bounds (`sizeof(cl.lockfile)-1`), which is a good practice. However, the primary input sources (`read_config`, `read_authkey`) are not shown, so the full context is unknown. The visible part demonstrates moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about validating protocol message length fields. The target code is for setup and configuration, not for parsing network protocol messages. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 4,
        "reasoning": "The specification is about validating memory allocation size parameters. The target code does not contain any explicit memory allocation calls (like malloc, calloc). Any allocations would be hidden within functions like `read_config` or `find_site_by_name`. Therefore, the connection is weak.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing consistent type handling in protocols. The code uses an integer `type` parameter and checks it in a conditional (`type == CLIENT || type == GEOSTORE`). While this shows some type-aware logic, it is for application mode/role, not for data serialization or protocol processing. The relevance is weak.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about enforcing RFC-specified length constraints for protocol message fields. The code does not process any network protocol messages. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 3,
        "reasoning": "The specification is about bounds checking in TLV (Type-Length-Value) processing. The target code does not parse TLV structures. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-2553_after_exclude_100:1c987b5b:spec": {
    "timestamp": "2026-01-17T01:52:02.057530",
    "cve_id": "CVE-2022-2553",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1c987b5b",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expression parsing. It reads configuration and authentication files, but there is no indication of regex pattern processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code does not contain any pattern compilation logic (e.g., for regex or format strings). Its operations are file reading and configuration validation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses `snprintf` with explicit length bounds (`sizeof(cl.lockfile)-1`), which is a length-aware operation. However, the input being formatted (`booth_conf->name`) is from a configuration file, which could be considered potentially untrusted. The relevance is moderate because the principle applies, but the code only shows one instance of string processing.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields. The target code is for setup and configuration, not for processing network protocol messages. There are no visible length fields from a network source being validated.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain explicit memory allocation operations (like malloc, calloc). However, functions like `read_config`, `read_authkey`, and `find_site_by_name` likely perform allocations internally. The specification has weak relevance because the principle of validating size parameters is important for security, but it's not directly observable in the provided snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about protocol implementations and type handling. This code is for daemon/client setup and configuration, not a network protocol implementation. The `type` parameter is used for control flow, but this is not related to protocol message type consistency.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message fields against RFC length constraints. This code handles local configuration files, not network protocol messages, so RFC constraints do not apply.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification is about TLV (Type-Length-Value) processing and bounds checking. The target code does not process TLV structures. It reads configuration files and sets up paths.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2015-7511_before_exclude_100:5f3bdf54:spec": {
    "timestamp": "2026-01-17T01:52:23.740986",
    "cve_id": "CVE-2015-7511",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f3bdf54",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification concerns embedded NUL bytes in regular expression patterns. The target code parses ASN.1/DER encoded elliptic curve parameters, which are binary data structures with explicit length fields. While it processes binary data, it does not involve regular expression parsing. The length fields are used to bound memory copies (e.g., for the seed), but the core issue of NUL bytes in string patterns is not present.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code performs ASN.1 parsing and elliptic curve mathematics, not lexical analysis or pattern compilation of escape sequences. There is no processing of escape sequences in this context.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The specification advocates for length-aware operations on untrusted input. The code uses length-aware operations: it checks for NULL pointers and uses provided length fields (e.g., params->curve->a->length, params->base->length) with functions like BN_bin2bn, memcpy, and EC_POINT_oct2point. This is relevant for preventing buffer overreads. However, the code's primary trust boundary is for structured ASN.1 data, not generic strings.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification mandates constant-time execution for cryptographic operations on secret values. This function parses and constructs an EC_GROUP from parameters; it does not perform cryptographic operations (e.g., scalar multiplication, signing) on secret keys. The validation of parameters (order, cofactor) involves public values. Therefore, constant-time requirements are not directly applicable to this parsing function itself, though they are critical for the group's subsequent use.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 8,
        "reasoning": "The specification requires side-channel resistance for elliptic curve implementations. The code's main purpose is to create an EC_GROUP. A key part of the function attempts to match the provided explicit parameters to a built-in named curve to potentially use a specialized, hardened EC_METHOD (which should provide side-channel resistance). This logic directly relates to ensuring the use of a secure implementation. The relevance is strong, though the function itself is a factory, not the core arithmetic.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires constant-time properties for secure memory operations during cryptographic processing. The code uses memcpy for the seed and various BIGNUM operations. While BIGNUM operations should be constant-time for secret values, the data being copied here (the seed) is not a secret key. The function is not in the \"hot path\" of secret cryptographic computation, so the direct relevance is moderate.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires validation of length fields against integer limits. The code performs several relevant checks: it validates field_bits against OPENSSL_ECC_MAX_FIELD_BITS, checks BN_num_bits(a) against field_bits + 1 (Hasse bound), and uses length fields to allocate memory and copy data. These are validations against operational limits, though not specifically against platform integer overflow (e.g., size_t limits) which is also checked indirectly via allocation failures.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires validation of memory allocation size parameters. The code performs this: it checks if field_bits > OPENSSL_ECC_MAX_FIELD_BITS before creating the group, which is a limit on the internal representation. It also checks the seed length before allocating memory with OPENSSL_malloc. Furthermore, the use of ASN.1_INTEGER_to_BN and BN_bin2bn with provided lengths relies on underlying library checks. The code demonstrates awareness of allocation limits.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2015-7511_after_exclude_100:5b29d6f4:spec": {
    "timestamp": "2026-01-17T01:53:02.433691",
    "cve_id": "CVE-2015-7511",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5b29d6f4",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code parses ASN.1/DER encoded elliptic curve parameters, not regular expressions. While it processes binary data that could contain NUL bytes, the context is fundamentally different. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences; it parses structured cryptographic parameters. The connection is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The specification is about using length-aware operations for untrusted input. The code uses `BN_bin2bn` and `EC_POINT_oct2point` which take length parameters, and validates the presence of data pointers and lengths (e.g., `params->curve->a->data`, `params->base->length`). It also copies seed data using `memcpy` with a length. However, it does not fully validate that all provided lengths are within sane bounds before use (e.g., for memory allocation), making relevance moderate.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about constant-time execution for secret values. The code parses curve parameters (which are usually public) and constructs an EC_GROUP. It does not perform operations on private keys (scalars) or secret values like nonces. The constant-time requirement is not directly applicable to this parameter parsing function, leading to weak relevance.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 6,
        "reasoning": "The specification is about side-channel resistance for elliptic curve implementations. The target code is responsible for constructing an EC_GROUP object from parameters. While it doesn't implement curve arithmetic itself, its output (the EC_GROUP) determines which EC_METHOD (and thus which implementation) will be used for subsequent operations. The code attempts to match parameters to built-in curves to use potentially more secure, specialized implementations. This gives the specification moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about constant-time memory operations during crypto processing. The code uses `memcpy` for the seed and handles BIGNUM data. However, the data being processed (curve parameters) is typically public. The function's primary role is parsing and structure creation, not manipulating secret data where constant-time memory ops are critical. Relevance is weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 8,
        "reasoning": "The specification is about validating length fields against integer limits. The code validates several integer values from the input: it checks `field_bits > OPENSSL_ECC_MAX_FIELD_BITS`, validates that `tmp_long` (for trinomial basis) is positive and less than `m`, validates pentanomial exponents ordering, checks BN_num_bits(order) against field_bits+1 (Hasse bound), and checks for negative/zero values for prime and order. This aligns strongly with the principle of validating integer parameters from untrusted input.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The specification is about validating memory allocation size parameters. The code allocates memory for the seed using `OPENSSL_malloc(params->curve->seed->length)` without explicitly checking if the length is reasonable before allocation. However, it does validate other size-related parameters (field_bits, Hasse bound) which indirectly protect against extreme allocations in later functions. The direct allocation check is missing for the seed, but the overall code context involves careful parameter validation, giving it strong relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-2963_before_exclude_100:d18e6f16:spec": {
    "timestamp": "2026-01-17T01:53:38.202973",
    "cve_id": "CVE-2022-2963",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d18e6f16",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code is a command-line argument parser using `jas_getopt`. While it processes input strings (arguments), it does not involve regular expression parsing. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences; it parses command-line options. The connection is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The code uses `addopt` to concatenate option strings into fixed-size buffers (`inoptsbuf`/`outoptsbuf`). If `jas_optarg` is untrusted (e.g., from user input), length-aware operations are needed to prevent buffer overflows. The `addopt` function (not shown) should enforce bounds. This has moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 10,
        "reasoning": "The code allocates memory for `cmdopts` with `malloc` and immediately initializes all fields (e.g., setting pointers to NULL/0, buffers to empty strings). This is a direct and correct application of the specification to prevent use of uninitialized memory.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "Error handling is present (e.g., malloc failure exits, invalid arguments call `badusage`). However, after `badusage()` is called (which likely exits), the function does not return, so object state consistency is less critical. There's moderate relevance regarding cleanup on error paths.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-2963_after_exclude_100:e924ad77:spec": {
    "timestamp": "2026-01-17T01:54:15.748433",
    "cve_id": "CVE-2022-2963",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e924ad77",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It is a command-line argument parser using a getopt-like function (jas_getopt). The input patterns are static strings in the cmdoptions array, not user-provided regular expressions. Therefore, the specification about handling embedded NUL bytes in regex patterns is not relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It parses command-line arguments into predefined options. The specification about pattern compilers and escape sequences does not apply to this context.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The code processes command-line arguments (potentially untrusted input from users). It uses jas_getopt, which likely uses string operations. The function `addopt` (not shown) is called with a buffer and a maximum size (OPTSMAX), suggesting some length-aware operations. However, the core parsing loop does not explicitly show length-aware string handling for the argument values (jas_optarg). There is a risk if jas_optarg is used without length checks in other parts of the codebase. The principle of the specification is moderately relevant.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 10,
        "reasoning": "The code directly applies this specification. After allocating memory for `cmdopts` with `malloc`, it explicitly initializes all fields of the structure to default values (e.g., setting pointers to 0/NULL, integers to -1 or 0, buffers to empty strings). This prevents the use of uninitialized memory, which is a critical security practice.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code demonstrates good error state handling. When `jas_getopt` returns an unrecognized option (default case), it calls `cmdopts_destroy(cmdopts)` to clean up the allocated object before calling `badusage()` and exiting. This maintains a consistent state by freeing resources before error termination. The principle of cleaning up before error exit is strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 4,
        "reasoning": "The code is a command-line argument parser, not a network protocol handler. While it does validate input (e.g., checking for required options like output format), the specification's focus on network protocols and the associated threat model (remote attackers) is not directly applicable. The general principle of input validation is weakly connected.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code performs a memory allocation (`malloc(sizeof(cmdopts_t))`) but does not validate the size parameter. While `sizeof(cmdopts_t)` is a compile-time constant and likely safe, the specification's principle of validating size parameters applies broadly. The subsequent usage of the allocated structure is safe due to the full initialization (Spec 4). The connection is moderate because the allocation size is not derived from user input, but the general best practice is relevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-0361_after_exclude_100:e7fc58db:spec": {
    "timestamp": "2026-01-17T01:54:30.150170",
    "cve_id": "CVE-2022-0361",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e7fc58db",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It copies lines of text within a buffer. There is no processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns containing escape sequences. It is a line copy operation, not a pattern compiler.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The code uses `vim_strsave()` and `ml_get()` to copy lines. While it handles internal buffer lines, the principle of using safe operations (like `vim_strsave` which allocates a copy) for data that could be manipulated has moderate relevance. However, the input is not clearly \"untrusted\" in the typical security sense.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "The code interacts with a buffer's line data (`ml_get`, `ml_append`) which likely involves internal locking or state management. The comment about the line being \"unlocked within ml_append()\" indicates awareness of resource (line) lifecycle and locking. Holding required locks until operations complete is a relevant principle here.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource lifecycle must be protected by holding all required locks until operations co..."
      },
      {
        "score": 7,
        "reasoning": "The code performs a multi-step operation (copying a range of lines) that modifies shared buffer state. The principle of maintaining atomic operation boundaries under lock protection is relevant to ensure the buffer remains consistent. The existing lock/unlock comments show this is a consideration.",
        "spec_index": 4,
        "spec_preview": "HS-TIMING-002: Shared resource access must maintain atomic operation boundaries under lock protectio..."
      },
      {
        "score": 4,
        "reasoning": "The code does not explicitly show memory policy reference counting (e.g., for shared objects). It allocates and frees memory with `vim_strsave`/`vim_free`, but this is simple ownership, not reference counting synchronized with lock state.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory policy reference counting must be synchronized with lock state"
      },
      {
        "score": 3,
        "reasoning": "The code does not parse protocol messages or validate length fields from external input. It operates on line numbers (`linenr_T`) which are internal counts, but there is no shown validation against integer overflow for the `count` variable, which is a weak connection at best.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses `vim_strsave()` which internally performs memory allocation. The principle of validating size parameters is weakly relevant because `vim_strsave`'s input comes from `ml_get` (getting a buffer line), whose length is not validated here for allocation limits. However, the buffer's line length is an internal, potentially trusted value.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-0361_before_exclude_100:6236ed62:spec": {
    "timestamp": "2026-01-17T01:54:32.263775",
    "cve_id": "CVE-2022-0361",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6236ed62",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing. It copies lines of text within a buffer. The input (line numbers) are trusted indices, not string patterns containing NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile or process patterns with escape sequences. It performs line duplication using `ml_get()` and `ml_append()`.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses `vim_strsave()` on the result of `ml_get()`, which returns a pointer to a line in the buffer. While the buffer content could be considered untrusted user data, the operations are typical editor buffer management. The primary risk would be if the line contained an embedded NUL, but `vim_strsave()` is a string copy function. The guidance on length-aware operations for untrusted input has some value here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code comment explicitly mentions that the line pointer from `ml_get()` will be unlocked within `ml_append()`. This indicates a resource (buffer line) lifecycle that must be protected. The code uses `vim_strsave()` to create a copy before calling `ml_append()`, which appears to be a mechanism to hold the required data until the operation completes, aligning with the specification's principle.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource lifecycle must be protected by holding all required locks until operations co..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code manipulates shared resources (the buffer lines) and uses locking internally (implied by the \"unlocked\" comment). However, the atomicity of the overall copy operation is managed by the `u_save()` (undo save) call and the loop logic, not explicitly by locks visible in this snippet. The connection to the specification is indirect.",
        "spec_index": 4,
        "spec_preview": "HS-TIMING-002: Shared resource access must maintain atomic operation boundaries under lock protectio..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not show explicit memory policy reference counting (e.g., for shared buffers or objects). The `vim_strsave()`/`vim_free()` pair manages memory for a local copy, which is simple ownership, not reference counting synchronized with a lock state.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory policy reference counting must be synchronized with lock state"
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol messages or validate length fields. It operates on line numbers (`linenr_T`) provided as arguments, which are presumably validated by the caller.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2019-11235_before_exclude_100:80d225e5:spec": {
    "timestamp": "2026-01-17T01:54:51.233183",
    "cve_id": "CVE-2019-11235",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "80d225e5",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve parsing numeric fields from a buffer. It is primarily handling cipher objects and state updates after they have already been derived by a lower layer (Fizz). There is no direct buffer length validation happening here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol message parsing must validate all numeric fields against remaining buffer len..."
      },
      {
        "score": 4,
        "reasoning": "The code is not parsing or handling SSH message formats. It is part of a QUIC handshake state machine, dealing with cryptographic material and transport parameters. The specification's focus on strict structural validation of message formats is not directly applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: SSH message handlers must maintain strict structural validation of message formats"
      },
      {
        "score": 3,
        "reasoning": "The code does not perform integer operations. It deals with moving smart pointers and cipher objects, and checking for null pointers. There are no arithmetic operations that would require overflow checks.",
        "spec_index": 2,
        "spec_preview": "HS-LOGIC-003: Integer operations must include overflow checks before use in memory operations"
      },
      {
        "score": 5,
        "reasoning": "The code updates connection state based on the availability of cryptographic objects. It conditionally sets ciphers and handles the case where client transport parameters are missing (throwing an exception). This relates to ensuring the connection state is correctly initialized based on handshake progress, though it's not about \"packet parsing failure\" per se.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 4,
        "reasoning": "The code is not a protocol dissector validating headers. It assumes the handshake layer (Fizz) has already processed messages and derived cryptographic material. The checks are for the presence of cipher objects, not protocol headers.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      },
      {
        "score": 5,
        "reasoning": "The code demonstrates good practice in checking if objects (like `zeroRttReadCipher`, `clientParams`) are initialized/non-null before using them. This aligns with the principle of guaranteeing field initialization before use, though the fields are complex objects rather than simple network input fields.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Network input processing must guarantee field initialization before use"
      },
      {
        "score": 5,
        "reasoning": "The code moves resources (cipher objects) into the connection state. There is no explicit resource cleanup shown here. The principle of conditional cleanup based on successful initialization is only weakly connected, as the code's success path assumes the moved-from objects are in a valid state.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "The code's core function is to retrieve and apply cryptographic keys (ciphers and header ciphers) that have already been created by the handshake layer. The specification about verifying algorithm support before key creation is highly relevant in the broader context. This code operates *after* that step, but its correct function depends on the handshake layer having performed such verification. The `CHECK` statements also ensure state consistency related to cipher existence.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2021-24029_after_exclude_100:e27bf576:spec": {
    "timestamp": "2026-01-17T01:55:21.026690",
    "cve_id": "CVE-2021-24029",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e27bf576",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve parsing numeric fields from a buffer. It is focused on updating internal cryptographic state based on already-retrieved cipher objects from a handshake layer. The specification about validating numeric fields against buffer length is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol message parsing must validate all numeric fields against remaining buffer len..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about SSH message handlers and strict structural validation. The target code is for QUIC handshake state updates in a C++ implementation, not SSH protocol message processing. The core concept of validation is not applied here.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: SSH message handlers must maintain strict structural validation of message formats"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform integer operations that could overflow, nor does it use integers for memory allocations. It deals with moving cipher objects and updating state flags.",
        "spec_index": 2,
        "spec_preview": "HS-LOGIC-003: Integer operations must include overflow checks before use in memory operations"
      },
      {
        "score": 5,
        "reasoning": "While the code is not about packet parsing failure, it does involve state initialization and updates (e.g., setting ciphers, updating conn state). The principle of ensuring state is correctly initialized during a process is weakly relevant, as the function's purpose is to update the connection state based on handshake progress.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "The code does not act as a protocol dissector or validate packet headers. It assumes the handshake layer has already processed messages and provides cipher objects.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      },
      {
        "score": 5,
        "reasoning": "The code checks for the presence of objects (like `zeroRttReadCipher`, `clientParams`) before using them, which aligns with the principle of guaranteeing field initialization before use. However, it's not processing raw network input but internal objects.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Network input processing must guarantee field initialization before use"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve resource cleanup or conditional cleanup based on initialization success. It is about acquiring and assigning resources (ciphers).",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code's core function is to conditionally retrieve and apply cryptographic keys and ciphers (e.g., Zero RTT, One RTT) based on the handshake state. The process implicitly verifies that the handshake layer supports and has generated these algorithms before creating/assigning the key objects to the connection state. The check for `clientParams` before `processClientInitialParams` also follows a similar validation-before-use pattern for cryptographic negotiation data.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2016-1835_before_exclude_100:f030234f:spec": {
    "timestamp": "2026-01-17T01:56:28.956644",
    "cve_id": "CVE-2016-1835",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f030234f",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing. It is an XML writer function that constructs XML elements, namespaces, and attributes. There is no pattern matching or regex processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences in a pattern compiler context. It does call `raptor_xml_escape_string` for attribute value escaping, which is related to XML escaping, but the specification is about pattern compilers (like regex) which is not the primary function here.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code uses length-aware string operations extensively (e.g., `raptor_iostream_counted_string_write`, `element->name->local_name_length`, `lang_len`). It processes XML element names, attributes, and language values which could be from untrusted input, making length-aware operations crucial to prevent buffer overflows.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates an array `nspace_declarations` based on a calculated maximum count (`nspace_max_count`). Accesses to this array use indices (`i`, `nspace_declarations_count`) that are controlled by loops with bounds checks (e.g., `for(i = 0; i < element->attribute_count; i++)`). However, there is a potential off-by-one error: `nspace_declarations` is allocated with size `nspace_max_count * sizeof(struct nsd)`, but the code may write up to `nspace_max_count` entries (index 0 to `nspace_max_count-1`). The logic for incrementing `nspace_declarations_count` and using it as an index appears safe as long as `nspace_max_count` is correctly calculated. Direct relevance is high because buffer bounds validation is critical.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code is part of an XML writer, not a parser. However, it does process input structures (element, attributes, namespaces) to generate XML output. It validates namespace scoping and checks for duplicates before adding declarations, which enforces some structural constraints. The specification is more about parser input validation, but the principles apply to ensuring the input data structure is valid before processing.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "This is an XML protocol implementation (writer side). The code must maintain boundary integrity when constructing XML output, especially when handling namespaces, attributes, and escaped strings (e.g., `raptor_xml_escape_string`). Proper escaping and length management are essential to prevent XML injection or malformed output that could affect downstream parsers.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 6,
        "reasoning": "The code uses `RAPTOR_CALLOC` which likely zero-initializes the allocated memory for `nspace_declarations`. However, the struct fields (`declaration`, `length`, `nspace`) are later assigned before use. The allocation size calculation and potential initialization of all entries are relevant, but the code does not read uninitialized memory. Partial relevance because memory is allocated and must be safely managed.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has a clear error handling path (goto error) that frees allocated `nspace_declarations` and their internal `declaration` strings. It maintains consistent state by cleaning up resources on error. However, the function returns an error code without rolling back other state changes (e.g., namespace stack modifications may have occurred before error). Still, error handling is present and relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2016-1836_after_exclude_100:30d8d02f:spec": {
    "timestamp": "2026-01-17T01:56:29.386459",
    "cve_id": "CVE-2016-1836",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "30d8d02f",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing. It is an XML writer function that constructs XML elements, namespaces, and attributes. There is no pattern matching or regex processing where embedded NUL bytes would be relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code extensively uses length-aware string operations: raptor_iostream_counted_string_write is used with explicit length parameters (prefix_length, local_name_length), and raptor_xml_escape_string is called with a length parameter (lang_len). This aligns with the principle of using length-aware operations for input, though the input in this writer function may not be \"untrusted\" in the typical sense (it's data being written out).",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function processes an XML element structure (element) and its attributes. It validates structural constraints implicitly by checking for null pointers (e.g., if(element->name->nspace)) and using sequence sizes. However, this is more about writing/outputting XML rather than parsing and validating input XML structure. The specification is more targeted at parsers validating input before processing.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. This is an XML protocol implementation (XML writer) that constructs XML output. It must maintain boundary integrity when handling namespaces, attributes, and escaped content (e.g., via raptor_xml_escape_string). The function carefully manages namespace declarations and attribute formatting to produce well-formed XML, which directly relates to maintaining strict boundary integrity during XML generation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Memory is allocated via RAPTOR_CALLOC, which likely zero-initializes the memory (calloc-like). However, the struct nsd contains pointers and length fields; after allocation, the code immediately starts assigning to specific indices, not necessarily initializing all allocated slots. The initialization is done on-demand as entries are added. This could leave gaps if not all slots are used, but those gaps are not accessed later. The specification about full initialization before use is partially followed but not strictly for the entire allocated block.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code has explicit error handling (goto error) that cleans up allocated memory (nspace_declarations and their internal declarations) before returning an error code. This ensures consistent state on error paths by freeing resources. However, note that on success, nspace_declarations is freed at the end, but the individual declaration strings are freed earlier in the loops after writing. The error path properly cleans up any partially allocated declarations.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-38383_before_exclude_100:972962fe:spec": {
    "timestamp": "2026-01-17T01:58:00.716071",
    "cve_id": "CVE-2021-38383",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "972962fe",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process protocol messages with length fields. It handles network binding and socket configuration. The only input resembling a length is the port number, but it's not a protocol message length field in the sense of network protocol parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit dynamic memory allocation (like malloc). Memory allocation for `addrinfo` structures is done internally by `getaddrinfo`. While size validation is important, the specification about validating size parameters against allocation limits is not directly applicable to the primary operations shown.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles socket types (SOCK_STREAM/SOCK_DGRAM) and address families (AF_INET/AF_INET6). There is some type filtering (`hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM))`) and consistent handling across binding stages. However, this is not about a complex protocol implementation with multiple processing stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers at all. This specification is completely irrelevant to the network binding functionality.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. This specification is completely irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses `snprintf` with a fixed-size buffer for the port string, which is good. However, the `cfgaddr` and `log_service_name` inputs are passed to `getaddrinfo` and `DPRINTF` without visible length validation. The `cfgaddr` comes from configuration, which could be considered untrusted. There is weak relevance because string handling is present but not the main focus.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes local variables (hints, yes, no). It does not perform heap allocations that need initialization. The `addrinfo` structure from `getaddrinfo` is initialized by the system call. The relevance is weak.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (getaddrinfo failure, socket creation failure, setsockopt failures, bind failure). It uses `goto error` to clean up the file descriptor on final error. However, there is a potential issue: if the loop fails after a successful `socket()` but before `bind()`, the `close(fd)` in the loop may close a valid descriptor, but if `ptr` is NULL at the end, the error path will also call `close(fd)` on a potentially invalid fd (if fd == -1). Actually, `fd` is initialized to -1, and the error path closes `fd` regardless, which could close an invalid descriptor. This is a minor issue but shows the error handling path attempts to maintain consistency. The specification about maintaining consistent object states in error paths is highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-38383_after_exclude_100:95880ed4:spec": {
    "timestamp": "2026-01-17T01:58:05.864096",
    "cve_id": "CVE-2021-38383",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "95880ed4",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process protocol messages with length fields. It performs network socket binding and address resolution. The specification about validating protocol message length fields is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation (like malloc, calloc). Memory allocation for addrinfo structures is handled internally by getaddrinfo(). The specification about validating size parameters for memory allocation has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles socket address structures (addrinfo, sockaddr) and converts between different representations. There's moderate relevance regarding consistent handling of address families (AF_INET vs AF_INET6) and socket types, though not specifically about protocol type handling.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expressions at all. It performs network socket operations and address resolution. This specification has no relevance to the target code.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain pattern compilers or process escape sequences. It deals with network socket binding and configuration. This specification has no relevance to the target code.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses snprintf() with proper bounds checking for strport, and net_address_get() appears to take a size parameter. However, the primary input (cfgaddr, port) comes from configuration, not directly from untrusted network input. Weak relevance as some string handling exists but is not the main focus.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes several local variables (hints = {0}, naddr = {0}, yes/no variables). This demonstrates good practice of initializing memory before use. Moderate relevance as initialization is present but not the code's primary security concern.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (goto error, continue in loops, early returns). It maintains consistent state by closing file descriptors on errors and freeing allocated resources (freeaddrinfo). Strong relevance as error handling is a significant aspect of this function.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-1297_before_exclude_100:b90fa7a0:spec": {
    "timestamp": "2026-01-17T01:58:15.133883",
    "cve_id": "CVE-2022-1297",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b90fa7a0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses R_NEW0 which zero-initializes memory, satisfying HS-MEM-001. However, there are pointer dereferences (e.g., bin->entry_table + off) without validation that the computed address points within the allocated buffer, which is a related memory safety concern.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error handling paths (memory allocation failures, missing segments) where it frees some resources (like 'entries') but may leak others (like 'segments' in some paths). State consistency is not fully maintained.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code parses a binary file format (NE executable) from a buffer, not network protocol data. The principle of input validation is analogous but the context is different.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code validates length fields (bundle_length, EntryTableLength) against buffer size using checks like `tableat + off >= r_buf_size(bin->buf)`. However, it does not explicitly validate against integer overflow/underflow when computing offsets (e.g., tableat + off + 4).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code does not perform direct memory allocation based on user-controlled size parameters. However, it uses length fields from the binary to control loop iterations and pointer arithmetic, which indirectly affects memory access. Validation of these against buffer bounds is partially done.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code handles different bundle types (0, 0xff, others) and performs different operations. Consistency is somewhat maintained, but the primary concern is not protocol type handling but binary structure parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve regular expression parsing. The specification about embedded NUL bytes is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve pattern compilers or escape sequence processing. The specification is unrelated to the binary parsing context.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-1297_after_exclude_100:741a06e5:spec": {
    "timestamp": "2026-01-17T01:58:34.913289",
    "cve_id": "CVE-2022-1297",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "741a06e5",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses R_NEW0 which zero-initializes memory, satisfying the requirement to initialize allocations before use. However, there are other allocations (like the RList for 'entries') where the elements are initialized later in the logic, but the list nodes themselves are managed by r_list_newf. The main concern is that the function ensures allocated structures (RBinAddr) are fully initialized with relevant fields (bits, paddr) before being appended to the list, aligning well with HS-MEM-001.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code demonstrates strong error handling that maintains consistent state. It checks for NULL after allocations (RList, RBinAddr) and properly frees previously allocated resources (e.g., r_list_free(entries)) before returning NULL. It also frees the 'segments' list before returning the final result. This careful cleanup on error paths prevents memory leaks and keeps object states consistent, which is the core of HS-STATE-002.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is parsing a binary file format (NE executable) from a buffer, not handling network protocols. There is no network input processing, making HS-IO-003 irrelevant to this scenario.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 7,
        "reasoning": "The code validates length fields from the binary structure against buffer boundaries. It checks `tableat + off >= r_buf_size(bin->buf)` and `tableat + off + 4 >= r_buf_size(bin->buf)` before accessing data. It also validates `bundle_length` and ensures `off` doesn't exceed `EntryTableLength`. This aligns with the principle of validating length fields against limits (here, buffer size), though the specification mentions \"platform-specific integer limits\" which is a broader concept.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2016-1835_before_exclude_100:cead6673:spec": {
    "timestamp": "2026-01-17T01:58:41.874453",
    "cve_id": "CVE-2016-1835",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cead6673",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses strtok for string splitting, not regular expression parsing. While embedded NUL bytes could affect strtok behavior (as it expects null-terminated strings), the specification is specifically about regex parsers, making the connection weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequence processing, which doesn't apply to this simple string splitting function that doesn't compile patterns or process escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code uses strtok which is not length-aware and could be problematic with untrusted input containing embedded NUL bytes. The function processes input strings and should use safer, length-bounded operations for security.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The error handling paths carefully maintain consistent object states by freeing all allocated memory (result array, strings, and copy) before returning NULL, preventing memory leaks in error conditions.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. This is a general string splitting utility function, not a network protocol handler. There's no network I/O or protocol processing in this code.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The error handling paths consistently free all allocated memory (result array, individual strings, and the copy buffer) across all execution branches, maintaining proper memory state even when allocations fail.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function processes input strings but doesn't validate or establish clear boundaries before memory operations. It relies on strtok which assumes proper null-termination, making boundary validation important for security.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2011-1003_after_exclude_100:a6c92b39:spec": {
    "timestamp": "2026-01-17T01:59:34.751355",
    "cve_id": "CVE-2011-1003",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a6c92b39",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses strtok for string splitting, not regular expression parsing. While embedded NUL bytes could affect strtok behavior (as it expects null-terminated strings), the specification specifically addresses regular expression parsers, making the connection weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification addresses pattern compilers and escape sequence processing, which is completely unrelated to the simple string splitting functionality in the target code. No pattern compilation or escape sequence handling occurs.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code uses strtok which is not length-aware and could be problematic with untrusted input containing embedded NUL bytes. The specification recommends length-aware operations for security, which this function lacks.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code allocates memory via realloc but doesn't explicitly initialize all bytes. However, it immediately assigns string pointers to the allocated slots, so the risk is somewhat mitigated. Still, uninitialized memory could exist in the result array if allocations fail mid-process.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code has multiple error handling paths that free allocated memory consistently. It maintains object state consistency by cleaning up partial allocations when realloc fails, though there's a potential issue with the first realloc failure case.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code performs simple string splitting, not network protocol handling. No network input validation occurs in this function.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The error handling paths carefully maintain consistent memory state by freeing all allocated resources (copy, result array, and individual strings) when realloc fails. This prevents memory leaks across execution branches.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The function accepts arbitrary input strings without validation. While it doesn't perform boundary checks before memory operations (realloc), the use of dupstr and strtok on the copy provides some isolation from the original input.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2022-3028_after_exclude_100:58ebbc91:spec": {
    "timestamp": "2026-01-17T01:59:56.807427",
    "cve_id": "CVE-2022-3028",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "58ebbc91",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code does not parse or validate any length fields from the `sadb_msg` structure; it only checks the `sadb_msg_satype` field against a maximum value. Therefore, the connection is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code calls `compose_sadb_supported` with `GFP_KERNEL | __GFP_ZERO`, but there is no visible validation of the size parameter for that allocation. The specification's principle of validating size parameters against allocation limits is moderately relevant, as the allocation failure is handled (ENOBUFS), but proactive validation is not shown.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns validating userspace-provided array lengths. The target code does not process any array-like structures with explicit length fields from userspace. The `ext_hdrs` parameter is not used, so relevance is weak.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about verifying the structural integrity of variable-length components in protocol messages. The target code does not parse or validate the `ext_hdrs` array or any variable-length fields within the message. Relevance is weak.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The specification relates to buffer allocation accounting for worst-case input. The allocation in `compose_sadb_supported` is internal and its size likely depends on kernel state (available algorithms), not direct user input. However, the principle of handling allocation failure exists. Relevance is weak to moderate.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The specification is highly relevant. The code uses a mutex (`pfkey_mutex`) to protect the shared resource state transition between `xfrm_probe_algs()` and `compose_sadb_supported()`. This ensures atomicity for the operations on shared algorithm data.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The specification is strongly relevant. The code maintains consistency for the `pfk->registered` bitmask. If memory allocation fails, it rolls back the registration state (`pfk->registered &= ~(1<<hdr->sadb_msg_satype)`), ensuring strict consistency between the allocation state and the tracking structure.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-3028_before_exclude_100:a253b8b7:spec": {
    "timestamp": "2026-01-17T02:00:00.039637",
    "cve_id": "CVE-2022-3028",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a253b8b7",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code does receive a protocol message (`hdr`), but it does not explicitly validate any length field from it (like `sadb_msg_len`). The primary validation is on the `satype` field. Therefore, the connection is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs a memory allocation via `compose_sadb_supported`. The size parameter for this allocation is not directly visible here, but it's implied it's based on the protocol message. The code does check for allocation failure (`!supp_skb`) and handles it by rolling back the registration state, which relates to validating the allocation succeeded for its intended use. However, there's no explicit validation of a size parameter against limits before the call, making relevance moderate.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code strongly enforces type handling for the `sadb_msg_satype` field. It validates it is not greater than `SADB_SATYPE_MAX` and has specific logic for the `SADB_SATYPE_UNSPEC` type versus other types. This ensures consistent interpretation and processing of the type field across the registration logic, making it highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns validating userspace-provided array lengths. The target code does not process any explicit array where a length is provided by userspace. The `ext_hdrs` pointer array is passed in but its length is not directly manipulated or validated here. The connection is weak.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about verifying the structural integrity of variable-length components in a protocol message. The function receives `ext_hdrs` which are variable-length extensions, but the code does not process or validate them in this function. The primary logic operates on the fixed header `hdr`. Therefore, relevance is weak.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates a buffer (`supp_skb`) for a supported algorithms reply. The allocation size inside `compose_sadb_supported` would need to account for the worst-case number of supported algorithms. While this is a consideration for the subsystem, the target code snippet itself does not contain explicit size limit checks or calculations, leading to weak-to-moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The registration state (`pfk->registered`) is a shared resource (per socket). The code performs a non-atomic check (`if (pfk->registered&(1<<hdr->sadb_msg_satype))`) and then an update (`pfk->registered |= ...`). Without a lock or atomic operation, this is a classic TOCTOU race condition. The specification directly calls for atomic check-and-update, making it highly relevant. The current implementation is vulnerable.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The code manages resource allocation state: the registration bitmask (`pfk->registered`). It shows strict consistency by rolling back the registration (`pfk->registered &= ~(1<<hdr->sadb_msg_satype)`) if the subsequent resource allocation (for `supp_skb`) fails. This prevents an inconsistent state where the socket is marked as registered but lacks necessary resources. The principle applies directly.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2017-18249_before_exclude_100:356876e0:spec": {
    "timestamp": "2026-01-17T02:00:29.763805",
    "cve_id": "CVE-2017-18249",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "356876e0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the input `size` parameter against a maximum limit (`RINGBUF_MAX_RECORD_SZ`). This is a direct validation of a length field (the requested reservation size) against a platform-specific limit, aligning with the core principle of HS-INPUT-001. It's not a network protocol message, but the pattern of validating a user-provided size against a defined limit is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The function's primary purpose is to \"reserve\" space in a ring buffer, which is a form of memory allocation. It validates the `size` parameter against `RINGBUF_MAX_RECORD_SZ` and also performs a critical check to ensure the new producer position does not overflow the buffer's capacity (`rb->mask`). This directly addresses validating size parameters against allocation limits and subsequent usage (preventing wrap-around/buffer overflow).",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "The code deals with an internal kernel ring buffer mechanism, not a communication protocol. There are no distinct processing stages with type conversions or serialization/deserialization concerns. The specification's focus on protocol type handling is not applicable here.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "The `size` parameter is ultimately provided from userspace (via a BPF program syscall). The code validates this size against a system constraint (`RINGBUF_MAX_RECORD_SZ`) before using it to calculate memory offsets and positions. This is a direct application of the specification's principle.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The code handles a single, simple \"record\" with a header and data. It validates the total size but does not parse or verify the structure of variable-length components within the reserved data area. The specification is aimed at complex protocol parsers, which doesn't match this simple allocator.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The function performs buffer allocation within a fixed-size ring buffer. It accounts for the worst-case input scenario (the maximum allowed `size`) by checking `new_prod_pos - cons_pos > rb->mask`. This ensures the requested space, plus header, does not exceed the available capacity, preventing buffer overrun.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      }
    ]
  },
  "CVE-2017-18249_after_exclude_100:e54de199:spec": {
    "timestamp": "2026-01-17T02:00:37.463294",
    "cve_id": "CVE-2017-18249",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e54de199",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the input `size` parameter against a maximum record size (`RINGBUF_MAX_RECORD_SZ`). This is a direct validation of a length field (the `size` parameter acts as a length for the record to be reserved) against a platform-specific limit, aligning with the core principle of HS-INPUT-001. However, the specification mentions \"protocol message length fields,\" while this is a kernel internal API for BPF ring buffers, not a network protocol. The relevance is strong but not a perfect match for the context.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code performs multiple validations related to memory allocation/space reservation. It validates `size` against `RINGBUF_MAX_RECORD_SZ`, rounds up the total size (header + data), and validates this `len` against the ring buffer's capacity (`rb->mask + 1`). Finally, it checks for available space by ensuring the new producer position doesn't wrap beyond the consumer. This comprehensive validation against allocation limits and usage requirements makes this highly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "The specification concerns protocol implementations and consistent type handling across processing stages. The target code is a low-level kernel memory buffer management function. It uses basic integer types (u64, u32, unsigned long) and pointer arithmetic, but there is no protocol parsing or multi-stage type consistency issue involved. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 7,
        "reasoning": "The `size` parameter is ultimately provided from userspace (via a BPF program helper). The code validates this size against system constraints (`RINGBUF_MAX_RECORD_SZ` and the ring buffer's capacity) before processing (reserving space). This aligns with the principle of validating userspace-provided lengths. The relevance is moderate to strong, though the specification's focus on \"array lengths\" is slightly narrower than the general \"size\" parameter used here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "The specification is for protocol message handlers verifying variable-length components. This code manages a ring buffer for BPF programs; it does not parse or handle structured protocol messages with variable-length components. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 9,
        "reasoning": "The code explicitly accounts for worst-case input by validating the requested `size` against a hard maximum (`RINGBUF_MAX_RECORD_SZ`). Furthermore, the space check (`new_prod_pos - cons_pos > rb->mask`) ensures that the reservation does not exceed the total available buffer space, which is the fundamental explicit size limit. This is a core part of the function's logic, making it highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "The specification is about memory release operations and ownership semantics. This function (`__bpf_ringbuf_reserve`) is solely responsible for *allocating/reserving* space in the ring buffer. It does not contain any memory release or free operations. The relevance is essentially non-existent.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about file content processing and handling empty files. The target code operates on a kernel ring buffer in memory and has no relation to file I/O, file systems, or processing file content. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      }
    ]
  },
  "CVE-2021-37847_before_exclude_100:b09ab173:spec": {
    "timestamp": "2026-01-17T02:02:12.145279",
    "cve_id": "CVE-2021-37847",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b09ab173",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code performs a digest verification using memcmp on binary data. There is no regular expression parsing, making the connection very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code uses `memcmp` with an explicit length `len`, which is a length-aware operation. This is good practice for comparing binary data like digests, aligning with the principle of using length-aware operations for data (which could be considered untrusted input in a broader context).",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates the length `len` implicitly by using it for allocation and memcmp, but it does not validate `len` against any system constraints (e.g., maximum buffer size). The `len` comes from `digest_length(d)`, which is presumably a trusted internal function. The connection to validating user-provided array lengths is weak.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The specification is about protocol message handlers verifying variable-length components. This function verifies a digest, which is a fixed-length component based on the digest algorithm. The structural integrity check is a simple binary comparison, not protocol parsing. Relevance is weak.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 7,
        "reasoning": "The code allocates a buffer of size `len` for the computed digest. This accounts for the exact size needed, which is the worst-case for this specific operation. However, it does not consider explicit, broader input size limits, as `len` is determined by a trusted function. There is moderate relevance to the principle of allocating based on known requirements.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 4,
        "reasoning": "The specification is about validating protocol message length fields. The target code does not process protocol messages or length fields. The `len` variable is an internal digest length, not a user-provided length field. Relevance is weak.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs memory allocation (`xmalloc(len)`). While it doesn't explicitly show validation of the `len` parameter, using the result of `digest_length(d)` as the size is a form of validation if that function is trusted. The principle of ensuring the allocation size is appropriate for subsequent usage (here, for `digest_final` and `memcmp`) is directly followed, showing strong relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-37847_after_exclude_100:64568640:spec": {
    "timestamp": "2026-01-17T02:02:21.913987",
    "cve_id": "CVE-2021-37847",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "64568640",
    "scores": [
      {
        "score": 2,
        "reasoning": "The specification concerns regular expression parsers handling embedded NUL bytes. The target code performs a cryptographic digest verification using memory comparison. There is no regular expression parsing or string pattern processing involved.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The specification concerns pattern compilers and escape sequence processing. The target code does not compile patterns, parse escape sequences, or process textual patterns of any kind.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The specification advises using length-aware operations for untrusted input. The code uses `crypto_memneq` for a length-controlled comparison (`len`), which is a length-aware operation. However, the input `md` is a pointer, and there's no explicit validation shown that the buffer it points to is at least `len` bytes, which relates to the principle. Relevance is moderate.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about validating userspace-provided array lengths. The `len` variable is derived from `digest_length(d)`, an internal cryptographic API, not a userspace-provided input. The principle of validating lengths before use is good, but the scenario doesn't directly involve untrusted length inputs.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The specification concerns protocol message handlers verifying variable-length components. This code is a low-level digest verification function, not a protocol message handler. It does not parse or validate the structure of composite messages.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The specification advises accounting for worst-case input with explicit size limits for buffer allocation. The code allocates a buffer sized to `len` (the digest length). Digest lengths are typically small, fixed constants (e.g., 16, 20, 32 bytes). While it accounts for the exact needed size, the \"worst-case\" and \"explicit limits\" principle has weak relevance as `len` is not derived from variable or untrusted input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 2,
        "reasoning": "The specification concerns validating protocol message length fields. The code does not process protocol messages or have any length fields from an external source to validate.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The specification states memory allocation size parameters must be validated against allocation limits and usage requirements. The code uses `xmalloc(len)`. While `xmalloc` might internally handle allocation failure, the size `len` comes from `digest_length(d)`. If `digest_length` could return an erroneous or excessively large value (e.g., due to a corrupted state), it could lead to an oversized allocation. The principle of validating this internal size parameter before allocation has moderate relevance. The code's safety depends on the correctness of `digest_length`.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2018-10675_before_exclude_100:dc39a069:spec": {
    "timestamp": "2026-01-17T02:03:05.826969",
    "cve_id": "CVE-2018-10675",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dc39a069",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code validates a user-provided file descriptor index (`fd`) against `ctx->nr_user_files`. This is a form of length/range validation for an array index, which is related to validating integer limits. However, the specification specifically mentions \"protocol message length fields,\" which is a network/communication context. The core principle of validating user input against limits is present, but the specific scenario (kernel internal file table vs. protocol messages) is different, resulting in weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation operations. It accesses a pre-allocated file table slot. The validation of the `fd` index could be seen as related to preventing out-of-bounds access, which is a subsequent usage requirement, but the specification's primary focus is on validating size parameters for allocation functions (like `kmalloc`, `vmalloc`). The connection is very low.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code handles a kernel-internal data structure (io_uring's file table) and a cancellation request. There is no implementation of a communication protocol with variable types or serialization/deserialization stages that require consistent type handling. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The code directly validates a userspace-provided array index (`fd`) against a system constraint (`ctx->nr_user_files`) before using it to access the `file_table` array. It even uses `array_index_nospec` to mitigate speculative execution attacks. This is a textbook example of the specification's requirement.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2022-3103_after_exclude_100:8835f192:spec": {
    "timestamp": "2026-01-17T02:03:20.659183",
    "cve_id": "CVE-2022-3103",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8835f192",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code validates a user-provided file descriptor index (fd) against a maximum limit (ctx->nr_user_files). This is a form of length/range validation, but it's not specifically about \"protocol message length fields.\" The principle of validating user input against limits is relevant, but the context (kernel internal file table vs. network protocol) is different, making the direct application weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation operations. It performs bounds checking and array indexing, which is related to safe memory access but not to the validation of size parameters for allocation functions like kmalloc or malloc. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code is not implementing a network or inter-process protocol. It is an internal kernel function for canceling asynchronous I/O operations. The concept of consistent type handling (e.g., for data serialization) does not apply here. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2016-10317_before_exclude_100:579c64f7:spec": {
    "timestamp": "2026-01-17T02:04:10.958332",
    "cve_id": "CVE-2016-10317",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "579c64f7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memcpy operations based on calculated widths and offsets. Specification HS-MEM-003 about buffer allocation accounting for padding and safety margin is strongly relevant. The function assumes dest_strip has sufficient capacity for left_width + (num_tiles * src_width) + right_width bytes. If the caller's allocation doesn't include proper safety margins or miscalculates these parameters, buffer overflow could occur.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-004 about image compression encoder buffers has weak relevance. While the function appears to process image strip data (possibly for compression/threshold operations), it doesn't directly perform compression. The bounds checking principle applies indirectly, but the specification is specifically about compression operations.",
        "spec_index": 1,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-001 about string operations validating length fields has moderate relevance. Although this code uses memcpy not string functions, the core principle of validating length fields against buffer capacity directly applies. The function uses multiple length parameters (left_width, src_width, right_width) that should be validated against available buffer space.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-001: String operations must validate length fields against remaining buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 about external format parsers implementing length validation chains has moderate relevance. The function processes data strips which could come from external sources. The parameters (widths, offsets, tile counts) should be validated as part of a validation chain before reaching this memory operation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-002: External format parsers must implement complete length validation chains"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-LOGIC-001 about image dimension calculations validating against maximum safe values has moderate relevance. The function performs calculations involving left_width + (num_tiles * src_width) + right_width. These calculations should be validated for integer overflow and against maximum safe values before memory allocation in calling functions.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must validate against maximum safe values before memory a..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 about external input validation before memory operations is strongly relevant. All parameters to this function (src_width, left_offset, left_width, num_tiles, right_width) should be validated as they control memory copy operations. Without validation, negative values, overly large values, or invalid combinations could cause buffer overflows.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-002: External input must be validated before use in memory operations"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 about memory allocation validation against calculated size requirements is highly relevant. The total bytes copied = left_width + (num_tiles * src_width) + right_width. This calculation must be validated against the allocated size of dest_strip. Integer overflow in this calculation is also a concern.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory allocation must be validated against calculated size requirements"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-001 about fixed buffer operations enforcing strict bounds validation is highly relevant. The function performs multiple memcpy operations to what appears to be a fixed buffer (dest_strip). It must validate that left_width, src_width * num_tiles, and right_width don't exceed the destination buffer capacity. The code shows no bounds checking before write operations.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      }
    ]
  },
  "CVE-2016-8670_after_exclude_100:43c160f8:spec": {
    "timestamp": "2026-01-17T02:04:28.389574",
    "cve_id": "CVE-2016-8670",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "43c160f8",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memcpy operations whose total size (left_width + num_tiles*src_width + right_width) must fit within the destination buffer. Specification HS-MEM-003 about accounting for padding and safety margin is strongly relevant, as the function must ensure the calculated total copy size does not exceed the allocated dest_strip buffer. The code does not show this validation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-004 mentions image compression and encoder buffers. The code appears to handle image strip/tile data (threshold buffer), which could be part of an image processing pipeline. However, it performs raw memory copying, not explicit compression operations. The relevance is weak to moderate.",
        "spec_index": 1,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 4,
        "reasoning": "Specification HS-MEM-001 refers to string operations and validating length fields. The code uses memcpy, not string functions (like strcpy). While the principle of validating lengths against buffer capacity is similar, the direct focus on \"string operations\" makes the connection weak.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-001: String operations must validate length fields against remaining buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 (first instance) is about external format parsers implementing complete length validation chains. The function parameters (like src_width, num_tiles) likely come from external input (e.g., an image file header). The code uses these parameters directly in memcpy without validating that they are within safe bounds of the source and destination buffers, making the specification's principle moderately to strongly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-002: External format parsers must implement complete length validation chains"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-LOGIC-001 is about validating image dimensions before memory allocation. This function operates on already-allocated buffers. However, the calculations involving left_width, num_tiles, src_width, and right_width effectively define a \"logical\" output size. If these input parameters are not validated, they could lead to buffer overflow. The relevance is moderate.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must validate against maximum safe values before memory a..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 (second instance) is highly relevant. The function parameters (src_width, left_offset, num_tiles, etc.) are external inputs that directly control memory copy sizes and offsets. The code uses them in memcpy operations without any apparent validation, creating a clear risk of buffer overflow if malicious or corrupted inputs are provided.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-002: External input must be validated before use in memory operations"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 (second instance) about validating allocation against calculated size requirements is strongly relevant. Although the allocation likely happens before this function is called, the function's logic calculates a total copy size. The caller must ensure the destination buffer allocation is sufficient for this calculated size. The function itself does not validate this.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory allocation must be validated against calculated size requirements"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-001 (second instance) is highly relevant. The code performs fixed buffer write operations (memcpy) into dest_strip. It must enforce strict bounds validation before these writes. The function lacks validation of parameters like left_width, src_width, num_tiles, and right_width against the actual size of dest_strip and src_strip, making it a direct violation of this specification's principle.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      }
    ]
  },
  "CVE-2016-10050_before_exclude_100:b2607ab7:spec": {
    "timestamp": "2026-01-17T02:04:33.856211",
    "cve_id": "CVE-2016-10050",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b2607ab7",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation (reverse operation) and does not involve any cryptographic operations on secret values. The specification is about constant-time execution for cryptography, which is completely unrelated to this numerical computation code.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor reverse operation in what appears to be a machine learning framework (likely TensorFlow). It has no elliptic curve implementations or any cryptographic components whatsoever.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "While the code involves memory operations (tensor allocation and manipulation), it is not performing cryptographic processing. The specification specifically targets secure memory operations during cryptographic processing, which doesn't apply here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor computations without any view-based data access, privilege checks, or database/view security semantics. This is purely numerical array manipulation.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "No security-critical state transitions or privilege contexts are involved in this tensor reverse operation. The code maintains computational state but not security state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code has no SQL protocol implementations, database access, or view security semantics. This is a mathematical tensor operation in a computational framework.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code performs buffer operations (tensor manipulation) and includes validation checks (OP_REQUIRES for dimension matching and rank limits). While not explicitly checking \"available space before each write,\" it validates input dimensions and allocates output tensor with proper shape validation, which aligns with the principle of validating boundaries before operations.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code includes input validation (checking dims shape, dimension matching) and maintains invariants about tensor dimensions. While not a traditional parser, it processes input tensors and validates their structure before state transitions in the computation, somewhat aligning with the principle of maintaining invariants during state transitions.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2021-29556_after_exclude_100:be9c9fc3:spec": {
    "timestamp": "2026-01-17T02:04:38.550323",
    "cve_id": "CVE-2021-29556",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "be9c9fc3",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation (reverse operation) with no cryptographic operations on secret values. It does not involve any timing-sensitive secret-dependent branching or memory access patterns related to cryptography.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor computation kernel with no elliptic curve operations or cryptographic implementations of any kind. Side-channel resistance for curve models is completely irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code manipulates tensor data structures with no view-based data access mechanisms, privilege checks, or database/view security semantics involved.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "This is a computational kernel function with no security-critical state transitions, privilege contexts, or authentication/authorization logic.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor operations with no SQL protocol implementations, database access, or view security semantics of any kind.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code validates tensor dimensions before operations (e.g., checking input_dims == dims.dim_size(0), input_dims <= 8). While not exactly buffer space validation, it follows the principle of validating constraints before use. The OP_REQUIRES macros perform validation similar to pre-write checks.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code maintains some invariants through dimension validation and conditional checks, but doesn't involve parser state transitions or buffer position management in the traditional sense. The validation of tensor dimensions and shapes could be loosely related to maintaining invariants during data processing.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2017-12858_before_exclude_100:dd146535:spec": {
    "timestamp": "2026-01-17T02:05:07.251983",
    "cve_id": "CVE-2017-12858",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dd146535",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves decoding tensor content into a buffer. While it uses an allocator and checks for successful allocation (p != nullptr), it does not explicitly show \"strict bounds validation before write operations\" within the decoding/field parsing helpers (Helper<T>::Decode, FromProtoField<T>). The relevance is moderate because buffer operations are central, but the validation logic is not visible in this function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "The function is an input parser for a TensorProto. It performs validation steps: checking tensor shape validity (TensorShape::IsValid), checking for invalid dtype, and calculating num_elements. However, the completeness of input size validation (e.g., ensuring content size matches N * sizeof(T)) likely depends on the helper functions, which are not shown. Strong relevance as it's a core input parsing function with several upfront checks.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 5,
        "reasoning": "This function is a configuration/structured data parser (parsing a TensorProto). It explicitly enforces structural constraints: validating tensor_shape() and rejecting DT_INVALID. It also handles two different data representation paths (tensor_content vs. fields). Highly relevant as it's a canonical example of a configuration parser applying structural validation.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve string functions (like strcpy, strlen) that require NUL-termination. It deals with binary tensor content and numeric fields. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory buffers passed to string functions must guarantee NUL-termination"
      },
      {
        "score": 5,
        "reasoning": "The function manages buffer allocation (via the allocator 'a') and aims to maintain a safe state. It checks for allocation failure (p == nullptr) and only updates internal state (shape_, dtype_, buf_) after successful decoding. It also properly unreferences the old buffer. Strong relevance to maintaining invariants during state transition.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Buffer allocation must maintain invariant of known-safe state"
      },
      {
        "score": 5,
        "reasoning": "This is a protocol parser for TensorProto. It validates the overall structure (shape, dtype) before processing. The critical buffer boundary validation (ensuring the parsed content length matches the expected number of elements) is likely deferred to the Decode/FromProtoField helpers. Strong relevance as it's the primary purpose of the function.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Protocol parsers must validate buffer boundaries before processing"
      },
      {
        "score": 5,
        "reasoning": "The function uses an allocator and tracks the size via `N` (num_elements) and the dtype. Consistent size tracking is implied as `N` and `dtype` are passed to the decoding helpers. However, the actual consistency between allocated buffer size and tracked size depends on the helper implementations. Moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "Resource management is a key aspect: it uses an allocator, manages a TensorBuffer (buf_), and ensures the old buffer is unreferenced (UnrefIfNonNull) before assigning the new one. It also logs memory allocation. This directly aligns with maintaining invariant consistency during resource updates. Highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2016-5844_after_exclude_100:df128c09:spec": {
    "timestamp": "2026-01-17T02:06:00.988408",
    "cve_id": "CVE-2016-5844",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "df128c09",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves buffer operations through `Helper<T>::Decode` and `FromProtoField<T>`. While it validates the tensor shape and number of elements (`N`) before processing, the specification's emphasis on \"strict bounds validation before write operations\" is only partially addressed. The actual bounds checking during the decode/field parsing is delegated to helper functions, making relevance moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "The code performs input size validation by checking `TensorShape::IsValid`, ensuring `N` (num_elements) is handled, and validating the data type. This aligns strongly with the principle of validating input size before processing, though the validation of `proto.tensor_content()` size versus expected `N` is not explicitly shown in this snippet.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function is a configuration/parser for a TensorProto, enforcing structural constraints like valid tensor shape, valid data type (DT_INVALID check), and handling of empty/incomplete shapes. This directly matches the specification's focus on enforcing structural constraints on input data.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code does not involve string functions (like strcpy, strlen) that require NUL-termination guarantees. It deals with binary tensor content and typed data fields.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory buffers passed to string functions must guarantee NUL-termination"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code allocates a `TensorBuffer* p` and updates `buf_` after unreferencing the old buffer. It maintains some state consistency (shape_, dtype_). However, the \"known-safe state\" invariant is partially dependent on the helper functions (`Decode`, `FromProtoField`) correctly allocating and initializing memory, which is not fully visible here.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Buffer allocation must maintain invariant of known-safe state"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code is a protocol parser (TensorProto). It validates the tensor shape and data type early, which relates to buffer boundary validation. However, the exact validation of `proto.tensor_content()` size against the expected size based on `N` and `dtype` is likely inside `Helper<T>::Decode`, so it's not directly visible, keeping it from a perfect score.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Protocol parsers must validate buffer boundaries before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Memory allocation occurs via `a` (Allocator) in helper functions. The code tracks size via `N` (num_elements) and shape, but the consistency of size tracking between the allocated buffer and `N` is delegated to the helper functions. The logging at the end records allocation but doesn't enforce size consistency.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function manages resources (TensorBuffer, memory via Allocator). It maintains invariants by validating input before allocation, unreferencing the old buffer (`UnrefIfNonNull(buf_)`) before assigning the new one, and updating shape_ and dtype_ consistently. The logging also tracks resource allocation.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2009-3909_before_exclude_100:2c3286e4:spec": {
    "timestamp": "2026-01-17T02:06:03.779121",
    "cve_id": "CVE-2009-3909",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2c3286e4",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor scatter operations, not cryptographic operations on secret values. There is no indication of cryptographic processing or secret data handling.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor computation kernel for machine learning operations, not an elliptic curve implementation. No cryptographic curve models are involved.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation and validation, not secure memory operations for cryptographic processing. No constant-time requirements are evident.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code validates integer sizes to prevent overflow when converting N_big to Index type and checking params->dim_size(0) against Index limits, similar to file position calculations needing appropriate integer types.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates tensor shapes and indices against boundaries (e.g., checking indices are within [0, params->dim_size(0))), analogous to archive parsers validating file positions against boundaries.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. While the code performs validation that could fail, there's no clear archive parsing state management. The error handling uses OP_REQUIRES which aborts execution on failure.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Archive parsing state must remain consistent during position calculation failures"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses RefCountPtr for resource management which provides automatic cleanup, but there's no explicit conditional cleanup based on initialization success shown in this snippet.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code performs tensor operations and validation, not cryptographic key object creation or algorithm support verification.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2016-7970_after_exclude_100:29e11f55:spec": {
    "timestamp": "2026-01-17T02:06:11.341156",
    "cve_id": "CVE-2016-7970",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "29e11f55",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor scatter operations, not cryptographic operations on secret values. There's no evidence of cryptographic processing or timing-sensitive secret data handling.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is performing tensor computation operations, not elliptic curve cryptography. No cryptographic operations or curve models are involved.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code handles tensor data manipulation, not cryptographic processing requiring constant-time memory operations. No secret data or cryptographic algorithms are present.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code performs integer size validations (N_big <= std::numeric_limits<Index>::max()) to prevent overflow when converting between integer types, which aligns with the principle of using appropriately sized integer types.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code validates tensor shape relationships and indices bounds, it's not parsing archive files or validating file positions against archive boundaries. The validation principles are similar but applied to tensor operations instead of archives.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code includes error checking with OP_REQUIRES that maintains consistent state when validation fails, but this is for tensor computation state rather than archive parsing state.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Archive parsing state must remain consistent during position calculation failures"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses OP_REQUIRES_OK to check resource lookup success before proceeding, and performs validation before operations. This follows the principle of conditional execution based on successful initialization, though not specifically for resource cleanup.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code doesn't involve cryptographic algorithms, key objects, or algorithm support verification. It's performing tensor scatter operations with validation of tensor shapes and indices.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2017-14151_before_exclude_100:5e95bef3:spec": {
    "timestamp": "2026-01-17T02:06:30.700072",
    "cve_id": "CVE-2017-14151",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5e95bef3",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via jas_alloc2 and uses the allocated memory (e.g., lutents) without explicit full initialization. While some fields may be initialized later in loops, the specification about initializing memory before use is highly relevant to prevent use of uninitialized values.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has extensive error handling using goto error; paths. It must ensure consistent object states (like setting pointers to NULL after destruction) when errors occur. The pattern of setting box=0 after jp2_box_destroy and the cleanup at the error label directly relates to this specification.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code reads structured box data which contains length fields. It should validate these lengths against integer limits to prevent overflow in allocations or loops. The relevance is moderate as the code uses jas_stream_t and box parsing functions where length validation likely occurs internally.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses jas_alloc2 for dynamic allocation. It should validate size parameters (dec->numchans * sizeof(uint_fast16_t)) against allocation limits and subsequent usage (e.g., array indexing). The direct memory allocation call makes this specification strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles multiple box types (JP2_BOX_IHDR, JP2_BOX_BPCC, etc.) and enforces consistency between them (e.g., IHDR numcmpts vs image components, BPCC box consistency, CMAP/PCLR interdependence). This directly matches the specification about enforcing consistent type handling across processing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It processes JPEG 2000 box structures, not regex patterns with embedded NUL bytes. The specification is essentially irrelevant to this code scenario.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is a JPEG 2000 decoder dealing with box-structured data. This specification has very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2019-13219_after_exclude_100:1197ce4e:spec": {
    "timestamp": "2026-01-17T02:07:00.102008",
    "cve_id": "CVE-2019-13219",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1197ce4e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via jas_alloc2 and uses the allocated memory (e.g., lutents) without explicit full initialization. While some fields may be written to later, the specification about initializing memory before use is highly relevant to prevent information leaks or undefined behavior.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code uses extensive error handling with goto error paths. It must ensure consistent object states (like setting pointers to NULL after destruction) when errors occur. The pattern of setting box=0 after jp2_box_destroy and the cleanup at the error label directly relates to this specification.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code decodes a JP2 stream from an input stream. It validates box types, magic numbers, and field consistency (e.g., numcmpts, bpc) before processing. This aligns with validating input before processing, though it's file format parsing rather than network protocol handling.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code checks various numeric fields from the input stream (e.g., numcmpts, channo, cmptno) against expected ranges and array bounds. This is similar to validating length/range fields, though not explicitly against integer overflow/limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses jas_alloc2 for dynamic allocation. It should validate size parameters to prevent overflow (e.g., dec->numchans * sizeof(uint_fast16_t)). The specification is highly relevant for safe memory allocation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code enforces consistency between different data representations (e.g., IHDR box vs. code stream components, BPCC box vs. component data types, CMAP/PCLR box dependencies). This directly matches the specification about consistent type handling across processing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It processes JP2 box structures, not regex patterns with NUL bytes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It's a JP2/JPEG2000 decoder, not a pattern compiler.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2019-25034_before_exclude_100:9adee18e:spec": {
    "timestamp": "2026-01-17T02:08:00.432101",
    "cve_id": "CVE-2019-25034",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9adee18e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses R_NEW0 which zero-initializes memory, satisfying HS-MEM-001. However, other allocations (like via r_bin_java_default_attr_new) are not shown, and the initialization of the attr structure depends on proper parsing of buffer data.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (e.g., NULL checks for attr, icattr, obj). However, when breaks occur due to invalid data or allocation failures, the function may return a partially initialized 'attr' object, potentially leaving it in an inconsistent state.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "HS-IO-003 is about network protocol handlers. This code parses a binary structure (Java class file attribute) from a buffer, not network input. The principle of input validation is relevant, but the context is different.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code validates the 'number_of_classes' field indirectly via a bounds check (offset + 8 > sz) for each class entry. It does not explicitly validate the initial length field against integer limits before starting the loop, which is the core of HS-INPUT-001.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-002 is highly relevant. The code performs a critical size validation: `if (offset + 8 > sz)`. This checks that the upcoming data usage (8 bytes) does not exceed the total buffer size ('sz'), preventing buffer over-read.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-003 about consistent type handling has weak relevance. The code reads specific numeric fields (USHORT) from a buffer and stores them in a structured object. It does not deal with type conversions or multiple processing stages in a way that highlights type inconsistency risks.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-001 regarding regular expression parsers and NUL bytes is completely irrelevant to this code, which parses binary Java class file attributes without using regular expressions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-002 about pattern compilers and escape sequences is completely irrelevant to this code, which performs binary parsing without any pattern compilation or escape sequence processing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2019-25034_after_exclude_100:7b2d032b:spec": {
    "timestamp": "2026-01-17T02:08:25.030187",
    "cve_id": "CVE-2019-25034",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7b2d032b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses R_NEW0 which zero-initializes memory, satisfying HS-MEM-001. However, there is a potential issue if the allocation fails (returns NULL) and the code proceeds without checking before initializing fields (though it breaks later). The initialization principle is directly applied.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error paths (e.g., buffer bounds checks, allocation failures). When breaking from the loop due to errors, it may leave the attr object in an inconsistent state (partially populated list, size set incorrectly). This relates to maintaining consistent object states on error paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code parses a binary structure (Java class file attribute), not network protocol data. While input validation is performed, the specification specifically mentions \"Network protocol handlers,\" which is not the context here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code validates length fields (number_of_classes derived from buffer) against available buffer size (sz) before and during processing. This directly matches the requirement to validate message length fields against limits, even though it's file parsing, not network protocol.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs size validation (buf_offset + offset + 8 > sz) before reading data and before allocating/processing entries. This checks both allocation limits (indirectly, as allocations are per-entry) and usage requirements (buffer reads), making it highly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles a specific Java class file attribute type. It ensures type consistency by checking buffer bounds and reading specific field types (USHORT). However, the specification emphasizes \"across all processing stages,\" which is only partially demonstrated in this isolated function.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It reads binary data with no pattern matching or NUL byte handling concerns.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It parses structured binary data with fixed fields.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2009-3909_before_exclude_100:83f167f4:spec": {
    "timestamp": "2026-01-17T02:08:29.421490",
    "cve_id": "CVE-2009-3909",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "83f167f4",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a TensorFlow Lite SVDF operator preparation function handling tensor dimensions, types, and memory allocation. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor validation and memory management for a neural network operation. It does not involve pattern compilers, escape sequence processing, or any string/pattern manipulation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the code processes tensor data (which could be considered input), it uses TensorFlow Lite's safe access functions (GetInputSafe, GetTemporarySafe) and validates tensor dimensions. However, it doesn't directly handle strings or use length-aware string operations, making the relevance very low.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code implements a neural network layer preparation routine, not cryptographic operations. There are no secret values being processed, and timing attacks are not a concern for this tensor manipulation code.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is for a TensorFlow Lite SVDF (Singular Value Decomposition Filter) operator, not elliptic curve cryptography. No cryptographic operations or side-channel resistance considerations are present.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor memory allocation and dimension validation. While it handles memory, it doesn't implement cryptographic processing or require constant-time memory operations for security purposes.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code manages tensor buffers and operator data structures in a machine learning framework. It doesn't involve view-based data access, privilege checks, or any security context management.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code prepares tensors for a neural network operation. It doesn't handle security-critical state transitions, privilege contexts, or any security state management.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2009-3909_after_exclude_100:1a12f78d:spec": {
    "timestamp": "2026-01-17T02:08:37.559214",
    "cve_id": "CVE-2009-3909",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1a12f78d",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a TensorFlow Lite SVDF operator preparation function. It handles tensor dimensions, allocations, and quantization parameters. There is no regular expression parsing involved, making this specification about embedded NUL bytes in patterns completely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns pattern compilers and escape sequence processing. The target code performs numerical tensor operations and memory management for a machine learning kernel. There is no pattern compilation or escape sequence handling.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification advises using length-aware operations for untrusted string input. While the code processes tensor data (which could be considered input), it does not use string processing functions. It accesses data via tensor dimensions and indices, which provides some bounds control, but the core principle of the spec is about string APIs, not numerical array indexing. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs preparatory calculations for a neural network layer, including computing effective quantization scales. This is not a cryptographic operation on secret values. The timing properties of these calculations are not security-critical in this context.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The specification is specific to elliptic curve cryptography implementations requiring side-channel resistance. The target code is for a TensorFlow Lite SVDF operator and contains no cryptographic operations or elliptic curve math.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "Similar to spec 4 and 5, this specification concerns maintaining constant-time properties during cryptographic processing. The code's memory operations (e.g., tensor resizing) are not related to cryptography or side-channel resistance for secrets.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The specification deals with database or system security, requiring privilege checks when accessing data through views. The target code is a low-level tensor manipulation function in a machine learning framework with no concept of users, views, or privilege checks.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The specification is about security-critical state transitions and privilege context consistency, likely in a system security or state machine context. The \"state\" variable in the code refers to a neural network's internal state tensor, not a security state. The concept of privilege is absent.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2022-24764_before_exclude_100:c1de04af:spec": {
    "timestamp": "2026-01-17T02:08:54.194575",
    "cve_id": "CVE-2022-24764",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c1de04af",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the length of the output buffer before writing the \"m=\" line, which is a form of length field validation. However, this validation is specific to the initial segment and does not comprehensively cover all protocol message length fields throughout the function, especially those handled by sub-functions like `print_connection_info`, `print_bandw`, and `print_attr`. The principle of validating against platform-specific integer limits is partially applied.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function performs buffer length checks (e.g., `if (len < ...)`) to prevent overflow, which relates to validating size parameters against usage requirements. However, it does not involve explicit memory allocation operations (like malloc), so the connection to allocation limits is weak. The check is a usage validation, not an allocation validation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code processes SDP media description fields (media type, port, transport, formats) and serializes them into a text buffer. It must handle these fields consistently (e.g., port count, attribute lists). However, the specification about \"consistent type handling across all processing stages\" is broad; the code shows serialization but not deep protocol parsing or type conversion stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It performs simple memory copies and string formatting. The specification about embedded NUL bytes in regex patterns is completely irrelevant to this context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It copies string data directly without interpretation of escape sequences. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code extensively uses length-aware operations: it tracks buffer length (`len`, `end-p`), uses `pj_memcpy` with explicit lengths (`slen`), and checks buffer bounds before writes. This is a direct application of using length-aware operations for potentially untrusted input to prevent buffer overflows.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform memory allocations. It writes into a pre-allocated buffer `buf`. The specification about initializing memory allocations before use is not relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has error handling paths (return -1) when buffer length checks fail or when sub-functions return errors. However, it does not manage complex object states; it mainly aborts serialization. The principle of maintaining consistent states on error is partially relevant, as the buffer content might be partially written, but no larger object state is discussed.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-24764_after_exclude_100:e5468368:spec": {
    "timestamp": "2026-01-17T02:09:44.118907",
    "cve_id": "CVE-2022-24764",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e5468368",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates buffer length before writing (e.g., `if (len < (pj_size_t)m->desc.media.slen+...`). This is a form of length validation to prevent buffer overflow, which aligns with the core principle of HS-INPUT-001 (validating length fields). However, the specification specifically mentions \"protocol message length fields,\" while this code validates internal buffer sizes against calculated string lengths. The relevance is strong but not a direct match.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer length checks but does not involve dynamic memory allocation (e.g., `malloc`, `calloc`). The principle of validating size parameters before use is present (checking `len` and `end-p`), which is related to safe memory usage. However, HS-MEM-002 is specifically about memory *allocation* operations, making the connection weak.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2019-15166_before_exclude_100:0b19ef00:spec": {
    "timestamp": "2026-01-17T02:10:29.241800",
    "cve_id": "CVE-2019-15166",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0b19ef00",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the capability length field (cap.length) before using it to calculate the next pointer position (pnt += cap.length + 3). This directly aligns with HS-INPUT-001's requirement to validate field lengths before accessing corresponding data. The check \"if (pnt + (cap.length + 3) > end)\" is a critical validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 8,
        "reasoning": "The code performs strict validation for the MP (Multiprotocol) capability type (CAPABILITY_CODE_MP), checking the validity of AFI and SAFI values. However, for other capability codes, it only logs a warning and ignores them, which may not constitute \"strict structure validation\" for all types as implied by the specification. The validation for the recognized type is strong.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains strict bounds checking throughout the parsing loop. It validates the initial minimum length, the capability-specific length against the packet end pointer ('end'), and ensures the loop advances without exceeding bounds. This is a core practice of the specification.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 5,
        "reasoning": "The code validates length fields against the actual received message boundary ('end'), which is a fundamental RFC constraint. However, the specification emphasizes \"RFC-specified length constraints,\" which could also include minimum/maximum values for specific fields (e.g., cap.length). The code checks boundary overflow but not necessarily explicit RFC value ranges.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code implements TLV (Type-Length-Value) style parsing for BGP capabilities. It performs complete bounds checking (\"if (pnt + (cap.length + 3) > end)\") before accessing the capability-specific data (the Value part), which is the essence of this specification.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "This is a direct restatement of Specification 1. The code validates the 'cap.length' field before using it to calculate offsets and access subsequent data, making it highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 5,
        "reasoning": "The code enforces strict message boundary validation by continuously comparing the current pointer ('pnt') against the calculated end of the message ('end'). This prevents parsing from exceeding the allocated buffer, which is the core of this specification.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains a clear separation: 'pnt' marks the current parsing position within the validated region, and 'end' marks the absolute boundary of the unvalidated data. The loop condition and length checks enforce this separation. The use of 'memcpy' on a potentially unvalidated length (cap.length) for the structure copy is a minor concern, but the length is validated immediately after.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2017-13053_after_exclude_100:f2bb1a2e:spec": {
    "timestamp": "2026-01-17T02:10:34.272514",
    "cve_id": "CVE-2017-13053",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f2bb1a2e",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the capability length field (hdr->length) before using it to calculate pointer offsets (pnt + hdr->length + 3) and before performing memcpy. This directly aligns with the specification's requirement to validate field lengths before accessing corresponding data.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 7,
        "reasoning": "The code validates the capability code and performs specific processing for CAPABILITY_CODE_MP. However, for other capability types, it only logs a warning and ignores them, rather than performing strict structure validation (e.g., checking if the capability length matches the expected structure size for its type). This is a partial implementation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 9,
        "reasoning": "The code maintains strict bounds checking throughout the parsing loop. It checks (pnt + 3 > end) for the header, and later (pnt + hdr->length + 3 > end) for the capability data, ensuring pointers stay within the bounds of the input buffer.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 6,
        "reasoning": "The code validates length fields against the remaining buffer (end), which is a general bounds check. However, the specification emphasizes \"RFC-specified length constraints.\" The code does not appear to check if hdr->length matches the expected size for the specific capability type (e.g., CAPABILITY_CODE_MP should have a specific struct size), which is an RFC-level constraint.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code implements TLV (Type-Length-Value) style parsing for BGP capabilities. It performs complete bounds checking (verifying pnt + length + 3 does not exceed end) before accessing the value field via memcpy, perfectly aligning with this specification.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 9,
        "reasoning": "This is a restatement of Specification 1. The code validates the length field (hdr->length) before using it for pointer arithmetic and data access (memcpy), making it highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 8,
        "reasoning": "The code validates the message boundary (end) at each step of the loop, ensuring the parser does not read beyond the declared length of the capability message. It checks both the initial header and the full capability length against 'end'. This is strong relevance, though the specification is slightly broader.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains a clear separation: 'pnt' iterates through the unvalidated input buffer, and data is only copied into a local structure (mpc) after length validation. The validated data (afi, safi) is then used for further operations. The loop advance (pnt += hdr->length + 3) is also based on validated lengths.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2017-12904_before_exclude_100:bc56ca7a:spec": {
    "timestamp": "2026-01-17T02:10:55.508608",
    "cve_id": "CVE-2017-12904",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bc56ca7a",
    "scores": [
      {
        "score": 1,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code does not handle any network protocols or parse message length fields. It constructs a command line string for bookmarking.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns validating memory allocation size parameters. The target code does not perform any explicit memory allocation operations (like malloc, new, or container resizes) that would require such validation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing consistent type handling in protocol implementations. The target code is not a protocol implementation; it is a utility function for executing a bookmark command.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires memory allocations to be initialized before use. The target code does not contain any raw memory allocations that would need explicit initialization. The std::string objects are properly initialized.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The specification states error handling paths must maintain consistent object states. The code has a potential error path if the `bookmark_cmd` is empty, returning an error message. The main object state (the controller and its view `v`) appears consistent, but the function pushes/poops a formaction which could be impacted if `run_interactively` or `run_program` throws. However, this is not the core focus of the code, and the specification's broader context (like protocol state machines) doesn't apply. Weak connection.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification is for network protocol handlers to validate input before processing. This code does not handle network protocols; it processes function parameters to build a shell command.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification requires character encoding validation enforcing domain-specific size constraints. The code uses user-provided strings (url, title, description, feed_title) to construct a shell command. It performs a critical security-relevant encoding operation by replacing single quotes (`'`) in the URL with `%27` to prevent shell injection. However, it does not validate or constrain the overall length of the resulting `cmdline` string, which could exceed shell/argument limits, nor does it handle other shell metacharacters or encoding issues in the other parameters (title, description, feed_title) beyond quoting them with `stfl::quote`. This is a direct and relevant security concern for the code's functionality.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification requires pre-access validation of computed indices for array/buffer operations. The target code uses a fixed-size array `my_argv[4]` with direct, constant index assignments (0, 1, 2, 3). There are no computed indices or buffer overflow risks from indices in this snippet.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2017-12904_after_exclude_100:0aaded85:spec": {
    "timestamp": "2026-01-17T02:11:00.364208",
    "cve_id": "CVE-2017-12904",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0aaded85",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about validating protocol message length fields against integer limits. The target code constructs a shell command string with user-controlled input but does not involve parsing or validating protocol messages with length fields. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The specification concerns validating memory allocation size parameters. The target code does not perform explicit memory allocation operations (like malloc, new). It uses std::string which manages memory internally, but the code does not validate size parameters for these internal allocations against user input length. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about enforcing consistent type handling in protocol implementations. The target code is not a protocol implementation; it's a utility function for executing a bookmark command. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires memory allocations to be initialized before use. The target code uses std::string and a char* array for exec arguments, but there's no explicit uninitialized memory allocation that is later used. The char* array pointers are set before use. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The specification states error handling paths must maintain consistent object states. The target code has potential error paths (e.g., if run_interactively or run_program fails), but it's unclear how object state (like the view 'v') is maintained. The push/pop operations on 'v' might leave state inconsistent if an exception occurs between them. This provides weak relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification is about network protocol handlers validating input before processing. The target code receives input strings (url, title, etc.) but not from a network protocol. It does perform some input sanitization (replacing single quotes) but not for network protocol purposes. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification involves character encoding validation and enforcing domain-specific size constraints. The target code performs input sanitization by replacing single quotes with %27 to prevent shell injection, which is a form of character encoding/escaping for the shell command domain. However, it doesn't validate size constraints (e.g., total command line length limits). This shows moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification requires pre-access validation of computed indices for array/buffer operations. The target code uses a fixed-size char* array (my_argv[4]) with direct index assignments (0,1,2,3). There are no computed indices or buffer accesses that require validation. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2016-3179_before_exclude_100:91b6f52b:spec": {
    "timestamp": "2026-01-17T02:12:21.531587",
    "cve_id": "CVE-2016-3179",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "91b6f52b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process protocol messages with explicit length fields. It handles function arguments (`len` and `a`), but these are internal counts and values, not untrusted protocol data. The validation of `len` is indirect via `mrb_stack_extend`, which is more about internal resource management than protocol validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code calls `mrb_stack_extend(mrb, len+2)`, which is a critical memory allocation/extension operation. The `len` parameter should be validated to prevent excessive stack allocation. While the specification's principle applies, the code shows the allocation call but not the validation logic itself, which would be inside `mrb_stack_extend`.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code implements a fiber switching mechanism within a language runtime (MRI Ruby). It manages internal state (status enums, contexts) but does not implement a communication protocol with type serialization/deserialization that requires consistent type handling.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No relevance. The code does not contain any regular expression parsing or processing logic. It is focused on context switching and stack management for fibers.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No relevance. The code does not contain a pattern compiler or process escape sequences. It is focused on runtime execution control flow.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code copies an array of `mrb_value` arguments using a loop (`while (b<e) { *b++ = *a++; }`). This is a length-aware operation based on the `len` parameter. However, the values (`mrb_value`) are complex internal objects, not raw strings, and the primary concern is not C string handling vulnerabilities like buffer overflows from untrusted data.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs stack extension and then writes to the newly allocated/available stack slots (`b` to `e` and `c->stbase[0]`). It does not show explicit initialization of all allocated memory (e.g., the slots between `e` and the new stack top). Uninitialized stack memory could lead to information disclosure or instability if accessed. The principle of initializing allocations is relevant, though the code snippet does not show it being fully followed.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function's core responsibility is managing the state of fiber contexts (`c` and `old_c`). It validates the fiber's `status` and raises errors for invalid state transitions (e.g., \"double resume\", \"resuming dead fiber\"). It also updates the `status` and `prev` pointers of contexts during the switch. Maintaining consistent object (context) states, especially in error paths (though early errors raise exceptions and likely exit), is central to this code's correctness and security to prevent use-after-free, double resumes, or other state corruption.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-0890_after_exclude_100:8a37a6ed:spec": {
    "timestamp": "2026-01-17T02:12:30.911104",
    "cve_id": "CVE-2022-0890",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8a37a6ed",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process protocol messages with explicit length fields. It handles a `len` parameter representing argument count for a fiber switch, but this is not a network protocol message length. Some basic validation exists (checking if len >= 15), but it's not about platform integer limits like SIZE_MAX.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs stack extension via `mrb_stack_extend(mrb, len+2)` based on the `len` parameter. While there is some validation (the branch for len >= 15), it does not explicitly validate `len` against allocation limits or subsequent usage requirements (e.g., ensuring `len+2` doesn't overflow or exceed stack bounds). The allocation is managed internally by the runtime.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code implements fiber context switching within a runtime, not a network protocol. There is no processing of protocol messages with types that need consistent handling across stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "No relevance. The code does not involve regular expression parsing or input patterns with embedded NUL bytes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "No relevance. The code does not involve pattern compilers or escape sequence processing.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code copies argument values (`*b++ = *a++`) but these are mrb_value objects, not raw strings. There is no direct string processing of untrusted input using length-aware operations here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code initializes stack slots during argument copying (`*b++ = *a++`) and sets `c->stbase[0]` and `c->cibase->n`. However, it does not show explicit initialization of all allocated memory (e.g., the extended stack region might have uninitialized portions). The context switch logic relies on proper initialization of context fields.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function performs complex state transitions for fibers (status checks, setting `old_c->status`, `c->prev`, etc.). Error handling paths (like `mrb_raise` for double resume, dead fiber) must ensure object/fiber states remain consistent before raising exceptions. The code shows careful status checks before modifying context states.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-32978_before_exclude_100:cf193faf:spec": {
    "timestamp": "2026-01-17T02:13:09.273488",
    "cve_id": "CVE-2022-32978",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cf193faf",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation calls. Memory for line data (line->m_pData) is likely allocated elsewhere. While the code writes to this memory (*lp = rx << preshift), it doesn't show the allocation or initialization. The relevance is weak because the specification focuses on initialization of allocated memory, which is not visible in this parsing function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code contains multiple comments about missing error handling: \"No error handling strategy. No RST in scans. Bummer!\" and \"No error handling here.\" The function returns a hardcoded 'false' regardless of success/failure, indicating inconsistent state management. Error handling paths are clearly inadequate, directly violating the specification's principle.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is an image compression/decompression function (JPEG-LS), not a network protocol handler. While it processes input data from a stream (m_Stream.ByteStreamOf()), it's not network protocol input validation. The specification specifically targets network protocols.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code performs JPEG-LS image decoding, not regular expression parsing. There are no regex operations or pattern matching with NUL byte considerations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is for image compression/decompression, not pattern compilation. There are no escape sequence processing or pattern compiler operations in this JPEG-LS decoder function.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code processes input data through a stream, it uses length-aware operations (checking 'length' variable in loops). However, it's not specifically string processing, and the input validation appears minimal. The connection to \"untrusted input\" handling for strings is weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code writes to buffer locations (*lp = rx << preshift) within loops controlled by 'length' and 'lines' variables. While buffer bounds checking isn't explicitly shown, the code structure suggests length-controlled writes. However, the specification's focus on allocation with padding requirements isn't directly visible in this parsing function.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. This is directly an image compression operation (JPEG-LS decoder). The code processes image data through buffers (line->m_pData) and performs compression-related operations (Golomb decoding, error mapping, reconstruction). Strict bounds checking is critical for encoder/decoder buffers to prevent overflows, though explicit bounds checks aren't prominently visible in this snippet.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2017-12982_after_exclude_100:da4e78ec:spec": {
    "timestamp": "2026-01-17T02:13:29.443457",
    "cve_id": "CVE-2017-12982",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "da4e78ec",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses pointers and memory operations (e.g., `*lp++ = a << preshift`), but there is no explicit memory allocation visible in this function. The initialization of memory before use is implied through the loop that writes to `lp`, but the core principle of initializing allocated memory is not directly demonstrated or violated here. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code contains a comment \"No error handling strategy. No RST in scans. Bummer!\" and another \"No error handling here.\" This directly indicates a lack of error handling paths, which could lead to inconsistent object states if errors occur during the decoding process. The specification is highly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This function parses image data (JPEG-LS) from a byte stream, not a network protocol. While input validation is a general secure coding principle, the specification is specifically about network protocol handlers. The connection is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. The specification is about handling NUL bytes in regex patterns, which is completely unrelated to this image decoding function.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It is a JPEG-LS decoding routine. The specification is irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function processes data from a stream (`m_Stream.ByteStreamOf()`) and writes to a buffer pointed to by `lp`. While it uses a `length` variable to control the loop, it does not show explicit length-aware operations for untrusted input (like `strncpy`). The principle of bounds checking is relevant but not explicitly demonstrated. Relevance is weak to moderate.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The function operates on pre-allocated buffers (e.g., `line->m_pData`). The safety of these operations depends on correct buffer sizes being allocated elsewhere. The code does not show the allocation, but the specification's principle of accounting for padding and safety margins is moderately relevant to the overall image decoding context to prevent buffer overflows.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "This function is explicitly an image compression (specifically, lossless JPEG-LS) decoding operation. It reads from a stream and writes to line buffers. The loop is controlled by `length` and `lines`, but there is no explicit bounds checking shown to ensure that writes to `*lp` stay within the allocated `line->m_pData` buffer. The specification about enforcing strict bounds checking for encoder/decoder buffers is directly and highly applicable.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2016-8860_before_exclude_100:744d7366:spec": {
    "timestamp": "2026-01-17T02:13:33.509267",
    "cve_id": "CVE-2016-8860",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "744d7366",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It is an iterator function for arrays, strings, and objects. The specification about handling embedded NUL bytes in regex patterns is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It iterates over data structures (arrays, strings, objects) and calls a handler function. The specification's focus on pattern compilers is irrelevant here.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code demonstrates length-aware string processing. It uses `njs_string_prop` to get string properties (size, length) and iterates using pointers (`p`, `end`) with bounds checks (e.g., `njs_utf8_next`, `njs_utf8_prev`). This aligns with the principle of using length-aware operations for safe iteration, though the input's trust level isn't specified.</spec_1_reasoning>\n<spec_4_score>3</spec_4_score>\n<spec_4_reasoning>The code does not parse protocol messages or validate length fields from an external source. It operates on internal JavaScript-like values (arrays, strings) and uses loop indices (`from`, `to`) which are derived from function arguments, but there is no explicit validation shown against platform integer limits.</spec_2_reasoning>\n<spec_5_score>5</spec_5_score>\n<spec_5_reasoning>The code has one memory allocation point (`njs_object_value_alloc`), but it does not show explicit validation of the size parameter against allocation limits. The check for a NULL return is present, which is a basic safety measure. The relevance is weak because the allocation's size is not directly manipulated by user input in the shown code path, and the specification's full scope (validating size against usage requirements) is not clearly demonstrated.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code does not parse protocol messages or validate length fields from an external source. It operates on internal JavaScript-like values (arrays, strings) and uses loop indices (`from`, `to`) which are derived from function arguments, but there is no explicit validation shown against platform integer limits.</spec_2_reasoning>\n<spec_5_score>5</spec_5_score>\n<spec_5_reasoning>The code has one memory allocation point (`njs_object_value_alloc`), but it does not show explicit validation of the size parameter against allocation limits. The check for a NULL return is present, which is a basic safety measure. The relevance is weak because the allocation's size is not directly manipulated by user input in the shown code path, and the specification's full scope (validating size against usage requirements) is not clearly demonstrated.</spec_3_reasoning>\n<spec_6_score>7</spec_6_reasoning>\n<spec_6_reasoning>The function's core logic is type handling. It dispatches behavior based on the type of `value` (array, string, object string, generic object) and maintains consistency in how it iterates and calls the handler for each type. This aligns with the principle of enforcing consistent type handling, though it's for an internal iterator rather than a network protocol.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code has one memory allocation point (`njs_object_value_alloc`), but it does not show explicit validation of the size parameter against allocation limits. The check for a NULL return is present, which is a basic safety measure. The relevance is weak because the allocation's size is not directly manipulated by user input in the shown code path, and the specification's full scope (validating size against usage requirements) is not clearly demonstrated.</spec_3_reasoning>\n<spec_6_score>7</spec_6_reasoning>\n<spec_6_reasoning>The function's core logic is type handling. It dispatches behavior based on the type of `value` (array, string, object string, generic object) and maintains consistency in how it iterates and calls the handler for each type. This aligns with the principle of enforcing consistent type handling, though it's for an internal iterator rather than a network protocol.</spec_4_reasoning>\n<spec_7_score>3</spec_7_score>\n<spec_7_reasoning>The code does not process protocol messages or enforce RFC-specified constraints. It handles internal data structure iteration. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The function's core logic is type handling. It dispatches behavior based on the type of `value` (array, string, object string, generic object) and maintains consistency in how it iterates and calls the handler for each type. This aligns with the principle of enforcing consistent type handling, though it's for an internal iterator rather than a network protocol.</spec_4_reasoning>\n<spec_7_score>3</spec_7_score>\n<spec_7_reasoning>The code does not process protocol messages or enforce RFC-specified constraints. It handles internal data structure iteration. The specification is not applicable.</spec_5_reasoning>\n<spec_8_score>3</spec_8_score>\n<spec_8_reasoning>The code does not process TLV (Type-Length-Value) encoded data. It iterates over arrays and strings using indices and pointers with internal bounds checks, but this is not TLV processing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2016-8860_after_exclude_100:34d7b269:spec": {
    "timestamp": "2026-01-17T02:14:15.054586",
    "cve_id": "CVE-2016-8860",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "34d7b269",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code is an iterator function for arrays, strings, and objects, with no regular expression processing. The connection is very weak, though both involve string/input processing at a high level.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences; it iterates over data structures. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code processes strings with explicit length checks (e.g., `string_prop.start + string_prop.size`, `njs_string_offset`). It handles both byte/ASCII and UTF-8 strings using length-aware operations, which aligns with the specification's principle for safe string processing, especially with potentially untrusted iteration inputs.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2021-46668_before_exclude_100:dea4995c:spec": {
    "timestamp": "2026-01-17T02:14:20.055344",
    "cve_id": "CVE-2021-46668",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dea4995c",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It is a database table drop function that calls file deletion routines. No pattern input with embedded NUL bytes is processed.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It deals with file deletion for database tables, not protocol or pattern parsing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function takes a string input `name` which could be untrusted (table name). While the code itself doesn't show string processing, the called function `maria_delete_table_files` might process this name. However, no length-aware operations are visible in the provided snippet.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process protocol messages or length fields. It is a local file system operation for dropping a database table.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While no explicit memory allocation is shown, the function calls `ha_close()` and `maria_delete_table_files` which may involve resource cleanup. Memory allocation validation could be relevant in those deeper implementations, but not directly in this snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a network protocol or involve type handling across processing stages. It performs local file deletion operations.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. No memory allocation is visible in this snippet. However, proper initialization of any allocated memory in called functions (`ha_close`, `maria_delete_table_files`) is generally important for security, but not directly applicable here.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function performs destructive operations (table file deletion) and calls `ha_close()`. Error handling is critical here: if `ha_close()` fails but execution continues to `maria_delete_table_files`, or if the deletion fails after closing the handle, the object/table state could become inconsistent. The code shows `(void)` casts ignoring return values, which may indicate insufficient error handling that could violate state consistency.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-46668_after_exclude_100:d67371db:spec": {
    "timestamp": "2026-01-17T02:14:38.049058",
    "cve_id": "CVE-2021-46668",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d67371db",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve regular expression parsing. It is a database table deletion function dealing with file operations, not pattern matching with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It is a straightforward file deletion routine for database tables.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function takes a string input `name` which could potentially be untrusted (e.g., from user input). While the code itself doesn't show string processing, the called function `maria_delete_table_files` might need to handle the `name` parameter safely. However, no length-aware operations are visible in the provided snippet.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol messages or validate length fields. It performs file deletion operations on a database table.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not contain explicit memory allocation operations. The function's primary purpose is file deletion, though memory allocation might occur internally in called functions, but it's not visible here.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "The code does not implement a network protocol or handle protocol messages. It is a database storage engine method for dropping tables.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. No memory allocation is visible in this code snippet. The function focuses on closing a file handle and deleting table files.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function performs multiple operations (ha_close and maria_delete_table_files) that could fail. Error handling paths must ensure consistent object states (like the `file` handle state) even when operations fail. The DBUG_ASSERT also suggests state assumptions about the table being temporary.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2014-9512_before_exclude_100:5ab17dd3:spec": {
    "timestamp": "2026-01-17T02:14:58.456835",
    "cve_id": "CVE-2014-9512",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5ab17dd3",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not handle any protocol message length fields. It deals with file operations and user dialogs for file extraction/overwriting. The specification is about validating integer limits in network protocols, which is not relevant here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory operations (g_free, _g_string_list_free) but does not show explicit memory allocation with size parameters that need validation. The primary operations are file I/O and GUI dialog management. The connection to validating allocation size parameters is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement any network or data protocol. It uses GLib/GIO APIs for file operations and GTK for UI. The specification about enforcing consistent type handling across protocol stages is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It performs file path manipulation and extraction operations. This specification is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain pattern compilers or process escape sequences. It handles file overwrite dialogs and extraction logic. This specification is completely irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes file paths (odata->current_file->data) which could be considered untrusted input from archives. The function _g_path_get_relative_basename likely processes strings, but it's unclear if it uses length-aware operations. There is weak relevance as string handling occurs but not explicitly shown as security-critical.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code accesses data structures (odata, odata->current_file, etc.) but does not show explicit buffer operations like array indexing. There is potential for null pointer dereference if odata->current_file is NULL when accessed, but this is checked. Weak relevance as general memory safety principles apply but not specific buffer bounds validation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain a parser that needs structural constraint validation. It processes file extraction requests and user dialog responses. The connection to parser input validation is very low.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2013-4668_after_exclude_100:1286b270:spec": {
    "timestamp": "2026-01-17T02:15:11.018851",
    "cve_id": "CVE-2013-4668",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1286b270",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not process any protocol messages or their length fields. It is a GUI dialog function for handling file overwrite confirmation during extraction.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses memory allocation indirectly (e.g., `g_free`), but does not contain explicit memory allocation operations with size parameters that need validation against limits. The primary logic is file system interaction and UI flow.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement any network or data protocol. It handles local file operations and GUI events.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "The code does not use regular expression parsers. It processes file paths and user interface actions.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain pattern compilers or process escape sequences. It is focused on file extraction logic.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "There is weak relevance. The function processes file paths (`odata->current_file->data`) which could be considered input. While it uses GLib functions that are generally safe, the principle of using length-aware operations for untrusted input is a good practice for any path handling, though not directly demonstrated here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "There is weak relevance. The code accesses data structures (e.g., `odata->current_file->data`) and performs string operations via `_g_path_get_relative_basename_safe`. The safe version of the function suggests some bounds-checking awareness, but the core buffer access logic is not visible in this snippet.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 4,
        "reasoning": "There is weak relevance. The code validates state (e.g., `odata->edata->overwrite == FR_OVERWRITE_ASK`, `odata->current_file != NULL`) before proceeding with operations, which aligns with the general principle of enforcing constraints before processing. However, this is not about parsing complex input structures.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2014-0196_after_exclude_100:e642d750:spec": {
    "timestamp": "2026-01-17T02:17:48.747249",
    "cve_id": "CVE-2014-0196",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e642d750",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation calls. It operates on pre-allocated buffers (e.g., `runtime->oss.buffer`). While it writes silence data into these buffers using `snd_pcm_format_set_silence`, this is initialization of existing memory for a specific purpose, not the initialization of a newly allocated memory region to prevent information leaks or undefined behavior as typically covered by HS-MEM-001. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code has multiple error handling paths (e.g., after `mutex_lock_interruptible`, `snd_pcm_oss_make_ready_locked`, `snd_pcm_oss_sync1`). It uses `goto` statements to a common `unlock` label to release locks (`mutex_unlock`) and decrement reference counts (`atomic_dec`) before returning an error. This ensures the `params_lock` mutex and `rw_ref` atomic counter are left in a consistent state even on failure, which is the core principle of HS-STATE-002.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is a kernel-level OSS (Open Sound System) PCM audio synchronization function. It handles audio data buffers and hardware control via ioctls. There is no network protocol handling involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not process any protocol messages with length fields. It performs calculations on internal audio buffer sizes (like `period_bytes`, `buffer_used`), but these are not parsed from untrusted input streams in the context of a network protocol.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform any memory allocation operations (e.g., `kmalloc`, `vmalloc`). Size calculations are performed for audio sample manipulation (e.g., `size = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width`), but these are not passed to an allocator. The checks are for algorithmic correctness within a known buffer bounds, not for guarding against allocation limits.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is not implementing a communication protocol. It manages audio data formatting and device synchronization. While it handles different data access types (`SNDRV_PCM_ACCESS_RW_INTERLEAVED` vs `NONINTERLEAVED`), this is not about protocol type consistency across stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not contain any regular expression parsing logic.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not contain any pattern compiler or logic for processing escape sequences.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2014-0196_before_exclude_100:9d8a28f6:spec": {
    "timestamp": "2026-01-17T02:17:50.759520",
    "cve_id": "CVE-2014-0196",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d8a28f6",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code uses runtime->oss.buffer and performs operations based on buffer_used and period_ptr. While there is no explicit memory allocation in this function, the function snd_pcm_format_set_silence writes to a pre-allocated buffer. The relevance is moderate because the specification about memory initialization before use is a general good practice, but the code does not show the allocation point, only the usage. The silent-filling operation itself is a form of initialization.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error handling paths (e.g., after snd_pcm_oss_make_ready, mutex_lock_interruptible, snd_pcm_oss_sync1). It uses goto statements (unlock, __direct) and carefully releases acquired locks (params_lock) and decrements reference counts (rw_ref) before returning errors. This demonstrates a focus on maintaining consistent object states (like lock state, refcount, buffer_used, prepare flag) across both success and error paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is an audio OSS (Open Sound System) emulation layer function for synchronizing and draining PCM audio streams. It deals with kernel internal data structures and audio buffers, not network protocols or network input.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is about validating protocol message length fields. This code performs audio buffer manipulation and synchronization calculations (size based on period_bytes, buffer_used, width). It does not parse or handle any external protocol messages with length fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The function calculates a 'size' variable used for silent buffer filling. The calculation involves arithmetic operations (multiplication, division) on unsigned values derived from internal state (period_bytes, buffer_used, width). While there is a potential for integer overflow or miscalculation leading to incorrect buffer access, the code does not perform any explicit memory allocation based on this 'size'. The primary risk is a buffer overflow in snd_pcm_format_set_silence if size is miscalculated, which relates more to bounds checking than allocation limits.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification concerns protocol type handling. This code handles audio sample format (snd_pcm_format_t) and access mode (SNDRV_PCM_ACCESS_*), ensuring correct functions (snd_pcm_lib_write/writev) are called. While this shows type-aware processing, it is for audio data, not a communication protocol.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is specifically about regular expression parsers handling NUL bytes. This code does not involve regular expressions or pattern parsing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is about pattern compilers and escape sequences. This code is an audio synchronization routine and does not compile or process any patterns or escape sequences.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-29212_before_exclude_100:bb4ed060:spec": {
    "timestamp": "2026-01-17T02:18:23.024624",
    "cve_id": "CVE-2022-29212",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bb4ed060",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code performs quantized tensor comparison operations for machine learning inference. While it involves arithmetic operations, it does not handle cryptographic secrets or keys. The operations are data-dependent (scaling, shifting based on tensor parameters) but are not security-critical in a cryptographic sense. Timing side-channels here would not expose secret keys.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It is purely a numerical comparison function for quantized tensors in a machine learning framework.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory operations via GetTensorData calls, but these are not security-critical cryptographic memory operations. The function deals with tensor data comparison, not cryptographic key material or sensitive data that requires constant-time memory access patterns.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code performs numerical computations on tensor data without any view-based data access, privilege checks, or database/view security semantics. It's a pure computation function.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "No security-critical state transitions or privilege context management is present in this tensor comparison code. It's a stateless computational function.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to SQL protocols, database access, or view security semantics. It's a numerical computation function for tensor operations.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or pattern matching. It performs arithmetic operations on quantized tensor data.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilation, escape sequence processing, or any text/pattern parsing. It's a numerical comparison function for quantized data.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-29212_after_exclude_100:1dd64377:spec": {
    "timestamp": "2026-01-17T02:18:38.606994",
    "cve_id": "CVE-2022-29212",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1dd64377",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code performs quantized tensor comparison operations for machine learning inference. While it involves arithmetic operations, it does not handle cryptographic operations on secret values. The values being processed are model inputs/parameters, not cryptographic secrets requiring constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It's performing tensor comparison operations in a machine learning context, not cryptographic operations.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory operations for tensor data access but not in a cryptographic context. While memory operations exist, they are not security-critical cryptographic memory operations that require constant-time properties to protect secrets.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor data comparison operations without any view-based data access, privilege checks, or database/view security semantics. It's purely numerical computation on tensor data structures.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The code has no security-critical state transitions or privilege context management. It's a pure computation function that processes tensor data without any security state or privilege considerations.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to SQL protocols, database access, or view security semantics. It's performing numerical tensor operations in a machine learning inference context.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or pattern matching. It's performing arithmetic comparison operations on quantized tensor data, not processing text patterns or regular expressions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilation, escape sequence processing, or any text pattern manipulation. It's performing numerical operations on tensor data structures for machine learning inference.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2016-5844_before_exclude_100:8cca0078:spec": {
    "timestamp": "2026-01-17T02:19:29.570425",
    "cve_id": "CVE-2016-5844",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8cca0078",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code performs data processing for machine learning (initializing examples, weights, features) and contains no cryptographic operations on secret values. The specification about constant-time cryptographic execution is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or any cryptographic operations. This specification is completely irrelevant to the target code's functionality.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 3,
        "reasoning": "The code manages state transitions for example initialization but doesn't involve security-critical privilege context management. It's focused on data structure setup rather than security state transitions.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code has no SQL protocol implementations or database access. This specification about SQL protocol security is completely irrelevant to the machine learning data processing code.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 2,
        "reasoning": "The code performs error handling through TF_RETURN_IF_ERROR but doesn't involve privilege separation or process termination. Error handling returns status codes rather than enforcing process termination.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 3,
        "reasoning": "The code performs state initialization with validation checks, but these aren't security-critical state transitions requiring atomic verification. The validation ensures data consistency rather than security state integrity.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2016-5844_after_exclude_100:a34d0faa:spec": {
    "timestamp": "2026-01-17T02:19:35.355696",
    "cve_id": "CVE-2016-5844",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a34d0faa",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs data processing for machine learning (initializing examples, weights, labels, sparse/dense features). It contains no cryptographic operations on secret values. The specification about constant-time cryptographic execution is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is part of a TensorFlow kernel for handling training data. It does not implement any elliptic curve cryptography or cryptographic primitives. The specification is irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code involves memory allocation and data structure initialization but not for cryptographic processing. Operations like `resize()` on vectors are not security-critical memory operations requiring constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code processes input tensors in a computational graph. There is no concept of database views, view owners, or privilege checks based on ownership. This is a data processing function, not a data access control mechanism.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The function manages example data for model training. It does not handle security-critical state transitions (like authentication states or privilege levels) or maintain any privilege context.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code is unrelated to SQL protocols or database access. It handles TensorFlow op inputs (sparse indices, dense features) for machine learning. The specification does not apply.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 1,
        "reasoning": "There is no privilege separation mechanism in this code (no multiple privileges, no security boundaries). The function validates input sizes and returns error statuses but does not enforce process termination.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 1,
        "reasoning": "The code performs sequential initialization and validation of data structures. While it validates inputs, these are not security-critical state transitions requiring atomic verification (like cryptographic key changes or privilege escalations).",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2018-1000222_before_exclude_100:db5432e6:spec": {
    "timestamp": "2026-01-17T02:20:00.048110",
    "cve_id": "CVE-2018-1000222",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "db5432e6",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification HS-MEM-001 is about initializing memory allocations before use. The target code performs pixel operations on an existing image structure but does not involve dynamic memory allocation or initialization of new memory blocks. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "HS-STATE-002 concerns error handling and consistent object states. The function has minimal error handling (returns early if border < 0 or leftLimit == -1) but does not significantly manage complex object states or error paths. The connection is weak to moderate.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "HS-LOGIC-001 requires file format parsers to validate numeric fields. While this is not a parser, it processes image coordinates and color/border values. It lacks validation for input parameters (x, y, border, color) against image bounds or valid color ranges, which is a related concern. Relevance is moderate.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-002 states image decoders must implement bounded iteration. This function is an image processor (flood fill) that uses recursion and loops over pixel ranges. It relies on `im->sx` and `im->sy` for bounds but does not protect against deep recursion stack overflow (e.g., filling large areas). The principle of bounded/controlled iteration directly applies. Relevance is strong.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 5,
        "reasoning": "HS-STATE-003 is for parser state machines validating intermediate states. This code implements a flood fill algorithm with some state (`lastBorder`), but it's not a state machine in the parsing context. The connection is weak.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Resource deallocation must use matching release functions for allocated types"
      },
      {
        "score": 5,
        "reasoning": "HS-STATE-002 (duplicate label) concerns resource lifecycle consistency between creation and destruction. The code does not create or destroy resources; it only modifies pixel data. Relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource lifecycle transitions must maintain consistency between creation and destruct..."
      }
    ]
  },
  "CVE-2018-1000222_after_exclude_100:e13340e2:spec": {
    "timestamp": "2026-01-17T02:20:03.967644",
    "cve_id": "CVE-2018-1000222",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e13340e2",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification HS-MEM-001 is about initializing memory allocations before use. The target code does not perform any dynamic memory allocation; it only manipulates pixel data within an existing image structure. The relevance is weak because the core principle of the specification (preventing use of uninitialized heap/stack memory) does not directly apply to the pixel setting/getting operations shown.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 4,
        "reasoning": "The specification HS-STATE-002 concerns maintaining consistent object states in error handling paths. The function has minimal error handling (a return for invalid border, and bounds clipping). While the state of the `gdImagePtr` object could become partially filled if the function returns early, this is not a primary focus of the code. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The specification HS-IO-003 is for network protocol handlers. The target code is an image processing function (flood fill) with no network interaction. The specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-LOGIC-001 is for file format parsers validating numeric fields. This is not a parser. However, the function does perform some input validation/range checking (clipping x, y to image bounds, checking border value). This weak connection provides minor guidance value on the importance of validating input parameters.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 8,
        "reasoning": "The specification HS-INPUT-002 is highly relevant. The function is an image decoder/processor component (flood fill). It implements a recursive algorithm. While it uses image bounds (`im->sx`, `im->sy`) to limit horizontal iteration, the recursion depth is not bounded and could lead to a stack overflow if filling a large, contiguous area. The specification's principle of \"bounded iteration\" directly applies to this potential vulnerability.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 4,
        "reasoning": "The specification HS-STATE-003 is for parser state machines validating intermediate states. This function is not a state machine parser. It is a procedural flood fill algorithm. The weak connection is that it checks pixel colors (a form of state) before deciding to recurse, but this is not the complex state validation the specification targets.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 1,
        "reasoning": "The specification HS-MEM-001 (duplicate label, appears to be about deallocation) mandates matching release functions. The target code does not allocate or deallocate any resources (memory, files, etc.). It only modifies pixel data. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Resource deallocation must use matching release functions for allocated types"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-STATE-002 (duplicate label, about resource lifecycle) concerns consistency between creation and destruction. The function does not create or destroy the main image resource; it operates on an already created `gdImagePtr`. The weak connection is that it must ensure the modifications (pixel color changes) leave the image in a valid state, but this is not the primary focus of the specification.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource lifecycle transitions must maintain consistency between creation and destruct..."
      }
    ]
  },
  "CVE-2012-4559_before_exclude_100:51b45140:spec": {
    "timestamp": "2026-01-17T02:20:20.354556",
    "cve_id": "CVE-2012-4559",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "51b45140",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves constructing and sending an SFTP protocol packet (SSH_FXP_MKDIR). While it doesn't directly parse incoming length fields, it calls functions like `sftp_packet_write`, `sftp_read_and_dispatch`, and `parse_status_msg` which are part of a larger protocol implementation. These underlying functions must validate message length fields from the network against integer limits to prevent overflows. The principle is strongly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code performs memory allocation via `ssh_buffer_new()` and `ssh_string_from_char()`. While it checks for NULL returns (out-of-memory), it does not explicitly validate the size parameter (the length of the `directory` string) against allocation limits before the allocation occurs. The relevance is moderate because the allocation is for a user-provided string, but the validation is implicit in the string conversion function.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "The code is a core part of an SFTP protocol implementation. It constructs a message with a specific type (SSH_FXP_MKDIR), expects a specific response type (SSH_FXP_STATUS), and validates the received packet type. It also handles attributes (`SSH_FILEXFER_ATTR_PERMISSIONS`). Ensuring consistent handling of these types across all message construction, sending, receiving, and parsing stages is highly relevant to prevent protocol state confusion or type confusion vulnerabilities.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing at all. It handles directory path strings and SFTP protocol messages. This specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It deals with SFTP commands and file paths. This specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function receives a `directory` string (`const char *`) from the caller, which could be considered untrusted input. It converts it to an `ssh_string` using `ssh_string_from_char`. The security depends on the implementation of `ssh_string_from_char` and subsequent functions like `buffer_add_ssh_string`. If these are not length-aware (e.g., they rely on null-termination without length checks), vulnerabilities could exist. The relevance is moderate as the principle applies to the input handling chain.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code constructs a buffer and adds data (ID, path string, attributes) to it using functions like `buffer_add_u32`, `buffer_add_ssh_string`, and `buffer_add_attributes`. The security of this operation depends on these buffer addition functions correctly validating the input length against the remaining buffer capacity before copying. This is a core principle for preventing buffer overflows. The relevance is strong, though the validation logic is abstracted into the buffer functions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate input length against destination buffer size before cop..."
      },
      {
        "score": 8,
        "reasoning": "The code is part of an SFTP (SSH File Transfer Protocol) network protocol implementation. Protocol specifications define maximum sizes for packets, strings, and attributes. The functions `ssh_buffer_new`, `buffer_add_ssh_string`, and the underlying packet writing/reading routines must enforce these maximum size constraints to prevent resource exhaustion or buffer overflows. This is a fundamental requirement for secure network protocol implementations and is highly relevant to this code context.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce maximum size constraints defined by p..."
      }
    ]
  },
  "CVE-2012-4559_after_exclude_100:1e22750c:spec": {
    "timestamp": "2026-01-17T02:21:11.831785",
    "cve_id": "CVE-2012-4559",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1e22750c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves constructing and sending an SFTP protocol message (SSH_FXP_MKDIR). While it doesn't directly parse incoming length fields, the `sftp_read_and_dispatch` and `parse_status_msg` functions called later will process server responses. These functions must validate message length fields against integer limits to prevent overflows. The relevance is strong as the code is part of a protocol implementation where such validation is critical.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code performs memory allocation via `ssh_buffer_new()` and `ssh_string_from_char(directory)`. While the code checks for NULL returns (out-of-memory), it does not explicitly validate the size of the `directory` input parameter against allocation limits before creating the ssh_string. The `ssh_string_from_char` function should perform this validation. The principle applies, but the validation is likely delegated to helper functions.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "The code handles protocol messages (SSH_FXP_MKDIR, SSH_FXP_STATUS) and expects specific packet types. It explicitly checks `msg->packet_type == SSH_FXP_STATUS` and handles unexpected types. This demonstrates consistent type handling. The relevance is very strong as the code is a core part of a protocol implementation.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate input length against destination buffer size before cop..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce maximum size constraints defined by p..."
      }
    ]
  },
  "CVE-2018-20760_before_exclude_100:068bcf0f:spec": {
    "timestamp": "2026-01-17T02:22:07.166075",
    "cve_id": "CVE-2018-20760",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "068bcf0f",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs encoding conversion operations (UTF-8, UTF-16, etc.) but does not validate the return value of gf_utf8_wcstombs before using it to copy data with strcpy. This directly violates the specification's requirement to validate return values before buffer operations.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. The code uses fixed-size buffers (szLineConv[1024]) and performs potentially unsafe operations like strcpy(szLine, szLineConv) without checking if the converted string fits within the destination buffer (szLine with size lineSize). This directly violates strict bounds checking requirements.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs character encoding conversions but lacks complete error handling. For example, it doesn't handle cases where gf_utf8_wcstombs might fail or return invalid lengths, and there's no error handling for malformed UTF-8 sequences in the manual parsing logic.",
        "spec_index": 2,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code initializes szLine with memset, but szLineConv is not fully initialized before use. While parts of szLineConv get written during conversion, not all indices may be written before the null termination, potentially leaving uninitialized data that could be copied.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function has multiple error paths (returning NULL) but doesn't consistently maintain object states. For example, when returning NULL due to gf_fgets failure, the buffer szLine has been zeroed but the function returns early without completing processing.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes file input (FILE* txt_in), not network protocol input. While both involve input validation, the specification specifically addresses network protocol handlers, which have different threat models and requirements.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not use regular expressions. It performs character encoding conversion and line reading operations, but there are no regex parsing operations that would need to handle embedded NUL bytes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not contain pattern compilers or process escape sequences. It performs character encoding conversion and text line processing, which is unrelated to pattern compilation with escape sequence handling.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-37652_after_exclude_100:897b8637:spec": {
    "timestamp": "2026-01-17T02:22:30.750991",
    "cve_id": "CVE-2021-37652",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "897b8637",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs no cryptographic operations on secret values. It handles tree ensemble data and resource management, which is not sensitive in a cryptographic sense.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code does not implement or interact with elliptic curve cryptography. It is a machine learning kernel for tree ensemble processing.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs no cryptographic processing. Memory operations are related to resource initialization and cleanup, not cryptographic secrets.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code conditionally cleans up a resource (`result->Unref(); result.release();`) when initialization (`InitFromSerialized`) fails. This directly aligns with ensuring resource cleanup is tied to initialization success.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 2,
        "reasoning": "The code does not create cryptographic key objects. It creates a `BoostedTreesEnsembleResource` after attempting to parse a proto, which is not a cryptographic algorithm verification step.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to DNSSEC or network protocol key processing. It manages an internal machine learning resource.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 1,
        "reasoning": "The code does not deal with privilege separation or process termination. It is a TensorFlow op kernel function handling data and resources.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2021-37652_before_exclude_100:48fbad19:spec": {
    "timestamp": "2026-01-17T02:22:37.334325",
    "cve_id": "CVE-2021-37652",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "48fbad19",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs no cryptographic operations on secret values. It handles tree ensemble data and resource management, which are not sensitive in a cryptographic sense.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code does not implement or use elliptic curve cryptography. It is a machine learning kernel for managing tree ensemble resources.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs no cryptographic processing. Memory operations involve parsing a proto and creating a resource, with no requirement for constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 8,
        "reasoning": "This specification is highly relevant. The code conditionally cleans up the `result` resource (`result->Unref()`) only when initialization via `InitFromSerialized` fails. This prevents resource leaks by ensuring cleanup occurs on unsuccessful initialization.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 2,
        "reasoning": "The code does not create cryptographic key objects or verify algorithm support. It parses a serialized tree ensemble proto, which is not a cryptographic operation.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      },
      {
        "score": 2,
        "reasoning": "The code is unrelated to DNSSEC key processing. It manages an internal machine learning resource (BoostedTreesEnsembleResource).",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: DNSSEC key processing must maintain valid object state across all code paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve privilege separation or process termination. It is a TensorFlow op kernel function that returns status errors to the framework.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "While the code manages a resource state (creating it if it doesn't exist), the verification (checking `stamp_token` and parsing) is not atomic in a concurrency sense. The relevance is very low as the state is not security-critical in the cryptographic or access control sense implied by the specification.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2018-20760_after_exclude_100:6c712836:spec": {
    "timestamp": "2026-01-17T02:22:39.675907",
    "cve_id": "CVE-2018-20760",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6c712836",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs encoding conversion operations (UTF-8, UTF-16, and other encodings) but does not validate the return value of `gf_utf8_wcstombs` before using it to index and null-terminate `szLineConv`. This directly violates the specification's requirement to validate return values before buffer operations.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. The code uses a fixed-size buffer `szLineConv[2048]` and performs a `strcpy(szLine, szLineConv)` without checking if the converted string length exceeds the destination buffer `szLine` (which has size `lineSize`). This is a classic buffer overflow vulnerability. The loop logic also risks overrunning `szLineConv` if `j` exceeds 2047.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function performs complex character encoding conversions (handling multiple UTF-8 byte sequences, UTF-16 endianness) but lacks complete error handling. For example, it doesn't handle malformed byte sequences robustly (the `else { i+=1; continue; }` path simply skips bytes), and there's no error path for conversion failures.",
        "spec_index": 2,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code initializes buffers with `memset` and through assignment in loops, so memory is initialized before use. The specification about memory allocations doesn't strongly apply as the buffers are stack-allocated, not dynamically allocated.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Low relevance. While the function has multiple execution paths, it primarily returns either `NULL` or the original `sOK` pointer. The internal state (content of `szLine`) is modified, but there's no complex object state to maintain. Error handling is minimal, but the specification about \"consistent object states\" is not a primary concern here.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code reads from a file (`FILE *txt_in`), not a network protocol. While input validation is important, this specification specifically addresses network protocol handlers, which doesn't apply to this file processing scenario.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not use regular expressions. It processes text lines with encoding conversion, but doesn't involve regex parsing or handling of NUL bytes in patterns.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve pattern compilers or processing of escape sequences. It handles character encoding conversion, not pattern matching or compilation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-16914_before_exclude_100:1fd9edb6:spec": {
    "timestamp": "2026-01-17T02:24:24.721048",
    "cve_id": "CVE-2017-16914",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1fd9edb6",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the w_length field from the USB control request against USB_COMP_EP0_BUFSIZ, which is a platform-specific buffer size limit. This directly aligns with HS-INPUT-001's requirement to validate protocol message length fields against platform limits. However, the validation is not comprehensive for all length fields (e.g., other descriptors), and the cast to modify the const wLength is a concerning practice.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation; it uses a pre-allocated request buffer (cdev->req->buf). However, it does validate that data to be copied (like descriptors) fits within the buffer by using min() operations with w_length. This relates indirectly to validating size parameters against usage requirements, but since no dynamic allocation occurs, relevance is weak.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code handles USB protocol requests with various data types (u8, u16, le16). It performs endianness conversion (le16_to_cpu) on incoming fields and uses min() with type casting for length bounds. While there is consistent handling, the cast of a const pointer to modify w_length violates strict type consistency, showing a moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 6,
        "reasoning": "Before queuing a request for data transfer, the code partially initializes the request structure (req->zero, req->context, etc.). However, for the OS descriptor handling path, it explicitly zeroes the buffer with memset. Memory initialization is present but not fully systematic across all code paths, leading to moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error paths (goto done, break) that return error values. The request structure state is managed, and delayed status is tracked. However, some error paths may leave the request partially configured, and the spin_lock/unlock pairing could be imbalanced if an error occurs mid-way, indicating moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "This is a USB protocol handler that extensively validates input before processing: it checks request type, recipient, w_index, w_value, and w_length bounds. It validates against array bounds (MAX_CONFIG_INTERFACES) and buffer sizes. This is a strong example of input validation in a network-like protocol handler.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The code validates w_length against USB_COMP_EP0_BUFSIZ, which is a system constraint. It also validates intf against MAX_CONFIG_INTERFACES before using it as an array index. These are direct applications of validating userspace-provided (host-provided) lengths against system constraints, though not all array accesses are protected equally.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 7,
        "reasoning": "The code handles variable-length USB descriptors (device, config, string, BOS, etc.) and uses min() to ensure response length does not exceed requested length or buffer size. However, it does not deeply verify the structural integrity of each descriptor's internal variable-length fields; it relies on higher-level functions. Relevance is moderate.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2017-16914_after_exclude_100:e3514cc4:spec": {
    "timestamp": "2026-01-17T02:24:40.202025",
    "cve_id": "CVE-2017-16914",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e3514cc4",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the `w_length` field from the USB control request against `USB_COMP_EP0_BUFSIZ` at the beginning. This is a direct validation of a protocol message length field against a platform-specific limit (the endpoint 0 buffer size). If the length is too large for an IN request, it's truncated; for an OUT request, the request is rejected. This aligns directly with HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation. It uses a pre-allocated request buffer (`cdev->req->buf`). While there is an implicit usage of buffer space when copying data (e.g., via `memcpy`), the validation of `w_length` against buffer size (`USB_COMP_EP0_BUFSIZ` or other calculated sizes) serves a similar purpose for preventing overflow, but the specification's focus on allocation operations is not directly applicable.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles various USB request types (standard, vendor) and recipients (device, interface, endpoint). It uses the `bRequestType` field to route processing (e.g., checking for `USB_DIR_IN`, `USB_RECIP_INTERFACE`). There is consistent use of `le16_to_cpu` for converting little-endian fields from the USB message to host CPU order. This demonstrates enforcement of consistent type handling across processing stages, relevant to HS-PROTOCOL-003.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes fields of the `req` structure (zero, context, complete, length) before use. In the OS descriptors handling block, it explicitly zeros the buffer with `memset(buf, 0, w_length)`. However, not all code paths guarantee full initialization (e.g., buffer contents for some descriptor responses are filled by helper functions which may not initialize the entire buffer up to `w_length`). The relevance is moderate.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error paths (using `break`, `goto done`, `goto unknown`). It generally returns an error value (`-EOPNOTSUPP` or negative from functions) which typically leads to a STALL on the USB endpoint. The `cdev` state appears consistent, but the function does not perform complex state rollback. The use of `spin_lock`/`spin_unlock` around `set_config` and `set_alt` shows awareness of protecting state. Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This function is a USB gadget control request handler, analogous to a network protocol handler. It performs extensive validation of input parameters from the `ctrl` request: checking `w_length` against buffer limits, validating `bRequestType` and `bRequest` against expected values, checking `w_index` for interface bounds (`intf >= MAX_CONFIG_INTERFACES`), and validating `w_value` in specific cases. This is a core part of the function's logic, making HS-IO-003 highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The `w_length` field is provided by the USB host (userspace equivalent). The code validates it against `USB_COMP_EP0_BUFSIZ` immediately. Furthermore, in multiple descriptor handling cases (e.g., GET_DESCRIPTOR for device, config, string), it uses `min(w_length, (u16) value)` to ensure the response does not exceed the requested length or the actual data size. This is a direct application of HS-INPUT-001's principle to array/buffer length validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code handles variable-length components such as descriptors (device, config, string, BOS, OS descriptors). It validates the requested length (`w_length`) and ensures the returned data length does not exceed it. For OS descriptors, it further validates `w_index` and `w_value` fields to ensure structural integrity before processing extended compatibility or property descriptors. However, the validation depth varies, and some complex nested structures are handled by helper functions (`fill_ext_compat`, `fill_ext_prop`). Moderate to strong relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2016-8860_before_exclude_100:d064254f:spec": {
    "timestamp": "2026-01-17T02:24:42.452436",
    "cve_id": "CVE-2016-8860",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d064254f",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code reads a length field from the input data and uses it for memory allocation and copying. It performs a basic validation (`p + len > end`) to ensure the declared length does not cause the read pointer to exceed the buffer end. However, it does not validate the length against platform-specific integer limits (e.g., maximum size_t value, potential integer overflow when calculating `p + len`). The specification is highly relevant as it directly addresses a critical missing check in the length field validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code directly performs a memory allocation (`p_malloc(pool, len)`) based on an untrusted input (`len`). The specification is highly relevant. The code validates that `p + len` does not exceed `end`, which is a usage requirement check, but it fails to validate `len` against allocation limits (e.g., maximum allowable allocation size for the pool) and does not guard against integer overflow in the `p + len` calculation itself, which is a classic vulnerability.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about consistent type handling across protocol stages. The target code is a low-level buffer reading function that treats data as bytes. There is no indication of type confusion or inconsistent interpretation (like treating an integer as a string) within this function. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "The specification requires memory to be initialized before use. The code uses `memcpy` to copy data from the input buffer into the newly allocated memory. Therefore, the allocated memory is being written to, not read from, before initialization. The specification about initializing memory to a known state before reading it does not apply here. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function has multiple error return paths (returning 0). The specification about maintaining consistent object states in error paths is moderately relevant. The function does not seem to have complex object states to maintain, but it does leave the `*data` and `*buffer` output parameters in an undefined state on error (they are not explicitly set). A caller relying on them could be in an inconsistent state. The principle applies.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a network protocol handler function (`rpa_read_buffer`). It validates input (`p > end` and `p + len > end`) before processing (allocating and copying). This is the core activity the specification addresses. However, as noted in other evaluations, the validation is incomplete (missing overflow check). The specification is directly and highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is specifically about regular expression parsers handling NUL bytes. The target code does not involve regular expressions at all. It is a general-purpose buffer reading function. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code performs simple memory copying without any pattern compilation, escape sequence processing, or boundary checking related to such features. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2016-8860_after_exclude_100:80a6eba4:spec": {
    "timestamp": "2026-01-17T02:24:47.623906",
    "cve_id": "CVE-2016-8860",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "80a6eba4",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code reads a length field from the input data and uses it to allocate memory and copy data. It validates that `p + len > end`, which checks for buffer over-read, but does not explicitly validate the length against platform-specific integer limits (e.g., overflow when adding `1 + len` to `*data` or ensuring `len` is within a safe maximum bound). The principle of validating length fields is directly applicable and partially implemented, making it highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs memory allocation based on a user-controlled length (`len`). It validates that `len` is not zero and that `p + len` does not exceed `end`, but it does not check if `len` exceeds a reasonable allocation limit (e.g., maximum allowed buffer size) or consider integer overflow in `p_malloc(pool, len)`. The main principle of validating size parameters before allocation applies strongly.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification about consistent type handling across protocol processing stages is very low relevance. The code deals with raw bytes and length fields but does not involve complex type conversions or multiple processing stages with type mismatches.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires memory allocations to be fully initialized before use. The code uses `memcpy` to copy data into the allocated buffer, which initializes it with user input, not a known safe state. This does not align with the typical meaning of initialization (e.g., zeroing memory) for security purposes, so the specification basically doesn't apply.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has error handling paths that return 0 on failure. It must ensure that object states (like `*data` and `*buffer`) remain consistent. Currently, `*data` is only updated on success, which is good, but `*buffer` is left unmodified on failure. This could leave a dangling pointer if `*buffer` was previously allocated. The principle of maintaining consistent states in error paths has moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a network protocol handler (reading a buffer from data) that validates input length before processing (checking `p + len > end` and `len == 0`). This directly aligns with the specification's requirement to validate input before processing, making it highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification about regular expression parsers handling embedded NUL bytes is completely unrelated to the target code, which does not involve regular expressions or pattern parsing. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification about pattern compilers processing escape sequences is completely unrelated to the target code, which performs simple buffer reading and copying without any pattern compilation or escape sequence handling. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-16914_before_exclude_100:9026c71a:spec": {
    "timestamp": "2026-01-17T02:25:13.360226",
    "cve_id": "CVE-2017-16914",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9026c71a",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes a CAN frame where `cf->len` (DLC) is used directly as `usb_msg.dlc`. While there is a check `can_dropped_invalid_skb` that may validate the skb, the specification about validating protocol message length fields against integer limits is moderately relevant. The DLC field is a critical length field for the subsequent `memcpy`, but its validation is indirect and relies on higher-layer CAN subsystem checks.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation; it retrieves a context via `mcba_usb_get_free_ctx`. However, the specification about validating size parameters for allocation and usage has weak relevance. The main memory operation is `memcpy` using `usb_msg.dlc`, which depends on the validated `cf->len`.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles two CAN frame types (standard and extended) with different bitfield layouts, converting `can_id` into SID/EID fields for USB message. This requires consistent type handling (e.g., bitmask operations, byte order conversion via `put_unaligned_be16`). The specification is strongly relevant as protocol type consistency is crucial for correct message construction.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The `cf->len` (DLC) from the skb data acts as a userspace-provided array length for `cf->data`. It is used in `memcpy` without explicit validation in this function, but `can_dropped_invalid_skb` may perform validation. This provides moderate relevance, as the check is delegated rather than explicit here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code processes variable-length CAN data (0-8 bytes) indicated by `cf->len`. It copies `cf->len` bytes via `memcpy`. Structural integrity of this variable-length component is partially ensured by prior skb validation. The specification is moderately relevant as the copy depends on a length field that should be verified.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The `usb_msg.data` buffer has a fixed size (likely 8 bytes for CAN). The code copies `cf->len` bytes into it. While CAN DLC is limited to 8, worst-case input scenarios are implicitly handled by the CAN subsystem. The specification has weak relevance as no dynamic buffer allocation occurs here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code accesses shared resource `ctx` via `mcba_usb_get_free_ctx` and uses it for transmission. However, there is no visible atomic check-and-update for state transitions of shared resources (e.g., context reuse). The specification has weak relevance as concurrency protection is not shown in this snippet.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The function manages resources: skb, CAN echo skb, and USB context. It calls `can_put_echo_skb` to track skb, and on failure, frees the echo skb and context. Consistency between skb, context, and netdev stats is important. The specification is strongly relevant as resource state consistency is maintained in error handling.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2017-16914_after_exclude_100:124ed1c9:spec": {
    "timestamp": "2026-01-17T02:26:20.531570",
    "cve_id": "CVE-2017-16914",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "124ed1c9",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes a CAN frame where `cf->len` (DLC) is used directly as `usb_msg.dlc`. While there is a check `can_dropped_invalid_skb` that may validate the skb, the specification about validating protocol message length fields against integer limits is moderately relevant. The DLC field is a critical length field for the subsequent `memcpy`, but its validation is indirect and relies on higher-layer CAN subsystem checks.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation; it retrieves a free context via `mcba_usb_get_free_ctx`. The specification about validating size parameters for memory allocation has weak relevance because the primary memory operations (like `memcpy`) use the DLC field which is not directly tied to a dynamic allocation size parameter in this function.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 6,
        "reasoning": "The `cf->len` (DLC) determines how many bytes are copied from `cf->data` via `memcpy`. This length originates from userspace via the socket layer. While `can_dropped_invalid_skb` may perform validation, the explicit validation of this array length against system constraints (like max CAN frame length) is not visible in this function. The relevance is moderate as the core operation depends on this length.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The USB message has a variable-length data component based on `usb_msg.dlc`. The code uses `memcpy` with this length. The specification about verifying structural integrity of variable-length components is moderately relevant. While there is no explicit structural parsing beyond the DLC, ensuring the `cf->data` buffer matches the DLC is critical and is partly addressed by earlier skb validation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform buffer allocation. The USB message `usb_msg` is a stack variable with a fixed-size `data` array (likely 8 bytes for CAN). The specification about allocation for worst-case input has weak relevance because the buffer size is fixed and defined by the protocol (CAN FD not shown, but classic CAN max 8 bytes).",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The function retrieves a free context (`mcba_usb_get_free_ctx`) which may involve shared resource (context pool) state transitions. However, the atomicity of this operation is not visible in this snippet. The specification has very low relevance to the shown code, as the core logic focuses on message formatting and transmission, not explicit atomic state protection.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The function uses a context (`ctx`) obtained from a pool and associates it with an echo skb via `can_put_echo_skb`. This involves tracking structures (context, skb). The specification about maintaining strict consistency between different tracking structures has weak relevance. While consistency is important, the code does not show complex state management; it frees the context on error.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2021-33909_before_subset_100:eda1afb6:spec": {
    "timestamp": "2026-01-17T02:26:41.529652",
    "cve_id": "CVE-2021-33909",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "eda1afb6",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs a memory allocation operation (kvmalloc). HS-MEM-003, which deals with memory release operations and ownership semantics, is strongly relevant. While this function allocates rather than releases memory, the principle of ownership is foundational. The caller of this function becomes the owner of the allocated memory and is responsible for its eventual release, making the specification's core concept highly applicable to the context in which this function is used.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code is a simple kernel memory allocator function. It does not process file content, handle files, or deal with any input streams. The specification regarding file content edge cases has no connection to this code scenario.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 6,
        "reasoning": "The code allocates a resource (memory). HS-STATE-002, concerning resource cleanup across all execution paths, has moderate relevance. While this function itself does not perform cleanup, it is the acquisition half of the resource management pair (alloc/free). The caller must ensure that cleanup happens on all paths, and the success/failure state of this allocation (returning NULL or a pointer) directly influences the program's resource state.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The function takes an `unsigned long size` parameter. There is a weak relevance to HS-LOGIC-001 regarding arithmetic overflow prevention. The caller is responsible for ensuring the `size` argument is valid and that its use (e.g., in subsequent operations) does not cause overflow. The `kvmalloc` function internally may have its own checks, but the interface itself does not show explicit bounds checking or type conversion for overflow prevention.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must prevent overflow through explicit type conversion or bounds..."
      },
      {
        "score": 1,
        "reasoning": "The code performs generic kernel memory allocation. It is not a file system operation, does not calculate block sizes, and does not interact with file system structures. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-FS-002: File system operations must validate block size calculations before processing"
      },
      {
        "score": 1,
        "reasoning": "The code is a memory allocation function in the kernel's virtual memory subsystem. It does not perform file system operations or manage file system metadata state. The specification regarding file system consistency during interruptions is irrelevant.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: File system state must maintain consistency during interrupted operations"
      },
      {
        "score": 4,
        "reasoning": "This is a duplicate of HS-MEM-003 but with a more specific title \"Linked structure deallocation...\". The code allocates memory, which could potentially be used for a linked structure. However, the function itself is generic and has no knowledge of the data structure it will hold. The specific guidance about maintaining neighbor relationships during deallocation is only weakly connected, as it would be the responsibility of the code that frees the memory, not this allocator.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 6,
        "reasoning": "HS-STATE-004 concerns resource cleanup and establishing isolation state. This has moderate relevance. Memory allocation is a key resource acquisition step. Proper cleanup (isolation) would involve freeing this memory and ensuring no dangling pointers. While this function doesn't perform cleanup, the memory it returns must be managed in a way that leads to complete isolation upon release, making the specification's principle relevant to the lifecycle of the resource this function provides.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2014-9904_after_subset_100:3471d20b:spec": {
    "timestamp": "2026-01-17T02:26:58.371861",
    "cve_id": "CVE-2014-9904",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3471d20b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code performs memory allocation, not memory release. Specification HS-MEM-003 focuses on ownership semantics during release operations, which is not applicable here. The weak connection is that memory allocation is a prerequisite to later release, but the current code does not handle release.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-004 deals with file content processing and edge cases for empty files. The target code is a generic memory allocation function with no file operations or input processing, making this specification basically inapplicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The code has a simple execution path with early return on size check failure. While it doesn't have complex cleanup requirements, the principle of consistent state could apply if this function were part of a larger resource acquisition sequence. However, the current implementation is too minimal to strongly relate.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code performs bounds checking (size > MAX_RW_COUNT) which is directly related to preventing overflow issues. The specification about arithmetic operations and bounds checking strongly applies, though the check is simple rather than complex arithmetic.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must prevent overflow through explicit type conversion or bounds..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-FS-002 concerns file system operations and block size calculations. The target code is a generic memory allocator with no file system context, making this specification largely inapplicable beyond the general concept of size validation.",
        "spec_index": 4,
        "spec_preview": "HS-FS-002: File system operations must validate block size calculations before processing"
      },
      {
        "score": 5,
        "reasoning": "HS-STATE-003 addresses file system consistency during interrupted operations. The code performs simple memory allocation without file system operations or state management, making this specification essentially inapplicable.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: File system state must maintain consistency during interrupted operations"
      },
      {
        "score": 5,
        "reasoning": "While this is labeled HS-MEM-003 (duplicate number), it specifically addresses linked structure deallocation and neighbor relationships. The target code performs allocation only, not deallocation, and doesn't involve linked structures, resulting in very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "HS-STATE-004 concerns resource cleanup and isolation state. The code performs allocation without cleanup, so the specification has weak relevance. However, the concept of proper resource management could apply if considering the broader context of how allocated memory should eventually be handled.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-23566_after_subset_100:c3a93b49:spec": {
    "timestamp": "2026-01-17T02:27:07.646877",
    "cve_id": "CVE-2022-23566",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c3a93b49",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve any explicit memory allocation or release operations. It focuses on shape inference and validation of output port indices, not memory ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes node and port indices, not file content. The specification about handling empty files is not applicable to this context.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "While the function validates input and maintains consistency in shape setting, it does not deal with resource cleanup (like file handles, network connections, or memory) across multiple execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to printer configuration files, document processing, or sanitization of such files.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code is not implementing or parsing the IPP (Internet Printing Protocol). It is performing internal shape inference within a computational graph.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve XML parsing or any external entity processing mechanisms.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve document processing, XML, or entity resolution.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2017-9499_before_subset_100:35405ae6:spec": {
    "timestamp": "2026-01-17T02:27:08.624847",
    "cve_id": "CVE-2017-9499",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "35405ae6",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve any explicit memory allocation or release operations. It deals with shape inference in a graph context, primarily setting an output shape handle. There is no management of dynamic memory ownership to which this specification directly applies.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes internal graph node structures and shape handles, not file content. There is no file I/O or logic related to handling empty files or file-based edge cases.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "While the code does not manage resources like memory or file handles, it does interact with a context object (`InferenceContext`). The function must ensure the context is valid before use, which relates to maintaining a consistent program state. However, this is a weak connection as there is no complex cleanup or multiple resource states across execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code performs shape inference in a computational graph (likely TensorFlow) and validates a context pointer, which is unrelated to IPP or print job processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to printer configuration files, document processing, or sanitization of external input files. It operates on internal graph node definitions.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The code is not implementing or parsing the IPP protocol. It is part of a graph shape inference mechanism, dealing with tensor shapes, not network message parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain an XML parser or any logic for processing XML data. The specification regarding disabling external entity processing for XML is completely unrelated to this function's purpose.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code does not process documents (e.g., PDF, XML, Office files) or perform any entity resolution. It is concerned with setting tensor shapes in a computational graph.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2019-18609_before_subset_100:2b8f7631:spec": {
    "timestamp": "2026-01-17T02:28:08.104826",
    "cve_id": "CVE-2019-18609",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2b8f7631",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs numeric input validation (e.g., checking row_remapping.size() == num_rows_, col_remapping.size() == num_cols_) before using these values in arithmetic operations and loops. This aligns with the principle of enforcing bounds before operations. However, the validation is not exhaustive for all possible arithmetic (e.g., slice calculations use max_old_row and min_old_row without explicit validation against tensor bounds beyond the initial size check).",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 7,
        "reasoning": "The code reads from a checkpoint file (BundleReader) and validates numeric fields from the file, such as tensor shape dimensions and data type. It checks tensor rank, dimension sizes, and type against expected values. This matches the specification's principle of validating file format numeric fields against constraints, though the file is a TensorFlow checkpoint, not a generic image/media file.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      },
      {
        "score": 4,
        "reasoning": "This specification is about image parsers validating dimensions against file data size. The target code reads a TensorFlow checkpoint (not an image file) and validates tensor dimensions, but does not compare claimed dimensions against actual file data size directly. The relevance is weak as the context differs (checkpoint vs. image file).",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The code implements a file format reader (BundleReader) that performs dimension checking (tensor_shape.dims() == 2, num_cols_ == tensor_shape.dim_size(1)) before memory allocation for the output matrix (context->allocate_output). This aligns well with safe dimension checking before allocation, though it's specific to TensorFlow checkpoints.",
        "spec_index": 3,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "This specification is about IPP (Internet Printing Protocol) attribute validation. The target code does not involve IPP or printer-related processing. The relevance is very low as the context is completely different (TensorFlow checkpoint loading vs. printing protocol).",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "This specification is about IPP protocol message parsing. The target code does not implement any network protocol parsing; it reads from a checkpoint file via BundleReader. The relevance is very low due to context mismatch.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code does not explicitly show memory release operations (e.g., delete, free). Memory management is handled by TensorFlow's Tensor objects and standard containers. There is no clear ownership transfer or manual memory release to evaluate. Weak relevance as the specification's principle of ownership semantics is not directly applicable in this code snippet.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      }
    ]
  },
  "CVE-2016-8670_after_subset_100:8d0da41f:spec": {
    "timestamp": "2026-01-17T02:28:17.836366",
    "cve_id": "CVE-2016-8670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8d0da41f",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs numeric input validation (e.g., checking row_remapping size equals num_rows_, col_remapping size equals num_cols_, tensor rank and dimensions) before using these values in arithmetic operations and memory allocation. This aligns with the principle of enforcing bounds before operations. However, it's not exclusively about \"upper bounds\" but general dimensional consistency.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 7,
        "reasoning": "The code validates numeric fields from a file format (TensorFlow checkpoint bundle) - it reads tensor shape/dtype and validates rank, dimension sizes, and data type against expected constraints (e.g., rank must be 2, column size must match). This is a direct application of validating file format numeric fields.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      },
      {
        "score": 3,
        "reasoning": "This specification is specifically for image parsers validating dimensions against file data size. The target code processes TensorFlow checkpoint files, not image files, so the context doesn't match. The validation principles are similar but applied to a different domain.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "The code implements safe dimension checking before memory allocation: it validates tensor_shape dimensions, checks num_cols_ against tensor_shape.dim_size(1) when not remapping columns, and validates row/column remapping sizes before allocating the output matrix. This directly corresponds to safe dimension checking principles.",
        "spec_index": 3,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 2,
        "reasoning": "This specification is about IPP (Internet Printing Protocol) attribute validation. The target code processes TensorFlow checkpoints and tensors, not IPP protocol data, so this specification doesn't apply to the current context.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 2,
        "reasoning": "This specification concerns printer configuration file sanitization. The target code reads TensorFlow checkpoint files, not printer configuration files, making this specification irrelevant to the current code scenario.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 2,
        "reasoning": "This specification is specifically for IPP protocol implementations requiring strict message parsing. The target code implements a TensorFlow op kernel for loading checkpoints, not an IPP protocol handler, so this doesn't apply.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 3,
        "reasoning": "The code manages memory through Tensor objects and allocation contexts, but doesn't explicitly show manual memory release operations or ownership transfer semantics. TensorFlow handles most memory management internally. There's weak relevance as the code must ensure proper resource management but doesn't demonstrate explicit memory release patterns.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      }
    ]
  },
  "CVE-2016-7425_before_subset_100:54fc979b:spec": {
    "timestamp": "2026-01-17T02:28:40.847470",
    "cve_id": "CVE-2016-7425",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "54fc979b",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code performs memory movement (memmove) but does not involve memory allocation or release operations. Specification HS-MEM-003 focuses on ownership semantics during memory release, which is not applicable here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code operates on an in-memory buffer, not on file content processing. There is no file I/O or handling of empty files in this function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "While the function sets an error state (buf->error) on certain conditions, it does not perform comprehensive resource cleanup (like freeing memory) across all execution paths. The state management is limited to error flag setting.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "This specification is specific to image parsers validating dimensions. The target code is a generic buffer manipulation function with no image processing context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The function performs some bounds checking before memory movement, which relates to safe dimension checking. However, it's not specifically for file format readers or memory allocation.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function validates size parameters (len, offset converted to aoffset) against buffer boundaries. It handles signedness by using abs(offset) and checking both positive and negative offset cases, directly addressing signedness constraints in buffer operations.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function enforces non-negative length constraints by validating that buf->offset + aoffset + len doesn't exceed maxlen (for positive offset) and that buf->offset >= aoffset (for negative offset), ensuring safe memory operations.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs arithmetic operations (buf->offset + aoffset + len) for bounds checking but doesn't explicitly include overflow/underflow protection for these calculations. The checks prevent buffer overflows but don't guard against integer overflows in the arithmetic itself.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2016-5418_before_subset_100:a5a4affe:spec": {
    "timestamp": "2026-01-17T02:28:44.977290",
    "cve_id": "CVE-2016-5418",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a5a4affe",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves memory allocation (e.g., xasprintf for srcbuf) and immediate freeing, which touches on memory ownership. However, the specification \"Memory release operations must maintain strict ownership semantics\" is more about complex ownership models and preventing use-after-free/double-free. The code shows simple, linear ownership (allocate, use, free), so relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about file content processing edge cases. The target code is a mount utility that parses command-line arguments and interacts with mount contexts, but does not directly process file contents (like reading from files). The fstab handling is indirect via libmount. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The code must ensure resource cleanup (context, table) across all execution paths (normal, error exits). It uses `goto done` for cleanup and `atexit(close_stdout)`. However, some error paths call `err()` or `exit_non_root()` which may exit without explicit cleanup (though `err()` may flush buffers). Strong relevance because consistent state cleanup is crucial.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve XML parsing. It is a mount command-line utility. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification is about document processing and entity resolution boundaries. The target code does not process documents (XML, SGML, etc.). Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code gates certain mount operations (like bind, move, source/target specification) behind root checks (`mnt_context_is_restricted`). Security-sensitive features (mounting) are restricted. However, the specification is about explicit configuration options, not runtime privilege checks. Moderate relevance because the principle of restricting sensitive operations applies.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification is about linked structure deallocation maintaining neighbor relationships. The code uses libmount structures (context, table) but deallocation is via `mnt_free_context` and `mnt_free_table` which are opaque library calls. No manual linked list manipulation is visible. Weak relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification is about resource cleanup establishing complete isolation state. The code cleans up context and table at the end, but isolation state (e.g., undoing mounts) is not addressed heremount operations are persistent. Weak relevance because cleanup is limited to memory/resources, not system state isolation.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2016-5418_after_subset_100:d8f0d1dc:spec": {
    "timestamp": "2026-01-17T02:28:46.496965",
    "cve_id": "CVE-2016-5418",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d8f0d1dc",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves memory allocation (e.g., `xasprintf(&srcbuf, ...)`) and deallocation (`free(srcbuf)`). It maintains ownership by freeing `srcbuf` immediately after use in the same scope. However, the specification about \"strict ownership semantics\" is only partially relevant as the memory management is relatively simple and localized, not involving complex ownership transfers or shared ownership scenarios.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about file content processing edge cases. The code reads command-line arguments and may process fstab files via `append_fstab`, but it does not show detailed file content handling logic. The relevance is very low as the core logic is about mount operations and argument parsing, not generic file content processing.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The code shows cleanup operations (`mnt_free_context`, `mnt_free_table`) in a `done` label reached via multiple execution paths (e.g., after `goto done`). It ensures resources are freed consistently. However, the cleanup is not exhaustive (e.g., no cleanup for `types` pointer which points to `optarg`). Strong relevance as the pattern of centralized cleanup exists.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve XML parsing at all. It is a mount utility processing command-line options and performing mount operations. The specification is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Similar to spec 4, the code does not involve document processing or entity resolution. It is a system utility for mounting filesystems. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code gates security-sensitive operations (like mount operations that require root) behind checks: `mnt_context_is_restricted(cxt)` is used to restrict options for non-root users (e.g., `exit_non_root`). This aligns with the principle that sensitive features must be explicitly controlled. Highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 3,
        "reasoning": "The specification is about linked structure deallocation maintaining neighbor relationships. The code frees a context and table, but these are likely opaque structures; the internal deallocation logic is not visible. Weak relevance as the code does not explicitly show linked list or graph deallocation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification about \"complete isolation state\" during resource cleanup is partially relevant. The cleanup (`mnt_free_context`, `mnt_free_table`) may release system resources (like file descriptors), but the code does not show explicit isolation steps (e.g., resetting global state). Moderate weak relevance.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2016-7425_after_subset_100:ef1c0b2e:spec": {
    "timestamp": "2026-01-17T02:29:53.626766",
    "cve_id": "CVE-2016-7425",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ef1c0b2e",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code performs memory movement but does not involve memory release or ownership semantics. The function manipulates an existing buffer's contents without allocating or freeing memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code operates on an in-memory buffer, not on file content processing. There is no file I/O or handling of file-specific edge cases like empty files.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function does not allocate or clean up resources. It only modifies buffer content and updates an error state. There is no complex resource management across multiple execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code is a generic buffer manipulation function, not an image parser. It does not validate image dimensions or process image data.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "While the function performs bounds checking, it is not a file format reader and does not allocate memory based on dimensions. Its checks are for buffer boundaries, not file format dimensions.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function performs buffer copy via memmove and validates size parameters (len, offset) against buffer bounds. It handles signedness by converting offset to absolute value (aoffset) and checking for negative offset cases. This directly addresses signedness constraints in buffer operations.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function enforces non-negative length constraints indirectly through bounds checking. It validates that buffer operations stay within valid ranges, preventing negative or excessive lengths from causing out-of-bounds memory access.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function performs arithmetic operations (buf->offset + aoffset + len) for bounds checking but does not explicitly include overflow/underflow protection. The checks compare against maxlen, which may catch some overflow results, but integer overflow in the arithmetic itself is not prevented.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2017-8068_before_subset_100:f7d3b96d:spec": {
    "timestamp": "2026-01-17T02:30:04.899256",
    "cve_id": "CVE-2017-8068",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f7d3b96d",
    "scores": [
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-001 is about validating IPP (Internet Printing Protocol) attribute values. The target code processes IRC (Internet Relay Chat) capability negotiation strings. The protocols and contexts are completely different. The general principle of input validation is relevant to all software, but this specific specification is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-002 concerns sanitizing printer configuration files. The target code does not process any configuration files; it handles dynamic IRC protocol messages. There is no relevance.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-PROTOCOL-003 is for enforcing strict message parsing in IPP protocol implementations. While the target code does parse a protocol message (the `extensions_str`), it is for the IRC CAP protocol, not IPP. The core principle is similar, but the specification is tied to a different, specific protocol.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 6,
        "reasoning": "Specification HS-MEM-003 is about maintaining strict ownership semantics during memory release. The target code uses `g_strsplit` to allocate an array and `g_strfreev` to free it. This demonstrates a clear ownership pattern (the function allocates and frees the array within its scope). The relevance is moderate as the code correctly follows the principle, though the specification's wording is general.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-004 is about handling edge cases when processing file content. The target code processes a string argument (`extensions_str`), not file content. The concept of handling edge cases (like an empty string) is present, as `g_strsplit` would handle it, but the specification's context is not relevant.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "Specification HS-STATE-002 is about maintaining consistent state during resource cleanup across all execution paths. The target code has a potential state inconsistency: the `serv->sent_capend` flag is only set to `TRUE` in the `if (!want_sasl)` branch. If `want_sasl` is 1, the flag is not updated, which might leave the server connection state inconsistent if this function is called again. This is a moderate relevance as the code contains a state management pattern that should be examined for consistency.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-001 (second instance) is about XML parsers disabling external entity processing. The target code does not parse XML; it performs simple string operations on an IRC capability list. There is no relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-002 (second instance) is about enforcing strict entity resolution boundaries during document processing. The target code does not process documents (XML, SGML, etc.) and has no concept of entity resolution. There is no relevance.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2016-7425_after_subset_100:d8fd07c6:spec": {
    "timestamp": "2026-01-17T02:30:26.669608",
    "cve_id": "CVE-2016-7425",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d8fd07c6",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code handles IRC (Internet Relay Chat) capability negotiation. The protocols and contexts are completely different. The general principle of \"input validation\" is a secure coding best practice, but the specific IPP context makes it largely irrelevant to this code.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 2,
        "reasoning": "The specification concerns sanitizing printer configuration files. The target code processes a dynamic IRC capability list string received over the network. There is no processing of configuration files in this function, making the specification essentially inapplicable.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 3,
        "reasoning": "The specification mandates strict message parsing for the IPP protocol. While the code does parse an IRC CAP LS message (splitting the extensions string), it is for a different protocol. The core principle of careful parsing is relevant, but the specific IPP context and requirements are not.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 7,
        "reasoning": "The specification about memory release operations maintaining strict ownership semantics has moderate relevance. The code uses `g_strsplit` and `g_strfreev` for memory management. While the function correctly frees the allocated array, ensuring consistent ownership and cleanup across all potential execution paths (e.g., early returns on error, not shown in this snippet) is a relevant general principle for secure memory handling.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The specification deals with handling edge cases when processing file content. The target code processes a network string, not file content. The concept of handling edge cases (like an empty `extensions_str`) is a good general practice, but the file-specific context of the specification makes the direct relevance very low.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The specification on maintaining consistent state during resource cleanup is strongly relevant. The function manages state (`serv->sent_capend`) and sends network commands (`CAP END`) conditionally based on `want_sasl`. Ensuring that state transitions and network actions are consistent and correct across all logical paths (e.g., if `want_cap` is true/false, if `want_sasl` is true/false) is crucial to avoid protocol desynchronization or unexpected client/server state.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "The specification is about XML parsers disabling external entity processing. The target code does not parse XML at all; it handles space-delimited IRC capability strings. Therefore, this specification is almost entirely irrelevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 2,
        "reasoning": "The specification concerns enforcing strict entity resolution boundaries during document processing. Similar to spec_7, this is specific to document formats (like XML) and does not apply to the IRC protocol parsing performed in this function.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2015-4054_before_subset_100:da1a168f:spec": {
    "timestamp": "2026-01-17T02:30:32.535375",
    "cve_id": "CVE-2015-4054",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "da1a168f",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code manages memory and resources (krb5_context, krb5_keytab, krb5_principal, krb5_keytab_entry) with explicit cleanup in an exit block. This aligns with the principle of maintaining strict ownership semantics. However, the cleanup of the `entry` structure via `krb5_kt_free_entry` only occurs on one successful path, not on the `KRB5_KT_NOTFOUND` path where `rc` is set to 1. This creates a potential inconsistency in ownership management across different execution paths, preventing a higher score.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about processing file contents and handling edge cases like empty files. The target code resolves a keytab file path but does not read or process the file's content directly; it uses a Kerberos library API (`krb5_kt_resolve`). Therefore, this specification is not relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "This specification is highly relevant. The code uses multiple resources (context, keytab, principal, keytab entry) and has a centralized `exit:` block for cleanup. This promotes consistent state cleanup across most execution paths (via `goto exit`). The flaw noted in spec_1 (missing `krb5_kt_free_entry` on the `KRB5_KT_NOTFOUND` path) is a specific violation of this principle, as resource state is not cleaned up consistently for all paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about configuring XML parsers to disable external entity processing. The target code deals with Kerberos keytab files and has no XML parsing functionality. It is not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns document processing and entity resolution boundaries, likely in the context of XML or similar formats. The target code does not process documents in this sense. It is not relevant.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The specification has moderate relevance. The function checks for the availability of a security-sensitive resource (a Kerberos keytab entry). The use of a non-default keytab file is gated behind an explicit configuration option (`kssl_ctx->keytab_file`). However, the core security check (keytab entry existence) is the function's primary purpose, not just a feature gate. The principle of explicit configuration for security-sensitive operations is partially reflected.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 1,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code is part of a Kerberos/SSL context and does not involve IPP. It is not relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification is about sanitizing printer configuration files before processing. The target code handles Kerberos keytab files, which are a different type of security-sensitive file. While the concept of handling sensitive files is similar, the specific context (printer configuration) and required actions (sanitization) do not apply to this keytab resolution code.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2010-0433_after_subset_100:443a9d89:spec": {
    "timestamp": "2026-01-17T02:30:35.065985",
    "cve_id": "CVE-2010-0433",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "443a9d89",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code manages memory and resources (krb5_context, krb5_keytab, krb5_principal, krb5_keytab_entry) with explicit cleanup in an exit block. It demonstrates ownership semantics by checking pointers before freeing/closing. However, the cleanup of `krb5keytab` uses `krb5_kt_close` only if the pointer is non-NULL, which is correct, but the pattern of setting pointers to NULL after cleanup is not shown, and ownership transfer is not a primary concern here. The relevance is moderate as the principle applies but is not the central, complex focus.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code reads a keytab file path from `kssl_ctx->keytab_file` but does not process the file's content directly; it passes the path to `krb5_kt_resolve`. The specification about handling edge cases in file content processing (like empty files) is not directly applicable, as the Kerberos library handles the low-level file reading. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The code uses a centralized `exit:` label for cleanup across multiple error and success paths. It ensures resources (context, keytab, principal, keytab entry) are properly released regardless of whether the function exits early due to errors or succeeds. This is a classic example of maintaining consistent state cleanup across all execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve XML parsing or processing in any way. It deals with Kerberos keytab files and principal names. This specification is completely irrelevant to the provided code scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve document processing, entity resolution, or any markup language handling. It is focused on Kerberos authentication and keytab availability checks. This specification has no applicability.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code checks for a security-sensitive feature (keytab availability) which is gated behind the `kssl_ctx->keytab_file` configuration option. If it's NULL, a default is used. This aligns with the principle of having explicit configuration control over security-sensitive resources (keytabs). The relevance is moderate because it's a simple check rather than a complex gating mechanism.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 1,
        "reasoning": "The code does not process IPP (Internet Printing Protocol) attributes. It works with Kerberos contexts, keytabs, and principals. This specification is not relevant to the code's functionality.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code does not process printer configuration files. It handles Kerberos keytab files, which are a different security construct. The specification's focus on printer file sanitization is not applicable here.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2022-23593_before_subset_100:a0daa45a:spec": {
    "timestamp": "2026-01-17T02:31:30.619123",
    "cve_id": "CVE-2022-23593",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a0daa45a",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code performs shape analysis and manipulation but does not involve explicit memory allocation or deallocation. The specification about memory release ownership is only weakly relevant, as the code deals with high-level MLIR values and symbolic expressions, not raw memory management.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes tensor shapes and dimensions, not file content. The edge case handling mentioned in the specification (empty files) has no direct parallel in the shape analysis context, making relevance very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "While the function must handle all code paths consistently (returning values or empty optionals), it doesn't manage external resources like files, sockets, or memory that require cleanup. The state consistency concern is limited to the function's logical flow.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code validates shape dimensions (checking for constant 1, comparing symbolic expressions) before processing, which aligns with the general principle of input validation. However, it doesn't deal with IPP attributes specifically, making the connection indirect.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code performs mathematical shape analysis for compiler optimization, completely unrelated to printer configuration files or sanitization. No relevance exists.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 2,
        "reasoning": "The code parses and analyzes tensor shapes, not network protocols. While both involve parsing structured information, the domain (IPP protocol vs. compiler shape analysis) is completely different, resulting in very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code manipulates collections of symbolic expressions but doesn't involve linked data structures or deallocation. The \"neighbor relationships\" concept doesn't apply to the array indexing logic used here.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The function doesn't manage resources requiring isolation state during cleanup. It's a pure analysis/transformation function operating on immutable analysis results and builder operations.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-23593_after_subset_100:0a3258ff:spec": {
    "timestamp": "2026-01-17T02:31:52.767553",
    "cve_id": "CVE-2022-23593",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0a3258ff",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code performs shape analysis and tensor construction but does not involve explicit memory allocation or deallocation operations. While it manages data structures like SmallVector, these are stack-allocated or managed by higher-level frameworks. The strict ownership semantics of HS-MEM-003 are not directly applicable to this algorithmic transformation code.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code performs shape analysis and may return early on failure, but doesn't manage external resources like file handles, network connections, or memory that requires cleanup. The state management is limited to local variables and return values, not system resources requiring consistent cleanup across execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "While the code validates shape dimensions (checking for constant 1, comparing dimensions for equality), it's not validating IPP (Internet Printing Protocol) attributes specifically. The general principle of input validation applies weakly as the code does check shape compatibility before proceeding with transformations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor shape analysis and broadcasting simplification, completely unrelated to printer configuration files or any file sanitization. This specification has no relevance to the mathematical shape manipulation operations.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code implements a broadcasting simplification algorithm for tensor operations, not an IPP protocol implementation. There is no message parsing, network protocol handling, or printing-related functionality in this code.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code manages arrays and vectors of shape information but doesn't involve linked list structures or complex pointer-based data structures that require careful deallocation. The memory management is handled by higher-level containers, not manual linked structure manipulation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't perform resource cleanup operations or establish isolation states. It's a pure function that analyzes shapes and potentially creates new tensor values, without managing system resources, security boundaries, or isolation contexts.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-23565_before_subset_100:a92cde1c:spec": {
    "timestamp": "2026-01-17T02:32:10.643692",
    "cve_id": "CVE-2022-23565",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a92cde1c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification discusses memory release operations and ownership semantics. The target code does not perform any explicit memory allocation or deallocation; it uses standard containers (unordered_map) and references. There is a weak connection because the map stores pointers to elements in a container whose lifetime is managed elsewhere, but no ownership transfer or release occurs in this function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about file content processing and edge cases like empty files. The target code processes protobuf repeated fields in memory, not files. There is no file I/O or handling of file-specific edge cases.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about linked structure deallocation and neighbor relationships. The target code does not use linked lists, trees, or similar structures requiring manual deallocation or neighbor updates. It uses an unordered_map of pointers, but no deallocation or link manipulation occurs.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 1,
        "reasoning": "The specification is about resource cleanup establishing complete isolation state. The target code does not manage shared resources, perform isolation (like sandboxing), or have cleanup beyond local automatic variables. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "The specification states that all IPP (Internet Printing Protocol) attribute values must be validated before processing. The target code validates uniqueness of attribute names (via DCHECK) and compares attribute definitions for equality. While not about IPP, the core principle of validating input data (AttrDef names and contents) before use is moderately relevant. However, the context (protobuf OpDef attributes vs. IPP attributes) differs.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files before processing. The target code does not process configuration files, nor is it related to printing or sanitization of file content. No relevance.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about IPP protocol implementations enforcing strict message parsing. The target code is a utility function comparing two repeated protobuf fields; it is not a protocol implementation, does not parse network messages, and is not related to IPP.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      }
    ]
  },
  "CVE-2010-5313_before_subset_100:79fd0ce1:spec": {
    "timestamp": "2026-01-17T02:32:17.147656",
    "cve_id": "CVE-2010-5313",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "79fd0ce1",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves memory management for `xfrm_state` objects (via `xfrm_states_put` and `xfrm_states_delete`). Specification HS-MEM-003 about maintaining strict ownership semantics is highly relevant. The function must correctly transfer ownership of states during migration and ensure they are not leaked or double-freed, especially in error paths. The relevance is strong but not a perfect 10, as the specification is broad and the code's memory handling is for specific kernel objects rather than generic memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "Specification HS-INPUT-004 is about processing file contents and handling edge cases like empty files. The target code performs network security policy and state migration in the Linux kernel. It does not process file contents at all. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Specification HS-STATE-002 is highly relevant. The function manages multiple resources (policy and state objects) and has multiple execution paths (success, error goto `out`, error goto `restore_state`). The `restore_state` cleanup block must ensure a consistent state is maintained by cleaning up newly created states (`x_new`) and not double-freeing or leaking the original states (`x_cur`). This is a core concern of the code.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-001 mandates disabling external entity processing in XML parsers. The target code is kernel-level IPsec/XFRM migration logic and contains no XML parsing functionality. The specification is completely irrelevant to this code scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-002 concerns document processing and entity resolution boundaries, likely in the context of XML or similar formats. This is unrelated to the kernel networking and security policy migration code provided.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-CONF-003 discusses gating security-sensitive features behind explicit configuration. The function `xfrm_migrate` is itself a security-sensitive operation (migrating IPsec SAs and policies). Its availability might be controlled by kernel configuration (e.g., `CONFIG_XFRM_MIGRATE`). However, the code itself does not implement the gating logic; it is the feature. Therefore, the connection is weak and indirect.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 7,
        "reasoning": "Specification HS-MEM-003 (duplicate ID, but different text: \"Linked structure deallocation must maintain consistent neighbor relationships\") has moderate relevance. The `xfrm_state` and `xfrm_policy` objects are likely part of linked structures or hash tables within the kernel. Functions like `xfrm_states_delete` must properly remove objects from these structures without corrupting links. The code's context implies this, but the internal implementation of those functions is not visible.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 8,
        "reasoning": "Specification HS-STATE-004 about establishing complete isolation state during resource cleanup is strongly relevant. The error path (`restore_state`) aims to roll back the migration, attempting to isolate the system from partially applied changes by deleting newly created states (`x_new`). The goal is to return the system to a stable, isolated pre-migration state (or a clean error state). The success path also establishes a new isolated state by deleting old states. The principle directly applies.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2010-5313_after_subset_100:b51910d6:spec": {
    "timestamp": "2026-01-17T02:32:20.070838",
    "cve_id": "CVE-2010-5313",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b51910d6",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves memory management for `xfrm_state` objects (via `xfrm_states_put` and `xfrm_states_delete`). Specification HS-MEM-003 about maintaining strict ownership semantics is highly relevant. The function must correctly transfer ownership from old to new states and ensure proper cleanup on error paths to prevent leaks or double frees.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-004 deals with file content processing and edge cases for empty files. The target code performs network security policy/state migration and does not process any file content. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Specification HS-STATE-002 is highly relevant. The function manages multiple resources (policy, old states, new states) and has multiple execution paths (success, error goto `out`, error goto `restore_state`). The `restore_state` cleanup block must ensure all allocated resources are properly released to maintain a consistent system state, which it attempts to do.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-001 is about configuring XML parsers to disable external entity processing. The target code is for IPsec/XFRM migration in the Linux kernel and does not involve XML parsing. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-SEC-002 concerns document processing and entity resolution boundaries, likely in the context of XML or similar formats. This is unrelated to the network security state migration functionality of the code.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-CONF-003 about gating security-sensitive features has weak relevance. The function `xfrm_migrate` itself is a security-sensitive operation (migrating IPsec SAs/policies). Its availability should be controlled at a system configuration level, but the code itself does not implement such gating; it's a core function called when the feature is used.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 (duplicate ID, but different description: \"Linked structure deallocation must maintain consistent neighbor relationships\") has moderate relevance. While the code deals with state objects that are likely part of larger hash tables or lists (e.g., policy state bundles), the cleanup functions (`xfrm_states_put`, `xfrm_states_delete`) are responsible for properly removing states from these structures. The function's success depends on these lower-level operations maintaining consistency.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-004 about establishing complete isolation state during resource cleanup is strongly relevant. During the migration rollback (`restore_state`), the function must not only free new states but also ensure any partial changes to the policy or old states are reverted to isolate the failed migration attempt and leave the system in a stable, consistent pre-migration state.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-23565_after_subset_100:40230d9d:spec": {
    "timestamp": "2026-01-17T02:33:05.275174",
    "cve_id": "CVE-2022-23565",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "40230d9d",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code does not perform any explicit memory allocation or deallocation; it uses standard containers and references. There is no manual memory management to evaluate against ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The specification is about resource cleanup and consistent state. The target code does not manage resources like file handles or network connections. It uses a local unordered_map, but its cleanup is automatic (RAII). The state consistency discussed here is logical (comparing two collections), not resource state.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about deallocating linked structures and maintaining neighbor relationships. The target code does not use linked lists, trees, or similar structures that require manual deallocation. The containers used manage their own memory.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification is about resource cleanup achieving isolation state. The target code does not deal with shared resources, isolation, or cleanup of external state. Its scope is limited to a comparison function.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating attribute values before processing. The target code validates that attribute names in the first list (`a1`) are unique, logging an error if not. This is a form of input validation, though the validation is for internal consistency rather than external, untrusted input. The principle of validating data before use has moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code operates on protocol buffer definitions related to operation attributes, which is unrelated to printer configuration or file sanitization.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing strict message parsing in IPP protocol implementations. The target code is part of a system (likely TensorFlow) that defines and compares operation attributes, which is a form of protocol or schema definition. The function ensures strict equality checking between two attribute lists, which aligns with the principle of strict validation in protocol handling, but it is not directly about parsing network messages.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      }
    ]
  },
  "CVE-2021-40565_before_subset_100:a7f559e5:spec": {
    "timestamp": "2026-01-17T02:33:58.235939",
    "cve_id": "CVE-2021-40565",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a7f559e5",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code is an AVC (H.264) NAL unit parser. It processes video stream data, which inherently involves parsing dimensions and structural information from the bitstream. While not an image parser per se, it is a media parser that must validate the integrity and structure of incoming data against expected formats to prevent malformed data from causing out-of-bounds reads or other memory corruption. The principle of validating parsed data against actual available data is directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 7,
        "reasoning": "The code reads from a GF_BitStream (`bs`), which is a file/stream format reader abstraction. It parses NAL headers and slice information, which contain dimensions and parameters. Safe dimension checking before any subsequent processing or implicit allocation (e.g., within `gf_avc_read_sps_bs_internal`) is a core security concern for this type of code. The relevance is strong, though the allocation logic is not directly visible in this function.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2021-40565_after_subset_100:5f146953:spec": {
    "timestamp": "2026-01-17T02:33:59.853046",
    "cve_id": "CVE-2021-40565",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f146953",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code is an AVC (H.264) NAL unit parser. While it doesn't directly parse image dimensions, it processes video stream data structures (SPS, PPS, slices) which contain parameters like picture dimensions. The function should validate these parameters against reasonable limits before use, making the principle of validating claimed dimensions moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 6,
        "reasoning": "The code reads and parses video stream data structures. While it doesn't directly allocate memory based on dimensions in this function, it calls other functions (like gf_avc_read_sps_bs_internal) that likely parse dimension parameters. Safe dimension checking before any dependent memory allocation is a relevant principle for the broader parsing context.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code shown doesn't contain explicit memory allocation or release operations. It works with stack-allocated structures (n_state) and copies data between them. Memory ownership semantics aren't directly addressed in this function.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The function processes binary stream data and must handle various edge cases: invalid NAL unit types, malformed data, unexpected EOF when reading bits, and inconsistent state transitions. The function does check return values (e.g., avc->last_ps_idx < 0) but comprehensive edge case handling is crucial for parser security.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function maintains parser state (avc->s_info) and updates it conditionally. While it doesn't manage external resources like file handles or heap memory, it must ensure state consistency across different NAL unit types and error conditions. Some relevance exists but is not the primary focus.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code parses binary AVC/H.264 video data, not XML. External entity processing is an XML-specific concern that doesn't apply to this binary video parser.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Document processing and entity resolution boundaries are concepts related to markup language parsers (XML, HTML), not binary video codec parsers. This specification has no relevance to the AVC NAL unit parsing code.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't implement security-sensitive features that would require gating behind configuration options. It's a core parsing function that should behave consistently. The emulation byte removal feature (gf_bs_enable_emulation_byte_removal) could be considered a security-relevant parsing mode, but it's not explicitly gated.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2016-0723_before_subset_100:393bad68:spec": {
    "timestamp": "2026-01-17T02:34:14.677298",
    "cve_id": "CVE-2016-0723",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "393bad68",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code handles memory allocation (talloc_array) and deallocation (TALLOC_FREE) in several places. While it maintains ownership semantics by freeing allocated memory before returning error statuses (e.g., in FSCTL_GET_SHADOW_COPY_DATA), there is a potential issue: in FSCTL_CREATE_OR_GET_OBJECT_ID, memory is allocated for 64 bytes regardless of max_out_len, which could lead to wasted allocation if max_out_len is smaller. However, ownership is properly transferred to the caller via *out_data. The relevance is moderate because memory management is present but not the core focus.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes file-related operations (e.g., sparse file setting, shadow copy data) but does not explicitly handle file content processing. Edge cases like empty files are not directly addressed; for example, FSCTL_QUERY_ALLOCATED_RANGES checks if file size is zero, but this is a minor aspect. The specification is about file content processing, which is not the primary function of this FSCTL handler. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The code demonstrates consistent resource cleanup across execution paths. For instance, in FSCTL_GET_SHADOW_COPY_DATA, shadow_data is allocated and properly freed via TALLOC_FREE in error paths and after successful use. Similarly, memory allocated for cur_pdata is managed through talloc_zero_array and associated with ctx. All error returns ensure resources are not leaked. This shows strong adherence to maintaining consistent state during cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve XML parsing at all. It handles Windows FSCTL (File System Control) operations, which are unrelated to XML processing. Therefore, this specification is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Similar to specification 4, this code does not involve document processing or entity resolution. It deals with file system control operations, such as sparse files and shadow copies. No document formats (XML, etc.) are processed here.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code implements several security-sensitive FSCTL operations (e.g., FSCTL_SET_REPARSE_POINT, FSCTL_GET_SHADOW_COPY_DATA). However, it does not gate them behind explicit configuration options; they are always available if the VFS module is loaded. Some operations return NOT_SUPPORTED or NOT_IMPLEMENTED, but this is not based on configuration. Weak relevance because security-sensitive features are present but not configurable.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 9,
        "reasoning": "The code extensively validates buffer lengths and calculations. Examples: In FSCTL_GET_SHADOW_COPY_DATA, it checks max_out_len < 16, calculates *out_len, and verifies max_out_len < *out_len. In FSCTL_QUERY_ALLOCATED_RANGES, it validates in_len and max_out_len. Length calculations use safe operations (e.g., MIN to avoid overflow). This directly aligns with the specification's principle of validating length calculations against allocated sizes.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 2,
        "reasoning": "The code does not perform pathname expansion or pattern validation. It uses file paths (e.g., fsp->conn->connectpath) but only for logging or passing to VFS functions. No shell-style pattern expansion or syntax validation occurs. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2016-0723_after_subset_100:ba180a6e:spec": {
    "timestamp": "2026-01-17T02:34:22.000861",
    "cve_id": "CVE-2016-0723",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ba180a6e",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses talloc for memory allocation and TALLOC_FREE for release, which generally maintains ownership semantics. However, there are potential issues: in the FSCTL_CREATE_OR_GET_OBJECT_ID case, memory is allocated with talloc_array(ctx, char, 64) but the function returns NT_STATUS_OK, leaving the caller responsible for freeing. This is consistent with the API where *_out_data is an output parameter, but ownership transfer must be clearly documented. The code shows awareness of memory management but doesn't explicitly demonstrate strict ownership semantics enforcement.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes file-related operations (sparse files, shadow copies, allocated ranges) and handles some edge cases like zero-length files in FSCTL_QUERY_ALLOCATED_RANGES (checking if st.st_ex_size == 0). However, the specification specifically mentions \"file content processing\" which this code doesn't directly perform - it handles file metadata and control operations rather than content reading/writing. Some edge cases are handled, but not comprehensively for file content.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The code demonstrates good resource cleanup practices. In FSCTL_GET_SHADOW_COPY_DATA, shadow_data is properly freed with TALLOC_FREE in multiple error paths and success path. Memory allocated with talloc_zero_array is also properly managed. The code maintains consistent state by ensuring resources are cleaned up before returning error statuses. However, not all execution paths are explicitly shown (some early returns don't have cleanup for partially allocated resources, but talloc's parent-child relationships may handle this).",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain any XML parsing functionality. It handles Windows filesystem control operations (FSCTL) which are binary protocols, not XML-based. The specification about XML parsers and external entity processing is completely irrelevant to this C code that deals with SMB filesystem operations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Similar to spec 4, this specification about document processing and entity resolution boundaries is completely unrelated to the target code. The code implements filesystem control operations for an SMB server, not document processing of any kind (XML, PDF, Office documents, etc.).",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2021-4154_before_subset_100:ae35f13a:spec": {
    "timestamp": "2026-01-17T02:34:39.018815",
    "cve_id": "CVE-2021-4154",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ae35f13a",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code handles string parameters (e.g., `release_agent`, `name`) by reassigning pointers (`param->string = NULL`) after taking ownership, which relates to memory ownership semantics. However, it's not a classic memory release operation like free(), but a transfer of responsibility for the string memory from the parameter to the context.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes input parameters, not file content. It does handle an edge case for an empty name (`!param->size`), which shows some consideration for input validation, but the specification's primary focus on file processing is not directly applicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple return paths. It maintains state consistency by checking for duplicate specifications (e.g., `release_agent`, `name`, `source`) and returning an error, and by setting `param->string = NULL` to prevent double use. However, it's not a complex resource cleanup scenario.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a cgroup parameter parser, not an XML parser. The specification is completely irrelevant to this context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns document processing and entity resolution, which has no relation to the kernel cgroup configuration parsing code.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code gates the `name` option behind a boot parameter check (`cgroup_no_v1_named`), which is a direct example of a security-sensitive feature (named cgroups in v1) being controlled by an explicit configuration. It also checks if controllers are enabled/disabled before allowing them in the mask.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification is about deallocating linked structures. This code does not deallocate any linked lists or complex structures; it primarily parses and validates parameters for a filesystem context.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification focuses on establishing isolation during resource cleanup. This function is about setup and configuration parsing, not cleanup. The weak connection is that it ensures parameters aren't applied twice, maintaining a kind of state isolation.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2016-0723_after_subset_100:f4ffff00:spec": {
    "timestamp": "2026-01-17T02:35:56.148213",
    "cve_id": "CVE-2016-0723",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f4ffff00",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code handles string parameters (e.g., `source`, `release_agent`, `name`) by reassigning the pointer (`param->string = NULL`) after taking ownership (`ctx->release_agent = param->string`). This demonstrates an awareness of ownership transfer to prevent double-free or use-after-free, aligning with the principle of maintaining strict ownership semantics during memory operations.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about processing file contents and handling edge cases like empty files. The target code parses configuration parameters for a cgroup filesystem context, not file contents. The check for an empty name (`!param->size`) is related to input validation of a string parameter, not file content processing.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple return paths. It consistently uses `invalf`/`invalfc` for error returns and sets `param->string = NULL` when transferring ownership of string parameters to the context (`ctx`). This helps maintain a consistent state by ensuring the original parameter doesn't retain a pointer to freed or reassigned memory. However, the cleanup of other allocated resources within `ctx` on error paths is not shown in this snippet.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is specifically about XML parsers and disabling external entity processing. The target code is a kernel function for parsing cgroup v1 mount options and has no relation to XML parsing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns document processing and entity resolution, likely in the context of XML or similar formats. The target code processes simple key-value pair parameters for filesystem mounting and is unrelated to document processing or entity resolution.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code directly implements gating of security-sensitive features behind explicit configuration or checks. For example, the `name` option is blocked if `cgroup_no_v1_named` boot parameter is set. Also, subsystem (controller) usage is explicitly checked for being enabled and not disabled (`cgroup_ssid_enabled(i)`, `cgroup1_ssid_disabled(i)`). This aligns strongly with the specification's principle.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification is about deallocating linked structures and maintaining neighbor relationships. The target code does not perform any deallocation of linked lists or similar structures. Its memory operations are limited to pointer reassignment for string parameters.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification focuses on establishing complete isolation during resource cleanup. The code's transfer of string pointer ownership (`param->string = NULL`) can be seen as a step to isolate the `fs_parameter` from the resource it previously referenced. However, this is a minor aspect of the function, and the broader concept of \"complete isolation state\" during cleanup is not the primary focus of the shown code paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2017-8068_before_subset_100:cbaf701b:spec": {
    "timestamp": "2026-01-17T02:36:03.108698",
    "cve_id": "CVE-2017-8068",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cbaf701b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves memory resource management (alloc_etherdev, devm_ioremap_resource) and has an error path that calls free_netdev. While it uses managed resources (devm_ioremap_resource), the free_netdev in the error path must correctly handle ownership semantics to avoid double-free or leaks if other resources were partially initialized. This aligns with memory ownership principles.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "Specification is about file content processing edge cases. The target code is a device driver probe function dealing with device tree and hardware resources, not file I/O or file content processing. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple resource acquisition steps (alloc_etherdev, platform_get_resource, devm_ioremap_resource, of_parse_phandle) and a single error cleanup path using 'goto error'. It must ensure all acquired resources are properly cleaned up in all failure scenarios to maintain consistent state. The current structure appears to handle this, making the specification directly applicable.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 3,
        "reasoning": "Specification mentions \"Network feature declarations must precisely match implementation capabilities\". The code sets ndev->flags &= ~IFF_MULTICAST, which is a feature declaration. However, the specification title is \"HS-MEM-003\" (duplicate numbering with spec 1), suggesting a possible mislabel. The actual content about network features has weak connection to the main memory/resource management focus of the code.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 3,
        "reasoning": "Specification is about packet processing and validating fragment counts against buffer space. The target code is a probe/initialization function, not a packet processing path. It initializes buffer indices (next_tx_buf_to_use, next_rx_buf_to_use) but doesn't process packets. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 4,
        "reasoning": "Specification is about feature negotiation with capability verification. The code reads device tree properties (xlnx,tx-ping-pong, xlnx,rx-ping-pong) via get_bool(), which could be seen as simple feature negotiation. However, there's no complex negotiation or verification against hardware capabilities shown. Weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      },
      {
        "score": 2,
        "reasoning": "Specification is about DMA operations requiring heap-allocated buffers with VMAP_STACK. The code doesn't show any DMA buffer allocation; it deals with MMIO mapping (devm_ioremap_resource) and network device structure allocation. No DMA operations are present in this probe function.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 2,
        "reasoning": "Specification is about USB control message handlers validating buffer allocation. This is an Ethernet driver, not USB, and the code doesn't handle control messages or buffer transfers in the shown probe function. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      }
    ]
  },
  "CVE-2016-10764_after_subset_100:596b08dc:spec": {
    "timestamp": "2026-01-17T02:36:15.089401",
    "cve_id": "CVE-2016-10764",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "596b08dc",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates a network device (ndev) using alloc_etherdev and later may free it via free_netdev in the error path. This involves memory ownership and release. The specification about memory release maintaining strict ownership semantics is strongly relevant, as the function must ensure the allocated device is properly freed on error paths and not double-freed. The current code shows a single free_netdev in the error label, which is correct, but the relevance is high because memory ownership management is central to the function's cleanup logic.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The specification about file content processing and edge cases like empty files is very low relevance. This code is a device driver probe function dealing with device tree resources, IRQs, memory mapping, and network device registration. There is no file reading or file content processing involved.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple resource acquisitions (IRQ, memory mapping, netdev allocation) and a single error cleanup path (goto error). The specification about resource cleanup maintaining consistent state across all execution paths directly applies. The code must ensure that if an error occurs after some resources are acquired, all allocated resources are properly cleaned up before returning. The current error handling uses a goto to free_netdev, but other resources like devm_ioremap_resource are managed via devm, which may auto-clean. This is a key secure coding concern for device drivers.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      }
    ]
  },
  "CVE-2017-9499_before_subset_100:a0ecf0e7:spec": {
    "timestamp": "2026-01-17T02:36:18.738140",
    "cve_id": "CVE-2017-9499",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a0ecf0e7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the dirLength field (TIFF IFD entry count) against a maximum threshold of 500, which is a form of dimension validation. However, it doesn't validate against the actual file data size, only against an arbitrary limit to prevent excessive processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 7,
        "reasoning": "The code performs some dimension checking before memory allocation (checking dirLength before reading entries, checking type validity). However, the buffer allocation \"DataBuf buf(size*count + pad+20)\" uses unchecked multiplication of size and count, which could overflow. The check for type validity helps prevent some invalid allocations.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 1,
        "reasoning": "This specification about IPP (Internet Printing Protocol) attribute values is completely unrelated to the TIFF/EXIF image parsing code shown. The code deals with image metadata, not printing protocols.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "This specification about printer configuration files is completely unrelated to the image parsing functionality in the target code.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "This IPP protocol specification is irrelevant to the TIFF/EXIF image parsing code, which doesn't implement any network printing protocols.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code validates dirLength > 500 before processing, which is an upper bounds check. However, it doesn't validate the multiplication \"size*count\" before buffer allocation, which could lead to integer overflow. The check happens after the arithmetic operation in the buffer allocation.",
        "spec_index": 5,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates multiple numeric fields: dirLength (IFD entry count), type validity, and performs bounds checking on count values for display purposes. The validation of type before processing prevents invalid type values from causing issues. However, it could be more comprehensive (e.g., checking offset values against file size).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code shows multiple memory management patterns: DataBuf objects with RAII-style management, explicit delete[] operations for dynamically allocated byte arrays in specific code paths (IPTC and MakerNote handling). The ownership semantics appear clear with proper cleanup, though manual new/delete in some branches could be risky if exceptions occur.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      }
    ]
  },
  "CVE-2016-7101_after_subset_100:3bf5df09:spec": {
    "timestamp": "2026-01-17T02:36:30.193595",
    "cve_id": "CVE-2016-7101",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3bf5df09",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the `dirLength` field (number of directory entries) against a maximum threshold (500) before processing, which is a form of dimension validation. However, it does not appear to validate image dimensions (like width/height) against the actual file size, which is the more typical interpretation of this specification. The relevance is strong because the principle of validating parsed structural metadata against safe limits is present.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 9,
        "reasoning": "The code performs a critical safe dimension check before memory allocation. It calculates `allocate = (long long) (size*count + pad+20)` and checks if `allocate > (long long) io.size()`. This prevents excessive memory allocation based on untrusted file data, which is the core intent of this specification. The check is directly tied to the allocation size.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 1,
        "reasoning": "The code is parsing TIFF/Exif image metadata, not IPP (Internet Printing Protocol) attributes. There is no relevance to IPP processing or validation.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code processes image file structures (TIFF/IFD), not printer configuration files. The specification is about a different domain and file type.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The code implements a TIFF/Exif structure parser, not an IPP protocol implementation. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 7,
        "reasoning": "The code validates numeric fields (`dirLength`, and implicitly `count` and `size` through the allocation size check) before using them in arithmetic operations (e.g., `size*count`). The upper bound check on `dirLength` (500) and the allocation size check against `io.size()` enforce bounds. However, the check on `dirLength` is a hardcoded limit rather than a dynamic one based on file constraints, making it moderately relevant.",
        "spec_index": 5,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The code validates multiple numeric fields from the file format: `dirLength` is checked against 500, `type` is validated via `typeValid(type)`, and the combined `size*count` is validated against the file size before allocation. These are direct applications of validating file format numeric fields against reasonable constraints to prevent abuse.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      },
      {
        "score": 6,
        "reasoning": "The code contains dynamic memory allocation and release (`new[]`/`delete[]` for IPTC and MakerNote data). While it appears to correctly pair allocations and deallocations within the same scope, the specification about \"maintaining strict ownership semantics\" is broadly about preventing issues like double-free or use-after-free. The code shows manual management, which carries risk, but doesn't explicitly demonstrate a violation. The relevance is moderate as memory release is present and the principle applies.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      }
    ]
  },
  "CVE-2022-30975_before_subset_100:7f091387:spec": {
    "timestamp": "2026-01-17T02:37:42.976355",
    "cve_id": "CVE-2022-30975",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7f091387",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve any dynamic memory allocation or release operations. It is a syntax dumping/printing function that outputs formatted text based on an AST. There are no ownership semantics to manage.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 4,
        "reasoning": "The code processes an abstract syntax tree (AST) to generate output, not file content. While it could be considered a form of data processing, the specification about handling edge cases in file content (like empty files) is only weakly connected to this code's purpose of printing a syntax tree.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function does not acquire or manage any system resources (like file handles, memory, locks) that require cleanup. Its execution paths are simple and do not create inconsistent state that needs to be resolved.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a JavaScript syntax dumper, not an XML parser. The specification about disabling external entity processing in XML parsers is completely irrelevant to this context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns document processing and entity resolution boundaries, typically for formats like XML. This code processes JavaScript ASTs and outputs text, which does not involve entity resolution.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "There is moderate relevance. The function uses a `minify` flag (set from the `dominify` parameter) to control output formatting. This resembles a configuration option that gates a feature (minified vs. pretty-printed output). While not \"security-sensitive\" in a critical sense, it is a behavior-controlling option.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The code does not process IPP (Internet Printing Protocol) attributes. It is part of a JavaScript interpreter/compiler's utility functions for dumping syntax trees.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not process printer configuration files. It is unrelated to printing systems or file sanitization for such systems.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2018-20749_before_subset_100:a53a06a0:spec": {
    "timestamp": "2026-01-17T02:37:47.252426",
    "cve_id": "CVE-2018-20749",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a53a06a0",
    "scores": [
      {
        "score": 3,
        "reasoning": "Specification HS-MEM-003 is about memory release operations and ownership semantics. The target code primarily deals with file I/O, network transfers, and file system operations. While there are calls to functions like `close(f)` and `unlink(atomic_file)`, these are resource cleanup for file descriptors and files, not dynamic memory management. No explicit memory allocation or freeing (e.g., malloc/free) is visible in this snippet, making the specification's focus on memory ownership largely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "Specification HS-INPUT-004 is about handling all edge cases in file content processing, including empty files. The code shows explicit handling for file size (e.g., `st.st_size > (off_t) 0`), restart/append logic, and truncation. It also manages zero-byte files (e.g., the comment about anonymous users overwriting 0-byte files). However, the specification is broadly about file content processing, and this function is more about the upload protocol and file system state than deep content inspection.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-001 is about validating IPP (Internet Printing Protocol) attribute values. The target code is an FTP server file upload function (`dostor`). There is no reference to IPP, printing, or attribute processing. The context is completely different (FTP vs. IPP), making this specification essentially irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-002 concerns sanitizing printer configuration files before processing. The code is for FTP file uploads, not printer configuration management. The function validates filenames (`checknamesanity`) and handles file system operations, but this is unrelated to printer configuration files or their sanitization.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-PROTOCOL-003 is about enforcing strict message parsing in IPP protocol implementations. The code implements part of an FTP server's file upload process, dealing with data channels and file I/O. While it may involve parsing FTP commands at a higher level, this snippet does not show protocol message parsing. The specification is tied to IPP, a different protocol altogether.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-MEM-001 is about verifying allocation ownership before freeing memory. Similar to spec_1, this code snippet does not show dynamic memory allocation or deallocation. Resources like file descriptors and files are cleaned up, but these are not heap-allocated memory. The specification's core concept does not apply here.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory release operations must verify allocation ownership before freeing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 is about maintaining consistent state during dynamic growth of input. The code handles file uploads where data is dynamically written to a file, potentially growing it. It manages state like `filesize`, `restartat`, and quota tracking during this growth. However, the specification seems more focused on input buffers or data structures that resize, whereas here the \"growth\" is of a file on disk. The principle of state consistency during growth is partially applicable.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must maintain consistent state during dynamic growth"
      }
    ]
  },
  "CVE-2016-5418_after_subset_100:1cb494d2:spec": {
    "timestamp": "2026-01-17T02:37:51.124664",
    "cve_id": "CVE-2016-5418",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1cb494d2",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code is an FTP file upload function that primarily deals with file I/O, path validation, and quota management. While it uses local variables and potentially dynamic memory elsewhere (not shown), there are no explicit memory allocation or release operations (like malloc/free) visible in this snippet. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory release operations must verify allocation ownership before freeing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must maintain consistent state during dynamic growth"
      }
    ]
  },
  "CVE-2022-30975_after_subset_100:966bfe09:spec": {
    "timestamp": "2026-01-17T02:38:02.887702",
    "cve_id": "CVE-2022-30975",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "966bfe09",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation or release operations. It appears to be a syntax dumper/pretty-printer that outputs formatted text. There are no malloc/free or similar ownership transfer operations visible in this snippet.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes abstract syntax tree structures, not file content. While it handles program syntax representation, it doesn't read from files. The \"empty file\" edge case isn't directly applicable, though it does check if 'prog' is NULL.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple execution paths (if-else branches) but doesn't manage resources like file handles, memory, or network connections. The only potential resource is standard output, which doesn't require cleanup. State consistency is maintained through the 'minify' variable.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a JavaScript syntax dumper, not an XML parser. It processes abstract syntax trees, not XML documents, so XML external entity processing is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "This specification relates to document processing and entity resolution boundaries, which doesn't apply to JavaScript syntax dumping. The code doesn't process documents or resolve external entities.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The 'minify' parameter controls output formatting behavior, which could be considered a security-sensitive feature if output affects downstream parsing. However, it's passed as a parameter rather than being gated behind explicit configuration options in this function.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "This specification relates to IPP (Internet Printing Protocol) attribute validation. The code is a JavaScript syntax dumper and has nothing to do with IPP or printer protocols.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2022-1795_before_subset_100:24fab362:spec": {
    "timestamp": "2026-01-17T02:38:21.401109",
    "cve_id": "CVE-2022-1795",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "24fab362",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code manipulates node reference counts (`node->sgprivate->num_instances = 2`) and calls `gf_node_unregister`. This directly relates to memory ownership and release semantics. If the reference counting is incorrect (e.g., not decremented properly on all error paths), it could lead to memory leaks or use-after-free vulnerabilities, making HS-MEM-003 highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code parses data from a bitstream (`GF_BitStream *bs`), not a traditional file. While it processes input, the specification specifically mentions \"empty files,\" which is a very specific edge case not directly applicable to the stream parsing logic shown. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The function has multiple execution paths (success, error returns `GF_NON_COMPLIANT_BITSTREAM`). It must ensure proper resource cleanup (unregistering old `global_qp`, managing `ActiveQP` state) on all paths to avoid inconsistent state, double-frees, or memory leaks. The current code shows some cleanup but a full analysis of all error paths is needed.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is for image parsers validating dimensions. This code is for parsing a scene graph quantization parameter from a MPEG-4 BIFS bitstream. It does not process image data or dimensions. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 2,
        "reasoning": "Similar to spec_4, this is for file format readers performing dimension checking before allocation. The target code decodes a node from a bitstream, which may involve allocation internally (`gf_bifs_dec_node`), but the core logic shown does not deal with dimensional data or the associated safety check described in the spec.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The specification is explicitly for XML parsers and disabling external entity processing. The target code parses a binary MPEG-4 BIFS stream, not XML. The specification basically doesn't apply.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns document processing and entity resolution boundaries, likely in the context of XML or similar structured documents. The target code handles a binary graphics stream, making this specification irrelevant.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code sets a global quantization parameter (`global_qp`) for a scenegraph. While modifying global rendering state could have security implications (e.g., resource consumption), the code does not show this feature being gated behind a configuration option. The connection is weak, as the spec's principle of protecting sensitive state is tangentially related but not implemented here.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2013-2124_after_subset_100:4d5e333f:spec": {
    "timestamp": "2026-01-17T02:39:17.129986",
    "cve_id": "CVE-2013-2124",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4d5e333f",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory/object management via `gf_node_unregister` calls. Specification HS-MEM-003 about maintaining strict ownership semantics is strongly relevant. The code calls `gf_node_unregister(node, NULL)` twice on the same node, which could indicate a double-release or ownership transfer issue if the function decrements a reference count. This pattern requires careful ownership tracking to avoid use-after-free or double-free scenarios.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "Specification HS-INPUT-004 about handling file content edge cases is very low relevance. The code parses a bitstream structure for a specific node type, but it's not processing a generic file, nor are empty file edge cases a primary concern in this function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "Specification HS-STATE-002 about resource cleanup maintaining consistent state is moderately relevant. The function manages the global quantizer pointer (`codec->scenegraph->global_qp` and `codec->ActiveQP`) and must ensure they are correctly set or reset across all execution paths (including error returns). The early error return path does reset some state but may leave `codec->ActiveQP` inconsistent if it was previously set.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-001 for image parsers validating dimensions is not relevant. This code deals with MPEG-4 BIFS scene graph decoding, not image parsing or dimension validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-001 for XML parsers disabling external entities is not relevant. This is a binary bitstream parser, not an XML parser.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-002 about document processing and entity resolution boundaries is not relevant. The code processes a binary scene graph command, not a document with external entities.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-CONF-003 about gating security-sensitive features is weakly relevant. The function sets a global quantization parameter which could affect rendering/processing behavior. While not obviously a security feature, changes to global state could have side-effects, but the connection to explicit configuration options is tenuous.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2018-1000085_before_subset_100:6cdc455d:spec": {
    "timestamp": "2026-01-17T02:39:34.746993",
    "cve_id": "CVE-2018-1000085",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6cdc455d",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code performs validation of image dimensions (data_width, data_height) against a threshold to prevent excessive memory allocation. It also checks for negative dimensions and validates that the total data size (width * height * channels) is not zero or excessively large (e.g., >= 0x4000000000 on 64-bit). This directly aligns with validating claimed dimensions against practical limits before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 9,
        "reasoning": "The code implements multiple dimension checks before memory allocation: it validates data_width/data_height are non-negative, checks against a heuristic threshold (1024*8192), and verifies total_data_len is not zero or overly large. These checks occur before calling AllocateImage, which is a safe dimension checking practice.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 2,
        "reasoning": "The code shows memory allocation (calloc for tiles, AllocateImage) but doesn't demonstrate memory release operations or ownership semantics in this function. The specification focuses on release operations which aren't visible in this code snippet.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The code handles some edge cases like checking for zero data_len, insufficient data size, and invalid dimensions. However, it doesn't explicitly show handling of completely empty files at the function entry point - it assumes offsets and data exist.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "While the function returns error codes consistently, it doesn't show comprehensive resource cleanup on error paths. For example, if an error occurs after allocating tiles with calloc, there's no visible cleanup code. The specification focuses on maintaining consistent state during cleanup which isn't fully demonstrated.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 8,
        "reasoning": "The code performs numeric validation before arithmetic operations: checks data_width/data_height bounds before calculating total_data_len, validates tile coordinates before use, and checks data_len against data_size. It also includes overflow checks for line_no calculation.",
        "spec_index": 5,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 9,
        "reasoning": "The code extensively validates numeric fields: tile_size_x/y, data_width/height, line_no, data_len, tile_coordinates, and offsets against size constraints. It validates both individual fields and their combinations against reasonable constraints.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      },
      {
        "score": 8,
        "reasoning": "The code validates size parameters in buffer operations: checks offsets against size before memcpy operations, validates data_len against data_size, and uses size_t for size calculations. However, it uses signed int for some size comparisons which could benefit from more explicit signedness validation.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      }
    ]
  },
  "CVE-2018-1000085_after_subset_100:29d7f7ef:spec": {
    "timestamp": "2026-01-17T02:39:38.325484",
    "cve_id": "CVE-2018-1000085",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "29d7f7ef",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code performs validation of image dimensions (data_width, data_height) against a threshold (1024*8192) and checks for negative values. It also validates tile sizes and checks if offsets exceed the input data size. This directly aligns with validating claimed dimensions against actual file data size.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 9,
        "reasoning": "The code performs dimension checking (data_width, data_height, tile_size_x, tile_size_y) before memory allocation in AllocateImage calls. It also checks for overflow in total_data_len calculation. This is a strong implementation of safe dimension checking before allocation.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 2,
        "reasoning": "The code shows memory allocation (calloc, AllocateImage) but doesn't show corresponding cleanup or release operations in this function. The specification about memory release ownership semantics cannot be evaluated from this code snippet alone.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The code handles some edge cases like zero or negative dimensions, insufficient data size, and data_len == 0. However, it's not clear if it handles completely empty files at the entry point. The validation of offsets against size provides partial edge case handling.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "The code doesn't show comprehensive resource cleanup in error paths. While it returns error codes, there's no evidence of cleanup for allocated resources (like exr_image->tiles) in failure cases. This specification has weak relevance to the shown code.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 8,
        "reasoning": "The code performs numeric validation before arithmetic operations: checks data_width/data_height before calculations, validates tile coordinates, checks line_no bounds, and performs overflow check in lno calculation. This demonstrates good practice in validating numeric inputs before use.",
        "spec_index": 5,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 9,
        "reasoning": "The code extensively validates numeric fields: image dimensions, tile sizes, line numbers, data lengths, and offsets. It checks against reasonable constraints (threshold, 2<<20 for line_no, etc.). This is a strong implementation of numeric field validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      },
      {
        "score": 8,
        "reasoning": "The code validates size parameters in multiple places: checks offsets against size, validates data_len against data_size, and uses size_t for size calculations. It handles signed/unsigned comparisons properly in most cases, though some int/size_t mixing exists.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      }
    ]
  },
  "CVE-2019-11470_before_subset_100:50528e8e:spec": {
    "timestamp": "2026-01-17T02:39:58.212312",
    "cve_id": "CVE-2019-11470",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "50528e8e",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a regex engine implementation in C, not an XML parser. There is no XML processing or external entity handling involved.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code does not process documents or entities. It is a low-level regex matching function operating on character buffers.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the code has configurable features (like FEAT_RELTIME, FEAT_SYN_HL), they are compile-time options, not runtime security-sensitive features gated behind explicit configuration. The main logic is about regex matching, not security feature enablement.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code manages dynamic memory through ga_grow() calls and maintains stacks (regstack, backpos). While it doesn't explicitly show free operations with ownership verification, the pattern of growing arrays and maintaining lengths relates to memory management principles. However, the specification focuses on free operations, which are not visible in this function.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory release operations must verify allocation ownership before freeing"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function processes input (rex.input) and maintains complex state (regstack, backpos, brace_count, etc.) during dynamic pattern matching. It must ensure state consistency when backtracking (reg_restore), advancing input (ADVANCE_REGINPUT), and handling line breaks (reg_nextline). The core challenge is maintaining consistent state during the regex engine's growth through backtracking and recursion.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input processing must maintain consistent state during dynamic growth"
      },
      {
        "score": 1,
        "reasoning": "The code is not an image parser. It processes regular expressions on text buffers.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 1,
        "reasoning": "The code does not read file formats or allocate memory based on dimensions from a file. It operates on in-memory regex programs and text buffers.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code performs arithmetic on positions (lnum, col), counts (brace_count, rst->count), and lengths, but these are primarily used for comparisons and loop control, not for memory allocation based on layout dimensions. There is some length calculation (e.g., STRLEN) but no evident overflow checks for arithmetic operations.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-001: All arithmetic operations on layout dimensions must include overflow checks"
      }
    ]
  },
  "CVE-2019-19012_after_subset_100:0edb9d84:spec": {
    "timestamp": "2026-01-17T02:40:14.481315",
    "cve_id": "CVE-2019-19012",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0edb9d84",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a regex matching engine (regmatch) from Vim/Neovim. It does not involve XML parsing or external entity processing. The specification is about XML security, which is completely unrelated to this regex engine implementation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns document processing and entity resolution boundaries, typically for XML/HTML parsers. This regex matching code processes character patterns, not documents with entities, making this specification irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code manages dynamic memory through ga_grow() calls and maintains stacks (regstack, backpos). While not showing explicit ownership verification before freeing, the pattern of careful stack management and the comment about reducing malloc()/free() calls shows awareness of memory management concerns central to this specification.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory release operations must verify allocation ownership before freeing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The regex engine processes input dynamically, maintains state (rex.input, rex.line, rex.lnum), and handles backtracking via regstack and backpos. The code must maintain consistent state during input advancement and backtracking, which is exactly what this specification addresses.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input processing must maintain consistent state during dynamic growth"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is a regex matching engine, not an image parser. It doesn't process image dimensions or file data sizes.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. While not a file format reader, the code does process input patterns and uses ga_grow() for dynamic memory allocation. There's some indirect connection to safe dimension checking before allocation, but not in the file format context specified.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs arithmetic operations on positions (rex.input - rex.line), line numbers, and uses ga_grow() with size calculations. While not explicitly showing overflow checks in all arithmetic, the pattern of careful bounds checking (like checking p_mmp limit) shows awareness of dimension safety concerns.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-001: All arithmetic operations on layout dimensions must include overflow checks"
      }
    ]
  },
  "CVE-2013-7459_before_subset_100:9ed340dc:spec": {
    "timestamp": "2026-01-17T02:41:03.249614",
    "cve_id": "CVE-2013-7459",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9ed340dc",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code dynamically allocates memory for `key` and `outbuf` using `emalloc` and must free them correctly. It maintains ownership semantics by checking `if (key != (unsigned char*)password)` before freeing `key`, ensuring it only frees memory it allocated. This aligns with the principle of strict ownership.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about file content processing and edge cases for empty files. The target code processes string data for encryption, not file content. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "The code must clean up resources (allocated memory, OpenSSL context) across multiple execution paths (success, failure after `EVP_EncryptFinal`). It performs cleanup in both success and error paths, though a more detailed analysis is needed for all potential early returns. The principle of consistent state cleanup is highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for image parsers validating dimensions. The target code is a symmetric encryption function and has no relation to image parsing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The specification is for file format readers performing dimension checks before allocation. The target code performs encryption and allocates an output buffer based on data size and cipher block size, which is a different context. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The specification is about deallocating linked structures while maintaining neighbor relationships. The target code deals with simple buffers and an OpenSSL context, not linked data structures.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The code cleans up the OpenSSL cipher context (`EVP_CIPHER_CTX_cleanup`) and dynamically allocated memory. This establishes an isolation state by releasing resources. However, the specification's emphasis on \"complete\" isolation is broadly applicable but not the core focus of this function.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "The code uses `memcpy` to copy the password into a newly allocated key buffer. It validates that the source length (`password_len`) is not greater than the destination size (`keylen`) in the condition `if (keylen > password_len)`. However, it does not explicitly handle the signedness of these `int` parameters, which could be relevant for security. The principle has moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      }
    ]
  },
  "CVE-2021-46664_before_subset_100:ac700691:spec": {
    "timestamp": "2026-01-17T02:41:19.592325",
    "cve_id": "CVE-2021-46664",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ac700691",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code involves managing a linked list of query units (`SELECT_LEX_UNIT`) and performing operations that may exclude units (`exclude_level()`). While there is potential for memory or resource management issues if ownership semantics are violated during these exclusions or iterations, the code does not explicitly show memory allocation or deallocation. The relevance is weak as the specification focuses on memory release ownership, which is not a central theme here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code is related to SQL query optimization and subquery processing in a database engine. It does not involve file content processing, reading files, or handling file-related edge cases. The specification is completely unrelated to this context.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function manages query execution state, saves and restores context variables (like `save_select`, `save_options`), and must ensure proper cleanup and state consistency across multiple execution paths (e.g., early returns on error, loops through subqueries). This aligns with the principle of maintaining consistent state during resource management, though the primary resources here are query execution contexts, not system resources like memory or files.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is for SQL query optimization and has no relation to XML parsing, external entities, or any markup language processing. The specification is irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, this specification concerns document processing (e.g., XML, HTML) and entity resolution, which is unrelated to the SQL subquery optimization code provided.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code checks for the `SELECT_DESCRIBE` flag (likely related to `EXPLAIN` functionality), which could be considered a security-sensitive feature if it exposes query execution details. However, the gating is a simple flag check, not an explicit configuration option. The connection is weak but present.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The code iterates over a linked structure of query units (`SELECT_LEX_UNIT` and `SELECT_LEX`), using `next_unit()` and `next_select()`. It also calls `exclude_level()` on a unit, which could modify the structure's relationships. Maintaining consistent neighbor relationships during such operations is important to prevent corruption. This has moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The function saves and restores thread/query state (`current_select`, `select_options`) and must ensure isolation between different subquery execution contexts. However, \"complete isolation state\" typically refers to stronger separation (e.g., process/container isolation), not just local variable saving. The relevance is weak to moderate.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2017-13715_after_subset_100:f55c2194:spec": {
    "timestamp": "2026-01-17T02:41:32.535590",
    "cve_id": "CVE-2017-13715",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f55c2194",
    "scores": [
      {
        "score": 8,
        "reasoning": "HS-MEM-003: The code performs memory allocation (emalloc) and deallocation (efree) for key, outbuf, iv, and base64_str. Ownership semantics are critical: `key` is conditionally freed only if it was allocated (key != password), and `iv` is freed only if `free_iv` is true. This aligns with the specification's focus on strict ownership, though there is a potential issue if `EVP_DecryptInit_ex` fails before cleanup paths.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "HS-INPUT-004: This specification is about file content processing and edge cases for empty files. The target code processes string inputs (data, password, iv) for decryption, not file contents. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "HS-STATE-002: The code must clean up multiple resources (key, outbuf, iv, base64_str, cipher_ctx) across different success/error paths. The current cleanup happens at the end but may be incomplete if an error occurs early (e.g., if EVP_DecryptInit_ex fails, the allocated outbuf and possibly key/iv may not be freed). This violates consistent state cleanup across all execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "HS-INPUT-001: This specification is specifically for image parsers validating dimensions against file size. The target code is an OpenSSL decryption function with no image processing. It is not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 2,
        "reasoning": "HS-IO-002: This specification concerns file format readers performing safe dimension checking before allocation. The code does allocate memory (outbuf) based on data_len and cipher block size, but it's not reading a file format with dimensions. The connection is very low.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-003: This is a duplicate ID (also seen in spec 1) but with a different description about linked structure deallocation and neighbor relationships. The code does not involve linked structures (it's simple buffers). Not relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "HS-STATE-004: The code performs resource cleanup (freeing memory, EVP_CIPHER_CTX_cleanup) to establish isolation. However, as noted in spec 3, cleanup may not be complete on all error paths, so the \"complete isolation state\" is not fully guaranteed. The principle is relevant but not perfectly implemented.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-001: The code has buffer copy operations (memcpy for key expansion) where size parameters involve keylen and password_len. It ensures keylen > password_len before memcpy, which is safe. However, it does not explicitly validate against signedness issues (all lengths are ints, but comparisons are signed). Moderate relevance as the principle applies but the risk is low here.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      }
    ]
  },
  "CVE-2021-46664_after_subset_100:84bf2b44:spec": {
    "timestamp": "2026-01-17T02:41:44.285946",
    "cve_id": "CVE-2021-46664",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "84bf2b44",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves managing query execution units and their state, which may involve memory allocation and deallocation for JOIN structures and subquery components. However, the code does not explicitly show memory release operations. The relevance is moderate because the principle of maintaining ownership during state changes (like `exclude_level()` and managing `uncacheable` flags) is present, but it's not a direct memory management scenario.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code is related to SQL query optimization and subquery execution, not file content processing. There is no handling of files, empty or otherwise. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The code manages resource state (query execution plans, correlation flags, cacheability) across multiple execution paths (e.g., loops through UNION subqueries, early returns on error). It ensures consistent state by updating flags (`uncacheable`, `is_correlated`) and restoring context (`save_select`, `save_options`). This aligns with the principle of maintaining consistent state during resource management, though not explicitly about cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is for SQL query optimization in a database system. It does not involve XML parsing or any external entity processing. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code is for SQL subquery optimization, not document processing (XML, HTML, etc.). There is no entity resolution involved. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code includes conditional behavior based on flags like `SELECT_DESCRIBE` (for EXPLAIN) and `const_only`. While these are configuration-like options influencing security-sensitive query execution (e.g., optimization paths), they are not primarily security gates. The relevance is weak.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The code manipulates linked structures of SQL query units (`SELECT_LEX_UNIT`, `SELECT_LEX`) using `next_unit`, `first_select()`, `next_select()`. It maintains relationships when excluding units (`exclude_level()`) and iterating. This directly relates to managing neighbor relationships in linked structures during traversal and modification, though not explicitly for deallocation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The code performs state isolation by saving/restoring context (`save_select`, `save_options`) and managing correlation flags to ensure proper execution isolation for subqueries. However, it's more about execution state than resource cleanup (e.g., memory, handles). The relevance is weak to moderate.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2017-9499_before_subset_100:63506481:spec": {
    "timestamp": "2026-01-17T02:42:19.901603",
    "cve_id": "CVE-2017-9499",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "63506481",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory for `msh` using `calloc` and frees it using `free` in several error paths via `longjmp`. However, the ownership semantics are complicated by the use of `setjmp`/`longjmp` for error handling. The memory is freed in the error handler after `longjmp`, which maintains ownership but introduces non-local control flow. This is relevant to strict ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The code processes file content (mesh files) and includes checks for file opening failures and read errors. It handles some edge cases like invalid version numbers or dimensions, but it's not clear if it explicitly handles empty files (e.g., reading from an empty file might lead to EOF checks). The relevance is moderate as file content processing is central to the function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Resource cleanup (file handles `msh->hdl` and `msh->FilDes`, allocated memory `msh`) is performed in multiple execution paths, including the error handler after `longjmp` and normal error returns. The code ensures resources are released consistently across different error conditions, making this highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2016-7101_after_subset_100:d2e06400:spec": {
    "timestamp": "2026-01-17T02:42:54.472264",
    "cve_id": "CVE-2016-7101",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d2e06400",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `calloc` to allocate memory for `msh` and `free` to release it. Ownership is clear, and `free` is called in multiple error paths via `longjmp` and the final `else` block. However, the use of `longjmp` for error handling complicates the control flow, and it's crucial that all resources (memory, file handles) are cleaned up consistently. The code attempts this, but the pattern is error-prone.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The code processes file content (both binary and ASCII mesh files). It checks for EOF and handles some error cases (e.g., missing \"MeshVersionFormatted\" or \"Dimension\" tags). However, it does not explicitly handle empty files; for binary files, it attempts to read the endian tag, which could fail on an empty file, leading to a longjmp. Edge case handling is present but not exhaustive.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The function manages multiple resources: dynamically allocated memory (`msh`), file descriptors (`FilDes`), and file pointers (`hdl`). It uses a `setjmp`/`longjmp` error handling scheme, which must ensure all resources are cleaned up on every error path. The code shows cleanup for both `hdl` and `FilDes` in the initial error handler, and `free(msh)` is called in several places. Consistency across all paths is critical and mostly achieved, though complex.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "This specification is for image parsers validating dimensions against file size. The target code is a mesh file parser, not an image parser. While it reads a `dim` (dimension) field, it does not validate it against the actual file data size. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The code reads a mesh dimension (`msh->dim`) from the file and validates it (must be 2 or 3). However, this check occurs *after* the dimension is read and before any major allocation based on that dimension (the function itself doesn't allocate mesh data arrays; that likely happens elsewhere). The principle of validating dimensions before use is partially present, but the primary allocation here is for the `GmfMshSct` structure itself, not dimension-dependent data.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for XML parsers and disabling external entity processing. The target code parses custom binary/ASCII mesh formats, not XML. It does not involve any XML processing. Relevance is basically non-existent.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns document processing and entity resolution boundaries, likely in the context of XML or similar structured documents. The target code does not process documents with entities. It reads simple keywords and numerical data. Relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code uses a compile-time flag `WITH_GMF_AIO` to switch between POSIX I/O (`open`/`read`/`close`) and standard C I/O (`fopen`/`fread`/`fclose`). This is a feature gated behind configuration, but it's not clearly a \"security-sensitive\" feature. The choice of I/O API could have performance implications but minimal direct security impact in this context. Weak relevance.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2017-18257_before_subset_100:7e088572:spec": {
    "timestamp": "2026-01-17T02:43:04.702611",
    "cve_id": "CVE-2017-18257",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7e088572",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not explicitly perform memory release operations. It allocates temporary tensors via context->forward_input_or_allocate_temp, and the framework likely manages their lifetime. There is no manual memory management (like malloc/free or new/delete) where strict ownership semantics would be critically evaluated. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes tensor data, not file content. The specifications about handling empty files or file content edge cases are not directly applicable. The code does check tensor dimensions and element counts, but this is not related to file I/O. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code allocates a temporary tensor and performs computations, but there is no explicit resource cleanup (like file handles, network connections, or complex state that needs rollback). The TensorFlow framework manages the primary resource lifecycle. The code's execution paths are relatively linear within this function. Relevance is weak.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "While not processing image files, the code validates claimed tensor dimensions (orig_input_tensor_shape) against other input data (row_seq_tensor, col_seq_tensor sizes relative to out_backprop dimensions). This is analogous to validating claimed dimensions against actual data, a core principle of the specification. However, it's for tensors in memory, not file parsing. Relevance is moderate.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, the code performs dimension checking (OP_REQUIRES on row_seq_tensor and col_seq_tensor sizes) before using these dimensions in loops and index calculations, which helps prevent out-of-bounds access. This aligns with the principle of safe dimension checking before operations that depend on those dimensions. It is not about file format readers or memory allocation per se, but the safety concept is relevant. Relevance is moderate.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code validates some input tensor properties (dimensions, element counts) but does not process IPP (Internet Printing Protocol) attributes. The specification is specifically about IPP, which is unrelated to this tensor computation kernel. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code is a TensorFlow op kernel performing numerical backpropagation; it does not process configuration files or any textual data that requires sanitization. Relevance is extremely low.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing strict message parsing in the IPP protocol. The target code is a computational kernel for deep learning, not a network protocol implementation. Relevance is extremely low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      }
    ]
  },
  "CVE-2017-18257_after_subset_100:9d65a7d3:spec": {
    "timestamp": "2026-01-17T02:43:30.321483",
    "cve_id": "CVE-2017-18257",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d65a7d3",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not explicitly perform memory release operations. It allocates a temporary tensor (`in_backprop_tensor_temp`) via `context->forward_input_or_allocate_temp`, whose lifecycle is managed by the TensorFlow framework. While proper resource management is important, the specification about \"strict ownership semantics\" during memory release is not directly applicable to this code's manual memory management patterns.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes tensor data, not file content. The specifications about handling edge cases for empty files are not relevant to this numerical computation kernel.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code allocates temporary resources (tensors) but relies on the TensorFlow runtime for cleanup. There are no explicit cleanup operations or multiple execution paths (like error returns) that require manual state consistency. The framework handles resource cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant principle. The code validates tensor dimensions (e.g., checking `orig_input_tensor_shape` has 4 elements, checking row/col sequence lengths against output dimensions, checking input dimensions are non-zero). This aligns with the core principle of validating claimed dimensions against actual data before processing, even though the data is from tensors, not image files.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs multiple dimension checks (OP_REQUIRES) before using indices to access data and before implicit memory operations via tensor allocation. This follows the principle of safe dimension checking before memory allocation/access, which is central to preventing buffer overflows.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code does not process IPP (Internet Printing Protocol) attributes. This specification is domain-specific and not applicable to this TensorFlow kernel code.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not process printer configuration files. This specification is domain-specific and not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement or parse the IPP protocol. This specification is domain-specific and not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      }
    ]
  },
  "CVE-2019-13302_before_subset_100:bae2a0d2:spec": {
    "timestamp": "2026-01-17T02:43:51.188397",
    "cve_id": "CVE-2019-13302",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bae2a0d2",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes an existing Image structure, but it does not parse dimensions from a file. It operates on already-loaded image data (rows, columns). The function assumes dimensions are valid. Therefore, the specification about validating claimed dimensions against file data size has weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 4,
        "reasoning": "Similar to spec 1, this function is not a file format reader. It is an internal image processing function that transforms an image to grayscale. It does not allocate memory based on dimensions read from a file. The relevance is weak.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This function processes an internal Image structure, not raw file content. Edge cases like an image with zero rows or columns might be handled implicitly by loop conditions (y < 0), but the specification about file content processing (empty files) does not directly apply to this grayscale transformation routine.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      }
    ]
  },
  "CVE-2019-11470_after_subset_100:e4380e83:spec": {
    "timestamp": "2026-01-17T02:44:17.886950",
    "cve_id": "CVE-2019-11470",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e4380e83",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes an existing Image structure but does not parse dimensions from a file. It operates on already-loaded image data (rows, columns). Therefore, it does not directly validate claimed dimensions against file data size, which is a parser's responsibility. Weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 4,
        "reasoning": "Similar to spec 1, this function is not a file format reader. It transforms an image to grayscale, assuming dimensions are already validated. It does allocate memory based on image->colors and MaxColormapSize, but these are not direct image dimensions (width/height). Weak relevance.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code uses ssize_t for indices and loops, which are signed, and performs operations like `colormap_index[intensity]` where intensity is a size_t. There is a potential signed/unsigned mismatch if intensity exceeds SSIZE_MAX, but the code uses ScaleQuantumToMap which likely limits the range. Moderate relevance because the principle of validating size parameters against signedness is present but not the core focus.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The code uses image->rows and image->columns as loop bounds, which are likely unsigned (size_t). It casts them to ssize_t for loop counters. It does not explicitly enforce non-negativity, but assumes these values are valid. The memory operations (e.g., colormap_index access) rely on intensity being within allocated bounds. Weak to moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "The code performs arithmetic for memory allocation: `AcquireQuantumMemory(MagickMax(image->colors+1, MaxMap), sizeof(*colormap_index))`. The use of `image->colors+1` could overflow if image->colors is SIZE_MAX. The MagickMax and AcquireQuantumMemory might have internal checks, but the direct addition lacks explicit overflow protection. Strong relevance as memory sizing calculations are present.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      },
      {
        "score": 5,
        "reasoning": "The code manages memory for colormap_index and colormap, ensuring they are relinquished via RelinquishMagickMemory on error paths and at the end. It also reassigns image->colormap after allocating a new colormap, properly relinquishing the old one. Ownership semantics appear consistent. Highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The function handles image data transformation, not direct file content processing. Edge cases like empty images (zero rows or columns) might be handled by the loops (y from 0 to rows-1, which would skip if rows=0). However, this is not the primary focus. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error paths (memory allocation failures, cache view failures) where it cleans up resources (colormap_index, image_view) before returning. It also ensures image->colormap is updated consistently. The status flag is used to track errors across parallel regions. Strong relevance, nearly direct application.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      }
    ]
  },
  "CVE-2018-25033_before_subset_100:8ced705b:spec": {
    "timestamp": "2026-01-17T02:44:34.504003",
    "cve_id": "CVE-2018-25033",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8ced705b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not perform any explicit memory release operations. It only updates statistical counters based on neighbor counts. While it deals with a data structure (stl) that likely contains allocated memory, the function itself does not deallocate anything, making the ownership semantics principle only weakly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes an internal data structure (STL mesh connectivity), not file content. There is no file I/O or parsing logic present, so this specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function updates state (statistical counters) as part of what appears to be a resource (facet) removal or cleanup process. It ensures the counters are decremented correctly based on the facet's connectivity before removal. This relates to maintaining consistent program state during cleanup, though it's a specific statistical state rather than a broader resource state.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve XML parsing or any markup language processing. It manipulates a geometric mesh data structure, so this specification is irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, this specification concerns document processing and entity resolution, which is completely unrelated to the 3D mesh connectivity update logic in the target code.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code performs a straightforward data structure update. It does not implement or gate any security-sensitive features like cryptography, authentication, or access control.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function's core purpose is to update statistics when a facet is being removed from a linked structure (an STL mesh). It examines the `neighbor` relationships of the facet (`facet_num`) to determine how many connections it has, and then updates global counters accordingly. This is a critical step in maintaining consistent neighbor relationship metadata during a deallocation or removal process. The specification's principle applies directly.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The function is part of a resource cleanup operation (removing a facet). It updates statistical state to reflect the change, which contributes to establishing an accurate post-cleanup program state. However, the function itself does not perform the actual isolation (e.g., freeing memory, nulling pointers) - it only updates counters. Therefore, the relevance is moderate.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2018-25033_after_subset_100:2976908d:spec": {
    "timestamp": "2026-01-17T02:44:37.045604",
    "cve_id": "CVE-2018-25033",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2976908d",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code decrements counters but does not perform any explicit memory release or ownership transfer operations. The connection is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about file content processing and handling empty files. The target code operates on an internal data structure (stl_file) and has no file I/O operations. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The specification is about maintaining consistent state during resource cleanup. The target code updates statistical counters (state) when a facet's connectivity changes, which is a form of state maintenance during a removal/cleanup operation. The principle of keeping derived state consistent with structural changes is directly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about XML parser security configuration. The target code processes a mesh data structure and has no XML parsing functionality. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification is about document processing and entity resolution boundaries. The target code is not processing documents or resolving entities. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The specification is about gating security-sensitive features behind configuration. The target code performs a basic data structure update with no security-sensitive features or configuration options. The specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification is about maintaining consistent neighbor relationships during linked structure deallocation. The target code's core function is to update connectivity statistics when a facet is removed, directly based on its neighbor relationships (`stl->neighbors_start`). This is a central concern for maintaining data structure integrity during modifications, making it highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification is about establishing complete isolation state during resource cleanup. The target code updates counters to reflect the new isolation state of the mesh (how many edges are disconnected) after a removal. While it doesn't establish isolation in a security sense, it tracks the topological isolation of facets, showing moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-36042_before_subset_100:04f49c65:spec": {
    "timestamp": "2026-01-17T02:45:30.928437",
    "cve_id": "CVE-2022-36042",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "04f49c65",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code manages memory allocation and deallocation for `result`, `infos`, and `pruned_infos`. It maintains clear ownership: `result` is freed on error paths (`beach`), and `infos` is either assigned to `result->entries` or freed before jumping to `beach`. The reallocation logic for `pruned_infos` correctly frees the original `infos` after copying. This demonstrates attention to ownership semantics, though the analysis is localized to this function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes binary cache data from a buffer, not traditional file content. While it handles edge cases like missing slide info (`!total_slide_infos`) or zero-size reads, the specification about \"empty files\" is not directly applicable. The primary validation is on buffer read operations and data structure fields, not file emptiness.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple error paths (via `goto beach`) that must clean up allocated resources (`result`, `infos`) to prevent leaks. The `beach` label ensures `result` is freed before returning NULL. For the `infos` array, it is freed in specific error conditions before jumping to `beach`. This maintains consistent state (no dangling allocations) across all execution paths, which is the core of this specification.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "The code deals with arrays (`RzDyldRebaseInfosEntry *infos`), not linked lists or structures with explicit neighbor pointers. Memory is managed as contiguous blocks. Therefore, the specification about \"consistent neighbor relationships\" during deallocation of linked structures is not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 7,
        "reasoning": "Resource cleanup (freeing memory) establishes isolation by ensuring that no allocated blocks are left orphaned when the function fails. The `beach` cleanup and the conditional frees before it aim to leave no trace on error. However, \"complete isolation state\" is a broader system concept; this function only handles its own allocations.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 6,
        "reasoning": "While not an image parser, the code parses a binary cache format with mappings and slide info entries. It performs validation by checking offsets and sizes read from the buffer (e.g., `entry.slideInfoOffset && entry.slideInfoSize`). It ensures data is present before use. This aligns with the spirit of validating claimed data ranges against available data, though not specifically about image dimensions.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "The code performs safe dimension checking before memory allocation. It calculates `total_slide_infos` by summing counts read from the buffer, and only allocates `infos` if `total_slide_infos > 0`. The allocation uses `RZ_NEWS0` which likely wraps a safe allocator. This directly implements the principle of validating data-derived sizes before allocation.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code uses `memcpy` with a size calculated as `sizeof(RzDyldRebaseInfosEntry) * k`. The parameter `k` is a count derived from loop iterations and is unlikely to be negative, but there's no explicit validation against signedness issues (e.g., ensuring `k` is positive and doesn't cause integer overflow in the multiplication). The relevance is weak because the size calculation is simple, but the risk of overflow exists if `k` is very large.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      }
    ]
  },
  "CVE-2017-18257_after_subset_100:29ae75c0:spec": {
    "timestamp": "2026-01-17T02:46:00.005011",
    "cve_id": "CVE-2017-18257",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "29ae75c0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code demonstrates careful memory ownership management. It allocates memory (result, infos, pruned_infos) and ensures proper cleanup via goto beach on errors. However, there is a potential issue: if `RZ_NEWS0` fails for `pruned_infos`, the original `infos` is freed, but the function proceeds to `beach` where `result` is also freed. Since `result->entries` was never assigned (the allocation failed), freeing `result` is safe. Ownership semantics are largely maintained.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes binary cache structures, not typical \"file content\" in a generic sense. It does handle some edge cases like checking for zero `total_slide_infos` or zero `slide_infos_offset`, but the specification about \"empty files\" is not directly applicable. The relevance is weak as the context is specific binary format parsing.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code uses a `beach` cleanup label to ensure consistent state cleanup across multiple error paths. All allocated resources (`result`, `infos`) are freed before returning NULL on failure. The cleanup path maintains consistency by freeing only what was successfully allocated.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 3,
        "reasoning": "The code deals with arrays (`RzDyldRebaseInfosEntry`), not linked structures (nodes with explicit neighbor pointers). Memory is managed as contiguous blocks. The specification about \"consistent neighbor relationships\" during deallocation does not apply here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The `beach` cleanup establishes isolation by freeing allocated memory, preventing leaks. However, \"complete isolation state\" might imply more thorough cleanup (e.g., nullifying pointers), which is not done here. The function returns NULL, leaving the caller with no handle to any partially constructed state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. While not an image parser, the code parses a binary cache format with headers and slide info entries. It performs some validation, like checking offsets and sizes are non-zero, and guards against overflow in `total_slide_infos`. It does not explicitly validate \"claimed dimensions against actual file data size\" by checking against the buffer's total size, which is a missed opportunity.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code reads counts (`n_slide_infos[i]`) from the file and uses them to calculate `total_slide_infos` for memory allocation. It includes an overflow check (`if (total < total_slide_infos)`). However, it does not validate that these counts or the resulting offsets are within the bounds of the buffer, which is a key aspect of safe dimension checking.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses `memcpy` with a size calculated as `sizeof(RzDyldRebaseInfosEntry) * k`. `k` is a `ut32` (unsigned), and the multiplication is safe from signedness issues in this context. However, the specification broadly applies to validating size parameters, and the code does not validate that `k` is within reasonable bounds (e.g., that `k * sizeof(...)` does not overflow a `size_t`), though `k` is derived from earlier validated data.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      }
    ]
  },
  "CVE-2022-23595_after_subset_100:25a7fdd3:spec": {
    "timestamp": "2026-01-17T02:46:14.950277",
    "cve_id": "CVE-2022-23595",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "25a7fdd3",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code dynamically allocates memory for `*cache` using `new`. While the function returns this pointer to the caller, it does not show the subsequent ownership transfer or cleanup logic. Specification HS-MEM-003 about maintaining strict ownership semantics is moderately relevant because proper ownership of the allocated `XlaCompilationCache` must be defined and managed by the caller to prevent leaks, but the code snippet itself does not handle release.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-004 regarding file content processing and empty files is not relevant. The code deals with device configuration, platform management, and compilation cache creation, not file I/O or file content processing.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 about resource cleanup and consistent state across execution paths is moderately relevant. The function has multiple early return paths (error cases). While it allocates a `new XlaCompilationCache` only on success paths, it does not acquire other resources that need cleanup within this function. However, the principle of ensuring no partial state or resource leaks on error paths is applicable to the function's design pattern.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-001 about validating IPP (Internet Printing Protocol) attribute values is not relevant. The code is for XLA compilation cache setup in a machine learning framework and does not involve IPP or printing protocols.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-SEC-002 about sanitizing printer configuration files is not relevant. The code processes a TensorFlow configuration proto for GPU options, but this is unrelated to printer configurations or sanitization of such files.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-003 about enforcing strict message parsing for the IPP protocol is not relevant. The code does not implement or parse any network protocol messages; it handles platform IDs, compiler retrieval, and client configuration.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-LOGIC-001 about numeric input validation and enforcing upper bounds before arithmetic operations has very low relevance. The code uses `device->tensorflow_cpu_worker_threads()->num_threads` as an integer value but does not perform arithmetic that could overflow, nor does it validate this input against bounds. The connection is weak and indirect.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 about validating file format numeric fields is not relevant. The code does not parse or process any file formats. It reads a configuration proto's `visible_device_list` string, but the validation (via `ParseVisibleDeviceList`) is for GPU IDs, not file format numeric fields.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      }
    ]
  },
  "CVE-2016-8670_before_subset_100:1404ab40:spec": {
    "timestamp": "2026-01-17T02:46:16.864432",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1404ab40",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve explicit memory release operations (like free/delete). Memory management is handled via the String class, which likely uses RAII. There is no manual ownership transfer or release that needs to be tracked, making the specification only weakly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes numeric formatting for a double, not file content. There is no file I/O or handling of file streams. The edge cases handled are related to numeric precision and string buffer sizes, not file-specific issues like empty files.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code uses RAII-style String objects for buffers, which helps ensure cleanup. However, there are early returns (e.g., on snprintf failure) that rely on the String destructor for cleanup. While generally safe, the specification about consistent state across all execution paths has some weak relevance, as the function ensures resources are managed via destructors.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not process IPP (Internet Printing Protocol) attribute values. It formats a double into a string with decimal and thousand separators. The specification is completely unrelated to the code's purpose.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not handle printer configuration files or any file sanitization. It is a numeric formatting function with no relation to printer configuration.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement or parse IPP protocol messages. It is a standalone utility function for string number formatting, with no network or protocol handling.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code performs multiple buffer length calculations (e.g., for integral part, thousand separators, decimal point) and checks for integer overflow before allocating the result buffer. It uses snprintf with explicit size limits and validates the output length. The main security concern is ensuring buffer operations are safe and length calculations do not exceed allocated sizes, which is directly addressed.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform pathname expansion (like globbing) or validate pattern syntax. It formats numbers, not file paths. The connection is very low.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2022-23595_before_subset_100:a0edd8b1:spec": {
    "timestamp": "2026-01-17T02:46:22.531545",
    "cve_id": "CVE-2022-23595",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a0edd8b1",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code allocates memory for a new XlaCompilationCache object using `new` and passes ownership to the caller via the `cache` output parameter. Specification HS-MEM-003 about maintaining strict ownership semantics is moderately relevant. The function's success/failure paths must ensure the `cache` pointer is correctly managed (not leaked, not double-freed). However, the code shows direct assignment (`*cache = new XlaCompilationCache(...)`) on success paths and returns errors without touching `*cache` on failure paths, which is a correct ownership pattern. The specification's broader principles apply, but the scenario is straightforward.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      }
    ]
  },
  "CVE-2016-8670_after_subset_100:364397b5:spec": {
    "timestamp": "2026-01-17T02:47:16.957728",
    "cve_id": "CVE-2016-8670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "364397b5",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve explicit memory release operations (like `free` or `delete`). Memory management is handled by the `String` class, which likely uses RAII. There is no manual ownership transfer or release that needs to be tracked, making the specification's focus on ownership semantics during release largely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about processing file content. The target code formats a numeric double into a string and does not read, write, or process any files. Therefore, this specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The code uses stack variables and a `String` object. While the `String` class should handle its own resource cleanup via destructors (RAII), there are multiple early return paths (e.g., on `snprintf` error). The code ensures the `String` object (`tmpstr`, `resstr`) is returned correctly on these paths, maintaining consistent state. However, the specification's broader focus on \"resources\" (like file handles, network connections) is not a primary concern here, leading to weak relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code is a general-purpose number formatting function with no relation to IPP or printing protocols.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code performs numeric formatting and has no interaction with configuration files or printer-specific data.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing strict parsing of IPP protocol messages. The target code is not a protocol implementation; it is a utility function for string formatting.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The code performs multiple buffer length calculations and memory operations:\n1. It calculates `reslen` based on `integral`, `dec`, and separator sizes, with explicit overflow checks (`if (integral + thousand_sep.size() * ((integral-1) / 3) < integral)`).\n2. It uses `memcpy` to copy data into the pre-allocated `resbuf`, ensuring operations stay within the calculated `reslen`.\n3. Pointer arithmetic (`t`, `s`) is carefully managed to stay within buffer bounds.\nThe core logic directly aligns with the specification's requirement to validate length calculations against allocated size.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating pathname patterns (like globbing). The target code formats numbers and uses string separators; it does not perform any pathname expansion or filesystem operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2014-3566_before_subset_100:7c789221:spec": {
    "timestamp": "2026-01-17T02:47:44.441090",
    "cve_id": "CVE-2014-3566",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7c789221",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory release operations (like free()). It primarily processes input arrays and copies data into session structures. While there is memory safety concern with buffer operations (like array bounds checking), the specification about \"memory release operations\" and \"strict ownership semantics\" is only weakly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes input data (the `data` buffer containing cipher suites), and handles edge cases like checking `datalen % 2 != 0`. However, it does not process file content. The principle of handling input edge cases is somewhat applicable, but the specification is specifically about file processing, making the relevance weak to moderate.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 6,
        "reasoning": "The function has multiple early return paths on error. While it doesn't explicitly clean up resources (like freeing memory), it must ensure the session state remains consistent. The function modifies `session->security_parameters.cipher_suite` and `session->internals.auth_struct` only on successful paths. This relates to maintaining consistent state, giving moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs buffer operations on `data` and `cipher_suites`. It validates `datalen` (e.g., `datalen % 2 != 0` check) and uses loops with step of 2, ensuring it does not read out of bounds (`i+1` is accessed after checking `i < datalen`). The use of `MAX_CIPHERSUITE_SIZE` and `sizeof(cipher_suites)` also shows length consideration. Direct application of buffer length validation principles.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve pathname expansion or pattern syntax validation. It processes a list of cipher suites from network data, not filesystem paths.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Filesystem path processing must maintain consistent state during expansion operations"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve XML parsing or external entity processing. It processes binary TLS handshake data.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve document processing or entity resolution. It is part of a TLS protocol implementation.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2014-9904_before_subset_100:ac1192cc:spec": {
    "timestamp": "2026-01-17T02:47:55.608177",
    "cve_id": "CVE-2014-9904",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ac1192cc",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code does not perform any explicit memory allocation or release (like malloc/free). It uses local stack buffers and closes file descriptors, which is resource cleanup, not memory ownership management.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about processing file content and handling edge cases for empty files. The target code processes a network command string, not file content. The context is completely different (FTP command handling vs. file I/O).",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The specification is highly relevant. The code performs resource cleanup (stopping an event watcher and closing a socket) at the beginning of the function. It ensures the `data_sd` state is consistent (-1 if closed) before proceeding. This is a clear example of maintaining consistent state during cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about DMA operations and VMAP_STACK, which are kernel-level, hardware-specific concepts. The target code is a user-space FTP server function handling a command. There is no DMA or kernel stack mapping involved.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 2,
        "reasoning": "The specification is about USB control message handlers in a driver context. The target code handles an FTP network protocol command. The domains (USB vs. TCP/IP sockets) and abstraction levels (kernel driver vs. user-space application) are entirely different.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      },
      {
        "score": 1,
        "reasoning": "The specification is about driver initialization and platform memory architecture. The target code is part of a user-space application's command handler and has no relation to driver initialization or low-level platform memory constraints.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Driver initialization must account for platform memory architecture constraints"
      },
      {
        "score": 9,
        "reasoning": "The specification is very relevant. The code validates an IP address attribute (from the PORT command argument) using `inet_aton()` before processing it further. This is a direct application of the principle \"attribute values must be validated before being processed,\" even though the context is FTP (IPP is a printing protocol, but the core security principle is identical).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code processes a dynamic network command string. While both involve input parsing, the context (static configuration files vs. transient network data) and the specific security concerns (file injection vs. command injection/network validation) are different. The code does validate the IP address, which is a form of input sanitization, but the specification's context is too specific.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2014-3566_after_subset_100:0c2da4fb:spec": {
    "timestamp": "2026-01-17T02:47:56.354276",
    "cve_id": "CVE-2014-3566",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0c2da4fb",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation or deallocation operations. It uses stack-allocated arrays (cipher_suites, pk_algos) with fixed sizes. While there is memory copying (memcpy), there are no dynamic memory release operations to evaluate against ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes network data (cipher suite lists), not file content. It does handle some edge cases like checking datalen % 2, but this is not related to file processing or empty files specifically.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple early return paths for error conditions. While it doesn't explicitly clean up resources, it maintains consistency by returning error codes before modifying critical session state. The goto finish pattern helps centralize error handling for the successful path.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code performs buffer operations with explicit length validation: checks datalen % 2, uses datalen as loop bound, compares against MAX_CIPHERSUITE_SIZE via sizeof(cipher_suites), and ensures i+1 accesses are within bounds through the loop structure and modulo check.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pathname expansion or pattern syntax validation. It processes cipher suite identifiers from network data, not filesystem paths.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      },
      {
        "score": 1,
        "reasoning": "The code does not process filesystem paths or perform path expansion operations. It handles TLS cipher suite negotiation entirely in memory.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Filesystem path processing must maintain consistent state during expansion operations"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve XML parsing or document processing. It's a TLS handshake function that processes binary protocol data.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The code does not process documents or perform entity resolution. It handles TLS cipher suite selection and negotiation, which is unrelated to document processing security concerns.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2020-20276_after_subset_100:808efdc9:spec": {
    "timestamp": "2026-01-17T02:48:08.717699",
    "cve_id": "CVE-2020-20276",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "808efdc9",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code does not perform explicit memory allocation or release (like malloc/free). It uses local stack buffers and closes file descriptors, which is resource cleanup, not memory ownership management in the sense of dynamic memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about processing file content. The target code processes a network command string, not file content. The edge cases relevant here (e.g., malformed input string) are more about input validation than file processing specifics.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The specification is about resource cleanup maintaining consistent state. The code explicitly checks and cleans up an existing data socket (`data_sd`) before proceeding, ensuring the control structure's state (`data_sd = -1`) is consistent. This is a direct application of the principle, though the scope is limited to one resource.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about DMA operations and VMAP_STACK, which are kernel-level, hardware-specific concepts. The target code is user-space application code (an FTP server handler) and does not involve DMA or kernel stack configurations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      },
      {
        "score": 1,
        "reasoning": "The specification is about driver initialization and platform memory architecture. The target code is for a user-space network service and does not involve driver initialization or low-level platform memory constraints.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Driver initialization must account for platform memory architecture constraints"
      },
      {
        "score": 9,
        "reasoning": "The specification is about validating attribute values before processing. The code validates the IP address parsed from the input string using `inet_aton()`. This is a direct and critical security practice to prevent malicious or malformed input from causing issues. The validation could be more robust (e.g., checking number ranges from `sscanf`), but the principle is strongly applied.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code processes a dynamic network command, not a static configuration file. While input sanitization is a related general concept, the specific context of printer files does not apply.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2018-12600_before_subset_100:885827bc:spec": {
    "timestamp": "2026-01-17T02:49:03.536201",
    "cve_id": "CVE-2018-12600",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "885827bc",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates image dimensions (bmp_info.width and bmp_info.height) against zero/negative values before memory allocation. It also checks if bmp_info.file_size matches GetBlobSize(image) and validates that length (calculated from dimensions) does not exceed GetBlobSize(image). This directly aligns with validating claimed dimensions against actual file data size.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 9,
        "reasoning": "The code performs multiple dimension checks (width > 0, height != 0, planes == 1, bits_per_pixel validation) before calling SetImageExtent and allocating memory via AcquireVirtualMemory. This implements safe dimension checking before memory allocation as required.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 9,
        "reasoning": "The code validates width, height, planes, bits_per_pixel, compression, and number_colors before any significant memory allocation occurs. These checks prevent invalid dimensions from causing excessive memory allocation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Image decoders must validate all dimension values before memory allocation"
      },
      {
        "score": 8,
        "reasoning": "The code validates multiple header fields: file_size, size, width, height, planes, bits_per_pixel, compression, number_colors, and offset_bits. However, some validations occur after partial processing (e.g., after reading colormap), not strictly before all content processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-005: File parsers must validate all header fields before processing content"
      },
      {
        "score": 7,
        "reasoning": "The code calculates bytes_per_line and length using image dimensions and bits_per_pixel, but validates these calculations against GetBlobSize(image) after the arithmetic. Some upper bound checking occurs but could be more comprehensive before calculations.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 9,
        "reasoning": "The code extensively validates numeric fields: width > 0, height != 0, planes == 1, bits_per_pixel values, compression values, number_colors against bits_per_pixel limits. These checks enforce reasonable constraints on all critical fields.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      },
      {
        "score": 8,
        "reasoning": "The code generally pairs resource acquisition with release: uses DestroyImageList on failure, RelinquishMagickMemory for bmp_colormap, and RelinquishVirtualMemory for pixel_info. Most execution paths include cleanup, though some early returns might miss some cleanup.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Resource acquisition must be paired with guaranteed release in all execution paths"
      },
      {
        "score": 8,
        "reasoning": "The code implements cleanup during parse failures: uses ThrowReaderException which appears to propagate errors, and cleanup occurs in error paths via RelinquishMagickMemory and RelinquishVirtualMemory. However, the exact error handling flow through exceptions could be more explicit.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: File format processors must ensure resource cleanup during parse failures"
      }
    ]
  },
  "CVE-2016-8862_after_subset_100:2683a5c5:spec": {
    "timestamp": "2026-01-17T02:49:33.885379",
    "cve_id": "CVE-2016-8862",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2683a5c5",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates image dimensions (bmp_info.width and bmp_info.height) against zero/negative values before memory allocation. It also checks if bmp_info.file_size matches GetBlobSize(image) and validates length against GetBlobSize(image) for sufficient image data. This directly addresses validating claimed dimensions against actual file data size.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 9,
        "reasoning": "The code performs multiple dimension validations before memory allocation: checks for negative/zero width/height, validates bits_per_pixel, compression compatibility, and number_colors. Memory allocation (AcquireVirtualMemory) occurs only after these checks, implementing safe dimension checking.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 9,
        "reasoning": "The code validates all dimension values (width, height, planes, bits_per_pixel, number_colors, compression) before any significant memory allocation. It throws exceptions for invalid values, preventing allocation with malicious dimensions.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Image decoders must validate all dimension values before memory allocation"
      },
      {
        "score": 8,
        "reasoning": "The code validates multiple header fields: file_size, size, width, height, planes, bits_per_pixel, compression, number_colors. However, some validations occur after partial processing (like reading color management info for size > 40), not strictly all before any processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-005: File parsers must validate all header fields before processing content"
      },
      {
        "score": 5,
        "reasoning": "The code validates numeric fields against constraints but doesn't explicitly check for integer overflow before arithmetic operations like bytes_per_line calculation. However, it validates dimensions before memory allocation which indirectly prevents some overflow issues.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 5,
        "reasoning": "The code extensively validates numeric fields: width > 0, height != 0, planes == 1, bits_per_pixel in {1,4,8,16,24,32}, number_colors <= 2^bits_per_pixel, compression compatibility. These are reasonable constraints for BMP format.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      },
      {
        "score": 5,
        "reasoning": "The code generally pairs resource acquisition with release: uses DestroyImageList on failure, RelinquishMagickMemory for bmp_colormap, RelinquishVirtualMemory for pixel_info. Most execution paths have cleanup, though some early returns might miss some cleanup.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Resource acquisition must be paired with guaranteed release in all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code implements cleanup during parse failures: uses ThrowReaderException which likely propagates to cleanup routines, and has explicit RelinquishMagickMemory/RelinquishVirtualMemory calls in error paths. However, some early error paths might not clean up all resources.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: File format processors must ensure resource cleanup during parse failures"
      }
    ]
  },
  "CVE-2019-25038_before_subset_100:b3bfaddf:spec": {
    "timestamp": "2026-01-17T02:49:42.169687",
    "cve_id": "CVE-2019-25038",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b3bfaddf",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code dynamically allocates memory using `malloc` for `rr` and uses `strdup` for strings inserted into lists. While it frees `rr` before returning, it does not explicitly handle cleanup of the `cfg->local_zones` and `cfg->local_data` lists if the function fails mid-execution (e.g., due to a later `malloc` failure). This relates to memory ownership and cleanup, though not perfectly aligned with \"strict ownership semantics\" as the primary issue is potential resource leak on error paths.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The specification is about file content processing and handling empty files. The target code does not process any file content; it processes in-memory certificate data and configuration structures. Therefore, it has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The function allocates resources (memory via `strdup` and `malloc`) and has multiple early return paths on error. It frees `rr` but does not clean up previously allocated and inserted `strdup` strings into `cfg->local_zones` or `cfg->local_data` if an error occurs later. This risks inconsistent state (memory leaks) across execution paths, matching the core concern of this specification.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about XML parsers and disabling external entity processing. The target code does not parse XML; it handles DNSCrypt certificates and constructs DNS resource records. Therefore, it is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns document processing and entity resolution boundaries, likely in the context of XML or similar structured documents. The code processes binary certificate data and constructs a string, with no document parsing or entity resolution involved. It has no relevance.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code adds DNSCrypt certificate data to local DNS zones and data, which is a security-sensitive feature (publishing cryptographic certificates). However, it's not clear from this snippet if this feature is gated behind an explicit configuration option or is automatically enabled. The weak relevance comes from the general theme of controlling security-sensitive features.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification is about linked structure deallocation and maintaining neighbor relationships. The code uses lists (`cfg->local_zones`, `cfg->local_data`) but does not perform any deallocation of linked structures within this function. The memory management concerns are simpler (allocation and potential leak), so relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification focuses on resource cleanup establishing complete isolation state. The function's cleanup is incomplete on error paths, potentially leaving allocated strings in global config lists, which could affect state isolation if those lists are partially populated. However, the connection to \"isolation state\" is indirect, leading to weak relevance.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2016-7425_after_subset_100:7c932f61:spec": {
    "timestamp": "2026-01-17T02:49:52.183283",
    "cve_id": "CVE-2016-7425",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7c932f61",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs memory allocation (malloc, strdup) and has a free(rr) call. However, it does not demonstrate complex ownership semantics like transfer of ownership between functions or shared ownership. The main memory management is straightforward: allocate, use, and free before returning. There is a potential issue if cfg_strlist_insert fails to take ownership of the strdup'ed string, which could lead to a leak, but this is not explicitly shown. Therefore, the relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about processing file content and handling edge cases like empty files. The target code processes internal data structures (signed certificates) and does not read or process any external file content. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple execution paths (early returns on error, continue in loop). It allocates memory (rr) and correctly frees it before continuing the loop or returning. However, there is a potential issue: if cfg_strlist_insert fails after strdup(rr), the duplicated string could be leaked, as the code does not check its return value or clean up on failure. This is a state consistency issue in error paths. The early returns on error (e.g., log_err for memory allocation) also need to ensure other allocated resources (like the earlier strdup for local_zones) are cleaned up, which is not shown. This gives moderate to strong relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve XML parsing. The specification is completely irrelevant to the target C code which handles DNSCrypt certificates and constructs DNS resource records.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification is about document processing and entity resolution, likely in the context of XML or similar. The target code does not process documents or resolve external entities. It is fundamentally unrelated.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code is part of a DNSCrypt feature which is security-sensitive (cryptographic certificate distribution). The code itself loads this data into the configuration, but it's not clear from this snippet if this feature is gated behind an explicit configuration option. The function appears to be called to load data, suggesting the feature is enabled. The relevance is weak to moderate, as the principle of gating security features applies, but the code snippet does not show the gating mechanism.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "While the specification mentions \"linked structure deallocation,\" the code does not deal with linked lists or similar structures in its deallocation. It uses simple dynamic arrays (dnscenv->signed_certs) and a simple malloc/free for a string buffer. The cfg->local_data and cfg->local_zones are likely linked lists, but their deallocation is not shown in this function. Therefore, relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns establishing complete isolation state during resource cleanup. The code's cleanup is minimal (freeing a buffer). It does not involve complex resource isolation like closing network connections, wiping memory, or resetting global state. The connection is weak.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2017-9499_before_subset_100:c0a26d72:spec": {
    "timestamp": "2026-01-17T02:50:07.365890",
    "cve_id": "CVE-2017-9499",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c0a26d72",
    "scores": [
      {
        "score": 1,
        "reasoning": "The specification is about XML parsers disabling external entity processing. The target code is an ELF file parser, not an XML parser. There is no XML processing or external entity handling in the code.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns document processing and entity resolution boundaries, which is specific to formats like XML. The target code parses ELF binary files, which do not have entities in the XML sense. The principle does not apply.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The specification about gating security-sensitive features has weak relevance. The code is a diagnostic/display tool for ELF files. It does not expose security-sensitive features that require explicit configuration. However, the principle of safe defaults could be considered for any file parser, but it's not directly addressed.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification about memory release operations maintaining ownership semantics is moderately relevant. The code uses `mmap` to map a file into memory but does not show the corresponding `munmap` call or file descriptor `close`. The function returns without cleaning up these resources, violating the principle of consistent state cleanup. The main logic applies, but the full cleanup path is not visible in the provided snippet.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification about file content processing handling edge cases is strongly relevant. The code processes ELF file headers and structures directly from memory-mapped data. It must handle edge cases such as malformed ELF headers, invalid offsets (e.g., `e_shoff`, `e_phoff`), empty sections, and files smaller than the expected header size. The current code lacks robust validation of these offsets and sizes before using them to calculate pointers, which is a critical security issue.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification about resource cleanup maintaining consistent state is strongly relevant. As noted for spec_4, the function acquires resources (`open`, `mmap`) but does not release them (`close`, `munmap`) before returning. This creates resource leaks and inconsistent state across all execution paths (including error returns). This is a direct violation of the specification's principle.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification about image parsers validating dimensions has moderate relevance. While the code is not for images, it is for the ELF file format. A similar principle applies: it must validate claimed structural sizes and offsets (like `e_shnum`, `e_phnum`, `e_phentsize`, `e_shentsize`) against the actual mapped file size (`st.st_size`) before using them to compute memory accesses. Failure to do so can lead to out-of-bounds reads. The code performs no such validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The specification about file format readers implementing safe dimension checking before memory allocation is highly relevant. The code performs pointer arithmetic based on fields read from the ELF header (e.g., `&elf_map[ehdr->e_shoff]`) without verifying that these offsets and subsequent structure accesses lie within the bounds of the memory-mapped file (`st.st_size`). This is a classic cause of segmentation faults and potential information disclosure. Safe dimension checking is absolutely required here and is missing.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2016-8670_after_subset_100:0bc5d420:spec": {
    "timestamp": "2026-01-17T02:51:11.097722",
    "cve_id": "CVE-2016-8670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0bc5d420",
    "scores": [
      {
        "score": 1,
        "reasoning": "The specification is about XML parsers disabling external entity processing. The target code is an ELF file parser written in C that reads binary executable files, not XML files. There is no XML parsing or external entity processing involved.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The specification addresses document processing and entity resolution boundaries, which is relevant to markup languages like XML/SGML. The target code parses ELF binary formats, not document formats with entity resolution mechanisms.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code doesn't have explicit security-sensitive features that need gating, it does process potentially untrusted ELF files. However, there's no configuration system for enabling/disabling features like symbol table parsing or dynamic section analysis.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses mmap for memory mapping but doesn't explicitly show munmap for cleanup. The function returns early on errors without unmapping memory, potentially causing resource leaks. However, the code doesn't show complex ownership transfers.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code processes ELF file content and should handle edge cases like empty or malformed files. It does check for some conditions (like validated_offset) but may not handle all edge cases comprehensively, such as files smaller than ELF header size or invalid offsets.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function has multiple early return paths on errors (open, fstat, mmap failures) but doesn't show cleanup of mapped memory or file descriptors in all paths. Resource cleanup consistency is important for this file parser.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. While not an image parser, the ELF parser should validate claimed dimensions (section sizes, offsets) against actual file data size. The code does some validation with validated_offset but may not comprehensively check all dimensions against file bounds.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code is an ELF file format reader that performs pointer arithmetic based on file offsets (e.g., &elf_map[ehdr->e_shoff]). It must validate these dimensions before dereferencing pointers to prevent out-of-bounds memory access. The validated_offset check is a step in this direction but may not be comprehensive enough.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2017-12667_before_subset_100:8b77877c:spec": {
    "timestamp": "2026-01-17T02:51:28.265319",
    "cve_id": "CVE-2017-12667",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8b77877c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory (s1, s2, ret) and has multiple cleanup paths. However, there is a potential ownership issue: when `malloc(n2+1)` fails, the code returns NULL without freeing `s1` and `ret` that were already allocated earlier, causing a memory leak. This violates strict ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code reads from a buffer (not necessarily a file) and handles read size mismatches, but it does not specifically address edge cases like empty files or incomplete data beyond checking `size != n1` or `size != n2`. The specification is more about file content processing in general, which has weak connection.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Resource cleanup must be consistent across all execution paths. The code has multiple cleanup points but is inconsistent: in the `n2` malloc failure path, it returns NULL without freeing previously allocated `s1` and `ret`. Also, when `error` is true after reading `n2`, it returns NULL without freeing `s1` and `ret`. This leaves resources leaked, violating consistent state cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "The specification is about image parsers validating dimensions against file data size. This code parses a Python complex number object from a serialized buffer, not an image format. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 7,
        "reasoning": "The code reads sizes (n1, n2) from the buffer and allocates memory based on them. It does check the read size against expected size after reading data, but it does not validate the sizes (n1, n2) for safety before allocation (e.g., against maximum allowed size). This relates to safe dimension checking before allocation, though not strictly for file format readers.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 9,
        "reasoning": "The code uses `n1` and `n2` read from the buffer for memory allocation and reads. It does not enforce non-negative constraints (though they are unsigned, so they are always non-negative), but it does not check for zero or extremely large values that could cause allocation failures or integer overflow. The specification directly applies because input lengths control memory operations.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2017-9499_after_subset_100:42200afc:spec": {
    "timestamp": "2026-01-17T02:51:35.946107",
    "cve_id": "CVE-2017-9499",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "42200afc",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code shows mixed ownership management. It correctly frees `s1` and `s2` before returning NULL in some error paths (e.g., after `rz_buf_read` fails for `s2`). However, there is a critical flaw: if `malloc(n2 + 1)` fails, the function returns NULL without freeing the previously allocated `s1` and `ret`, causing a memory leak. This violates strict ownership semantics as resources are not properly released on all error paths.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple execution paths (success, various error conditions). Resource cleanup (freeing `ret`, `s1`, `s2`) is inconsistent across these paths. As noted in spec_1, the error path when `malloc` for `s2` fails leaks `s1` and `ret`. This creates an inconsistent state where some allocated resources are not cleaned up.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The specification is about image parsers validating dimensions against file size. This code parses a Python complex number object from a serialized stream, not an image format. The core concern is different.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code is a file/format reader (parsing pyc objects). It performs dimension checking (`n1`, `n2`) before memory allocation (`malloc(n1+1)`, `malloc(n2+1)`). However, the safety of this check is undermined by the missing overflow check for `n1+1` in the second allocation block (see spec_8). The principle of safe checking before allocation is present but imperfectly implemented.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses `ut32` (unsigned) for size parameters `n1` and `n2`. It validates them indirectly via `UT32_ADD_OVFCHK(n1, 1)` before using them in `malloc(n1 + 1)`. This addresses signedness concerns by using unsigned types and checking for overflow from the +1 operation. However, it only performs this check for the first allocation (`s1`) and not consistently for the second (`s2`), making the implementation incomplete.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code reads lengths (`n1`, `n2`) from the buffer. These lengths are used for memory allocation and buffer reads. The code enforces non-negative constraints by using unsigned types (`ut32`). However, the critical flaw is that the overflow check `UT32_ADD_OVFCHK(n2, 1)` is performed, but if it passes, the code proceeds to `malloc(n2 + 1)`. If `n2` is very large (e.g., `UT32_MAX`), the overflow check passes (because `UT32_MAX + 1` overflows, so `UT32_ADD_OVFCHK` returns true), causing the function to return NULL. This is safe but the check is placed incorrectly for the second allocation, leading to a leak (see spec_1 & 3). The principle of validating length is applied.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 10,
        "reasoning": "Highly relevant and directly applicable. The code uses arithmetic (`n1 + 1`, `n2 + 1`) to calculate sizes for memory allocation. It explicitly uses the macro `UT32_ADD_OVFCHK` to protect against overflow for both `n1` and `n2`. This is a direct implementation of overflow protection for memory sizing. However, there is a logical error: the overflow check for `n2` is performed, but if it *fails* (i.e., no overflow), the function returns NULL, which is the opposite of the intended logic. The check should guard against overflow, not success. This appears to be a bug. Despite the bug, the specification's requirement is central to the code's operation.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2020-27209_before_subset_100:45ce44af:spec": {
    "timestamp": "2026-01-17T02:51:36.998157",
    "cve_id": "CVE-2020-27209",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "45ce44af",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification HS-MEM-003 is about memory release operations and ownership semantics. The target code performs cryptographic calculations using stack-allocated arrays (tmp, s, p) and does not involve dynamic memory allocation or explicit memory release operations. The connection is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification HS-INPUT-004 is about processing file contents and handling edge cases like empty files. The target code processes a message hash and a private key in memory, with no file I/O operations. The specification is not relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "The specification HS-STATE-002 is about resource cleanup and consistent state across execution paths. The function uses local variables and returns success/failure codes. While it ensures consistent return values (0 on failure, 1 on success), it does not manage external resources like handles or dynamic memory that require cleanup. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-INPUT-001 is about XML parsers disabling external entity processing. The target code is a cryptographic signing function and does not parse XML. The specification is not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-SEC-002 is about document processing and entity resolution boundaries. The target code performs ECDSA signing and does not process documents or entities. The specification is not relevant.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-CONF-003 states security-sensitive features must be gated behind explicit configuration options. The code includes a conditional branch based on `g_rng_function` to optionally add randomness for side-channel protection. This is a security-sensitive feature (side-channel mitigation) controlled by the presence of an RNG function. The relevance is moderate.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-MEM-003 (duplicate label) is about linked structure deallocation and neighbor relationships. The target code uses simple arrays for calculations and does not involve linked lists or similar dynamic structures. The specification is not relevant.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-STATE-004 is about resource cleanup establishing complete isolation state. The function operates on local data and parameters. Its cleanup is limited to ensuring cryptographic values (like `k`) are properly processed and not leaked, but it doesn't manage isolatable resources. The connection is very weak.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2020-27209_after_subset_100:32e832ad:spec": {
    "timestamp": "2026-01-17T02:51:51.809767",
    "cve_id": "CVE-2020-27209",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "32e832ad",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification HS-MEM-003 is about memory release operations and ownership semantics. The target code performs cryptographic calculations using stack-allocated arrays (tmp, s, p) and does not contain any dynamic memory allocation or explicit memory release operations (like free). Therefore, the connection is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification HS-INPUT-004 is about processing file contents and handling edge cases like empty files. The target code is a low-level ECC signing function that operates on byte arrays (private_key, message_hash). It does not involve file I/O or file content processing at all. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "The specification HS-STATE-002 is about resource cleanup and consistent state across execution paths. The function uses local stack variables and returns early on errors (e.g., returns 0). While it ensures consistent return values, it does not manage external resources (like file handles, network connections, or dynamic memory) that require cleanup. The connection is very low to weak.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-INPUT-001 is about XML parsers disabling external entity processing. The target code is a cryptographic signing function and has no relation to XML parsing. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The specification HS-SEC-002 is about document processing and entity resolution boundaries, likely in the context of XML or similar formats. The target code performs ECDSA signing and does not process documents or entities. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-CONF-003 states that security-sensitive features must be gated behind explicit configuration options. The code includes a conditional branch based on `g_rng_function` to enable side-channel protection measures (using a random initial Z value and premultiplying by a random number). This is a security-sensitive feature (side-channel resistance) that is explicitly controlled by the presence of an RNG function. This shows strong relevance.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-MEM-003 (second instance) is about linked structure deallocation and maintaining neighbor relationships. The target code does not use linked lists or similar dynamic data structures; it operates on fixed-size arrays for numerical computations. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-STATE-004 is about resource cleanup operations establishing complete isolation state. The function does not acquire or clean up external, shareable resources that would require isolation (like shared memory, process-level resources). Its state is confined to the function call stack. The connection is very low.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-2652_before_subset_100:886a8c04:spec": {
    "timestamp": "2026-01-17T02:53:02.178423",
    "cve_id": "CVE-2022-2652",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "886a8c04",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves feature/capability declaration (V4L2 capabilities like V4L2_CAP_STREAMING, V4L2_CAP_VIDEO_CAPTURE). The specification about matching declarations to implementation capabilities is relevant. The code sets capabilities based on device state (`dev->announce_all_caps`, `dev->ready_for_capture/output`), which is a form of ensuring the declared features match what the device can currently do. However, it's not about a \"network feature\" but a device driver interface feature, making it highly relevant but not a perfect match.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 1,
        "reasoning": "The code performs no packet processing, fragment handling, or buffer allocation based on counts. It is a simple IOCTL handler that fills a capability structure. The specification is about low-level network packet processing and is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The function `vidioc_querycap` is the primary capability negotiation function in a V4L2 driver. It queries and reports the device's capabilities to userspace. The code verifies internal device state (`dev->ready_for_capture`, `dev->ready_for_output`, `dev->announce_all_caps`) to determine which capabilities to advertise, which is a direct form of capability verification during feature negotiation.",
        "spec_index": 2,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      },
      {
        "score": 1,
        "reasoning": "The code contains no memory release operations, ownership transfers, or deallocation logic. It only reads from and writes to provided structures. The specification does not apply.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 1,
        "reasoning": "The function has a single return path (`return 0;`) and performs no resource acquisition or cleanup within its body. It does not manage resources like memory, locks, or file descriptors that require state-consistent cleanup across multiple paths. The specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code does not deal with linked structures (lists, trees) or their deallocation. It works with simple structures and integers. The specification is irrelevant to this code scenario.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 1,
        "reasoning": "Similar to spec 6, this function performs no resource cleanup operations. Its purpose is to query and report information, not to isolate or release resources. The specification has no connection to the provided code.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2020-15204_before_subset_100:802687a5:spec": {
    "timestamp": "2026-01-17T02:53:06.516203",
    "cve_id": "CVE-2020-15204",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "802687a5",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves tensor storage and resource handle creation, which implies memory/resource ownership management. While not directly showing memory release operations, the allocation and storage of tensors must maintain proper ownership semantics to avoid leaks or double frees. However, the code snippet does not show explicit release operations.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes tensor inputs, not file content. There is no file I/O or handling of empty files in this context.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The code adds a tensor to a tensor store and creates resource handles. Resource cleanup and state consistency are relevant here, especially if errors occur later or if resources need to be properly managed across execution paths. The OP_REQUIRES_OK checks help maintain consistency.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not process IPP (Internet Printing Protocol) attributes. It handles tensor inputs and resource creation, which is unrelated to IPP.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve printer configuration files or any sanitization of such files. It is completely unrelated to printing systems.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement or parse IPP protocol messages. It is part of a tensor computation kernel, not a printing protocol.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code allocates output tensors and copies data (e.g., setting constant string values). While buffer size validation might be relevant in tensor operations, the snippet does not show explicit buffer copying with size parameters. The relevance is weak but present in underlying tensor libraries.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The code processes input tensors and allocates outputs. Input validation for tensor shapes and sizes is important to prevent negative dimensions, but the snippet does not explicitly show length constraint enforcement. Weak relevance due to general input handling.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      }
    ]
  },
  "CVE-2022-2652_after_subset_100:0170c8b9:spec": {
    "timestamp": "2026-01-17T02:53:14.447050",
    "cve_id": "CVE-2022-2652",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0170c8b9",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves feature/capability declaration (V4L2 capabilities like STREAMING, READWRITE, CAPTURE, OUTPUT). Specification HS-MEM-003 about matching declarations to implementation capabilities is relevant. The code conditionally sets capabilities based on device state (`dev->ready_for_capture`, `dev->ready_for_output`) and a configuration flag (`dev->announce_all_caps`), which aligns with the principle of precise declaration. However, it's not about \"network features\" specifically, but the core concept of accurate capability reporting applies strongly.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 2,
        "reasoning": "Specification HS-IO-002 is about packet processing and validating fragment counts against buffers. The target code performs a V4L2 ioctl query for capabilities, involving no packet processing, network fragments, or buffer allocation based on counts. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 9,
        "reasoning": "Specification HS-SEC-004 on feature negotiation with capability verification is highly relevant. The function `vidioc_querycap` is the primary V4L2 ioctl handler for querying device capabilities. It negotiates/declares what features (capture, output, streaming, etc.) the device supports based on its internal state (`dev->ready_for_capture`, `dev->announce_all_caps`). This is a core security aspect to prevent misuse by accurately reporting supported operations.</spec_1_reasoning>\n<spec_4_score>2</spec_4_score>\n<spec_4_reasoning>Specification HS-MEM-003 (this instance) is about memory release operations and ownership semantics. The target code does not perform any memory allocation, deallocation, or release operations. It only copies and formats strings into a provided structure. Relevance is very low.</spec_2_reasoning>\n<spec_5_score>2</spec_5_score>\n<spec_5_reasoning>Specification HS-INPUT-004 concerns processing file content and handling edge cases like empty files. The code is a kernel driver ioctl handler dealing with a V4L2 capability structure. It does not process file content in the sense of reading/writing file data. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      },
      {
        "score": 2,
        "reasoning": "Specification HS-MEM-003 (this instance) is about memory release operations and ownership semantics. The target code does not perform any memory allocation, deallocation, or release operations. It only copies and formats strings into a provided structure. Relevance is very low.</spec_2_reasoning>\n<spec_5_score>2</spec_5_score>\n<spec_5_reasoning>Specification HS-INPUT-004 concerns processing file content and handling edge cases like empty files. The code is a kernel driver ioctl handler dealing with a V4L2 capability structure. It does not process file content in the sense of reading/writing file data. Relevance is very low.</spec_3_reasoning>\n<spec_6_score>3</spec_6_score>\n<spec_6_reasoning>Specification HS-STATE-002 is about resource cleanup maintaining consistent state across execution paths. The function `vidioc_querycap` is a query function that does not acquire or clean up resources. It only reads device state and fills a structure. It has a single return path (`return 0`). While it reads state, it doesn't modify or clean up resources, so relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "Specification HS-INPUT-004 concerns processing file content and handling edge cases like empty files. The code is a kernel driver ioctl handler dealing with a V4L2 capability structure. It does not process file content in the sense of reading/writing file data. Relevance is very low.</spec_3_reasoning>\n<spec_6_score>3</spec_6_score>\n<spec_6_reasoning>Specification HS-STATE-002 is about resource cleanup maintaining consistent state across execution paths. The function `vidioc_querycap` is a query function that does not acquire or clean up resources. It only reads device state and fills a structure. It has a single return path (`return 0`). While it reads state, it doesn't modify or clean up resources, so relevance is very low.</spec_4_reasoning>\n<spec_7_score>2</spec_7_score>\n<spec_7_reasoning>Specification HS-MEM-003 (this instance) is about linked structure deallocation and neighbor relationships. The code does not deal with linked lists, deallocation of structures, or maintaining relationships between linked elements. It works with simple structures and device pointers. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-STATE-002 is about resource cleanup maintaining consistent state across execution paths. The function `vidioc_querycap` is a query function that does not acquire or clean up resources. It only reads device state and fills a structure. It has a single return path (`return 0`). While it reads state, it doesn't modify or clean up resources, so relevance is very low.</spec_4_reasoning>\n<spec_7_score>2</spec_7_score>\n<spec_7_reasoning>Specification HS-MEM-003 (this instance) is about linked structure deallocation and neighbor relationships. The code does not deal with linked lists, deallocation of structures, or maintaining relationships between linked elements. It works with simple structures and device pointers. Relevance is very low.</spec_5_reasoning>\n<spec_8_score>2</spec_8_score>\n<spec_8_reasoning>Specification HS-STATE-004 is about resource cleanup establishing complete isolation state. Similar to spec_6, this function performs no cleanup operations. It is a pure query/initialization function for a capability structure. It does not isolate or release any resources. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2020-15204_after_subset_100:e81fde20:spec": {
    "timestamp": "2026-01-17T02:53:27.979453",
    "cve_id": "CVE-2020-15204",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e81fde20",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code involves Tensor memory management but does not explicitly show memory release operations or ownership transfer. The session state and tensor store manage resources, but the specification about strict ownership semantics during release is not directly addressed in this snippet.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code processes Tensor inputs, not file content. There is no file I/O or handling of empty files in this context.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code manages resources (Tensor handles) through a session state and tensor store. While it adds a tensor to the store, it does not show cleanup paths. The principle of maintaining consistent state during resource management is relevant, especially for session-based resources.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve IPP (Internet Printing Protocol) attributes. It deals with TensorFlow kernel operations and resource handles.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not process printer configuration files. It is part of a TensorFlow operation kernel.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement or parse IPP protocol messages. It is focused on internal TensorFlow session and tensor handling.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "While the code does not explicitly show buffer copying with size parameters, Tensor operations often involve underlying buffer management. The general principle of validating size parameters could apply indirectly, but it's not a direct match.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The code handles input tensors but does not explicitly show length validation for memory operations. However, TensorFlow's internal APIs may enforce constraints. The relevance is weak as the specification is not directly visible in this snippet.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      }
    ]
  },
  "CVE-2017-12667_before_subset_100:16f6706a:spec": {
    "timestamp": "2026-01-17T02:54:00.910864",
    "cve_id": "CVE-2017-12667",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "16f6706a",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes tiling pattern dimensions (width, height, xStep, yStep, surface_width, surface_height) and performs calculations that could lead to integer overflows or excessive memory allocation if dimensions are maliciously crafted. While not a traditional image parser, it validates dimensions (e.g., checking if surface_width * surface_height > 0x800000L) before allocation, which aligns with the core principle of validating claimed dimensions against safe limits.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "The code performs dimension checking (e.g., checking product against 0x800000L) before allocating memory for a new SplashBitmap. This is a direct application of safe dimension checking prior to allocation to prevent excessive memory consumption or integer overflow attacks, which is the main principle of this specification.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 2,
        "reasoning": "The code does not process IPP (Internet Printing Protocol) attribute values. It handles PDF tiling pattern parameters, which are unrelated to IPP. The specification is not applicable to this context.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code processes PDF content streams and pattern data, not printer configuration files. The specification targets a different file type and security context, so it has very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 2,
        "reasoning": "The code implements PDF rendering logic, not an IPP protocol implementation. There is no IPP message parsing involved, making this specification irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code manages memory for bitmap objects (SplashBitmap) and other resources (Splash, Gfx). It shows careful ownership transfer (e.g., saving formerBitmap, restoring it on failure, deleting allocated objects). However, the logic is complex with multiple early returns, which could risk leaks if not all paths are covered. The principle of maintaining strict ownership semantics is relevant but not perfectly followed in all potential paths.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 6,
        "reasoning": "The code handles various edge cases in dimension calculations (e.g., checking for finite CTM values, zero dimensions, small scaling factors). It includes checks for division by zero (implicitly via conditions like ctm[1] == 0) and extreme values. While not specifically about empty files, it deals with edge cases in geometric transformations and pattern data, which aligns partially with the specification's intent.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code demonstrates careful resource cleanup and state consistency. It saves the original splash and bitmap pointers, restores them on multiple error paths, and ensures allocated objects (bitmap, splash, gfx) are deleted. The state (CTM) is also restored on error returns. This is a strong example of maintaining consistent state across execution paths, which is the core of this specification.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      }
    ]
  },
  "CVE-2016-7425_before_subset_100:9f564151:spec": {
    "timestamp": "2026-01-17T02:54:40.064935",
    "cve_id": "CVE-2016-7425",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9f564151",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs memory buffer manipulation (memmove) and checks for buffer boundaries against INDX_INFLBUF_SIZEMAX. While it doesn't involve memory release, the principle of maintaining safe memory operations and preventing buffer overflows is moderately relevant. The checks for `l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX` align with secure memory handling practices.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes a rule-based data stream, not file content directly. It includes some edge case handling (e.g., position validation, buffer bounds checks), but the specification about file processing edge cases is only weakly connected. The function's primary concern is decoding logic, not file I/O edge cases.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve resource acquisition or cleanup (like files, handles, or dynamic memory). It operates on provided buffers and returns error codes, but there are no resources to clean up. The specification about maintaining consistent state during cleanup has very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code manipulates a linear buffer, not linked structures. There are no pointers to neighbors or linked list nodes. The specification about linked structure deallocation is essentially irrelevant to this scenario.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 3, the code does not perform resource cleanup operations. It is a pure decoding function without any isolation state requirements. The specification has very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "The code is not an image parser. It is a generic data decoding/inflation routine for a specific format. The specification about image dimension validation is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "This has strong relevance. The function acts as a format reader/decoder for a compression rule set. It performs critical safe dimension checking before performing memory operations (memmove). The checks `if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX)` are direct implementations of safe bounds checking to prevent buffer overflow, which is the core principle of HS-IO-002.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code is not an XML parser. It processes a custom bytecode-like rule format for data transformation. The specification about XML external entities is completely irrelevant to this code scenario.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      }
    ]
  },
  "CVE-2019-11470_after_subset_100:985547f7:spec": {
    "timestamp": "2026-01-17T02:54:44.410777",
    "cve_id": "CVE-2019-11470",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "985547f7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes image/pattern dimensions (width, height, surface_width, surface_height) derived from input data (bbox, ptm, ctm). It performs validation checks (e.g., checking for finite values, checking for zero dimensions, checking if product exceeds 0x800000L) before memory allocation for the SplashBitmap. This aligns with the core principle of HS-INPUT-001: validating claimed dimensions before processing, though the context is PDF pattern filling, not a generic image parser.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "The code performs multiple dimension calculations and safety checks (e.g., checking for zero, checking for excessively large size > 0x800000L, using ceil) before allocating memory for `new SplashBitmap(surface_width, surface_height, ...)`. This directly implements the principle of safe dimension checking before allocation as specified in HS-IO-002.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 1,
        "reasoning": "The code deals with PDF graphics rendering (tiling patterns), not the Internet Printing Protocol (IPP). There is no processing of IPP attributes. The specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code processes PDF content streams and pattern definitions, not printer configuration files. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code is part of a PDF rendering engine, not an IPP protocol implementation. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code manages memory for SplashBitmap and Splash objects. It shows careful ownership transfer (e.g., saving former pointers, deleting temporary objects, restoring pointers). However, the scenario is not primarily about complex ownership semantics across threads/lifetimes, but about cleanup within a single function. The principle of maintaining clear ownership to prevent leaks/double-free is relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code handles various edge cases in dimension calculations (zero, infinity, very large/small scaling factors) and returns false appropriately. It does not explicitly mention handling empty content streams (`str`), but the function could fail gracefully later. The principle of handling edge cases is moderately relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code meticulously saves the original CTM state (`savedCTM`) and restores it via `state->setCTM()` on multiple error return paths and before function exit. It also saves and restores the global `splash` and `bitmap` pointers. This is a strong example of maintaining consistent state across all execution paths (success, failure, early returns) as required by HS-STATE-002.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      }
    ]
  },
  "CVE-2016-7425_after_subset_100:a85794cf:spec": {
    "timestamp": "2026-01-17T02:55:01.606607",
    "cve_id": "CVE-2016-7425",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a85794cf",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs memory buffer manipulation (memmove) and checks for out-of-bounds writes (d + l > decoded + INDX_INFLBUF_SIZEMAX). While it doesn't involve memory release, the principle of maintaining strict ownership and ensuring memory operations stay within allocated bounds is relevant. The checks for buffer overflow are a direct application of safe memory handling principles.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes a data stream (rule pointer) but is not specifically file content processing. It handles a continuous input buffer, not file I/O with edge cases like empty files. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function manages an internal buffer but does not acquire or release system resources (like file handles, network connections). It returns error codes but does not perform complex state cleanup across multiple resources. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code manipulates a linear buffer, not a linked data structure. There are no pointers to neighbors or complex deallocation logic. The specification does not apply.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 2,
        "reasoning": "Similar to spec 3, the function does not manage isolatable resources. It works on provided buffers and returns status codes, but doesn't establish isolation states. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 1,
        "reasoning": "The code is a generic data inflation/decoding routine, not an image parser. It does not process image dimensions or file headers. The specification does not apply.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "This is highly relevant. The function acts as a decoder/reader for a specific format (inflation rules). It performs critical dimension/size checking before memory operations (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) to prevent buffer overflows. This is a direct application of safe dimension checking before buffer manipulation.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code does not parse XML. It processes a custom byte stream rule format. The specification about XML external entities is completely irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      }
    ]
  },
  "CVE-2022-23586_before_subset_100:4d9cb40b:spec": {
    "timestamp": "2026-01-17T02:55:03.514651",
    "cve_id": "CVE-2022-23586",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4d9cb40b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code processes input arguments (arg_def, attr_values) to build a graph node index. It performs some validation (e.g., checking dtypes size) and type resolution via ArgNumType. This aligns with the core principle of HS-INPUT-001 (validating input attribute values before processing), though the validation scope is specific to data types and structure rather than generic IPP attributes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code deals with TensorFlow graph construction and function argument processing. There is no interaction with printer configuration files or any file sanitization logic. Specification HS-SEC-002 is completely unrelated to this context.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code allocates and constructs NodeDef objects (via AddNode) and manages collections (result_.nodes, result_.arg_types). While it handles resource arguments (resource_arg_unique_id), it does not explicitly show memory release or ownership transfer operations. The principle of maintaining strict ownership semantics (HS-MEM-003) is a weak, general connection to resource management in C++ code.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes function argument definitions and data types, not file content. It does handle an edge case for an empty dtypes list (dtypes.size() < 1), which is somewhat analogous to handling empty input, but the specification's focus on \"file content processing\" makes the relevance very low.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function builds state (adding nodes to result_) across a loop. If an error occurs (TF_RETURN_IF_ERROR), it returns early, potentially leaving the result_ in a partially updated state. The specification's principle of maintaining consistent state across all execution paths (especially error paths) has weak relevance, as the code relies on Status returns but doesn't show explicit rollback cleanup.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve deallocation of linked lists, trees, or graph nodes in a way that requires maintaining neighbor relationships. It is constructing new nodes and adding them to a container. Specification HS-MEM-003 (duplicate label, appears as \"Linked structure deallocation\") is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The code is focused on graph construction and resource argument annotation, not on cleaning up or isolating resources (like closing handles, freeing memory, or resetting state). The specification's context of resource cleanup for isolation does not apply.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-23586_after_subset_100:3e754d6b:spec": {
    "timestamp": "2026-01-17T02:55:51.776661",
    "cve_id": "CVE-2022-23586",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3e754d6b",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code validates input attributes (e.g., via ArgNumType and checks on dtypes size) before processing, which aligns with the principle of input validation. However, the specification is specifically about IPP attribute values, which is a network protocol context not present in this TensorFlow graph construction code. The general principle applies, but the specific domain does not.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code deals with TensorFlow graph node construction and function argument processing. It has no relation to printer configuration files or their sanitization.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The code is not implementing or parsing the IPP (Internet Printing Protocol). It is building an internal graph representation for a TensorFlow function.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 4,
        "reasoning": "The code allocates and constructs NodeDef objects but does not explicitly show memory release or ownership transfer. The principle of maintaining ownership semantics is a general good practice for memory management, which could be relevant to the broader system this code is part of, but it is not directly addressed or visible in this snippet.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code includes a check for `dtypes.size() < 1`, which is a form of handling an empty or invalid input list. This parallels the concept of handling edge cases like empty files in file processing. The connection is weak because the context is data type lists, not file content.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function manages the internal state of a graph construction object (`result_`). It adds nodes and updates `arg_types`. Ensuring consistent state across all execution paths (e.g., early returns on error) is important. The function uses `TF_RETURN_IF_ERROR` which helps maintain state consistency on error paths, showing some relevance.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code constructs nodes but does not deallocate or manage linked structures (like linked lists or trees) where neighbor relationships need preservation. The data structures appear to be vectors (arrays).",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit resource cleanup (like closing handles, freeing memory). It is in a construction phase. The principle of establishing isolation state during cleanup is not applicable to the primary activity shown. However, if a failure occurs, the consistent state maintenance (as noted in spec_6) could be seen as a weak parallel to cleanup isolation.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2015-8374_before_subset_100:b025089a:spec": {
    "timestamp": "2026-01-17T02:56:37.053719",
    "cve_id": "CVE-2015-8374",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b025089a",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves device removal and memory deallocation (btrfs_free_device). It must ensure the device object is only freed after all references are removed and operations are complete, which relates to ownership semantics. However, the specification is generic about memory release, while this code deals with a complex linked structure within a filesystem context.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The specification is about processing file contents and handling edge cases like empty files. The target code performs device removal operations in a filesystem, not file content processing. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function performs complex resource cleanup (device removal, superblock updates, list management) and has multiple error paths (goto error_undo, goto out). It must ensure state consistency (device lists, counters, superblock metadata) is maintained across all execution paths, which it attempts through rollback logic (error_undo section).",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-003: Filesystem operations must maintain consistent security state across all object types"
      }
    ]
  },
  "CVE-2015-8374_after_subset_100:413110aa:spec": {
    "timestamp": "2026-01-17T02:56:41.529910",
    "cve_id": "CVE-2015-8374",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "413110aa",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code manages the removal and deallocation of a device structure (`btrfs_free_device(device)`). It must ensure the device is no longer referenced (e.g., removed from RCU lists with `list_del_rcu`, decrementing counters) before freeing, which relates to maintaining strict ownership semantics during memory release. However, the specification is broadly about memory ownership, and this code deals with a specific kernel resource cleanup pattern.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The specification is about processing file contents and handling edge cases like empty files. This code performs device removal in a filesystem, dealing with block devices and metadata, not with processing the contents of regular files. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function performs complex resource cleanup (device removal) and must maintain consistent state across multiple execution paths (success, error rollback via `error_undo` label). It updates multiple related data structures (device lists, counters, superblock) and ensures cleanup operations are atomic or rolled back correctly on failure.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-003: Filesystem operations must maintain consistent security state across all object types"
      }
    ]
  },
  "CVE-2022-1452_before_subset_100:b099a3ef:spec": {
    "timestamp": "2026-01-17T02:56:57.395314",
    "cve_id": "CVE-2022-1452",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b099a3ef",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code manages dynamic memory (creating a list with a custom free function `r_bin_java_bootstrap_method_free`). While it shows ownership transfer to the list, the specification about \"strict ownership semantics\" is moderately relevant. The relevance is not direct (10) because the code focuses on parsing and construction rather than explicit release operations within this function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification about handling file content edge cases has weak relevance. The function processes a memory buffer, not a file directly. It does check `offset >= sz` during iteration, which is a basic boundary check, but doesn't explicitly handle cases like an empty or malformed attribute structure at the start.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification about validating IPP attribute values has very low relevance. The code parses Java class file attributes (BootstrapMethods), which is a completely different domain and protocol from IPP (Internet Printing Protocol).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification about sanitizing printer configuration files has no relevance. The code is part of a Java binary analysis tool (radare2) and processes Java class file structures, not printer configurations.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification about strict IPP protocol message parsing has very low relevance. While the code does parse a structured format (Java class file), it is a different protocol specification. The principle of strict parsing is similar, but the domain mismatch is significant.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification about validating size parameters against signedness constraints is highly relevant. The function receives a `sz` parameter (ut64) and an `offset` (ut64). It performs a critical check `if (offset >= sz)` before calling `r_bin_java_bootstrap_method_new` with calculated sizes like `sz - offset`. This prevents negative/wrapped values when passed to downstream functions, directly aligning with the specification's intent.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification about enforcing non-negative length constraints for memory operations is strongly relevant. The core of the loop safety relies on the `num_bootstrap_methods` value read from the buffer (`R_BIN_JAVA_USHORT`). If this value is maliciously large, the loop could process excessive data. The `offset >= sz` check provides a crucial safety stop, enforcing an effective length constraint based on the actual buffer size.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      }
    ]
  },
  "CVE-2018-12320_after_subset_100:e8b5500b:spec": {
    "timestamp": "2026-01-17T02:57:11.043200",
    "cve_id": "CVE-2018-12320",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e8b5500b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory for `attr` and its internal list. If the initial size check (`offset + 8 > sz`) fails, `attr` is freed, demonstrating ownership cleanup. However, the loop may break early if `offset >= sz`, leaving the partially populated list. The list's destructor (`r_bin_java_bootstrap_method_free`) should handle cleanup, but overall ownership semantics during partial parsing could be more explicit.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Specification focuses on file content processing and empty files. The code processes a binary buffer, not a file directly. While buffer size (`sz`) is checked, the specific edge case of an \"empty\" buffer (sz == 0) is not explicitly handled at the start; `r_bin_java_default_attr_new` might handle it.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple exit paths (return NULL, return attr). Resource cleanup (freeing `attr`) is done on the early size check failure. The `r_list_newf` with a destructor helps cleanup. However, if the loop breaks early due to `offset >= sz`, the function still returns `attr` (with partial data), which may leave the object in an inconsistent state (size field set to final `offset`, but list may be incomplete).",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Specification is about validating IPP (Internet Printing Protocol) attribute values. The code parses Java class file attributes (BootstrapMethods), which is a completely different domain and protocol. No relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "Specification concerns sanitizing printer configuration files. The code parses Java bytecode, not printer files. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "Specification is about strict message parsing for IPP protocol. The code parses Java class file structures, which is a different binary format. The principle of strict parsing (size checks) is present, but the protocol context is entirely different.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs buffer operations (`buffer + offset`, `sz - offset`) and uses size parameters (`sz`, `offset`). It validates `offset + 8 > sz` before reading `num_bootstrap_methods`, and checks `offset >= sz` in the loop. These checks prevent buffer over-reads by validating offsets against the total size `sz`, which is unsigned (ut64). This directly addresses signedness/unsigned size validation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code reads a `num_bootstrap_methods` field (likely a 16-bit unsigned value) and uses it as a loop counter. The loop condition `i < attr->info.bootstrap_methods_attr.num_bootstrap_methods` relies on this value being sane. While there's no explicit check that this count is non-negative (it's unsigned), the code does validate that sufficient data exists (`offset >= sz` break) before each iteration, indirectly constraining the effective length of operations based on the remaining buffer size.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      }
    ]
  },
  "CVE-2022-29195_before_subset_100:efa65bf1:spec": {
    "timestamp": "2026-01-17T02:57:33.934590",
    "cve_id": "CVE-2022-29195",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "efa65bf1",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses `core::ScopedUnref` for automatic reference counting cleanup, which is a form of ownership management. However, the specification focuses on \"memory release operations\" with \"strict ownership semantics,\" which is only partially relevant as the primary memory management here is via ref-counting rather than explicit allocation/deallocation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about file content processing and empty files. The target code deals with buffer/tensor operations in a computational graph context, not file I/O. No relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code uses RAII (`ScopedUnref`) for resource cleanup, ensuring cleanup on all exit paths. However, the specification broadly addresses \"resource cleanup\" and \"consistent state,\" which applies partially but not comprehensively to this limited scope.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification refers to IPP (Internet Printing Protocol) attribute validation. The target code is unrelated to printing protocols.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code does not process printer files or configurations.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about IPP protocol message parsing. The target code is not implementing a network protocol.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer operations (`buf->Peek(index, &tuple)`) and validates the tuple size against the number of outputs. This aligns with validating length/parameters against expected sizes, though not explicitly against a \"destination buffer size\" in the classic C sense.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "The code validates external input (`ctx->input(0).scalar<int>()()`) indirectly through `OP_REQUIRES_OK` and `OP_REQUIRES` checks. The index is used in `buf->Peek`, and the tuple size is validated before use, demonstrating input validation before buffer operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      }
    ]
  },
  "CVE-2022-29195_after_subset_100:198ab99b:spec": {
    "timestamp": "2026-01-17T02:58:21.571373",
    "cve_id": "CVE-2022-29195",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "198ab99b",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code uses `core::ScopedUnref` for automatic reference counting cleanup, which is a form of memory/ownership management. However, it's a high-level RAII pattern rather than explicit memory release operations. The principle of maintaining strict ownership semantics is partially relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code does not process file content. It deals with tensor buffers in a computational graph context, not file I/O operations.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The code uses RAII (`ScopedUnref`) for resource cleanup, which helps maintain consistent state. However, the code path is relatively simple with no complex branching, so the full importance of this specification is not fully demonstrated.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not process IPP (Internet Printing Protocol) attributes. This specification is specific to printing protocol implementations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not process printer configuration files or any configuration files. This specification is completely unrelated to the tensor buffer manipulation shown.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement or parse IPP protocol messages. This is a machine learning framework kernel implementation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code validates that `tuple.size()` matches `ctx->num_outputs()` before proceeding with buffer operations. This is a length validation that prevents buffer mismatches, though it's not checking against a specific destination buffer size in the traditional sense.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "The code validates the size of the retrieved tuple against expected outputs, which could be considered validation of external input (the buffer contents). However, the validation is somewhat limited in scope compared to comprehensive input validation.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      }
    ]
  },
  "CVE-2019-11454_before_subset_100:211b7ca8:spec": {
    "timestamp": "2026-01-17T02:58:27.714775",
    "cve_id": "CVE-2019-11454",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "211b7ca8",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve explicit memory allocation or deallocation operations (like malloc/free). It uses a fixed-size stack buffer and a StringBuffer for output. The concept of \"ownership semantics\" for memory release is not directly applicable here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The code processes file content (a log file) by reading it in chunks. It handles the case where the file fails to open. However, it does not explicitly demonstrate handling of all edge cases, such as files containing null bytes or very long lines that could affect the HTML output. The `fread` call uses `sizeof(buf) - 1` to leave room for a null terminator, which is a good practice for string handling, but the overall file processing is basic.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code opens a FILE resource (`f`) and correctly closes it using `fclose(f)` on the successful path. However, there is a potential resource leak if `fopen` succeeds but a later operation (before the `fclose`) causes an early function return (not present in this snippet) or if an exception occurred in a language that supports them. In this C code, the cleanup path appears consistent for the shown logic. The `f` variable is only defined within the `if (f)` block, ensuring it's not used uninitialized.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not process IPP (Internet Printing Protocol) attribute values. It handles an HTTP request to view a log file, which is unrelated to printing protocols.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code reads a log file for display, not a printer configuration file. There is no sanitization shown related to printer configurations.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code is part of an HTTP server handling a specific request (`do_viewlog`). It does not implement or parse the IPP protocol.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform archive extraction. It reads a single, specified log file directly from the filesystem.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform any extraction (sandboxed or otherwise). It reads a file from a predetermined path (`Run.files.log`). There is no path isolation mechanism involved.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      }
    ]
  },
  "CVE-2019-11454_after_subset_100:a6c151b0:spec": {
    "timestamp": "2026-01-17T02:58:34.322613",
    "cve_id": "CVE-2019-11454",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a6c151b0",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve explicit memory allocation or deallocation operations. It uses a fixed-size stack buffer and a StringBuffer for output. There are no malloc/free or similar operations where ownership semantics would be a primary concern.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code processes file content (a log file) by reading it in chunks. It handles the case where the file cannot be opened (fopen fails) but does not explicitly demonstrate handling of all edge cases like empty files (the while loop would simply not execute, resulting in an empty textarea, which is acceptable). The principle of robust file content processing applies.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code opens a FILE resource (f) and correctly closes it with fclose(f) on the successful path. However, it should be evaluated if all error or early return paths ensure the file is closed. The code structure shows fclose is only called if fopen succeeds and is placed before the function ends, which is good. The principle of maintaining consistent resource state across execution paths is directly applicable to file handling.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is for viewing a log file via a web interface. It does not process IPP (Internet Printing Protocol) attribute values. The specification is specific to a different protocol domain.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function handles HTTP requests/responses to serve a web page containing log data. It does not implement or parse the IPP protocol.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code reads a file from a known, configured path (Run.files.log). It does not extract files from an archive or perform path traversal operations that would require path component validation.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform any extraction operations, sandboxed or otherwise. It simply reads and displays a file.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      }
    ]
  },
  "CVE-2022-2183_before_subset_100:36db90f3:spec": {
    "timestamp": "2026-01-17T02:58:48.979997",
    "cve_id": "CVE-2022-2183",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "36db90f3",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve any dynamic memory allocation or deallocation. It operates on local variables, cursor positions, and string pointers from existing line buffers. There are no memory release operations to evaluate against ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes text content (Lisp code) line by line. While it handles various syntactic elements (parentheses, strings, comments, whitespace), it is not explicitly shown to handle all edge cases like extremely long lines or missing newlines. Its primary purpose is indentation calculation, not general file processing, so relevance is weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The function modifies the global cursor state (`curwin->w_cursor`) during its operation but restores it before returning. This is a form of state cleanup. However, the specification focuses on resource cleanup (like files, memory) across execution paths, not temporary state restoration. The connection is weak.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a Lisp indentation function for a text editor. It does not parse or process XML in any way. The specification is completely irrelevant to this code scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The code processes Lisp source code for indentation. It does not involve document processing (like XML, HTML) or entity resolution. The specification is completely irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code checks a configuration option (`p_cpo` for `CPO_LISP`) to decide between \"vi-compatible\" and other indentation methods. This gates a security-sensitive feature (parsing/interpretation logic that could be influenced by file content) behind an explicit user configuration. The principle of gating behavior based on configuration applies directly, though the security sensitivity here is low (indentation logic).",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The code processes Lisp syntax, not Internet Printing Protocol (IPP) attributes. There is no IPP functionality present. The specification is completely irrelevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code processes Lisp source code lines from a text editor buffer. It is not related to printer configuration files or any sanitization of such files. The specification is completely irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2022-2183_after_subset_100:d8ed21e4:spec": {
    "timestamp": "2026-01-17T02:59:01.329790",
    "cve_id": "CVE-2022-2183",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d8ed21e4",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation or release operations. It works with string pointers and cursor positions within existing buffers, but there is no dynamic memory management that would require ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes text lines (via ml_get_curline()) to calculate indentation. While it handles various characters and string escapes, it's not explicitly processing file content in a way that highlights edge cases like empty files. Its primary context is line-by-line analysis within an editor buffer.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The function saves and restores the cursor state (realpos) at the beginning and end, which is a form of state consistency. However, this is a simple local variable swap, not resource cleanup (like files, memory, or locks) across complex execution paths with early returns.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code is a Lisp indentation function for a text editor. It does not parse or process XML in any way, so XML external entity processing is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code does not process documents in a way that involves entity resolution (like XML, HTML, or SGML). It is analyzing Lisp/Scheme code for indentation.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 7,
        "reasoning": "The code checks the 'cpoptions' setting (p_cpo) for the CPO_LISP flag to decide between \"vi-compatible\" and other indentation logic. This gates a security-sensitive feature (code interpretation/indentation logic) behind an explicit configuration option, aligning with the specification's principle.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to the Internet Printing Protocol (IPP) or processing of IPP attributes. It is a syntax-aware indentation routine.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code does not process printer configuration files. It operates on generic text buffers within an editor for the purpose of calculating indentation.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2016-8652_before_subset_100:ddd79b54:spec": {
    "timestamp": "2026-01-17T02:59:43.425821",
    "cve_id": "CVE-2016-8652",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ddd79b54",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code allocates memory using t_malloc (likely a talloc or similar allocator) but does not explicitly release it within this function. The function returns the allocated table, so ownership is transferred to the caller. The specification about maintaining strict ownership semantics is weakly relevant because the code shows allocation and transfer, but we cannot evaluate the full ownership lifecycle or release operations from this snippet alone.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification about resource cleanup and consistent state across execution paths has very low relevance. The function primarily builds and returns a data structure. There is no complex resource acquisition or cleanup within the function that could lead to inconsistent state. The memory allocation is a single operation at the start.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification about validating IPP attribute values is very low relevance. This code is part of an authentication system (likely Dovecot), not an IPP (Internet Printing Protocol) implementation. The IP addresses present (local_ip, remote_ip) are converted to strings but not validated in a protocol-specific sense.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification about sanitizing printer configuration files is very low relevance. The code has no relation to printer configuration files or processing thereof.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification about IPP protocol message parsing is very low relevance. This code is not implementing or parsing the IPP protocol.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification about packet parsing failure handling and state initialization is very low relevance. This function is not parsing network packets. It is expanding variables from an already-parsed authentication request structure.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "The specification about protocol dissectors validating complete headers is very low relevance. This code is not a protocol dissector and does not process protocol headers.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      }
    ]
  },
  "CVE-2016-8652_after_subset_100:2f7b2112:spec": {
    "timestamp": "2026-01-17T02:59:56.859713",
    "cve_id": "CVE-2016-8652",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2f7b2112",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code allocates memory using t_malloc (likely a talloc wrapper) but does not explicitly free it within this function. The function returns the allocated table, so ownership is transferred to the caller. There is no direct memory release operation here to evaluate against strict ownership semantics. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about processing file contents and handling empty files. The target code performs authentication request variable expansion and string manipulation, with no file I/O operations. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 2,
        "reasoning": "The specification concerns resource cleanup and state consistency across execution paths. This function primarily builds and populates a data structure. While it allocates memory, it does not perform cleanup of other resources (like file handles, network sockets) or have complex error paths that require state rollback. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code handles authentication data (usernames, IP addresses, ports, etc.) for a mail/authentication service, not IPP. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code does not process configuration files; it expands variables for an authentication request. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about enforcing strict message parsing for the IPP protocol. The target code is part of an authentication system, not an IPP protocol implementation. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 2,
        "reasoning": "The specification is about packet parsing failure handling and state initialization. While this function initializes a table structure (setting values, some via conditional checks), it is not parsing network packets. Its failure modes (e.g., NULL pointers) are handled via simple conditional checks, not a comprehensive state machine. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 1,
        "reasoning": "The specification is about protocol dissectors validating complete headers before processing. This code is not a protocol dissector; it's a helper function for variable expansion. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      }
    ]
  },
  "CVE-2016-7101_before_subset_100:25b3cb7e:spec": {
    "timestamp": "2026-01-17T03:00:14.398960",
    "cve_id": "CVE-2016-7101",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "25b3cb7e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code demonstrates strict ownership semantics for dynamically allocated arrays (orders, insParaPtrs, patParaPtrs, samplePtrs, pattern, packed). Memory is consistently released using delete[] on all code paths before returning, including error paths. However, there is a potential issue in the nested allocation for `packed` where if `new mp_ubyte[size+5]` fails and throws an exception (if exceptions are enabled), the previously allocated arrays might not be freed, though the current code returns NULL and MP_OUT_OF_MEMORY. The ownership chain is clear and maintained.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 9,
        "reasoning": "The code is a file format loader (S3M module) and must handle various edge cases in file content. It performs multiple reads and seeks based on offsets and sizes read from the file. It includes safety checks like verifying the file type (byte value 16), checking pattern sizes, and using a `safeRead` function (implied by its use) to prevent reading beyond buffer boundaries. It also has checks for loop length becoming negative and row index exceeding 64. However, it does not explicitly handle completely empty or truncated files at the very beginning; some initial reads are assumed to succeed.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Resource cleanup (memory deallocation) is performed consistently across most execution paths. All dynamically allocated arrays are deleted before returning, whether due to success (MP_OK) or error (MP_OUT_OF_MEMORY, MP_LOADER_FAILED). The cleanup cascades correctly in error cases, deleting only the arrays allocated up to that point. The state of the module (header, instruments, samples, patterns) is also initialized/cleaned via `module->cleanUp()` at the start.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about XML parsers and disabling external entity processing. The target code is a binary music file (S3M) loader, not an XML parser. This specification is completely irrelevant to the code scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns document processing and entity resolution boundaries, likely in the context of XML or similar structured documents. The target code processes a binary module format with no concept of entities or external references. It does not apply.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The specification is about gating security-sensitive features behind explicit configuration. The code is a file loader with no apparent security-sensitive features (like network access, system calls, or configurable security policies) that need to be enabled via configuration. It is a straightforward data parser.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The specification is for image parsers validating dimensions against file size. While not an image parser, the code does parse a binary format and performs some validation of claimed data sizes. For example, it reads a pattern `size` from the file and then reads that many bytes into a buffer. It also checks `smp[s].samplen` before loading the sample. However, it does not comprehensively validate all dimensions (e.g., `header->ordnum`, `header->insnum`, `header->patnum`) against the actual file size before allocating memory or performing reads based on them. The relevance is very low but not zero.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The code is a file format reader that allocates memory based on dimensions read from the file (e.g., `header->ordnum`, `header->insnum`, `header->patnum`, pattern `size`). It performs safe dimension checking in some places: it uses a `safeRead` function when unpacking patterns to prevent buffer overflows, and it has a check `if (size > 2)` before allocating `packed` of size `size+5`. However, it does not validate the *reasonableness* of the dimensions (e.g., against maximum limits) before allocation, which could lead to excessive memory allocation. The principle of safe dimension checking before allocation is central to this code.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2022-23577_before_subset_100:d8fae047:spec": {
    "timestamp": "2026-01-17T03:00:28.542905",
    "cve_id": "CVE-2022-23577",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d8fae047",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve explicit memory allocation or deallocation. It works with string references and protobuf objects, typically managed by higher-level containers. There are no manual memory release operations to evaluate against ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes a MetaGraphDef protobuf structure loaded from a file (export_dir). While it handles missing keys and collection sizes, it does not explicitly demonstrate handling of all edge cases related to file content, such as a completely empty or malformed protobuf file. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function does not acquire or manage system resources (like file handles, network connections, or memory) that require explicit cleanup. It performs read-only queries on data structures and returns a Status. No resource cleanup logic is present.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification refers to validating IPP (Internet Printing Protocol) attribute values. The target code processes TensorFlow SavedModel metadata and has no relation to IPP or printer protocols.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is explicitly about sanitizing printer configuration files. The target code processes machine learning model graphs and has no relation to printer configuration or sanitization tasks.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing strict message parsing for the IPP protocol. The target code parses a TensorFlow-specific protobuf structure, which is a different domain. The general principle of strict parsing is partially present (e.g., checking value_size), but the direct protocol context does not apply.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code validates that `node_list().value_size() == 1` before accessing the first element. This is a form of numeric input validation (checking a count) that prevents out-of-bounds access, aligning with the core principle of the spec. However, it does not involve arithmetic operations or upper bounds in a broader sense.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 5,
        "reasoning": "The code validates a numeric field (`value_size`) from a protobuf structure (a file format) against a specific constraint (must be 1). This aligns with the principle of validating file format numeric fields. However, the validation is simple and the spec's mention of \"reasonable constraints\" is broader than this single equality check.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      }
    ]
  },
  "CVE-2016-7101_after_subset_100:f966b138:spec": {
    "timestamp": "2026-01-17T03:00:28.670494",
    "cve_id": "CVE-2016-7101",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f966b138",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code shows multiple dynamic memory allocations (new[]) and corresponding delete[] operations. While ownership is generally maintained (each allocation has a corresponding deallocation), there are complex execution paths with early returns. The code ensures cleanup of allocated arrays before returning errors in most cases, but careful analysis is needed to verify all paths maintain strict ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The code processes file content from an XMFileBase object, reading various headers and data structures. It includes some boundary checks (like checking pattern numbers against 256), but doesn't comprehensively handle all edge cases like truncated files or malformed data that could cause out-of-bounds reads. The safeRead function helps but overall edge case handling is incomplete.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple early return paths with resource cleanup. It generally maintains consistent state by deleting allocated memory before returning errors. However, there's one concerning pattern: the early return at line 17 doesn't clean up module state after module->cleanUp() was called, potentially leaving the module in an inconsistent state if other initialization occurred before that point.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code processes S3M music module files, not XML. There are no XML parsers or XML-related operations in this code, so this specification about XML external entity processing doesn't apply.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "This specification relates to document processing and entity resolution boundaries, which is specific to document formats like XML. The code processes S3M music files, which don't have entities in the XML sense, making this specification irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code doesn't implement security-sensitive features that would require gating behind configuration options. It's a file loader for a music format without apparent security-sensitive functionality that needs explicit enabling/disabling.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "While not an image parser, the code does process binary file formats with dimensions (pattern sizes, sample lengths). It performs some validation (checking patnum > 256, insnum > MP_MAXINS) but doesn't comprehensively validate all claimed dimensions against actual file data size, which is conceptually similar to the image parser requirement.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant as the code is a file format reader that performs memory allocations based on file data. It does implement some dimension checking (header->patnum > 256, header->insnum > MP_MAXINS) before allocations, but could benefit from more comprehensive validation of all size fields before allocation to prevent excessive memory consumption or integer overflows.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2022-23577_after_subset_100:460505a0:spec": {
    "timestamp": "2026-01-17T03:01:06.664088",
    "cve_id": "CVE-2022-23577",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "460505a0",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve any explicit memory allocation or deallocation operations. It works with string references and protobuf messages, managing object lifetimes through standard C++ semantics (stack variables, parameter passing). There is no manual memory management to which strict ownership semantics would apply.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes a data structure (MetaGraphDef) loaded from a file, but it does not directly handle raw file content or its edge cases (like empty files). The validation focuses on the structure and presence of keys within the already-parsed protobuf, not on the file reading process itself.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function does not acquire or manage external resources (like file handles, network connections, or dynamic memory) that require explicit cleanup. It performs read-only queries on input data structures and returns a status and a string. There is no resource state to be cleaned up or made consistent across paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code is part of TensorFlow's model loading logic and has no relation to printing protocols or IPP.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is explicitly about sanitizing printer configuration files. The target code processes machine learning model metadata and has no connection to printer functionality or configuration files.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code validates that `node_list().value_size() == 1`, which is a form of numeric input validation enforcing a specific bound (equality to 1). However, it is not validating user input for arithmetic operations, nor is it checking for typical overflow/underflow scenarios. The relevance is weak to moderate.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 5,
        "reasoning": "The code validates the `value_size()` from a protobuf field, which can be seen as validating a numeric field from a serialized file format (the SavedModel). It ensures it meets a specific constraint (==1). However, it does not check for \"reasonable constraints\" in a broad sense (like min/max ranges for integrity), only a specific expected value.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      }
    ]
  },
  "CVE-2015-5156_before_subset_100:bbbb56ed:spec": {
    "timestamp": "2026-01-17T03:01:28.508271",
    "cve_id": "CVE-2015-5156",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bbbb56ed",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code performs arithmetic operations and memory writes but does not involve any explicit memory allocation or release operations. Ownership semantics for dynamically allocated memory are not relevant here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes arrays in memory, not file content. Edge cases related to file I/O, such as empty files, are not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 2,
        "reasoning": "The function performs computations and writes results. It does not acquire or manage system resources (like file handles, network connections) that require cleanup across different execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 3,
        "reasoning": "The code uses parameters from the `ArithmeticParams` structure (like offsets, multipliers, broadcast_shape). While input validation is generally good practice, the specification is specifically about IPP (Internet Printing Protocol) attributes, which is not the context of this code.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code is a mathematical broadcast function with no relation to printer configuration or file sanitization.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about enforcing strict message parsing for the IPP protocol. The target code is a low-level arithmetic loop and does not implement any network protocol.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 6,
        "reasoning": "The code uses dimensions (y0-y4) from `params.broadcast_shape` to guide loop iterations and pointer arithmetic. While not parsing an image file, the principle of validating claimed dimensions against actual data bounds to prevent out-of-bounds memory access is moderately relevant. The function trusts the provided shapes and sizes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 6,
        "reasoning": "Similar to spec_7. The code operates on pre-allocated buffers based on provided dimensions. The principle of performing safe dimension checking before using them to calculate memory offsets and loop bounds is relevant to prevent buffer overflows, though the allocation itself happens elsewhere.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2021-37688_after_subset_100:78bccf0a:spec": {
    "timestamp": "2026-01-17T03:01:53.337423",
    "cve_id": "CVE-2021-37688",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "78bccf0a",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code performs arithmetic operations on array data but does not involve any explicit memory allocation or release operations. Ownership semantics for memory are not a primary concern in this function, as it operates on provided pointers and loops within given bounds. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes in-memory arrays, not file content. There is no file I/O or handling of file-specific edge cases like empty files. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "The function performs computations and updates output data. It does not acquire or manage resources (like file handles, network connections, or dynamic memory) that require cleanup across different execution paths. State consistency for resource cleanup is not a concern here.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "The specification refers to validating IPP (Internet Printing Protocol) attribute values. The target code is a generic tensor/broadcast arithmetic function with no relation to IPP or printing protocols.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns sanitizing printer configuration files. The target code performs numerical array operations and has no interaction with configuration files, printers, or sanitization logic.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 2,
        "reasoning": "The specification is about enforcing strict message parsing for the IPP protocol. The target code is a mathematical kernel function for array broadcasting and does not implement any network protocol or message parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 6,
        "reasoning": "While the code does not parse image files, it operates on multi-dimensional arrays (tensors) with shapes and broadcast parameters. It implicitly relies on the correctness of dimensions (y0-y4) derived from `params.broadcast_shape`. If these dimensions were invalid (e.g., not matching the actual data size), it could lead to out-of-bounds memory access. The principle of validating claimed dimensions against actual data size has moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 6,
        "reasoning": "Similar to spec_7, this code is not a file format reader. However, it is a data processing function that uses dimensions to guide memory access loops. Safe dimension checking before proceeding with the nested loops is a relevant secure coding principle to prevent buffer overflows. The connection is moderate.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2021-3888_before_subset_100:49f50fb5:spec": {
    "timestamp": "2026-01-17T03:01:58.258864",
    "cve_id": "CVE-2021-3888",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "49f50fb5",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code validates the `huff_rec_count` against a maximum (`HUFF_RECORD_MAXCNT`) and checks the size of the initial HUFF record against a minimum (`HUFF_RECORD_MINSIZE`). This aligns with the principle of validating claimed dimensions (like record count and size) against expected limits before processing, though it's for a data structure parser, not an image parser.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "The code performs a safe dimension check (`huff_rec_count > HUFF_RECORD_MAXCNT`) before allocating memory based on that count (`malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols))`). This directly implements the principle of validating input dimensions to prevent excessive memory allocation.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 3,
        "reasoning": "The code allocates memory but does not show any memory release operations (free). Therefore, the specification about maintaining strict ownership semantics during release is not applicable in this visible code segment.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 6,
        "reasoning": "The code handles several edge cases: checking for NULL pointers, validating record counts and sizes, and handling the case where `curr` becomes NULL during iteration. It does not explicitly show handling of an entirely \"empty\" input data structure, but it validates the presence of necessary metadata and records.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The code has multiple early return paths on error. If an error occurs after `malloc` but before the function returns, the allocated memory for `huffcdic->symbols` is not freed, potentially causing a memory leak and leaving the `huffcdic` structure in an inconsistent state (symbols pointer allocated but other fields potentially uninitialized). This is a weakness related to resource cleanup on error paths.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2021-3888_after_subset_100:2765864b:spec": {
    "timestamp": "2026-01-17T03:02:17.373978",
    "cve_id": "CVE-2021-3888",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2765864b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates `huff_rec_count` against `HUFF_RECORD_MAXCNT` before proceeding, which is analogous to validating claimed dimensions (record count) against a safe maximum. It also checks `curr->size` against `HUFF_RECORD_MINSIZE`. This aligns with the core principle of validating input dimensions before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 9,
        "reasoning": "The code performs a critical safe dimension check (`huff_rec_count > HUFF_RECORD_MAXCNT`) before a subsequent memory allocation (`malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols))`). This directly implements the specification's requirement to check dimensions before allocation to prevent excessive memory consumption.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The provided code snippet does not contain any memory release operations (e.g., `free`). It only has a `malloc`. Therefore, the specification about maintaining strict ownership semantics during release is not applicable to this code segment.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code handles several edge cases: it checks for NULL pointers in metadata, validates record count and size, and handles the case where `curr` becomes NULL during the CDIC record iteration. While it doesn't explicitly mention \"empty files,\" it robustly handles malformed or insufficient data, which covers the spirit of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple early return paths on error. If `mobi_parse_huff` or `mobi_parse_cdic` fails, or if malloc fails, the function returns without freeing the `huffcdic->symbols` pointer that was just allocated. This creates a memory leak and an inconsistent state (allocated memory is lost), violating the principle of consistent state cleanup across all paths. The relevance is low because the specification is about a problem the code has, not a practice it demonstrates.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is parsing a custom HUFF/CDIC dictionary structure for MOBI e-books, not XML. The specification regarding XML external entity processing is completely unrelated to this code's functionality.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec_6, this specification concerns document processing entities (like XML entities). The target code parses a binary compression dictionary format and has no concept of entity resolution.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code implements core parsing logic for a file format. It does not implement any security-sensitive features (like decryption, network access, or system commands) that would need to be gated behind configuration options. It is purely a data validation and parsing routine.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2022-2288_before_subset_100:c73e50b5:spec": {
    "timestamp": "2026-01-17T03:02:35.802185",
    "cve_id": "CVE-2022-2288",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c73e50b5",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve explicit memory allocation or deallocation operations. It primarily parses command strings and modifies command modifier structures. While there is pointer manipulation (e.g., eap->cmd pointer arithmetic), there are no memory release operations that would require strict ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes command-line input, not file content. It handles edge cases like empty commands and comments, but this is command parsing rather than file processing. The specification about file content edge cases has minimal relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The code has multiple return paths and error conditions. While it doesn't manage traditional resources like file handles or memory, it does modify parser state (eap->cmd pointer) and command modifier structures. Some consistency is maintained, but this is not the primary focus of the code.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code is a command parser for Vim editor commands, not an XML parser. There is no XML processing whatsoever, so this specification is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Similar to spec 4, this specification deals with document processing and entity resolution, which has no relation to Vim command parsing. The code processes command modifiers, not documents with entities.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 6,
        "reasoning": "The code includes conditional compilation for features like FEAT_BROWSE_CMD, FEAT_GUI_DIALOG, and FEAT_CON_DIALOG, which gates security-sensitive features behind configuration options. However, this is more about feature availability than explicit security configuration.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 1,
        "reasoning": "The code does not process images or validate dimensions. It's a command-line parser for editor commands, completely unrelated to image parsing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 2,
        "reasoning": "While the code does some parsing and validation (e.g., checking tab numbers against valid ranges), it doesn't read file formats or perform dimension checking before memory allocation. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2022-2288_after_subset_100:da5b1e72:spec": {
    "timestamp": "2026-01-17T03:03:01.918855",
    "cve_id": "CVE-2022-2288",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "da5b1e72",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not contain any explicit memory release operations. It primarily parses command modifiers and manipulates string pointers. While there is potential for memory allocation (e.g., vim_regcomp), the specification about strict ownership semantics during memory release is not directly addressed in the shown code segment.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes command-line input strings, not file content. It handles edge cases like empty commands and comments, but the specification specifically concerns processing the content of files, which is not the context of this function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function manages parsing state and command modifiers. There is some resource allocation (vim_regcomp for the 'filter' modifier) and the function has multiple return paths. However, the code shown does not demonstrate comprehensive cleanup of allocated resources (like the regprog) on all failure paths, making the relevance to maintaining consistent state during resource cleanup only partial and indirect.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a command parser for Vim, not an XML parser. The specification about disabling external entity processing in XML parsers is completely irrelevant to this code scenario.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns document processing and entity resolution, which is unrelated to the command modifier parsing functionality of the target code.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code conditionally enables certain features (like CMOD_BROWSE, CMOD_CONFIRM) based on compile-time feature flags (FEAT_BROWSE_CMD, FEAT_GUI_DIALOG, etc.). This aligns with the principle of gating security-sensitive or optional features behind explicit configuration, though the \"security-sensitive\" aspect is not strongly emphasized for all flagged features.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The code does not parse images or any file format that involves dimensions. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The code is not a file format reader that allocates memory based on dimensions. It parses strings and may compile a regex pattern, but this does not involve checking dimensions before allocation as specified.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2022-1055_before_subset_100:f42ad556:spec": {
    "timestamp": "2026-01-17T03:03:38.191880",
    "cve_id": "CVE-2022-1055",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f42ad556",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves multiple resource management operations (tcf_proto, tcf_chain, tcf_block) with complex ownership transfers. Functions like tcf_proto_put, tcf_chain_put, and tcf_block_release must maintain strict ownership semantics to prevent leaks or double-frees. The error handling paths carefully manage these resources, making this specification highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "This specification deals with file content processing edge cases. The target code processes network messages and TC filter configurations, not file contents. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error paths (errout, errout_locked, errout_tp) that must consistently clean up resources (mutex locks, chain references, block references, tp allocations). The code shows careful state cleanup across different failure scenarios, including the replay mechanism for EAGAIN.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 3,
        "reasoning": "This appears to be a mislabeled specification (HS-MEM-003 duplicate). It mentions network feature declarations matching implementation capabilities. While the code handles TC filter features, the specification's focus doesn't directly align with the main logic of filter creation and management.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 3,
        "reasoning": "The code processes Netlink messages and TC filter commands, not packet fragments. While it validates message structures, it doesn't deal with packet fragmentation or buffer space allocation for fragments.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs capability checks (CAP_NET_ADMIN) at the beginning and validates various constraints (chain index limits, filter kind matching, protocol requirements). However, this is more about permission and parameter validation than feature negotiation between peers.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function initializes many local variables and must handle parsing failures (nlmsg_parse_deprecated, parameter validation) while ensuring proper state initialization. The error paths ensure resources are properly cleaned up even when parsing fails early.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates Netlink message structure and TC filter attributes, which is somewhat analogous to protocol header validation. However, it's not a traditional protocol dissector processing network packets with layered headers.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      }
    ]
  },
  "CVE-2018-12320_after_subset_100:11312ba0:spec": {
    "timestamp": "2026-01-17T03:03:46.157854",
    "cve_id": "CVE-2018-12320",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "11312ba0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves multiple resource management operations (tcf_proto, tcf_chain, tcf_block, fh handles) with get/put semantics. The error handling paths (errout, errout_tp, errout_locked) must correctly release resources based on ownership and creation state (tp_created flag). This aligns with memory/ownership semantics, though it's more about resource ownership than pure memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "This specification is about file content processing edge cases. The target code deals with network filter configuration via netlink messages, not file I/O. There is no file reading or empty file handling involved.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function has complex error handling with multiple cleanup labels (errout, errout_tp, errout_locked). It must ensure proper resource cleanup (chain, tp, block, rtnl lock) across all execution paths, including the replay goto. The tp_created flag is used to track state for correct cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code handles network filter features, the specification about \"network feature declarations matching implementation capabilities\" is more about API/ABI declarations. The code validates filter kind (TCA_KIND) and protocol, but this is more about parameter validation than declaration matching.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code processes netlink messages (skb) but doesn't deal with packet fragmentation or buffer pre-allocation for fragments. It's about control plane filter management, not data plane packet processing.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code starts with a capability check (CAP_NET_ADMIN) and validates user-provided parameters (priority, chain index, filter kind). However, it's not a typical feature negotiation protocol; it's more about authorization and parameter validation for filter operations.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code initializes many local variables (tp, block, q, chain, etc.) to NULL/0 before use. Error handling after nlmsg_parse_deprecated failure returns early, but state initialization is already done. The \"replay\" goto could potentially reinitialize state, though some variables are reset at the start.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code parses netlink messages (nlmsg_parse_deprecated) and validates attributes presence (TCA_KIND, TCA_CHAIN). This is similar to protocol validation but for netlink attributes rather than network packet headers. It checks for required fields before proceeding with processing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      }
    ]
  },
  "CVE-2018-1000085_before_subset_100:41b90a71:spec": {
    "timestamp": "2026-01-17T03:04:11.294465",
    "cve_id": "CVE-2018-1000085",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "41b90a71",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves multiple memory management operations (gf_isom_box_del, gf_list_add, etc.) and ownership transfers. While it shows some ownership discipline (e.g., deleting boxes when duplicates are detected), there are complex execution paths with multiple conditional branches where resource cleanup must be carefully handled to maintain strict ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The function parses ISO media file boxes and handles incomplete files (GF_ISOM_INCOMPLETE_FILE). It checks for available data and handles edge cases like missing moov/meta boxes, but doesn't explicitly handle completely empty files. The progressive_mode flag and bytesMissing parameter show some edge case consideration.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has numerous execution paths with resource allocation and cleanup. It must maintain consistent state across all branches (success, error, incomplete file). The code shows careful state management with early returns and cleanup, but the complexity of switch cases and conditional branches makes consistent state maintenance critical.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. This is an ISO media file parser, not an image parser. While it processes box dimensions (size fields), it doesn't deal with image dimensions specifically. The validation of box sizes against file data is related but not the same as image dimension validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code parses file format boxes with size fields and must perform safe dimension checking before memory allocation. Functions like gf_isom_parse_root_box likely validate box sizes. The code handles box size fields (a->size) and checks for incomplete files, which relates to safe dimension checking.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is not an XML parser; it's a binary ISO media file parser. The code deals with box structures, not XML documents or entities.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes ISO media boxes, not XML documents. There are no entity resolution mechanisms involved in this binary file parsing code.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses conditional compilation (GPAC_DISABLE_ISOM_FRAGMENTS) and runtime flags (FragmentsFlags) to gate features. Security-sensitive parsing modes (like FRAG_READ_DEBUG) are controlled by flags, showing some alignment with gating features behind configuration.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2018-1000085_after_subset_100:c0ccd4ff:spec": {
    "timestamp": "2026-01-17T03:04:24.477127",
    "cve_id": "CVE-2018-1000085",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c0ccd4ff",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves multiple memory management operations (gf_isom_box_del, gf_list_add, etc.) and must ensure proper ownership semantics when boxes are added to lists or deleted. There are several paths where boxes are deleted or retained, requiring careful ownership tracking to avoid double-frees or leaks.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The function parses a file format (ISO base media file format) and must handle edge cases like incomplete files (GF_ISOM_INCOMPLETE_FILE), empty or truncated data, and progressive parsing modes. It checks for available data and missing bytes, which relates to handling file content edge cases.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Resource cleanup is critical across many execution paths (error returns, duplicate box detection, mode switches). The code must maintain consistent state for mov structures, TopBoxes lists, and other resources when errors occur or boxes are deleted. Multiple return paths require careful cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is for ISO media file parsing, not specifically image parsing. While media files can contain images, the function doesn't validate image dimensions against file data size directly. This specification is not directly applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "As a file format reader, the code parses box sizes and structures. It should perform safe dimension checking before memory allocation for boxes. The gf_isom_parse_root_box (called internally) likely handles size validation, making this relevant.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve XML parsing; it parses binary ISO media file formats. External entity processing is irrelevant to this context.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 6, this specification about document processing and entity resolution boundaries doesn't apply to binary media file parsing.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code includes conditional compilation (GPAC_DISABLE_ISOM_FRAGMENTS) and feature flags (GF_ISOM_FRAG_READ_DEBUG) that gate security-sensitive parsing behaviors (like fragment handling). This aligns with gating features behind configuration options.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2022-29156_before_subset_100:e71b1c15:spec": {
    "timestamp": "2026-01-17T03:04:56.048981",
    "cve_id": "CVE-2022-29156",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e71b1c15",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs a simple kfree on a single structure obtained via container_of. While it does not involve a traditional linked list traversal, the `container_of` macro is a common pattern for retrieving a parent structure from a member pointer, which is a form of structural relationship. The deallocation of `clt` correctly follows this relationship, maintaining consistency. However, the specification emphasizes \"neighbor relationships\" in linked structures, which is not fully demonstrated here, making it strongly relevant but not a perfect match.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The function is a device release callback responsible for freeing memory. This is a resource cleanup operation. However, \"complete isolation state\" implies more comprehensive cleanup, such as ensuring no other references exist, removing the object from global lists, or releasing other associated resources. The code only performs a basic memory free, which is a part of isolation but may not be complete if `clt` holds other resources. Therefore, it has moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The code's core action is a memory release operation (`kfree`). \"Strict ownership semantics\" means the code freeing the memory must be its unambiguous owner. The function is a `dev_release` callback, which is typically called when the device's reference count reaches zero, indicating the kernel has transferred ownership to this function for final release. The use of `container_of` correctly identifies the owned structure based on the provided device pointer, demonstrating proper ownership tracking.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about processing file content and handling edge cases like empty files. The target code is a device release function in the kernel that performs memory deallocation. It does not involve file I/O, reading file content, or processing any external input streams. Therefore, it has very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function is a cleanup path (device release). The specification about maintaining consistent state across all execution paths is relevant. This single-path function does one thing: frees the session structure. Consistency depends on whether this is the *only* place `clt` is freed and if all other references are properly managed before this is called. The code itself is simple and consistent, but the broader context (how this function is invoked) determines if the specification is fully met. This gives it moderate to strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification mixes memory release (HS-MEM-003) with network feature declarations. The target code performs a memory release (`kfree`) but is part of an RTRS (RDMA Transport) client session structure, hinting at a network context. However, the code itself does not declare, negotiate, or implement any network features; it merely frees memory. The connection is very weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns packet processing, validating fragment counts, and buffer space. The target code is a memory deallocation routine in a device release callback. It does not process packets, handle network buffers, or deal with fragmentation. It has no relevance to this specification.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 5,
        "reasoning": "The specification is about feature negotiation and capability verification, typically during a connection or session setup phase. The target code is a destructor/cleanup function that runs when a session is being torn down. It does not perform any negotiation or verification. The weak connection exists because it operates on a network session (`rtrs_clt_sess`) object, but the function's purpose is opposite to negotiation.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      }
    ]
  },
  "CVE-2022-29156_after_subset_100:01ea2643:spec": {
    "timestamp": "2026-01-17T03:05:23.774562",
    "cve_id": "CVE-2022-29156",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "01ea2643",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code frees a linked structure (rtrs_clt_sess) but does not explicitly show traversal or neighbor pointer updates. The specification is moderately relevant because the function is a release handler that destroys mutexes and frees memory, implying the structure is being removed from a larger context. However, the code snippet itself does not show the linked list manipulation, only the final cleanup.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 8,
        "reasoning": "The specification is strongly relevant. The function performs resource cleanup (destroying mutexes and freeing memory) for a session object. Establishing \"complete isolation state\" means ensuring no resources are leaked and no references remain. The code destroys synchronization primitives before freeing the container, which is a key part of isolation.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 9,
        "reasoning": "The specification is highly relevant. The core of the function is a memory release operation (kfree(clt)). \"Strict ownership semantics\" means the function should only free memory it owns and ensure no other references exist. The context suggests this is the final release callback, implying ownership is clear. The destruction of mutexes before the free is part of maintaining proper ownership and lifecycle.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about file content processing and handling empty files. The target code is a device release function dealing with mutex destruction and memory deallocation. There is no file I/O or content processing involved, making the specification irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification is highly relevant. This is a cleanup function that must ensure all associated resources (mutexes, memory) are properly released to maintain a consistent state. The code shows a clear, singular execution path for cleanup, which is crucial for avoiding state inconsistencies like leaking mutexes or memory.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about network feature declarations matching implementations. The code is a cleanup routine for a client session structure, which may be part of a network module, but the snippet itself contains no declarations, feature negotiation, or capability checks. The connection is very weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 5,
        "reasoning": "The specification is about packet processing and validating fragment counts against buffers. The target code performs basic resource cleanup with no packet processing, network buffers, or validation logic. The specification does not apply.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 5,
        "reasoning": "The specification is about feature negotiation and capability verification. The code is a destructor function, not an initialization or negotiation function. While it might clean up state from a prior negotiation, the act of verification is not present in this snippet. Relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      }
    ]
  },
  "CVE-2022-0847_before_subset_100:2918d08d:spec": {
    "timestamp": "2026-01-17T03:05:40.543756",
    "cve_id": "CVE-2022-0847",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2918d08d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates pages with `alloc_page(GFP_USER)` but does not explicitly show memory release or ownership transfer. The function pushes data into a pipe buffer, and memory ownership is transferred to the pipe's buffer management. The specification is strongly relevant because proper ownership semantics must be maintained when pages are allocated and assigned to pipe buffers to prevent leaks or double frees. However, the release logic is not visible in this snippet.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification focuses on file content processing edge cases like empty files. This code deals with pipe I/O iteration and buffer allocation, not file content processing. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple execution paths (e.g., early returns, break on page allocation failure). It updates `pipe->head` and buffer fields but must ensure pipe state remains consistent if allocation fails or partial data is written. This relates to maintaining consistent state across execution paths during resource (page) allocation.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "The specification targets linked structure deallocation and neighbor relationships. This code builds a pipe buffer ring but does not deallocate or manipulate linked lists. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 4,
        "reasoning": "The specification concerns resource cleanup establishing isolation state (e.g., zeroing memory). This code allocates and assigns pages but does not show cleanup or isolation. Weak connection as cleanup is not the focus here.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function uses `size` and `i->count` and performs checks like `if (unlikely(size > i->count)) size = i->count`. It also uses `iter_head & p_mask` to index the pipe ring buffer, which validates against ring size. Buffer length operations (`buf->len = min_t(ssize_t, left, PAGE_SIZE)`) also enforce bounds. Directly aligns with buffer length validation principles.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The `size` parameter is likely derived from external input. The code validates it against `i->count` and handles edge cases (zero size). This is input validation before buffer operations, though the validation is minimal and assumes `i->count` is trustworthy.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. Pipes are kernel communication mechanisms, and this function manages pipe buffers. It enforces boundary checks via ring buffer masking (`iter_head & p_mask`) and size limits (`pipe->max_usage`). However, the specification emphasizes device communication buffers specifically, which is a broader category than pipes.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Device communication buffers must enforce strict boundary checks"
      }
    ]
  },
  "CVE-2022-0847_after_subset_100:5e26539c:spec": {
    "timestamp": "2026-01-17T03:06:05.184580",
    "cve_id": "CVE-2022-0847",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5e26539c",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code allocates memory pages (alloc_page) but does not show corresponding release operations. The specification about maintaining strict ownership semantics during memory release is moderately relevant. While the function pushes data into a pipe (likely for writing), proper ownership and cleanup of allocated pages in error or partial completion paths is important, but the full lifecycle isn't visible here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code deals with pipe buffers and memory allocation, not file content processing. The edge cases handled (size > i->count, !size) are related to buffer sizes, not file content like empty files.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function modifies pipe state (pipe->head, buf->len) and allocates resources (pages). If the allocation fails (alloc_page returns NULL), the loop breaks, but the function must ensure the pipe's internal state (like iter_head, buffered data) remains consistent. The code updates pipe->head iteratively, which needs to be correct across all paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Device communication buffers must enforce strict boundary checks"
      }
    ]
  },
  "CVE-2016-10154_before_subset_100:e9284692:spec": {
    "timestamp": "2026-01-17T03:06:37.101298",
    "cve_id": "CVE-2016-10154",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e9284692",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves multiple dynamic memory work areas (key, ctx, final_wa, tag) allocated via functions like ccp_init_dm_workarea and ccp_init_data. These resources are freed in a cleanup section (e_key, e_ctx, etc.) using functions like ccp_dm_free and ccp_free_data. The ownership and release of these memory buffers must be carefully managed across all error paths to avoid leaks or double-frees, which aligns with the core principle of HS-MEM-003.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "This specification is about file content processing and handling empty files. The target code is processing cryptographic data (AES-GCM operations on scatter-gather lists) from a hardware command queue. It does not involve file I/O or processing file contents. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer operations via functions like ccp_set_dm_area, ccp_get_dm_area, and scatterwalk_ffwd. It validates input lengths (key_len, authsize, iv_len) early in the function. However, the validation is primarily for cryptographic parameter correctness (e.g., allowed key sizes, auth sizes) rather than explicitly against a specific destination buffer size. The functions called likely perform internal bounds checking, but it's not directly visible. There is moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "The function validates multiple fields from the external `cmd` and `aes` structures before performing operations: it checks for non-NULL `aes->iv`, valid `aes->key_len`, non-NULL `aes->key`, and valid `authsize`. This input validation occurs before any significant buffer operations (DMA area setup, copy operations), which aligns well with HS-INPUT-002.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      },
      {
        "score": 5,
        "reasoning": "The code is part of a device driver (CCP - Cryptographic Coprocessor) communicating with hardware. It uses DMA work areas (`ccp_dm_workarea`) and performs copies to/from the device's \"SB\" (likely a hardware register/ memory block) via `ccp_copy_to_sb`/`ccp_copy_from_sb`. Ensuring that these operations respect the boundaries of the allocated work areas and the hardware's expected data sizes is critical to prevent corruption or information leakage, making this specification strongly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Device communication buffers must enforce strict boundary checks"
      },
      {
        "score": 5,
        "reasoning": "This specification is about packet parsing failure handling and state initialization. The target code is not parsing network packets. It is executing a cryptographic command. While it does initialize an `op` structure and has error handling, the context of \"packet parsing\" and ensuring \"complete state initialization\" for a parser is not directly applicable. The connection is very low.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "This specification is specifically for network protocol dissectors, which validate headers before processing. The target code performs a cryptographic operation (AES-GCM) on data provided via scatter-gather lists. It does not dissect or process any network protocol headers. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      }
    ]
  },
  "CVE-2013-7459_after_subset_100:dcdc7b28:spec": {
    "timestamp": "2026-01-17T03:06:45.670869",
    "cve_id": "CVE-2013-7459",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dcdc7b28",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code manages multiple DMA work areas (key, ctx, final_wa, tag) and data structures (src, dst, aad) with explicit allocation and deallocation (ccp_init_dm_workarea/ccp_dm_free, ccp_init_data/ccp_free_data). Ownership is clearly transferred and released along all error paths (e_key, e_ctx, etc.), maintaining strict ownership semantics. However, the primary focus is on DMA/device resources rather than general application memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification about file content processing edge cases is not directly relevant. This code processes cryptographic operation descriptors (AES-GCM) from a command queue, not file contents. While it does handle zero-length AAD and plaintext/ciphertext (ilen, aad_len), these are not \"file\" edge cases.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function has multiple resource allocation points (DMA work areas, data contexts) and a complex set of error labels (e_key, e_ctx, e_aad, e_src, e_dst, e_final_wa) ensuring cleanup occurs consistently across all failure paths. The goto chain ensures proper rollback in reverse allocation order, maintaining consistent state.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs buffer operations via scatter/gather lists and DMA areas. It validates key lengths and authsize against allowed values, and uses ilen derived from src_len and authsize. However, there is no explicit validation of destination buffer sizes for output operations against the actual allocated scatterlist lengths; it relies on the underlying DMA/crypto engine and prior validation.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function validates multiple external input parameters from the `aes` command structure early: checking for non-NULL IV, valid key lengths (128/192/256), non-NULL key scatterlist, and valid authsize values. This input validation occurs before any significant buffer operations.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code is entirely about device communication (CCP crypto accelerator). It uses DMA work areas and scatter-gather lists to transfer data to/from the device. Boundary checks are implicit in the `ccp_set_dm_area`, `ccp_get_dm_area`, and scatterwalk functions, which operate within pre-allocated DMA regions. The device operations (perform->aes) likely enforce hardware boundaries.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Device communication buffers must enforce strict boundary checks"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code parses a cryptographic command packet (AES-GCM parameters). Failure handling (via multiple error labels) ensures cleanup, but the \"complete state initialization\" aspect is partially met: the `op` structure is memset to zero and fields are set incrementally. If parsing fails early (e.g., invalid authsize), the function returns without extensive state cleanup because no resources were allocated yet.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification is about protocol dissectors validating headers. This function processes a cryptographic command, not a network protocol. However, it does validate the structure of the command (key, IV, authsize) before processing, which is analogous to header validation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      }
    ]
  },
  "CVE-2022-1205_before_subset_100:9b4c1879:spec": {
    "timestamp": "2026-01-17T03:07:03.337023",
    "cve_id": "CVE-2022-1205",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9b4c1879",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs socket and AX25 control block cleanup, involving memory release operations. It must ensure proper ownership semantics when releasing resources like `ax25_dev` (with `dev_put_track` and `ax25_dev_put`) and the socket itself (with `sock_put`). The sequence of operations (hold, orphan, release) must maintain correct ownership to prevent use-after-free or double-free issues.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about file content processing and edge cases for empty files. The target code is a network socket release function for the AX25 protocol, with no file I/O operations. There is no relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns DMA operations and VMAP_STACK, requiring heap-allocated buffers. The target code performs socket cleanup and protocol state management, with no DMA operations or stack buffer usage for DMA. No relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 1,
        "reasoning": "The specification is about USB control message handlers and buffer allocation validation. The target code is for AX25 (amateur radio) socket release, not USB. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      },
      {
        "score": 2,
        "reasoning": "The specification is about driver initialization and platform memory architecture constraints. The target code is a cleanup/release function, not an initialization routine. While it's part of a driver, the specific constraint about memory architecture during initialization does not apply here.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Driver initialization must account for platform memory architecture constraints"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code deallocates structures like the AX25 control block (`ax25`) which is part of a linked network stack. It must maintain consistent relationships with neighboring structures (e.g., the socket `sk`, the device `ax25_dev`). The cleanup sequence (orphaning, disconnecting, destroying) must ensure the overall linked data structure remains consistent.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function's purpose is resource cleanup and establishing a complete isolation state before returning. It must ensure the socket is fully disconnected, timers are stopped, references are dropped, and the socket is set to a destroyed state (`SOCK_DESTROY`), preventing any further operations on the released resources.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2016-0723_after_subset_100:08210d40:spec": {
    "timestamp": "2026-01-17T03:07:31.230179",
    "cve_id": "CVE-2016-0723",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "08210d40",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs socket and timer cleanup, which involves releasing memory resources. While not explicitly about ownership transfer, the operations (sock_hold/sock_put, timer deletion, dev_put_track) must maintain correct ownership semantics to prevent use-after-free or double-free issues. The pattern of holding a reference, performing operations, and then releasing it is central to the code's logic.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about processing file contents and handling edge cases like empty files. The target code is a network socket release function in the AX25 protocol implementation. It does not involve file I/O or file content processing at all.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function's primary purpose is resource cleanup (sockets, timers, device references) and it must ensure state consistency across multiple execution paths (different socket types, different AX25 protocol states). It uses switch statements and conditionals to handle different states, ensuring timers are stopped and resources are released appropriately for each path.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns DMA operations and VMAP_STACK, requiring heap-allocated buffers. The target code does not perform any DMA operations. It deals with socket protocol state management and timer cleanup.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 1,
        "reasoning": "The specification is about USB control message handlers and buffer allocation validation. The target code is for a network protocol (AX25) socket release, not USB device drivers. No USB operations or buffer allocation checks are present.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      },
      {
        "score": 2,
        "reasoning": "The specification is about driver initialization and platform memory architecture. The target code is a cleanup/release function, not an initialization function. While it's part of a driver, the specific concerns of memory architecture during initialization are not addressed here.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Driver initialization must account for platform memory architecture constraints"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code manages linked structures (sockets, associated AX25 control block `ax25`, and device `ax25_dev`). The cleanup logic, especially the conditional `ax25_destroy_socket` calls and the final cleanup block that removes timers and puts the device, must ensure that relationships between these structures are handled consistently to avoid dangling pointers or memory leaks.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function's core task is to establish a complete isolation state by releasing the socket and all its associated resources (timers, device references). It ensures the socket is orphaned, state is set to CLOSE, shutdown flags are set, callbacks are triggered, and finally, the socket pointer in the structure is nullified (`sock->sk = NULL`). This aims to isolate the released socket from the system.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-0213_before_subset_100:87107975:spec": {
    "timestamp": "2026-01-17T03:07:43.868110",
    "cve_id": "CVE-2022-0213",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "87107975",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not contain any explicit memory allocation or deallocation operations. It primarily handles string formatting and screen drawing. The static `busy` variable manages re-entrancy but is not a memory ownership issue. Therefore, HS-MEM-003 about memory release ownership has very low relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes a buffer name and status line text but does not read or process external file contents. The operations are on in-memory buffers for UI display. HS-INPUT-004 regarding file content processing edge cases is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code uses a `busy` flag to prevent re-entrancy, ensuring state consistency during recursive calls. This is a form of resource/state management. However, it's a simple boolean guard rather than complex resource cleanup (like files, memory, handles). The principle of maintaining consistent state applies moderately.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is part of a text editor's UI rendering (Vim). It does not process IPP (Internet Printing Protocol) attributes or any printing-related data. This specification is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not process printer configuration files. It is UI drawing logic for a status line. This specification has no connection.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement or parse the IPP protocol. It handles string formatting for display. This specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code does not parse image files or validate image dimensions. It deals with text buffers and screen coordinates. The connection is extremely weak, though there is a general concept of validating display space (this_ru_col) against text length.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The code does not read complex file formats or allocate memory based on file dimensions. However, it does perform bounds checking when preparing text for display (e.g., checking `len` against `this_ru_col` to avoid overflow in the status line). This aligns weakly with the general principle of safe dimension checking before use, though not for memory allocation.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2022-0213_after_subset_100:46ada946:spec": {
    "timestamp": "2026-01-17T03:08:20.712827",
    "cve_id": "CVE-2022-0213",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "46ada946",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not contain any explicit memory allocation or release operations. It primarily handles string formatting and screen drawing operations. While there is a static `busy` flag for preventing reentrancy, this is not related to memory ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes a buffer name and status information for display, not file content. It does not read or process external file contents, so file edge cases like empty files are not relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code uses a static `busy` flag to prevent reentrant calls and ensures it's set to FALSE before returning via a cleanup path. This shows some consideration for maintaining consistent state (preventing infinite recursion) across execution paths, though it's not about resource cleanup in the traditional sense (like memory or file handles).",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to IPP (Internet Printing Protocol) or processing of printer attribute values. It is part of a text editor's UI rendering logic.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not process printer configuration files or any external configuration files. It deals with window status line rendering in Vim.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement or parse any network protocols, including IPP. It is purely local UI update functionality.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code does not parse image files or validate image dimensions. It handles text strings for display and performs calculations based on screen columns and string lengths.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "While the code does check string lengths against buffer sizes (e.g., using `MAXPATHL` with `vim_snprintf`), which is a form of safe dimension checking to prevent buffer overflows, it is not allocating memory based on these dimensions. The relevance is weak because the specification is focused on file format readers and memory allocation, whereas this code is about formatting strings into a fixed-size buffer for display.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2022-1212_before_subset_100:dc7ada28:spec": {
    "timestamp": "2026-01-17T03:08:40.660794",
    "cve_id": "CVE-2022-1212",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dc7ada28",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a VM interpreter for mruby, handling opcode execution and stack manipulation. While it manages internal data structures (stack frames, call info, etc.), there is no explicit linked structure deallocation shown in this snippet. Memory management appears to be handled via garbage collection (mrb_gc_arena_save/restore). The specification about maintaining consistent neighbor relationships during deallocation is not directly applicable to the visible operations.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 3,
        "reasoning": "The code does not show explicit resource cleanup operations like file handles, network connections, or similar resources. It manages VM execution state, stack, and exceptions. The specification about establishing complete isolation state during cleanup is not relevant to the shown code paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 4,
        "reasoning": "The code uses garbage collection for memory management (mrb_gc_arena_save/restore, mrb_write_barrier). While memory ownership is implicitly managed by the GC, the specification about strict ownership semantics during explicit memory release is not directly applicable as there are no manual malloc/free operations visible in this VM interpreter core.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code is a bytecode VM interpreter for mruby, not a file processing system. It handles opcodes, stack operations, and method execution, but does not process file contents. This specification about file content edge cases is completely unrelated to the target code.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code shows some resource state management through exception handling (TRY/CATCH blocks), stack unwinding, and cleanup during control flow changes (like L_RAISE, L_BREAK). However, this is more about VM execution state consistency than external resource cleanup. There's moderate relevance in maintaining consistent state across exception paths.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a Ruby VM interpreter, not an XML parser. It handles bytecode execution, method dispatch, and object manipulation, but has nothing to do with XML parsing or external entity processing. This specification is completely irrelevant.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 6, this specification about document processing and entity resolution boundaries is completely unrelated to the mruby VM interpreter code. The code deals with Ruby language execution, not document processing.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code includes some configuration-like elements (MRB_USE_DEBUG_HOOK, DIRECT_THREADED, MRB_NO_FLOAT), but these are compile-time flags rather than runtime security-sensitive features. The specification about gating security features behind explicit configuration options has very low relevance to this VM execution engine.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2019-11470_after_subset_100:7ab655a2:spec": {
    "timestamp": "2026-01-17T03:08:56.081548",
    "cve_id": "CVE-2019-11470",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7ab655a2",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a VM interpreter for mruby, handling opcode execution and stack management. While it manipulates linked structures (call stack, environment chains), there is no explicit deallocation of linked structures shown in this code snippet. Memory management appears to be handled by garbage collection (mrb_gc_arena_save/restore). The relevance is weak because the specification focuses on deallocation consistency, but this code primarily deals with execution flow rather than explicit memory deallocation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 3,
        "reasoning": "The code does not show explicit resource cleanup operations like file handles, network connections, or similar resources. It manages VM execution state, stack frames, and exception handling. The \"complete isolation state\" concept from the specification doesn't directly apply to this VM interpreter context. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 4,
        "reasoning": "Similar to spec 1, the code works with memory through garbage collection mechanisms (mrb_gc_arena_save/restore, mrb_write_barrier). However, it doesn't show explicit memory release operations - memory management is abstracted through the GC. The ownership semantics are managed by the garbage collector rather than explicit manual memory management. Weak relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code is a VM bytecode interpreter, not a file content processor. It executes opcodes from compiled Ruby code, not file I/O operations. The specification about handling empty files and file edge cases is completely unrelated to this VM execution engine. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2018-13441_before_subset_100:91f4894b:spec": {
    "timestamp": "2026-01-17T03:09:12.692060",
    "cve_id": "CVE-2018-13441",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "91f4894b",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation or release operations. It works with function parameters and a global/static linked list of query handlers. There are no malloc/free or similar operations where ownership semantics would be relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2018-13441_after_subset_100:b40096f9:spec": {
    "timestamp": "2026-01-17T03:09:22.495687",
    "cve_id": "CVE-2018-13441",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b40096f9",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation or deallocation operations. It works with provided buffers and function calls. There is no visible memory ownership transfer or release logic to evaluate against HS-MEM-003.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The function processes a string buffer, not file content. The specification about handling empty files and file edge cases is not directly applicable to this network/command handler scenario.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple return paths but does not appear to acquire or manage resources like file descriptors, memory, or locks that require cleanup. The socket descriptor 'sd' is passed in and used, but not opened or closed within this function. Relevance is weak.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain an XML parser. It is a simple command handler for a \"help\" system. This specification is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, this specification concerns document processing and entity resolution, which is unrelated to the provided command-line help function.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The function provides help text and lists handlers, which is not a security-sensitive feature. The handlers it calls (via `qh->handler`) could be sensitive, but the code itself does not gate their execution behind configuration; it unconditionally provides help or lists them. Relevance is weak.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The function receives a buffer 'buf' and a length 'len', but it does not use 'len' for bounds checking. It passes 'buf' directly to `strcmp` and `qh_find_handler`, which is risky if 'buf' is not null-terminated. While it doesn't perform buffer *operations* like copying, the principle of validating input length against its usable size is moderately relevant. The call `qh->handler(sd, \"help\", 4)` correctly uses a literal length.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform pathname expansion (globbing). It treats the input 'buf' as a command string (\"help\", \"list\", or a handler name). The principle of validating input syntax is loosely related, but the specific context of pathnames is not present.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      }
    ]
  },
  "CVE-2021-37661_before_subset_100:dd98f04c:spec": {
    "timestamp": "2026-01-17T03:10:04.275278",
    "cve_id": "CVE-2021-37661",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dd98f04c",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code creates a new `QuantileStreamResource` object with `new` and passes ownership to `CreateResource`. Specification HS-MEM-003 about maintaining strict ownership semantics is moderately relevant. The code must ensure the resource is properly managed (created, tracked, and eventually released) by the resource manager (`CreateResource`). A failure in ownership handling could lead to memory leaks or double frees.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-004 is about handling edge cases for file content processing. The target code processes tensor inputs from a computational graph, not file contents. There is no file I/O involved, making this specification essentially irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 is strongly relevant. The code is responsible for creating a resource (`QuantileStreamResource`). The `CreateResource` function's status is checked, and the code must handle both success and the `ALREADY_EXISTS` condition correctly. Failure to maintain consistent state (e.g., leaking the `new` resource on certain error paths) could lead to resource leaks or inconsistent program state.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-001 is moderately relevant. The code validates the `epsilon` input attribute (checking it's > 0). It also retrieves `num_streams` but does not show validation for it (e.g., being positive). The principle of validating all input attribute values before use applies, but the validation shown is incomplete.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-SEC-002 is about sanitizing printer configuration files. The target code performs numerical computation and resource management within a machine learning framework, with no relation to printers, configuration files, or sanitization of such data.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-003 is about enforcing strict message parsing for the IPP (Internet Printing Protocol). The target code is part of a TensorFlow op kernel, handling internal tensor data structures, not network protocol messages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-001 is about validating path components during archive extraction. The code does not perform any filesystem operations, archive handling, or path manipulation.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-SEC-002 (second instance) is about enforcing path isolation for sandboxed extraction. Similar to spec_7, this is unrelated to the code's purpose of creating a computational resource.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      }
    ]
  },
  "CVE-2021-37661_after_subset_100:4fde71e8:spec": {
    "timestamp": "2026-01-17T03:10:29.252389",
    "cve_id": "CVE-2021-37661",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4fde71e8",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code creates a new `QuantileStreamResource` object with `new` and passes ownership to `CreateResource`. Specification HS-MEM-003 about maintaining strict ownership semantics is moderately relevant. The code shows proper ownership transfer (the resource manager takes ownership), but we cannot fully verify if all error paths correctly handle the allocated memory without seeing the implementation of `CreateResource` and `OP_REQUIRES`.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-004 about processing file content edge cases has very low relevance. The target code processes tensor inputs from a computational graph, not file contents.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 about consistent resource cleanup across execution paths is strongly relevant. The code creates a resource and registers it. The `CreateResource` function's behavior on failure (especially when status is not OK and not ALREADY_EXISTS) is critical. The `OP_REQUIRES` call ensures failure propagation, but the exact cleanup of the newly allocated `result` object in the `ALREADY_EXISTS` case or other error paths depends on `CreateResource`'s implementation.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-001 about validating IPP attribute values has moderate relevance. While the code is not about IPP (Internet Printing Protocol), the core principle of validating all input attribute values before processing is demonstrated. The code validates `epsilon` (must be > 0) and `num_streams` (must be >= 0). However, it does not validate the upper bounds of these inputs.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-SEC-002 about sanitizing printer configuration files has very low relevance. The target code deals with tensor computation resources, not printer configurations or file processing.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-003 about enforcing strict IPP protocol message parsing has very low relevance. The code is part of a TensorFlow op kernel processing structured tensor inputs, not a network protocol implementation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-001 about validating archive extraction paths has very low relevance. The code performs no filesystem operations or archive extraction.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-SEC-002 about enforcing path isolation in sandboxed extraction has very low relevance. The code is unrelated to sandboxing, file extraction, or path manipulation.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      }
    ]
  },
  "CVE-2017-12994_before_subset_100:bae17b54:spec": {
    "timestamp": "2026-01-17T03:10:52.311207",
    "cve_id": "CVE-2017-12994",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bae17b54",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code allocates memory via `pj_pool_alloc` but does not explicitly release it within this function. Memory management is likely handled by the pool's lifecycle elsewhere, making the direct relevance to this specific code snippet weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The specification concerns file content processing and edge cases like empty files. The target code is parsing a DNS packet from a network buffer, not a file. The connection is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The specification is about resource cleanup and consistent state across execution paths. The function has multiple early returns on error, but it primarily allocates memory and parses data. If an error occurs after allocation but before successful completion, the allocated memory for `q->name.ptr` remains in the pool. While not a classic leak (pool cleanup is external), the function does not clean up its partial state on error, showing a weak connection to the spec.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification states protocol parsers must validate all TLV structures before processing. This function parses a DNS query, which has a Type-Length-Value-like structure (name, type, class). It performs some validation via `get_name_len` and `get_name`, but the direct copying of `type` and `dnsclass` assumes the packet has sufficient data. The principle of validating structure fields before use is highly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all TLV structures before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification requires network protocol implementations to enforce strict message boundary validation. This is a DNS packet parser. The code uses `max` as the boundary and passes it to helper functions (`get_name_len`, `get_name`) for validation. However, the direct `pj_memcpy` operations for `type` and `dnsclass` do not explicitly check if `p+2` exceeds `max`. This is a core concern for the function, making the specification strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The specification mandates strict bounds checking for all memory accesses during packet dissection. This is the central security issue in the code. The function accesses the packet buffer `pkt` via `start` and `p`. While it uses bounded functions for name parsing, the two `pj_memcpy` calls for `type` and `dnsclass` do not verify that 2 bytes are available before copying. This is a direct violation of the specification's principle, making it highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking for all memory accesses"
      },
      {
        "score": 7,
        "reasoning": "The specification states buffer copy operations must validate size parameters against signedness constraints. The code uses `pj_memcpy` with a hardcoded size of 2. The size parameter is not a variable, so signedness issues are not apparent here. However, the underlying principle of validating copy sizes is related to the missing bounds check for those 2-byte copies, giving it moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification requires input processing to enforce non-negative length constraints for memory operations. The function receives `name_len` from `get_name_len`. It uses `name_len+4` for allocation, which could overflow if `name_len` is negative or very large. While `get_name_len` might prevent negative values, the code does not explicitly validate that `name_len` is non-negative and safe for arithmetic before allocation. This is a strong relevance.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      }
    ]
  },
  "CVE-2017-12994_after_subset_100:1ad7c937:spec": {
    "timestamp": "2026-01-17T03:10:57.090929",
    "cve_id": "CVE-2017-12994",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1ad7c937",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code allocates memory (`pj_pool_alloc`) but does not release it within this function. The relevance is weak because the code focuses on parsing and allocation, not on cleanup or ownership transfer.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about file content processing and edge cases for empty files. The target code processes network packet data (DNS query), not file content. The connection is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification is about resource cleanup and consistent state across execution paths. The function has multiple error return paths, but it primarily returns error status codes. It does not explicitly clean up resources (like the allocated `q->name.ptr`) on failure before returning, which could lead to memory leaks if the caller doesn't handle it. However, the pool-based allocation might be managed elsewhere. Relevance is weak.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating TLV structures before processing. The code parses a DNS query, which is a structured message with Type-Length-Value-like components (name, type, class). It performs bounds checking (`if (p + 4 > max)`) before reading the type and class fields. The `get_name_len` and `get_name` functions also perform validation. This is highly relevant to the core activity of the function.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all TLV structures before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing strict message boundary validation for network protocols. The function is a DNS protocol parser. It explicitly checks boundaries (`p + 4 > max`) to ensure it doesn't read beyond the provided buffer (`max`). The `get_name_len` and `get_name` functions also receive `max` for boundary checks. This is strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The specification is about maintaining strict bounds checking for all memory accesses during packet dissection. This is the primary security concern in the code. The function validates buffer bounds before performing `pj_memcpy` operations and relies on helper functions (`get_name_len`, `get_name`) to do the same for the name field. This directly prevents buffer overflows. Highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking for all memory accesses"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating size parameters against signedness constraints in buffer copies. The code uses `int` for lengths (`name_len`, `name_part_len`, `parsed_len`). It allocates `name_len+4` bytes. If `name_len` were negative (e.g., due to an error in `get_name_len`), this could cause a problematic allocation size. The code trusts the return value of `get_name_len`. There is moderate relevance, as the validation of `name_len` likely occurs in the helper function, but the direct copy operations (`pj_memcpy`) use fixed sizes (2) and checked pointers.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing non-negative length constraints for memory operations. The function uses the `name_len` variable for memory allocation. A negative `name_len` would be catastrophic. The security of this operation depends entirely on the `get_name_len` function returning a valid, non-negative length. The principle of validating input lengths is strongly relevant to this parser's safety.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      }
    ]
  },
  "CVE-2016-5844_before_subset_100:adf445c0:spec": {
    "timestamp": "2026-01-17T03:11:15.715538",
    "cve_id": "CVE-2016-5844",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "adf445c0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory using gf_malloc for location_entry and extent_entry but does not show corresponding cleanup or error handling paths that release this memory if the function fails later (e.g., due to another allocation failure). This relates to ownership semantics and proper cleanup, though the full context of the caller's cleanup is not visible.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2016-7101_after_subset_100:3e680e14:spec": {
    "timestamp": "2026-01-17T03:11:51.243029",
    "cve_id": "CVE-2016-7101",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3e680e14",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code uses GF_SAFEALLOC for memory allocation and adds allocated items to lists. However, there is no explicit memory release operation shown in this function. The specification about maintaining strict ownership semantics during release is moderately relevant because the function must ensure that if an error (like GF_OUT_OF_MEM) occurs mid-execution, previously allocated resources (like gf_list_new() and GF_SAFEALLOC'd items) are properly cleaned up to avoid leaks. The current code returns early on allocation failure without cleaning up earlier allocations, which violates the ownership principle.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification about handling edge cases for file content processing has very low relevance. The function reads a structured box from a bitstream, but it does not explicitly handle edge cases like empty or malformed data that could result in item_count or extent_count being zero. While ISOM_DECREASE_SIZE may provide some size checking, the spec's focus on \"empty files\" is not directly addressed in this code snippet.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The function allocates multiple resources (GF_ItemLocationEntry, gf_list_new, GF_ItemExtentEntry) in nested loops. If a memory allocation fails (GF_OUT_OF_MEM) after some resources have already been allocated and added to lists, the function returns immediately without cleaning up those resources, leaving the program in an inconsistent state. This is a direct violation of maintaining consistent state across all execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 7,
        "reasoning": "Moderately to strongly relevant. The function reads values (item_count, extent_count) that are used as loop counters and for memory allocation. It must ensure these lengths are non-negative and reasonable. While the values are read as unsigned integers (u16, u32), which are inherently non-negative, the specification's principle of enforcing valid length constraints applies. The code lacks explicit validation that these counts are within sane bounds relative to the available data size.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs arithmetic operations for memory sizing and size decrements: `8*ptr->base_offset_size`, `ptr->offset_size+ptr->length_size`, `8*ptr->offset_size`, `8*ptr->length_size`. These multiplications and additions could overflow, especially since the size fields (offset_size, length_size, base_offset_size, index_size) are read from the input stream and could be large (up to 15, as they are 4-bit fields). The ISOM_DECREASE_SIZE macro likely also involves arithmetic. Without overflow protection, these calculations could wrap, leading to incorrect size checks and memory access issues.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2017-8068_before_subset_100:82fc10f1:spec": {
    "timestamp": "2026-01-17T03:12:12.918938",
    "cve_id": "CVE-2017-8068",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "82fc10f1",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not contain any explicit memory allocation or deallocation operations (like malloc/free). It uses local arrays and processes input data, but there is no memory ownership transfer or release logic to evaluate against HS-MEM-003's principle of maintaining strict ownership semantics during release.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The function processes data from parameters, not directly from file content. While it handles variable-length input data, the specification HS-INPUT-004 is specifically about processing the content of files, including edge cases like empty files, which is not the primary scenario here.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function uses local resources (like file pointer `fp`) but does not acquire complex resources like network connections or dynamic memory that require cleanup. The `endoutput(fp)` call suggests some finalization, but the code's execution paths are relatively linear and don't show significant state inconsistency risks. Relevance is weak.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The function acts as a parser for a sequence of name-value pairs (`nextvar`). It validates the decoded data (e.g., using `decodets`, `decodenetnum`, `decodeuint`) before processing and has fallback error handling (`output_raw = '?'`). This aligns with the core principle of HS-INPUT-001: validating structures before processing, though the data format is not explicitly a TLV (Type-Length-Value) structure.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all TLV structures before processing"
      },
      {
        "score": 5,
        "reasoning": "The code is a data formatting/output function, not a network protocol message receiver. It does not handle raw network packets, message boundaries, or protocol state. The `sockaddr_u` type suggests network origin for some data, but the function itself does not implement protocol validation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The function performs \"packet dissection\" of a sort, parsing variables from input data. It uses fixed-size buffers (`bn[2 * MAXVARLEN]`, `bv[2 * MAXVALLEN]`) and employs `atoascii` with explicit length bounds (`sizeof(bn)`, `sizeof(bv)`). The `snprintf` for buffer `b` also uses `sizeof(b)`. This demonstrates conscious bounds checking for memory accesses during dissection, making the specification highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking for all memory accesses"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-INPUT-001 is about validating IPP (Internet Printing Protocol) attribute values. The target code appears to be part of an NTP (Network Time Protocol) related utility (based on functions like `prettydate`, `refnumtoa`, `statustoa`). There is no indication it processes IPP attributes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification HS-SEC-002 is explicitly about sanitizing printer configuration files. The target code does not read or process configuration files; it formats and prints data from function parameters. This specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2017-8068_after_subset_100:acaf2404:spec": {
    "timestamp": "2026-01-17T03:12:39.909147",
    "cve_id": "CVE-2017-8068",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "acaf2404",
    "scores": [
      {
        "score": 3,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code does not perform any dynamic memory allocation or deallocation (no malloc/free). It uses stack-allocated buffers and string manipulation, so this specification is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about processing file content and handling edge cases like empty files. The target code is a function that prints formatted data (likely from network packets or similar structured input) to a file pointer. It does not read or process the contents of a file itself.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification is about resource cleanup and consistent state across execution paths. The function uses local variables and a file pointer but does not acquire external resources (like memory, file descriptors, locks) that require explicit cleanup. The `endoutput(fp)` call might perform some finalization, but the code's primary flow is not focused on complex resource management.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating TLV (Type-Length-Value) structures before processing. The function `cookedprint` processes variable-length data (`name`/`value` pairs) extracted by `nextvar`. While not a classic TLV, it follows a similar pattern of parsing structured input. The code performs validation via format-specific decoders (e.g., `decodets`, `decodenetnum`, `decodeuint`), which aligns with the principle of validating input structures before use. However, the validation is not a generic TLV validation but is specific to the expected data types.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all TLV structures before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing strict message boundary validation in network protocols. The function appears to be part of a network service (NTP) that processes received data. It relies on the `length` parameter and the `nextvar` iterator to control parsing, which implies some boundary management. However, the core validation of the overall message boundary likely happens before this function is called. The function's focus is on decoding fields within an already extracted data segment.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The specification is about maintaining strict bounds checking for all memory accesses during packet dissection. This is highly relevant. The code processes external input (`data`, `value`) and writes to fixed-size stack buffers (`b`, `bn`, `bv`). It uses `atoascii` with explicit size limits (`MAXVARLEN`, `sizeof(bn)`) to prevent overflows, and a comment even references a past buffer overrun vulnerability (TALOS-CAN-0063). The `snprintf` call also uses `sizeof(b)`. This demonstrates active bounds checking, which is the core of this specification.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking for all memory accesses"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code is part of the NTP (Network Time Protocol) daemon (`ntpd`), as evidenced by functions like `statustoa`, `prettydate`, `stoa`, and `refnumtoa`. It has no relation to IPP or printer protocols.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. As with spec_7, this code is from NTP, not a printing service. The function processes network data or internal state, not printer configuration files.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2021-41206_before_subset_100:57a82bbc:spec": {
    "timestamp": "2026-01-17T03:12:54.067108",
    "cve_id": "CVE-2021-41206",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "57a82bbc",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses std::unique_ptr for the CudaSolver, which enforces strict ownership semantics. However, it also manually manages other resources (like scratch space and tensors) through the solver object, and the final cleanup is handled via an async callback. While ownership is generally clear, the async nature and multiple resource types introduce moderate complexity.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 6,
        "reasoning": "The code explicitly handles empty input cases (if input.NumElements() == 0 || rhs.NumElements() == 0) by returning early, which is analogous to handling empty files. This shows consideration for edge cases, though the specification is about file processing while this code processes tensor data.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "Resource cleanup is managed through the CudaSolver destructor (via std::unique_ptr) and an async callback (info_checker) that ensures cleanup after kernel execution. The callback captures necessary objects to prevent premature deallocation, maintaining consistent state across async execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about IPP (Internet Printing Protocol) attribute validation, which is completely unrelated to this CUDA-based linear algebra kernel code that processes tensor inputs.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns printer configuration file sanitization, which has no relevance to this numerical computation code that operates on GPU tensors.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about IPP protocol message parsing, while this code performs mathematical computations (LU factorization and solving) on tensor data using CUDA libraries.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 8,
        "reasoning": "The code performs extensive dimension validation before processing: checking tensor ranks, matching dimensions between input matrices, verifying square matrices, and row count consistency. This is analogous to validating claimed dimensions against actual data, though for tensors rather than image files.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "The code validates tensor dimensions extensively before any memory allocation or computation (using OP_REQUIRES_ASYNC checks). It ensures shape compatibility and prevents invalid operations, which aligns with the principle of safe dimension checking before resource allocation.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2021-41206_after_subset_100:16a5d4e1:spec": {
    "timestamp": "2026-01-17T03:13:11.878548",
    "cve_id": "CVE-2021-41206",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "16a5d4e1",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `std::unique_ptr` for the CudaSolver, which enforces strict ownership semantics. Memory for tensors (input_copy, pivots, transposed_rhs) is allocated via the solver's scoped tensor methods, which likely manage lifetime correctly. However, the specification focuses on memory release operations, and while ownership patterns are present, the exact release mechanisms are not fully detailed in the snippet.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code handles empty input cases (if input.NumElements() == 0 || rhs.NumElements() == 0) by early return, which is an edge case handling. However, the specification is specifically about file content processing, while this code processes tensor data in memory, not files. The principle of handling empty data is relevant but the context differs.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The code ensures resource cleanup across execution paths using RAII (std::unique_ptr for solver) and scoped tensor allocations. The async callback (`info_checker`) captures necessary objects to prevent premature deallocation. All error paths use OP_REQUIRES_ASYNC or similar to ensure cleanup via the `done` callback, maintaining consistent state.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values before processing. The target code is a GPU linear algebra kernel for tensor operations, with no relation to IPP or printing protocols. No relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns sanitizing printer configuration files. The target code performs matrix computations (LU factorization, solving) on GPU, with no file processing or printer-related functionality. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code extensively validates tensor dimensions before processing: it checks ranks, equality of dimensions, square matrices, matching rows, and outer dimensions. This directly aligns with the principle of validating claimed dimensions against actual data shape to prevent out-of-bounds access or logical errors, though it's for tensors rather than image files.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The code performs multiple dimension checks (OP_REQUIRES_ASYNC) before allocating memory for output and intermediate tensors (e.g., input_copy, pivots, transposed_rhs). This ensures safe memory allocation based on validated dimensions, matching the specification's principle of safe dimension checking before allocation, though applied to tensor operations rather than file formats.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2020-36406_before_subset_100:6e572c25:spec": {
    "timestamp": "2026-01-17T03:13:36.367083",
    "cve_id": "CVE-2020-36406",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6e572c25",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a topic publishing function for a pub/sub system, likely for MQTT-style wildcard matching. It does not involve XML parsing or external entity processing in any way.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve document processing (e.g., XML, JSON) or entity resolution. It operates on string views and a topic tree structure.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code processes topic strings, not file content. Edge cases for empty files are not relevant.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all TLV structures before processing"
      },
      {
        "score": 2,
        "reasoning": "The code is part of a message publishing logic within an application, not a network protocol implementation. It does not deal with network sockets, message framing, or boundary validation from a byte stream.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce strict message boundary validation"
      }
    ]
  },
  "CVE-2020-36406_after_subset_100:fe0115df:spec": {
    "timestamp": "2026-01-17T03:14:04.932974",
    "cve_id": "CVE-2020-36406",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fe0115df",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a topic publishing function for a message broker (likely MQTT-like) and does not involve XML parsing or external entity processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve document processing or entity resolution of any kind.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code includes logic to disallow wildcards ('+' and '#') during publishing, which is a security-sensitive feature to prevent \"explosive recursion.\" This acts as a safety gate, though it's not a user-configurable option but a hardcoded security control.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code manages a collection (`triggeredTopics`) and a state flag (`triggered`), which involves ownership semantics for the Topic objects. However, there are no explicit memory release operations (like `delete` or `free`) in this snippet.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes topic strings and message views, not file content.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function manages state (`triggered` flag, `numTriggeredTopics`, `triggeredTopics` array) and ensures cleanup via a `drain()` call when a limit (64) is reached. It must maintain consistent state across recursive calls and early returns, which aligns with the principle of consistent state management across execution paths.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code parses a topic string segmented by '/', which is a simple delimiter, not a TLV (Type-Length-Value) structure. It does perform some validation (wildcard checking) but not on TLV formats.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all TLV structures before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is part of a higher-level application protocol (like MQTT) topic matching engine, not a network protocol implementation dealing with raw message boundaries. Its validation is on topic content, not network message framing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce strict message boundary validation"
      }
    ]
  },
  "CVE-2022-0492_after_subset_100:e3990621:spec": {
    "timestamp": "2026-01-17T03:14:36.008812",
    "cve_id": "CVE-2022-0492",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e3990621",
    "scores": [
      {
        "score": 4,
        "reasoning": "Specification HS-MEM-003 about memory release operations and ownership semantics is weakly relevant. The code writes to a buffer (release_agent_path) but does not involve explicit memory deallocation or ownership transfer. The primary concern is copying user data into a kernel buffer, not managing ownership of freed memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-004 about file content processing has moderate relevance. The code processes input from a user-space buffer (buf) via a kernfs file operation. It uses strstrip() but does not explicitly handle all edge cases like extremely long strings (though BUILD_BUG_ON and strlcpy provide some protection). Input validation and boundary checks are relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 about resource cleanup maintaining consistent state has weak relevance. The code does not perform resource cleanup; it updates a configuration string. However, it uses locking (cgroup_kn_lock_live, spin_lock) to maintain consistency during the update, which relates to state consistency.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 about linked structure deallocation has very low relevance. The code does not deallocate any linked structures. It writes to a static buffer within a cgroup root structure. No linked list or node manipulation occurs.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-004 about resource cleanup establishing isolation state is weakly relevant. The code does not perform cleanup or isolation operations. It modifies a shared path string, but isolation is not a primary concern here.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-TIMING-001 about shared resource access synchronization is highly relevant. The code accesses shared resources: cgrp->root->release_agent_path is protected by release_agent_path_lock (spin_lock), and cgroup_kn_lock_live is used to lock the cgroup. This directly addresses synchronization for shared state.",
        "spec_index": 5,
        "spec_preview": "HS-TIMING-001: Shared resource access must use proper synchronization when retrieving state"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 about validating object references against concurrent modification is strongly relevant. The code uses cgroup_kn_lock_live(of->kn, false) to obtain a live reference to the cgroup and lock it, ensuring the cgroup is not being concurrently destroyed. This validates the object reference in the presence of potential concurrent modification.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Object references must be validated against concurrent modification"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-003 about device control operations maintaining consistent state has moderate relevance. While not a device control operation per se, it is a control operation on a cgroup via a kernfs file. The use of locking to protect the release_agent_path during concurrent writes aligns with the principle of maintaining consistent state across concurrent accesses.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Device control operations must maintain consistent state across concurrent accesses"
      }
    ]
  },
  "CVE-2022-0492_before_subset_100:ed4d2a90:spec": {
    "timestamp": "2026-01-17T03:14:40.682602",
    "cve_id": "CVE-2022-0492",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ed4d2a90",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification \"Memory release operations must maintain strict ownership semantics\" is weakly relevant. The code does not perform explicit memory release/deallocation. It copies a string into a statically sized buffer (release_agent_path). The primary concern is buffer overflow prevention via strlcpy, not ownership during release.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification \"File content processing must handle all edge cases including empty files\" has moderate relevance. The function processes input (`buf`) from a kernfs file. It uses `strstrip(buf)` which handles leading/trailing whitespace, but edge cases like extremely long strings (beyond PATH_MAX) are prevented by `strlcpy` and the `BUILD_BUG_ON` size check. However, handling of empty content or null strings is not explicitly shown.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Resource cleanup must maintain consistent state across all execution paths\" has weak to moderate relevance. The function locks a cgroup via `cgroup_kn_lock_live` and must unlock it on all paths. It returns `-ENODEV` on lock failure (no unlock needed) and unlocks before the successful return. This maintains consistent lock state, which is a form of resource cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Linked structure deallocation must maintain consistent neighbor relationships\" has very low relevance. The code does not deallocate any linked structures. It writes a string path into a buffer within a cgroup root structure. No linked list or tree manipulation is performed.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Resource cleanup operations must establish complete isolation state\" has very low relevance. The function is not performing resource cleanup or isolation. It is an update/write operation for a configuration string (release agent path).",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Shared resource access must use proper synchronization when retrieving state\" is highly relevant. The code accesses the shared `cgrp->root->release_agent_path` buffer. It uses a dedicated spinlock (`release_agent_path_lock`) to synchronize access to this shared resource during the copy operation (`strlcpy`), preventing concurrent modification issues.",
        "spec_index": 5,
        "spec_preview": "HS-TIMING-001: Shared resource access must use proper synchronization when retrieving state"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Object references must be validated against concurrent modification\" has strong relevance. The function obtains a reference to a cgroup (`cgrp`) via `cgroup_kn_lock_live(of->kn, false)`, which locks the cgroup and returns a live object if it exists. This validates the cgroup's existence and state, protecting against use-after-free or concurrent destruction while the reference is held. The lock is held for the duration of the operation on the cgroup's root.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Object references must be validated against concurrent modification"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Device control operations must maintain consistent state across concurrent accesses\" has moderate to strong relevance. While not a typical device control, the kernfs file operates on a cgroup subsystem, which is a kernel control interface. The code uses locking (cgroup lock and a path spinlock) to ensure the `release_agent_path` is updated atomically and consistently, even with concurrent writes or reads from other threads.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Device control operations must maintain consistent state across concurrent accesses"
      }
    ]
  },
  "CVE-2016-8670_before_subset_100:b472db2f:spec": {
    "timestamp": "2026-01-17T03:15:04.770736",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b472db2f",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs a memcpy operation using the 'rlen' parameter, which is derived from the 'len' input. The function validates that 'len' is not greater than the available data ('remain'), but it does not explicitly check if 'len' is negative. Since 'len' is a signed int, a negative value could bypass the validation (remain >= len could be true if len is negative) and lead to a large, unintended copy operation. This directly relates to validating size parameters against signedness constraints.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function's primary purpose is to process an input length ('len') for a memory copy operation. It must enforce that the effective copy length ('rlen') is non-negative. The current check (remain >= len) is insufficient if 'len' is negative, as explained in Spec 1. This specification directly addresses the need for non-negative length constraints for safe memory operations.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code calculates 'remain = dp->logicalSize - dp->pos'. This subtraction could theoretically underflow if 'dp->pos' is greater than 'dp->logicalSize', leading to a large positive 'remain' value and subsequent buffer overflow. The code does not validate this relationship. However, this is a state integrity issue rather than a sizing operation for a new allocation.",
        "spec_index": 2,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function 'dynamicGetbuf' does not perform any memory release or deallocation operations. It only reads data from an internal buffer. The specification concerning memory release ownership semantics does not apply to this code snippet.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function handles the edge case where 'remain' (available data) is zero by returning EOF. This is analogous to handling an empty file or a read past the end of available data. The specification's principle of handling edge cases applies, though the code is for a general I/O context, not strictly file content.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function is a simple reader that updates the 'pos' member. There are no complex resources to clean up, and there is a single return path. The specification about maintaining consistent state during resource cleanup across multiple execution paths is not a primary concern here.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The code is a generic buffer read function within an I/O context (potentially used by an image parser). It does not parse image dimensions or validate them against a file size. The connection is indirect, as safe use of this function by an image parser would require such validation elsewhere.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Low relevance. Similar to Spec 7, this function is a low-level data reader, not a file format reader that performs dimension checking or memory allocation. Its safety depends on the higher-level caller ensuring the buffer ('dp->data') is sufficiently large, which relates to safe allocation practices.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2016-7425_after_subset_100:d8811b26:spec": {
    "timestamp": "2026-01-17T03:15:25.192995",
    "cve_id": "CVE-2016-7425",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d8811b26",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code performs a memcpy operation using the calculated rlen. While it checks that remain (dp->logicalSize - dp->pos) is positive before copying, it does not explicitly validate that the len parameter itself is non-negative. If a negative len is passed, the condition (remain >= len) could be true (if remain is large), leading to a negative rlen being used in memcpy, causing a large buffer overflow. This directly relates to validating size parameters against signedness constraints.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 9,
        "reasoning": "The specification is highly relevant. The function's len parameter represents an input length for a memory operation (memcpy). The code must enforce that this length is non-negative. The current check (if (remain >= len)) does not protect against a negative len value, which is a critical flaw for memory safety.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      },
      {
        "score": 1,
        "reasoning": "The code snippet does not contain any memory release operations (e.g., free, realloc). It only reads from a buffer. Therefore, this specification about ownership semantics during deallocation is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The function reads from an internal dynamic buffer, not directly from a file. While the buffer's data might originate from a file, this specific function is one layer abstracted. It does handle the \"empty\" or \"end-of-data\" case (remain <= 0 returns EOF), so there is a very weak connection.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 1,
        "reasoning": "The function has a simple execution flow with a single return point. It does not acquire or release resources (like file handles or allocated memory) within its scope that would require complex cleanup across multiple paths. The specification is not relevant.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The function is part of an I/O context, likely used in image parsing. It reads from a buffer (`dp->data`) whose size (`dp->logicalSize`) should have been validated when the buffer was filled. The function itself trusts these internal fields. There is a moderate relevance because if the caller (an image parser) provided corrupted `dp` fields, this function could read out of bounds, but the validation responsibility lies earlier in the call chain.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Similar to HS-INPUT-001, this specification is about high-level file format readers. This function is a low-level buffer reader. Its safety depends on the correctness of `dp->logicalSize` and `dp->pos`, which should have been validated by the higher-level reader before this function is called. The connection is indirect and of moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2013-0310_before_subset_100:cc8f3659:spec": {
    "timestamp": "2026-01-17T03:15:56.468099",
    "cve_id": "CVE-2013-0310",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cc8f3659",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory release operations. It increments a chain's reference count (`chain->use++`), which relates to resource management, but the specification about \"strict ownership semantics\" during memory release is only weakly connected. The primary focus is on parsing and validation, not on ownership transfer or release.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about processing file content, including empty files. The target code processes network packet attributes (Netlink attributes) for NFTables verdicts, which is unrelated to file I/O or file content handling.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 6,
        "reasoning": "The code has multiple error return paths. It must ensure that no inconsistent state (like an incremented `chain->use` without proper cleanup) is left on failure. The current code increments `chain->use` only after successful validation, which is good. However, the specification about maintaining consistent state across *all* execution paths is moderately relevant, as a more complex function might require rollback logic.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The function is a packet (Netlink attribute) parsing routine. It must handle parsing failures (e.g., via `nla_parse_nested_deprecated`, missing required attributes, invalid codes, or chain lookup errors) and ensure the `data` and `desc` output structures are left in a safe, predictable state (e.g., not partially initialized) before returning an error.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "The code acts as a dissector for a specific Netlink packet structure (NFT verdict). It validates the presence of required attributes (`NFTA_VERDICT_CODE`) and the validity of nested structures before proceeding with further processing (like chain lookup). This aligns with the core principle of the specification, though the \"protocol\" here is Netlink/NFTables, not a typical network protocol header.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      },
      {
        "score": 5,
        "reasoning": "This is strongly relevant. The function processes network input (Netlink attributes). It demonstrates guaranteed initialization before use by validating the presence of `tb[NFTA_VERDICT_CODE]` before dereferencing it with `nla_get_be32`. It also validates the existence of chain-related attributes before using them in lookup functions, preventing the use of uninitialized or unexpected input fields.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Network input processing must guarantee field initialization before use"
      },
      {
        "score": 3,
        "reasoning": "The specification is about IPP (Internet Printing Protocol) attribute validation. The target code validates Netlink attributes for the NFTables subsystem in the Linux kernel. While the general concept of \"validate attributes before processing\" is similar, the specific protocol context (IPP vs. Netlink/NFTables) makes the direct relevance very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code deals with kernel-level Netlink message parsing for network packet filtering rules. There is no relation to printer configuration files or the need for sanitization in that context.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2013-0310_after_subset_100:766ccdf2:spec": {
    "timestamp": "2026-01-17T03:16:20.088987",
    "cve_id": "CVE-2013-0310",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "766ccdf2",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation or release operations. It performs lookups (`nft_chain_lookup`, `nft_chain_lookup_byid`) which may return pointers, but there is no direct memory management (like `kmalloc`/`kfree`). The principle of ownership is indirectly relevant when considering reference counting (`chain->use++`), but this is not the core focus of the specification.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about processing file content. The target code processes network packet attributes (Netlink attributes) related to nftables verdicts, not files. The context is completely different.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 6,
        "reasoning": "The code has multiple error return paths. It must ensure that no partial or inconsistent state is left if an error occurs. For example, if the function fails after `chain->use++`, it could leave an incorrect reference count. However, the function returns on errors before incrementing `use`, and there's no other resource acquisition (like locks) shown, so the risk is moderate.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The function parses nested Netlink attributes (a form of packet/data structure). It validates the presence of required attributes (`NFTA_VERDICT_CODE`) and the validity of the verdict code early. If parsing fails (`nla_parse_nested_deprecated` returns error), it returns immediately, ensuring no further processing with invalid state. This aligns well with the specification's principle.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "The code acts as a dissector for nftables verdict Netlink attributes. It validates the presence of the core attribute (`NFTA_VERDICT_CODE`) before processing its value. For `NFT_JUMP`/`NFT_GOTO`, it also validates the presence of a chain identifier attribute before performing the chain lookup. This matches the protocol validation principle, though the \"header\" here is an attribute structure.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code processes network input (Netlink attributes). It strictly validates and initializes data before use: 1) It parses the nested attribute array `tb`. 2) It checks `tb[NFTA_VERDICT_CODE]` exists before dereferencing it with `nla_get_be32`. 3) For jump/goto verdicts, it checks for the existence of chain attributes before using them in lookup functions. This prevents use of uninitialized or attacker-controlled pointers.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Network input processing must guarantee field initialization before use"
      },
      {
        "score": 5,
        "reasoning": "The specification is about IPP (Internet Printing Protocol) attribute validation. The target code deals with nftables (Netfilter) Netlink attributes, which is a completely different protocol and subsystem (networking packet filtering vs. printing). The general concept of validating attributes is similar, but the specific context and threat models are unrelated.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code has no relation to printers, configuration files, or file sanitization. It processes in-memory network data structures for firewall rules.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2018-19843_before_subset_100:3592b78f:spec": {
    "timestamp": "2026-01-17T03:16:29.465731",
    "cve_id": "CVE-2018-19843",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3592b78f",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs memory allocation (malloc for buf) and has multiple early return paths. While it frees 'buf' at the end, the ownership semantics are generally clear (allocated and freed in the same function). However, there are early returns before allocation and after allocation that could lead to leaks if not careful. The function does free 'buf' before returning in the main path, but the early returns after malloc (e.g., on iend > MAX_SCAN_SIZE) do free it, but the early returns before malloc do not apply. The main issue is that if malloc succeeds but later errors occur (e.g., ESIL initialization fails), the function returns without freeing buf, which is a memory leak. This violates strict ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code reads file-like content via r_io_read_at from an IO source, but it's not primarily processing file contents in the sense of parsing structured data. It handles buffer reads for analysis, and edge cases like empty ranges (iend < 0) are checked. However, the specification about \"file content processing\" and \"empty files\" is more about parsers of file formats, not low-level binary analysis reading raw bytes. The connection is weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The function manages several resources: dynamically allocated buffer (buf), ESIL callback hooks, and register arena state. Cleanup is performed at the end (free buf, reset hooks, pop arena). However, there are multiple early return paths that may skip some cleanup (e.g., if malloc fails, it returns without resetting hooks or popping arena, but hooks aren't set yet; if ESIL initialization fails after malloc, buf is not freed). The state consistency across all execution paths is not fully maintained, making this highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve deallocation of linked structures like lists, trees, or graphs in a way that requires maintaining neighbor relationships. It frees a plain buffer and some lists (ictx.bbl, etc.) at the end, but these are simple list free operations, not complex linked structure re-linking. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 6,
        "reasoning": "Resource cleanup includes freeing memory, resetting callback hooks to NULL, and popping the register arena to restore state. This establishes isolation by ensuring no leftover hooks or allocated memory. However, the early return leaks break complete isolation. The principle applies but is not fully adhered to.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "No document processing (XML, etc.) or entity resolution is present in this code. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code reads several configuration options (anal.strings, emu.lazy, anal.gpfixed, anal.gp) that influence analysis behavior. These could be considered security-sensitive if they affect analysis results (e.g., enabling lazy emulation might skip certain checks). However, they are not explicitly \"gated\" behind security configuration; they are just regular config settings. Weak relevance because the specification is about explicit security gates, not general configuration.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2018-19843_after_subset_100:a71f1147:spec": {
    "timestamp": "2026-01-17T03:16:46.498271",
    "cve_id": "CVE-2018-19843",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a71f1147",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation (malloc for buf) and has multiple early return paths. While it does free the allocated buffer at the end, the ownership and release semantics are not strictly maintained across all early returns (e.g., returns after malloc failure, ESIL initialization failure, or other error checks). This makes HS-MEM-003 relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code does not process file content. It reads memory from an I/O interface (r_io_read_at) which could be backed by a file, but the specification specifically addresses file content processing edge cases like empty files, which is not the primary concern here.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "The function allocates several resources (buf, pcname, spname, and uses ESIL hooks). It has a cleanup section at the end that frees/restores these resources. However, there are multiple early return paths before this cleanup, which could leave resources allocated or hooks set, violating consistent state cleanup. This is a direct concern of HS-STATE-002.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code does not deallocate linked structures. It frees simple buffers and lists but does not involve complex linked structure deallocation where neighbor relationships need to be maintained.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 7,
        "reasoning": "The function sets ESIL hooks (hook_mem_read, hook_mem_write, hook_reg_write) and user data. The cleanup section attempts to restore isolation by NULLing these hooks and user pointer. However, early returns break this isolation, making HS-STATE-004 relevant, though the resource is not a traditional OS resource but an internal state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain an XML parser. This specification is completely irrelevant to the provided code.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code does not process documents or resolve external entities. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 6,
        "reasoning": "The code reads several configuration options (anal.strings, emu.lazy, anal.gpfixed, anal.gp) using r_config_get_i. These configurations gate behavior like string analysis and lazy emulation, which could be considered security-sensitive in an analysis context. However, they are not explicitly security gates in the traditional sense (e.g., authentication). The relevance is moderate.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2018-14665_before_subset_100:a28a3e75:spec": {
    "timestamp": "2026-01-17T03:17:08.544747",
    "cve_id": "CVE-2018-14665",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a28a3e75",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code dynamically allocates memory for `logFileName`, `suffix`, and `oldLog` using `asprintf`. It correctly calls `free(suffix)` and `free(oldLog)` in the backup path. However, the function returns `logFileName` to the caller, transferring ownership. This is a clear ownership semantics scenario. The code does not free `logFileName` before returning, which is correct if the caller is expected to free it. The relevance is strong because the specification directly addresses memory ownership, which is a central concern in this function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about processing file content and handling edge cases like empty files. The target code does not process file content at all; it only manipulates file names and performs file system operations (rename, remove) based on file existence. Therefore, the connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The function manages resources (dynamically allocated strings and file system state) across multiple execution paths (backup vs. non-backup, success vs. error). It must ensure cleanup (freeing memory, handling file operations) is consistent whether the `backup` condition is true or false, and whether operations like `rename` or `remove` succeed or fail. The use of `FatalError` on allocation failures simplifies cleanup but terminates the program, which is a form of state consistency.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code is a generic log file preparation function with no relation to IPP or any printing protocol. Therefore, it is basically not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification is about sanitizing printer configuration files before processing. The target code handles log file names, not printer configuration files, and does not perform any sanitization. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about enforcing strict message parsing in IPP protocol implementations. The target code has nothing to do with network protocols or message parsing. No relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating path components before archive extraction. The target code constructs file paths using format strings (`fname`, `backup`) and user-provided `idstring`, then uses them in file operations (`rename`, `remove`). There is a weak connection because the code does not validate the constructed paths for directory traversal or other unsafe components before using them, which could be a security issue. However, it is not specifically about archive extraction.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 1,
        "reasoning": "The specification is about enforcing path isolation during sandboxed extraction. The target code performs simple log file rotation/removal and is not related to sandboxing, extraction, or path isolation mechanisms. No relevance.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      }
    ]
  },
  "CVE-2018-14665_after_subset_100:8a5fd570:spec": {
    "timestamp": "2026-01-17T03:17:31.981757",
    "cve_id": "CVE-2018-14665",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8a5fd570",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `free()` for `suffix` and `oldLog`, but does not free `logFileName` before returning it. This could lead to a memory leak if the caller is not responsible for freeing it, violating strict ownership semantics. However, the function returns the pointer, so ownership may be transferred, making the relevance moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about processing file contents, but the target code deals with file names and file system operations (rename, remove). It does not read or process the content of any log files, so the relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple execution paths (if backup exists, else block) and uses `FatalError` which likely terminates the program. However, before calling `FatalError`, allocated memory (`logFileName`, `suffix`, `oldLog`) is not freed, leaving the program state inconsistent. This is a direct violation of maintaining consistent state during resource cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code is a generic log file preparation function with no relation to IPP or printer protocols. The relevance is basically non-existent.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing strict message parsing in IPP protocol implementations. The target code does not implement any network protocol or message parsing; it performs local file system operations. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code constructs file paths using user-controlled format strings (`fname`, `backup`, `idstring`) and performs filesystem operations (`rename`, `remove`). It does not validate the resulting path components (e.g., for directory traversal sequences like \"../\") before use, which is a security weakness. However, the specification is specifically about \"archive extraction,\" which this code is not doing, so the relevance is weak.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing path isolation in a sandboxed extraction context. The target code performs simple file operations in the normal filesystem with no sandboxing or isolation mechanisms mentioned. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      }
    ]
  },
  "CVE-2019-19012_before_subset_100:8a3d6071:spec": {
    "timestamp": "2026-01-17T03:18:18.295738",
    "cve_id": "CVE-2019-19012",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8a3d6071",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs multiple buffer operations using STRCPY, STRNCPY, and STRMOVE on buffer 'buf' allocated with a fixed size. There is no validation that these string operations stay within the allocated bounds, especially when concatenating directory names and path components. The calculation \"STRLEN(path) + BASENAMELEN + 5\" may be insufficient for long filenames or deep directory structures.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 10,
        "reasoning": "Directly relevant. The function's core purpose is pathname expansion with wildcards. It processes patterns containing \"*\", \"?\", \"[\", \"{\", \"~\", \"$\" and specially handles \"**\" for recursive expansion. The code converts patterns to regex and validates matches, but lacks explicit validation of pattern syntax length constraints before processing, which could lead to resource exhaustion or buffer overflows.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function performs recursive filesystem path expansion with state maintained through static variable 'stardepth' and recursion. It must maintain consistent state during directory traversal, pattern matching, and recursive calls. The code uses opendir/readdir/closedir and handles intermediate buffer states, but complex recursion paths could lead to inconsistent state if interrupted or if errors occur.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem path processing must maintain consistent state during expansion operations"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code allocates memory for 'buf' and 'pat', and allocates regex program via vim_regcomp. Memory is freed via vim_free and vim_regfree. However, there are multiple early return paths (e.g., when alloc returns NULL, pat is NULL, or regmatch.regprog is NULL) that must ensure proper cleanup. The ownership semantics appear maintained but could be complex due to recursion.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This specification concerns file content processing, but the target code deals with pathname expansion and directory traversal, not reading or processing file contents. The function checks file existence via mch_lstat/mch_getperm but doesn't process file data.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function uses multiple resources: allocated memory (buf, pat, regprog), directory handles (dirp), and recursive state. Cleanup must occur across all execution paths including early returns, recursion branches, and error conditions. The code has vim_free and vim_regfree calls at the end, but early returns might miss some cleanup in complex scenarios.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Not relevant. This specification specifically addresses XML parsers and external entity processing. The target code is a Unix path expansion function with no XML parsing capabilities.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Not relevant. This specification concerns document processing and entity resolution boundaries, typically for XML or similar formats. The code performs filesystem path expansion, not document processing.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2017-15670_after_subset_100:1db61766:spec": {
    "timestamp": "2026-01-17T03:18:31.243401",
    "cve_id": "CVE-2017-15670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1db61766",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs buffer operations with `buf = alloc(STRLEN(path) + BASENAMELEN + 5)` and subsequent string manipulations using `STRCPY`, `STRNCPY`, and pointer arithmetic. While there is some length consideration (adding BASENAMELEN+5), the code doesn't explicitly validate that all operations stay within allocated bounds, especially during recursive expansions and string concatenations. This makes HS-MEM-001 relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 9,
        "reasoning": "The function `unix_expandpath` is specifically for pathname expansion with wildcards. It processes patterns containing \"*\", \"?\", \"[\", etc., converts them to regex via `file_pat_to_reg_pat`, and validates matches. The code handles pattern syntax and has some constraints (like stardepth < 100), making HS-INPUT-002 highly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code performs filesystem path processing with recursive directory traversal (via `opendir`/`readdir`), state maintenance through `stardepth` static variable, and consistent expansion across recursive calls. It maintains state during expansion operations, aligning with HS-IO-003.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem path processing must maintain consistent state during expansion operations"
      },
      {
        "score": 5,
        "reasoning": "Memory is allocated with `alloc` and freed with `vim_free(buf)` and `vim_regfree(regmatch.regprog)`. Ownership appears clear, but there are multiple early returns (e.g., when `pat == NULL` or `regmatch.regprog == NULL`) that could complicate ownership semantics if not all paths free resources properly. HS-MEM-003 has moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code deals with path expansion and directory traversal, not file content processing. HS-INPUT-004 focuses on file content edge cases (empty files), which doesn't apply here.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function manages resources like `buf`, `regmatch.regprog`, and `dirp`. Cleanup occurs at multiple points and across early returns. However, there's a potential issue: if `opendir` fails, `dirp` is NULL and no cleanup is needed, but if `readdir` or other operations fail mid-loop, resources are still cleaned up at the end. HS-STATE-002 is relevant.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve XML parsing; it's a Unix path expansion function. HS-INPUT-001 is about XML parsers and external entities, which is completely unrelated.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve document processing or entity resolution; it's a filesystem path expansion function. HS-SEC-002 is irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2016-7425_before_subset_100:1cf31f48:spec": {
    "timestamp": "2026-01-17T03:18:40.539777",
    "cve_id": "CVE-2016-7425",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1cf31f48",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory release operations (like free). It manipulates a buffer pointer `r->_buf` and writes to it, but there is no deallocation. The specification about maintaining strict ownership semantics during release is weakly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes an array of spans, not file content. The specification about handling edge cases in file processing (like empty files) has very low relevance to this graphics rendering function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple execution paths (conditional branches) but always returns `CAIRO_STATUS_SUCCESS`. It does not acquire or release external resources (like file handles or allocated memory) within its scope, so the relevance to resource cleanup and state consistency is weak to moderate.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a low-level image span renderer, not an image parser. It does not validate image dimensions against file data. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, this function is not a file format reader and does not perform memory allocation based on dimensions. The relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer write operations via pointer `m` and uses `memset`. The length `len` is calculated from span coordinates (`spans[1].x - spans[0].x`). While there is no explicit size validation shown for the destination buffer `r->_buf`, the principle of validating size parameters is moderately relevant to this pattern of memory writing.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The code uses the calculated `len` for memory operations (`memset`). It checks if `len >= r->u.composite.run_length` but does not explicitly enforce that `len` is non-negative. The calculation `spans[1].x - spans[0].x` could theoretically be negative if the spans array is malformed, leading to unsafe behavior. The specification's principle is strongly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "The code performs arithmetic (`spans[1].x - spans[0].x`) to calculate a length used in memory operations (`memset`). There is no visible protection against integer overflow/underflow in this subtraction or in the subsequent pointer arithmetic (`m += len`). This is a relevant concern for secure memory sizing.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2020-35492_after_subset_100:c7e13658:spec": {
    "timestamp": "2026-01-17T03:18:48.712204",
    "cve_id": "CVE-2020-35492",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c7e13658",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory release operations (like free). It manipulates memory buffers (e.g., `m`, `base`) but focuses on writing coverage data and calling compositing functions. Ownership semantics for allocated resources are not a primary concern in this rendering function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes span data, not file content. While it checks for `num_spans == 0`, this is a trivial input edge case, not related to file processing. The specification's focus on file handling is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "This is an image rendering function, not an image parser. It operates on already-decoded image data and span information. It does not validate dimensions against a file's data size.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, this function is not a file format reader. It performs pixel composition operations, not safe dimension checking prior to allocation from untrusted files.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer writes via `*m++` and `memset`. The `len` variable, derived from span coordinates (`spans[1].x - spans[0].x`), is used as a size for `memset`. While `len` is used in a context (`if (len > 1)`) that prevents a negative count for `memset`, there is no explicit validation against signedness issues (e.g., if the calculation could overflow). The relevance is moderate as buffer operations are present but not the core vulnerability pattern.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The code calculates `len = spans[1].x - spans[0].x` and later uses it in `memset (m, spans[0].coverage, --len)`. It checks `if (len > 1)` before this operation, which enforces a positive length for the memset call. This directly relates to enforcing non-negative length constraints for memory operations. The check on `spans[0].x != x0` before composite calls also acts as a non-zero width check.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "Arithmetic operations are present, such as `spans[1].x - spans[0].x` and `spans[0].x - x0`. These results are used as width parameters for memory operations (`memset`) and compositing functions. The code does not show explicit overflow/underflow protection for these calculations (e.g., checking if `spans[1].x >= spans[0].x`). The relevance is moderate because these calculations are integral to memory sizing for the operations.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2015-8803_before_subset_100:a189c989:spec": {
    "timestamp": "2026-01-17T03:19:04.406272",
    "cve_id": "CVE-2015-8803",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a189c989",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code performs low-level modular arithmetic on multi-precision integers (limbs). It manipulates an array `rp` but does not involve dynamic memory allocation or release operations. The specification about maintaining strict ownership semantics during memory release is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code is a mathematical function for elliptic curve cryptography (ECC) reduction modulo a prime. It does not process files or file content in any way. The specification is completely irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 3,
        "reasoning": "The function operates on a fixed-size input array to compute a mathematical result. It does not acquire or manage external resources (like file handles, network sockets) that require cleanup across different execution paths. Its state is confined to local variables and the output array.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code works on a contiguous array of numeric limbs, not on linked lists, trees, or other pointer-based structures. The concept of deallocating linked structures while maintaining neighbor relationships does not apply.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 2,
        "reasoning": "The function is a pure computation with no persistent resources to clean up or isolate. The specification about establishing a complete isolation state after resource cleanup is not relevant to this algorithmic code.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 1,
        "reasoning": "This is cryptographic arithmetic code, not an XML parser. The specification regarding XML external entity processing is entirely unrelated.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Similar to spec 6, this specification concerns document processing and entity resolution, which has no connection to the low-level modular reduction function shown.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 4,
        "reasoning": "There is a weak connection. The code implements a core cryptographic primitive (ECC modular reduction). While the code itself doesn't show configuration options, the broader system using this function should gate security-sensitive features (like which curves are enabled) behind explicit configuration. The code is a building block for such features.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2022-29207_before_subset_100:bbd20934:spec": {
    "timestamp": "2026-01-17T03:20:07.897944",
    "cve_id": "CVE-2022-29207",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bbd20934",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code deals with device selection for tensor operations in a machine learning framework (likely TensorFlow). There is no processing of IPP attributes or any printing-related protocol in this code, making the connection very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns sanitizing printer configuration files. The target code performs device resolution logic for computational operations and does not involve parsing, processing, or sanitizing any configuration files, let alone printer-specific ones. The relevance is extremely low.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about enforcing strict message parsing for the IPP protocol. The target code contains no network message parsing logic. It is focused on internal device and resource handling within a runtime context.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 6,
        "reasoning": "The specification about memory release operations maintaining strict ownership semantics has moderate relevance. While the code does not explicitly allocate or free memory in this snippet, it handles device and tensor resource pointers (e.g., `Device*`, `TensorHandle*`). Ensuring correct ownership and lifecycle management of these resources is a related secure coding concern, though not the primary focus of the function.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about handling edge cases when processing file content. The target code processes tensor handles and device information, not file content. A weak connection exists in the sense that the code does handle edge cases (e.g., null device pointers, different tensor types), but the domain (file I/O vs. runtime object management) is different.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification about resource cleanup maintaining consistent state across execution paths has strong relevance. The function has multiple conditional branches (non-local tensor, resource tensor, local tensor) and must ensure the `*result` device pointer is correctly assigned in every path. Failure to do so could leave the caller with an inconsistent or invalid device state, which is a core concern of this specification.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns network feature declarations matching implementation capabilities. The target code is part of a device placement and execution runtime. There is no declaration or negotiation of network features. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating packet fragment counts against buffer space during packet processing. The code performs logical device selection and does not involve low-level network packet processing, fragmentation, or buffer allocation based on packet data.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      }
    ]
  },
  "CVE-2016-8650_after_subset_100:87964959:spec": {
    "timestamp": "2026-01-17T03:20:08.564364",
    "cve_id": "CVE-2016-8650",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "87964959",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code performs low-level modular arithmetic for elliptic curve cryptography (ECC). It manipulates multi-precision integers (limbs) but does not involve any dynamic memory allocation or release operations. The specification about memory release ownership is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code is a mathematical function for modular reduction. It does not process files or file content in any way. The specification is completely irrelevant to this context.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 2,
        "reasoning": "The function operates on provided limb arrays and local variables. It does not acquire or manage external resources (like file handles, network sockets, or dynamic memory) that require cleanup across different execution paths. Its state consistency is purely mathematical within the algorithm.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code works with arrays of integers (limbs), not linked data structures (nodes, lists, trees). The concept of deallocating linked structures while maintaining neighbor relationships does not apply.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "The code is a cryptographic arithmetic function, not an XML parser. This specification is entirely unrelated to the target code.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns document processing and entity resolution, which is a domain (e.g., XML, SGML) completely separate from the low-level mathematical operations in this ECC modular reduction code.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "There is a very weak connection. The code implements a core cryptographic primitive (ECC modular reduction). Cryptographic implementations are security-sensitive. However, the code itself does not expose configuration options; it is a foundational building block. The relevance is minimal because the specification is about gating features behind configuration, not about implementing the sensitive algorithm correctly.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2022-29207_after_subset_100:0e7d849d:spec": {
    "timestamp": "2026-01-17T03:20:26.801532",
    "cve_id": "CVE-2022-29207",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0e7d849d",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about validating IPP attribute values before processing. The target code processes a tensor handle and resource handle, but it is not related to the IPP protocol. There is weak relevance because the code does perform some validation (e.g., checking for empty resource handle), but the context and protocol are completely different.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code deals with tensor operations and device placement in a machine learning framework, with no relation to printers or configuration files.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about enforcing strict message parsing for the IPP protocol. The target code does not parse any network protocol messages; it handles internal data structures for device selection.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 6,
        "reasoning": "The specification is about memory release operations maintaining strict ownership semantics. The target code does not explicitly allocate or release memory, but it manages device and tensor handle references. Ensuring correct device assignment and avoiding dangling references relates to resource ownership principles, though not directly about memory release.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "The specification is about handling all edge cases including empty files when processing file content. The target code explicitly checks for an empty resource handle (`tensor->NumElements() == 0`) and returns an error, which is a direct example of handling an edge case (empty resource) in data processing. However, the context is not about file content but tensor/resource handles.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification is about maintaining consistent state during resource cleanup across all execution paths. The target code does not perform explicit resource cleanup; it selects a device based on input conditions. However, ensuring consistent device assignment and error handling (like returning errors for invalid states) relates to maintaining a consistent program state, which is a weaker connection.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about network feature declarations matching implementation capabilities. The target code is focused on device management for tensor operations, with no network features or declarations involved.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating fragment counts against pre-allocated buffer space during packet processing. The target code does not process network packets or buffers; it operates on high-level tensor and device objects.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      }
    ]
  },
  "CVE-2018-20855_before_subset_100:415e514a:spec": {
    "timestamp": "2026-01-17T03:20:45.907682",
    "cve_id": "CVE-2018-20855",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "415e514a",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves dynamic memory allocation (`kvzalloc`) and release (`kvfree`). While ownership is clear (allocated and freed within the same function), the error path `err_cqwq` only destroys the work queue but does not free the allocated `in` buffer if `mlx5_vector2eqn` fails, creating a potential memory leak. This violates strict ownership semantics as memory is not released on all error paths.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification about processing file contents and handling empty files is not relevant. This code deals with creating a hardware completion queue (CQ) for a device driver, not file I/O operations.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple resource allocation steps (wq creation, memory allocation) and multiple error paths. The cleanup must ensure all allocated resources (wq, `in` buffer) are properly released and state is consistent. The identified memory leak on one error path is a direct violation of this principle.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code calculates `inlen` based on a structure size and the number of pages, then allocates a buffer of that size. While it doesn't perform typical buffer copies where length validation is critical, it does pass `in` and `inlen` to `mlx5_core_create_cq`. The safety depends on the internal validation of that function. The calculation itself uses kernel macros and seems correct.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The primary input parameter is `cq_size`, which is validated/transformed via `roundup_pow_of_two`. There's no processing of untrusted external input (like from userspace) in a classic security sense. The parameters are likely internal driver state.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      },
      {
        "score": 5,
        "reasoning": "Moderately to strongly relevant. The code prepares a command (`in` buffer with CQC context and page address list) to communicate with the hardware device (MLX5) to create a CQ. It is crucial that the buffer boundaries (`inlen`) are correctly calculated and respected when the data is passed to the hardware. Miscalculation could lead to out-of-bounds access.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Device communication buffers must enforce strict boundary checks"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification text \"Network feature declarations must precisely match implementation capabilities\" seems misplaced or mis-copied (it repeats HS-MEM-003's identifier but different text). The original HS-MEM-003 is about memory release. The code here is implementing a specific hardware feature (CQ creation), not declaring network features.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification concerns packet processing and fragment counts. This code is setting up a hardware queue structure for device communication, not processing network packets or their fragments.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      }
    ]
  },
  "CVE-2019-19045_after_subset_100:9e8ecfa8:spec": {
    "timestamp": "2026-01-17T03:20:56.988542",
    "cve_id": "CVE-2019-19045",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9e8ecfa8",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves dynamic memory allocation (`kvzalloc`) and release (`kvfree`). While ownership is clear (allocated `in` is freed before function exit on both success and error paths), the error path `err_cqwq` does not free `in` if `mlx5_vector2eqn` fails, as `in` is freed before jumping to that label. However, if `mlx5_core_create_cq` fails, `in` is correctly freed. This shows attention to ownership, but the early error path's direct free and jump bypasses the `err_cqwq` cleanup for `in`, which is correct but should be checked for consistency. The main principle of maintaining strict ownership semantics is strongly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about file content processing and handling empty files. The target code deals with creating a Completion Queue (CQ) for an FPGA connection in a driver context. There is no file I/O, reading, or processing of file contents. The scenario is completely unrelated.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple resource allocation points (wq creation, memory allocation) and multiple error paths. It uses `goto` statements for centralized cleanup (`err_cqwq`). The cleanup function `mlx5_wq_destroy` is called appropriately on the error path. However, it's important to verify that all allocated resources (like the wq) are cleaned up on all exit paths. The code shows a clear pattern of attempting to maintain consistent state, making this specification highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 6,
        "reasoning": "The code calculates `inlen` based on a fixed header size plus a variable number of pages. It then allocates a buffer of that size. There is no direct user-provided \"length parameter\" being validated against a fixed buffer size. However, the principle of ensuring calculated sizes do not overflow or cause allocation issues is present. The use of `roundup_pow_of_two` and `ilog2` on `cq_size` could be seen as input validation/transformation. Relevance is moderate as the core concept of size validation is present but not in the classic buffer overflow defense context.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "The function parameter `cq_size` is an external input (from the caller). It is validated/transformed via `roundup_pow_of_two`. However, there is no explicit check for minimum/maximum bounds or invalid values before it's used in calculations (e.g., `ilog2`). The connection to \"buffer operations\" is indirect, as the size influences the WQ and CQ creation. The relevance is weak to moderate.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      },
      {
        "score": 7,
        "reasoning": "The code prepares a command (`in` buffer) to communicate with the hardware device (create CQ). It fills this buffer with context data and page addresses. The size of this communication buffer (`inlen`) is precisely calculated and passed to `mlx5_core_create_cq`. This enforces a boundary for the command. The principle of ensuring device communication buffers are correctly sized and structured is clearly applicable, making it moderately to strongly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Device communication buffers must enforce strict boundary checks"
      },
      {
        "score": 1,
        "reasoning": "The specification mentions \"Network feature declarations\". The target code is for an FPGA connection CQ creation within a driver. It does not involve declaring network features (like offload capabilities) or advertising them to the network stack. The scenario is unrelated.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 1,
        "reasoning": "The specification is about packet processing and validating fragment counts. This code is setting up a hardware queue structure (CQ) for a connection. There is no packet data, fragmentation, or packet processing logic in this function. The scenario is completely unrelated.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      }
    ]
  },
  "CVE-2022-25761_before_subset_100:ca1d4e74:spec": {
    "timestamp": "2026-01-17T03:21:35.320024",
    "cve_id": "CVE-2022-25761",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ca1d4e74",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code shows secure channel setup and initialization, but does not involve any explicit DMA (Direct Memory Access) operations or mention of VMAP_STACK. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 2,
        "reasoning": "The code is related to network/communication channel security, not USB device drivers or USB control message handling. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      },
      {
        "score": 4,
        "reasoning": "While the code performs driver/channel initialization, there is no visible logic dealing with platform-specific memory architecture constraints (e.g., alignment, DMA zones). The connection is weak.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Driver initialization must account for platform memory architecture constraints"
      },
      {
        "score": 5,
        "reasoning": "The code allocates and initializes resources (secure channel, connection) but does not show any memory release or ownership transfer operations. The principle of maintaining ownership semantics during release is not demonstrated, leading to weak relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code does not process file content. It sets up a communication channel. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-25761_after_subset_100:617626c5:spec": {
    "timestamp": "2026-01-17T03:21:48.909617",
    "cve_id": "CVE-2022-25761",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "617626c5",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code shows secure channel setup and connection attachment in a user-space application context. There is no indication of Direct Memory Access (DMA) operations, stack usage with VMAP_STACK, or kernel-level driver development. The specification is for low-level kernel/driver programming and does not apply.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 2,
        "reasoning": "The code involves initializing a network secure channel (likely OPC UA). There is no USB device interaction, control message handling, or buffer transfer logic present. The specification is specific to USB driver development.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      },
      {
        "score": 5,
        "reasoning": "The code performs high-level API calls for secure channel setup. While memory allocation may occur internally (e.g., for send buffers), the code does not show direct driver initialization or explicit handling of platform-specific memory architecture constraints like physical vs. virtual address spaces.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Driver initialization must account for platform memory architecture constraints"
      },
      {
        "score": 5,
        "reasoning": "The code initializes resources (secure channel, connection) but does not show cleanup or release operations. The principle of maintaining strict ownership semantics during memory release is a general secure coding practice relevant to any resource management. The code's setup phase implies that corresponding cleanup must follow this principle, giving it moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code deals with network channel security setup, not file I/O or file content processing. There is no file handling logic present.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code establishes a connection and attaches it to a secure channel, changing the channel's state. If an error occurs later or during cleanup, all interconnected resources (testChannel, testingConnection) must be cleaned up consistently to avoid dangling pointers or inconsistent states. This is a core concern for the lifecycle of the objects shown, giving the specification moderate to strong relevance.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code creates linked structures (testChannel.connection points to testingConnection, and the connection likely references the channel). While deallocation is not shown, the principle of maintaining consistent neighbor relationships during deallocation is relevant to preventing memory corruption or use-after-free in such linked data. The connection is weak because the code only shows setup, not teardown.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Similar to HS-STATE-002, this specification concerns resource cleanup. The code creates linked resources. Complete isolation state during cleanup (ensuring no cross-references remain) is important to prevent security issues. The relevance is moderate as the principle applies to the implied cleanup of the constructed objects, though not demonstrated.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2017-18257_before_subset_100:0155b048:spec": {
    "timestamp": "2026-01-17T03:22:09.053781",
    "cve_id": "CVE-2017-18257",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0155b048",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about memory release operations and ownership semantics. The target code constructs a chunk and adds data to it but does not involve any memory deallocation or ownership transfer. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about file content processing and edge cases for empty files. The target code deals with network protocol (SCTP) chunk construction, not file I/O. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The specification is about resource cleanup maintaining consistent state. The target code is a construction function that allocates a chunk and adds parameters. It does not perform cleanup or have multiple execution paths requiring state consistency. Weak relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 6,
        "reasoning": "The specification is about packet parsing failure handling ensuring state initialization. The target code constructs a packet (chunk) for a reset request. While it's not parsing, it is building a protocol message. There is moderate relevance because proper initialization of the chunk and its parameters is crucial, and failure (if sctp_make_reconf fails) is handled by returning NULL.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 8,
        "reasoning": "The specification is about protocol dissectors validating complete header presence. The target code is constructing a protocol message (SCTP Re-configuration chunk with reset parameters). It correctly sets parameter types and lengths (e.g., param_hdr.type, param_hdr.length) based on input flags and stream list. This is directly relevant to ensuring a well-formed protocol message is built, though it's construction rather than dissection. Strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about network input processing guaranteeing field initialization before use. The target code processes input parameters (stream_num, stream_list, out, in) to build an outgoing chunk. It uses these to calculate lengths and conditionally add data. It must ensure derived fields (outlen, inlen) and structure fields are properly initialized before being added to the chunk, which it does. Moderate to strong relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Network input processing must guarantee field initialization before use"
      },
      {
        "score": 5,
        "reasoning": "The specification is about linked structure deallocation maintaining neighbor relationships. The target code does not deallocate any linked structures. It creates a new chunk and adds data to it. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification is about resource cleanup operations establishing complete isolation state. The target code is a construction function that allocates a chunk. It does not perform cleanup or isolation. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-0322_after_subset_100:a1d80125:spec": {
    "timestamp": "2026-01-17T03:22:14.998852",
    "cve_id": "CVE-2022-0322",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a1d80125",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code constructs a chunk for a stream reset request and does not involve any explicit memory release or deallocation operations. The specification about memory release ownership is only weakly relevant as the function allocates a chunk via `sctp_make_reconf`, but ownership and release semantics are managed by the caller of this function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification is about file content processing and edge cases for empty files. The target code deals with network protocol (SCTP) chunk construction, not file I/O. There is no relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function constructs a data chunk and returns it. If the allocation fails, it returns NULL. There is no complex resource cleanup within this function itself (like closing handles, freeing multiple resources). The relevance is weak, as the main resource (the chunk) is either successfully created and returned or not allocated at all.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is constructing an outgoing packet, not parsing an incoming one. However, it does handle a potential failure from `sctp_make_reconf` by returning NULL, which could be considered a form of failure handling for the construction process. The connection to \"packet parsing failure handling\" is indirect and weak.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 5,
        "reasoning": "The code is a protocol message constructor (a form of \"dissector\" in reverse). It validates input conditions (the `out` and `in` booleans) before deciding which protocol parameters to include and their lengths. It ensures the structure is built correctly based on the presence of required data, aligning with the principle of validating what to process before building.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function processes input parameters (`stream_num`, `stream_list`, `out`, `in`) to build a network message. It correctly initializes local variables (`outlen`, `inlen`) and uses them to control flow. It also uses the association's state fields (`strreset_outseq`, `next_tsn`) which are assumed to be initialized by the caller, a key aspect of input processing.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Network input processing must guarantee field initialization before use"
      },
      {
        "score": 5,
        "reasoning": "The specification is about deallocating linked structures and maintaining neighbor relationships. This code does not deallocate any linked structures; it only allocates and builds a single chunk. No relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns resource cleanup and establishing isolation state. This function's cleanup is trivial (returning NULL on allocation failure). It does not perform operations like locking, context switching, or complex state isolation that the specification likely addresses. Relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2016-8670_before_subset_100:72769e50:spec": {
    "timestamp": "2026-01-17T03:22:33.677468",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "72769e50",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification \"Memory release operations must maintain strict ownership semantics\" is weakly relevant. The target code performs arithmetic operations and clamping on array data but does not involve any explicit memory allocation or deallocation. There are no `malloc`, `free`, or similar operations whose ownership needs to be tracked.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification \"File content processing must handle all edge cases including empty files\" has very low relevance. The target code processes in-memory arrays (float pointers) and performs mathematical computations. There is no file I/O or file content processing involved in this function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 1,
        "reasoning": "The specification \"Resource cleanup must maintain consistent state across all execution paths\" has very low relevance. The function is a pure computational kernel that modifies an array in-place. It does not acquire or release resources (like file handles, network connections, or dynamic memory) that require cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 9,
        "reasoning": "The specification \"Array access operations must validate indices against array bounds\" is highly relevant. The function performs numerous array accesses via pointer arithmetic (e.g., `array_ptr[i]`, `bias_data[i]`). While it uses a defensive check (`TFLITE_DCHECK_EQ((array_size % bias_size), 0`) and loop conditions (`i <= bias_size - 16`, `i < bias_size`) to control iterations, the core security principle of ensuring indices are within bounds is central to this code's correctness and safety. The NEON intrinsics also assume valid memory regions.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Array access operations must validate indices against array bounds"
      },
      {
        "score": 6,
        "reasoning": "The specification \"Instruction operand validation must enforce semantic constraints\" has moderate relevance. The function's operands are the input parameters (clamp_min, clamp_max, bias_size, bias_data, array_size, array_data). The code includes one runtime check (`TFLITE_DCHECK_EQ`) to validate a relationship between `array_size` and `bias_size`. However, it does not comprehensively validate other semantic constraints, such as ensuring `clamp_min <= clamp_max` or that pointers are non-null. The principle of validating inputs before use is applicable but only partially addressed.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Instruction operand validation must enforce semantic constraints"
      },
      {
        "score": 2,
        "reasoning": "The specification \"Instruction encoding must maintain consistent state during assembly\" has very low relevance. This specification seems targeted at low-level instruction generation or assembly code. The target code is a C/C++ function with NEON intrinsics. While it uses SIMD instructions, the concern is about their correct use for computation, not about maintaining a consistent state during the encoding/assembly process itself.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Instruction encoding must maintain consistent state during assembly"
      },
      {
        "score": 1,
        "reasoning": "The specification \"Linked structure deallocation must maintain consistent neighbor relationships\" has very low relevance. The code operates on contiguous arrays of floats, not on linked lists, trees, or any other linked data structures. There are no node pointers or neighbor relationships to maintain.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 1,
        "reasoning": "The specification \"Resource cleanup operations must establish complete isolation state\" has very low relevance. As with specification 3, this function does not involve resource acquisition or cleanup. It performs a data transformation and returns. The concept of an \"isolation state\" after cleanup does not apply.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-23557_after_subset_100:ec40a95f:spec": {
    "timestamp": "2026-01-17T03:23:09.639089",
    "cve_id": "CVE-2022-23557",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ec40a95f",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification \"Memory release operations must maintain strict ownership semantics\" is weakly relevant. The target code performs arithmetic operations and clamping on array data but does not involve any explicit memory allocation or deallocation operations. There are no calls to free, delete, or similar memory release functions.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification \"File content processing must handle all edge cases including empty files\" has very low relevance. The code processes in-memory arrays (bias_data and array_data) and performs numerical computations. There is no file I/O, reading, or writing operations present in the function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Resource cleanup must maintain consistent state across all execution paths\" is weakly relevant. The function operates on provided data arrays without acquiring external resources (like file handles, network connections, or dynamically allocated memory that needs cleanup). The early return for bias_size==0 and the loop structures maintain computational state consistency but not resource cleanup state.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Array access operations must validate indices against array bounds\" has strong relevance. The code performs multiple array accesses (bias_data[i], array_ptr[i]) within loops. While there is a TFLITE_DCHECK_EQ for size alignment, this is a debug assertion that may be disabled in production. The loops use conditions like \"i <= bias_size - 16\" and \"i < bias_size\" which provide bounds control, assuming the input parameters (array_size, bias_size) are correct and the DCHECK holds.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Array access operations must validate indices against array bounds"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Instruction operand validation must enforce semantic constraints\" has moderate relevance. The function validates that bias_size is not zero (early return) and uses a debug check for size alignment. However, it doesn't thoroughly validate other semantic constraints like ensuring clamp_min <= clamp_max, or that bias_data and array_data pointers are valid for the given sizes. The NEON intrinsics assume proper memory alignment which isn't validated.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Instruction operand validation must enforce semantic constraints"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Instruction encoding must maintain consistent state during assembly\" has very low relevance. This specification appears to concern low-level instruction encoding or assembly generation. The target code is C/C++ with NEON intrinsics, not assembly language. The compiler handles instruction encoding, not the programmer.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Instruction encoding must maintain consistent state during assembly"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Linked structure deallocation must maintain consistent neighbor relationships\" has very low relevance. The code operates on contiguous arrays, not linked data structures (nodes with pointers to neighbors). There are no pointers being followed or modified in a way that would affect structural relationships.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Resource cleanup operations must establish complete isolation state\" is weakly relevant. Similar to spec_3, the function doesn't acquire or release external resources that would require isolation. It modifies array_data in-place, which could be considered a state change, but not in the context of resource cleanup or isolation from other system components.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2016-8670_before_subset_100:65967082:spec": {
    "timestamp": "2026-01-17T03:23:14.214245",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "65967082",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code accesses an array `s->edid_blob` using an index `s->reg` that is incremented without any bounds checking. This directly violates the principle of validating length parameters against the destination buffer size. A buffer over-read could occur if `s->reg` exceeds the size of `edid_blob`.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The index `s->reg` acts as an input (state) controlling the buffer read. While not \"external input\" in the typical network/user sense, it is mutable state that influences the buffer operation and should be validated. The lack of validation before the array access aligns with the core concern of this specification.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. This code is part of an I2C device communication model (`I2CSlave`). The function reads from a device buffer (`edid_blob`). The specification about enforcing strict boundary checks for device communication buffers applies directly, as the current code performs no boundary checks on `s->reg`.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Device communication buffers must enforce strict boundary checks"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code performs a memory read operation, not a memory release or deallocation. The specification regarding ownership semantics during release does not apply to this scenario.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes an internal EDID data blob, not file content. The specification concerning file handling and empty files is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function is a simple data accessor and does not acquire or clean up resources (like memory, handles, locks) that would require state consistency across different execution paths.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The operation `s->reg++` is an arithmetic increment. While integer overflow of the index itself is a concern, the more immediate issue is that the unchecked increment leads to an out-of-bounds array access on the next call, which is a consequence of missing bounds checking related to arithmetic operations on indices.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must prevent overflow through explicit type conversion or bounds..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve file system operations, block devices, or block size calculations. It operates on a memory-based data blob.",
        "spec_index": 7,
        "spec_preview": "HS-FS-002: File system operations must validate block size calculations before processing"
      }
    ]
  },
  "CVE-2016-8670_after_subset_100:1a60f570:spec": {
    "timestamp": "2026-01-17T03:23:50.975814",
    "cve_id": "CVE-2016-8670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1a60f570",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The code performs a buffer read operation using `s->reg` as an index into `s->edid_blob`. The modulus operation `% sizeof(s->edid_blob)` is a validation that prevents the index from exceeding the buffer size, directly addressing the requirement to validate length parameters against destination buffer size.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The index `s->reg` is state that could be influenced by external I2C master writes (not shown in this snippet). Before being used in the buffer operation, it is validated/modified via the modulus operation. This aligns with the principle of validating external input before buffer operations.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a direct device communication (I2C) buffer read function. The use of the modulus operator enforces a strict boundary check on the register index `s->reg` against the fixed size of the `edid_blob` buffer, which is a core requirement of this specification.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Device communication buffers must enforce strict boundary checks"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code snippet only performs a buffer read and increments a register. It does not involve any memory allocation, deallocation, or ownership transfer operations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes data from an internal EDID blob array, not from file content. The specification regarding file handling edge cases does not apply.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function is a simple accessor and state modifier. It does not acquire or release resources (like memory, locks, or file descriptors) that would require cleanup across different execution paths.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code uses the modulus operator to wrap the index `s->reg`, which prevents an integer overflow from leading to an out-of-bounds access. However, the increment `s->reg++` itself could theoretically overflow if `s->reg` is an integer type with a maximum value. The primary arithmetic concern (buffer index calculation) is well-handled.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must prevent overflow through explicit type conversion or bounds..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform any file system operations or block size calculations. It operates on a fixed-size in-memory buffer.",
        "spec_index": 7,
        "spec_preview": "HS-FS-002: File system operations must validate block size calculations before processing"
      }
    ]
  },
  "CVE-2017-13033_before_subset_100:09565ccf:spec": {
    "timestamp": "2026-01-17T03:23:54.241435",
    "cve_id": "CVE-2017-13033",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "09565ccf",
    "scores": [
      {
        "score": 4,
        "reasoning": "Specification HS-INPUT-001 discusses validating IPP attribute values, which is a specific protocol (Internet Printing Protocol) not related to the general type inference logic in the provided TensorFlow node code. The connection is very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-002 is about sanitizing printer configuration files. The target code performs forward type inference in a computational graph and has no relation to printer configurations or file sanitization.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-PROTOCOL-003 is about enforcing strict message parsing for the IPP protocol. The target code does not implement any network protocol message parsing.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 7,
        "reasoning": "Specification HS-MEM-003 about maintaining strict ownership semantics during memory release has moderate relevance. The code uses `std::vector` and `std::reference_wrapper` which manage memory automatically, but the `ClearTypeInfo()` call and the potential state changes in `MaybeCopyOnWrite()` touch on resource management and ownership concepts, though not explicitly memory release.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-INPUT-004 about handling edge cases in file content processing has very low relevance. The code processes node inputs and types within a graph structure, not file contents. The check for `nullptr` inputs is a form of edge case handling, but it's not related to files.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "Specification HS-STATE-002 about maintaining consistent state during resource cleanup has strong relevance. The function `ClearTypeInfo()` is called on certain paths (when inputs are incomplete), and `MaybeCopyOnWrite()` is called before modifying `props_->node_def`. This shows attention to ensuring the object's state remains consistent when operations are aborted or when modifications are made.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 6,
        "reasoning": "Specification HS-LOGIC-001 about validating numeric input bounds before arithmetic operations has moderate relevance. The code uses `DCHECK` to assert that `edge->dst_input()` and `ix` are within the bounds of their respective containers (`input_nodes.size()` and `node_t.args_size()`). This is a form of bounds checking, though `DCHECK` is typically disabled in release builds, which weakens the security relevance.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-INPUT-002 about validating numeric fields in file formats has very low relevance. The code validates integer indices against container sizes, but these indices come from the graph structure (edge connections), not from parsed file formats.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      }
    ]
  },
  "CVE-2022-23592_after_subset_100:f61b2f58:spec": {
    "timestamp": "2026-01-17T03:24:17.636782",
    "cve_id": "CVE-2022-23592",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f61b2f58",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification HS-INPUT-001 is about validating IPP attribute values before processing. The target code performs forward type inference in a computational graph (likely TensorFlow). While it does check for null inputs and validates array indices (e.g., `ix >= node_t.args_size()`), this is not related to IPP (Internet Printing Protocol) attributes. The connection is very weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-002 concerns sanitizing printer configuration files. The target code deals with graph node type inference and has no relation to printer configuration files or file sanitization.",
        "spec_index": 1,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-003 is about enforcing strict message parsing in IPP protocol implementations. The target code is not parsing network protocol messages; it is processing internal graph data structures for type inference.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 states memory release operations must maintain strict ownership semantics. The target code uses `std::vector` and `std::reference_wrapper` which manage memory automatically. However, it uses a `static FullTypeDef* no_type = new FullTypeDef();` which is a potential memory leak (never deleted) and could indicate an ownership issue. The principle of clear ownership applies, but the code is not primarily about memory release.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-004 is about handling edge cases in file content processing, including empty files. The code handles edge cases like missing inputs (`node == nullptr`), incomplete type information, and invalid indices. While the principle of handling incomplete/invalid data is relevant, the context is graph node processing, not file content processing.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 requires resource cleanup to maintain consistent state across all execution paths. The code has multiple early returns (e.g., when inputs are incomplete or type info is bad). Before each early return, it calls `ClearTypeInfo()` to ensure the node's type state is cleared consistently. This aligns well with the specification's principle of maintaining consistent state on all exit paths.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-LOGIC-001 requires numeric input validation before arithmetic operations. The code validates `edge->dst_input() < input_nodes.size()` with a `DCHECK` and explicitly checks `ix >= node_t.args_size()` before using `ix` to access `node_t.args(ix)`. This prevents out-of-bounds access. The validation is performed before the array indexing operation, which is the core principle of the specification.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Numeric input validation must enforce upper bounds before arithmetic operations"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 is about validating numeric fields in file formats against reasonable constraints. The code validates numeric indices (`dst_input`, `src_output`, `ix`) against container sizes. This is conceptually similar. However, the data is not coming from an external file format but from internal graph structures. The relevance is moderate but indirect.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: All file format numeric fields must be validated against reasonable constraints"
      }
    ]
  },
  "CVE-2022-23578_after_subset_100:61d020e7:spec": {
    "timestamp": "2026-01-17T03:24:49.198709",
    "cve_id": "CVE-2022-23578",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "61d020e7",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves memory management through unique_ptr and vector operations (e.g., const_tensors_.emplace_back, outputs_required allocation). While it doesn't explicitly show manual memory release, the use of RAII patterns (unique_ptr) and careful handling of kernel creation/deletion (params_.delete_kernel) shows attention to ownership. However, the specification is about strict ownership semantics during release, which is only partially demonstrated.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code processes a computational graph structure, not file content. There is no file I/O or handling of file data, empty or otherwise. This specification is completely unrelated to the target code's functionality.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The code performs resource initialization and cleanup (kernel creation/deletion on error, tensor management). The early return on kernel creation failure includes proper cleanup (params_.delete_kernel), maintaining consistent state. The initialization of multiple data structures (pending_ids_, frame_info_, etc.) shows attention to consistent state setup across the function's execution paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to printer configuration files or any file sanitization. This is a TensorFlow graph execution initialization function, completely unrelated to printer systems or configuration file processing.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations involving untrusted input must include overflow validation"
      },
      {
        "score": 5,
        "reasoning": "The code validates graph structure constraints (frame consistency, parallel_iterations checking) and ensures proper initialization ordering. While not about network protocol framing, it does validate structural constraints before processing (e.g., checking frame_info consistency). This represents a weak but meaningful connection to the specification's principle of validating structural constraints.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message framing constraints before processin..."
      }
    ]
  },
  "CVE-2022-23578_before_subset_100:605f59ae:spec": {
    "timestamp": "2026-01-17T03:24:49.352996",
    "cve_id": "CVE-2022-23578",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "605f59ae",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves memory management through vectors (e.g., `enter_frame_info_.resize(id + 1)`) and unique pointers (e.g., `absl::make_unique<std::vector<const NodeItem*>>()`). While it doesn't explicitly show manual memory release operations like `delete` or `free`, it uses RAII patterns. The principle of maintaining strict ownership semantics is relevant to ensuring that resources like `const_tensors_` and dynamically allocated kernel objects are properly managed. However, the code does not directly demonstrate ownership transfer or release operations that are the primary focus of HS-MEM-003.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code processes a computational graph structure, not file content. There is no file I/O, reading, or processing of file data. HS-INPUT-004 is specifically about handling edge cases in file content processing (like empty files), which is completely unrelated to this graph initialization code.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The code initializes and manages various stateful resources (NodeItem kernels, frame information, pending counts, constant tensors). It includes error handling with `TF_RETURN_IF_ERROR` that ensures cleanup on failure paths. The principle of maintaining consistent state across execution paths is relevant, especially when kernel creation fails (`item->kernel = nullptr`) or when resizing vectors. However, the code doesn't show explicit cleanup of partially initialized state on error, which would be the core of HS-STATE-002.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 8,
        "reasoning": "The code extensively processes node attributes (e.g., `GetNodeAttr(n->attrs(), \"send_device\", &send_device)`, `GetNodeAttr(n->attrs(), \"is_constant\", &is_constant_enter)`). These attributes are essentially input parameters that must be validated before use. While not explicitly labeled as IPP attributes, the principle of validating all input attribute values before processing directly applies. The code does perform some validation (e.g., checking frame_name consistency) but could be more comprehensive.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to printer configuration files or any file sanitization. It processes TensorFlow graph structures and node attributes, not printer or external configuration files. HS-SEC-002 is completely unrelated to this code scenario.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 3,
        "reasoning": "While the code doesn't implement IPP protocol, it does parse and process graph node structures and their attributes, which is analogous to message parsing in a protocol. The principle of strict parsing could apply to how node attributes are extracted and validated. However, the connection is weak since this is graph processing rather than network protocol implementation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code performs arithmetic operations when calculating indices (e.g., `item->input_start = frame_info->total_inputs`, `frame_info->total_inputs += n->num_inputs()`, `enter_frame_info_.resize(id + 1)`). These operations could potentially overflow if inputs are untrusted (e.g., very large graph with many nodes/edges). However, the code doesn't show explicit overflow validation, and the input (graph structure) is typically trusted in this context. The relevance is weak but present.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations involving untrusted input must include overflow validation"
      },
      {
        "score": 4,
        "reasoning": "The code validates some structural constraints of the computational graph (e.g., checking frame_name consistency for parallel_iterations). This is analogous to validating message framing constraints. However, this is graph validation rather than protocol message validation. The connection exists but is weak since HS-PROTOCOL-002 specifically refers to protocol implementations, not graph processing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message framing constraints before processin..."
      }
    ]
  },
  "CVE-2019-18609_before_subset_100:a6665f6b:spec": {
    "timestamp": "2026-01-17T03:25:29.504101",
    "cve_id": "CVE-2019-18609",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a6665f6b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code involves memory allocation via `ctx->allocate_output`, but it does not explicitly show memory release operations. The ownership of allocated tensors is managed by the TensorFlow framework's context (`OpKernelContext`), which likely handles cleanup. There is no manual memory management or explicit ownership transfer visible, making the direct application of strict ownership semantics for memory release weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes tensor inputs for quantization, not file content. There is no file I/O or handling of file streams. Edge cases like empty inputs might be relevant for tensor dimensions, but the specification is specifically about file content processing, which is not present here.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code allocates resources (tensors) and has multiple execution paths (e.g., `num_slices == 1` branch vs. else). However, resource cleanup is managed by the TensorFlow framework, not manually. The specification about maintaining consistent state during cleanup is only partially relevant, as the code relies on the framework to handle state consistency.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code validates some input conditions using `OP_REQUIRES` (e.g., checking `mode_ != QUANTIZE_MODE_MIN_FIRST` and axis constraints). It also uses tensor values (`min_range`, `max_range`) without explicit validation of their ranges or relationships (e.g., ensuring min <= max). The specification about validating attribute values before processing is moderately relevant, as some validation exists but may not be comprehensive.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code is a tensor quantization operation in a machine learning context, with no relation to printer configuration files or sanitization. The specification is completely unrelated to the code scenario.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code implements a quantization kernel, not an IPP (Internet Printing Protocol) protocol. There is no message parsing or network protocol handling involved. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The code processes tensor dimensions (e.g., `axis_`, `num_slices`, `pre_dim`, `post_dim`) and uses them for shaping output tensors. It implicitly relies on the input tensor's shape being valid. While not about image parsers, the principle of validating claimed dimensions against actual data size is relevant, as incorrect dimensions could lead to out-of-bounds access (e.g., in loops or `chip` operations). However, validation is limited to framework checks.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory for output tensors based on input shapes (`ctx->allocate_output`). It performs dimension calculations (e.g., `pre_dim`, `post_dim`) and uses them for reshaping. Safe dimension checking is partially present through TensorFlow's shape inference and `OP_REQUIRES`, but the code does not explicitly validate that dimensions are non-negative or within safe limits before allocation. The specification's principle applies moderately.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2021-37663_after_subset_100:fffd2732:spec": {
    "timestamp": "2026-01-17T03:25:35.499340",
    "cve_id": "CVE-2021-37663",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fffd2732",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation or release operations (like malloc/free, new/delete). Memory management is handled by the TensorFlow framework via `ctx->allocate_output`. While ownership semantics are important, the specification about \"strict ownership semantics\" for memory release is not directly applicable to this high-level tensor allocation pattern.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about file content processing and handling empty files. The target code processes tensor data in memory, not file content. There is no file I/O or handling of file-specific edge cases like empty files.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code performs resource allocation (tensor outputs) and has multiple execution paths (based on `axis_` and `num_slices`). It ensures outputs are allocated before use via `OP_REQUIRES_OK`. However, it does not deal with complex resource cleanup (like file handles, network connections) or explicit rollback operations. The framework likely manages cleanup, making the relevance moderate.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification about validating attribute values before processing is highly relevant. The code extensively validates input tensor attributes (dimensions, sizes, number of elements) using `OP_REQUIRES` before performing computations. This includes checks on `axis_`, input dimensions, min/max range tensor shapes, and element counts, which aligns directly with the principle of input validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification is about sanitizing printer configuration files. The target code is a tensor quantization operation in a machine learning framework and has no relation to printer configuration files or sanitization of such data.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about enforcing strict message parsing in the IPP (Internet Printing Protocol). The target code is a computational kernel for tensor quantization and does not involve network protocols or message parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification about validating claimed dimensions against actual data size has moderate relevance. The code validates tensor dimensions and sizes (e.g., `input.dims() > axis_`, `input_min_range.dim_size(0) == num_slices`) to ensure consistency before further processing and memory access. This is analogous to dimension validation in image parsers, though the context is different.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "The specification about safe dimension checking before memory allocation is relevant. The code performs multiple dimension checks (via `OP_REQUIRES`) on input tensors before allocating output tensors with `ctx->allocate_output`. This helps prevent allocation based on malicious or malformed dimension values, though the allocation is for tensors, not generic file formats.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2022-2207_before_subset_100:10fb958d:spec": {
    "timestamp": "2026-01-17T03:25:56.622190",
    "cve_id": "CVE-2022-2207",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "10fb958d",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve explicit memory allocation or deallocation operations. It primarily handles cursor movement, character deletion, and line joining within a text editor buffer. While buffer manipulation occurs, there are no malloc/free or ownership transfer patterns that align with HS-MEM-003's focus on memory ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code explicitly checks for empty file conditions at the beginning (BUFEMPTY()) and handles edge cases like cursor at buffer start. This aligns with HS-INPUT-004's principle of handling edge cases in content processing, though the context is text editor operations rather than file I/O.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function maintains editor state consistency through multiple execution paths (e.g., checking State flags, updating cursor positions, handling undo saves with u_save()). While not about system resources, it maintains consistent editor state across different backspace modes and conditions.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a text editor backspace function with no XML parsing capabilities. HS-INPUT-001 specifically addresses XML parser security configuration, which is completely unrelated to this C function for text editing operations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, this specification about document processing and entity resolution boundaries is irrelevant to a text editor's character deletion functionality. No document parsing or entity resolution occurs in this code.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code uses feature flags (FEAT_RIGHTLEFT, FEAT_JOB_CHANNEL, etc.) to gate functionality, which aligns with the concept of gating features behind configuration. However, these are compile-time features rather than runtime security-sensitive configurations.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "While the code manipulates text buffer structures, it doesn't involve linked list deallocation or maintenance of neighbor relationships in data structures. The \"neighbor relationships\" here refer to cursor position relative to insertion points, not data structure pointers.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The function performs cleanup of editor state (cursor positions, insertion points) but doesn't deal with system resources or establish isolation states. The \"isolation state\" concept from HS-STATE-004 doesn't apply to this text editing context.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2022-2207_after_subset_100:d56fe9c3:spec": {
    "timestamp": "2026-01-17T03:26:28.701609",
    "cve_id": "CVE-2022-2207",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d56fe9c3",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation or deallocation operations (like malloc/free). It manipulates cursor positions and text buffers but does not demonstrate ownership transfer or release of memory blocks. The specification about memory ownership is only weakly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The function manages editor state (cursor position, insertion start, replace stack) and has multiple return paths. It performs operations like u_save() for undo and calls like stop_arrow(). While not about traditional OS resources, it must maintain consistent editor state, showing moderate to strong relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code is a text editor backspace function. It does not parse or process XML in any way. The specification about XML parsers is completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Similar to spec 4, this is about document processing and entity resolution, which is unrelated to the core functionality of deleting characters in a text buffer. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code checks several editor configuration options (like 'backspace' via can_bs(), 'autoindent', 'softtabstop') that influence its behavior. These features could be considered security-sensitive in an editor context (e.g., influencing file modification). The connection is present but indirect and not the primary focus of the code.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "The code does not manipulate linked data structures (like lists or trees) that require careful neighbor updates during deallocation. It works on linear buffers and cursor indices. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The function performs cleanup-like actions (deleting characters, joining lines) and must ensure the editor's internal state is isolated/correct after these operations. However, the specification's concept of \"complete isolation state\" is more stringent and typically applies to system resources or security contexts, making the connection weak.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      }
    ]
  },
  "CVE-2016-8670_before_subset_100:f02d8d13:spec": {
    "timestamp": "2026-01-17T03:26:37.312841",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f02d8d13",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a character encoding conversion filter. It processes individual characters and outputs converted values. There are no dynamic memory allocations or ownership transfers visible in this snippet, making the memory release ownership specification largely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes character streams, not file contents directly. While it could be part of a file processing pipeline, the specification about handling empty files and edge cases in file content processing has very low direct relevance to this character-by-character conversion logic.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function maintains internal state (filter->status) for DBCS character processing, but there's no resource cleanup involved. The state management is simple and doesn't involve resources like file handles, memory, or network connections that would require cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "This specification is specifically for image parsers validating dimensions against file size. The target code is a character encoding converter for Big5/CP950, not an image parser, making this specification completely irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "This specification concerns file format readers performing dimension checking before allocation. The target code doesn't read file formats, allocate memory based on dimensions, or perform any file parsing that would require such checks.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "This specification is specifically for XML parsers and external entity processing. The target code handles Big5/CP950 character encoding conversion, not XML parsing, making this specification completely irrelevant.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "This specification concerns document processing and entity resolution boundaries. The target code is a low-level character encoding converter, not a document processor that would handle entities or have resolution boundaries.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "There's weak relevance as the code handles different encoding schemes (Big5 vs CP950) with different behaviors. While not exactly a \"security-sensitive feature\" in the typical sense, the encoding selection could potentially affect security if mishandled, but the connection is tenuous.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2017-13033_after_subset_100:58da091f:spec": {
    "timestamp": "2026-01-17T03:27:16.360056",
    "cve_id": "CVE-2017-13033",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "58da091f",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a character encoding conversion filter. It does not perform any explicit memory allocation or release operations within the shown function. The function processes single characters and outputs them via a callback. There is no direct management of memory ownership semantics here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes a stream of characters/bytes for encoding conversion. It is not directly processing file contents, nor does it handle file-level concepts like empty files. Its logic is focused on byte sequences and state transitions for multi-byte characters.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The function uses a state machine (filter->status) to handle multi-byte sequences. While it resets the status to 0 in the default case, the primary logic does not involve acquiring or cleaning up external resources (like file handles or memory). The state consistency is relevant but limited to the conversion state, not broader resource cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code is a text encoding converter, not an image parser. The specification about validating image dimensions is completely unrelated to this function's purpose.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 2,
        "reasoning": "The code does not read file formats or perform memory allocation based on dimensions. It processes a byte stream character by character. Safe dimension checking before allocation is not applicable to this context.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 1,
        "reasoning": "The code is not an XML parser. It converts between Big5/CP950 and wide character encodings. Specifications regarding XML external entity processing are irrelevant.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "The code is not processing documents (like XML or SGML) that involve entity resolution. It is a low-level character encoding conversion routine.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 3,
        "reasoning": "The function includes a minor security-sensitive feature: it handles a special case for CP950 encoding (PUA - Private Use Area mapping) differently than standard Big5. However, this is a hardcoded behavioral difference based on the source encoding type, not a feature gated behind an explicit user configuration option. The relevance is very weak.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2019-19012_before_subset_100:b4c36711:spec": {
    "timestamp": "2026-01-17T03:27:33.834325",
    "cve_id": "CVE-2019-19012",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b4c36711",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves complex memory management through recursive calls and frame structures (scan_frame). While it doesn't explicitly show memory release operations, it maintains ownership through careful state management across recursion levels. The frame allocation uses Newxz and has destructor registration (SAVEDESTRUCTOR_X), showing awareness of ownership semantics.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "This is regex compilation/optimization code, not file content processing. The code processes regex patterns in memory, not file contents. Edge cases handled are related to regex structure (zero-length expressions, infinite loops) rather than file I/O edge cases.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code implements complex recursive state management with scan_frame structures. Resource cleanup is carefully managed through unwind mechanisms (S_unwind_scan_frames destructor). State consistency is maintained across all execution paths including recursion unwinding and error conditions (FAIL macros).",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "Not relevant. This is Perl regex compilation code, not XML parsing. The code has no XML processing capabilities or entity resolution mechanisms.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "Not relevant. This specification relates to document processing and entity resolution boundaries, which doesn't apply to regex pattern compilation and optimization code.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code includes configuration-dependent optimizations (PERL_ENABLE_TRIE_OPTIMISATION, PERL_ENABLE_POSITIVE_ASSERTION_STUDY). Security-sensitive regex features like variable length lookbehind generate warnings (WARN_EXPERIMENTAL__VLB) and are gated behind checks. However, this is more about performance optimization than security.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 2,
        "reasoning": "Not relevant. This is regex compilation code, not image parsing. The code validates regex structure and calculates min/max lengths but doesn't process image dimensions or file data sizes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. While the code does perform bounds checking (e.g., checking for integer overflow in minlen calculations with SSize_t_MAX checks) and validates regex structure before optimization, it's not processing file formats or allocating memory based on external dimension claims in the way file format readers do.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2019-19012_after_subset_100:b97465c5:spec": {
    "timestamp": "2026-01-17T03:27:44.112469",
    "cve_id": "CVE-2019-19012",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b97465c5",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves complex memory management through recursive study_chunk calls and frame handling (scan_frame structures). While it doesn't explicitly show memory release operations, the recursive nature and frame management require careful ownership semantics to avoid memory leaks or use-after-free issues. The code uses StructCopy operations and manages RExC_frame structures, which implies ownership considerations.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "This is a regex compilation/optimization function (study_chunk) for Perl regular expressions, not file content processing. The code processes regex opcode trees, not file contents. Edge case handling relates to regex patterns (like zero-length expressions, infinite loops) rather than file I/O edge cases.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple execution paths through recursive calls, frame unwinding, and early returns. It manages resources like scan_frame structures, recursion tracking (RExC_study_chunk_recursed), and state flags. The frame unwinding mechanism and consistent state maintenance across recursion levels are important for correct resource cleanup.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "This is regex compilation code, not XML parsing. The function processes regular expression opcodes to optimize pattern matching, with no XML or external entity processing involved.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "No document processing or entity resolution in this regex compilation code. The code deals with regex optimization, character classes, and pattern analysis, not document parsing.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "While not directly about security features, the code does have configuration-dependent behavior (PERL_ENABLE_TRIE_OPTIMISATION, PERL_ENABLE_POSITIVE_ASSERTION_STUDY, NOJUMPTRIE). Some optimizations like variable-length lookbehind warnings are gated behind experimental flags. However, these are performance optimizations rather than security-sensitive features.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 2,
        "reasoning": "No image parsing or dimension validation in this regex code. The closest analogy might be bounds checking in regex operations, but it's not about file format validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 3,
        "reasoning": "Not file format reading code. However, the function does perform bounds checking and overflow prevention (e.g., checking SSize_t_MAX boundaries, preventing integer overflows in min/max calculations), which is conceptually similar to safe dimension checking before allocation.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2021-43814_after_subset_100:f64e400e:spec": {
    "timestamp": "2026-01-17T03:28:24.745636",
    "cve_id": "CVE-2021-43814",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f64e400e",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about linked structure deallocation maintaining neighbor relationships. The target code parses DWARF debug information and inserts data into a hash table (`ht_up_insert`). While it involves data structures, there is no explicit deallocation of linked structures shown in this snippet. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns resource cleanup achieving complete isolation. The code allocates memory with `strdup` and may free it on insertion failure. This touches on cleanup but is not about establishing a comprehensive isolated state. The connection is weak to moderate.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 6,
        "reasoning": "The specification is about memory release maintaining strict ownership semantics. The code shows a clear ownership transfer: `strdup` creates memory, and `ht_up_insert` is expected to take ownership (as implied by freeing on failure). This aligns with ownership principles, though the full release logic isn't shown. Moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The specification is about file content processing handling edge cases like empty files. The code processes a buffer of DWARF data but does not explicitly check for empty or malformed buffers at this level. The `buf_end` parameter provides a bound, but edge case handling is not the focus. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification is about resource cleanup maintaining consistent state across execution paths. The code has a cleanup path (free on insertion failure) which helps state consistency. However, it's a limited scenario and not the core function of the code. Weak to moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about XML parsers disabling external entity processing. The code parses DWARF debug information, not XML. The specification basically doesn't apply.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification is about document processing enforcing entity resolution boundaries, likely in the context of XML or similar. The code processes DWARF attributes, not documents with external entities. The specification basically doesn't apply.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The specification is about gating security-sensitive features behind explicit configuration. The code is a low-level DWARF parsing function with no user-facing features or configuration options. The specification basically doesn't apply.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2016-7425_before_subset_100:905bc903:spec": {
    "timestamp": "2026-01-17T03:28:27.487582",
    "cve_id": "CVE-2016-7425",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "905bc903",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve deallocation of linked structures. It parses DWARF debug information and inserts a key-value pair into a hash table. While there is a hash table insertion, there is no explicit deallocation or manipulation of neighbor relationships within a linked structure shown in this snippet.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 4,
        "reasoning": "The code allocates memory with `strdup` and inserts it into a hash table. If the insertion fails, the memory is freed. This is a form of cleanup, but it's a simple, localized operation. The specification about establishing a \"complete isolation state\" during resource cleanup is more relevant to complex resource management (like closing network connections and clearing all related data), which is not the primary focus here.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 8,
        "reasoning": "This specification is highly relevant. The code demonstrates strict ownership semantics for the `name` pointer. Ownership is created by `strdup`. Ownership is then transferred to the hash table via `ht_up_insert`. If the transfer fails, the original owner (this function) cleans up the memory with `free(name)`. This is a clear and correct pattern for maintaining memory ownership.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 1,
        "reasoning": "This specification is about gating security-sensitive features behind configuration options. The target code is a low-level parsing function for debug information. It does not implement any user-facing security-sensitive features that would require such configuration.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2016-8670_before_subset_100:33011477:spec": {
    "timestamp": "2026-01-17T03:29:11.667510",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "33011477",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve any memory allocation or release operations. It only parses a buffer and populates a structure with pointers into that buffer. There is no ownership transfer or memory management.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes a network protocol message buffer, not file content. The specification regarding empty files is not applicable to this context.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function does not acquire or manage resources (like file handles, memory allocations, or network connections) that require cleanup. It is a pure parsing function that returns a status code.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification is about IPP (Internet Printing Protocol) attribute validation. The target code parses STUN (Session Traversal Utilities for NAT) protocol messages, which is a completely different protocol.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns printer configuration file sanitization. The target code is a network protocol parser for STUN, not related to printer configuration or file processing.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is for IPP protocol implementations. While the code is a protocol parser, it is for the STUN protocol, not IPP. The core principle of strict parsing is relevant, but the specific protocol context makes direct application very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code parses STUN messages which contain TLV (Type-Length-Value) structures (attributes). It performs critical validation: it checks the total message length, iterates through attributes, validates each attribute's length against remaining buffer space (`if (msg_len < len)`), and handles unknown attribute types. This directly aligns with the specification's requirement to validate all TLV structures before processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all TLV structures before processing"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant and directly applicable. The function's primary purpose is to parse a network protocol (STUN) message. It enforces strict message boundary validation by:\n1. Checking the declared message length (`msg_len`) against the actual buffer length provided (`buf_len - sizeof(pjstun_msg_hdr)`).\n2. During attribute parsing, it ensures each attribute's computed length (`len`) does not exceed the remaining `msg_len`.\nThis prevents buffer overreads and ensures the parser stays within the bounds of the provided message, which is the exact intent of this specification.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce strict message boundary validation"
      }
    ]
  },
  "CVE-2017-13033_after_subset_100:37c404c7:spec": {
    "timestamp": "2026-01-17T03:29:30.428381",
    "cve_id": "CVE-2017-13033",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "37c404c7",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve any memory release operations. It only parses a message buffer without allocating or freeing memory, so HS-MEM-003 about memory ownership semantics is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The code processes network protocol messages, not file content. HS-INPUT-004 specifically addresses file processing edge cases, which is irrelevant to this STUN message parsing function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function does not acquire or manage resources that require cleanup (like file handles, memory allocations, or network connections). It only validates and parses input data, so resource cleanup consistency is not a concern.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "HS-INPUT-001 refers specifically to IPP (Internet Printing Protocol) attribute validation. This code parses STUN (Session Traversal Utilities for NAT) protocol messages, which is a completely different protocol.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code does not process printer configuration files or any configuration files. It parses network protocol messages, making this specification completely irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "While the code does implement protocol message parsing, it's for the STUN protocol, not IPP (Internet Printing Protocol). The specification specifically mentions IPP protocol implementations.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code implements a TLV (Type-Length-Value) parser for STUN message attributes. It validates attribute lengths, checks for length mismatches, handles padding, and validates attribute types against known types, which directly aligns with the principle of validating all TLV structures before processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all TLV structures before processing"
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. The code performs strict message boundary validation by checking that the declared message length (msg_len) matches the actual buffer length minus header size. It also validates individual attribute lengths against remaining message length, preventing buffer overflows and ensuring message integrity.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Network protocol implementations must enforce strict message boundary validation"
      }
    ]
  },
  "CVE-2022-23579_before_subset_100:9a2770b8:spec": {
    "timestamp": "2026-01-17T03:29:35.078161",
    "cve_id": "CVE-2022-23579",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9a2770b8",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve any explicit memory allocation or release operations. It focuses on graph node analysis and safety checks for removing identity nodes, with no ownership semantics related to memory management.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes node graph structures, not file content. There is no file I/O, reading, or handling of file edge cases like empty files.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "While the function determines if a node can be safely removed (a form of resource cleanup), it does not perform the cleanup itself or manage state consistency across multiple execution paths. The relevance is weak.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The code has no archive extraction, filesystem operations, or path validation logic. It operates purely on an in-memory computational graph.",
        "spec_index": 3,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 1,
        "reasoning": "No sandboxing, extraction, or path isolation is present. The code is about graph optimization, not security isolation for file operations.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      },
      {
        "score": 2,
        "reasoning": "No filesystem operations or security state management for file objects occurs. The code's \"state\" refers to graph node validity, not filesystem security.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Filesystem operations must maintain consistent security state across all object types"
      },
      {
        "score": 3,
        "reasoning": "The code validates node inputs and attributes (e.g., checking input size, node types) which loosely aligns with the principle of validating inputs before processing. However, it is not related to IPP (Internet Printing Protocol) attributes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "No printer configuration files, sanitization, or printing-related processing is involved. The code is part of a graph dependency optimizer, likely in a machine learning framework.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2022-23579_after_subset_100:38f5da89:spec": {
    "timestamp": "2026-01-17T03:29:59.272562",
    "cve_id": "CVE-2022-23579",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "38f5da89",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code deals with graph optimization (removing identity nodes) and does not involve any explicit memory allocation or deallocation. Ownership semantics for memory release are not relevant to this logic.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code processes node graph structures, not file contents. Edge cases related to empty files are not applicable here.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code performs graph analysis, not archive extraction or filesystem path operations. Path validation is irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-IO-001: Archive extraction must validate all path components before filesystem operations"
      },
      {
        "score": 5,
        "reasoning": "The code has no sandboxing or path isolation mechanisms. It operates on an in-memory computation graph.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Sandboxed extraction must enforce complete path isolation"
      },
      {
        "score": 5,
        "reasoning": "While the code must maintain a consistent graph state, it does not perform filesystem operations or manage security states of filesystem objects. The relevance is very indirect.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Filesystem operations must maintain consistent security state across all object types"
      },
      {
        "score": 5,
        "reasoning": "The code validates node inputs and types (e.g., checking for Variable, Recv, Switch), which is a form of input validation. However, the specification is specifically about IPP (Internet Printing Protocol) attribute values, which is a completely different domain, making direct relevance very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code is part of a dependency optimizer for a computational graph (likely TensorFlow). It has no relation to printer configuration files or their sanitization.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      }
    ]
  },
  "CVE-2022-3037_before_subset_100:4e5d5047:spec": {
    "timestamp": "2026-01-17T03:30:13.591370",
    "cve_id": "CVE-2022-3037",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4e5d5047",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code manipulates a buffer (curbuf) and deletes lines using ml_delete. While it doesn't explicitly perform memory deallocation (like free()), the buffer line deletion is a resource management operation. The specification about maintaining strict ownership semantics during memory release is moderately relevant, as improper handling of the buffer's line list could lead to inconsistencies, though the connection is not direct.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2022-3037_after_subset_100:252fa8e6:spec": {
    "timestamp": "2026-01-17T03:31:06.811245",
    "cve_id": "CVE-2022-3037",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "252fa8e6",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code involves buffer line manipulation (deleting lines with ml_delete) and manages a linked list of error entries (qfline_T). While not directly about memory deallocation like free(), it manages dynamic resources (buffer lines) and must ensure ownership and lifecycle are handled correctly to avoid dangling references or leaks, especially when qfp traverses the list. However, the specification's focus on \"strict ownership semantics\" for memory release is only partially applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes a list of error entries (quickfix list) which could be considered \"content.\" It checks if the list is empty (qfl->qf_start != NULL) and handles an empty buffer condition (ML_EMPTY). This relates to handling edge cases like empty inputs. However, the specification is specifically about \"File content processing,\" which is a narrower context than the general list processing seen here.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 7,
        "reasoning": "The function modifies global/stateful resources like the current buffer (curbuf), its properties (b_p_ma, filetype), and global variables (KeyTyped, curbuf_lock). It must ensure state consistency across multiple execution paths (e.g., early returns, breaks). For example, it restores KeyTyped at the end and manages curbuf_lock. This aligns well with the principle of maintaining consistent state during resource cleanup and operations.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification is about validating IPP (Internet Printing Protocol) attribute values. The target code is part of a quickfix feature in an editor (likely Vim) and has no relation to IPP, printing, or network protocol attribute processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The specification concerns sanitizing printer configuration files. The target code deals with an internal editor buffer for displaying error lists, not parsing or processing printer configuration files.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The specification is about enforcing strict message parsing for the IPP protocol. The target code does not implement any network protocol; it processes an internal data structure (quickfix list) for UI display.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about image parsers validating dimensions against file size. The target code does not parse images or any binary file formats; it handles text lines in an editor buffer.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 3,
        "reasoning": "The specification is about file format readers performing safe dimension checks before allocation. The code does read/process data (a list of errors) and adds lines to a buffer, which involves memory management. However, it does not parse complex file formats with dimensions (like images or documents). The weak connection is the general principle of validating input size/count before buffer operations, but it's not a direct application.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      }
    ]
  },
  "CVE-2017-15670_before_subset_100:b358bbd0:spec": {
    "timestamp": "2026-01-17T03:31:15.514609",
    "cve_id": "CVE-2017-15670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b358bbd0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memory allocations and buffer operations using calculations based on pattern lengths (e.g., `pattern_len = strlen(pattern) - 1`, `dirlen + 1`). While it uses `alloca` and `malloc` with these calculated sizes, it does not explicitly validate that the length calculations do not overflow or underflow before allocation. The relevance is strong because buffer length validation is a core security concern in this pattern expansion function, though not all calculations are explicitly checked for overflow.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant as the entire function is dedicated to pathname expansion (glob pattern matching). The code validates pattern syntax (e.g., checking for brace expression validity via `next_brace_sub`, handling escapes, and validating metacharacters). It also considers length constraints in allocations. The main principles of strict pattern validation directly apply to this glob implementation.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      },
      {
        "score": 8,
        "reasoning": "The code maintains consistent state during filesystem path expansion by carefully managing directory and filename separation, recursive glob calls, and appending results to the `glob_t` structure. It handles state transitions (like `dirname_modified`) and ensures cleanup on error paths. The specification's focus on consistent state during expansion operations is strongly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem path processing must maintain consistent state during expansion operations"
      },
      {
        "score": 7,
        "reasoning": "Memory release operations are performed with `free()` calls conditional on ownership flags (`malloc_dirname`, `alloca_onealt`, `malloc_home_dir`). The code tracks ownership to avoid double-free and ensure proper cleanup. However, the ownership semantics are not always strictly enforced in all error paths (e.g., early returns might miss some frees). Moderate relevance as the principle applies but implementation has some complexity.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "This specification about file content processing and empty files is very low relevance. The target code is a pathname pattern expansion function (glob), not a file content processor. It deals with directory listings and pattern matching, not reading or processing the contents of files.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 8,
        "reasoning": "The code demonstrates careful resource cleanup across execution paths: it uses `goto out` and `goto no_matches` to centralize cleanup, frees allocated memory in error conditions, and calls `globfree()` on temporary structures. It maintains consistent state by resetting `pglob->gl_pathc` and `pglob->gl_pathv` on errors. Strong relevance as resource cleanup is a key aspect of this function's error handling.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "This specification about XML parsers and external entity processing is completely irrelevant to the target C code, which is a filesystem globbing function with no XML processing capabilities.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "This specification about document processing and entity resolution boundaries is completely irrelevant. The code performs filesystem pattern matching, not document processing of any kind.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2017-15670_after_subset_100:db73f18e:spec": {
    "timestamp": "2026-01-17T03:31:29.611507",
    "cve_id": "CVE-2017-15670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "db73f18e",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs numerous buffer operations with length calculations, including using mempcpy, strdup, realloc, and manual memory allocation based on pattern lengths. It validates size calculations (e.g., checking pglob->gl_offs against overflow) and uses alloca/malloc based on computed lengths. However, not all buffer writes are explicitly validated against allocated size after dynamic string construction.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 10,
        "reasoning": "Directly relevant. The entire function implements pathname expansion (globbing) with pattern syntax validation. It processes braces {}, tilde ~, escapes, and metacharacters, validating pattern syntax (e.g., detecting illegal brace expressions) and enforcing length constraints through allocation checks. This is the core functionality of the code.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code maintains consistent state during filesystem path expansion operations, particularly when handling recursive glob calls, directory separators, and tilde expansion. It carefully manages the glob_t structure state (gl_pathc, gl_pathv) across multiple expansion phases and error conditions.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem path processing must maintain consistent state during expansion operations"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code has complex memory ownership semantics with multiple allocation sources (alloca, malloc) and conditional freeing based on malloc_dirname, malloc_home_dir, alloca_onealt flags. It must maintain strict ownership to avoid double-free or leaks across all execution paths.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes filesystem patterns and directory listings, not file content. While it handles empty patterns (pattern[0] == '\\0'), this is pattern processing, not file content processing. The specification about file content edge cases doesn't apply.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function has numerous execution paths with early returns on errors. It must ensure proper resource cleanup (freeing dirname, globfree(&dirs), freeing pglob->gl_pathv) across all paths. The code shows careful cleanup with goto out labels and conditional freeing.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "No relevance. The code implements filesystem globbing, not XML parsing. There are no XML parsers or external entity processing concerns in this C glob implementation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "No relevance. The code deals with filesystem path expansion, not document processing or entity resolution. This specification about document processing boundaries doesn't apply to glob pattern matching.",
        "spec_index": 7,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      }
    ]
  },
  "CVE-2021-3521_before_subset_100:3cc580b2:spec": {
    "timestamp": "2026-01-17T03:31:40.107737",
    "cve_id": "CVE-2021-3521",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3cc580b2",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves memory management through `pgpDigParamsNew` and `pgpDigParamsFree`. The ownership of the `digp` structure is clearly defined: it is allocated inside the function and its release is conditional on the success (`rc == 0`) and whether a caller wants the result (`ret`). This demonstrates strict ownership semantics, making the specification highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes input data (`pkts`, `pktlen`), but it's not file content. It handles the boundary condition of an empty or malformed packet stream via the `while (p < pend)` loop and the `decodePkt` check. However, the specification is specifically about \"File content processing,\" which is a weaker connection to this buffer parsing code.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The function has multiple execution paths (successful parse, break due to decode error, break due to tag mismatch, break due to `pgpPrtPkt` error). It must ensure the `digp` resource is cleaned up (`pgpDigParamsFree`) on failure paths and not cleaned up (but transferred) on the success path. The final conditional block handles this state consistency across all paths.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 3,
        "reasoning": "The code deals with a single allocated structure (`pgpDigParams`). There is no indication of linked lists, trees, or other structures with explicit neighbor relationships that need to be maintained during deallocation. Therefore, this specification has very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification refers to establishing a \"complete isolation state\" during cleanup, which typically involves more complex scenarios like wiping memory, closing network connections, or terminating processes. This function's cleanup is limited to freeing a single memory structure, which does not align with the concept of \"isolation state.\" Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "The code is parsing PGP (Pretty Good Privacy) packet data, not XML. The specification is exclusively for XML parsers and therefore does not apply to this code scenario at all.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec_6, this specification is about document processing (likely XML/HTML entity resolution). The target code processes binary PGP packets and does not involve entity resolution. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code is a low-level parsing function. It does not implement security-sensitive features (like encryption, signature verification logic, or network access) that would need to be gated behind configuration options. Its operation is dictated by its input parameters. The specification has very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2021-3521_after_subset_100:8520f694:spec": {
    "timestamp": "2026-01-17T03:32:10.560401",
    "cve_id": "CVE-2021-3521",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8520f694",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code involves dynamic memory allocation (xmalloc/xrealloc) and deallocation (free, pgpDigParamsFree). Specification HS-MEM-003 about memory release operations maintaining strict ownership semantics is highly relevant. The code shows ownership transfer (digp assigned to *ret) and cleanup in different branches, which must be managed correctly to avoid double-free or leaks. However, the specification's title mentions \"Linked structure deallocation\" which is less directly applicable than its core principle.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes binary packet data (pkts, pktlen). Specification HS-INPUT-004 about handling all edge cases in file/content processing has weak relevance. The code does handle some boundary conditions (p < pend, decodePkt failures), but it's not specifically about file processing, and the specification's focus on \"empty files\" is not a direct match for this binary packet parsing scenario.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code has multiple execution paths (break conditions, success/failure returns) and must ensure proper resource cleanup (free(all), pgpDigParamsFree(digp)) in all paths. The current implementation shows cleanup in both success and failure branches, directly addressing the need for consistent state maintenance across execution paths as specified in HS-STATE-002.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the code uses dynamic memory allocation, it does not involve linked structures or neighbor relationships. The all array is a simple dynamically allocated array, not a linked list or graph structure. The specification specifically mentions \"linked structure deallocation\" and \"neighbor relationships,\" which don't apply here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs resource cleanup (free(all), pgpDigParamsFree) which relates to establishing isolation state. However, the specification HS-STATE-004 about \"complete isolation state\" suggests more comprehensive isolation than what's shown here (like zeroing memory or more thorough cleanup). The current cleanup is basic memory deallocation.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "Basically doesn't apply. The code is parsing PGP packet structures, not XML. Specification HS-INPUT-001 specifically addresses XML parsers and external entity processing, which has no connection to this binary packet parsing code.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Basically doesn't apply. Similar to spec 6, this specification about document processing and entity resolution boundaries is specific to document formats (likely XML/HTML), not binary PGP packet parsing. No document entities are involved in this code.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code doesn't implement security-sensitive features that require gating behind configuration options. It's a PGP packet parsing function with fixed behavior. While parsing untrusted data is security-sensitive, the specification specifically addresses features that should be configurable, which doesn't match this code's structure.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2016-8670_before_subset_100:410c52ac:spec": {
    "timestamp": "2026-01-17T03:32:50.966712",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "410c52ac",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs memory operations (array element copying, expansion, and deletion) but does not explicitly involve memory release or ownership transfer. The principle of maintaining consistent state during memory manipulation is relevant, but not a direct match for \"strict ownership semantics\" typically associated with allocation/deallocation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code implements an array splice operation and does not process file content. There is no handling of files, empty or otherwise.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code must maintain consistent array state across multiple execution paths (fast vs. slow array, different delta values). It performs cleanup (deleting elements) and state updates (length adjustment) while ensuring error handling returns early to prevent inconsistent states.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code manipulates array elements but does not involve linked list or graph structures where neighbor relationships need preservation during deallocation.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform resource cleanup that requires establishing isolation (like closing network connections or wiping memory). It modifies array contents in-place.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code performs critical buffer operations (memcpy, array expansion, index calculations) and validates length calculations (e.g., checking length + delta against NJS_MAX_LENGTH, bounds checking for start/delete). It ensures operations stay within allocated array bounds.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The code does not process pathnames or perform pattern expansion. It is purely an array manipulation function.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve filesystem path processing or expansion operations. It operates only on in-memory array data structures.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Filesystem path processing must maintain consistent state during expansion operations"
      }
    ]
  },
  "CVE-2016-8670_after_subset_100:f7f8fa13:spec": {
    "timestamp": "2026-01-17T03:33:06.271688",
    "cve_id": "CVE-2016-8670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f7f8fa13",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs memory operations (array expansion, copying) but does not explicitly release memory. The specification about memory release ownership is only moderately relevant as the focus is on array manipulation and reallocation, not explicit deallocation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes array splice operations, not file content. There is no file I/O or handling of file data, making this specification basically inapplicable.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple execution paths with early error returns. It must ensure the array object remains in a consistent state when errors occur (e.g., during property access or array expansion). The code checks return values and propagates errors, which relates to maintaining state consistency.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code manipulates array elements but does not involve linked list or graph structures with explicit neighbor pointers. The array is a contiguous or indexed structure, so linked structure deallocation semantics are not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns establishing isolation during resource cleanup. This code does not perform cleanup of external resources (files, sockets, etc.) and does not require isolation states, making it weakly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "The code performs buffer-like operations on array memory: calculates new length (length + delta), validates against NJS_MAX_LENGTH, and uses memcpy for fast arrays. It must ensure length calculations do not cause overflow or out-of-bounds access, which aligns with buffer length validation principles.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer operations must validate length calculations against allocated size"
      },
      {
        "score": 5,
        "reasoning": "The code does not process pathnames or perform pattern expansion. It is purely an array manipulation function, so this specification is irrelevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Pathname expansion must strictly validate pattern syntax and length constraints"
      },
      {
        "score": 5,
        "reasoning": "No filesystem path processing occurs in this code. The function operates only on JavaScript array objects and values, making this specification inapplicable.",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Filesystem path processing must maintain consistent state during expansion operations"
      }
    ]
  },
  "CVE-2022-27376_before_subset_100:74df93de:spec": {
    "timestamp": "2026-01-17T03:33:23.464563",
    "cve_id": "CVE-2022-27376",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "74df93de",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves memory management (allocating TABLE objects with my_malloc, releasing shares with tdc_release_share). While it doesn't explicitly transfer ownership in complex ways, the principle of maintaining strict ownership semantics is relevant to ensuring resources are properly released to the correct owner (e.g., share references, table objects added to caches). However, the code is more focused on table opening logic than pure memory ownership patterns.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "The code deals with opening database tables, not file content processing. There is no handling of file reads, parsing file contents, or edge cases like empty files. The specification is about file I/O, while this code is about database table metadata and handle management.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error paths and cleanup requirements (goto err_lock, various DBUG_RETURN points). It must ensure proper resource cleanup (share references, table objects, MDL locks) across all execution paths to avoid leaks and inconsistent state. The code shows patterns like releasing shares before returning errors.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "No relevance. The code does not involve XML parsing or any XML processing. It is a database table opening function in MySQL/MariaDB.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "No relevance. The specification concerns document processing and entity resolution, which doesn't apply to database table opening routines.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses flags (MYSQL_OPEN_IGNORE_FLUSH, MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK, etc.) to gate certain behaviors, which aligns with the principle of controlling sensitive operations via configuration/options. However, these are runtime flags rather than persistent security configurations.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "Relevant. The code frees memory (my_free(table)) and releases shares (tdc_release_share). While ownership verification isn't explicit, the logic ensures resources are only freed by the appropriate owner (e.g., table freed only after allocation failure, shares released when no longer needed). The context of table cache management implies ownership considerations.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory release operations must verify allocation ownership before freeing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code processes input (table names, flags) but doesn't involve dynamic growth of input buffers. It primarily validates and uses existing structures. The state consistency during input processing is somewhat relevant to error handling but not a primary focus.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must maintain consistent state during dynamic growth"
      }
    ]
  },
  "CVE-2022-27376_after_subset_100:dc71ee81:spec": {
    "timestamp": "2026-01-17T03:33:34.491269",
    "cve_id": "CVE-2022-27376",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dc71ee81",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code involves memory management (allocating TABLE objects with my_malloc, releasing shares with tdc_release_share). While it doesn't explicitly transfer ownership in complex ways, the pattern of acquiring/releasing shares and tables requires careful ownership tracking to avoid double-free or leaks, especially across error paths. The principle of maintaining strict ownership semantics is moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "This specification is about file content processing edge cases (like empty files). The target code is opening database tables, not processing generic file contents. While it reads .frm files, the specification's focus on \"all edge cases including empty files\" is not directly applicable to this table opening logic.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error paths and cleanup points (goto err_lock, various DBUG_RETURN points). It must ensure proper resource cleanup (table shares, TABLE objects, MDL locks) across all execution paths to avoid leaks and maintain consistent state. The code shows patterns like releasing shares on error.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "This specification is specifically about XML parsers disabling external entity processing. The target code does not involve XML parsing at all; it's opening database tables in MySQL. No relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 1,
        "reasoning": "This specification is about document processing and entity resolution boundaries, likely referring to XML/SGML/HTML. The target code is for database table operations, not document processing. No relevance.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code has various flags (MYSQL_OPEN_IGNORE_FLUSH, MYSQL_OPEN_IGNORE_REPAIR) that control behavior, these are more about operational modes than security-sensitive features. The specification about gating security features behind explicit configuration doesn't directly apply to this low-level table opening function.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code allocates memory with my_malloc and frees with my_free. While there's no explicit ownership verification shown, the pattern requires that free operations only happen on properly owned memory. The error handling paths must ensure only allocated resources are freed. The principle applies but isn't the main focus.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory release operations must verify allocation ownership before freeing"
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The specification is about input processing during dynamic growth. While this function processes table opening requests (a form of input), it doesn't involve dynamic data structures that grow during processing. The main state management is about resources (tables, locks) rather than input buffers. The principle of maintaining consistent state during processing has some applicability.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input processing must maintain consistent state during dynamic growth"
      }
    ]
  },
  "CVE-2022-29208_before_subset_100:2684f15c:spec": {
    "timestamp": "2026-01-17T03:33:53.323583",
    "cve_id": "CVE-2022-29208",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2684f15c",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not explicitly perform memory release operations. It allocates an output tensor via `ctx->allocate_output`, but TensorFlow's runtime manages the lifecycle of tensors. There is no manual memory management (like `new`/`delete` or `malloc`/`free`) where strict ownership semantics would be critical. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code processes sparse tensor inputs, not file contents. While it handles edge cases like empty sequences (e.g., \"zero-length truth\"), the specification is specifically about file processing. The connection is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The code does not explicitly manage resources like file handles or network connections that require cleanup. It operates on tensors provided by the TensorFlow framework, which handles resource lifecycle. There are no complex execution paths with manual resource cleanup. Relevance is weak.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code validates tensor shapes (e.g., via `ValidateShapes` and checks that `output_elements > 0`), which is analogous to validating claimed dimensions. However, it is not processing image files or raw file data. The principle of dimension validation applies, but the context is different.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, the code performs dimension checking (e.g., shape validation, output buffer bounds checks via `OP_REQUIRES` on `loc < output_elements`) before writing to memory. This aligns with the safe dimension checking principle, but the code is not a file format reader.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "The code validates input tensor shapes and values (via `ValidateShapes` and bounds checks). This aligns with the general principle of validating attribute/input values before processing. However, the specification is specifically about IPP (Internet Printing Protocol) attributes, which do not apply here.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 5,
        "reasoning": "The code does not process printer configuration files or any external configuration files. It computes Levenshtein distance on sparse tensors. The specification is completely unrelated.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not implement or parse the IPP protocol. It is a TensorFlow op kernel for tensor computation. The specification is irrelevant.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      }
    ]
  },
  "CVE-2017-15670_after_subset_100:1c67d758:spec": {
    "timestamp": "2026-01-17T03:34:34.030418",
    "cve_id": "CVE-2017-15670",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1c67d758",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not contain explicit memory allocation or release operations (like new/delete, malloc/free). Memory management is handled by TensorFlow's Tensor objects and OP_REQUIRES_OK mechanisms, which manage their own lifecycle. There is no manual memory management to which strict ownership semantics would directly apply.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 3,
        "reasoning": "The code processes tensor data from an op kernel context, not file content. While it validates input shapes and handles edge cases like zero elements, the core context of file processing (empty files, file I/O) is not present.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 4,
        "reasoning": "The code does not explicitly acquire or release external resources (like file handles, network connections). It operates on input tensors and allocates an output tensor via the framework. There is no manual resource cleanup logic that could lead to inconsistent state across different execution paths (like early returns). Error handling uses OP_REQUIRES which aborts execution.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "While not processing images, the code performs a similar core security activity: validating claimed dimensions against actual data size. It validates input tensor shapes (via ValidateShapes) and checks that derived output shapes have positive elements. This aligns with the principle of validating metadata before use, though the domain is tensor data, not image files.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, the code performs safe dimension checking before memory allocation. It validates input shapes, computes an output shape, checks that its number of elements is >0, and only then allocates the output tensor. This follows the principle of the specification but applies to tensor processing rather than file format reading.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 6,
        "reasoning": "The code validates multiple input attributes (tensor shapes, indices, values) before processing them, using OP_REQUIRES and ValidateShapes. This aligns with the general principle of validating all input attribute values. However, the specification is specifically about IPP (Internet Printing Protocol) attributes, which is not the context here.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "The code does not process printer configuration files or any configuration files. It computes a distance metric (Levenshtein) between sparse tensor sequences. There is no sanitization logic relevant to this specification.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not implement or parse the IPP protocol. It is a TensorFlow op kernel that processes tensors. The specification is completely unrelated to the code's functionality.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      }
    ]
  },
  "CVE-2017-18257_before_subset_100:8af68de7:spec": {
    "timestamp": "2026-01-17T03:34:59.884901",
    "cve_id": "CVE-2017-18257",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8af68de7",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs a memory release operation (gs_free_object). Specification HS-MEM-003 about maintaining strict ownership semantics is strongly relevant. The function manages a circular buffer and frees it when empty, which touches on ownership and lifecycle management. However, the specification's full implications (like clear ownership transfer) are not fully visible in this isolated snippet.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "Specification HS-INPUT-004 deals with file content processing and edge cases for empty files. The target code is reading from an internal status buffer, not processing external file content. The connection is very low.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Specification HS-STATE-002 on resource cleanup maintaining consistent state is highly relevant. The function cleans up (frees) the status buffer when read_pos equals write_pos (buffer empty) and resets both indices to zero. This is a clear example of state consistency during cleanup. The single execution path simplifies the analysis.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-INPUT-001 is about validating IPP attribute values. The target code handles an internal PCL status buffer and has no relation to the IPP protocol or its attributes. It is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-SEC-002 concerns sanitizing printer configuration files. The code operates on a memory buffer for PCL status, not on configuration files. It is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "Specification HS-PROTOCOL-003 is for IPP protocol message parsing. The function is named pcl_status_read, indicating it's part of PCL handling, not IPP. It is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-001 is directly and highly relevant. The function performs a buffer operation (memcpy) and uses min() to calculate the 'count' of bytes to copy, ensuring it does not exceed the source buffer's available data (write_pos - read_pos). This is a critical length validation against the logical source buffer size, preventing over-read. It also respects the destination buffer size 'max_data' via the same min() operation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 has moderate relevance. The parameters 'data' and 'max_data' are likely external inputs to this function. The code validates 'max_data' against the internal buffer's available data using min(), which is a form of input validation before the buffer operation (memcpy). However, the specification broadly covers external input, and the validation here is specifically for length, which is already strongly covered by HS-MEM-001.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      }
    ]
  },
  "CVE-2017-18257_after_subset_100:4d2a47fa:spec": {
    "timestamp": "2026-01-17T03:35:08.231291",
    "cve_id": "CVE-2017-18257",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4d2a47fa",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory release via gs_free_object. While it correctly sets the buffer pointer to NULL after freeing (good ownership practice), the specification about maintaining strict ownership semantics is highly relevant. The function manages a shared status buffer, and ownership/cleanup logic is central to its operation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code processes an internal memory buffer, not file content. There is no file I/O or handling of empty files in this function.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function performs resource cleanup (freeing buffer) and must maintain consistent state (resetting read_pos, write_pos, and buffer pointer) across all execution paths. The current logic appears consistent, making this specification directly applicable.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not process IPP (Internet Printing Protocol) attribute values. It handles internal buffer status reading.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All IPP attribute values must be validated before being processed"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-SEC-002: Printer configuration files must be sanitized before processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is not implementing IPP protocol message parsing. It is a simple buffer read function.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: IPP protocol implementations must enforce strict message parsing"
      },
      {
        "score": 10,
        "reasoning": "Highly relevant and directly applicable. The function performs buffer operations (memcpy) and must validate length parameters. It uses min() to ensure count does not exceed max_data and also respects the buffer's valid range (write_pos - read_pos). This is a core secure coding practice for this code.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: All buffer operations must validate length parameters against destination buffer size"
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The function parameters 'data' and 'max_data' are external inputs from the caller. While the function validates 'max_data' against internal state via min(), it doesn't explicitly validate that 'data' points to a buffer of at least 'max_data' size. The principle of validating external input before buffer operations applies, though the primary validation is for the source buffer size, not the destination.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: External input must be validated before buffer operations"
      }
    ]
  },
  "CVE-2016-7514_before_subset_100:1f5082c8:spec": {
    "timestamp": "2026-01-17T03:35:31.755145",
    "cve_id": "CVE-2016-7514",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1f5082c8",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates image dimensions against file size: `if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image)) ThrowReaderException(...);`. This directly implements dimension validation against actual data size, though the division by 8 might be oversimplified for bit-depth calculation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 8,
        "reasoning": "The code performs dimension checking before memory allocation: the dimension validation occurs before `SetImageExtent` which allocates memory. However, the check uses division by 8 which might not accurately reflect required memory for all bit depths.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 5,
        "reasoning": "Resource acquisition (image, quantum_info) is generally paired with release (DestroyImageList, DestroyQuantumInfo). However, some early return paths (like after `OpenBlob` failure) properly clean up, but not all execution paths are explicitly shown to guarantee release.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-002: Resource acquisition must be paired with guaranteed release in all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The code uses ThrowReaderException for parse failures which appears to propagate errors. Resource cleanup happens in some paths (DestroyImageList), but the exception handling mechanism's guarantee of cleanup isn't fully visible in this snippet.",
        "spec_index": 3,
        "spec_preview": "HS-IO-003: File format processors must ensure resource cleanup during parse failures"
      },
      {
        "score": 5,
        "reasoning": "The parsing loop for reading pixel data maintains consistent state with progress reporting and break conditions. However, the loop could potentially leave resources in inconsistent state if breaks occur mid-processing.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Complex parsing loops must maintain consistent resource state"
      },
      {
        "score": 5,
        "reasoning": "The code uses CopyMagickString which should handle buffer sizes, but direct buffer operations like `ReadBlob(image,sizeof(cin.file.version),(unsigned char *) cin.file.version)` assume sizeof matches buffer size without explicit validation of the read count against buffer size.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 5,
        "reasoning": "The code validates `cin.file.user_length > GetBlobSize(image)` before allocation, enforcing non-negative length constraints. Also checks `count != 4` for magic number validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "The dimension calculation `image->columns*image->rows/8` uses MagickSizeType which is a large type, but the division by 8 could cause truncation issues. The multiplication could still overflow before division, though MagickSizeType helps mitigate this.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2016-7514_after_subset_100:f7101349:spec": {
    "timestamp": "2026-01-17T03:35:46.193137",
    "cve_id": "CVE-2016-7514",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f7101349",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates image dimensions against file size: `if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image)) ThrowReaderException(...)`. This directly implements HS-INPUT-001 by checking claimed dimensions (columns * rows) against the actual file data size before processing pixel data.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image parsers must validate claimed dimensions against actual file data size"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs dimension validation before significant memory allocation. The check `if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))` occurs before `SetImageExtent` which likely allocates memory. This aligns with HS-IO-002's principle of safe dimension checking before allocation.",
        "spec_index": 1,
        "spec_preview": "HS-IO-002: File format readers must implement safe dimension checking before memory allocation"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code shows proper resource acquisition and release patterns: `image=AcquireImage`, `quantum_info=AcquireQuantumInfo`, and corresponding `DestroyImageList`/`DestroyQuantumInfo` calls in error paths. However, not all execution paths are explicitly shown for every resource (e.g., `profile` handling is good).",
        "spec_index": 2,
        "spec_preview": "HS-MEM-002: Resource acquisition must be paired with guaranteed release in all execution paths"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code implements cleanup during parse failures through multiple `ThrowReaderException` calls which likely trigger error handling, and explicit cleanup like `image=DestroyImageList(image)` in early error paths. The pattern of `DestroyQuantumInfo` and `DestroyStringInfo` shows resource cleanup awareness.",
        "spec_index": 3,
        "spec_preview": "HS-IO-003: File format processors must ensure resource cleanup during parse failures"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The parsing loop `for (y=0; y < (ssize_t) image->rows; y++)` maintains consistent resource state with proper pixel queueing and syncing. However, the loop is relatively simple and doesn't involve complex nested parsing that would heavily test state consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-004: Complex parsing loops must maintain consistent resource state"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code uses `CopyMagickString` which internally handles buffer bounds, but direct buffer size validation against signedness constraints isn't prominently visible. Most copying uses `sizeof()` for source bounds, but signed/unsigned comparisons for length parameters aren't explicitly shown.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Buffer copy operations must validate size parameters against signedness constraints"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code enforces some length constraints: `if (cin.file.user_length > GetBlobSize(image))` prevents reading beyond file bounds. However, other length fields like `cin.file.image_offset` are used in comparisons without explicit non-negativity checks, though they're compared against constants.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-002: Input processing must enforce non-negative length constraints for memory operations"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The dimension calculation `(MagickSizeType) image->columns*image->rows/8` uses `MagickSizeType` (likely a large unsigned type) for overflow protection, showing some awareness. However, other arithmetic operations (like offset calculations) don't explicitly show overflow protection, and the `/8` operation could lose precision.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-003: Arithmetic operations must include overflow/underflow protection when used for memory ..."
      }
    ]
  },
  "CVE-2013-2124_before_subset_100:0dd5649d:spec": {
    "timestamp": "2026-01-17T03:36:22.098030",
    "cve_id": "CVE-2013-2124",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0dd5649d",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification concerns linked structure deallocation and neighbor relationships. The target code deletes individual objects but does not show traversal or modification of a linked data structure where neighbor pointers need updating. The relationship between `mixer` and `player` is a simple ownership/association, not a linked list or graph requiring neighbor consistency during deallocation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 8,
        "reasoning": "The specification requires resource cleanup to establish complete isolation state. The destructor attempts to clean up multiple resources (mixer, player, audioDriverName, listener) and includes logic to conditionally call `mixer->removeDevice(player)` before deletion. However, there is a critical flaw: it accesses `mixer->isActive()` after potentially deleting `mixer` (if `mixer` is non-null, it is deleted at the start). This creates a use-after-free, violating the isolation state principle. The relevance is strong because the code's purpose is cleanup but fails to achieve safe isolation.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 9,
        "reasoning": "The specification requires memory release operations to maintain strict ownership semantics. The destructor manages ownership of several dynamically allocated objects (mixer, player, audioDriverName, listener). The clear bug is that `mixer` is deleted early, then later dereferenced (`mixer->isActive()`) when checking conditions for player cleanup. This violates ownership semanticsaccessing a pointer after its owned memory is released. The specification directly applies to this scenario.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns file content processing and handling edge cases like empty files. The target code is a destructor managing memory and object cleanup, with no file I/O operations. There is no relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "The specification requires resource cleanup to maintain consistent state across all execution paths. The destructor has a logical error: if `mixer` is non-null, it is deleted immediately, but then the code proceeds to a block where `player` is non-null and uses `mixer->isActive()` (dereferencing freed memory). This leads to undefined behavior, breaking state consistency. The specification is highly relevant as it addresses cleanup path correctness.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns XML parsers and disabling external entity processing. The target code is a C++ destructor with no XML parsing or document processing. No relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns document processing and entity resolution boundaries. The code does not involve document processing, XML, or entities. No relevance.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns gating security-sensitive features behind explicit configuration options. The target code is a destructor performing resource cleanup, not enabling or disabling security-sensitive functionalities. There is a very weak connectionif `mixer` or `player` involved security-sensitive operations, their cleanup might be relevant, but the code itself doesn't show such configuration gating.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2013-2124_after_subset_100:02d9665f:spec": {
    "timestamp": "2026-01-17T03:36:43.283938",
    "cve_id": "CVE-2013-2124",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "02d9665f",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code shows deletion of objects but does not clearly involve linked structures with neighbor relationships that need to be maintained during deallocation. The mixer and player objects appear to have some relationship (mixer can remove device player), but this is more about resource cleanup than maintaining linked list consistency.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Linked structure deallocation must maintain consistent neighbor relationships"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant as this is a destructor performing resource cleanup. The code attempts to establish isolation by removing the player from the mixer before deletion and cleaning up multiple resources (player, mixer, audioDriverName, listener). However, the order and conditions may not guarantee complete isolation.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-004: Resource cleanup operations must establish complete isolation state"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The destructor demonstrates ownership semantics through delete operations. The conditional checks before deleting player (checking mixer state) show awareness of ownership relationships. The code maintains strict ownership by ensuring proper cleanup sequence.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is a destructor for a PlayerGeneric class handling audio resources, not file content processing. No file operations are present in this code snippet.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a destructor that must maintain consistent state across all execution paths. The code shows conditional logic (if statements) that could affect state consistency. The order of cleanup operations is critical for maintaining consistent state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code involves audio device and mixer management, not XML parsing. No XML-related operations are present in this destructor.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: XML parsers must explicitly disable external entity processing by default"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification relates to document processing and entity resolution, which has no connection to this audio player destructor code.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-002: Document processing must enforce strict entity resolution boundaries"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the code manages resources, it doesn't involve security-sensitive features that need explicit configuration gating. This is standard resource cleanup in a destructor.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-003: Security-sensitive features must be gated behind explicit configuration options"
      }
    ]
  },
  "CVE-2017-14106_before_subset_100:de00fd23:spec": {
    "timestamp": "2026-01-17T03:36:53.554674",
    "cve_id": "CVE-2017-14106",
    "code_type": "before",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "de00fd23",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code demonstrates strict ownership semantics through careful use of `g_steal_pointer`, `g_clear_pointer`, `g_clear_error`, and `connection_attempt_unref`. Ownership of objects like `attempt->socket` and `attempt->connection` is explicitly transferred, and resources are cleaned up on various execution paths (success, error, cancellation). This aligns well with HS-MEM-003's principle of maintaining clear ownership to prevent memory issues.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification HS-INPUT-004 is about processing file contents and handling edge cases like empty files. The target code deals with network socket connections, proxy negotiation, and asynchronous callbacks. There is no file I/O or file content processing involved, making this specification essentially irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The code meticulously manages resource cleanup (sockets, connections, tasks, timeout sources, error objects, attempt lists) across multiple execution paths: successful connection, connection errors, and task cancellation. Functions like `connection_attempt_unref`, `g_clear_pointer`, and `g_slist_free` are called in all branches to ensure state consistency and prevent leaks, which is the core of HS-STATE-002.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 5,
        "reasoning": "The specification title \"HS-MEM-003\" is a duplicate of spec 1, but its description \"Network feature declarations must precisely match implementation capabilities\" suggests a different intent. The code does involve network features (proxies, protocols) and has a guard clause checking if a connection is TCP before proxying, which loosely relates to capability matching. However, this is a minor aspect compared to the code's primary focus on connection flow and resource management. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-002 concerns packet processing and validating fragment counts against buffers. The target code operates at a much higher abstraction level (GLib's GSocketClient), handling connection establishment, callbacks, and proxy setup. There is no low-level packet or buffer manipulation visible, making this specification not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 5,
        "reasoning": "The code has moderate relevance to HS-SEC-004. It performs a form of capability verification during proxy setup: it checks if a proxy protocol is supported by the application (`g_hash_table_contains`) or by the system (`g_proxy_get_default_for_protocol`). If not supported, it sets an appropriate error. This aligns with the principle of verifying capabilities before proceeding with a feature (proxy negotiation). However, it's not a comprehensive security negotiation protocol.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-001 deals with kernel-level DMA operations and VMAP_STACK, which are concerns specific to kernel or very low-level system programming. The target code is user-space application code using the GLib library. There is no DMA or stack mapping involved, so this specification does not apply.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-IO-002 (second instance) is about USB control message handlers and buffer allocation validation. The target code is for network sockets, not USB devices. The concepts of buffer allocation for transfers and validation, while generally good practice, are not directly visible or applicable in this high-level network connection callback context.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      }
    ]
  },
  "CVE-2017-14106_after_subset_100:a842ab8c:spec": {
    "timestamp": "2026-01-17T03:37:23.547541",
    "cve_id": "CVE-2017-14106",
    "code_type": "after",
    "data_source": "subset_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a842ab8c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code demonstrates strict ownership semantics for memory and object references. It uses `g_steal_pointer` to transfer ownership, `g_clear_pointer` and `g_clear_error` for safe cleanup, and `connection_attempt_unref` for reference counting. This aligns with the core principle of HS-MEM-003, though the specification's title mentions \"memory release,\" its principle of maintaining clear ownership is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 1,
        "reasoning": "The specification is about processing file contents and handling edge cases like empty files. The target code deals with network socket connections, proxy negotiation, and asynchronous callbacks. There is no file I/O or file content processing involved, making this specification irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-STATE-002: Resource cleanup must maintain consistent state across all execution paths"
      },
      {
        "score": 1,
        "reasoning": "The specification title \"HS-MEM-003\" is a duplicate of spec 1 and its description (\"Network feature declarations...\") is mismatched. Assuming the description is correct, the code does not declare network features; it uses them. The check `if (!G_IS_TCP_CONNECTION (data->connection))` is a runtime safety guard, not a declaration-capability matching issue. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Network feature declarations must precisely match implementation capabilities"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns packet processing and validating fragment counts against buffers. This code operates at a higher abstraction level (socket connections, proxy setup, TLS handshakes) and does not involve low-level packet fragmentation or buffer pre-allocation for fragments.",
        "spec_index": 4,
        "spec_preview": "HS-IO-002: Packet processing must validate fragment counts against pre-allocated buffer space"
      },
      {
        "score": 5,
        "reasoning": "The code has moderate relevance. It performs a form of feature negotiation during proxy setup. It checks if a proxy protocol is supported (`g_hash_table_contains` for app proxies, `g_proxy_get_default_for_protocol` for system proxies). If not supported, it sets an error. This aligns with the principle of capability verification, though it's not a complex multi-feature negotiation.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-004: Feature negotiation must include capability verification"
      },
      {
        "score": 5,
        "reasoning": "The specification is about DMA operations and VMAP_STACK, which are low-level kernel or driver development concepts. This is user-space GLib application code handling socket connections. There is no DMA or kernel stack mapping involved.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: DMA operations must use heap-allocated buffers when VMAP_STACK is enabled"
      },
      {
        "score": 5,
        "reasoning": "The specification is specific to USB control message handlers. This code is for network sockets (TCP/IP, proxies, TLS). The domains are completely different, and the code does not handle USB operations or validate USB buffer allocations.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: USB control message handlers must validate buffer allocation success before transfer"
      }
    ]
  },
  "CVE-2022-23645_after_exclude_100:a71eba38:spec": {
    "timestamp": "2026-01-20T10:06:01.889458",
    "cve_id": "CVE-2022-23645",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a71eba38",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2019-18276_after_exclude_100:eb7952c7:spec": {
    "timestamp": "2026-01-20T10:06:02.145135",
    "cve_id": "CVE-2019-18276",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "eb7952c7",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2022-31796_after_exclude_100:e294828b:spec": {
    "timestamp": "2026-01-20T10:06:02.396758",
    "cve_id": "CVE-2022-31796",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e294828b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must validate against maximum safe values before memory a..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: External input must be validated before use in memory operations"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Memory allocation must be validated against calculated size requirements"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Image decoders must validate pixel allocation calculations against maximum supported dim..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Image decoders must validate all header values before memory allocation"
      }
    ]
  },
  "CVE-2021-37687_before_exclude_100:6a2f429c:spec": {
    "timestamp": "2026-01-20T10:06:02.677069",
    "cve_id": "CVE-2021-37687",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6a2f429c",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2021-37665_before_exclude_100:d93eea82:spec": {
    "timestamp": "2026-01-20T10:06:02.938475",
    "cve_id": "CVE-2021-37665",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d93eea82",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed-size buffers must account for maximum potential expansion during mathematical oper..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-002: Arithmetic operations affecting memory allocation must be bounded and validated"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: External parameters affecting memory operations must be sanitized"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2019-18276_before_exclude_100:905b4d53:spec": {
    "timestamp": "2026-01-20T10:06:03.190837",
    "cve_id": "CVE-2019-18276",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "905b4d53",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2021-37687_after_exclude_100:7bb5027c:spec": {
    "timestamp": "2026-01-20T10:06:03.423833",
    "cve_id": "CVE-2021-37687",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7bb5027c",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2022-23645_before_exclude_100:010b21f2:spec": {
    "timestamp": "2026-01-20T10:06:03.859839",
    "cve_id": "CVE-2022-23645",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "010b21f2",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-29694_after_exclude_100:d0483ac9:spec": {
    "timestamp": "2026-01-20T10:06:04.098445",
    "cve_id": "CVE-2022-29694",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d0483ac9",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      }
    ]
  },
  "CVE-2021-40571_before_exclude_100:c4a4e548:spec": {
    "timestamp": "2026-01-20T10:06:04.370808",
    "cve_id": "CVE-2021-40571",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c4a4e548",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: File format parsers must validate all size fields against remaining buffer space before ..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all extracted sizes against both declared and available ..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      }
    ]
  },
  "CVE-2022-29694_before_exclude_100:ab5ff0c7:spec": {
    "timestamp": "2026-01-20T10:06:04.648566",
    "cve_id": "CVE-2022-29694",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ab5ff0c7",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      }
    ]
  },
  "CVE-2018-16881_before_exclude_100:76d6414d:spec": {
    "timestamp": "2026-01-20T10:06:04.999938",
    "cve_id": "CVE-2018-16881",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "76d6414d",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2008-4934_after_exclude_100:42ea0279:spec": {
    "timestamp": "2026-01-20T10:06:05.277304",
    "cve_id": "CVE-2008-4934",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "42ea0279",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-003: Input processing must handle misaligned data safely"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      }
    ]
  },
  "CVE-2021-40571_after_exclude_100:529ec8c9:spec": {
    "timestamp": "2026-01-20T10:06:05.553207",
    "cve_id": "CVE-2021-40571",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "529ec8c9",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: File format parsers must validate all size fields against remaining buffer space before ..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all extracted sizes against both declared and available ..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      }
    ]
  },
  "CVE-2021-29552_after_exclude_100:605823e9:spec": {
    "timestamp": "2026-01-20T10:06:05.818199",
    "cve_id": "CVE-2021-29552",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "605823e9",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Array write operations must validate bounds against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Profile-specific parameter validation must enforce domain constraints"
      }
    ]
  },
  "CVE-2019-9923_before_exclude_100:5166b9ac:spec": {
    "timestamp": "2026-01-20T10:06:06.142142",
    "cve_id": "CVE-2019-9923",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5166b9ac",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2018-16881_after_exclude_100:e27f20a8:spec": {
    "timestamp": "2026-01-20T10:06:06.357551",
    "cve_id": "CVE-2018-16881",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e27f20a8",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2008-4934_before_exclude_100:ac6bfc52:spec": {
    "timestamp": "2026-01-20T10:06:06.634663",
    "cve_id": "CVE-2008-4934",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ac6bfc52",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-003: Input processing must handle misaligned data safely"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      }
    ]
  },
  "CVE-2022-37434_before_exclude_100:7e804c61:spec": {
    "timestamp": "2026-01-20T10:06:06.913129",
    "cve_id": "CVE-2022-37434",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7e804c61",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2022-37434_after_exclude_100:6cbc0133:spec": {
    "timestamp": "2026-01-20T10:06:07.218170",
    "cve_id": "CVE-2022-37434",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6cbc0133",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      }
    ]
  },
  "CVE-2019-9923_after_exclude_100:d7f7d56b:spec": {
    "timestamp": "2026-01-20T10:06:10.331760",
    "cve_id": "CVE-2019-9923",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d7f7d56b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-29194_after_exclude_100:b4e9ea0b:spec": {
    "timestamp": "2026-01-20T10:06:10.629601",
    "cve_id": "CVE-2022-29194",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b4e9ea0b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory buffers passed to string functions must guarantee NUL-termination"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Buffer allocation must maintain invariant of known-safe state"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Protocol parsers must validate buffer boundaries before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2022-36879_after_exclude_100:99a7709f:spec": {
    "timestamp": "2026-01-20T10:06:10.918118",
    "cve_id": "CVE-2022-36879",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "99a7709f",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2008-4933_after_exclude_100:0835b058:spec": {
    "timestamp": "2026-01-20T10:06:11.257854",
    "cve_id": "CVE-2008-4933",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0835b058",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2020-16302_after_exclude_100:f780a580:spec": {
    "timestamp": "2026-01-20T10:06:11.524155",
    "cve_id": "CVE-2020-16302",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f780a580",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2020-16302_before_exclude_100:875b9f0b:spec": {
    "timestamp": "2026-01-20T10:06:11.805273",
    "cve_id": "CVE-2020-16302",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "875b9f0b",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2008-4933_before_exclude_100:beca84f8:spec": {
    "timestamp": "2026-01-20T10:06:12.054633",
    "cve_id": "CVE-2008-4933",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "beca84f8",
    "scores": [
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Evaluation failed: API call failed: API Error: API call failed, retried 1 times",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-27382_after_exclude_100:850c669c:spec": {
    "timestamp": "2026-01-20T10:10:11.840539",
    "cve_id": "CVE-2022-27382",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "850c669c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It is focused on creating equality expressions for query optimization.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation or processing of escape sequences. It handles SQL item equality and cloning.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes items, it does not directly handle string operations on untrusted input. Its primary concern is building expression trees, not string manipulation with length safety.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs memory allocation via `new` and could potentially leave objects partially initialized if constructors fail or if error paths are taken. However, it doesn't show explicit raw buffer allocation.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The function has multiple error checks (e.g., for clone failures, allocation failures) and returns early. It must ensure that object states remain consistent when errors occur, especially when items are cloned and added to lists.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code does not handle network protocols or validate external input. It operates on internal SQL items within the query optimizer.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The code allocates memory via `thd->mem_root` but does not involve buffer padding or safety margins for operational data structures. It's more about object construction than buffer management.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not involve image compression, encoder buffers, or bounds checking for media operations. Completely unrelated domain.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2021-3559_after_exclude_100:f8fc56e6:spec": {
    "timestamp": "2026-01-20T10:10:13.734913",
    "cve_id": "CVE-2021-3559",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f8fc56e6",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages or validate length fields. It handles local device data structures and file system paths, not network or inter-process communication protocols.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code calls `virMediatedDeviceGetMdevTypes` which likely performs memory allocation. While this function isn't directly shown, proper validation of size parameters (like `ntypes`) before allocation is a security concern for the overall operation. The current code trusts the return values from that function.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a protocol. It performs local device management operations, handling internal data structures (`virMediatedDeviceTypePtr`), not serialized protocol data with type consistency requirements across stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not use regular expression parsers. The input is a filesystem path (`sysfspath`), not a regex pattern.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not contain pattern compilers or process escape sequences. It deals with mediated device types from the system.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The primary input is a filesystem path string (`sysfspath`). While using length-aware operations for this path would be good practice if it were untrusted, the code's main security focus is on memory management of the returned array of device types, not string processing.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code manages mediated (mdev) devices, not USB devices. It does not process USB requests or buffers.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not implement the USB/IP protocol or process network packets. Its scope is local device information retrieval.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2020-14361_after_exclude_100:0e2d8117:spec": {
    "timestamp": "2026-01-20T10:10:14.016277",
    "cve_id": "CVE-2020-14361",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0e2d8117",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the message length field (`client->req_len * 4`) against the size of the request structure (`SIZEOF(xkbSelectEventsReq)`) and subsequent data elements (`dataLeft < (size * 2)`). This directly relates to HS-INPUT-001's requirement to validate protocol message length fields, though the check is for internal consistency rather than explicit platform-specific integer limits.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not contain explicit memory allocation operations. It processes an existing request buffer from the client. While buffer bounds are checked, this is more about input validation than memory allocation size parameter validation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code performs type-consistent handling through byte-swapping operations (`swaps`, `swapl`) based on data size (2 or 4 bytes). It also validates data types through the switch statement for different notification types. This aligns with enforcing consistent type handling across processing stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing at all. It processes X11 protocol messages, not text patterns with embedded NUL bytes.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation or escape sequence processing. It handles X11 keyboard extension protocol messages.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes potentially untrusted input (client requests), it uses length-aware operations by tracking `dataLeft` and validating against required sizes. However, it's not specifically string processing but rather structured binary data processing.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform memory allocations. It operates on an existing request buffer provided by the client.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code includes error handling paths that return `BadValue` or `BadLength` when validation fails. However, it's unclear if it maintains consistent object states before returning errors, as the function primarily validates input before calling the main processing function.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-41201_before_exclude_100:7fee5302:spec": {
    "timestamp": "2026-01-20T10:10:16.186281",
    "cve_id": "CVE-2021-41201",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7fee5302",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs equation parsing for tensor operations (likely Einsum). It does not involve any cryptographic operations on secret values. The logic is focused on mapping labels and counting dimensions, not on secret-dependent branching or timing-sensitive data processing.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It is a utility function for parsing mathematical equation strings in a tensor computation context.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform cryptographic processing or secure memory operations that require constant-time properties. It manipulates standard containers (vectors, hash maps) for label mapping and counting.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "While the code parses an input string (equation), it is not a regular expression parser. It uses a custom parser (`ParseEinsumEquation`) for a specific mathematical notation. The handling of embedded NUL bytes is not addressed, but the relevance is weak because the specification targets regex parsers specifically.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It parses a tensor equation format where labels are typically single characters or ellipsis, not escape sequences.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes input strings (`equation`, `input_str`, `output_str`). While it uses string parameters, it relies on higher-level parsing functions. The specification about length-aware operations for untrusted input is moderately relevant because the function accepts an external string (`equation`), but the code itself does not show low-level string manipulation (e.g., using `strlen` or pointer arithmetic).",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code performs label counting and indexing but does not involve file position calculations or integer overflow concerns in the context of file operations. The integer types used (e.g., `int` for counts and indices) could potentially overflow with extremely large equations, but this is not the primary focus of the specification.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 5,
        "reasoning": "The code is not an archive parser and does not validate file positions against archive boundaries. It is purely a mathematical equation parsing function for tensor operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      }
    ]
  },
  "CVE-2022-36879_before_exclude_100:acde4279:spec": {
    "timestamp": "2026-01-20T10:10:16.610158",
    "cve_id": "CVE-2022-36879",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "acde4279",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform any cryptographic operations or use scatterlists. It deals with XFRM (IPsec) policy lookup and expansion, which is a networking/security policy layer, not direct cryptographic data manipulation.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 3,
        "reasoning": "The code does not implement cryptographic algorithms or handle cryptographic data. It manages policy structures and references, not cryptographic key material or cipher operations.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. This is kernel code that handles pointers to policy structures. While it doesn't directly allocate stack memory, it must be careful with pointer handling (like checking IS_ERR). VMAP_STACK implications about stack pointer usage could be relevant for any kernel function, but this code doesn't show obvious stack-specific issues.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not parse regular expressions or handle input patterns with NUL bytes. It processes XFRM policy structures from kernel internal lookups.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not compile patterns or process escape sequences. It's focused on network security policy management.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code doesn't directly process strings, it does handle arrays of policy pointers (pols) with a user-controlled count (*num_pols). It performs bounds checking (i < *num_pols) and validates pols[0] before use, which aligns with the spirit of length-aware operations for potentially untrusted input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function receives *num_pols which could originate from userspace (via XFRM policy system calls). It validates this value (checking if == 0) and uses it to bound loop iterations. However, it doesn't validate against maximum system constraints, only basic zero check.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code handles policy structures that could be considered protocol messages in a broad sense. It validates pols[0] is not an error pointer and checks action fields, which relates to structural integrity verification. However, it's not parsing serialized network protocol data.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2021-37640_before_exclude_100:9d3d92f0:spec": {
    "timestamp": "2026-01-20T10:10:17.246329",
    "cve_id": "CVE-2021-37640",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d3d92f0",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor reshaping operations for sparse data structures. It does not involve any cryptographic operations on secret values. The specification is about constant-time execution for cryptography, which is completely unrelated to this numerical computation code.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor reshaping utility function in what appears to be a machine learning framework (TensorFlow). It has no elliptic curve implementations or any cryptographic operations. The specification is completely unrelated to the code's purpose.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory allocation and tensor operations but not for cryptographic processing. While it does allocate memory for output tensors, the constant-time requirement for cryptographic processing doesn't apply to this numerical reshaping operation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 6,
        "reasoning": "The code performs memory allocation operations (context->allocate_output) and maintains size tracking between input and output tensors. It validates that the reshaped tensor has the same number of elements as the original, which relates to consistent size tracking. However, this is not specifically about secure memory operations for security-sensitive data.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 7,
        "reasoning": "The code manages tensor resources and maintains invariant consistency between input and output shapes. It validates multiple invariants: input/output element count consistency, shape dimension validity, and proper handling of unknown dimensions. The OP_REQUIRES checks enforce these invariants throughout the reshaping operation.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 3,
        "reasoning": "The code processes tensor data (indices and shapes) rather than external string data. While it does validate input tensor shapes and dimensions, these are numerical validations rather than string termination checks. The specification is only loosely related through the general concept of input validation.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 2,
        "reasoning": "The code reshapes sparse tensor data structures but doesn't parse file formats or handle chunk boundaries. It operates on in-memory tensor representations within a computational graph. The specification about file format parsers has very low relevance to this tensor manipulation code.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      },
      {
        "score": 8,
        "reasoning": "The code performs multiple dimension calculations and products (product *= size) when computing output shapes. It validates that product * missing == dense_size, which checks for divisibility but doesn't explicitly protect against integer overflow. The calculations involve tensor dimensions that could potentially overflow if not properly validated, making this specification highly relevant for secure implementation.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      }
    ]
  },
  "CVE-2018-8905_before_exclude_100:324c9804:spec": {
    "timestamp": "2026-01-20T10:10:18.042702",
    "cve_id": "CVE-2018-8905",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "324c9804",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `_TIFFmemset` to initialize the LZW code table after a CLEAR code, which aligns with the principle of initializing memory before use. However, the initialization is conditional (only on CLEAR), and other memory structures (like `sp->dec_codetab`) are assumed to be pre-initialized. The relevance is moderate because the specification is about memory allocations, and this code is more about processing an existing buffer than allocating new memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error handling paths (e.g., corrupted LZW table, insufficient data) that return 0 (failure) but also update state variables (like `sp->dec_restart`, `tif->tif_rawcp`) before returning. The state may be partially updated in error paths, potentially leading to inconsistent states on subsequent calls. This is a strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2022-24763_after_exclude_100:df331759:spec": {
    "timestamp": "2026-01-20T10:10:18.872861",
    "cve_id": "CVE-2022-24763",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "df331759",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code is an XML parser, not a regular expression parser. However, it does parse input patterns (XML tags and content) using string scanning functions. While it doesn't explicitly handle NUL bytes, the scanner functions appear to work with pointers and lengths, which could potentially handle embedded NULs better than C string functions. Moderate relevance because it's pattern parsing but not regex.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "This specification is about pattern compilers and escape sequences. The code is an XML parser that handles attributes with quoted values, but it doesn't compile patterns or process escape sequences in the sense meant by this specification (like regex escape sequences). Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted XML input and uses length-aware operations throughout (pj_scan_get_until_ch, pj_scan_get_until_chr, pj_str_t with slen). It avoids common C string functions like strcpy/strcat. The scanner appears to track buffer boundaries and lengths, which is good practice for security.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "This specification is about protocol message length fields and integer limits. The XML parser doesn't process explicit length fields from the input; it parses text-based XML. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code calls alloc_node() and alloc_attr() which presumably perform memory allocation. While the code doesn't show size parameter validation directly, proper memory allocation is crucial for parser security. The relevance is moderate because we can't see the allocation implementations.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The XML parser must enforce consistent type handling (nodes, attributes, content, CDATA, comments, processing instructions). The code shows different parsing paths for different XML constructs, and maintaining consistency is important for security to prevent parsing ambiguities or injection attacks.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code extensively validates buffer boundaries before access through scanner functions that check curptr positions. It validates characters like '<', '>', '/', '?' before accessing them and uses length-aware scanning functions. This is exactly what this specification addresses for secure parsing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The parser maintains buffer state through the scanner object and consistently checks scanner->curptr before dereferencing. It uses scanner advancement functions that presumably maintain buffer invariants. This is crucial for preventing buffer overreads and maintaining parsing integrity.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-24763_before_exclude_100:a999a87b:spec": {
    "timestamp": "2026-01-20T10:10:19.153721",
    "cve_id": "CVE-2022-24763",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a999a87b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not use regular expressions for parsing XML. It uses character-by-character scanning and string comparison functions. While embedded NUL bytes could potentially affect string handling if the scanner functions are not length-aware, this is not the primary concern addressed by this specification.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code processes XML, not pattern compilation with escape sequences. While XML has entities that could be considered escape sequences, this parser doesn't handle XML entities in the shown code. The specification is about pattern compilers, which doesn't apply here.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted XML input using pj_scan_* functions that appear to be length-aware (taking pj_str_t structures with length fields). However, the code modifies string lengths directly (attr->value.slen -= 2) without clear boundary validation, which could be problematic if the string is empty or too short.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code doesn't process protocol message length fields. It's parsing XML structure, not protocol messages with explicit length fields. The scanner appears to work on null-terminated strings.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code calls alloc_node() and alloc_attr() functions which presumably perform memory allocation. While the code doesn't show these functions, memory allocation validation is important for any parser handling potentially malicious input that could cause excessive memory consumption.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The XML parser must handle different node types (elements, comments, processing instructions, CDATA) consistently. The code shows different parsing paths for different constructs, and consistency in type handling is important for security to avoid confusion between data and markup.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code performs extensive buffer access through scanner operations. Functions like pj_scan_advance_n, pj_scan_get_char, and pj_scan_get_until_chr must validate buffer boundaries before access. The code has multiple pointer dereferences (scanner->curptr, scanner->curptr+1) that require boundary checks to prevent buffer overreads.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code is a parser that maintains scanner state while processing input. It must ensure buffer state invariants are maintained, especially when advancing the scanner pointer, handling syntax errors, and parsing nested structures. The recursive nature (xml_parse_node calls itself) makes consistent buffer state crucial.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-1441_after_exclude_100:9c97c7ac:spec": {
    "timestamp": "2026-01-20T10:10:19.412108",
    "cve_id": "CVE-2022-1441",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9c97c7ac",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory but does not initialize it before reading data into it. While the subsequent `gf_bs_read_data` call writes to the buffer, the specification about initializing memory before use is relevant to ensuring predictable state and preventing information leaks from uninitialized memory. However, the read operation immediately follows allocation, so the primary risk is limited.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has an error handling path for memory allocation failure (return GF_OUT_OF_MEM). However, if allocation fails, the function returns without modifying the object state, which is consistent. The relevance is moderate because the specification encourages checking error paths for state consistency, which this code partially demonstrates.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code reads data from a bitstream (potentially from a network source) but does not validate the input size (`s->size`) before allocation and read. This is weakly relevant because the specification is about network protocol handlers, and this appears to be a media file parser, but the principle of validating input before processing applies.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code allocates memory based on `s->size` without any validation. If `s->size` is excessively large or negative (when cast), it could cause excessive memory allocation or integer overflow in `sizeof(char) * (s->size+1)`. This directly violates the need to pre-validate size parameters before allocation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for BMP parsers and bit count requirements. This code is for a completely different format (DIMS). No relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code writes `s->size` bytes into the allocated buffer without explicitly validating that the buffer has sufficient space. While the allocation size is `s->size+1`, ensuring the write operation does not overflow requires validation. The null-termination write (`p->content_script_types[s->size] = 0`) also depends on correct allocation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code reads data from a bitstream (`gf_bs_read_data`), which advances the buffer position. The specification about maintaining buffer position invariants during parser state transitions applies, but the code is a simple read function without complex state transitions.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2022-21740_before_exclude_100:505dfc01:spec": {
    "timestamp": "2026-01-20T10:10:19.693914",
    "cve_id": "CVE-2022-21740",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "505dfc01",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor computations (counting/aggregation) and does not involve any cryptographic operations on secret values. The specification is about constant-time execution for cryptography, which is not relevant here.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor operation kernel for a machine learning framework (likely TensorFlow). It contains no elliptic curve implementations or any cryptographic operations, making this specification irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "While the code involves memory operations (accessing tensor data), its primary purpose is numerical computation and aggregation. It does not perform cryptographic processing, so the requirement for constant-time properties during such processing is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code performs arithmetic for indexing and batch calculations (e.g., `num_batches`, `num_values`, loop bounds). It uses `int` types, not `size_t`, and does not show explicit overflow protection (e.g., checking multiplication for allocation size). There is a moderate relevance because improper bounds calculations could lead to security issues, but the focus is not on allocation size arithmetic itself.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations for memory allocation must use overflow-protected calculations w..."
      },
      {
        "score": 5,
        "reasoning": "The code validates tensor shapes and dimensions (e.g., checking indices is a 2D matrix, shape elements are non-negative). While it validates \"shape\" input, it does not explicitly check for maximum allocation size based on those dimensions before processing. There is weak relevance as dimension validation is present, but the specification's focus on pre-allocation size checks is not fully addressed.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image dimension validation must include maximum allocation size checks before processi..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain explicit memory allocation calls (like malloc/new). It works with Tensor objects, where allocation is managed by the framework. The specification about allocation wrappers enforcing boundaries is only loosely related, as the code relies on the framework's safety.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory allocation wrappers must enforce maximum safe allocation boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code performs bounds validation before write operations into the `per_batch_counts` data structure. It checks `batch < num_batches` and validates indices bounds. However, it uses a map-like structure (`BatchedMap`) rather than a fixed buffer, so strict fixed buffer bounds enforcement is not directly applicable. There is moderate relevance due to the bounds checking present.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code implements multiple input validations before processing: it checks tensor dimensions, shape values (non-negative), consistency between values and indices, and that indices dimensions are valid. This aligns well with the specification's requirement for complete input size validation before processing. The relevance is strong, though the validation is specific to tensor operations rather than general input parsing.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      }
    ]
  },
  "CVE-2021-37641_after_exclude_100:e43270b3:spec": {
    "timestamp": "2026-01-20T10:10:21.671380",
    "cve_id": "CVE-2021-37641",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e43270b3",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation and data copying operations within a machine learning kernel (likely TensorFlow). It does not involve any cryptographic operations on secret values. The specification is about constant-time execution for cryptography, which is completely unrelated to this code's purpose.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is not an elliptic curve implementation. It is a data processing kernel for handling ragged tensors. The specification regarding side-channel resistance for cryptographic curves has no relevance.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs standard memory operations for copying tensor values. It is not involved in cryptographic processing, so the requirement for constant-time properties during such processing is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code performs write operations via `WriteSplits` and `WriteValues`. While it validates indices and tensor dimensions (e.g., `OP_REQUIRES(context, params_dense_values_in.dims() > 0, ...)`), the specification's focus on \"strict bounds validation before write operations\" is a general security principle that applies to any code writing to buffers. The code's validation is present but not necessarily exhaustive for all buffer bounds, as the actual bounds checking is likely deferred to the helper functions (`ValidateIndices`, `MakeSplits`, `WriteSplits`, `WriteValues`).",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code is an input parser for tensor data. It performs several input validations before processing: checking that the `params_nested_splits_in` list is non-empty, that split tensors are not scalars, that `params_dense_values_in` has non-zero dimensions, and validates indices via `ValidateIndices`. This aligns directly with the specification's requirement for \"complete input size validation before processing.\"",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The code acts as a parser for structured input data (nested splits and dense values). It enforces structural constraints such as the relationship between the number of splits and the indexing of subsequent input tensors (`context->input(params_nested_splits_in.size())`), and validates tensor ranks and dimensions. This aligns with the spirit of enforcing structural constraints on input data, though the specification's term \"configuration parsers\" is slightly more specific than this data processing kernel.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 1,
        "reasoning": "No relevance. The code does not handle privilege separation or process termination. It is a computational kernel that returns errors via the `OP_REQUIRES` and `OP_REQUIRES_OK` mechanisms, which typically propagate errors back to the framework rather than terminating the process.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code performs a sequence of validation and computation steps but does not involve security-critical state transitions (like authentication state, privilege levels, or cryptographic session state) that would require atomic verification. Its state is local to the function call.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2016-9810_before_exclude_100:5a14ec73:spec": {
    "timestamp": "2026-01-20T10:10:21.912876",
    "cve_id": "CVE-2016-9810",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5a14ec73",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory for `frame_data` and `delta_data` using `g_malloc` without explicit initialization (e.g., zeroing). These buffers are later used in `memcpy` and decoding operations. While the decoder may fill them completely, uninitialized memory could lead to information leaks or instability if the decoder logic has flaws. Specification HS-MEM-001 is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error paths (e.g., `wrong_type`, decode failure). In the `wrong_type` error, it calls `gst_object_unref(flxdec)` but also returns an error, potentially leaving the parent object in an inconsistent state if references are mismanaged. Other error paths return without cleaning up adapter state. Specification HS-STATE-002 is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "While this is a media decoder, not a network protocol handler, it processes untrusted input (file data). It validates the FLX header type and checks chunk sizes, which aligns with the spirit of input validation. Specification HS-IO-003 is moderately relevant as a general input validation principle.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code reads size fields from the FLX header (`flxh->size`, `flxh->width`, `flxh->height`) and uses them in calculations (e.g., `flxdec->size = width * height`). It does not explicitly validate these against integer overflow or platform limits before allocation. Specification HS-INPUT-001 is weakly relevant as the code lacks robust integer overflow checks.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code calculates `flxdec->size = width * height` and allocates `frame_data` and `delta_data` based on this product. It does not validate that the multiplication doesn't overflow, nor does it check if the size is reasonable before allocation. This is a direct security concern. Specification HS-MEM-002 is highly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code checks header type (`flxh->type`) against expected magic values and uses endianness fixes for different structures. However, it assumes consistent type handling across chunks without exhaustive validation of all chunk types. Specification HS-PROTOCOL-003 is strongly relevant for media format parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The buffer allocations (`g_malloc`, `gst_buffer_new_and_alloc`) are based on calculated sizes without explicit safety margins or padding considerations. This specification is more relevant to network packet buffers or cryptographic operations. It has very low relevance here.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "This is a decompression/decoding operation, not compression/encoding. The `flx_decode_chunks` function likely performs bounds checking, but the code shown does not explicitly enforce bounds on encoder buffers. Specification HS-IO-004 is weakly relevant as it targets the opposite operation.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2012-2370_before_exclude_100:2226e343:spec": {
    "timestamp": "2026-01-20T10:10:23.002318",
    "cve_id": "CVE-2012-2370",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2226e343",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `g_malloc` which does not initialize memory. The allocated `bits` buffer is subsequently written to via pointer assignment (`*ptr = value`), so it is initialized before use. However, if the allocation succeeds but the subsequent read loop fails early (e.g., `next_int` returns -1), the function returns FALSE and frees the buffer, so uninitialized memory is not used. The specification is moderately relevant because proper initialization is considered, but the code appears to handle it correctly.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code uses a macro `RETURN` that frees the `bits` buffer on error paths, maintaining consistent state (no memory leak). However, other state variables like `ww`, `hh`, `hx`, `hy` are not reset on error, but they are local and not exposed. The function ensures that on failure, allocated memory is freed and no partial data is returned. Strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code reads from a file stream, not a network protocol. Specification is about network protocol handlers, which is not applicable here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "The code uses `fgets(line, MAX_SIZE, fstream)` to read lines, which bounds input to `MAX_SIZE`. It checks if `strlen(line) == MAX_SIZE-1` to detect truncation, which is a form of validation. However, `sscanf` is used on the buffer without explicit length validation on the format strings, but the buffer is null-terminated by `fgets`. Moderate relevance because buffer bounds are considered but not all string operations are fully validated (e.g., `sscanf` could overflow if line were not null-terminated, but `fgets` ensures it).",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code uses `sscanf` with format strings like `\"#define %s %d\"` where `%s` reads into `name_and_type` of size `MAX_SIZE`. This could overflow if the token is longer than `MAX_SIZE-1`. No explicit length validation in `sscanf`. Weak relevance because the risk exists but is partially mitigated by prior `fgets` limit.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      },
      {
        "score": 2,
        "reasoning": "The code does not implement a formatting state machine; it parses a bitmap file sequentially. No state machine position tracking is present. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Formatting state machines must maintain consistent position tracking"
      },
      {
        "score": 9,
        "reasoning": "The code validates critical header fields (`width` and `height`) before processing data: it checks `if (!ww || !hh) RETURN (FALSE);`. Also validates hotspots and other fields. Highly relevant as it ensures necessary header data is present before allocating memory and reading bitmap data.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 9,
        "reasoning": "Memory allocation `bits = g_malloc(size)` uses `size` calculated from `ww` and `hh`. The code validates `ww` and `hh` are non-zero before calculating `size`. However, it does not check for integer overflow in `bytes_per_line` or `size`. Still, strong relevance because pre-validation of parameters is performed.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2012-2370_after_exclude_100:142011d4:spec": {
    "timestamp": "2026-01-20T10:10:23.248494",
    "cve_id": "CVE-2012-2370",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "142011d4",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `g_malloc` to allocate memory for `bits`. While the allocated memory is subsequently written to in the loops that follow, there is no explicit full initialization (e.g., zeroing) of the entire buffer before use. The loops write sequentially, so all accessed bytes are initialized, but the specification is highly relevant as a general secure coding practice for memory allocations.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code uses a `RETURN` macro that frees `bits` on error paths, which helps maintain a consistent state (no memory leak). However, other object states (like the output parameters `width`, `height`, `data`, `x_hot`, `y_hot`) are only set on success; on error, they are left unchanged. This is moderately relevant as the function's interface relies on caller initialization, but consistent state on error is a security concern.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification is about network protocol handlers. This code reads from a `FILE*` (likely a local file), not a network protocol. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code uses `fgets` with a fixed buffer `line[MAX_SIZE]`, which bounds input. However, it checks `strlen(line) == MAX_SIZE-1` to detect possible truncation, which is a form of validation. The relevance is weak because the specification emphasizes \"string formatting operations\" (like `sprintf`), which this code does not use. The buffer bounds check is related but not the core focus.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code uses `sscanf` with format strings like `\"#define %s %d\"`. The `%s` can overflow the `name_and_type` buffer if the input line is very long. However, `fgets` already limits input to `MAX_SIZE-1` characters, and `name_and_type` is also `MAX_SIZE`. This provides some implicit protection, but the specification strictly about \"numeric format templates\" and \"output buffer capacity\" is not directly applicable here (the risk is with string `%s`, not numeric templates). Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about \"formatting state machines\" and \"position tracking\". This code does not implement a state machine for formatting; it sequentially parses lines. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Formatting state machines must maintain consistent position tracking"
      },
      {
        "score": 5,
        "reasoning": "This is an image format parser (bitmap file). It validates critical header fields like `width` and `height` (checking `value <= 0`) and ensures they are set (`!ww || !hh`) before processing data. It also validates size calculations for overflow. This is highly relevant and directly addresses security issues in image parsers.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code calculates `size = bytes_per_line * hh` and explicitly checks for overflow (`size / bytes_per_line != hh`) before calling `g_malloc`. This is a direct application of pre-validation of size parameters to prevent integer overflow and excessive allocation. Highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2019-18218_before_exclude_100:0ec1dbb2:spec": {
    "timestamp": "2026-01-20T10:10:23.495740",
    "cve_id": "CVE-2019-18218",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0ec1dbb2",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `cdf_grow_info` for dynamic memory allocation and later accesses the `inp` array. While the array elements are populated in the loop, there is no explicit full initialization of the entire allocated memory block before use. However, the code does write to each element's fields (`pi_id`, `pi_type`, etc.) during processing. The relevance is moderate because the specification is about general memory initialization, but the code's pattern is to initialize fields as they are used rather than upfront.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error handling paths (via `goto out`) that consistently reset `*info`, `*count`, and `*maxcount` to safe states (NULL, 0, 0) and set `errno`. This maintains consistent object states on failure, which is exactly what HS-STATE-002 addresses.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code is parsing a file format (CDF/Compound Document Format) from a stream in memory, not handling a network protocol. The validation performed is for file structure integrity, not network input.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates length fields from the file format against limits. Examples: checking `offs > UINT32_MAX / 4`, `sh.sh_len > CDF_SHLEN_LIMIT`, `sh.sh_properties > CDF_PROP_LIMIT`, and validating `nelements` and string lengths against remaining buffer size (`left`). This directly aligns with validating message length fields against integer limits and buffer boundaries.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code calls `cdf_grow_info` (assumed to perform memory allocation) based on `sh.sh_properties`, which is validated against `CDF_PROP_LIMIT` before allocation. Additionally, when handling vector types, it grows the info array again based on `nelements`, which is also validated (e.g., `nelements == 0` check). This validates size parameters against limits before allocation and usage.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses a `pi_type` field to determine how to process property data, with a switch statement handling different types (CDF_SIGNED16, CDF_STRING, etc.). It ensures type consistency by checking for unsupported types (CDF_ARRAY|CDF_BYREF|CDF_RESERVED) and handling unknown types in a default case. This enforces consistent type handling during parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve regular expression parsing. It processes binary property information from a structured file format, handling length-prefixed strings but not regex patterns with embedded NUL bytes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not compile patterns or process escape sequences. It is a file format parser for CDF properties, dealing with binary data types and structured records.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-1441_before_exclude_100:99dfb093:spec": {
    "timestamp": "2026-01-20T10:10:23.872658",
    "cve_id": "CVE-2022-1441",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "99dfb093",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification \"Memory allocations must be fully initialized before use\" is weakly relevant. The code does allocate memory via gf_strdup, but the primary security concern is not about initializing that allocated memory. The str buffer is filled character-by-character, but it is not guaranteed to be null-terminated before the copy if the loop breaks due to reaching the buffer end without a null byte, which is a more pressing issue than initialization.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Error handling paths must maintain consistent object states\" has moderate relevance. The function lacks error handling for the gf_strdup allocation failure (which could return NULL). If allocation fails, the function still returns GF_OK, leaving the object in an inconsistent state (p->content_script_types potentially NULL). However, the main vulnerability is buffer overflow, not state consistency.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Network protocol handlers must validate input before processing\" is highly relevant. The code reads untrusted input from a bitstream (bs) without validating the length of the string. It reads bytes into a fixed-size buffer (str[1024]) until a null byte is encountered, but there is no check to prevent writing beyond the buffer bounds (i >= 1024), leading to a buffer overflow.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Image format parsers must validate all critical header fields before processing\" has very low relevance. The code is for a DIMS script types box parser (likely multimedia container format), not specifically an image format parser. While it parses a box in a media file, the specification is too narrowly scoped to image headers.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Memory allocation must be guarded by pre-validation of size parameters\" is strongly relevant. Although the code does not directly allocate based on an untrusted size parameter, the buffer write operation (implicitly) depends on the length of the input string. The lack of validation of the string length before writing into the fixed-size buffer is a critical issue that this specification directly addresses.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "The specification \"BMP parser must enforce minimum bit count requirements per specification\" is not applicable. The code is for a DIMS script types box, not a BMP image parser. There is no relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Buffer write operations must validate available space before each write\" is directly and highly relevant. The code writes bytes into a fixed-size stack buffer (str[1024]) in a loop without checking if the index i exceeds the buffer size (1023, since null terminator is needed). This is a classic buffer overflow vulnerability. The specification precisely addresses this flaw.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "The specification \"Parser state transitions must maintain buffer position invariants\" has moderate to strong relevance. The function reads from a bitstream (bs) and decrements a size counter (ISOM_DECREASE_SIZE). However, if the buffer overflow occurs, the bitstream position and the size accounting will be incorrect, violating parser state invariants. The primary issue is the lack of bounds checking, but this specification covers a consequential effect.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2020-14361_before_exclude_100:eee3f3f9:spec": {
    "timestamp": "2026-01-20T10:10:25.310539",
    "cve_id": "CVE-2020-14361",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "eee3f3f9",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code validates the `stuff->length` field from the protocol message using `REQUEST_AT_LEAST_SIZE` and later calculates `dataLeft` based on `(stuff->length * 4)`. This directly involves validating the protocol message length field against the actual received data size, which is the core of HS-INPUT-001. The check `if (dataLeft < (size * 2))` and the final validation `if (dataLeft > 2)` further enforce length constraints, making this specification directly applicable to the code's security posture.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The code does not contain any explicit memory allocation operations (e.g., malloc, calloc, realloc). It operates on a buffer (`from.c8`) that is derived from the incoming request data pointer. While there is an implicit trust in the buffer's size based on the validated `length`, the specification about validating allocation size parameters is not directly applicable here.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function is a protocol swapper (`SProc`), responsible for byte-swapping incoming data from the client to host order. It meticulously handles different data types (CARD8, CARD16, CARD32) via a union and applies the correct swapping function (`swaps`, `swapl`) based on the event type (`ndx`). This ensures consistent type handling across the network and host processing stages, which is the essence of HS-PROTOCOL-003. The `default` case in the switch statement also enforces type validity.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not involve any regular expression parsing. It processes a structured binary protocol request related to XKB event selection. The specification regarding embedded NUL bytes in regex patterns is completely unrelated to this context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve pattern compilation or processing of escape sequences. It handles a fixed-format binary protocol for selecting keyboard events. This specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does process untrusted input (network data from the client). However, it does not use traditional C string functions (e.g., strcpy, strlen). It uses length-aware pointer arithmetic (`from.c8 += (size * 2)`) and tracks remaining data (`dataLeft`). While this is a form of bounds-checked buffer traversal, it's not specifically about \"string processing functions,\" which is the focus of HS-MEM-003. The relevance is indirect.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform any memory allocations that would require initialization. It works with a pre-existing request buffer. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function has multiple error return paths (`BadValue`, `BadLength`). These occur before the call to the main processing function (`ProcXkbSelectEvents`). The specification is relevant because it's important that these early error returns leave the server state consistent. However, the code shown is primarily a validation/swapping wrapper; it doesn't manipulate complex global object states itself. The relevance lies in the broader error handling pattern it participates in.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2019-18218_after_exclude_100:d8e939a3:spec": {
    "timestamp": "2026-01-20T10:10:25.890708",
    "cve_id": "CVE-2019-18218",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d8e939a3",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `cdf_grow_info` for dynamic memory allocation. While the newly allocated memory for the info array is used, the code does not show explicit initialization of all fields before use (e.g., `inp[i].pi_str.s_len` and `inp[i].pi_str.s_buf` are set only in the CDF_LENGTH32_STRING case). Other fields like `pi_id` and `pi_type` are explicitly set, but the initialization is not uniform across all code paths. The \"unknown\" case uses `memset` to zero `pi_val`, but this is not a full struct initialization. This is relevant to memory initialization before use.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The error handling path labeled \"out:\" consistently frees the `*info` pointer, sets it to NULL, and resets `*count` and `*maxcount` to 0, ensuring a consistent state on failure. This is a strong example of maintaining consistent object states in error paths, which is the core of this specification.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code parses a file format (CDF/Compound Document Format) from a byte stream, not a network protocol. While it performs extensive input validation, the specification is specifically for network protocol handlers, making it only loosely related.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code directly validates multiple length fields from the input data against limits before using them for calculations or memory operations. Examples include: checking `sh.sh_len > CDF_SHLEN_LIMIT`, validating `sh.sh_properties > CDF_PROP_LIMIT`, checking `nelements > CDF_ELEMENT_LIMIT`, and ensuring `offs > UINT32_MAX / 4` does not cause overflow. This is a direct and comprehensive application of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code indirectly validates size parameters through the `cdf_grow_info` function call (not shown, but implied by its use). More directly, it validates the `sh.sh_properties` count before using it to grow the info array and validates `nelements` before using it in the string case. It also performs offset and bounds checks (e.g., `cdf_check_stream_offset`, `p >= e`, `left < sizeof(uint32_t)`) to ensure subsequent memory accesses are safe. This strongly aligns with validating size parameters against limits and usage requirements.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code implements a type-handling state machine using `inp[i].pi_type`. It masks the type (`CDF_TYPEMASK`), checks for flags (`CDF_VECTOR`, `CDF_ARRAY`, etc.), and has a `switch` statement to process each data type consistently (e.g., copying the correct size, handling strings). The \"unknown\" default case provides a consistent fallback. This is a clear example of enforcing consistent type handling during parsing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. This code is a CDF file property parser; it does not involve regular expressions at all. The relevance is negligible.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. This code parses structured binary data from a file format. There is no compilation of patterns or processing of escape sequences. The relevance is negligible.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2016-9810_after_exclude_100:406a0451:spec": {
    "timestamp": "2026-01-20T10:10:28.375105",
    "cve_id": "CVE-2016-9810",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "406a0451",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory for `frame_data` and `delta_data` using `g_malloc` without explicit initialization (e.g., zeroing). These buffers are later used in `memcpy` and decoding operations. While the `flx_decode_chunks` function might write to `frame_data`, the initial state is uninitialized, which could lead to information disclosure or instability if the decode function doesn't fully populate the buffer. This directly relates to HS-MEM-001.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error paths (e.g., `wrong_type`, decode failure). In the decode failure path, it returns `GST_FLOW_ERROR` but does not clearly show if the decoder's internal state (like `flxdec->state`, allocated buffers) is cleaned up or reset to a consistent safe state. This could leave the object in an inconsistent condition for potential reuse. However, the primary error handling is present.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "Although this is a media decoder, not a network protocol handler, it processes untrusted input data (FLI/FLC/FLX files). The code validates the file header magic type and checks chunk sizes before processing. This is analogous to validating input before processing, which is the core of HS-IO-003. The validation is present but could be more extensive (e.g., more sanity checks on width/height).",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The code reads length fields from the input stream (`flxfh.size`, `flxh->width`, `flxh->height`) and uses them in calculations and allocations. It validates `avail < flxfh.size` before processing a chunk, which is a length validation. However, it does not explicitly check for integer overflow when calculating `flxdec->size = width * height` or when using `flxfh.size` in arithmetic (e.g., `flxfh.size - FlxFrameChunkSize`). This is a direct concern addressed by HS-INPUT-001.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code calculates allocation size as `flxdec->size = width * height` and later allocates `flxdec->size * 4` for the output buffer. There is no validation that `width` and `height` are positive, non-zero, and that their product doesn't overflow `guint` or lead to an excessively large allocation that could exhaust memory. This is a critical omission directly covered by HS-MEM-002.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "The code handles different file types (FLI, FLC, FLX) and chunk types (`FLX_FRAME_TYPE` vs. others). It uses endianness fixes (`FLX_HDR_FIX_ENDIANNESS`, `FLX_FRAME_CHUNK_FIX_ENDIANNESS`) to ensure consistent interpretation of data from the stream. This aligns with HS-PROTOCOL-003's requirement for consistent type handling. However, the handling of other chunk types (default case) is minimal.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2021-37666_before_exclude_100:0714d6ff:spec": {
    "timestamp": "2026-01-20T10:10:34.477964",
    "cve_id": "CVE-2021-37666",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0714d6ff",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation and ragged tensor unbatching operations. It does not involve any cryptographic operations on secret values, making this specification not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is unrelated to elliptic curve cryptography or any cryptographic curve implementations. It deals with tensor data structures in a machine learning context.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory operations for tensor manipulation but does not involve cryptographic processing or require constant-time properties for security purposes.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement view-based data access or privilege checks. It processes tensor data without any access control mechanisms.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve security-critical state transitions or privilege contexts. It performs data transformation operations on tensors.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code is completely unrelated to SQL protocols or database view security. It operates on tensor data structures in a computational graph context.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code involves dimension calculations (num_components = batched_splits_top_vec.size() - 1) and tensor shape operations. While not specifically about image dimensions, the principle of overflow protection in dimension calculations applies to the tensor size computations performed here.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The code processes input tensors (ragged_nested_splits_in) and validates them with OP_REQUIRES checks. While not specifically about file format parsers, the principle of validating numeric inputs before processing applies to the tensor input validation performed in this code.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: File format parsers must validate all numeric inputs before processing"
      }
    ]
  },
  "CVE-2021-37640_after_exclude_100:94edc9da:spec": {
    "timestamp": "2026-01-20T10:10:36.370558",
    "cve_id": "CVE-2021-37640",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "94edc9da",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor reshaping operations for sparse tensors. It does not involve any cryptographic operations on secret values. The specification is about constant-time execution for cryptography, which is completely unrelated to this numerical computation code.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is for tensor manipulation in a machine learning context, not elliptic curve cryptography. There are no cryptographic operations of any kind, let alone elliptic curve implementations requiring side-channel resistance.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "While the code involves memory operations (tensor allocation and manipulation), it does not perform cryptographic processing. The specification specifically addresses maintaining constant-time properties during cryptographic operations, which doesn't apply here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation operations (context->allocate_output) and maintains size tracking between input and output tensors. It validates that the reshaped tensor has the same number of elements as the original, which relates to consistent size tracking. However, this is not specifically about secure memory allocation patterns for security-critical data.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "The code manages tensor resources and maintains several invariants: input/output shape consistency, dimension validation, and sparse tensor properties. It performs multiple checks (OP_REQUIRES) to ensure resource consistency throughout the reshaping operation, which aligns with maintaining invariant consistency in resource management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code processes tensor data (indices and shapes) rather than external string data. While it validates input tensor shapes and dimensions, this is numerical validation rather than string termination validation. The connection is very weak.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "The code processes tensor structures but not file formats. It does validate tensor shape boundaries and consistency, which is somewhat analogous to enforcing structural invariants, but the specification specifically addresses file format parsers and chunk boundaries, which doesn't apply here.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The code performs multiple image/tensor dimension calculations including product computations (product *= size), division operations (dense_size / product), and multiplication validations (product * missing == dense_size). These operations need overflow protection, especially when dealing with potentially large tensor dimensions. The code checks for non-negative sizes but doesn't explicitly protect against integer overflow in the product calculations.",
        "spec_index": 7,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must use overflow-protected arithmetic"
      }
    ]
  },
  "CVE-2021-37683_after_exclude_100:6aa5b49c:spec": {
    "timestamp": "2026-01-20T10:10:38.250572",
    "cve_id": "CVE-2021-37683",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6aa5b49c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor division operations in a machine learning inference context. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. The specification is about a completely different domain (regex parsers).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code handles numerical tensor data for division operations. It does not involve pattern compilers, escape sequence processing, or any protocol/pattern compilation logic. The specification is irrelevant to this mathematical operation code.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code processes tensor input data (which could be considered untrusted) and uses length-aware operations through `input2->bytes / sizeof(data_type)` to determine element count. However, it's not traditional string processing but numerical array processing with bounds checking via the tensor size.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code accesses tensor data through `GetTensorData` and calculates element counts from byte sizes, which involves implicit size tracking. However, it doesn't perform explicit memory allocation operations that would require consistent size tracking as specified.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The code performs resource management (tensor access) and maintains invariant consistency by checking for division by zero for integer types (INT32, UINT8) while allowing it for FLOAT32 (producing infinities). This maintains mathematical consistency based on data type semantics.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 5,
        "reasoning": "The code performs tensor operations in a machine learning inference engine. It does not involve view-based data access, privilege checks, or any security context switching. The specification applies to database/view security systems, not numerical computation code.",
        "spec_index": 5,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The code implements a mathematical division operation in a TensorFlow Lite kernel. It does not involve security-critical state transitions, privilege contexts, or any security state management. The specification is about security systems, not numerical computation.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code performs division operations on tensors in a machine learning framework. It does not involve SQL protocols, view security semantics, or database access of any kind. The specification is completely unrelated to this numerical computation code.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      }
    ]
  },
  "CVE-2008-4618_after_exclude_100:0ec448a3:spec": {
    "timestamp": "2026-01-20T10:10:38.730412",
    "cve_id": "CVE-2008-4618",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0ec448a3",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not involve any memory allocation. It only declares a static constant string and calls a function. HS-MEM-001 is about initializing allocated memory, which is not present here.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function is an error handling path for an invalid chunk length. It calls a function to abort the association due to a protocol violation, which is a form of error handling. While it doesn't directly show complex state management, it is part of the error handling mechanism, giving it moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "The function is a network protocol handler (SCTP) that is specifically triggered when a chunk has an invalid length. This is a direct form of input validation, making the specification highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The function's name and purpose (\"violation_chunklen\") indicate it enforces RFC-specified length constraints for a protocol message field (the chunk). This is a direct and perfect match for the specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "SCTP chunks are a form of Type-Length-Value (TLV). This function is invoked when chunk length validation fails, meaning it is part of the bounds checking process for TLV processing. This is strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The function validates a fundamental structural requirement for an SCTP chunkits length. Before a chunk can be processed, its length must be valid. This has strong relevance to the specification.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate minimum structural requirements before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically about DNS record processing. The target code is for the SCTP protocol, which is unrelated to DNS. Therefore, relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: DNS record processing must enforce strict field boundary validation"
      },
      {
        "score": 5,
        "reasoning": "While the code itself doesn't perform a memory operation, the violation it handles (invalid chunk length) is a prerequisite for preventing out-of-bounds memory accesses when the chunk data is later processed. It is a key part of the bounds verification chain, giving it moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Memory operations must verify bounds against actual available data"
      }
    ]
  },
  "CVE-2019-19525_before_exclude_100:aeef0137:spec": {
    "timestamp": "2026-01-20T10:10:39.045315",
    "cve_id": "CVE-2019-19525",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "aeef0137",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a USB device disconnect handler performing cleanup operations. It does not process any protocol messages with length fields, so this specification about validating protocol message lengths is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code frees memory and URBs but does not perform any memory allocation operations. The disconnect routine is about resource cleanup, not allocation, so this specification has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "The code handles USB device disconnection and cleanup, not protocol processing. There are no protocol implementations with type handling stages in this disconnect function.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "This is a kernel driver disconnect handler, not processing userspace input. The function deals with internal driver structures and USB interface cleanup, not userspace-provided array lengths.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "The code performs USB device cleanup and does not handle any protocol messages with variable-length components. This specification about protocol message handlers is not applicable to this disconnect routine.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 3,
        "reasoning": "The function frees buffers and URBs but does not allocate them. While buffer allocation might have occurred elsewhere in the driver, this specific disconnect function only deals with deallocation, making the specification only loosely related.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. This is a USB device driver disconnect handler that manages USB resources (URBs, endpoints). While it doesn't validate endpoints before operation (which would happen during initialization), it properly cleans up USB resources including killing anchored URBs and freeing the TX URB, which is related to USB driver security practices.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: USB device drivers must validate all required endpoints before operation"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. This is part of device lifecycle management (disconnection phase). While not about configuration verification before initialization, it ensures proper cleanup and state management when a device is disconnected, which is related to device configuration lifecycle security.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-002: Device configuration must be fully verified before driver initialization"
      }
    ]
  },
  "CVE-2019-19525_after_exclude_100:65256516:spec": {
    "timestamp": "2026-01-20T10:10:39.373512",
    "cve_id": "CVE-2019-19525",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "65256516",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a USB device disconnect handler performing cleanup operations. It does not process any protocol message length fields, making this specification about validating protocol message lengths largely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code performs memory deallocation (freeing URBs and hardware structures) rather than memory allocation. While memory safety is important, this specific code focuses on cleanup after shutdown, not on validating size parameters during allocation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "The code handles device disconnection and resource cleanup, not protocol processing. There are no protocol message handlers or type handling operations in this disconnect function.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "This is a kernel driver disconnect function that doesn't process userspace-provided array lengths. It operates on kernel data structures during device removal, not on user input.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "The function performs USB device cleanup and doesn't handle protocol messages or variable-length components. It's a resource management function, not a protocol handler.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 3,
        "reasoning": "While buffer allocation safety is important for USB drivers, this specific function is focused on deallocation and cleanup rather than allocation. The allocation would have occurred elsewhere during device initialization.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant as this is a USB device driver disconnect handler. While it doesn't validate endpoints (which should happen during initialization), it properly cleans up USB resources (URBs) and handles the disconnection sequence, which is part of USB driver security hygiene.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: USB device drivers must validate all required endpoints before operation"
      },
      {
        "score": 6,
        "reasoning": "Somewhat relevant as this function is part of device lifecycle management. While it doesn't perform configuration verification (which should occur during initialization), proper cleanup during disconnection is important for system stability and security to prevent resource leaks or use-after-free issues.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-002: Device configuration must be fully verified before driver initialization"
      }
    ]
  },
  "CVE-2022-1244_before_exclude_100:7670ee9b:spec": {
    "timestamp": "2026-01-20T10:10:41.434188",
    "cve_id": "CVE-2022-1244",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7670ee9b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses R_NEWS0 which zero-initializes memory, and initializes arrays like deps with R_NEWS0. However, depArray and extras are allocated but not always fully initialized before use in loops (e.g., depArray may be allocated but read fails). This relates directly to memory initialization requirements.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "Error handling paths (goto next) free some resources but may leave others allocated (e.g., bins, target_lib_names). The state cleanup is inconsistent across branches, especially when jumps occur mid-function.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This code processes dyld cache files from disk buffers, not network protocols. No network handling is present.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "Code reads binary structures (e.g., ut16, ut32) from a buffer. While not explicitly checking alignment, it uses r_buf_fread_at which may handle unaligned access internally. Platform alignment is indirectly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 2,
        "reasoning": "No network protocol implementation is present. The code parses dyld cache file structures, but this is not a communication protocol.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      },
      {
        "score": 5,
        "reasoning": "Code reads binary data from a buffer and could encounter misaligned data from malformed files. It uses safe buffer read functions but does not explicitly validate alignment before accessing structured data.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Input processing must handle misaligned data safely"
      },
      {
        "score": 8,
        "reasoning": "Error handling paths (goto next) free depArray, extras, img but may leak other resources (e.g., path_to_idx if allocated before jump). Memory state consistency is partially maintained but has gaps.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "Input validation occurs (e.g., checking pa != UT64_MAX, buffer read sizes), but boundaries for path strings (file[256]) are not strictly enforced. The code reads pathFileOffset without validating it fits within buffer bounds.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2022-27007_after_exclude_100:980ab81e:spec": {
    "timestamp": "2026-01-20T10:10:44.284929",
    "cve_id": "CVE-2022-27007",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "980ab81e",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a function frame save routine for a VM, dealing with stack frame management, argument copying, and value initialization. It does not involve parsing or processing regular expressions, which is the focus of HS-INPUT-001. The relevance is very low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile patterns or process escape sequences. It handles internal VM data structures (frames, values, arguments). HS-PROTOCOL-002 is about pattern compilers, which is unrelated to this low-level runtime frame management code.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the code copies values (njs_value_t) in loops, it uses pointer arithmetic with known bounds (start, end) derived from internal VM state, not directly processing untrusted input strings. The relevance is very low, though the concept of bounds checking is tangentially related to memory safety.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "This specification is about validating protocol message length fields. The target code is an internal VM function manipulating stack frames and local variables, not parsing or validating network protocol messages. No relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code performs pointer arithmetic to calculate memory regions (new, value) based on counts (value_count, temp). While not a direct memory allocation call (like malloc), it implicitly \"allocates\" space within a frame. There is no visible validation that these calculated pointers remain within the bounds of the allocated 'native' frame memory. This is a moderate relevance issue regarding buffer bounds.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code ensures function arguments are valid or set to undefined, which relates to consistent type/value state handling. However, HS-PROTOCOL-003 is focused on protocol implementations across stages, not internal VM state management. The relevance is weak but present in the abstract concept of state consistency.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "This is highly relevant. The function initializes a new frame (native) by zeroing its size/free pointers, then carefully populates its fields (arguments, local, temp, pc). It also initializes argument values, setting them to undefined if not valid. This aligns directly with the requirement to fully initialize memory before use to avoid use of uninitialized data.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has a clear success path (return NJS_OK) but no shown error handling. If preconditions (like valid counts) are not met, pointer arithmetic could lead to invalid memory access. The specification about maintaining consistent object states in error paths is moderately relevant, as the code's lack of error checks could leave the VM in an inconsistent state.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-32323_after_exclude_100:d357ba72:spec": {
    "timestamp": "2026-01-20T10:10:47.523143",
    "cve_id": "CVE-2022-32323",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d357ba72",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively validates BMP header fields (magic numbers, biSize, biWidth, biHeight, biPlanes, biBitCnt, biClrUsed, compression type) before processing image data. Multiple sanity checks prevent processing of malformed files.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs integer overflow checks before calculating rowbytes and image dimensions, which indirectly guards memory allocation in ReadImage(). However, the actual allocation happens outside this function.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code validates biBitCnt against allowed values (1, 2, 4, 8, 16, 24, 32) and rejects invalid values. It also handles special cases for different bit depths.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code initializes local arrays (buffer, ColorMap) but memory allocation for image data happens in ReadImage() which is not shown. The at_bitmap_init() call may involve allocation but isn't shown in detail.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses goto cleanup pattern for error handling, which ensures consistent cleanup (file closing). However, the image object initialization happens late and may not be fully consistent in all error paths.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is a file parser, not a network protocol handler. While input validation principles are similar, the specification specifically mentions network protocols.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates header fields against integer limits (e.g., checking biWidth against 0x7fffffff) but these are file format validations, not protocol message length validations.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs overflow checks for width * bitcnt and width * height calculations, which would affect memory allocation in ReadImage(). However, the actual allocation and size parameter validation happens elsewhere.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2020-7046_after_exclude_100:6e310f5b:spec": {
    "timestamp": "2026-01-20T10:10:48.817748",
    "cve_id": "CVE-2020-7046",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6e310f5b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not use regular expressions. It parses SMTP command parameters character by character using UTF-8 decoding and character checks. While it processes input, the specification about embedded NUL bytes in regex patterns is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequences, which are not present in this code. The code performs basic character validation and trimming, not pattern compilation or escape sequence processing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code uses length-aware operations: it tracks buffer boundaries (parser->cur, parser->end), uses pointer arithmetic with bounds checking (p < parser->end), and calls uni_utf8_get_char_n with the remaining length. This is critical for safe parsing of untrusted input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code validates length against a configurable max_size, but this is not a protocol message length field from a header. It's a size limit for parameters. The specification about platform-specific integer limits (e.g., overflow when calculating message size) is not directly addressed here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code calls i_strdup_until to allocate memory for parameters. While it ensures the source pointers (parser->cur, mp) are within bounds, it doesn't explicitly show validation of the allocation size against broader limits before the allocation. The relevance is indirect.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderately strong relevance. The code handles two types of input (regular command parameters and AUTH responses) with different rules (UTF-8 vs. raw bytes, different size limits). It must enforce consistent type handling (auth_response flag) across parsing, validation, and error reporting, which it does.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code performs critical buffer length calculations: (p - parser->cur) > max_size and pointer arithmetic (p += nch) within the loop. It validates remaining capacity (p < parser->end) before each read and uses (p - parser->end) for the UTF-8 function. This prevents buffer overflows.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code is a core protocol string processing function. It maintains strict boundary awareness by tracking parser->end, checking p before dereferencing, and ensuring operations like trimming (mp--) stay within the buffer (mp > parser->cur). This prevents over-reads.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      }
    ]
  },
  "CVE-2022-2285_after_exclude_100:9fddf57c:spec": {
    "timestamp": "2026-01-20T10:10:49.814128",
    "cve_id": "CVE-2022-2285",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9fddf57c",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes terminal input sequences which can contain embedded NUL bytes (e.g., as part of escape sequences or mouse coordinates). The function uses length-aware operations (like `len` and `slen`) and explicitly sets `tp[len] = NUL` temporarily, which could be problematic if NUL bytes are part of the valid input. However, it doesn't use regular expression parsers directly, so relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function's core purpose is parsing terminal escape sequences (e.g., CSI, OSC, DCS). It must maintain strict boundaries when processing these sequences to avoid misinterpretation (e.g., confusing mouse codes with other keys). The code shows extensive boundary checking with `len` and `slen` comparisons.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function processes potentially untrusted terminal input. It consistently uses length-aware operations (e.g., `STRNCMP`, checking `len < slen`, bounds checks with `tp + len`). However, there is a risky line `tp[len] = NUL` that temporarily modifies the buffer without guaranteed restoration, which could be problematic if `len` equals buffer size.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Low relevance. The code uses stack-allocated arrays (e.g., `string[MAX_KEY_CODE_LEN + 1]`) and local variables that are initialized (like `slen = 0`). There are no dynamic memory allocations within this function that require initialization before use.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function returns early with -1 for partial sequences or errors, but it modifies global state (e.g., `mouse_col`, `mouse_row`, `current_menu`) before some error checks. Error paths might leave global state inconsistent, though many are caught early.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function handles terminal protocol sequences (CSI, OSC, DCS) which are essentially a network-like protocol. It validates input length extensively before processing (e.g., checking `len >= 3` for CSI sequences) to prevent buffer overreads.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function builds output in `string[MAX_KEY_CODE_LEN + 1]` and uses `new_slen` to track length. It calls `put_string_in_typebuf` which likely validates bounds, but direct writes to `string` via `mb_char2bytes` or array indexing should ensure `new_slen < MAX_KEY_CODE_LEN`.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses `atoi` on `modifiers_start` without strict length validation, but the input is bounded by earlier checks (digits parsed within `j` loop). No explicit numeric format templates (like printf) are used, so relevance is limited.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      }
    ]
  },
  "CVE-2015-5745_after_exclude_100:faf5d439:spec": {
    "timestamp": "2026-01-20T10:10:50.171251",
    "cve_id": "CVE-2015-5745",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "faf5d439",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code handles a control message with a `len` parameter. While it doesn't explicitly validate a \"length field\" from a protocol, the `len` value (which likely originates from an untrusted source) is used to copy data into an I/O vector without checking if the buffer (`elem.in_sg`) is large enough. The TODO comment explicitly mentions the need to detect a buffer that's too short. This relates to validating a length against usage requirements, making the specification moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code does not perform memory allocation itself. However, it uses a pre-allocated buffer (`elem.in_sg`) for input. The security concern is validating that the provided `len` does not exceed the allocated size of this buffer, which is a form of validating a size parameter against subsequent usage requirements. The relevance is moderate as the core action is a copy, not an allocation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-27666_before_exclude_100:78a697ce:spec": {
    "timestamp": "2026-01-20T10:10:50.530366",
    "cve_id": "CVE-2022-27666",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "78a697ce",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code handles ESP (Encapsulating Security Payload) protocol output, which involves constructing packets with specific length fields (esp->tailen, esp->plen). While it performs buffer management and size calculations, it does not explicitly show validation of incoming protocol message fields against RFC-specified length constraints. The relevance is moderate because the function is part of a protocol implementation that should enforce such constraints, but the validation likely happens elsewhere.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code processes network packet data but does not implement TLV (Type-Length-Value) parsing. It does perform bounds checking indirectly through operations like `skb_cow_data` and checking `skb_tailroom`, but this is general buffer management rather than TLV-specific bounds checking. Relevance is weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or pattern matching. It is a network packet processing function for ESP protocol output. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or any text-based pattern compilation. It handles binary network packet construction. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses length-aware operations when manipulating socket buffers (skb) and their data. Functions like `pskb_put`, `skb_cow_data`, and explicit length checks (`tailen <= skb_tailroom(skb)`) show awareness of buffer boundaries. However, it doesn't directly process untrusted strings. Relevance is moderate to strong due to the careful buffer handling.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code uses length fields (esp->tailen, esp->plen) for buffer allocation and manipulation. While it performs arithmetic (ALIGN with L1_CACHE_BYTES) and checks resource availability, it doesn't explicitly show validation of these fields against integer overflow or platform limits before use. The `skb_page_frag_refill` and allocation checks provide some protection. Moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation operations via `skb_page_frag_refill` and buffer expansion (`skb_cow_data`). It validates size parameters by checking available space (`skb_tailroom`, page fragment refill) and handles allocation failures. The `ALIGN(tailen, L1_CACHE_BYTES)` operation could potentially cause integer overflow if `tailen` is very large, but this is mitigated by the preceding checks. Strong relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code is part of a protocol implementation (ESP/IPsec) and handles protocol state (`xfrm_state`), headers (`ip_esp_hdr`), and packet data consistently. It maintains offsets (`esph_offset`) correctly when reallocating buffers. However, the specification about \"consistent type handling\" is broad; this code shows consistent handling of buffer types and protocol structures. Moderate to strong relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2018-18820_after_exclude_100:2e8ef557:spec": {
    "timestamp": "2026-01-20T10:10:50.869961",
    "cve_id": "CVE-2018-18820",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2e8ef557",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process explicit protocol message length fields. It works with the length `len` derived from `size * nmemb`, which is a common pattern for libcurl write callbacks. While integer overflow in `size * nmemb` is a theoretical concern, the code does not validate this multiplication against platform limits. The relevance is weak because the specification focuses on explicit length fields in protocol messages, not general buffer size calculations.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not contain any explicit memory allocation operations (like malloc, calloc, realloc). It performs memory copying with bounds checking. Therefore, this specification about validating allocation size parameters has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles HTTP header data. It uses `strncasecmp` for case-insensitive comparison and processes header values. There is some type handling (e.g., parsing unsigned int with `sscanf`), but the specification about enforcing consistent type handling across all processing stages is only loosely related, as the code's primary concern is parsing specific headers, not full protocol type consistency.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "The code does not use regular expressions at all. It uses string comparison (`strncasecmp`) and formatted input scanning (`sscanf`). This specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain pattern compilers or process escape sequences. It performs simple string matching and parsing. This specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The code processes potentially untrusted input (headers from an auth backend) and correctly uses length-aware operations: `strncasecmp` with explicit length parameters and bounds checking before `memcpy` into a fixed-size buffer (`url->errormsg`). It validates `len` before operations and calculates safe copy lengths. This is a direct application of the specification's guidance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "The code validates header data against internal buffer sizes (e.g., `sizeof(url->errormsg)`), not RFC-specified length constraints for HTTP headers. It ensures data fits into destination buffers, which is a form of length constraint enforcement, but not specifically RFC-based. The relevance is moderate.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code does not process TLV (Type-Length-Value) encoded data. It processes HTTP-style headers. However, it does perform bounds checking before accessing header values (e.g., checking `len` against header prefix lengths and for CRLF termination). This conceptually aligns with bounds checking before field access, making the relevance weak to moderate.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-32323_before_exclude_100:67321b7f:spec": {
    "timestamp": "2026-01-20T10:10:51.146686",
    "cve_id": "CVE-2022-32323",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "67321b7f",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively validates BMP header fields (magic numbers, biSize, biWidth, biHeight, biPlanes, biBitCnt, biClrUsed, compression type) before proceeding to read image data. It performs sanity checks on dimensions and color usage, directly aligning with the specification's requirement to validate critical header fields before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs integer overflow checks before calculating rowbytes and uses overflow checks for width/height/bit depth combinations. However, it doesn't explicitly guard memory allocation calls (like ReadImage's internal allocations) with pre-validation of all size parameters, though some validation exists.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates biBitCnt against acceptable values (1, 2, 4, 8, 16, 24, 32) and rejects invalid values. It also handles special cases for color maps based on bit depth, enforcing minimum requirements per BMP specification.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code shows initialization of local arrays (buffer, ColorMap) and structures, but the specification about memory allocation initialization doesn't directly apply since the code doesn't show dynamic memory allocation for the main image storage - that happens inside ReadImage which isn't shown.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code uses goto cleanup pattern for error handling, which helps maintain consistent state by centralizing cleanup. However, the image object is initialized early and returned even on errors, though at_bitmap_init(0,0,0,1) creates a minimal valid state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This specification is for network protocol handlers, but the code processes local file input, not network protocols. While input validation principles are similar, the specification specifically mentions network protocols.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates some integer fields against overflow (width, height calculations) and checks for specific dangerous values (-2147483648), but doesn't comprehensively validate all protocol message length fields against platform-specific limits as this is a file parser, not a network protocol handler.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code validates size parameters through overflow checks before calculations that would affect memory usage (rowbytes calculation, width*height checks). It protects against malicious BMPs with integer overflows, though it doesn't show explicit allocation limit checks against system constraints.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-2285_before_exclude_100:a7d01948:spec": {
    "timestamp": "2026-01-20T10:10:51.489884",
    "cve_id": "CVE-2022-2285",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a7d01948",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code processes terminal input sequences, not regular expression patterns. While it does parse character sequences looking for specific patterns (terminal escape codes), it does not use regex engines or handle embedded NUL bytes in the context of regex patterns. The input is treated as a byte stream where NUL may have significance as a terminator, but this is not the primary security concern addressed by HS-INPUT-001.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code extensively processes escape sequences (terminal control sequences starting with ESC or CSI) and must maintain strict boundaries between different sequence types. It validates sequence lengths and checks for partial sequences. However, it's not a \"pattern compiler\" in the traditional sense - it's an interpreter of terminal input sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted terminal input and uses length-aware operations throughout. It consistently checks buffer boundaries (using 'len' variable), validates offsets against buffer sizes, and returns -1 for partial sequences. Functions like STRNCMP with explicit length bounds are used, and there are checks like \"if (len < slen)\" before processing.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code uses stack-allocated arrays (like 'string[MAX_KEY_CODE_LEN + 1]') and local variables that are initialized at declaration or soon after. There are no dynamic memory allocations in this function that would require initialization before use. The security concern about uninitialized memory allocations doesn't apply here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function has multiple error return paths (returning -1, 0, or positive values) and maintains consistency in how it handles partial sequences and invalid input. However, it doesn't manage complex object states - mostly local variables and input buffers. The state consistency is more about the parsing state than object lifecycle management.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code functions as a terminal protocol handler, parsing escape sequences and control codes from terminal input (which can come over network connections in remote sessions). It validates input extensively before processing - checking lengths, validating character ranges, and handling partial sequences. The terminal protocol parsing must be robust against malicious or malformed input.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. While not string formatting in the printf sense, the code builds output strings in the 'string' buffer with bounds checking (MAX_KEY_CODE_LEN). It calculates 'new_slen' and writes within the allocated buffer. The put_string_in_typebuf function (not shown) would need to validate buffer bounds, which is implied but not visible in this code snippet.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does parse numeric values from terminal sequences (e.g., \"atoi((char *)modifiers_start)\") and validates that there's enough input before parsing. However, it's not using format templates like printf, and the numeric parsing is relatively simple. The buffer capacity validation happens earlier in the sequence length checks rather than during numeric conversion specifically.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      }
    ]
  },
  "CVE-2020-7046_before_exclude_100:e491ddc3:spec": {
    "timestamp": "2026-01-20T10:10:52.844541",
    "cve_id": "CVE-2020-7046",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e491ddc3",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not use regular expressions. It parses SMTP command parameters character by character using UTF-8 decoding and character checks. While it processes input, the specification about embedded NUL bytes in regex patterns is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The specification focuses on pattern compilers and escape sequences. This code is a protocol parser that handles raw bytes/characters and UTF-8 sequences, not pattern compilation with escape sequences. The relevance is weak.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted SMTP input. It uses length-aware operations: it tracks buffer boundaries (parser->cur, parser->end), checks `p < parser->end` in the loop, uses `uni_utf8_get_char_n` with a length parameter, and validates the parsed parameter length against `max_size`. This is a core security practice in the code.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates a length (`(uoff_t)(p - parser->cur) > max_size`) against a configured limit (`max_size`), but this is not a protocol message length field extracted from the input. It's a calculated length of a parameter string compared to a policy limit. The specification about validating integer limits of protocol-supplied length fields is not directly addressed here.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code calls `i_strdup_until(parser->cur, mp)` which likely allocates memory. The size of this allocation is derived from parsed input (`mp - parser->cur`). While the code validates this length against `max_size` before allocation (a form of limit validation), it doesn't explicitly show validation against platform allocation limits (e.g., SIZE_MAX) or subsequent usage. The prior length check provides some security.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderately to strongly relevant. The code enforces consistent handling of two data types: regular command parameters (which accept UTF-8) and AUTH responses (treated as raw bytes, not UTF-8). The logic branches with `if (parser->auth_response)` to apply different character validation rules, ensuring type-specific processing is maintained.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Strongly relevant. The code performs buffer length calculations and pointer arithmetic (e.g., `p - parser->cur`, `p - parser->end`). It validates remaining capacity implicitly by checking `p < parser->end` in the loop condition before dereferencing `p`, and explicitly when calling `uni_utf8_get_char_n` with the remaining length. This prevents buffer over-reads.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a core activity of the function. It processes protocol strings (SMTP parameters) while maintaining strict awareness of buffer boundaries (`parser->cur`, `parser->end`). It transforms the input by trimming trailing whitespace and extracting a substring, ensuring operations stay within the calculated bounds (`mp` is derived from `p`, which is bounded by `parser->end`).",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      }
    ]
  },
  "CVE-2020-16305_after_exclude_100:cb3879ce:spec": {
    "timestamp": "2026-01-20T10:10:53.532958",
    "cve_id": "CVE-2020-16305",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cb3879ce",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs pixel offset calculations via pointer arithmetic (`from += step`) and comparisons (`from < end`). It validates against the buffer boundary `end`, which is directly relevant to HS-MEM-001. However, the specification mentions \"Pixel offset calculations\" specifically, and while the code does boundary checks, it doesn't explicitly validate that `step` is positive or that `from + step` won't wrap around, making it moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Pixel offset calculations must validate against buffer boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code involves arithmetic operations like `from - start` and division by `step`. While it checks `from < end` to prevent buffer overrun, it doesn't explicitly validate for integer overflow (e.g., if `step` is very large, `from += step` could overflow). HS-INPUT-002 is about overflow validation in image decoders, which has some application here, but the code's primary focus is RLE encoding, not decoding, reducing direct relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must validate all arithmetic operations for overflow conditions"
      },
      {
        "score": 5,
        "reasoning": "HS-IO-003 is about file decoders validating derived values against image dimensions. This code is an RLE encoding function for PCX format, not a decoder. It writes data to a file but doesn't parse or validate image dimensions. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: File decoders must validate all derived values against image dimensions"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-001 (duplicate ID) specifies string operations validating length fields against buffer capacity. This code deals with byte arrays (pixel data) and RLE encoding, not string operations. The buffer boundary check is similar, but the context is different, leading to low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String operations must validate length fields against remaining buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-002 (duplicate ID) requires complete length validation chains in external format parsers. This code is an encoder, not a parser. It does validate buffer boundaries (`from < end`), but not as part of a parsing validation chain. The relevance is weak due to the encoder vs. parser mismatch.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: External format parsers must implement complete length validation chains"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-001 is about image format parsers validating header fields before processing. This code is an RLE encoding routine that writes pixel data, not a parser that reads headers. It doesn't process any header fields. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-002 requires guarding memory allocation with pre-validation of size parameters. This code does not perform any memory allocation; it writes to a file stream. Relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-003 is specifically for BMP parsers enforcing bit count requirements. This code is for PCX RLE encoding, not BMP parsing. No relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      }
    ]
  },
  "CVE-2019-3813_before_exclude_100:4c97e0ce:spec": {
    "timestamp": "2026-01-20T10:10:53.813480",
    "cve_id": "CVE-2019-3813",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4c97e0ce",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. It is a memory slot translation function for a virtual machine or graphics device.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not involve pattern compilers, escape sequence processing, or any form of text/pattern compilation. It deals with physical to virtual address translation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "Moderate to strong relevance. The function validates several input parameters (group_id, slot_id, generation) against limits (info->num_memslots_groups, info->num_memslots). This aligns with the principle of validating protocol/input fields against defined limits, though the limits are not strictly \"platform-specific integer limits\" but rather internal structural limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The core purpose of the function is to safely translate a guest physical address to a host virtual address. It performs multiple validation steps: checking group_id and slot_id bounds, validating the address generation, and finally calling memslot_validate_virt to check that the requested address range (h_virt with add_size) is within the allocated and valid memory slot. This directly relates to validating size/range parameters against allocation and usage limits.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function ensures type consistency by carefully converting between different address representations (QXLPHYSICAL, unsigned long, void*). It also validates that the abstract \"generation\" field matches between the address and the slot, enforcing a form of state consistency which is a broader interpretation of \"consistent type handling\".",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform memory release operations (free, delete, unmap). It only retrieves and validates a virtual address pointer from a managed memory slot structure.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code does not process file content. It handles in-memory address translation for a virtualization or device protocol.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      }
    ]
  },
  "CVE-2020-16305_before_exclude_100:cc9176e7:spec": {
    "timestamp": "2026-01-20T10:10:54.124211",
    "cve_id": "CVE-2020-16305",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cc9176e7",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs pointer arithmetic and comparisons (e.g., `from < end`, `from == end`, `from - start`) to ensure it stays within the buffer bounds defined by `from` and `end`. This is a form of boundary validation. However, it does not explicitly validate pixel offset calculations against image dimensions or a separate buffer size; it only uses the provided `end` pointer. This provides moderate protection, hence a score of 7.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Pixel offset calculations must validate against buffer boundaries"
      },
      {
        "score": 6,
        "reasoning": "The code involves arithmetic operations like `from - start` and division by `step`. While it checks `from < end` to prevent reading out of bounds, it does not explicitly validate for integer overflow in these calculations (e.g., if `step` is zero or negative, or if pointer differences overflow). The relevance is moderate because overflow could affect loop conditions and run-length calculations, but the code's context (a write function with controlled `step`) may reduce immediate risk.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must validate all arithmetic operations for overflow conditions"
      },
      {
        "score": 3,
        "reasoning": "The code is a PCX encoding (write) function, not a decoder. It writes data to a file based on input buffers but does not parse or validate image dimensions from a file. Specification HS-IO-003 is focused on decoders validating derived values against image dimensions, which is not applicable here. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: File decoders must validate all derived values against image dimensions"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve string operations or length fields. It processes byte data for RLE encoding, using pointer arithmetic to track buffer capacity via `end`. Specification HS-MEM-001 (string version) is not directly applicable, though the general concept of buffer capacity validation is partially present. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String operations must validate length fields against remaining buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "The code handles external format (PCX) encoding and includes some validation (buffer bounds). However, it does not implement a \"complete length validation chain\" as required for parsers; it assumes input pointers (`from`, `end`) are already valid. Weak relevance because it's an encoder, not a parser, and validation is minimal.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: External format parsers must implement complete length validation chains"
      },
      {
        "score": 5,
        "reasoning": "The code is an image encoder (writing PCX data), not a parser reading headers. It does not validate any header fields. Specification HS-INPUT-001 is for parsers validating critical header fields before processing. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform any memory allocation; it writes data to a file using `gp_fputc`. Specification HS-MEM-002 is about guarding memory allocation with size parameter validation, which is not applicable here. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "The code is for PCX format encoding, not BMP parsing. Specification HS-PROTOCOL-003 is specific to BMP parsers and bit count requirements, which has no relation to this code. Not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      }
    ]
  },
  "CVE-2021-3416_after_exclude_100:19e24b34:spec": {
    "timestamp": "2026-01-20T10:11:00.295109",
    "cve_id": "CVE-2021-3416",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "19e24b34",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It handles DMA descriptors and packet data, not pattern matching with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not process escape sequences or compile patterns. It is a network packet transmission function dealing with hardware descriptors and memory operations.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code reads data from DMA memory using length-aware operations (tx_desc_get_length). However, it operates on trusted hardware descriptors rather than arbitrary untrusted strings, and uses explicit length parameters in address_space_read.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates the descriptor length field against maximum buffer size (gem_get_max_buf_len) and checks for zero length. This directly corresponds to validating protocol (descriptor) length fields against platform limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. While not performing dynamic memory allocation, the code validates that the descriptor length fits within the pre-allocated tx_packet buffer, which is conceptually similar to validating size parameters against usage requirements.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code maintains consistent handling of descriptor data types (uint32_t arrays, hwaddr addresses) but doesn't involve complex protocol type conversions that would require strict consistency enforcement.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs critical validation of network-derived length values (tx_desc_get_length) for both range (checking against max buffer) and sign (implicitly as unsigned). This is exactly what HS-INPUT-001 specifies for network-derived length values.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates descriptor fields against buffer space remaining, which is analogous to validating variable-length fields against remaining message length. However, it's not parsing protocol options in the traditional sense.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2022-24950_before_exclude_100:9d93cf84:spec": {
    "timestamp": "2026-01-20T10:11:01.381886",
    "cve_id": "CVE-2022-24950",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d93cf84",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code creates a Unix domain socket server and does not process any protocol messages with length fields. The specification about validating message length fields is not applicable to this socket creation and binding logic.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation operations. It uses standard library containers and system calls for socket operations, but no custom memory allocation that requires validation of size parameters.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code establishes a socket but does not implement any protocol processing. There is no protocol type handling to enforce consistency across processing stages in this code snippet.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code uses strcpy() to copy the pipe path into local.sun_path without checking if the path fits within the buffer. This is a potential buffer overflow if pipePath is too long for sun_path. However, sun_path size is platform-defined and the code doesn't validate the length.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before writing"
      },
      {
        "score": 3,
        "reasoning": "The code does not generate protocol messages or write to output buffers. It only sets up a listening socket, so this specification about message generation buffer validation is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: All protocol message generation must validate output buffer capacity"
      },
      {
        "score": 3,
        "reasoning": "The code does not implement marker segment writers or any protocol parsing that would require boundary validation. This is socket setup code, not protocol processing code.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Marker segment writers must enforce strict boundary validation"
      },
      {
        "score": 5,
        "reasoning": "Weakly relevant. While the code doesn't fork processes, it creates file descriptors (sockets) that would need to be managed properly if forking occurred elsewhere in the program. The specification about file descriptor isolation during forking is only indirectly related to this socket creation code.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Process forking must ensure complete resource isolation by closing or marking all non-sh..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code creates a Unix domain socket and sets file permissions (chmod) to restrict access to the owner only. This directly addresses protecting network sockets (specifically Unix domain sockets) from unintended access by rogue processes. The chmod call with S_IRUSR | S_IWUSR | S_IXUSR ensures only the owner can access the socket file.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: Network sockets must be protected from unintended access by rogue processes"
      }
    ]
  },
  "CVE-2022-24950_after_exclude_100:fe35bf74:spec": {
    "timestamp": "2026-01-20T10:11:02.070616",
    "cve_id": "CVE-2022-24950",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fe35bf74",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code creates a Unix domain socket server and does not handle protocol messages with length fields. Specification HS-INPUT-001 is about validating message length fields in protocols, which is not applicable here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation operations. It uses standard library containers and system calls for socket operations, but no custom allocation with size parameters is present.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code does not implement a protocol with type handling. It sets up a socket server but does not define or process any protocol messages where type consistency would be a concern.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses `strncpy` to copy the pipe path into the `sun_path` buffer with a size limit (`sizeof(local.sun_path)`), which is a buffer write operation with space validation. However, `strncpy` does not guarantee null-termination if the source is too long, which is a potential issue.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before writing"
      },
      {
        "score": 5,
        "reasoning": "The code does not generate protocol messages or write to output buffers in the context of a protocol. It sets up a socket server, but message generation is not part of this function.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: All protocol message generation must validate output buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve marker segment writers or boundary validation for data segments. It is about socket creation and binding, not protocol data handling.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Marker segment writers must enforce strict boundary validation"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code creates a file descriptor (socket) but does not involve process forking. However, if this socket were used in a forked process, proper handling of file descriptors would be important, but that is not shown here.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Process forking must ensure complete resource isolation by closing or marking all non-sh..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code creates a Unix domain socket (network socket in a broader sense) and uses `chmod` to set permissions (S_IRUSR | S_IWUSR | S_IXUSR) to protect it from unintended access by rogue processes. This directly aligns with HS-IO-002's goal of protecting sockets from unauthorized access.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: Network sockets must be protected from unintended access by rogue processes"
      }
    ]
  },
  "CVE-2022-1507_before_exclude_100:6bcc844a:spec": {
    "timestamp": "2026-01-20T10:11:05.393457",
    "cve_id": "CVE-2022-1507",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6bcc844a",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code extensively parses GIF file format fields (image descriptor, offsets, dimensions, color table size). It performs range validation (e.g., checking offset_x + width <= gif->width, offset_y + height <= gif->height) and validates field values against expected constants (GIF_IMAGE_SEPARATOR). This directly addresses HS-LOGIC-001's requirement to validate numeric fields for correct range and semantics.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 7,
        "reasoning": "The code processes image data through bounded loops (for y in height, while x > 0) where height and width are validated earlier. The LZW decoding uses a burst mechanism but includes checks to prevent overrun. However, the primary iteration bounds (width, height) are derived from untrusted input and validated, making this moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 8,
        "reasoning": "The function maintains parser state (buffer_position, decoded_frame) and validates intermediate states through multiple checks: verifying sufficient data before proceeding, checking for GIF_TRAILER, validating image descriptor presence, and handling disposal methods. State consistency is checked before operations (e.g., ensuring frame is in range).",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 3,
        "reasoning": "The code does not directly perform memory allocation. It obtains a buffer via bitmap_get_buffer callback. While it initializes local variables and may clear frame buffers with memset, this is not about allocation initialization. The specification is only loosely related as the code assumes the callback provides a valid buffer.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Error handling uses goto gif_decode_frame_exit to centralize cleanup, restoring buffer_position and updating frame state (opaque, virgin flags) consistently. The function maintains object state (gif structure) across error paths, ensuring state consistency before returning.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "The code is a GIF file parser, not a network protocol handler. While both involve parsing untrusted data, the specification specifically mentions network protocols. Input validation occurs, but the context is file parsing, making relevance very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code validates length-like fields (width, height, colour_table_size) against buffer sizes and image boundaries, but not specifically against platform integer limits (e.g., overflow in calculations like offset_x + width). Some size validations exist (e.g., gif_bytes checks), but not comprehensive integer overflow validation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 4,
        "reasoning": "The code does not perform direct memory allocation; it uses callbacks. However, it validates size parameters before operations (e.g., checking gif_bytes before reading colour_table, ensuring width/height fit within bounds). This relates to validating usage requirements but not allocation limits directly.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2012-3517_after_exclude_100:5d32c165:spec": {
    "timestamp": "2026-01-20T10:11:05.751145",
    "cve_id": "CVE-2012-3517",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5d32c165",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates integer fields (vote_seconds, dist_seconds, dir_port, or_port, consensus_method) against platform limits using tor_parse_long with explicit bounds (0-INT_MAX, 0-65535, 1-INT_MAX). This directly addresses protocol message length/field validation against integer limits.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "The code performs memory allocation with tor_malloc_zero and smartlist_create, but doesn't explicitly validate size parameters against allocation limits. However, it does validate integer inputs before potential usage in allocations (e.g., tok->object_size bounds check before tor_memdup). Some relevance exists but not comprehensive.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 9,
        "reasoning": "The code strictly enforces type consistency: validates ns_type vs ns->type, checks flavor compatibility (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS), verifies vote/consensus/opinion types, and ensures directory signature object types match expectations. Directly addresses protocol type handling.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code extensively validates structural requirements before processing: checks for required tokens (K_VOTE_STATUS, K_VALID_AFTER, etc.), validates token ordering (known_flags, params), verifies minimum voter counts, and checks time interval constraints. Directly implements pre-processing validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate minimum structural requirements before processing"
      },
      {
        "score": 1,
        "reasoning": "The code does not process DNS records at all. It parses network status votes/consensus documents, not DNS protocol data. No relevance to DNS field boundary validation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: DNS record processing must enforce strict field boundary validation"
      },
      {
        "score": 8,
        "reasoning": "The code performs bounds checking: validates hex digest lengths (HEX_DIGEST_LEN), checks tok->object_size bounds before memory operations, uses strcmpstart with length awareness, and validates string lengths before base16_decode operations. Directly addresses memory bounds verification.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Memory operations must verify bounds against actual available data"
      },
      {
        "score": 1,
        "reasoning": "The code does not use regular expressions. It uses tokenization and string parsing functions but no regex patterns with potential NUL byte issues.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain pattern compilers or escape sequence processing. It uses escaped() for logging but doesn't compile patterns with escape sequences.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-43804_before_exclude_100:32a4bcbb:spec": {
    "timestamp": "2026-01-20T10:11:09.957048",
    "cve_id": "CVE-2021-43804",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "32a4bcbb",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses a length field from the RTCP packet (byte at offset 8) without validating it against the maximum buffer size (sizeof(sess->stat.peer_sdes_buf_)) before the PJ_MIN operation. While PJ_MIN provides some protection, the length field itself should be validated against platform integer limits and the actual available packet size (size parameter) to prevent integer overflow/wrap-around issues. The specification directly addresses this type of vulnerability.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs a memory copy operation using a length derived from untrusted input. While it uses PJ_MIN to limit the copy size to the buffer size, it doesn't validate that the source packet actually contains enough data for the copy operation (checking size > 8 + reason.slen). This relates to validating size parameters against usage requirements.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles protocol data (RTCP BYE packet) with type casting of byte pointers. While there's some consistency in using pj_uint8_t, the specification about consistent type handling across all processing stages is only loosely related as the code snippet shows limited processing stages.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This specification about regular expression parsers and NUL bytes is completely unrelated to the RTCP packet parsing code which doesn't use regular expressions.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This specification about pattern compilers and escape sequences is not applicable to the RTCP packet parsing code which doesn't involve pattern compilation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code processes untrusted input (network packet) and uses pj_memcpy with a length-aware approach via PJ_MIN. However, it could be more robust by ensuring the source buffer has sufficient data and by using explicit bounds checking. The specification directly addresses the security concerns in this string/memory processing code.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code appears to be processing a single packet in what seems to be a session-specific context. There's no indication of shared buffer access or concurrent operations in this static function, though the session object might be shared elsewhere.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared buffer access must be protected by appropriate synchronization primitives"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes an RTCP BYE message but doesn't show terminal state transitions or concurrent operations. This appears to be a simple parsing and logging function without state management concerns visible in the snippet.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Terminal state transitions must maintain consistency invariants during concurrent oper..."
      }
    ]
  },
  "CVE-2022-23567_before_exclude_100:17fc5fb0:spec": {
    "timestamp": "2026-01-20T10:11:10.829956",
    "cve_id": "CVE-2022-23567",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "17fc5fb0",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor operations (addition, division, etc.) and does not involve any cryptographic operations on secret values. It is a numerical computation kernel with no timing-sensitive secret data handling.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve operations or any cryptographic implementations. It is purely a numerical linear algebra operation for tensor processing.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "No secure memory operations or cryptographic processing is present. The code manipulates tensor data in a standard computational manner without constant-time requirements.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 8,
        "reasoning": "The code performs multiple bounds checks before writing operations. It validates indices against tensor dimensions using FastBoundsCheck, checks for division by zero, and validates tensor shape compatibility, which aligns with the spirit of validating available space before writing.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before writing"
      },
      {
        "score": 7,
        "reasoning": "While not dealing with protocol messages, the code validates output buffer capacity through ctx->allocate_output() calls and performs extensive input validation before computation, which is conceptually similar to validating output buffer capacity.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: All protocol message generation must validate output buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Marker segment writers must enforce strict boundary validation"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively validates input ranges through multiple OP_REQUIRES checks, handles edge cases explicitly (division by zero, empty shape, dimension mismatches), and validates indices against tensor bounds. This directly addresses mathematical computation safety.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      }
    ]
  },
  "CVE-2022-23567_after_exclude_100:90260a88:spec": {
    "timestamp": "2026-01-20T10:11:11.629669",
    "cve_id": "CVE-2022-23567",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "90260a88",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs sparse tensor operations (addition, division, etc.) and does not involve any cryptographic operations on secret values. The specification is about constant-time execution for cryptography, which is completely unrelated to this numerical computation code.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or any cryptographic operations. It's purely numerical tensor manipulation for machine learning operations.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "While the code does memory operations, they are not cryptographic in nature. The specification specifically addresses maintaining constant-time properties during cryptographic processing, which doesn't apply here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 7,
        "reasoning": "The code performs buffer write operations and includes validation before writing. It checks indices bounds with FastBoundsCheck and validates tensor dimensions before operations. However, it's not specifically about buffer overflow prevention in the traditional sense.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before writing"
      },
      {
        "score": 6,
        "reasoning": "The code validates output buffer capacity through OP_REQUIRES_OK(ctx, ctx->allocate_output(...)) which ensures sufficient space. While not exactly \"protocol message generation,\" the principle of validating output buffer capacity before writing is present.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: All protocol message generation must validate output buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "The code performs boundary validation for tensor indices (FastBoundsCheck) and validates tensor shapes/dimensions. While not about \"marker segment writers,\" the concept of enforcing strict boundary validation is relevant to the index checking in the tensor operations.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Marker segment writers must enforce strict boundary validation"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively validates input ranges and handles edge cases: checks tensor shapes, dimensions matching, indices bounds, division by zero prevention, and validates that indices are within bounds of the dense tensor dimensions. This is exactly what the specification addresses.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Mathematical computations must validate input ranges and handle edge cases explicitly"
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code validates structural constraints (tensor shapes, dimensions, indices) before computation, similar to how codebook processing would validate structural constraints. However, this is not specifically about codebook processing.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Codebook processing must validate structural constraints before computation"
      }
    ]
  },
  "CVE-2022-1198_after_exclude_100:0b994407:spec": {
    "timestamp": "2026-01-20T10:11:15.479306",
    "cve_id": "CVE-2022-1198",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0b994407",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process userspace-provided array lengths. It is a cleanup function for a network device, dealing with internal resource deallocation and state management, not input validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 3,
        "reasoning": "The code does not handle protocol messages. It is a close/destructor function that unregisters a network device, stops timers, and frees internal buffers.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code frees buffers (`sp->rbuff`, `sp->xbuff`), it does not show their allocation. The specification is about allocation with size limits, which is not visible in this snippet. The deallocation is correct, but the core guidance of the spec is not addressed here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code is for a Sixpack (serial line) network protocol, not USB request processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code is not related to USB/IP protocol implementation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not handle USB request state transitions.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: USB request state transitions must maintain consistent buffer-length relationships"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code uses a lock (`disc_data_lock`) to atomically retrieve and clear the `tty->disc_data` pointer. This is a critical check-and-set operation during resource teardown to prevent concurrent access to the `sixpack` structure during its destruction.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function manages the shared state transition of the `sixpack` structure from active to destroyed. It uses a lock to atomically sever the connection from the TTY, employs a refcount and completion (`sp->dead`) to wait for existing users, and stops the network queue before freeing resources. This ensures consistency invariants are maintained across all access paths during shutdown.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2021-41216_after_exclude_100:9d14bbe4:spec": {
    "timestamp": "2026-01-20T10:11:15.774342",
    "cve_id": "CVE-2021-41216",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d14bbe4",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a TensorFlow shape inference function for a transpose operation. It does not involve database views, privilege checks, or any access control mechanisms related to view owners. The specification is about database security and is completely unrelated to this numerical tensor manipulation code.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The code performs state transitions related to shape inference (from unknown to known dimensions), but these are not security-critical state transitions involving privilege contexts. The specification appears to be about system security states and privilege levels, which don't apply to this tensor shape calculation logic.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code has no SQL protocol implementation, no database operations, and no view security semantics. This is purely numerical tensor processing code for machine learning operations, completely unrelated to SQL or database security.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "The code does involve memory allocation indirectly through std::vector resizing and shape dimension handling. While not explicitly performing raw memory allocation, it manages collections of dimension handles. However, the specification's focus on \"consistent size tracking\" is only loosely related to the vector resizing operations in this code.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 4,
        "reasoning": "The code maintains consistency in shape inference (ensuring input rank matches permutation size, validating indices are within bounds). This relates to maintaining invariants in resource (shape) management, but the connection is weak as the specification seems broader and more security-focused than this numerical validation logic.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 1,
        "reasoning": "The code contains no regular expression parsing. It processes tensor dimensions and permutation indices, but uses no regex patterns or parsers. The specification is completely inapplicable.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code has no pattern compilers, no escape sequence processing, and no string pattern compilation. It processes numerical data from tensors, not textual patterns with escape sequences.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "The code processes potentially untrusted input (permutation tensor data) and performs bounds checking (in_idx >= rank || in_idx <= -rank). While not strictly string processing, it does handle external data with length-aware operations (checking indices against rank bounds). The connection is moderate as the core security principle of validating bounds on external input applies.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2022-1198_before_exclude_100:492c4252:spec": {
    "timestamp": "2026-01-20T10:11:17.020290",
    "cve_id": "CVE-2022-1198",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "492c4252",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process userspace-provided array lengths. It is a driver close function that manages internal cleanup, timers, and network device deregistration. There is no direct input validation against system constraints here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The code is not a protocol message handler. It is a cleanup routine for a network device using the sixpack protocol. While the sixpack protocol likely has message handlers elsewhere, this function does not validate variable-length components.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function frees buffers (`sp->rbuff`, `sp->xbuff`) but does not allocate them. The allocation with size limits would occur elsewhere in the driver. However, proper cleanup is related to memory safety, but the specification is about allocation, not deallocation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is for a sixpack serial line protocol, not USB. It does not process USB requests or validate USB buffer presence.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is for the sixpack protocol (used over serial lines), not USB/IP. It does not validate USB/IP packet structures.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code manages state for a network device and timers, not USB request state transitions or buffer-length relationships for USB.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: USB request state transitions must maintain consistent buffer-length relationships"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses a lock (`disc_data_lock`) to atomically check and set `tty->disc_data` to NULL. This is a critical concurrent resource (the `disc_data` pointer) initialization/cleanup operation performed under lock to prevent race conditions during close.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function manages shared state transitions (the `sp` object's lifecycle) using a refcount (`sp->refcnt`) and a completion (`sp->dead`). It ensures consistency by waiting for all existing users to finish (`wait_for_completion`) before proceeding with cleanup (stopping queue, deleting timers, unregistering netdev, freeing buffers). This maintains consistency invariants across access paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2021-41216_before_exclude_100:04f04d4a:spec": {
    "timestamp": "2026-01-20T10:11:17.301410",
    "cve_id": "CVE-2021-41216",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "04f04d4a",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a TensorFlow shape inference function for a transpose operation. It does not involve database views, view-based data access, or privilege checks. The specification is about database security and is not applicable to this tensor manipulation code.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 3,
        "reasoning": "The code performs state transitions related to shape inference (e.g., from unknown to known rank/dimensions), but these are not security-critical privilege context transitions. The primary concern is correctness and error handling, not security privilege consistency. The connection is very weak.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The specification is specifically about SQL protocol implementations and view security semantics. This C++ code is for tensor shape inference in a machine learning framework and has no relation to SQL, databases, or view security.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "The code resizes a vector (`dims.resize(rank)`) based on a calculated rank. There is a weak relevance because if the `rank` value were maliciously large or incorrect, it could lead to excessive memory allocation. However, the code does check bounds for permutation indices (`if (in_idx >= rank)`), and the primary memory operation is not the core security focus of the specification.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 4,
        "reasoning": "The code manages resources (shape handles, dimension handles) and must maintain invariants (e.g., output rank equals input rank, permutation indices are valid). There is a loose relationship to maintaining invariant consistency during these operations, but it's not the primary security focus of the code, which is more about validation and error handling.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain any regular expression parsing. It parses tensor data and permutation arrays, but not regex patterns. The specification is completely unrelated.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not contain a pattern compiler or process escape sequences. It handles integer arrays from tensors. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 6,
        "reasoning": "This has moderate relevance. The function processes a permutation tensor (`perm`) which could be considered untrusted input. It correctly uses the tensor's `NumElements()` and `dtype()` methods, and the `AsInt64` helper function (assumed to be bounds-aware) to safely extract data. It also performs a critical bounds check (`if (in_idx >= rank)`) to prevent out-of-bounds access. This aligns with the spirit of using length-aware operations and validating inputs, though it's not specifically about string processing.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2022-38150_before_exclude_100:e9d4ec47:spec": {
    "timestamp": "2026-01-20T10:11:17.529396",
    "cve_id": "CVE-2022-38150",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e9d4ec47",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It searches for a colon character in a header string using strchr, which is a simple string operation, not regex pattern matching with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile patterns or process escape sequences. It performs basic string searching and header flag lookup without any pattern compilation logic.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code uses strchr on fm->hd[u].b without explicit length validation. If this string is untrusted and not properly NUL-terminated, strchr could read beyond allocated memory. Using length-aware operations (like memchr with known length) would be more secure.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not process protocol message length fields. It checks HTTP header filtering status and examines header content, but doesn't parse or validate length fields from protocol messages.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform memory allocation operations. It only accesses existing data structures and calls string/search functions without allocating memory.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes HTTP headers and maintains consistency in how header flags are checked. While not directly about type handling, it does enforce consistent processing of header filtering logic across the protocol implementation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code accesses buffer fm->hd[u].b without explicit boundary validation. While it assumes proper NUL-termination, validating buffer boundaries before access (especially for untrusted input) would improve security. The strchr operation could potentially read beyond valid memory if the string isn't properly terminated.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code parses HTTP header content and maintains buffer state through the struct http. While it doesn't show complex parser state management, it does work with buffer data (fm->hd[u].b) and should maintain consistent invariants about buffer content and structure.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2019-3813_after_exclude_100:30ecb4a2:spec": {
    "timestamp": "2026-01-20T10:11:19.235599",
    "cve_id": "CVE-2019-3813",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "30ecb4a2",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It is a memory slot virtualization function that translates physical addresses to virtual addresses. The specification about embedded NUL bytes in regex patterns is not applicable.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not involve pattern compilers or processing of escape sequences. It handles memory address translation and validation, which is unrelated to the specification's focus on pattern compilation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The function processes an input address and size (add_size) to validate and compute a virtual address. While not about string functions, it does perform bounds checking via memslot_validate_virt, which aligns with the principle of length-aware operations for untrusted input (the addr and add_size parameters could be considered untrusted).",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code validates several input parameters against limits: group_id against info->num_memslots_groups, slot_id against info->num_memslots, and add_size is used in memslot_validate_virt. This directly corresponds to validating protocol/input length fields against defined limits to prevent out-of-bounds access.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code does not perform memory allocation itself. However, it validates that a computed virtual address range (based on add_size) is within a valid memory slot. This is a form of validating that a \"size parameter\" (add_size) meets usage requirements (fits within the slot's mapped memory), which is related to the spirit of the specification.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function ensures the address generation matches the slot's generation, which is a type of consistency check. However, the specification \"consistent type handling across all processing stages\" is broad and primarily aimed at protocol data type interpretation, which is not the main focus of this low-level memory translation code.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform memory release operations (free, delete, unmap). It only retrieves and validates a virtual address. The specification about ownership semantics during release is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code does not process file content. It deals with in-memory address translation for a virtualized device (likely a QXL graphics card). The specification about file edge cases is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      }
    ]
  },
  "CVE-2022-32546_before_exclude_100:ca7f2f65:spec": {
    "timestamp": "2026-01-20T10:11:19.799030",
    "cve_id": "CVE-2022-32546",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ca7f2f65",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses memset to initialize several structures (bounding_box, bounds, page, command) before use, which aligns with the specification. However, there are other local variables (e.g., geometry, input_filename arrays) that are not explicitly initialized before being passed to functions like FormatLocaleString or AcquireUniqueSymbolicLink, though they may be fully written before read. The initialization is good but not complete for all memory, leading to moderate relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code shows consistent error handling paths that maintain object states. For example, when status is MagickFalse after AcquireUniqueSymbolicLink, it calls ThrowFileException and destroys the image before returning NULL. Similar cleanup (DestroyImage, DestroyImageInfo, RelinquishUniqueFileResource) is performed in other error paths. This demonstrates strong adherence to consistent state management during failures.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2021-40153_before_exclude_100:153036c0:spec": {
    "timestamp": "2026-01-20T10:11:20.641577",
    "cve_id": "CVE-2021-40153",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "153036c0",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs arithmetic operations (e.g., `bytes += (*i)->offset`, `size = (*i)->data + bytes - 3`, `bytes += dire->size + 1`) that could overflow if inputs are malicious/corrupted. While some checks exist (e.g., `dir_count > SQUASHFS_DIR_COUNT`, `dire->size >= SQUASHFS_NAME_LEN`), there is no explicit validation of type boundaries (e.g., ensuring sums don't exceed buffer/table limits) before calculations, making this specification highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 9,
        "reasoning": "The code parses filesystem structures (directory headers, entries) and validates some structural fields against constraints (e.g., dir_count against SQUASHFS_DIR_COUNT, dire->size against SQUASHFS_NAME_LEN). However, it could be more comprehensive (e.g., validating start_block, offset). This directly aligns with the specification's requirement to validate structural fields against physical constraints.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 9,
        "reasoning": "The code performs bounds checking for on-disk structures (e.g., checking dir_count and dire->size). However, it lacks explicit validation that `bytes` and `size` remain within the bounds of `directory_table` memory region. This is a core security concern for filesystem parsers, making the specification strongly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 5,
        "reasoning": "The code initializes the `dir` struct members after malloc, and `buffer` is stack-allocated. However, `buffer` is not explicitly initialized before use (though it's filled via memcpy). The specification about initializing memory allocations before use has weak relevance here, as the primary security issues are not uninitialized memory use.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has a `corrupted:` error handling path that frees `dir->dirs` and `dir` before returning NULL. However, if `realloc` fails, it calls `EXIT_UNSQUASH` (likely terminating), which may not maintain consistent state for other parts of the program. The specification is moderately relevant as error handling exists but could be more consistent.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol handlers, but the target code is a filesystem parser (SquashFS). The validation principles are similar, but the context is entirely different (filesystem vs. network). Therefore, relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code declares `buffer` with `__attribute__((aligned))`, ensuring proper alignment for the `squashfs_dir_entry` structure. This directly addresses platform alignment requirements, making the specification highly relevant and correctly applied.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol implementations, while the code is a filesystem parser. Although both involve parsing structured data, the domain and threat models differ significantly. Relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      }
    ]
  },
  "CVE-2021-40153_after_exclude_100:667fbade:spec": {
    "timestamp": "2026-01-20T10:11:21.215641",
    "cve_id": "CVE-2021-40153",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "667fbade",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs arithmetic operations like `bytes += (*i)->offset;` and `size = (*i)->data + bytes - 3;` without explicit validation against integer overflow or underflow before use in memory accesses or loop conditions. Specification HS-LOGIC-001 is moderately relevant as these calculations could lead to security issues if inputs are malicious, but the code does have some bounds checks later (e.g., `dir_count > SQUASHFS_DIR_COUNT`).",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code is a filesystem parser that validates structural fields from disk: it checks `dir_count` against `SQUASHFS_DIR_COUNT`, validates `dire->size` against `SQUASHFS_NAME_LEN`, and checks for invalid characters in names. This directly aligns with HS-INPUT-002's requirement to validate structural fields against physical constraints.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs bounds checking for on-disk structures: it validates `dir_count` and `dire->size` before using them to calculate memory offsets and copy operations. It also ensures `dire->name` buffer usage respects size limits. This matches HS-IO-003's focus on strict bounds checking for filesystem structures.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem operations must enforce strict bounds checking for all on-disk structures"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. While the code uses `malloc` and `realloc`, it does initialize the `dir` struct fields after allocation. However, the `buffer` array is not explicitly initialized (though it's filled via `memcpy` later). HS-MEM-001 is only loosely applicable as major allocated structures are initialized before use.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code has a `corrupted:` error handling path that frees `dir->dirs` and `dir` before returning NULL, maintaining consistent state by preventing memory leaks. However, it doesn't handle all possible error paths (e.g., `realloc` failure calls `EXIT_UNSQUASH` which may exit abruptly). Overall, it demonstrates awareness of state consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. HS-IO-003 is about network protocol handlers validating input, but this code is a filesystem parser, not a network protocol handler. The validation principles are similar, but the context is completely different.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code declares `buffer` with `__attribute__((aligned))`, showing consideration for platform alignment requirements when accessing structured data from disk. This aligns with HS-MEM-001's focus on alignment, though it's a single instance rather than comprehensive memory operation handling.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. HS-PROTOCOL-002 specifically addresses network protocol implementations, while this code is a filesystem parser. Although both involve parsing structured data, the domain and attack vectors differ significantly.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      }
    ]
  },
  "CVE-2022-25139_after_exclude_100:af4cfa76:spec": {
    "timestamp": "2026-01-20T10:11:21.595674",
    "cve_id": "CVE-2022-25139",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "af4cfa76",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve parsing regular expressions or handling input patterns with embedded NUL bytes. It is focused on managing asynchronous execution context and frame switching within a VM.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not involve pattern compilation or processing escape sequences. It deals with VM frame management, function calls, and error handling for async/await operations.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the code handles values and could process strings indirectly, there are no explicit string operations shown. The primary operations are frame pointer manipulation, value assignment, and function calls.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code does not parse protocol messages or validate length fields. It operates on internal VM structures for async context management.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code manipulates VM frame pointers and context structures, which could involve memory safety if boundaries are not respected. However, no explicit memory allocation or size validation is visible in this snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles type checking (njs_is_error) and maintains consistency in VM state during async transitions. While not a network protocol, the internal VM protocol for async operations requires consistent type handling.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 7,
        "reasoning": "The code switches between different VM frame contexts and must ensure proper initialization of frame pointers and scope values. Inconsistent initialization could lead to use of uninitialized pointers or values.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code contains multiple error handling paths (failed label, different return codes) that must maintain consistent VM state. It carefully restores previous frame pointers and levels on both success and error paths, which is critical for security.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-40567_after_exclude_100:9fdcdd99:spec": {
    "timestamp": "2026-01-20T10:11:21.928427",
    "cve_id": "CVE-2021-40567",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9fdcdd99",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `gf_malloc` for `esd->URLString` without explicit initialization of the newly allocated memory. While `strcpy` immediately follows, ensuring the string portion is initialized, the memory allocation itself is not fully initialized before use, which could leave padding bytes uninitialized. This is relevant to HS-MEM-001.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error paths (e.g., returning GF_BAD_PARAM, GF_NOT_SUPPORTED). It partially maintains state by cleaning SDP lines at the start and adding lines conditionally. However, the handling of the `iod` object and its ESDescriptors list in error scenarios (like when `is_ok` becomes false) could leave the file in an inconsistent state, as some ESDescriptors may have been added before the error is detected.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not process protocol message length fields. It deals with sample data lengths and buffer sizes, but not in the context of parsing network protocol messages with length fields. Therefore, HS-INPUT-001 has very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory based on string lengths (`strlen(sdpLine)+1`). It does not explicitly validate these size parameters against allocation limits (like maximum heap size) before calling `gf_malloc`. However, the sizes are derived from controlled data (formatted strings and base64 encoded data), not directly from user input. There is a potential risk if `sdpLine` becomes excessively large, but the code uses fixed-size buffers (buf64[5000]) earlier, which indirectly limits the size. Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different media types (OD, Scene, Audio, Visual) and ensures ISMA compliance by checking stream types and object type indications. It enforces consistency in the types of streams allowed (e.g., only one MPEG-4 visual max). This relates to consistent type handling, but it's more about media format compliance than low-level protocol type safety. Weak to moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code uses fixed-size stack buffers (`buf64[5000]`, `sdpLine[5100]`) for base64 encoding and string formatting. It checks if base64 encoding fits within 2000 bytes (`gf_base64_encode(..., buf64, 2000)`), but the buffer is actually 5000 bytes, providing a safety margin. However, the `sprintf` calls into `sdpLine` could potentially overflow if the formatted string exceeds 5100 bytes, though the input data is bounded by `buf64` size. Weak relevance because buffer sizing is present but not thoroughly validated for all operational cases.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform image compression operations. It deals with MP4 file hinting, SDP generation, and base64 encoding of sample data. HS-IO-004 is not applicable to this code.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2021-40567_before_exclude_100:d297b14e:spec": {
    "timestamp": "2026-01-20T10:11:22.213616",
    "cve_id": "CVE-2021-40567",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d297b14e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via gf_malloc for esd->URLString but does not show explicit initialization of the entire allocated buffer beyond the strcpy. The strcpy copies a null-terminated string, which initializes the bytes it writes, but the specification about full initialization before use is relevant. However, the allocation size is precisely strlen(sdpLine)+1, and strcpy copies the entire source string including the null terminator, so the buffer is fully initialized for its intended use. The relevance is strong because the pattern of allocating based on a calculated size and then copying is present, and any miscalculation could lead to uninitialized memory.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error paths (e.g., returning GF_BAD_PARAM, GF_NOT_SUPPORTED, early returns). It modifies the file's internal state (e.g., gf_isom_sdp_add_line, gf_isom_set_extraction_slc) and allocates memory. If an error occurs after some modifications but before full completion, the function may leave the file object in an inconsistent state. For example, if memory allocation fails after adding SDP lines, the file may have partial SDP data. The code does not show rollback mechanisms. This is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "The code is part of a hinter/finalizer for an ISO file, generating SDP lines and embedding base64-encoded data. It does not directly handle network protocol input; it processes local file structures and parameters. Network protocol validation is not a primary concern here, though the generated SDP may be used in network contexts. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 2,
        "reasoning": "The code does not parse protocol message length fields from external sources. It deals with internal media sample sizes and base64 encoding, but there is no validation of length fields against integer limits in a protocol parsing sense. Not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "The code allocates memory based on string lengths (e.g., strlen(sdpLine)+1). It does not explicitly validate these size parameters against allocation limits (e.g., maximum buffer size) or subsequent usage requirements. The buffer buf64 is fixed at 5000 bytes, and gf_base64_encode uses a limit of 2000, but there is no check if the encoded data fits. This could lead to buffer overflows. Moderate relevance because size calculations are present but not thoroughly validated.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles various MPEG-4 object types and stream types (e.g., GF_STREAM_OD, GF_STREAM_SCENE, GF_STREAM_VISUAL, GF_STREAM_AUDIO). It ensures consistency in IOD profile handling (ISMA strict vs. ISMA). However, the specification about protocol type handling across all stages is more about network protocols. Weak relevance because the code deals with media types and descriptors, which are a form of type system, but not network protocol types.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "The code does not perform image compression operations. It deals with MPEG-4 file hinting, SDP generation, and base64 encoding. Not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2022-1507_after_exclude_100:efc03026:spec": {
    "timestamp": "2026-01-20T10:11:27.944104",
    "cve_id": "CVE-2022-1507",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "efc03026",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code extensively parses GIF file format fields (image descriptor, offsets, dimensions, color table size). It performs several range checks: validating offset_x+width and offset_y+height against gif->width/height, checking gif_bytes against required minimums, and ensuring colour_table_size doesn't cause out-of-bounds reads. However, it could be more thorough with signedness validation (e.g., ensuring offsets/dimensions aren't negative when interpreted as signed values).",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 5,
        "reasoning": "The code processes image data through bounded loops (y < height, x > 0) and uses lzw_decode which should internally manage iteration bounds. The \"burst\" mechanism processes chunks of data but maintains bounds checking. However, the specification is about input data processing generally, and this is an image decoder, so it's relevant but the implementation appears to have reasonable bounds.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 5,
        "reasoning": "The function maintains parser state through gif->buffer_position, gif->decoded_frame, and frame disposal states. It validates intermediate states: checking if frame > gif->frame_count_partial, verifying frame display flag, checking for sufficient data before proceeding to next parsing stage. Error paths use goto to maintain cleanup consistency.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 5,
        "reasoning": "The code initializes local variables and uses memset to clear frame_data. Colour table entries are fully initialized (RGBA). However, the specification primarily addresses heap allocations, and most memory here is managed through callbacks (bitmap_get_buffer). The direct memory operations appear properly initialized.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Error handling is consistent with goto gif_decode_frame_exit for cleanup. The function restores gif->buffer_position on exit, maintains gif->decoded_frame state, and ensures callbacks are called appropriately. Multiple error paths all converge to the same cleanup code, maintaining object state consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This is a file format parser (GIF decoder), not a network protocol handler. While both involve parsing untrusted input, the specific concerns of network protocols (streaming, partial data, timeouts) don't apply here. Input validation occurs but is file-oriented rather than network-oriented.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code validates length fields like width, height, and colour_table_size against available data (gif_bytes) and image boundaries. However, it doesn't explicitly check for integer overflow when calculating buffer sizes (e.g., width * height * sizeof(int), 3 * colour_table_size). Platform-specific integer limit validation is minimal.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "While most allocations are via callbacks, the code validates size parameters before use: checking gif_bytes before reading, validating colour_table_size against available data, ensuring width/height don't exceed boundaries. It checks for insufficient memory after bitmap_get_buffer calls. However, it doesn't validate size parameters passed to allocation callbacks directly.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-1382_before_exclude_100:612eefe8:spec": {
    "timestamp": "2026-01-20T10:11:30.695027",
    "cve_id": "CVE-2022-1382",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "612eefe8",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It processes binary structures (NE segment entries) from a file header, not text patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile or process patterns with escape sequences. It is a binary parsing function for executable file segments.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses `r_str_newf` to create a string, which is a formatted output function, not directly processing untrusted input strings. However, the data used in formatting (e.g., `se->flags`, `bs->paddr`) originates from a binary file, which could be maliciously crafted. The function does not appear to use length-aware string operations, but the primary risk is in the binary structure parsing, not string processing.</spec_1_reasoning>\n<spec_4_score>7</spec_4_score>\n<spec_4_reasoning>Moderate relevance. The code uses `bin->ne_header->SegCount` to loop and index into `bin->segment_entries`. This count comes from the file header (a protocol/message length field). If not validated before this function is called, a large `SegCount` could lead to out-of-bounds read. The code also calculates `bs->paddr` using a multiplication (`se->offset * bin->alignment`), which could overflow if values are not validated against integer limits.</spec_2_reasoning>\n<spec_5_score>8</spec_5_score>\n<spec_5_reasoning>Strong relevance. The code performs memory allocation for `RBinSection` (`R_NEW0`) and for the segment list. While it checks if `bs` is NULL, it does not validate the size parameters derived from the binary file (like `se->length`, `se->minAllocSz`) against reasonable allocation limits before they might be used elsewhere. The allocation for the list itself is not checked for success.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code uses `bin->ne_header->SegCount` to loop and index into `bin->segment_entries`. This count comes from the file header (a protocol/message length field). If not validated before this function is called, a large `SegCount` could lead to out-of-bounds read. The code also calculates `bs->paddr` using a multiplication (`se->offset * bin->alignment`), which could overflow if values are not validated against integer limits.</spec_2_reasoning>\n<spec_5_score>8</spec_5_score>\n<spec_5_reasoning>Strong relevance. The code performs memory allocation for `RBinSection` (`R_NEW0`) and for the segment list. While it checks if `bs` is NULL, it does not validate the size parameters derived from the binary file (like `se->length`, `se->minAllocSz`) against reasonable allocation limits before they might be used elsewhere. The allocation for the list itself is not checked for success.</spec_3_reasoning>\n<spec_6_score>6</spec_6_score>\n<spec_6_reasoning>Moderate relevance. The code interprets raw bytes from `segment_entries` as structured data (offsets, lengths, flags). It must consistently handle the types (e.g., treating `se->offset` as a multiplier for `bin->alignment`). Inconsistent interpretation due to incorrect casting or platform differences could cause security issues.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code performs memory allocation for `RBinSection` (`R_NEW0`) and for the segment list. While it checks if `bs` is NULL, it does not validate the size parameters derived from the binary file (like `se->length`, `se->minAllocSz`) against reasonable allocation limits before they might be used elsewhere. The allocation for the list itself is not checked for success.</spec_3_reasoning>\n<spec_6_score>6</spec_6_score>\n<spec_6_reasoning>Moderate relevance. The code interprets raw bytes from `segment_entries` as structured data (offsets, lengths, flags). It must consistently handle the types (e.g., treating `se->offset` as a multiplier for `bin->alignment`). Inconsistent interpretation due to incorrect casting or platform differences could cause security issues.</spec_4_reasoning>\n<spec_7_score>9</spec_7_score>\n<spec_7_reasoning>Highly relevant. The code uses `R_NEW0` which zero-initializes the allocated `RBinSection` memory. This is a good practice that directly aligns with the specification, preventing information leaks from uninitialized memory. All structure fields are then explicitly assigned.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code interprets raw bytes from `segment_entries` as structured data (offsets, lengths, flags). It must consistently handle the types (e.g., treating `se->offset` as a multiplier for `bin->alignment`). Inconsistent interpretation due to incorrect casting or platform differences could cause security issues.</spec_4_reasoning>\n<spec_7_score>9</spec_7_score>\n<spec_7_reasoning>Highly relevant. The code uses `R_NEW0` which zero-initializes the allocated `RBinSection` memory. This is a good practice that directly aligns with the specification, preventing information leaks from uninitialized memory. All structure fields are then explicitly assigned.</spec_5_reasoning>\n<spec_8_score>8</spec_8_score>\n<spec_8_reasoning>Strong relevance. The error handling path when `bs` allocation fails (`return segments;`) returns a partially constructed list, leaving `bin->segments` unassigned. This could lead to an inconsistent state if the caller expects `bin->segments` to be set. A more robust approach would be to free the list and return NULL, or ensure `bin->segments` is only set on full success.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-44512_before_exclude_100:d39935c0:spec": {
    "timestamp": "2026-01-20T10:11:31.496504",
    "cve_id": "CVE-2021-44512",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d39935c0",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses `getopt` to parse command-line arguments, which are C strings terminated by NUL bytes. While the code processes input (command-line arguments), it does not involve regular expression parsing. The relevance is weak because the specification is about a specific vulnerability in regex parsers, not general input handling.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile or process patterns with escape sequences. It parses simple command-line options. The specification is about pattern compilers (e.g., for regex), which is not present here. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses `xstrdup(optarg)` and `atoi(optarg)` on command-line arguments, which are potentially untrusted user input. `atoi` does not perform bounds checking and is not length-aware, which could be a security issue (e.g., integer overflow). `xstrdup` relies on NUL-terminated strings. There is moderate relevance because the code processes external input without explicit length-aware operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse protocol messages with length fields. It handles command-line arguments and sets configuration values. The specification is about protocol message validation, which is not directly applicable. Weak relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses `xstrdup` (which likely wraps `malloc` and checks for allocation failure) and `atoi` (which does not validate integer limits). There is no explicit validation of size parameters for memory allocation, but the allocations are for strings whose size is determined by `optarg`. Weak to moderate relevance because the code does not allocate based on untrusted size parameters directly, but integer conversion lacks validation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a complex protocol with multiple types. It parses command-line options and sets configuration values. The specification is about protocol type consistency, which is not directly relevant. Weak relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code initializes a global settings structure (`tmate_settings`) via command-line arguments. Not all fields may be initialized (e.g., `tmate_host` is conditionally set later). There is moderate to strong relevance because uninitialized memory could lead to undefined behavior if the structure is not properly set before use. The code checks `tmate_settings->tmate_host` for NULL, but other fields might be used uninitialized.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has error handling paths (e.g., `mkdir` failures call `tmate_fatal`, `usage()` on invalid options). However, it's unclear if object states (like `tmate_settings`) are kept consistent after partial failures (e.g., if one `mkdir` fails after another succeeded). Moderate relevance because error handling exists but may not ensure full state consistency.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-0419_before_exclude_100:4bd4b3af:spec": {
    "timestamp": "2026-01-20T10:11:33.147903",
    "cve_id": "CVE-2022-0419",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4bd4b3af",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages or validate length fields. It parses a Mach-O file buffer, which is a binary format, not a network protocol. The specification is about protocol message handling, which is not the context of this function.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation (e.g., `R_NEW0`, `r_list_new`) and uses buffer sizes from parsed structures (e.g., `prelink_range->range.size`). While there is some size usage (passed to `r_cf_value_dict_parse`), the code lacks explicit validation of these sizes against allocation limits or usage bounds before use, which is a potential concern. However, the validation is not the primary focus of the function.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles Mach-O binary structures, not a communication protocol. While type consistency is important for parsing binary data, the specification is specifically about protocol implementations, making it only loosely related.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expressions. It parses binary Mach-O and potential prelink info (likely property list data), but not via regex parsers.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It is a binary file loader.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes binary buffers, not strings. However, the `r_cf_value_dict_parse` function (likely parsing property list data) may internally process strings. The input buffer (`fbuf`) is trusted as it comes from the binary file being loaded, but the file content could be malicious. Length-aware operations are indirectly used via the buffer size parameter, but not explicitly for string handling.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code uses `R_NEW0` which zero-initializes memory, satisfying the specification. However, other allocations like `r_list_new()` may not fully initialize internal state, and the `obj` fields are assigned later. The initialization practice is good but not universally applied to all allocations.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The error handling paths (e.g., after `!prelink_info` or `!pending_bin_files`) attempt to free allocated resources (`R_FREE`) and set pointers to NULL before jumping to `beach`. However, the `beach` label frees `fbuf` and `main_mach0` but does not consistently free `rebase_info` or `prelink_info` if they were allocated earlier in the failure path. Also, `obj->cache_buf = NULL;` is set when `obj` might be NULL. This could lead to inconsistent state or memory leaks.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-0419_after_exclude_100:4512c917:spec": {
    "timestamp": "2026-01-20T10:11:34.792824",
    "cve_id": "CVE-2022-0419",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4512c917",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages or validate length fields. It parses a Mach-O binary file from a buffer, which is a local data structure, not a network protocol. The specification is about network/communication protocols, which is not the context here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation (e.g., R_NEW0, r_list_new) but does not explicitly validate size parameters before allocation. However, the allocations are for fixed-size structures (RKernelCacheObj, list head), not based on user-controlled sizes. Some relevance exists because the buffer `fbuf` contains untrusted file data, and parsing it (e.g., in MACH0_(new_buf), r_cf_value_dict_parse) could involve internal size calculations that should be validated. The specification is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code deals with binary file parsing (Mach-O format) which has a defined structure, but it's not a communication protocol. Type consistency is important for parsing the file headers and data structures correctly, but the specification is framed for network protocols, making it only loosely related.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expression parsers. It parses binary and possibly property list data (via r_cf_value_dict_parse), but not regex patterns. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It parses binary/structured data formats. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes data from a buffer (`fbuf`) that likely comes from an untrusted file. Functions like `r_cf_value_dict_parse` and Mach-O parsing routines should use length-aware operations to prevent overflows. While not directly shown, the specification applies to the underlying parsing logic. Moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code uses `R_NEW0` which zero-initializes memory, and other allocations (e.g., via r_list_new) may or may not initialize fully. However, the `obj` fields are assigned after allocation, ensuring initialization before use. The specification is highly relevant because proper initialization prevents information leaks and undefined behavior, especially in error paths where objects might be partially initialized.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error handling paths (e.g., goto beach) where resources (buffers, objects, ranges) must be freed and states kept consistent. It shows careful cleanup (e.g., freeing prelink_range, obj, main_mach0) but has complexity (e.g., early frees in some branches). The specification is highly relevant as inconsistent states in error paths could lead to memory leaks, double-frees, or use-after-free.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-37639_before_exclude_100:bb8824b9:spec": {
    "timestamp": "2026-01-20T10:11:36.804331",
    "cve_id": "CVE-2021-37639",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "bb8824b9",
    "scores": [
      {
        "score": 6,
        "reasoning": "The code performs bounds validation for the tensor slice data copy operation via `reader->CopySliceData`. However, the validation is indirect and relies on the `TensorSliceReader` implementation. The specification is moderately relevant because buffer operations occur during the copy, but the code does not show explicit, low-level bounds checks on fixed buffers before writes.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 7,
        "reasoning": "The code parses the `shape_spec` string to extract shape and slice information, enforcing structural constraints by verifying the parsed shape matches the saved shape. This is a form of configuration parsing with constraint validation, so the specification is moderately to strongly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 5,
        "reasoning": "The code uses `int64_t` for size calculations (e.g., `file_pattern_t.NumElements()`), but there is no explicit file position calculation or overflow prevention logic shown. The specification is about file positions in archive contexts, which is not directly applicable here, leading to low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve archive parsing or file position validation against archive boundaries. It reads from checkpoint files via `TensorSliceReader`, but boundary checks are abstracted away. The specification is not directly applicable, resulting in low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      },
      {
        "score": 5,
        "reasoning": "The code does not show archive parsing state management or handle position calculation failures explicitly. State consistency is managed by the `TensorSliceReader` and error handling via `OP_REQUIRES_OK`. The specification is not directly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Archive parsing state must remain consistent during position calculation failures"
      },
      {
        "score": 5,
        "reasoning": "The code uses `CHECK_NOTNULL(reader)` and validates `reader->status()`, but there is no explicit type verification of structure pointers before dereferencing. The specification is loosely related because pointer validation occurs indirectly through status checks and OP_REQUIRES.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: All structure pointer dereferences must be preceded by explicit type verification"
      },
      {
        "score": 5,
        "reasoning": "The code uses shared context objects (`OpKernelContext`, `slice_reader_cache`) and ensures type consistency by validating tensor data types match expected output types. However, the lifecycle type consistency is not explicitly managed beyond these checks. Moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared context objects must maintain type consistency throughout their lifecycle"
      }
    ]
  },
  "CVE-2022-1968_before_exclude_100:27578fbc:spec": {
    "timestamp": "2026-01-20T10:11:37.784958",
    "cve_id": "CVE-2022-1968",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "27578fbc",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses regular expression compilation (vim_regcomp) and execution (vim_regexec) with user-provided patterns from 'inc_opt', 'p_def', and 'curbuf->b_p_def'. While it doesn't explicitly show embedded NUL byte handling, the patterns come from Vim options which could potentially contain NUL bytes. The relevance is strong because improper handling of embedded NULs in regex patterns could lead to security issues.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code compiles regex patterns using vim_regcomp with magic_isset() flag, but there's no clear evidence of escape sequence boundary validation. The patterns come from configuration options, not untrusted network input. Moderate relevance as pattern compilation is present but escape sequence handling isn't explicitly shown.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes file paths and line content from potentially untrusted files. It uses STRLEN, STRNCMP, and MB_STRNICMP with explicit length parameters. However, some operations like sprintf with pat allocation could be vulnerable if len is improperly controlled. The code shows awareness of length-aware operations but has potential issues.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "The code uses lalloc_clear with TRUE parameter for initialization and ALLOC_MULT for dynamic allocation. Memory is generally initialized before use, but there are potential issues with the files array expansion logic where not all elements may be properly initialized. Moderate to strong relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code has multiple error handling paths (goto fpip_end) that clean up allocated resources (regprog, file_line, files). It maintains consistent state by freeing resources in error conditions. However, some early returns might leave resources allocated.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. This code processes local files and configuration, not network protocols. There's no network protocol handling in this function.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code extensively manipulates buffers and strings: file_line buffer of LSIZE, IObuff of IOSIZE, pattern buffers, and string operations. It shows some bounds checking but has potential issues with sprintf into pat buffer and string copying operations that should be examined for buffer overflows.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code parses file content for include patterns and definitions. It validates input through regex matching and checks file existence. However, the structural constraints validation is limited - it processes lines from potentially malformed files without extensive validation of file structure before content processing.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2022-1968_after_exclude_100:3d64fc56:spec": {
    "timestamp": "2026-01-20T10:11:39.226526",
    "cve_id": "CVE-2022-1968",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3d64fc56",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses regular expression compilation (vim_regcomp) and execution (vim_regexec) with user-provided patterns from 'inc_opt', 'p_def', and 'curbuf->b_p_def'. While the code doesn't directly show handling of embedded NUL bytes, the regular expression engine could potentially be vulnerable if it doesn't properly handle them. The relevance is strong because the code processes external pattern inputs through regex functions.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code uses vim_regcomp with RE_MAGIC flag for pattern compilation. While escape sequences are part of regex patterns, the code doesn't show direct manipulation of escape sequences. The specification is only moderately relevant as the pattern compilation is delegated to vim_regcomp, and the code doesn't implement its own escape sequence processing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses several string operations like STRNCPY, sprintf with length specifiers, and manual length calculations. However, it also uses functions like strstr on potentially untrusted 'inc_opt'. The sprintf usage with \"%.*s\" format is length-aware, but other operations might not be. Moderate relevance due to mixed usage of safe and potentially unsafe string operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 9,
        "reasoning": "The code uses lalloc_clear with TRUE parameter for initialization, and manually initializes regmatch structures to NULL. However, the bigger array allocation with ALLOC_MULT doesn't show explicit initialization for all elements. Strong relevance as memory initialization is critical for security and the code shows both good and potentially problematic patterns.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code has multiple error handling paths (goto fpip_end) that clean up allocated resources. It maintains consistent state by freeing memory and regex programs in error paths. However, some early returns might leave resources allocated. Strong relevance due to extensive error handling and cleanup logic.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code deals with file searching and pattern matching in source code files, not network protocols. There's no network protocol handling in this function. Very low relevance as this is a local file processing function.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code uses buffer operations with LSIZE constant and checks like \"if (p > line)\" before array access. However, there are pointer arithmetic operations and array accesses without explicit bounds checking (e.g., p[-1] access). Moderate relevance due to some bounds checking but potential for buffer overflows.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code validates input patterns before processing through regex compilation, and checks file existence before opening. However, the structural constraints validation is limited. Moderate relevance as there's some input validation but not comprehensive structural constraint enforcement.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2020-35981_after_exclude_100:b15f3320:spec": {
    "timestamp": "2026-01-20T10:11:39.507343",
    "cve_id": "CVE-2020-35981",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b15f3320",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses GF_SAFEALLOC which likely allocates and zero-initializes memory. However, the specification requires full initialization before use. While the code sets many fields after allocation, it's not guaranteed all fields are initialized (e.g., potential padding bytes or other struct members). The allocation pattern makes this relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error return paths (GF_ISOM_INVALID_FILE, GF_OUT_OF_MEM). The \"exit\" label cleans up writers, but early returns don't maintain consistent state for the MovieWriter structure. The function could leave partially initialized states on some error paths, making this moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This code processes local media file structures, not network protocols. No network input validation occurs here, making this specification not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code allocates memory for track writers but doesn't show buffer operations with padding requirements. This appears to be object allocation rather than buffer allocation for operational data with padding needs.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "This code sets up media writers for MP4 files but doesn't perform image compression operations. The specification specifically addresses image compression encoder buffers, which are not present here.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "While the code reads media file structures that contain length fields (sample counts, chunk offsets), it doesn't explicitly validate these against integer limits. However, this is file parsing rather than network protocol message handling, making relevance weak.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation via GF_SAFEALLOC and gf_isom_box_new. While size parameters aren't explicitly shown being validated, the allocation functions likely have internal checks. The specification is moderately relevant as proper memory allocation validation is important for this media parsing code.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different box types (STCO vs CO64) and media types (audio vs other). There's some type-based branching, but the specification focuses on protocol type consistency across stages, which only loosely applies to this media file processing code.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2020-35981_before_exclude_100:6e04d51e:spec": {
    "timestamp": "2026-01-20T10:11:41.968385",
    "cve_id": "CVE-2020-35981",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6e04d51e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses GF_SAFEALLOC which likely performs allocation and zero-initialization. However, the specification \"Memory allocations must be fully initialized before use\" is highly relevant because the code initializes most but not necessarily all fields of the allocated `TrackWriter` structure before use. Some fields are set conditionally (e.g., `constant_size`, `constant_dur`), but the initialization pattern should be reviewed for completeness.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function has multiple error paths (memory allocation failures for `writer`, `writer->stsc`, `writer->stco`) that return `GF_OUT_OF_MEM`. The `goto exit` path calls `CleanWriters` to maintain consistent state, but other early returns (e.g., for `writer->stco`) leak the previously allocated `writer->stsc` and `writer` objects, violating consistent state management. This is a direct security concern.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code is setting up internal track writers for a media file and does not involve network protocol handling or input validation from untrusted network sources.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code performs basic memory allocation for data structures but does not involve buffer allocation with operational padding requirements (e.g., for cryptographic operations or specific hardware). The allocations are for fixed-size control structures.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code deals with media track setup and sample tables, not image compression operations or encoder buffer management.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not parse or validate protocol message length fields from external sources. It works with internal movie/track structures.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. While the code uses wrapper allocation functions (GF_SAFEALLOC, gf_isom_box_new), the specification about validating size parameters against allocation limits is a general good practice. The direct allocations here are for fixed-size structures, but the function handles media sample data indirectly, where size validation could be critical elsewhere in the system.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code handles different box types (STCO vs CO64) based on the `ChunkOffset->type`, which shows type-aware branching. However, this is not a network protocol implementation, and the type handling is limited to local file format structures. The relevance to cross-stage protocol type consistency is minimal.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2015-1791_before_exclude_100:fda9a67c:spec": {
    "timestamp": "2026-01-20T10:11:42.359852",
    "cve_id": "CVE-2015-1791",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "fda9a67c",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the total message length (n) and checks that ticklen + 6 equals n, which validates the ticket length field against the overall message length. This directly addresses protocol message length field validation, though it doesn't explicitly check against platform-specific integer limits beyond the basic bounds checking.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs OPENSSL_malloc(ticklen) without validating ticklen against allocation limits. While it checks ticklen + 6 == n, it doesn't validate that ticklen is reasonable or within safe bounds before allocation, which could lead to excessive memory allocation attacks.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code handles TLS session ticket messages with consistent type handling (using SSL3_MT_NEWSESSION_TICKET), but the specification about enforcing consistent type handling across all processing stages is only partially addressed as we only see one processing stage in this function.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code validates that n >= 6 and ticklen + 6 == n, which enforces basic length constraints. However, it doesn't check if ticklen exceeds RFC-specified maximums for session tickets or validate the lifetime hint field against reasonable bounds.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code processes a TLV-like structure (ticket_lifetime_hint + ticket_length + ticket) and performs bounds checking with ticklen + 6 != n before accessing the ticket data. This is a direct implementation of TLV bounds checking, though it occurs after reading the length fields.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code doesn't use regular expressions at all. It processes binary TLS protocol messages, not text patterns with embedded NUL bytes.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code doesn't involve pattern compilers or escape sequence processing. It handles binary protocol data using memcpy and basic integer parsing.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code uses memcpy with explicit length (ticklen) for the ticket data, which is length-aware, the specification focuses on string processing functions. The ticket data is binary, not necessarily a string, and the code doesn't use traditional string functions like strcpy.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      }
    ]
  },
  "CVE-2022-21723_after_exclude_100:5f922726:spec": {
    "timestamp": "2026-01-20T10:11:43.917513",
    "cve_id": "CVE-2022-21723",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f922726",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a simple character scanner, not a regular expression parser. It does not parse or compile patterns, making this specification about embedded NUL bytes in regex patterns largely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It reads raw characters from a buffer, so this specification about pattern compilers and escape sequences is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code processes a string buffer (scanner->curptr) and checks against scanner->end, which is a length-aware operation. This is a good practice for potentially untrusted input to prevent buffer overreads. The relevance is strong but not a perfect 10 because the function itself is simple and the length check is already present.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code does not parse protocol messages or validate length fields. It operates on a simple character buffer within a scanner structure, making this specification about protocol message length fields irrelevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 2,
        "reasoning": "The code performs no memory allocation operations. It only reads from and updates pointers within a pre-allocated buffer, so this specification does not apply.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. While the code is part of a larger protocol/data processing library (PJSIP), the function itself is a low-level character reader. It does handle a `char` type consistently, but the specification's broader context of \"protocol implementations\" and \"all processing stages\" is only loosely related to this single function.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      }
    ]
  },
  "CVE-2022-21723_before_exclude_100:b484ad34:spec": {
    "timestamp": "2026-01-20T10:11:44.390379",
    "cve_id": "CVE-2022-21723",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b484ad34",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes input character by character and checks for a NUL terminator (if (!chr)). However, it does not explicitly handle embedded NUL bytes within a larger input buffer. If the scanner operates on a length-delimited buffer containing embedded NULs, this function would incorrectly treat them as the end of input, potentially causing syntax errors or truncated processing. This relates to the specification's concern about proper handling of embedded NULs.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code is a simple character scanner, not a pattern compiler. It does not process escape sequences or compile patterns, making this specification largely irrelevant.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function reads a character from a pointer (scanner->curptr) without explicit bounds checking against the buffer's end. It relies on a NUL terminator check to stop. If the scanner is processing untrusted input from a buffer without a proper length, this could lead to reading out-of-bounds. The specification advocates for length-aware operations, which this function lacks, making it highly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not parse or validate any protocol message length fields. It is a low-level character scanning utility, making this specification not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function performs no memory allocation operations. It only increments a pointer and reads a character. Therefore, this specification is not relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The function handles a single character (int type) and returns it. While it does involve type handling (int vs. char), the specification is focused on complex protocol implementations and consistent type handling across stages, which is a much broader concern than this simple function. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function's primary security flaw is its reliance on a NUL terminator (*scanner->curptr) to determine the end of input. If the external string data is not properly terminated (e.g., in a fixed-size buffer without a NUL), the function will read beyond the buffer boundary. The specification explicitly calls for validation of proper termination, which this code assumes but does not enforce.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: External string data must be explicitly validated for proper termination before proces..."
      },
      {
        "score": 5,
        "reasoning": "The code is a generic character scanner, not a specific file format parser. It does not process chunks or enforce structural invariants at boundaries. The relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-IO-002: File format parsers must enforce structural invariants at chunk boundaries"
      }
    ]
  },
  "CVE-2014-0142_before_exclude_100:10274b2d:spec": {
    "timestamp": "2026-01-20T10:11:49.048358",
    "cve_id": "CVE-2014-0142",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "10274b2d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code reads a `catalog_entries` field from an external image header and uses it to calculate a memory allocation size (`s->catalog_size * 4`). This is a classic case of validating an input length field against platform limits (INT_MAX). The check `s->catalog_size > INT_MAX / 4` directly aligns with HS-INPUT-001's requirement to validate protocol message length fields against integer limits to prevent overflow.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code performs a memory allocation (`g_malloc`) based on a calculated size (`s->catalog_size * 4`). It validates the size parameter against an allocation limit (`INT_MAX / 4`) before allocation, which is the core requirement of HS-MEM-002. This prevents an integer overflow that could lead to undersized allocation and subsequent buffer overflow during the `bdrv_pread` call.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code reads a header structure from disk, which is a form of protocol. It handles endianness conversion (`le32_to_cpu`) for multiple fields (`version`, `nb_sectors`, `tracks`, `catalog_entries`) and later for each entry in the catalog bitmap (`le32_to_cpus`). This enforcement of consistent type handling (specifically endianness) across processing stages aligns with HS-PROTOCOL-003.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers and embedded NUL bytes. The target code does not involve regular expressions or pattern parsing at all. It is parsing a binary file format. Therefore, the relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code deals with binary data parsing and memory allocation, not with compiling or processing textual patterns containing escape sequences. Therefore, the relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification is about using length-aware string functions for untrusted input. This code does process untrusted input (the disk image), but it uses `memcmp` for magic number validation and `bdrv_pread` for reading data with explicit lengths. It does not use traditional C string functions (`strcpy`, `strcat`, etc.) on the input data, so the relevance is weak.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires memory to be initialized before use. The code allocates memory with `g_malloc`, which does not initialize it. The memory is then immediately populated by `bdrv_pread`. While not explicitly \"initialized\" in the sense of being filled with a known value before the read, the subsequent read operation fully defines its content before any other use. The risk of using uninitialized memory is low here, making the relevance weak.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has a clear error handling path labeled `fail:`. On failure, it frees the `s->catalog_bitmap` if it was allocated, preventing a memory leak, and returns the error code. This maintains a consistent state (no leftover allocated memory) on the error path, which is the essence of HS-STATE-002.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2014-0142_after_exclude_100:a2f73e08:spec": {
    "timestamp": "2026-01-20T10:11:49.476195",
    "cve_id": "CVE-2014-0142",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a2f73e08",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the `catalog_entries` field from the header against `INT_MAX / 4` before using it to calculate an allocation size. This directly aligns with HS-INPUT-001's requirement to validate length fields against platform-specific integer limits to prevent integer overflow. The check is a good example of such validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The code performs a crucial validation (`s->catalog_size > INT_MAX / 4`) before the memory allocation `g_malloc(s->catalog_size * 4)`. This check prevents an integer overflow in the size calculation, which would lead to an undersized buffer allocation and subsequent buffer overflow during the `bdrv_pread` operation. It directly addresses the security issue the specification aims to prevent.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code demonstrates consistent type handling by converting data from disk (little-endian) to host CPU byte order using `le32_to_cpu` and `le32_to_cpus`. This ensures data is interpreted correctly regardless of the host platform's endianness, which is a core aspect of protocol/format implementation safety. However, the specification's scope (\"Protocol implementations\") is broader than this simple image format reader.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This specification is about regular expression parsers and NUL bytes in patterns. The target code does not use or contain any regular expressions. It is parsing a binary file format header. Therefore, it is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This specification is about pattern compilers and escape sequences. The target code does not compile or process patterns or escape sequences. It is reading a fixed binary structure. Therefore, it is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The specification focuses on string processing functions. This code primarily deals with binary data (structure `ph`, bitmap array). While `memcmp` is used on the magic field, it operates on a fixed 16-byte length, not a NUL-terminated string, so length-aware operations are inherently used. The relevance is very low as string processing is not the primary activity.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The memory allocated for `s->catalog_bitmap` is immediately populated with data from disk via `bdrv_pread`. This means the allocated memory is initialized before being read in the subsequent loop (`le32_to_cpus`). However, if the `bdrv_pread` fails partially or the `goto fail` is taken, the memory is freed but could have contained uninitialized data briefly. The specification is moderately relevant, as initialization is performed, but not necessarily before all potential uses (e.g., before the `goto fail` path frees it, though that's likely safe).",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The code has a clear `fail:` error handling path that ensures consistency: it frees the `catalog_bitmap` if it was allocated (preventing a memory leak) and returns the error code. This maintains a consistent state (no allocated memory left dangling) when an error occurs during the open operation. The pattern is a good example of the specification's intent.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-1587_before_exclude_100:3bd5372d:spec": {
    "timestamp": "2026-01-20T10:11:50.143850",
    "cve_id": "CVE-2022-1587",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3bd5372d",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is a helper function within a PCRE2 JIT compiler that calculates the length of private data needed for recursion. It processes an internal compiled regex bytecode pattern (`cc` to `ccend`), not raw user input containing NUL bytes. While embedded NULs in the original pattern could affect earlier compilation stages, this function operates on a sanitized internal representation, making the specification's direct relevance low.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers processing escape sequences. This function operates after the compilation stage, walking a compiled bytecode sequence. It does not parse or interpret escape sequences from a pattern string, so the relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The function iterates over a bytecode array using pointer (`cc`) and a bounded end (`ccend`). It uses a switch on opcodes and carefully advances the pointer using opcode-specific sizes (e.g., `cc += 1 + LINK_SIZE`). This demonstrates length-aware traversal of a potentially complex data structure. While the input is internal bytecode, the principle of bounded, safe iteration is strongly relevant.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message field lengths against an RFC. This code is part of a regex engine's JIT compiler, not a network protocol implementation. The relevance is negligible.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The function performs a form of TLV (Type-Length-Value) processing on compiled regex bytecode. Each opcode has a type, and the code calculates or uses known lengths to advance the pointer (`cc`). It ensures it stays within the `cc` to `ccend` bounds by design, though explicit bounds checks per opcode step are not shown (they are assumed to be valid from prior compilation). The principle of bounds checking before accessing opcode data is moderately to strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns validating integer length fields in protocol messages against platform limits. This function calculates an integer length for an internal data structure, but it does not parse or validate length fields from an external source. The relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function's purpose is to calculate a `length` (size requirement) for a private data structure. This calculated length is likely used later for memory allocation. While the function itself doesn't perform the allocation or validation, it is a critical step in determining the size parameter that must later be validated against allocation limits (HS-MEM-002). Therefore, it has moderate relevance as part of the chain leading to a secure allocation.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification demands consistent type handling in protocol implementations. This function consistently handles different regex opcode types via a switch statement, ensuring correct processing for each. However, it is not a protocol implementation. The analogy to type-safe opcode dispatch gives it weak to moderate relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2022-1899_before_exclude_100:c1d3b404:spec": {
    "timestamp": "2026-01-20T10:11:50.448766",
    "cve_id": "CVE-2022-1899",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c1d3b404",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes binary data to find strings, which may contain embedded NUL bytes. It handles NUL bytes as string terminators (e.g., breaking on `r == 0`), but the relevance is moderate because it's not a regular expression parser. The code does need to handle NUL bytes in input buffers correctly.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 6,
        "reasoning": "The code processes escape sequences for control characters (like `\\n`, `\\t`) when encoding them into output. It maintains boundaries by checking buffer sizes (e.g., `i + 32 < sizeof(tmp)`). However, it's not a pattern compiler, so relevance is moderate.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function processes potentially untrusted binary input (from a buffer) and uses length-aware operations like `r_buf_read_at`, checks `to - needle` bounds, and uses decoding functions with length parameters (e.g., `r_utf8_decode(buf + needle - from, to - needle, NULL)`). This directly aligns with the specification.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates the range `from` and `to` (e.g., `from > to`, `len > ST32_MAX`), which is similar to validating length fields. However, it's not processing protocol messages, and the validation is for internal scan ranges, not protocol-specific length fields.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code allocates memory based on `len` (calculated from `to - from`), validates `len` against `ST32_MAX`, and checks for allocation failure. It also ensures the size is positive. This aligns with validating size parameters against allocation limits.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code handles different string types (ASCII, UTF-8, WIDE, WIDE32) and ensures consistent type handling (e.g., setting `str_type`). However, it's not a protocol implementation, and type handling is for string detection, not protocol stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code uses `calloc` which initializes memory to zero, but there's no explicit initialization of all allocated memory before use (e.g., `buf` is read into). The specification is about mandatory full initialization, which isn't a primary focus here.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code has error handling paths (e.g., for invalid ranges, allocation failures) that return early, but it doesn't involve complex object states. Some resources like `buf` are freed on error, but consistency of object states isn't a central concern.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-1587_after_exclude_100:0e13ffdb:spec": {
    "timestamp": "2026-01-20T10:11:50.695016",
    "cve_id": "CVE-2022-1587",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0e13ffdb",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code is part of a PCRE2 regex compiler calculating data lengths for recursion handling. It processes an internal bytecode representation (cc to ccend), not raw user input patterns. While embedded NUL bytes could be relevant earlier in the parsing/compilation pipeline, this function works on already-compiled structures with explicit length (ccend), making HS-INPUT-001 only marginally relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This function processes compiled regex opcodes, not raw pattern strings with escape sequences. Escape sequence handling occurs earlier in the compilation phase. The code does not interpret escape sequences, so HS-PROTOCOL-002 has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code uses length-aware operations by iterating within the bounds defined by `cc` and `ccend`. It carefully advances the `cc` pointer using opcode-specific sizes and includes bounds checks via `SLJIT_ASSERT`. This aligns well with HS-MEM-003's principle of using length-aware operations for potentially untrusted input, though the input here is internal compiled code.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns protocol message field validation against RFC-specified lengths. This code is part of a regex engine's internal compiler, not a network protocol implementation. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "While not processing TLV structures in the protocol sense, the code performs similar operations: it interprets a bytecode stream with variable-length opcodes, calculates offsets (like `GET(cc, 1)`), and must ensure it stays within the `cc` to `ccend` bounds. It implements bounds checking through assertions (`SLJIT_ASSERT`) and careful pointer arithmetic, which aligns with the spirit of HS-PROTOCOL-002.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "The specification is about validating protocol message length fields. This code calculates an internal length variable (`int length`) for memory allocation but does not process external length fields from a protocol. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function's purpose is to calculate a `length` (sum of private machine words) which is likely used later to allocate memory. It must ensure this calculation is accurate and does not overflow or underflow, as an incorrect length could lead to buffer overflows/underflows in subsequent memory operations. This relates to validating size parameters for allocation, though the actual allocation and validation happen elsewhere.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code consistently handles different opcode types via a switch statement, ensuring each type is processed with the correct logic and size increments. This promotes consistent type handling, which is a general secure coding principle. However, HS-PROTOCOL-003 is framed in the context of network protocols, making the relevance only moderate.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2022-1899_after_exclude_100:48398ba7:spec": {
    "timestamp": "2026-01-20T10:11:51.759570",
    "cve_id": "CVE-2022-1899",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "48398ba7",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes binary data to find strings, which may contain embedded NUL bytes. It handles NUL bytes as string terminators (e.g., `break;` when `r` is zero), but the relevance is moderate because it's not a regular expression parser. The code does need to handle NUL bytes in input buffers correctly.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 6,
        "reasoning": "The code processes escape sequences for control characters (like `\\n`, `\\t`) when encoding strings into the `tmp` buffer. It uses a lookup table for escape characters, maintaining boundaries by checking buffer size (`i + 32 < sizeof(tmp)`). However, it's not a pattern compiler, so relevance is moderate.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code processes potentially untrusted binary input (`buf` from the binary file) and uses length-aware operations like `r_buf_read_at`, `r_utf8_decode` with bounds `to - needle`, and buffer size checks (e.g., `i < sizeof(tmp) - 4`). It avoids string operations without length checks.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates the range `from` and `to` (e.g., `from > to`, `len > ST32_MAX`), which is similar to validating length fields. However, it's not processing protocol messages but binary file ranges, so the specification only loosely applies.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code allocates memory based on `len` (`buf = calloc(len, 1)`) and validates `len` against `ST32_MAX` and minimum size. It also checks allocation success (`if (!buf)`). However, it doesn't explicitly validate against subsequent usage requirements beyond size checks.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code handles different string types (ASCII, UTF-8, WIDE, WIDE32) with consistent type handling via `str_type` variable and switch statements. However, it's not a protocol implementation, and type handling is for string detection, not protocol stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses `calloc` for `buf`, which initializes memory to zero. However, other allocations (like `RBinString *bs = R_NEW0(RBinString)`) may also initialize memory, but the specification is not directly focused on memory initialization security issues in this context.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code has error handling paths (e.g., invalid range, allocation failure) that return `-1` or break loops, and it frees resources (`free(buf)`, `pj_free(pj)`). However, it doesn't fully maintain consistent object states in all error paths (e.g., early returns may leave resources allocated).",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2022-31783_before_exclude_100:2a41e03d:spec": {
    "timestamp": "2026-01-20T10:11:53.501410",
    "cve_id": "CVE-2022-31783",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2a41e03d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code contains multiple memory allocations (e.g., malloc for patterns, arguments arrays) where size calculations should be validated for overflow. For example, `m->argument_count * sizeof(CharsString)` and `sizeof(*patterns) * 27720` are calculated without explicit overflow checks. The `_lou_outOfMemory()` function is called on allocation failure, but overflow validation before allocation is not shown.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: All size calculations must be validated for arithmetic overflow before memory allocati..."
      },
      {
        "score": 7,
        "reasoning": "Partial allocation failures are handled inconsistently. In some cases (like CTO_Match), cleanup is performed with goto labels and free(), but error paths don't always ensure all previously allocated resources are freed. The macro expansion code allocates arguments but may not clean them up on all error paths. State consistency during failures is a concern.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Resource cleanup must maintain consistent state during partial allocation failures"
      },
      {
        "score": 5,
        "reasoning": "Error handling paths generally return 0 or 1, but object lifecycle management (like table reallocation) is complex. The code mentions that `allocateSpaceInTranslationTable` may reallocate the table, requiring revalidation of pointers. Some error paths may leave tables in inconsistent states, though many operations check for errors.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Error handling paths must maintain object lifecycle invariants"
      },
      {
        "score": 5,
        "reasoning": "Pointer arithmetic and buffer bounds are validated in some places (e.g., checking `tmpFile.linelen >= MAXSTRING`), but not consistently. Array accesses like `(*table)->seqPatterns[(*table)->seqPatternsCount++]` increment counters without always checking bounds before access. Some loops use fixed sizes (27720) without clear validation.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Pointer arithmetic operations must validate bounds against buffer limits"
      },
      {
        "score": 5,
        "reasoning": "Input validation is extensive throughout the code. Parameters are checked for length constraints, opcode validity, token parsing, and character definitions. For example, checks for `ruleChars.length != 1`, `argument_count < m->argument_count`, and various size limits (MAXSTRING, LETSIGNSIZE, etc.) show strong input validation against operational constraints.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-004: Input parameters must be validated against operational constraints"
      },
      {
        "score": 5,
        "reasoning": "State transitions are managed with flags like noback, nofor, nocross, and error returns. However, the use of goto doOpcode for state resetting and the complex switch/case structure may lead to inconsistent boundary conditions. The code maintains some state consistency but could have edge cases.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-005: State transitions must maintain consistent boundary conditions"
      },
      {
        "score": 5,
        "reasoning": "Buffer operations show validation in many places: `tmpFile.linelen >= MAXSTRING` checks, array bounds checks for various fixed-size arrays (LETSIGNSIZE, SEQPATTERNSIZE, etc.). However, not all buffer accesses are validated (e.g., direct memory copies with memcpy assume allocated sizes are correct). Overall, good but not perfect.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer operations must validate position boundaries before memory access"
      },
      {
        "score": 5,
        "reasoning": "This specification about form input processing and position markers has very low relevance. The code processes tokens and characters from files, not web forms. While it does track line positions (linepos, linelen), it's not related to form input structural invariants as specified.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Form input processing must enforce structural invariants for position markers"
      }
    ]
  },
  "CVE-2020-15900_before_exclude_100:f3e15106:spec": {
    "timestamp": "2026-01-20T10:11:56.858036",
    "cve_id": "CVE-2020-15900",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f3e15106",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform any memory allocation. It operates on existing string objects passed as operands. Therefore, the specification about initializing memory allocations is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error/exit paths (e.g., \"can't match\", \"No match\", \"found\"). It modifies operand states (op, op1) differently on these paths. While it appears to maintain consistency for its intended logic (setting boolean results and adjusting string slices), a security review should verify that all object states are valid and consistent on every path, especially when manipulating pointer values and sizes.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a string search function, not a network protocol handler. There is no network input processing involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code searches for a pattern string within another string using `memcmp`. If the pattern string contains an embedded NUL byte, the `size` variable (from `r_size(op)`) dictates the comparison length. The code correctly uses this size with `memcmp`, so it should handle embedded NULs properly. This is directly relevant to secure string processing.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile patterns or process escape sequences. It performs a simple byte-wise search.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function processes two input strings (`op` and `op1`). It uses length-aware operations: it checks `r_size()` for both strings, validates that the pattern size is not larger than the source string size, and uses the stored `size` in the `memcmp` call. This prevents out-of-bounds reads if the size values are trusted. However, the security depends on whether `r_size()` returns a trusted value for these potentially untrusted string objects.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform character encoding validation. It treats strings as raw bytes. The specification about enforcing domain-specific size constraints is only loosely related because the code does perform a basic size constraint check (`if (size > r_size(op1))`).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding validation must enforce domain-specific size constraints"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code performs array/buffer operations on `ptr` and `pat`. It calculates `count = r_size(op1) - size` and uses it in a loop. It also computes `ptr - op[-1].value.bytes` and `ptr + size`. Before these operations, it validates the fundamental relationship (`size > r_size(op1)`), but a security expert must ensure that all pointer arithmetic and index uses (e.g., `pat[0]`, `ptr + incr` within the loop, `ptr + size`) stay within the bounds of their respective buffers based on the validated sizes.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array/buffer operations require pre-access validation of computed indices"
      }
    ]
  },
  "CVE-2013-2020_before_exclude_100:939e9692:spec": {
    "timestamp": "2026-01-20T10:12:00.423340",
    "cve_id": "CVE-2013-2020",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "939e9692",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory with `cli_malloc` but does not initialize it before reading data into it with `fread`. This is acceptable because `fread` will write to the entire buffer. However, after the byte-packing loop, the second half of the buffer (from roughly `len/2` to `len`) contains uninitialized data that was not overwritten and is then effectively discarded when the string is null-terminated. While not a direct vulnerability, the specification about initializing memory is relevant because the loop accesses the entire allocated buffer. The uninitialized portion is read during the loop but not used after termination, so the risk is low.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has error handling paths (OOM, fread failure). In the `fread` failure path, it correctly frees the allocated memory before returning NULL, maintaining a consistent state (no memory leak). The success path also correctly null-terminates and returns the memory. The specification is moderately relevant as the code demonstrates good error state management.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This specification is about network protocol handlers. The target code reads from a file (`FILE *f`), not a network protocol. Therefore, it is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expressions. It processes a string from a file, converting a wide-character-like format (skipping bytes) to a single-byte string.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This specification is about pattern compilers and escape sequences. The target code performs simple byte copying and string termination, with no pattern compilation or escape sequence processing.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The function processes input (from a file) which is potentially untrusted. It correctly uses length-aware operations: it bounds the `len` parameter to a maximum of 400, allocates exactly that length, and uses `fread` with that length. The subsequent loop also correctly iterates based on `len`. This prevents buffer overflows.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This specification is strongly relevant. It is nearly identical to HS-STATE-002 but focused on memory state. The code's error paths (OOM return, fread failure with free) and success path ensure memory is either properly allocated and returned or freed. There is no memory leak or double-free in the shown paths, maintaining consistent memory state.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "This specification is highly relevant. The function validates and establishes boundaries before memory operations. It checks if `len` is zero, caps it at 400, and only then allocates memory. This input validation and bounding happens before the `fseek` and `fread` operations, preventing excessive memory allocation or reading.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2022-27950_before_exclude_100:174364e6:spec": {
    "timestamp": "2026-01-20T10:12:00.791451",
    "cve_id": "CVE-2022-27950",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "174364e6",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not parse or handle protocol messages with length fields. It is a probe function for a HID device driver, primarily dealing with device initialization, memory allocation, and work scheduling. No network or complex protocol parsing is present.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The code performs a memory allocation (`kzalloc`) for a fixed-size structure (`struct elo_priv`). While the size is not user-controlled and is a compile-time constant, the specification's guidance on validating size parameters is a general good practice. The failure case is handled correctly by returning `-ENOMEM`.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a protocol with variable types that need consistent handling. It deals with kernel APIs for HID and USB, where type consistency is enforced by the kernel subsystem interfaces.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. This is a kernel driver probe function. It does not receive or process array lengths from userspace. All inputs come from the kernel (HID subsystem, USB core).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The function does not contain a protocol message handler for variable-length components. Its main actions are allocation, initialization, and starting HID hardware.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The only buffer allocation is for a fixed-size kernel structure. There is no processing of input data that could have a variable or worst-case size needing explicit limits in this function.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function manages resources (memory via `priv`, a USB device reference via `usb_get_dev`, and a delayed work item). It must ensure consistent state on error paths. The `err_free` path attempts to clean up, but note: if `hid_hw_start` fails, it jumps to `err_free` which frees `priv`. However, `priv->usbdev` holds a reference obtained via `usb_get_dev` which is not released in the error path, potentially causing a leak. This relates to atomicity and consistency of resource state.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function tracks resources (allocated memory, USB device reference, scheduled work) across multiple kernel subsystems (HID, USB, workqueue). The error handling path (`err_free`) has an inconsistency: it frees the `priv` structure but does not release the USB device reference (`usb_put_dev`) acquired earlier, breaking the consistency between the allocated memory state and the reference-counted USB device state. This could lead to a resource leak.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2008-3526_before_exclude_100:e972aa77:spec": {
    "timestamp": "2026-01-20T10:12:01.114085",
    "cve_id": "CVE-2008-3526",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e972aa77",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the user-provided `optlen` against a minimum size (`sizeof(struct sctp_authkey)`) before processing. However, it does not validate against a maximum system constraint, which is a partial application of the specification.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 7,
        "reasoning": "The code handles a variable-length structure (`sctp_authkey` with a key payload). It validates that the internal `sca_keylength` field does not exceed the overall `optlen`, which is a basic structural integrity check for a variable-length component.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 6,
        "reasoning": "The code allocates memory based directly on the user-provided `optlen` without an explicit, predefined upper limit. This does not account for a worst-case scenario with an explicit size limit, which is the core of this specification.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "The code validates the user-provided length field `optlen` against a minimum and also validates an internal length field (`sca_keylength`) against `optlen`. This aligns with the specification's requirement to validate protocol message length fields, though the context is a socket option, not a network packet.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The code allocates `kmalloc(optlen)` based on a user-controlled value. While it validates `optlen` is greater than a minimum, it does not validate it against a maximum allocation limit (e.g., to prevent excessive memory consumption) before performing the allocation, which is a key part of this specification.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles association IDs and key data, but the specification about \"consistent type handling across all processing stages\" is broad. The code's type handling (e.g., `authkey->sca_assoc_id`) appears consistent, but this is a weak and indirect match for the provided code snippet.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for USB request processing. The target code is for an SCTP (Stream Control Transmission Protocol) socket option, which is completely unrelated to USB.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for USB/IP protocol implementation. The target code is for the SCTP network protocol, making this specification not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2013-2020_after_exclude_100:c379cc8a:spec": {
    "timestamp": "2026-01-20T10:12:02.834316",
    "cve_id": "CVE-2013-2020",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "c379cc8a",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory with `cli_malloc` but does not fully initialize the entire buffer before use. The `fread` writes data into it, which is a form of initialization, but the subsequent loop only processes half the bytes, leaving the other half of the allocated memory (the odd-indexed bytes from the original read) uninitialized in the final string context. This could lead to information disclosure if the memory contained sensitive data. The specification is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error handling paths (OOM, fread failure). In the fread failure path, it correctly frees the allocated memory before returning NULL, maintaining a consistent state (no memory leak). The success path also properly null-terminates the string. However, the specification about \"object states\" is broader than just memory; the function's internal state (file pointer via fseek) is altered before the fread check, which could leave the external FILE object in an unexpected position on error. This is moderately relevant.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The specification is about network protocol handlers. This code reads from a FILE* (likely a local file) and performs no network operations. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification concerns regular expression parsers and embedded NUL bytes. This code does not involve regular expressions. It processes a raw byte stream from a file, converting from a 2-byte-per-character format. It is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. This code is a simple string extraction function with no compilation, pattern matching, or escape sequence processing. It is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function processes input from a file (`fread`) which is potentially untrusted. It uses length-aware operations: it validates and bounds `len` (capping at 400), allocates based on `len+1`, reads exactly `len` bytes, and processes in a loop bounded by `len`. This directly aligns with the specification's intent to prevent buffer overflows and ensure safe processing of untrusted input.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant and almost identical to the reasoning for HS-STATE-002 but more specific to memory. The function maintains consistent memory state across branches: it frees `name` on the `fread` failure path, returns NULL on the OOM path without freeing (since allocation failed), and returns a valid pointer on success. There is no double-free or leak in the shown paths. A minor point is that the `len>400` truncation changes the logical length but the allocation uses the truncated length, which is consistent.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 5,
        "reasoning": "This is strongly relevant. The function performs input validation by checking `len` (non-zero) and establishing a boundary (`len>400` cap) before performing memory allocation (`cli_malloc(len+1)`) and memory operations (`fread` and the processing loop). This is a direct application of the specification's principle.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2008-3526_after_exclude_100:d5ff394f:spec": {
    "timestamp": "2026-01-20T10:12:04.348378",
    "cve_id": "CVE-2008-3526",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d5ff394f",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the user-provided `optlen` against a minimum size (`sizeof(struct sctp_authkey)`). However, it does not validate it against a maximum system constraint before using it for `kmalloc`. This is a direct application of the specification, but the validation is incomplete (no upper bound check), hence not a perfect 10.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code handles a variable-length component (`sca_keylength` within `authkey`) and validates that the declared key length does not exceed the total buffer size provided (`optlen - sizeof(struct sctp_authkey)`). This is a structural integrity check for a variable-length component, making the specification moderately to strongly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates a buffer based directly on the user-controlled `optlen` without imposing an explicit, reasonable upper limit. This fails to account for a worst-case input scenario (a very large `optlen`) and could lead to excessive memory allocation or failure. The specification is highly relevant to this security flaw.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "While the code validates a length field (`authkey->sca_keylength`) against the available buffer, it does not validate the primary user-provided length (`optlen`) for integer overflow or platform-specific limits before operations like `optlen - sizeof(struct sctp_authkey)`. The specification is applicable but not fully addressed.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "This specification combines aspects of spec 1 and spec 3. The code validates `optlen` against a minimum (usage requirement) but fails to validate it against a maximum allocation limit before passing it to `kmalloc`. This is a central security concern in the code, making the specification highly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification concerns consistent type handling across protocol stages. The target code is a socket option handler, not a core protocol message parser. While it handles a structure (`sctp_authkey`), the check for type consistency is not the primary security focus here. Relevance is low.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for USB request processing. The target code is for the SCTP network protocol socket options. There is no relation to USB. Relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for USB/IP protocol implementation. The target code is for the SCTP network protocol. There is no relation to USB/IP. Relevance is very low.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      }
    ]
  },
  "CVE-2022-27950_after_exclude_100:4f63d3d6:spec": {
    "timestamp": "2026-01-20T10:12:07.537293",
    "cve_id": "CVE-2022-27950",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4f63d3d6",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not parse or handle protocol messages with length fields. It is a probe function for a HID device driver, primarily dealing with device initialization, memory allocation, and work scheduling. The specification about validating protocol message lengths is not applicable here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs a memory allocation (`kzalloc`) for a `struct elo_priv`. While it checks for allocation failure (`if (!priv)`), it does not explicitly validate the size parameter against platform-specific allocation limits or complex usage requirements. The allocation size is fixed (size of the struct), so the risk is lower, but the general principle of validating allocation parameters applies.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "Weak relevance. The code is not implementing a network or communication protocol with variable types. It handles kernel data structures and USB/HID device initialization. The specification about consistent type handling across protocol stages is not directly applicable.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "The code does not receive or process array lengths from userspace. It is a kernel driver probe function called by the kernel when a device is detected. The specification regarding userspace input validation is not relevant to this context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. Similar to spec 1 and 3, this code does not handle protocol messages with variable-length components. Its function is device setup and workqueue initialization.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The code allocates a fixed-size buffer for its private data structure. It does not allocate buffers based on external, variable-sized input. However, the principle of accounting for worst-case scenarios could be considered in a broader sense for the delayed work and potential data handled later by `elo_work`, but this is not visible in the provided snippet.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code schedules a delayed work item (`queue_delayed_work`) based on a condition (`elo_broken_firmware`). While not a classic shared resource like a lock, the workqueue (`wq`) and the device state are shared resources. The code does not show explicit atomic operations to protect the state transition (e.g., ensuring the work is not scheduled twice if the probe is called concurrently). This could be a potential issue area.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function manages several resources: a kernel memory allocation (`priv`), a USB device reference (`usb_get_dev`), and a HID device connection (`hid_hw_start`). The error handling path (`err_free`) attempts to maintain consistency by releasing the USB reference and freeing the memory if earlier steps fail. However, a closer look reveals a potential inconsistency: if `hid_hw_start` fails, the code jumps to `err_free`, which calls `usb_put_dev(udev)` and `kfree(priv)`. But `priv->usbdev` was already set. This is likely fine as `priv` is being freed, but it demonstrates the kind of state tracking the specification addresses. A more subtle issue is that the `wq` workqueue is not cleaned up on the error path, but it's only queued on a specific condition later.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-32545_after_exclude_100:46c3d522:spec": {
    "timestamp": "2026-01-20T10:12:07.911355",
    "cve_id": "CVE-2022-32545",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "46c3d522",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code reads pixel data into a buffer but does not perform memory allocation itself. It uses `GetAuthenticPixels` which likely allocates memory, but the code does not show initialization of that memory. However, the function's primary role is pixel data processing, not allocation/initialization, making the relevance weak.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function returns `MagickFalse` on pixel retrieval failure and uses `SyncAuthenticPixels` for finalization. Error handling is present but limited. The state of the `image` object could become inconsistent if an error occurs mid-loop, as partially written pixel rows might not be rolled back. This gives moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a PSD image parser reading from a memory buffer, not a network protocol handler. The specification is about network input validation, which is not applicable here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The function processes PSD channel pixel data. It relies on parameters like `channels`, `type`, `packet_size`, and `image->depth` which should have been validated by the caller (PSD header parser). The function itself does not validate these critical fields, making the specification highly relevant for the overall parser security, though validation likely occurs earlier.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The function does not directly perform memory allocation. It uses `GetAuthenticPixels` which may allocate based on `image->columns`. The code does not pre-validate `image->columns` or other size parameters before that call, but this is weak relevance as allocation is abstracted.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "The specification is specifically for BMP parsers. This code is for PSD (Photoshop) format parsing, so it is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Similar to spec 4, this is an image format parser function. It processes pixel data based on structural parameters (channels, depth, packet_size, columns). If these parameters have invalid relationships (e.g., packet_size inconsistent with depth), it could lead to out-of-bounds reads or incorrect processing. The function assumes they are valid, so validation is critical at the parser level.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The code contains array indexing via pointer `p` and loop variable `x`. It reads from `p` based on `packet_size` and writes to `q` (pixel array). Bounds validation is implicit: the loop runs up to `image->columns`, and `p` is assumed to have sufficient data. There is no explicit check that the input buffer `pixels` has enough bytes for `image->columns * packet_size`. This is a direct security concern for buffer over-read, making the specification highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      }
    ]
  },
  "CVE-2021-41864_after_exclude_100:4624827d:spec": {
    "timestamp": "2026-01-20T10:12:09.321982",
    "cve_id": "CVE-2021-41864",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "4624827d",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory based on `smap->map.max_entries`, which is likely a user-provided or configurable value. Specification HS-INPUT-001 is highly relevant because the code must validate that `max_entries` and the resulting `elem_size * max_entries` multiplication do not cause integer overflow or exceed system memory constraints before the allocation. The current code performs the multiplication without explicit overflow checks.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "Specification HS-PROTOCOL-002 is about verifying structural integrity of variable-length components in protocol messages. This code is for internal kernel data structure (BPF stack map) initialization and does not handle network protocol messages or variable-length data parsing.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 9,
        "reasoning": "Specification HS-MEM-003 is highly relevant. The code performs a buffer allocation (`bpf_map_area_alloc`) based on user-controllable `max_entries`. It must account for worst-case scenarios by ensuring the size calculation doesn't overflow and that the requested size is within acceptable limits. The multiplication `elem_size * smap->map.max_entries` should be checked for integer overflow.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-TIMING-001 addresses atomic operations for shared resource state transitions. This function appears to be part of map initialization, likely called during creation where concurrent access isn't an issue yet. The function doesn't show shared resource transitions that would require atomic check-and-update operations.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 has moderate relevance. The function allocates memory (`smap->elems`) and initializes a freelist with that memory. If the freelist initialization fails, it properly frees the allocated memory, maintaining consistency. However, in more complex error scenarios, ensuring strict consistency between the allocated memory and freelist state is important.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-FS-003 is about filesystem metadata operations and thread-safety. This code deals with BPF map memory allocation, not filesystem operations. The context is completely different.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-001 (duplicate number, but different content) is about regular expression parsers handling NUL bytes. This code has nothing to do with regular expression parsing or string processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-PROTOCOL-002 (duplicate number) addresses pattern compilers and escape sequences. This code is for BPF map initialization and doesn't involve pattern compilation, escape sequences, or protocol processing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-36692_before_exclude_100:31483f89:spec": {
    "timestamp": "2026-01-20T10:12:10.150702",
    "cve_id": "CVE-2021-36692",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "31483f89",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates PNG signature and critical IHDR chunk size early. It also checks width/height against cMaxPNGSize before processing, directly addressing header validation requirements.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 8,
        "reasoning": "The code performs size validation (w > cMaxPNGSize || h > cMaxPNGSize) before allocating frameRaw.p and frameRaw.rows. However, it doesn't check for overflow in rowbytes = w * 4 or imagesize = h * rowbytes.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "This specification specifically mentions BMP parser requirements, but the target code is for APNG/PNG format parsing, making it irrelevant.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "While the code allocates buffers, there's no evidence of accounting for operational padding or safety margins. The allocation is straightforward without additional padding considerations.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "This specification focuses on encoder buffers during compression operations, but the target code is a decoder parsing APNG data, making it only loosely related.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code validates various parameters against limits (w0, h0, x0, y0, dop, bop ranges) and checks boundary conditions (x0 + w0 > w, y0 + h0 > h), which aligns with parameter validation requirements.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All compression parameters must be validated against implementation limits before proc..."
      },
      {
        "score": 9,
        "reasoning": "The code strictly enforces APNG/PNG format constraints: validates signature, chunk IDs, size limits, coordinate boundaries, disposal/blend operation values, and animation control structures.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Image decoders must strictly enforce format specification constraints"
      },
      {
        "score": 5,
        "reasoning": "The code accesses frameRaw.rows and frameRaw.p with bounds checking in loops (j < h, y < h0, x < w0), but doesn't explicitly validate all array accesses against allocated sizes, particularly in processing_data calls.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Array accesses must be guarded by bounds checking against allocated size"
      }
    ]
  },
  "CVE-2021-41864_before_exclude_100:54bb4956:spec": {
    "timestamp": "2026-01-20T10:12:10.470852",
    "cve_id": "CVE-2021-41864",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "54bb4956",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `smap->map.max_entries` to calculate allocation size. This value is likely provided or influenced by userspace. Specification HS-INPUT-001 is highly relevant because the code must validate that the calculated `elem_size * smap->map.max_entries` does not cause integer overflow or exceed reasonable system constraints before passing it to `bpf_map_area_alloc`. The current code lacks explicit validation of this multiplication.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "Specification HS-PROTOCOL-002 deals with protocol message handlers and variable-length components. This code is for internal kernel memory pre-allocation for a BPF stack map and does not process network protocols or serialized messages. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 9,
        "reasoning": "Specification HS-MEM-003 is highly relevant. The code performs a buffer allocation (`bpf_map_area_alloc`) based on user-controllable inputs (`max_entries`, `value_size`). It must ensure the allocation size calculation accounts for worst-case scenarios to prevent integer overflow, excessive memory consumption, or allocation failure. The absence of explicit bounds checking for the multiplication is a direct concern addressed by this spec.</spec_1_reasoning>\n<spec_4_score>3</spec_4_score>\n<spec_4_reasoning>Specification HS-TIMING-001 concerns atomic operations for shared resource state transitions. This function appears to be part of map initialization, likely called during map creation where exclusive access is held. It does not show concurrent access to shared resources requiring atomic check-and-update operations. Relevance is low.</spec_2_reasoning>\n<spec_5_score>7</spec_5_reasoning>\n<spec_5_reasoning>Specification HS-STATE-002 has moderate relevance. The function allocates memory (`smap->elems`) and populates a freelist (`smap->freelist`) from that memory. It must maintain consistency between these two structures. The error handling path (`free_elems`) ensures that if freelist initialization fails, the allocated memory is freed, preventing an inconsistent state. However, the spec's broader context of maintaining consistency between \"different tracking structures\" applies here.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 3,
        "reasoning": "Specification HS-TIMING-001 concerns atomic operations for shared resource state transitions. This function appears to be part of map initialization, likely called during map creation where exclusive access is held. It does not show concurrent access to shared resources requiring atomic check-and-update operations. Relevance is low.</spec_2_reasoning>\n<spec_5_score>7</spec_5_reasoning>\n<spec_5_reasoning>Specification HS-STATE-002 has moderate relevance. The function allocates memory (`smap->elems`) and populates a freelist (`smap->freelist`) from that memory. It must maintain consistency between these two structures. The error handling path (`free_elems`) ensures that if freelist initialization fails, the allocated memory is freed, preventing an inconsistent state. However, the spec's broader context of maintaining consistency between \"different tracking structures\" applies here.</spec_3_reasoning>\n<spec_6_score>2</spec_6_score>\n<spec_6_reasoning>Specification HS-FS-003 is about filesystem metadata operations and thread-safety. This code is for BPF map memory management in the kernel and does not involve filesystem operations. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-STATE-002 has moderate relevance. The function allocates memory (`smap->elems`) and populates a freelist (`smap->freelist`) from that memory. It must maintain consistency between these two structures. The error handling path (`free_elems`) ensures that if freelist initialization fails, the allocated memory is freed, preventing an inconsistent state. However, the spec's broader context of maintaining consistency between \"different tracking structures\" applies here.</spec_3_reasoning>\n<spec_6_score>2</spec_6_score>\n<spec_6_reasoning>Specification HS-FS-003 is about filesystem metadata operations and thread-safety. This code is for BPF map memory management in the kernel and does not involve filesystem operations. The relevance is very low.</spec_4_reasoning>\n<spec_7_score>1</spec_7_score>\n<spec_7_reasoning>Specification HS-INPUT-001 (duplicate ID, but described as for regex parsers and NUL bytes) is not applicable. This code does not parse regular expressions or handle input patterns containing NUL bytes.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 2,
        "reasoning": "Specification HS-FS-003 is about filesystem metadata operations and thread-safety. This code is for BPF map memory management in the kernel and does not involve filesystem operations. The relevance is very low.</spec_4_reasoning>\n<spec_7_score>1</spec_7_score>\n<spec_7_reasoning>Specification HS-INPUT-001 (duplicate ID, but described as for regex parsers and NUL bytes) is not applicable. This code does not parse regular expressions or handle input patterns containing NUL bytes.</spec_5_reasoning>\n<spec_8_score>1</spec_8_score>\n<spec_8_reasoning>Specification HS-PROTOCOL-002 (duplicate ID, but described for pattern compilers and escape sequences) is not applicable. This code is for memory pre-allocation and has nothing to do with compiling patterns or processing escape sequences.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-28950_after_exclude_100:dc708239:spec": {
    "timestamp": "2026-01-20T10:12:11.293682",
    "cve_id": "CVE-2021-28950",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dc708239",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not process any userspace-provided array lengths. It operates on internal kernel structures (inode) and does not involve input validation from userspace.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code does not handle protocol messages or variable-length components. It is a simple internal function that modifies kernel data structures.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform any buffer allocation. It only manipulates existing kernel objects and sets a bit in a state field.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing or pattern processing. It is completely unrelated to this specification.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not process escape sequences or compile patterns. It is a simple kernel function for marking an inode as bad.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform string processing operations. It uses kernel API functions (remove_inode_hash, set_bit) on internal data structures.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function modifies shared resource state (inode) and sets a flag. While it doesn't show explicit atomic operations, state transitions in kernel code should be protected. The use of set_bit() is atomic at the bit level, but the overall operation sequence might need protection depending on context.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function maintains consistency between different tracking structures by removing the inode from the hash table and marking it as bad. This ensures the inode state is consistently tracked across different kernel data structures.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2021-28950_before_exclude_100:b20b2f37:spec": {
    "timestamp": "2026-01-20T10:12:12.356917",
    "cve_id": "CVE-2021-28950",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b20b2f37",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code sets a flag on an internal kernel inode structure. It does not process any userspace-provided array lengths or input, making this specification largely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "The function is a simple internal state setter for a fuse inode. It does not handle protocol messages or validate variable-length components from any external source.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 2,
        "reasoning": "No buffer allocation or input processing occurs in this function. It only manipulates an existing kernel object's state bit.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to regular expression parsing. It is a low-level filesystem function for marking an inode as bad.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilation, escape sequence processing, or any form of string interpretation.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "No string processing or operations on untrusted input are present. The function works on a trusted kernel data structure.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The function modifies a shared resource (the inode state) and should ensure atomicity to prevent race conditions. While `set_bit` is typically atomic for single bits, the context of marking an inode \"bad\" is a critical state transition that must be protected. The specification's guidance on atomic check-and-update operations is directly applicable to this type of operation.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The function updates the state of a resource (inode). While it only sets a single flag, maintaining consistency between this state flag and other potential tracking structures for the inode (e.g., cache state, open file counts) is an important consideration implied by this specification. The code itself is a simple setter, but the act of marking an inode bad likely has broader consistency requirements.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-0413_before_exclude_100:3b688cbd:spec": {
    "timestamp": "2026-01-20T10:12:12.754737",
    "cve_id": "CVE-2022-0413",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3b688cbd",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code performs arithmetic operations (e.g., line number calculations, buffer indexing), but it does not explicitly validate divisors or shift operands. The primary risk is buffer overflows or underflows, not undefined behavior from division by zero or invalid shifts. Relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate divisor and shift operands to prevent undefined be..."
      },
      {
        "score": 2,
        "reasoning": "This specification is for image format parsers, which is unrelated to the Vim substitute command code. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image format parsers must validate all mathematical operation inputs derived from file..."
      },
      {
        "score": 5,
        "reasoning": "The code manages line iteration and state during substitution, but \"mathematical consistency invariants\" is a broad term. It maintains line counts and cursor positions, but not in a rigorous mathematical sense. Moderate relevance.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Iterator state transitions must maintain mathematical consistency invariants"
      },
      {
        "score": 7,
        "reasoning": "The code performs buffer length calculations (e.g., allocating memory for substituted strings) and checks allocations, but it does not always explicitly validate remaining capacity before arithmetic. However, buffer overflows are a key concern. Moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Buffer length calculations must validate remaining capacity before arithmetic operatio..."
      },
      {
        "score": 8,
        "reasoning": "The code processes strings (patterns and substitutions) with strict boundary awareness, using functions like skip_regexp_ex and skip_substitute to avoid overflows. It handles multi-line matches and NUL characters carefully. Strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol string processing must maintain strict boundary awareness during transform..."
      },
      {
        "score": 8,
        "reasoning": "The code validates input (e.g., delimiter checks, pattern compilation) before applying substitutions. It also confirms buffer modifiability and user permissions. Strong relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Input processing must validate transformation requirements before applying modificatio..."
      },
      {
        "score": 6,
        "reasoning": "The code has multiple execution paths (e.g., with/without confirmation, count mode) and maintains state (subflags, cursor). It ensures consistency but not via formal assertions. Moderate relevance.",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Protocol state assertions must account for all valid execution paths"
      },
      {
        "score": 5,
        "reasoning": "This specification is about protocol backward compatibility, which is not applicable to Vim's substitute command. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Backward compatibility handling must maintain protocol invariants"
      }
    ]
  },
  "CVE-2022-27650_after_exclude_100:36eea24d:spec": {
    "timestamp": "2026-01-20T10:12:13.420221",
    "cve_id": "CVE-2022-27650",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "36eea24d",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It processes command-line arguments and environment variables for container execution, but does not use regex patterns in a way where embedded NUL bytes would be a concern.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "The code does not compile or process patterns with escape sequences. It handles command arguments, environment variables, and capability arrays, but there is no pattern compiler logic present.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code uses `getenv(\"LISTEN_FDS\")` and converts it via `strtoll`. While `getenv` returns a string that could be untrusted, the conversion is safe as `strtoll` handles NUL termination. However, other string operations (like `xstrdup` on argv) assume null-terminated inputs from the program's own arguments, which are typically trusted. The relevance is moderate because the principle of length-aware operations for untrusted input is a good general practice, but the code's exposure is limited.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function sets up process capabilities and the `no_new_privileges` flag for container execution. If privilege separation fails (e.g., capability dropping fails), the subsequent container execution might proceed with excess privileges. The specification about enforcing termination on failure is relevant to security-critical privilege operations, though the code shown does not explicitly implement such termination logic.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code configures security-critical state (capabilities, SELinux labels, AppArmor profiles) before container execution. A state transition occurs when `libcrun_container_exec_with_options` is called. The specification about atomic verification is loosely related because the code does not show atomic checks, but the setup is a linear configuration phase.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function validates and processes runtime configuration from command-line options and environment variables (e.g., `LISTEN_FDS`, capabilities, security profiles) before executing a container. This aligns directly with the requirement for security-sensitive daemons (here, a container runtime) to validate runtime configuration before operation.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. The code does not parse protocol messages with length fields. It handles command-line arguments and environment variables, but there are no network protocol or message length validations present.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs memory allocation via `xmalloc0` and `xmalloc` for process arguments and capabilities. While it uses wrapper functions (likely safe), the specification principle applies: size parameters (like `argc` for array allocation) should be validated against limits. The code uses `crun_assert_n_args` to check argument count, which provides some validation, but not necessarily against allocation limits.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-36692_after_exclude_100:16fe56d7:spec": {
    "timestamp": "2026-01-20T10:12:13.897061",
    "cve_id": "CVE-2021-36692",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "16fe56d7",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates PNG signature and critical header fields (IHDR size, width/height bounds) early in parsing, directly aligning with HS-INPUT-001's requirement to validate critical header fields before processing. Checks for cMaxPNGSize on w/h and later on w0/h0/x0/y0 are present.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 7,
        "reasoning": "Memory allocations (frameRaw.p, frameRaw.rows) are guarded by size validation (w > cMaxPNGSize || h > cMaxPNGSize) before allocation, but the validation could be more comprehensive (e.g., checking for overflow in imagesize = h * rowbytes). Moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "Specification explicitly targets BMP parser bit count requirements; this code is for APNG/PNG decoding, not BMP. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "While there is some size validation, the code does not clearly account for operational padding or safety margins in buffer allocations (e.g., rowbytes calculation assumes 4 bytes per pixel without explicit overflow checks). Weak relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Specification focuses on image compression encoder buffers; this is a decoder. Very low relevance.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "The code validates parameters like width, height, x0, y0, dop, bop against limits (cMaxPNGSize, dop>2, bop>1), which aligns with validating parameters against implementation limits. However, it's not strictly about compression parameters. Moderate relevance.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All compression parameters must be validated against implementation limits before proc..."
      },
      {
        "score": 5,
        "reasoning": "The code enforces many APNG/PNG format constraints: signature check, chunk validation, size bounds, disposal/blend op ranges (dop>2, bop>1), and coordinate boundaries (x0+w0>w, y0+h0>h). Highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: Image decoders must strictly enforce format specification constraints"
      },
      {
        "score": 5,
        "reasoning": "Array accesses in loops (e.g., frameRaw.rows[y], f[4*x+3]) are implicitly guarded by prior width/height validation, but no explicit bounds checking against allocated size within loops. Strong relevance as the principle applies, though implementation could be more explicit.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Array accesses must be guarded by bounds checking against allocated size"
      }
    ]
  },
  "CVE-2022-27650_before_exclude_100:603fdf83:spec": {
    "timestamp": "2026-01-20T10:12:14.328653",
    "cve_id": "CVE-2022-27650",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "603fdf83",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It processes command-line arguments and environment variables, but not in a way that uses regex patterns with embedded NUL bytes. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile or process patterns with escape sequences. It handles command arguments and environment variables directly. Very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code uses `strtoll` on an environment variable (`LISTEN_FDS`), which is potentially untrusted input. While `strtoll` is not a traditional string function, it is length-aware in the sense that it stops at the first non-digit. However, there is no explicit length validation before the conversion, which could be a concern if the variable contains very long strings. Other inputs (argv) are processed with string duplication (`xstrdup`) without explicit length checks, though they are bounded by `argc`.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function sets process capabilities and the `no_new_privileges` flag, which are directly related to privilege management. If privilege separation fails (e.g., capability setting fails), the function returns an error, but it's not clear if it enforces immediate process termination. The relevance is in the domain of privilege control.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code performs security-critical state transitions (e.g., setting capabilities, SELinux labels, AppArmor profiles) before container execution. However, there is no explicit atomic verification shown; the transitions are applied sequentially. The function relies on `libcrun_container_exec_with_options` to enforce them, but atomicity is not guaranteed in this snippet.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function validates and processes runtime configuration (e.g., capabilities, security labels, environment, arguments) for a container execution. It acts as a security-sensitive daemon (crun) that must validate this configuration before proceeding with `libcrun_container_exec_with_options`. Missing validation could lead to security issues.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does not process protocol messages with length fields. It handles command-line arguments and environment variables, where `argc` provides the count, but there is no validation against integer limits (e.g., overflow in `process->args_len = argc`). However, this is not a protocol parsing context.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs memory allocation via `xmalloc0` and `xmalloc` for `process` and its members. It uses `argc` to calculate size for `process->args` allocation (`(argc + 1) * sizeof(*process->args)`). While `argc` is trusted (from the program's own arguments), there is no explicit validation against allocation limits or integer overflow. The `dup_array` function for capabilities also duplicates arrays based on `exec_options.cap_size`, but no validation is shown. This relates to memory allocation safety.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-32545_before_exclude_100:d34c5448:spec": {
    "timestamp": "2026-01-20T10:12:16.896301",
    "cve_id": "CVE-2022-32545",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d34c5448",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses `GetAuthenticPixels` and `GetAuthenticIndexQueue` which likely perform memory allocation/retrieval. However, the code does not show the initialization of the allocated memory block itself. The pixel data is written via `SetPSDPixel` and `q++`, which initializes the target buffer. The specification is somewhat relevant as memory is being written to, but the code does not demonstrate a classic uninitialized memory read vulnerability. The primary security concern here is more about bounds checking than initialization.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "The function returns `MagickFalse` if `GetAuthenticPixels` fails, and the end returns the status of `SyncAuthenticPixels`. This shows some error handling. However, the specification about maintaining consistent object states in error paths is only moderately relevant. The code's main loop doesn't have complex error paths within it. If `SetPSDPixel` or internal operations failed, the state might not be rolled back consistently, but this is not explicitly shown.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This code is a PSD (Photoshop Document) image channel pixel reader, not a network protocol handler. The specification is about network input validation, which is not applicable to this local file parsing function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function `ReadPSDChannelPixels` is part of a PSD image format parser. It directly processes pixel data from a buffer (`pixels`). While it doesn't validate header fields itself (that likely happened earlier), the specification's core principle applies: all input data (like the `pixels` buffer, `packet_size`, `image->columns`, `channels`, `type`) must be validated before processing to prevent out-of-bounds reads/writes. The code uses these parameters in loops without explicit validation shown in this snippet, making the guidance critical.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function relies on `image->columns` for loop bounds. If this value was derived from the file header and not validated before memory allocation (e.g., in `GetAuthenticPixels`), a huge value could cause excessive memory allocation. The specification about pre-validating size parameters before allocation is a key security concern for this type of code, even though the allocation itself is not visible in this function.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. This specification is explicitly for BMP parsers. The target code is for parsing PSD (Photoshop) files.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. As an image format parser function, it must ensure structural integrity of the data. The code processes data based on `packet_size` (1, 2, or other), `image->depth`, `channels`, and `type`. Incorrect or malicious values in these fields, or a mismatch between `image->columns` and the actual size of the `pixels` buffer, could lead to buffer overflows or out-of-bounds reads. Validation of these relationships is crucial, though it may occur outside this function.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The code contains critical array indexing and pointer arithmetic. The loop `for (x=0; x < (ssize_t) image->columns; x++)` uses `x` to index the image pixel array. The pointer `p` is incremented (`p++`, `PushShortPixel`, `PushFloatPixel`) based on `packet_size` without explicit checks that `p` stays within the bounds of the input `pixels` buffer. Similarly, `q` is incremented (`q++`) without explicit check against the allocated pixel row size. This is a classic source of buffer overflows if input parameters are malicious.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      }
    ]
  },
  "CVE-2021-3712_before_exclude_100:5f3bdf54:spec": {
    "timestamp": "2026-01-20T10:12:18.312612",
    "cve_id": "CVE-2021-3712",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5f3bdf54",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes ASN.1/DER encoded parameters which can contain embedded NUL bytes in fields like curve->a->data and curve->b->data. The BN_bin2bn function uses length parameters, so embedded NULs are handled correctly. However, the primary security concern is not about regular expression parsing, making the relevance weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 2,
        "reasoning": "This specification addresses pattern compilers and escape sequences, which are completely unrelated to elliptic curve parameter parsing. The code processes binary ASN.1 structures, not text patterns with escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code extensively uses length-aware operations when processing potentially untrusted input parameters. Functions like BN_bin2bn, EC_POINT_oct2point, and memcpy all use explicit length parameters from the ASN.1 structures, preventing buffer overflows from malformed inputs.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "While this function parses parameters rather than performing cryptographic operations directly, it creates EC_GROUP structures that will be used for cryptographic operations. The function validates parameters but doesn't implement constant-time operations itself. However, it influences whether the resulting group uses constant-time implementations.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code explicitly attempts to match explicit parameters against built-in curves to use specialized, side-channel resistant implementations. The comment explains this is for \"better performance and hardening.\" This is a direct implementation of side-channel resistance for elliptic curves.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2022-0572_before_exclude_100:365c8d6f:spec": {
    "timestamp": "2026-01-20T10:12:21.407228",
    "cve_id": "CVE-2022-0572",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "365c8d6f",
    "scores": [
      {
        "score": 4,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. The target code is a tab/space conversion function (retab) that processes lines of text. While it does process strings and could encounter NUL bytes (as string terminators), it is not a regex parser. The relevance is weak because the core functionality is different, though string handling principles could loosely apply.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences; it converts whitespace (spaces/tabs) in text buffers. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "The specification recommends length-aware string operations for untrusted input. The code processes buffer lines (which could be considered untrusted user data) and uses operations like STRLEN, mch_memmove, and pointer arithmetic. It does not appear to use unsafe functions like strcpy, but it calculates lengths and copies memory with size calculations. There is moderate relevance because safe buffer handling is important, though the code's context is text editing, not network input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "The specification requires memory allocations to be fully initialized. The code allocates memory with alloc() and then initializes parts of it (e.g., filling with spaces/tabs). However, it does not necessarily initialize the entire allocated buffer before use (e.g., the tail part copied via mch_memmove may leave gaps uninitialized). This is moderately relevant because proper initialization prevents information leaks.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The specification requires error handling paths to maintain consistent object states. The code has several error checks (e.g., alloc failure, u_save failure) and early returns. It must ensure that buffer state, window settings (w_p_list), and allocated memory (new_vts_array, new_ts_str) are properly cleaned up or restored on errors. The code shows some cleanup (e.g., restoring w_p_list, freeing memory), making this strongly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "The specification is about network protocol handlers validating input. The target code processes editor buffer lines and command arguments locally, not network data. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 7,
        "reasoning": "The specification requires validating buffer boundaries before access. The code uses pointer arithmetic (ptr[col]) and loops until NUL, but also uses mb_ptr2len for multi-byte characters, which could overflow if invalid sequences exist. It relies on internal buffer integrity. This is moderately relevant because boundary checks are important for safe string processing, especially with multi-byte characters.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 5,
        "reasoning": "The specification requires parsers to maintain consistent buffer state invariants. The code is not a parser in the traditional sense (like parsing a language), but it does parse lines to identify whitespace regions. It modifies the buffer in-place and must ensure the buffer remains consistent (e.g., line lengths, NUL termination). Relevance is weak to moderate because buffer consistency is important but not the primary security focus.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2022-0699_after_exclude_100:a6c92b39:spec": {
    "timestamp": "2026-01-20T10:12:24.016295",
    "cve_id": "CVE-2022-0699",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a6c92b39",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses strtok which is NUL-terminated string based and does not involve regular expression parsing. Embedded NUL bytes in the input would cause strtok to stop processing early, but this is not a regular expression parser context.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not process escape sequences or compile patterns. It's a simple string splitting function using strtok with delimiter characters.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 7,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "The code allocates memory via realloc but doesn't explicitly initialize all bytes. However, it immediately assigns pointers to the allocated slots, so there's no use of uninitialized memory in practice.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "The code maintains consistent object states in error paths by properly freeing allocated memory before returning NULL, though there's a potential issue if realloc fails when i=0.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "This is not a network protocol handler. It's a general string utility function that could be used in various contexts including network processing, but the code itself doesn't handle network protocols.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The error handling paths consistently free allocated memory (copy, result array, and individual strings) across different failure scenarios, maintaining memory state consistency.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 6,
        "reasoning": "The code creates a copy of the input and processes it, but doesn't perform explicit input validation or boundary establishment before memory operations like realloc.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2021-24029_before_exclude_100:80d225e5:spec": {
    "timestamp": "2026-01-20T10:12:24.384417",
    "cve_id": "CVE-2021-24029",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "80d225e5",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code does not involve parsing numeric fields from a buffer. It is focused on updating the internal handshake state by retrieving and assigning cryptographic ciphers and parameters that have already been derived and validated by a lower layer (Fizz).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol message parsing must validate all numeric fields against remaining buffer len..."
      },
      {
        "score": 2,
        "reasoning": "The specification is about SSH message handlers and strict structural validation. The target code is for QUIC, not SSH, and does not parse or handle incoming message formats directly. It operates on already-processed cryptographic objects.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: SSH message handlers must maintain strict structural validation of message formats"
      },
      {
        "score": 1,
        "reasoning": "The code performs no integer arithmetic or memory operations based on calculated sizes. It deals with object pointers and moves smart pointers/objects.",
        "spec_index": 2,
        "spec_preview": "HS-LOGIC-003: Integer operations must include overflow checks before use in memory operations"
      },
      {
        "score": 3,
        "reasoning": "The code is not about packet parsing failure handling. It is a state update function that assumes the handshake layer is already initialized. However, it does check for the presence of `clientParams` and throws an exception if missing, which relates to state validation but not specifically to parsing failures.",
        "spec_index": 3,
        "spec_preview": "HS-STATE-001: Packet parsing failure handling must ensure complete state initialization"
      },
      {
        "score": 2,
        "reasoning": "The code is not a protocol dissector and does not validate packet headers. It retrieves pre-validated cryptographic material from the handshake layer.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol dissectors must validate complete header presence before processing"
      },
      {
        "score": 5,
        "reasoning": "The code ensures fields (like ciphers) are initialized (non-null) before using them (e.g., moving them to connection state). The `CHECK(!conn.oneRttWriteCipher.get())` also guards against re-initialization. This aligns with the spirit of guaranteeing initialization before use, though not in a network input parsing context.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Network input processing must guarantee field initialization before use"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit resource cleanup. It moves resources into the connection state. The specification about conditional cleanup based on initialization success is not directly applicable.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 8,
        "reasoning": "This is highly relevant. The function's core purpose is to retrieve and assign cryptographic ciphers (key objects) that have been derived by the handshake layer. The handshake layer (e.g., Fizz/TLS) must have already performed algorithm support verification during the handshake before creating these cipher objects. The code implicitly relies on this prior verification being complete and correct.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2017-18926_before_exclude_100:f030234f:spec": {
    "timestamp": "2026-01-20T10:12:27.090959",
    "cve_id": "CVE-2017-18926",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f030234f",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It is an XML writer function that constructs XML output, not parsing input patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code processes escape sequences via `raptor_xml_escape_string` when handling `xml:lang` attribute values. While it's not a pattern compiler, it must correctly handle escape sequences to maintain boundary integrity between data and markup.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code extensively uses length-aware string operations (e.g., `raptor_iostream_counted_string_write`, `raptor_xml_escape_string` with length parameters) when processing element names, namespace prefixes, and attribute values, which is crucial for safe handling of untrusted input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "Strong relevance. The code allocates `nspace_declarations` array based on calculated `nspace_max_count` and accesses it via indices `i` and `nspace_declarations_count`. While loops appear bounded by counts, careful review is needed to ensure no off-by-one errors occur given the complex counting logic across multiple code sections.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. As an XML writer, it assumes input structures (elements, attributes) are already validated. However, it does enforce namespace declaration logic and ordering, which relates to structural constraints of XML output generation.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. This is an XML protocol implementation that must maintain strict boundary integrity between markup and data. It uses proper escaping for attribute values and carefully manages namespace declarations to prevent injection or malformed XML output.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses `RAPTOR_CALLOC` for zero-initialization of `nspace_declarations`. However, it also directly assigns to array members without full initialization of all fields in some paths, though the structure appears simple. The allocation failure check is present.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code has a clear error handling path (`error:` label) that frees allocated memory for `nspace_declarations` and their `declaration` strings. This maintains consistent state by cleaning up resources before returning error code 1.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-3712_after_exclude_100:5b29d6f4:spec": {
    "timestamp": "2026-01-20T10:12:29.405326",
    "cve_id": "CVE-2021-3712",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5b29d6f4",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code processes ASN.1/DER encoded parameters which are binary data, not regular expressions. While it does handle input with length fields, the primary concern is not embedded NUL bytes in patterns but rather the correct parsing of structured cryptographic parameters. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers and escape sequences, which is not applicable to this code. This function parses elliptic curve parameters from ASN.1 structures, not textual patterns or escape sequences. Relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code extensively processes potentially untrusted input (ASN.1 parameters) using length-aware operations. It checks for NULL pointers and validates the `length` field of `ASN1_STRING` structures (e.g., `params->curve->a->length`) before using them in functions like `BN_bin2bn` and `memcpy`. This is a direct application of the specification.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function itself is a parameter parsing and group construction routine, not the core cryptographic operation (e.g., scalar multiplication). However, it influences which cryptographic implementation is used. The comment indicates a preference for built-in curves with \"specialized methods with better performance and hardening,\" which may include constant-time properties. The code does not itself implement constant-time algorithms.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 7,
        "reasoning": "Strong relevance. The function is central to instantiating elliptic curve groups from external parameters. Its choice of implementation (explicit parameters vs. named built-in curve) directly impacts whether side-channel resistant methods are used. The code explicitly tries to match parameters to a built-in curve to use a \"specialized EC_METHOD\" which is likely hardened. This is a key decision point for side-channel resistance.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The specification combines memory operations with constant-time requirements. This code uses `memcpy` for the seed, which is not secret, and other operations (BN_set_bit, ASN1_INTEGER_to_BN) are on public parameters. The primary security concern here is validation and correctness, not maintaining constant-time properties during memory manipulation of secrets.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code validates multiple length and size fields from the input parameters against security limits. Key examples: checking `field_bits > OPENSSL_ECC_MAX_FIELD_BITS`, validating the order `a` against the Hasse bound (`BN_num_bits(a) > (int)field_bits + 1`), and checking basis parameters (e.g., `char_two->m > tmp_long && tmp_long > 0`). This prevents resource exhaustion and invalid curve attacks.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs several memory allocations and validates associated size parameters. It checks for allocation failures (e.g., `if ((p = BN_new()) == NULL)`). More importantly, it validates the `length` field from input before using it in `OPENSSL_malloc` for the seed copy, preventing potential integer overflow or excessive allocation. The use of `field_bits` limit also acts as an indirect allocation size validation for internal structures.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2021-29556_before_exclude_100:b2607ab7:spec": {
    "timestamp": "2026-01-20T10:12:30.523105",
    "cve_id": "CVE-2021-29556",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b2607ab7",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation (reverse operation) and contains no cryptographic operations on secret values. It is a general-purpose compute kernel, not a cryptographic function.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no relation to elliptic curve cryptography or any cryptographic curve models. It is a tensor operation in what appears to be a machine learning framework.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory operations for tensor data but is not involved in cryptographic processing. There is no indication of secret data handling requiring constant-time properties.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code manipulates tensor data structures and does not implement view-based data access with privilege checks. It operates on tensor buffers without security context or ownership semantics.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "The code performs a computational operation without security-critical state transitions or privilege context management. It's a pure data transformation function.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The code has no relation to SQL protocols or database view security. It operates on tensor data structures in a computational context.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code allocates output memory based on input shape and performs write operations. While it validates dimensions and shape consistency, it doesn't explicitly validate buffer space before each write in the lower-level HandleReverseCase implementation (not shown). The shown code does proper allocation but the actual data writing happens elsewhere.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer write operations must validate available space before each write"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates input dimensions and maintains consistency between input and dimension specifications, which relates to maintaining invariants during parsing/processing. However, it's not a parser in the traditional sense and doesn't involve complex state transitions with buffer position tracking.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser state transitions must maintain buffer position invariants"
      }
    ]
  },
  "CVE-2022-0699_before_exclude_100:cead6673:spec": {
    "timestamp": "2026-01-20T10:12:31.486873",
    "cve_id": "CVE-2022-0699",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cead6673",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `strtok` which is not NUL-aware and will stop at the first embedded NUL byte in the input string. If `arg` contains embedded NULs, the splitting behavior will be incorrect/unexpected, which is a security concern for pattern parsing. However, this is not explicitly a \"regular expression parser,\" so relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not process escape sequences or compile patterns. It is a simple string splitter using `strtok` with a delimiter string. The specification about pattern compilers and escape sequences has very low relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code uses `strtok` which is not length-aware and operates on null-terminated strings. If `arg` comes from untrusted input and contains no null terminator (or is not properly bounded), `strtok` could read out of bounds. The function should use length-aware operations for untrusted input.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code initializes memory indirectly through `dupstr` (assumed to allocate and copy) and assignment of pointers. There's no explicit initialization of allocated memory bytes (like zeroing), but the pointers are set before use. The main risk is uninitialized pointer values if `realloc` fails in certain paths, but the code handles failure.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The error handling paths (when `realloc` fails) attempt to free previously allocated strings and the result array, then free `copy` and return NULL. However, there's a bug: in the second `realloc` failure path, `free(copy)` is called after `copy` was already freed earlier in the function. This creates an inconsistent state (double-free).",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code is a generic string splitting utility, not a network protocol handler. There's no network input validation involved.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. This specification directly addresses the memory state consistency in error paths. As noted in spec_5, there's a double-free bug in the second error path (`free(copy)` after `copy` already freed). Also, if the first `realloc` fails when `result` is NULL, the loop to free `result[i]` is skipped, which is correct, but the double-free remains a critical memory state inconsistency.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The function takes a `const char* arg` without a length parameter, implying it trusts the input to be properly null-terminated. If untrusted input lacks a null terminator, `dupstr` (likely using `strlen`/`strdup`) and `strtok` could read out of bounds. Clear boundaries (e.g., accepting a length parameter) should be established before memory operations.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2017-18926_after_exclude_100:30d8d02f:spec": {
    "timestamp": "2026-01-20T10:12:32.239967",
    "cve_id": "CVE-2017-18926",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "30d8d02f",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not involve regular expression parsing. It is an XML writer function that constructs XML elements, namespaces, and attributes. There is no pattern matching or regex processing that would need to handle embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "While the code does process escape sequences via `raptor_xml_escape_string` for the `xml:lang` attribute value, this is a specific, controlled escape for XML attribute values, not a general pattern compiler. The relevance is weak because the specification focuses on pattern compilers maintaining boundaries, which is a broader and more complex security concern than this single escape operation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "The code extensively uses length-aware operations. It uses `counted_string_write` with explicit lengths (`local_name_length`, `prefix_length`), calculates buffer sizes (`buf_length`), and uses `raptor_xml_escape_string` which takes a length parameter. This is highly relevant for safely handling potentially untrusted input strings that may not be null-terminated.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 7,
        "reasoning": "The code shows moderate relevance. It calculates buffer sizes (e.g., `buf_length` for xml:lang) and uses `raptor_xml_escape_string` which likely performs bounds checking. However, direct array accesses like `nspace_declarations[nspace_declarations_count]` rely on the earlier allocation size (`nspace_max_count`), and there is no explicit check that `nspace_declarations_count < nspace_max_count` before each write. This is a potential risk.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The function is part of an XML writer, not a parser. Its primary job is to output structured data, not validate input. However, it does process input structures (element, attributes) to generate output, so there is a moderate relevance regarding ensuring the input structure is valid before processing (e.g., checking pointers, sequence sizes) to avoid crashes.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      },
      {
        "score": 9,
        "reasoning": "This is highly relevant. The code is a core part of an XML protocol implementation (writing). It must maintain strict boundary integrity when constructing namespace declarations, attributes, and escaped content (like `xml:lang`). Proper handling of lengths, escaping, and memory boundaries is critical to prevent XML injection, malformed output, or buffer overflows in the generated stream.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: XML protocol implementation must maintain strict boundary integrity during parsing"
      },
      {
        "score": 5,
        "reasoning": "The code uses `RAPTOR_CALLOC` which zero-initializes the allocated `nspace_declarations` array. The `struct nsd` fields are then explicitly assigned before use. There is no use of uninitialized memory. The relevance is very low as the specification is already adequately addressed.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has a clear error handling path (`goto error;`) that cleans up allocated memory (`nspace_declarations` and their `declaration` strings). This ensures that on failure, resources are freed and a consistent error state (return value 1) is maintained. However, it does not roll back other state changes like modifications to `nstack` if `raptor_namespace_stack_start_namespace` fails after some have succeeded.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2021-3489_before_exclude_100:356876e0:spec": {
    "timestamp": "2026-01-20T10:12:33.977928",
    "cve_id": "CVE-2021-3489",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "356876e0",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code validates the input `size` against `RINGBUF_MAX_RECORD_SZ`, which is a platform-specific limit check. This is a direct length validation, though it's for an internal kernel ring buffer operation, not a network protocol message. The relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs critical validation before \"reserving\" space in the ring buffer. It checks that `size` does not exceed a maximum record size, and then calculates the required length (`len`), ensuring the new producer position does not overflow the buffer's capacity (`rb->mask`). This aligns with validating size parameters against allocation/usage limits.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "This specification concerns protocol type handling across stages. The target code is a low-level kernel memory buffer manager for BPF, not a protocol implementation. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The `size` parameter is ultimately provided from userspace (via a BPF program helper). The code validates it against `RINGBUF_MAX_RECORD_SZ`, which is a system constraint. However, the validation is a simple upper bound check; the specification's context of \"array lengths\" is only loosely related to this single size parameter.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "This specification is about verifying the structural integrity of variable-length protocol components. The code manages a flat byte ring buffer and writes a header, but it does not parse or handle complex protocol messages with components. Relevance is very low.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The function's core purpose is to reserve buffer space. It explicitly accounts for the worst-case input scenario by: 1) checking `size` against a maximum, 2) rounding up the total size, and 3) verifying that the new producer position does not exceed the available space relative to the consumer position, using the buffer's mask. This is a direct implementation of buffer allocation with explicit size limits.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "This specification is about memory release operations and ownership semantics. The provided code only handles the *reservation* of space in a ring buffer, not the release or deallocation of memory. The `BUSY_BIT` indicates ownership transfer, but the release logic would be in a separate function. Relevance is negligible.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "This specification is about file content processing edge cases. The target code operates on a kernel ring buffer data structure, not files. There is no relevance.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      }
    ]
  },
  "CVE-2021-37642_before_exclude_100:2c3286e4:spec": {
    "timestamp": "2026-01-20T10:12:34.353931",
    "cve_id": "CVE-2021-37642",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2c3286e4",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor scatter operations, not cryptographic operations on secret values. There is no handling of cryptographic keys, signatures, or encryption that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor computation kernel for machine learning operations, not an elliptic curve implementation. There is no cryptographic curve arithmetic or side-channel resistance mechanisms present.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "While the code performs memory operations on tensor data, it does not involve cryptographic processing or secret data that would require constant-time memory operations. The operations are standard tensor manipulations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code performs integer size validations (checking N_big against std::numeric_limits<Index>::max() and params->dim_size(0) against the same limit) to prevent overflow in index calculations, which is conceptually similar to file position calculations needing appropriate integer types.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates tensor shape relationships and index bounds (checking indices are within [0, params->dim_size(0))), which is analogous to validating file positions against archive boundaries, though in a different domain (tensor operations vs. archive parsing).",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses OP_REQUIRES to validate conditions and exits early on failures, which helps maintain consistent state. However, this is not specifically about archive parsing state consistency during position calculation failures.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Archive parsing state must remain consistent during position calculation failures"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code uses RefCountPtr for resource management but doesn't show complex initialization sequences or conditional cleanup based on initialization success. The resource handling is minimal and not the focus of this code.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "No relevance. The code does not involve cryptographic algorithms, key objects, or algorithm support verification. It's performing tensor scatter operations in a machine learning context.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2021-37642_after_exclude_100:29e11f55:spec": {
    "timestamp": "2026-01-20T10:12:34.811429",
    "cve_id": "CVE-2021-37642",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "29e11f55",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs tensor scatter operations, not cryptographic operations on secret values. There is no handling of cryptographic keys, signatures, or other secret data that would require constant-time execution to prevent timing attacks.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is a tensor computation kernel for scatter operations, not an elliptic curve implementation. There is no cryptographic curve manipulation or side-channel resistance considerations present.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor manipulation operations, not secure memory operations for cryptographic processing. While it does access memory, it doesn't handle cryptographic secrets or require constant-time memory operations.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code performs integer size validations (N_big <= std::numeric_limits<Index>::max()) to prevent overflow when converting between int64_t and Index types. This is similar to file position calculations needing appropriate integer sizing, though in a different context.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File position calculations must use appropriately sized integer types to prevent overf..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates tensor shape relationships and index bounds (checking indices are within [0, params->dim_size(0))). This is conceptually similar to validating file positions against archive boundaries, though applied to tensor indices rather than file positions.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Archive parsers must validate all calculated file positions against archive boundaries"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code validates inputs before operations and returns errors via OP_REQUIRES, which maintains consistent error state. However, this is not specifically about archive parsing state consistency during position calculation failures.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Archive parsing state must remain consistent during position calculation failures"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses RefCountPtr for resource management, which provides automatic cleanup. However, there's no explicit conditional cleanup based on initialization success shown in this snippet.",
        "spec_index": 6,
        "spec_preview": "HS-STATE-001: Resource cleanup must be conditional on successful initialization"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code performs tensor operations, not cryptographic key object creation. There is no algorithm support verification or cryptographic key handling present.",
        "spec_index": 7,
        "spec_preview": "HS-CRYPTO-002: Algorithm support verification must precede key object creation"
      }
    ]
  },
  "CVE-2017-9782_before_exclude_100:5e95bef3:spec": {
    "timestamp": "2026-01-20T10:12:36.001927",
    "cve_id": "CVE-2017-9782",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5e95bef3",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses jas_alloc2 for dynamic memory allocation (e.g., for dec->chantocmptlut and lutents). While the allocated memory for lutents is initialized via a loop, there is no explicit guarantee that all allocated memory is fully initialized before use. The specification is highly relevant as uninitialized memory use could lead to information disclosure or instability.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple error handling paths (goto error) that must clean up resources (boxes, decoder) to maintain consistent object states. It properly sets pointers to NULL after destruction and uses a central error label for cleanup. This is a strong example of consistent error state management.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-3489_after_exclude_100:e54de199:spec": {
    "timestamp": "2026-01-20T10:12:36.299279",
    "cve_id": "CVE-2021-3489",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e54de199",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code validates the input `size` parameter against `RINGBUF_MAX_RECORD_SZ`, which is a form of validating a length field against a platform-specific limit. However, this is not strictly about network protocol messages but about an internal kernel ring buffer API. The validation is present but the context is not exactly protocol message handling.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The function performs implicit memory \"allocation\" (reservation) within a ring buffer. It validates the `size` parameter against both a maximum record size (`RINGBUF_MAX_RECORD_SZ`) and, after rounding up, against the available buffer capacity (`rb->mask + 1`). It also checks for sufficient space before proceeding, which aligns with validating size against allocation limits and usage requirements.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The code deals with internal kernel data structures for a ring buffer, not with external protocol parsing or serialization. There is no handling of different data types or stages of protocol processing. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "The `size` parameter is likely provided from userspace (via a BPF program syscall). The code validates it against system constraints (`RINGBUF_MAX_RECORD_SZ` and the ring buffer's capacity) before using it to calculate offsets and write to memory. This is a direct application of the specification's intent.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The specification is about verifying the structural integrity of variable-length components in protocol messages. This code handles a fixed-size header and a variable-sized payload within a ring buffer, but its integrity checks are about buffer bounds and space, not about parsing or validating the structure of an incoming message from an untrusted source. The relevance is weak.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 9,
        "reasoning": "This specification is strongly relevant. The function's primary purpose is to reserve space in a fixed-size buffer (the ringbuf). It accounts for the worst-case scenario by validating that the requested size (plus header) does not exceed the total buffer size and that there is enough contiguous space (via the `new_prod_pos - cons_pos > rb->mask` check) before committing the reservation. This prevents buffer overflow.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 2,
        "reasoning": "This function is about memory reservation (allocation), not memory release or deallocation. It does not contain any `free`, `kfree`, or similar release operations. The specification is not applicable to this code snippet.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory release operations must maintain strict ownership semantics"
      },
      {
        "score": 5,
        "reasoning": "The code does not process file content. It manages a ring buffer in kernel memory. This specification has no relevance to the provided code.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: File content processing must handle all edge cases including empty files"
      }
    ]
  },
  "CVE-2022-23571_after_exclude_100:df128c09:spec": {
    "timestamp": "2026-01-20T10:12:36.639631",
    "cve_id": "CVE-2022-23571",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "df128c09",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs bounds validation indirectly through `TensorShape::IsValid()` and by checking `N > 0` before processing content. However, the validation is not explicitly \"strict bounds validation before write operations\" for fixed buffers, as the buffer allocation and writes happen inside `Decode` or `FromProtoField` helper functions which aren't shown. Moderate relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "The code validates input size through `TensorShape::IsValid()` and checks `N > 0` before processing tensor content. It also validates data type and handles empty tensors. This represents input size validation before processing, though the complete validation of content size depends on helper functions.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant as this is a configuration/parser function for TensorProto. It enforces structural constraints by validating tensor shape, data type, and checking for dtype errors. The CASES_WITH_DEFAULT pattern ensures only valid data types are processed.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code deals with binary tensor data, not string operations. There's no evidence of string functions or NUL-termination concerns in this tensor parsing code.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory buffers passed to string functions must guarantee NUL-termination"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code maintains state consistency by validating inputs before allocation, checking for allocation failures (p == nullptr), and properly managing buffer references with UnrefIfNonNull. However, the exact safety invariants depend on the helper functions.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Buffer allocation must maintain invariant of known-safe state"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance as this is a protocol parser for TensorProto. It validates buffer boundaries by checking tensor shape validity and element count before processing content. The validation occurs before calling Decode or FromProtoField methods.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Protocol parsers must validate buffer boundaries before processing"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code tracks size through `shape.num_elements()` and validates it, but the actual memory allocation and size tracking happens in helper functions (Decode/FromProtoField). The code does maintain consistency between shape and allocated buffer.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code manages tensor buffer resources by properly unreferencing old buffers (`UnrefIfNonNull(buf_)`) before assigning new ones. It maintains invariant consistency through validation before state changes and handles allocation failures.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2022-3103_before_exclude_100:dc39a069:spec": {
    "timestamp": "2026-01-20T10:12:37.391658",
    "cve_id": "CVE-2022-3103",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dc39a069",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code validates a user-provided file descriptor index (`fd`) against `ctx->nr_user_files`. This is a form of length/bounds validation, but it's for an array index within a kernel data structure, not a protocol message length field. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain any explicit memory allocation operations. It performs bounds checking on an index to safely access an existing array slot. The specification about validating size parameters for allocation is very low relevance here.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code is part of an asynchronous I/O cancellation operation within the io_uring subsystem, not a network or inter-process protocol implementation. The handling of flags and file descriptors is internal to the kernel subsystem. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The function accesses shared kernel resources (the `ctx->file_table` array). The comment mentions dropping a lock (`uring_lock`), implying concurrency is a concern. However, the code shown does not perform an atomic state transition itself; it performs a bounds-checked read. The relevance to protecting state transitions is weak to moderate.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The code ensures consistency when accessing a file descriptor slot. It validates the index, uses `array_index_nospec` for Spectre mitigation, and checks if the slot's `file_ptr` is non-NULL before using it. This helps maintain consistency between the index (`fd`), the array bounds (`nr_user_files`), and the actual resource (`file`). There is moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      },
      {
        "score": 5,
        "reasoning": "The code operates on file-related kernel metadata (file table slots). The context (io_uring) is highly concurrent, and the comment about dropping a lock implies thread-safety is a critical design consideration for the surrounding code. The function itself performs safe access to a shared file table. Relevance is moderate to strong.",
        "spec_index": 5,
        "spec_preview": "HS-FS-003: Filesystem metadata operations must guarantee thread-safety for all concurrent access pat..."
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code's primary security action is validating a userspace-provided array index (`fd`) against a system constraint (`ctx->nr_user_files`) before using it to access the kernel's `file_table` array. It also uses `array_index_nospec` to prevent speculative execution attacks, which is an advanced form of this validation. This directly aligns with HS-INPUT-001's intent.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "Similar to spec_3, this code is not handling variable-length protocol messages. It processes kernel-internal data structures based on flags and an index. The specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2017-9782_after_exclude_100:1197ce4e:spec": {
    "timestamp": "2026-01-20T10:12:37.716718",
    "cve_id": "CVE-2017-9782",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1197ce4e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via jas_alloc2 and jas_alloc2 for lutents. While it allocates memory, it doesn't explicitly show full initialization before use. The allocated chantocmptlut is initialized in loops, but there's potential risk if allocation succeeds but initialization fails or is incomplete. This is relevant to memory initialization security concerns.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has extensive error handling with goto error paths. It maintains object states (dec, box, image pointers) and ensures cleanup on error paths. The error handling consistently frees resources and nullifies pointers, showing good attention to consistent object states during error conditions.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 7,
        "reasoning": "While this is a file format decoder rather than network protocol handler, it validates input boxes (JP, FTYP, IHDR, etc.) before processing. It checks magic numbers, box types, and consistency between different parts of the JPEG2000 file structure, which is analogous to input validation in network protocols.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-23571_before_exclude_100:dd146535:spec": {
    "timestamp": "2026-01-20T10:12:38.788004",
    "cve_id": "CVE-2022-23571",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "dd146535",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code performs bounds validation indirectly through `TensorShape::IsValid` and by checking `N > 0` before processing. However, the validation is not explicitly \"strict bounds validation before write operations\" for a fixed buffer, as the buffer is dynamically allocated by `Decode` or `FromProtoField`. The relevance is moderate because the principle of validating shape/element count before allocation aligns with the specification's intent.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      },
      {
        "score": 8,
        "reasoning": "The code validates the input `proto` for valid tensor shape and data type before processing. It also checks if the number of elements (`N`) is greater than 0 before proceeding with decoding. This constitutes input size validation, making it strongly relevant to the specification.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Input parsers must implement complete input size validation before processing"
      },
      {
        "score": 9,
        "reasoning": "The code acts as a configuration/state parser for a TensorProto. It enforces structural constraints by validating `tensor_shape()` and `dtype()`, and ensures the data (either from `tensor_content` or fields) matches the expected type and element count. This is highly relevant to configuration parser security.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Configuration parsers must enforce structural constraints on input data"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve string functions (like strcpy, strlen) or NUL-terminated strings. It handles raw tensor content and typed fields. Therefore, this specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory buffers passed to string functions must guarantee NUL-termination"
      },
      {
        "score": 5,
        "reasoning": "The code maintains a known-safe state by validating all inputs before allocation (`buf_`). It only updates the internal state (`shape_`, `dtype_`, `buf_`) after successful validation and allocation, and properly unreferences the old buffer. This strongly aligns with maintaining allocation invariants.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Buffer allocation must maintain invariant of known-safe state"
      },
      {
        "score": 5,
        "reasoning": "This is a protocol parser (TensorProto). It validates the buffer boundaries implicitly by ensuring the `tensor_shape()` is valid and that the number of elements `N` is consistent with the provided data in `tensor_content` or fields via the `Decode`/`FromProtoField` helpers. This is a core security concern for the function, making it highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-003: Protocol parsers must validate buffer boundaries before processing"
      },
      {
        "score": 5,
        "reasoning": "The code tracks size via `TensorShape` and `N`. The allocation size consistency is delegated to `Helper<T>::Decode` and `FromProtoField<T>`. The parent function validates the expected element count but does not directly manage the allocation size tracking. Relevance is moderate.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocation operations must maintain consistent size tracking"
      },
      {
        "score": 5,
        "reasoning": "The function manages the critical resource `buf_` (TensorBuffer). It maintains invariant consistency by validating input, checking for allocation failures (`p == nullptr`), and using a transactional approach (only updating member variables after successful validation/allocation, and properly cleaning up the old buffer). This is strongly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource management operations must maintain invariant consistency"
      }
    ]
  },
  "CVE-2022-0518_before_exclude_100:9adee18e:spec": {
    "timestamp": "2026-01-20T10:12:40.124735",
    "cve_id": "CVE-2022-0518",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9adee18e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses R_NEW0 which zero-initializes memory, satisfying the initialization requirement. However, the code does not fully initialize the `attr` structure if the early `r_bin_java_default_attr_new` call fails (returns NULL), though this is handled by returning early. The main relevance is the proper zero-initialization of the `icattr` structure.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error handling paths (memory allocation failures, boundary checks). When `icattr` allocation fails, it breaks from the loop but doesn't clean up the partially built list, potentially leaving the `attr` object in an inconsistent state (with some classes added but not all). The early return when `attr` is NULL is consistent.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 2,
        "reasoning": "This specification is about network protocol handlers, but the code is parsing Java class file attributes from a binary buffer, not network data. While similar validation principles apply, the context is different.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "The code validates the `number_of_classes` field indirectly through boundary checking (`offset + 8 > sz`) in the loop. However, it doesn't explicitly validate the length field against integer overflow or platform limits before using it to control loop iterations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs critical size validation with `if (offset + 8 > sz)` before reading each inner class entry. This prevents buffer overreads. However, it doesn't validate the initial `sz` parameter against allocation limits or check for integer overflow in offset calculations.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code handles Java class file format parsing and maintains consistent type handling for the inner classes attribute structure. However, the specification focuses more on network protocols, and the code's type handling is specific to Java binary format.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "Not applicable. The code does not use regular expressions at all; it parses binary Java class file structures.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not process patterns or escape sequences; it parses binary data structures from Java class files.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2016-10317_after_exclude_100:43c160f8:spec": {
    "timestamp": "2026-01-20T10:12:43.259787",
    "cve_id": "CVE-2016-10317",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "43c160f8",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory copying operations based on calculated widths and offsets. Specification HS-MEM-003 is highly relevant because the function must ensure the destination buffer (`dest_strip`) has sufficient capacity for the total copied data (`left_width + num_tiles * src_width + right_width`). The code does not validate this, creating a potential buffer overflow if allocation was insufficient.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 3,
        "reasoning": "Specification HS-IO-004 is about image compression encoder buffers. The target code appears to be a helper function for filling a threshold buffer, likely for image processing, but it does not perform compression or explicit encoder operations. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-001 (String operations) is moderately relevant. While the code uses `memcpy` (not string functions), the core requirementvalidating length against buffer capacitydirectly applies. The function uses multiple length parameters without checking if they exceed the destination buffer's remaining capacity, which is the essence of this spec.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-001: String operations must validate length fields against remaining buffer capacity"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 (External format parsers) has weak relevance. The function takes parameters like widths and offsets, which could originate from external input (e.g., an image file header). A complete validation chain for these parameters before they are passed to this function would prevent overflows, but the spec's focus on \"parsers\" is broader than this low-level copy routine.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-002: External format parsers must implement complete length validation chains"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-LOGIC-001 (Image dimension calculations) is moderately relevant. Parameters like `src_width`, `left_width`, `num_tiles`, and `right_width` are effectively image/tile dimensions. The code does not validate them against maximum safe values, and an overflow in the calculation `left_width + num_tiles * src_width + right_width` could lead to an incorrect total size, though the more immediate risk is the buffer overflow during the copy.",
        "spec_index": 4,
        "spec_preview": "HS-LOGIC-001: Image dimension calculations must validate against maximum safe values before memory a..."
      },
      {
        "score": 5,
        "reasoning": "Specification HS-INPUT-002 (External input validation) is strongly relevant. The function's pointer and integer parameters are inputs. The code blindly trusts these values (e.g., `left_offset`, `src_width`) in memory operations. An attacker could provide malicious values to cause buffer over-reads (from `src_strip`) or overflows (into `dest_strip`). Validation before use is critical.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-002: External input must be validated before use in memory operations"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-003 (Memory allocation validation) is highly relevant. This is closely related to spec_1. The function assumes the `dest_strip` buffer is large enough for the total copy operation. The caller must have validated the allocation size against the calculated requirement. The function itself does not perform this check, which is a security gap the specification aims to address.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Memory allocation must be validated against calculated size requirements"
      },
      {
        "score": 5,
        "reasoning": "Specification HS-MEM-001 (Fixed buffer bounds validation) is highly relevant. This is the most direct specification for this code. The function operates on a buffer (`dest_strip`) and must enforce strict bounds validation before each `memcpy` write. It performs no validation on the destination pointer increments or the source offsets, making it vulnerable to out-of-bounds writes and reads. The PACIFY_VALGRIND block hints at padding concerns but is not a security bound check.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-001: Fixed buffer operations must enforce strict bounds validation before write operations"
      }
    ]
  },
  "CVE-2021-37682_before_exclude_100:83f167f4:spec": {
    "timestamp": "2026-01-20T10:12:44.169631",
    "cve_id": "CVE-2021-37682",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "83f167f4",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a TensorFlow Lite SVDF operator preparation function. It handles tensor dimensions, data types, and memory allocation. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. The specification is about a completely different domain (regex parsers).",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not involve pattern compilers or the processing of escape sequences. It is focused on numerical tensor operations for a machine learning kernel. The specification is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "While the code processes tensor data (which could be considered input), it primarily uses TensorFlow Lite's API functions (like `GetInputSafe`, `ResizeTensor`) which handle bounds and sizes internally. The core logic validates tensor dimensions and sizes, which is a form of length-aware operation, but it's not directly about string processing or untrusted input in the classic security sense. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor shape validation, memory allocation, and quantization parameter calculations. It does not perform any cryptographic operations on secret values. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is for a neural network layer (SVDF), not an elliptic curve cryptography implementation. The specification is not applicable.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code allocates and resizes temporary tensors for numerical computation. It does not perform secure memory operations (like wiping secrets) or cryptographic processing that requires constant-time properties. The specification is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code has no concept of view-based data access, database views, or privilege checks. It operates on tensor data within a single computational context. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code manages the internal state of a neural network operator (allocating scratch buffers, setting quantization parameters). This is a program state transition, but it is not security-critical in terms of privilege context or access control. The specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2022-37032_before_exclude_100:0b19ef00:spec": {
    "timestamp": "2026-01-20T10:12:49.707864",
    "cve_id": "CVE-2022-37032",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0b19ef00",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code directly implements length validation for capability fields. It checks if `pnt + 3 > end` for the basic header and later checks `pnt + (cap.length + 3) > end` before processing capability data. This aligns with HS-INPUT-001's requirement to validate field lengths before accessing data.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 7,
        "reasoning": "The code validates the capability action value and performs some structure validation for the MP capability type (checking AFI/SAFI values). However, for unrecognized capability codes, it only logs a warning and continues, rather than strictly rejecting the malformed message or performing comprehensive validation for all capability types as implied by the specification.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 9,
        "reasoning": "The code maintains strict bounds checking throughout the parsing loop with multiple checks (`pnt + 3 > end`, `pnt + (cap.length + 3) > end`) and carefully advances the pointer `pnt += cap.length + 3`. This ensures the parser stays within packet boundaries.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 8,
        "reasoning": "The code enforces length constraints by checking capability length against the remaining buffer (`end` pointer). While it doesn't explicitly reference RFC-specified constraints, it implements practical length validation that prevents buffer overflows.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code implements TLV-style parsing (Type-Length-Value for capabilities) with complete bounds checking before accessing capability data. The check `pnt + (cap.length + 3) > end` occurs before processing the capability value, which is exactly what this specification requires.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 9,
        "reasoning": "This is essentially the same as specification 1. The code validates the capability length field (`cap.length`) before using it to calculate offsets or access the corresponding capability data, preventing buffer overflows.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 5,
        "reasoning": "The code validates message boundaries through multiple checks against the `end` pointer. It ensures the parser doesn't exceed the declared message length (`length` parameter), though it could be more rigorous about validating that the entire message is consumed exactly.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains separation through pointer arithmetic and bounds checks, but there's potential concern with `memcpy(&cap, pnt + 1, sizeof(struct capability))` which copies before fully validating the capability length. While the structure size is fixed and small, this technically mixes validated and unvalidated data regions.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2021-37682_after_exclude_100:1a12f78d:spec": {
    "timestamp": "2026-01-20T10:12:50.137513",
    "cve_id": "CVE-2021-37682",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1a12f78d",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code is a TensorFlow Lite SVDF operator preparation function. It handles tensor dimensions, data types, and memory allocation. It does not involve regular expression parsing or processing of input patterns with embedded NUL bytes. The specification is about a specific input validation issue for regex parsers, which is completely unrelated to this numerical computation code.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code performs tensor operations and memory management for a machine learning operator. It does not involve pattern compilers, escape sequence processing, or any text/pattern manipulation. The specification is about compiler/parser security for escape sequences, which has no relevance to this numerical array processing code.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 3,
        "reasoning": "While the code does process input data (tensors), it uses TensorFlow Lite's API functions for safe tensor access (GetInputSafe, GetOutputSafe). However, the specification specifically addresses string processing functions and length-aware operations for untrusted input. This code deals with numerical tensors, not strings, and uses framework-provided safety mechanisms rather than direct string manipulation.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code implements a machine learning operator (SVDF) for inference, not cryptographic operations. It performs tensor dimension validation, memory allocation, and quantization parameter calculations. There are no secret values being processed, and timing attacks are not a concern for this type of numerical computation in neural network inference.",
        "spec_index": 3,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is part of a neural network inference engine (TensorFlow Lite) and implements an SVDF (Singular Value Decomposition Filter) layer. It has no relation to elliptic curve cryptography, cryptographic implementations, or side-channel resistance for cryptographic operations.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs memory allocation and tensor resizing operations for numerical computation. While it does handle memory, it's not performing secure memory operations for cryptographic purposes, nor does it need to maintain constant-time properties. This is standard numerical array processing for machine learning inference.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code operates within a neural network inference context, managing tensor data and computation parameters. It does not involve view-based data access, database views, privilege checks, or any security context management. This is purely numerical computation code without any access control mechanisms.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "The code implements a preparation function for a neural network operator. It validates tensor dimensions, allocates memory, and sets up computation parameters. There are no security-critical state transitions, privilege contexts, or security state management involved. This is standard numerical computation setup code.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      }
    ]
  },
  "CVE-2022-0518_after_exclude_100:7b2d032b:spec": {
    "timestamp": "2026-01-20T10:12:50.484469",
    "cve_id": "CVE-2022-0518",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "7b2d032b",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses R_NEW0 which zero-initializes memory, satisfying the initialization requirement. However, there is a potential issue if the allocation succeeds but subsequent field assignments fail before the structure is fully initialized for use (e.g., if r_bin_java_get_item_name_from_bin_cp_list fails and the function breaks early, a partially initialized icattr could be appended to the list). The initialization pattern is good but not perfectly robust against all error paths.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has multiple error handling paths (e.g., buffer boundary checks, allocation failures). It attempts to maintain consistency by breaking loops and returning NULL in some cases. However, when breaking from the loop due to an error, it does not clean up the attr->info.inner_classes_attr.classes list that was already created, potentially leaving the attr object in an inconsistent state (a list exists but may be incomplete). Also, if memory allocation for icattr fails, the loop breaks but the attr is still returned with a partial list.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This specification is about network protocol handlers validating input. The target code parses a binary structure (Java class file attribute) from a buffer, not network data. While input validation is relevant, the context is file/format parsing, not network protocols.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code validates length fields against the buffer size (sz). It checks \"buf_offset + offset + 8 > sz\" before reading the number_of_classes and again inside the loop before reading each class entry. This is a form of length field validation. However, it does not explicitly check for integer overflow when calculating these offsets (e.g., buf_offset + offset could overflow), which is part of platform-specific integer limits. The validation is present but not complete.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs size validation before reading data (checking buf_offset + offset + 8 > sz). This validates that the data to be read fits within the buffer, which is a check against usage requirements. It does not explicitly check allocation limits for the R_NEW0 allocation, but that allocator likely has its own checks. The main concern is the validation of the buffer size parameter 'sz' against the reads performed.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code parses a specific Java class file attribute (InnerClasses). It reads fields as unsigned shorts consistently using R_BIN_JAVA_USHORT. However, the specification about \"consistent type handling across all processing stages\" is broad. The code seems consistent in reading the binary format, but there is no explicit validation that the indices read (like inner_name_idx) are valid indices into the constant pool, beyond attempting to retrieve the item and printing an error if NULL. This could be seen as a type consistency issue (index vs. actual pool size).",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expressions at all; it parses binary Java class attributes.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This specification is about pattern compilers and escape sequences. The target code does not compile patterns or process escape sequences; it parses binary data structures.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-32978_after_exclude_100:da4e78ec:spec": {
    "timestamp": "2026-01-20T10:12:52.146406",
    "cve_id": "CVE-2022-32978",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "da4e78ec",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses pointers and array-like accesses (e.g., *lp++, line->m_pNext) but does not show explicit memory allocation. Memory initialization is not a primary focus; the code appears to operate on pre-allocated buffers (line->m_pData). Weak relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code contains comments like \"No error handling strategy\" and \"No error handling here\" in critical decoding loops. Error states from BeginReadMCU or GolombDecode are not handled, potentially leaving objects in inconsistent states.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is an image decompression routine (JPEG-LS) processing a byte stream, not a network protocol handler. Input validation may occur elsewhere but is not shown in this function.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not involve regular expression parsing or NUL byte handling.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not involve pattern compilers or escape sequence processing.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code processes a compressed bit/byte stream with length checks (e.g., 'length' variable) but does not use string processing functions.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code uses buffers (line->m_pData) but does not show allocation. Padding requirements are not evident, though buffer overflows could occur if m_ulWidth[0] exceeds allocated size.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. This is an image compression/decompression operation (JPEG-LS). The code lacks explicit bounds checking when writing to *lp (line buffer). While 'length' is decremented, no validation ensures lp stays within buffer bounds, risking encoder/decoder buffer overflows.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2022-37032_after_exclude_100:f2bb1a2e:spec": {
    "timestamp": "2026-01-20T10:12:53.948009",
    "cve_id": "CVE-2022-37032",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f2bb1a2e",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code directly validates the capability length field (hdr->length) before using it to calculate memory offsets and copy data. It checks if (pnt + hdr->length + 3) > end before proceeding with memcpy and processing. This is a direct implementation of validating field lengths before data access.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 7,
        "reasoning": "The code validates the capability code (hdr->code) and only processes CAPABILITY_CODE_MP, logging warnings for unrecognized codes. However, it doesn't perform comprehensive structure validation for the MP capability data beyond basic bounds checking and AFI/SAFI validation. Some structure validation is present but not exhaustive.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 9,
        "reasoning": "The code maintains strict bounds checking throughout the parsing loop with multiple checks: (pnt + 3 > end) for minimum header, (pnt + hdr->length + 3 > end) for capability data, and the loop condition (pnt < end). This prevents buffer overflows during packet dissection.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 6,
        "reasoning": "The code validates length fields against the message boundary (end pointer), which is a form of RFC-specified length constraint enforcement. However, it doesn't appear to check for minimum/maximum values of hdr->length beyond the buffer boundary check, which would be more specific RFC validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code implements TLV-like processing (Type-Length-Value where type=code, length=hdr->length, value=capability data) with complete bounds checking before accessing the capability data. The check (pnt + hdr->length + 3 > end) ensures the entire TLV structure fits within bounds.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 9,
        "reasoning": "Same as spec_1. The code validates the capability length field (hdr->length) before using it for memory operations (memcpy) and pointer arithmetic (pnt += hdr->length + 3). This prevents buffer overflows and ensures safe data access.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 8,
        "reasoning": "The code validates message boundaries through multiple checks against the 'end' pointer. It ensures each capability structure fits within the remaining message buffer. However, it doesn't validate the overall message length at function entry or check for integer overflows in pointer arithmetic.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains separation through pointer arithmetic and bounds checking, but the memcpy(&mpc, pnt + 3, sizeof(...)) copies unvalidated data directly into a stack structure. While length was checked, the content validation occurs after copying. True separation would validate before or during copying.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2021-37672_after_exclude_100:a34d0faa:spec": {
    "timestamp": "2026-01-20T10:12:55.141505",
    "cve_id": "CVE-2021-37672",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a34d0faa",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs data initialization and validation for a machine learning kernel (likely in TensorFlow). It involves input validation, memory allocation, and data structure setup. There are no cryptographic operations on secret values present in this code.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is unrelated to elliptic curve cryptography or any cryptographic curve implementations. It deals with feature representations and example data for model training/inference.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 5,
        "reasoning": "While the code involves memory operations (resizing vectors), these are not security-critical memory operations for cryptographic processing. The operations are standard C++ container manipulations for data management.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement view-based data access or perform any privilege checks. It processes input tensors and builds internal data structures without any access control mechanisms.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 5,
        "reasoning": "There are no security-critical state transitions or privilege context management in this code. The function initializes data structures and validates input dimensions.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 5,
        "reasoning": "The code is completely unrelated to SQL protocols or database access. It's a TensorFlow kernel operation for machine learning feature processing.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 5,
        "reasoning": "No privilege separation mechanisms are present in this code. It performs input validation and data structure initialization without any security enforcement or process termination logic.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 5,
        "reasoning": "There are no security-critical state transitions requiring atomic verification. The code performs sequential data validation and initialization operations.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2021-37672_before_exclude_100:8cca0078:spec": {
    "timestamp": "2026-01-20T10:12:55.465086",
    "cve_id": "CVE-2021-37672",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8cca0078",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs data initialization and feature processing for a machine learning model (likely in TensorFlow). It involves input validation, memory allocation, and parallel processing but contains no cryptographic operations on secret values. The specification is about constant-time execution for cryptography, which is not applicable here.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code has no elliptic curve implementations or any cryptographic operations. It is focused on feature representation and example processing for machine learning tasks.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "While the code involves memory operations (resizing vectors, accessing tensors), it is not performing cryptographic processing. The specification's requirement for constant-time properties during cryptographic operations is irrelevant to this context.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement view-based data access or perform any privilege checks. It is processing input tensors and building internal data structures for model computation.",
        "spec_index": 3,
        "spec_preview": "HS-SEC-001: View-based data access must perform privilege checks as the view owner"
      },
      {
        "score": 1,
        "reasoning": "There are no security-critical state transitions or privilege contexts in this code. It is initializing data structures and validating input sizes for a computational kernel.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Security-critical state transitions must maintain consistent privilege context"
      },
      {
        "score": 1,
        "reasoning": "The code has no SQL protocol implementations or database view security semantics. It is part of a machine learning framework's tensor processing logic.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: SQL protocol implementations must enforce view security semantics for all data acce..."
      },
      {
        "score": 1,
        "reasoning": "No privilege separation mechanisms or process termination logic is present. The function returns error status objects for invalid arguments but does not terminate processes.",
        "spec_index": 6,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 1,
        "reasoning": "No security-critical state transitions requiring atomic verification are performed. The code validates inputs and initializes data structures in a sequential manner.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      }
    ]
  },
  "CVE-2022-31307_after_exclude_100:34d7b269:spec": {
    "timestamp": "2026-01-20T10:12:56.672177",
    "cve_id": "CVE-2022-31307",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "34d7b269",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process regular expression patterns. It is an iterator function for arrays, strings, and objects. While it handles string data, the specification about embedded NUL bytes in regex patterns is not directly applicable. The relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification concerns pattern compilers and escape sequence processing. This code is an iterator, not a compiler or parser for patterns with escape sequences. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The function processes strings using length-aware operations (e.g., `njs_string_prop`, `string_prop.size`, `njs_string_offset`, `njs_utf8_prev`). It correctly handles byte and UTF-8 sequences by tracking start and end pointers, which is crucial for safe handling of potentially untrusted input to prevent over-reads.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about validating protocol message length fields. This code does not parse protocol messages or validate length fields from an external source. The relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code performs a memory allocation via `njs_object_value_alloc` and checks for NULL. However, it does not explicitly validate size parameters against allocation limits or usage requirements before the allocation. The relevance is moderate because memory safety is involved, but the specification's focus is not the core activity of this function.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "Strong relevance. The function's core purpose is type handling (array, string, object string, generic object) and it dispatches processing based on strict type checks (`njs_is_array`, `njs_is_string`, etc.). Ensuring consistent type handling across these branches is critical to avoid type confusion vulnerabilities.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about enforcing RFC-specified length constraints for protocol messages. This code is not implementing a network protocol or validating RFC-defined fields. The relevance is very low.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code performs bounds checking (e.g., `from < array->length`, pointer arithmetic within `string_prop.start` and `end`) which aligns with the spirit of bounds checking before access. However, it is not processing TLV (Type-Length-Value) structures specifically. The relevance is indirect and weak.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-31307_before_exclude_100:744d7366:spec": {
    "timestamp": "2026-01-20T10:12:56.998624",
    "cve_id": "CVE-2022-31307",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "744d7366",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not involve regular expression parsing. It is an iterator function for arrays, strings, and objects. While it processes string data, it does not parse or compile regular expression patterns with embedded NUL bytes.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The code does not compile patterns or process escape sequences. It iterates over existing data structures (arrays, strings, objects) and applies a handler function. The specification about pattern compilers and escape sequences is not applicable.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The function processes strings with explicit length checks (via `njs_string_prop` and `string_prop.size`). It handles both byte/ASCII and UTF-8 strings safely by using length-aware operations and pointer bounds (`start`, `end`), which is crucial for potentially untrusted input to prevent buffer overflows.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages with length fields. It operates on JavaScript-like values (arrays, strings, objects) within a VM context. The validation of `from` and `to` indices is against array/string lengths, not protocol-specific integer limits.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code includes a memory allocation for `njs_object_value_alloc` with a NULL check, which is a basic validation. However, it does not show explicit validation of size parameters against allocation limits or complex usage requirements. The primary security concern here is more about bounds checking during iteration.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Moderately to strongly relevant. The function implements consistent type handling across arrays, strings, and objects. It uses type checks (`njs_is_array`, `njs_is_string`, `njs_is_object_string`, `njs_is_object`) to dispatch to appropriate processing paths, which helps prevent type confusion vulnerabilities.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages or enforce RFC-specified constraints. It is an internal iteration function for a JavaScript-like language runtime, not a network protocol implementation.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "Weak to moderate relevance. The code performs bounds checking when iterating over arrays and strings (e.g., `from < array->length`, pointer checks against `start` and `end`). While not TLV (Type-Length-Value) processing specifically, the principle of bounds checking before access is applied, especially in the string iteration loops.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      }
    ]
  },
  "CVE-2022-0890_before_exclude_100:91b6f52b:spec": {
    "timestamp": "2026-01-20T10:12:57.528365",
    "cve_id": "CVE-2022-0890",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "91b6f52b",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not process protocol messages or validate message length fields. It is a fiber context switching function within a language runtime (likely mruby). The primary operations involve state validation and stack manipulation, not network protocol handling.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code calls `mrb_stack_extend(mrb, len+2)` which likely involves memory allocation or stack expansion. While not a direct memory allocation like malloc, it should validate the `len` parameter against reasonable limits to prevent excessive memory consumption or stack overflow. The specification's guidance on validating size parameters is applicable.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This specification concerns protocol implementations and consistent type handling across processing stages. The target code is an internal runtime function managing fiber state transitions, not a protocol implementation.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not contain any regular expression parsing logic. It works with fiber contexts, stack values, and function calls.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not involve pattern compilers or processing of escape sequences. It is a control flow management function for fibers.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code copies an array of values (`mrb_value *a`) using a loop, which is length-aware via the `len` parameter. However, this is not string processing, and the input `a` is an internal array pointer, not necessarily untrusted user input. The principle of bounds-checked copying is present but not the primary focus.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Moderate to strong relevance. The function performs critical state transitions for fibers. Before switching context, it validates the fiber's status and updates the status of the old context (`old_c->status = ...`). It also initializes stack slots during the copy loop. Ensuring all relevant context fields (status, prev, stack contents) are in a consistent, initialized state before and after the switch is crucial to prevent use of uninitialized data or invalid state, which aligns with the specification's intent.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a core function for the code's security. The function extensively validates the fiber state (`status`) through a switch statement and raises errors for invalid transitions (transferred, running, resumed, terminated). It must ensure that after any error is raised (or during normal flow), the state of both the current fiber (`c`) and the old context (`old_c`) remains consistent and valid. The assignment `old_c->status = ...` before the actual switch and the management of `c->prev` are critical to maintaining a consistent object state graph.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2013-4668_before_exclude_100:5ab17dd3:spec": {
    "timestamp": "2026-01-20T10:12:57.827220",
    "cve_id": "CVE-2013-4668",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5ab17dd3",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code does not handle any protocol message length fields. It is a GUI dialog function for file extraction, dealing with file paths and user interactions, not network protocols or message parsing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory operations (g_free, _g_string_list_free) but does not show explicit memory allocation with size parameters that need validation. The primary risk is use-after-free (freeing odata at the end), but the specification about validating size parameters for allocation is not directly applicable.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a network or data protocol. It handles file operations and GUI callbacks, so protocol type consistency is not relevant.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not use regular expressions. It processes file paths and strings but not with regex parsers.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not contain pattern compilers or process escape sequences. It is a file operation dialog handler.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code processes strings (file paths via `_g_path_get_relative_basename` and `base_name`). While it uses GLib functions which are generally safe, the input `odata->current_file->data` could be untrusted (from an archive). The relevance is moderate as length-aware operations are a good practice, but not directly visible in this snippet.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code accesses data structures (e.g., `odata->current_file->data`) and uses GLib functions that may internally handle buffers. Buffer bounds validation is a general secure coding principle relevant to any data access, but no explicit buffer operations are shown. The risk of null pointer dereference exists if `odata->current_file` is NULL when accessed, but the condition checks for non-NULL.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Buffer access operations must validate bounds before dereferencing"
      },
      {
        "score": 5,
        "reasoning": "The code performs some input validation (checking `odata->current_file != NULL` and `odata->edata->file_list`). However, it does not involve deep parsing of structured data. The validation is more about program state than parsing input streams, so relevance is weak.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Parser input validation must enforce structural constraints before content processing"
      }
    ]
  },
  "CVE-2022-3303_before_exclude_100:9d8a28f6:spec": {
    "timestamp": "2026-01-20T10:12:58.157206",
    "cve_id": "CVE-2022-3303",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9d8a28f6",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `snd_pcm_format_set_silence` to initialize memory regions in the audio buffer before use. This is a form of memory initialization, which aligns with the spirit of HS-MEM-001. However, the specification is about *allocations*, and this code is initializing an already allocated runtime buffer. The relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "This code has multiple error handling paths (e.g., after `mutex_lock_interruptible`, `snd_pcm_oss_sync1`, `snd_pcm_kernel_ioctl`). It consistently uses `goto unlock;` and decrements `rw_ref` before returning errors, maintaining the state of shared objects (like the mutex lock and atomic reference count). This is a strong example of consistent state management in error paths.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is an audio (OSS) driver synchronization function. It does not handle network protocols. The specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not process network protocol messages or validate length fields from such messages. The specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs calculations for buffer sizes (`size`) but does not involve explicit memory allocation calls (like `kmalloc`, `vmalloc`). The size calculations use values derived from internal runtime state (e.g., `period_bytes`, `buffer_used`). While buffer bounds should be checked, the specification's focus on allocation operations makes it only loosely related.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles audio data formats (e.g., `snd_pcm_format_t`, `width`) and access modes (`SNDRV_PCM_ACCESS_RW_INTERLEAVED`). It must ensure consistent handling of these types when writing silence or data. There is moderate relevance, as type consistency is important for correct audio buffer manipulation.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not contain or call any regular expression parsers. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not compile or process patterns containing escape sequences. The specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-3303_after_exclude_100:e642d750:spec": {
    "timestamp": "2026-01-20T10:12:58.450926",
    "cve_id": "CVE-2022-3303",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e642d750",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code uses `snd_pcm_format_set_silence` to initialize memory regions in the audio buffer before use, which is related to memory initialization. However, it's not about initializing allocated memory structures themselves (like `kmalloc`), but rather ensuring buffer content is defined. The relevance is moderate.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code has multiple error handling paths (e.g., after `mutex_lock_interruptible`, `snd_pcm_oss_make_ready_locked`, `snd_pcm_oss_sync1`) that use `goto` statements to unlock mutexes and decrement reference counts (`atomic_dec(&runtime->oss.rw_ref)`) before returning. This maintains consistent state for shared resources (locks, refcounts) on errors.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. This is an audio (OSS) driver synchronization function, not a network protocol handler. No network input validation is present.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not process protocol messages with length fields. It deals with internal audio buffer sizes and pointers.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the code performs size calculations (e.g., `size = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width`), these are for internal buffer manipulation, not for validating parameters for memory allocation functions like `kmalloc`. The risk is buffer overflow within pre-allocated regions, but the specification is about allocation size validation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The specification is about protocol type handling. This code handles audio data formats (e.g., `snd_pcm_format_t`), but it's not a network/generic protocol implementation where type confusion across stages is a typical threat.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not contain any regular expression parsing logic.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Not applicable. The code does not contain any pattern compiler or processing of escape sequences.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-40574_before_exclude_100:068bcf0f:spec": {
    "timestamp": "2026-01-20T10:13:00.793392",
    "cve_id": "CVE-2021-40574",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "068bcf0f",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code performs encoding conversion operations (UTF-8, UTF-16) but does not validate the return value of `gf_utf8_wcstombs` before using it to copy data with `strcpy`. This directly violates the specification's requirement to validate return values before buffer operations.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 8,
        "reasoning": "The code uses fixed-size buffers (`szLineConv[1024]`) and performs potentially unsafe operations like `strcpy(szLine, szLineConv)` without checking if the source fits in the destination. The loop also accesses `szLine[i+1]` without bounds checking, risking buffer overflows.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 5,
        "reasoning": "The character encoding conversion logic (for unicode_type<=1) has complex byte-by-byte manipulation but lacks proper error handling for invalid byte sequences. The conversion path using `gf_utf8_wcstombs` also lacks error checking, violating the requirement for complete error handling paths.",
        "spec_index": 2,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "The code initializes `szLine` with `memset` but does not initialize `szLineConv` before use. While `szLineConv` is written to before being read, partial initialization could occur in error paths. The specification is moderately relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple early returns and error paths but doesn't clearly maintain consistent object states. For example, when `sOK` is NULL, the function returns without ensuring `szLine` is in a valid state. However, this is less critical than buffer safety issues.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This specification addresses network protocol handlers, but the code processes file input (FILE *txt_in), not network input. The validation principles are similar but not directly applicable.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This specification concerns regular expression parsers handling NUL bytes, but the code performs character encoding conversion, not regular expression parsing. The specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "This specification addresses pattern compilers processing escape sequences, but the code performs text encoding conversion without pattern compilation or escape sequence processing. The specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2021-40574_after_exclude_100:6c712836:spec": {
    "timestamp": "2026-01-20T10:13:01.617236",
    "cve_id": "CVE-2021-40574",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6c712836",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs UTF-8 and UTF-16 encoding conversions but does not validate the return value of `gf_utf8_wcstombs` before using it to index and null-terminate `szLineConv`. This violates the requirement to validate return values before buffer operations.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All encoding conversion operations must validate return values before buffer operation..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses fixed-size buffers (`szLineConv[2048]`) and performs string operations (`strcpy`) without proper bounds checking. The `gf_utf8_wcstombs` conversion could potentially overflow the 2048-byte buffer if the converted string exceeds this size.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Fixed-size buffer operations must enforce strict bounds checking"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-ENCODING-003: Character encoding conversions must implement complete error handling paths"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2015-8874_after_exclude_100:e13340e2:spec": {
    "timestamp": "2026-01-20T10:13:01.939993",
    "cve_id": "CVE-2015-8874",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e13340e2",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation. It operates on an already allocated image structure (gdImagePtr) and manipulates pixel data. Therefore, the specification about initializing memory allocations before use has very low relevance.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function has minimal error handling (e.g., checking if border < 0). However, it does not manage complex object states that need to be rolled back on error. The main state change is pixel color modification, which is not transactional. The specification about maintaining consistent object states in error paths is only loosely applicable.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is an image processing function, not a network protocol handler. There is no network input validation involved.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. While not a full file format parser, the function processes numeric inputs (x, y, border, color) and performs some basic validation (border < 0, bounds checking for x and y). However, it does not comprehensively validate all numeric fields for signedness and range as a parser would.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. This is an image processing function (flood fill) that uses recursion. The recursion depth is controlled by the image's content (pixel colors) and could potentially lead to unbounded stack growth if the image is crafted maliciously (e.g., large contiguous areas without the border color). The specification about implementing bounded iteration in image decoders directly addresses this class of vulnerability.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The function implements a flood fill algorithm with a state (lastBorder) but it's a simple linear scan and recursion control, not a complex state machine parsing external data. Validation of intermediate states is minimal.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The function does not allocate or deallocate any resources (memory, files, etc.). It only modifies pixel values within an existing image structure.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Resource deallocation must use matching release functions for allocated types"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. Similar to spec_7, this function does not manage resource lifecycle (creation/destruction). It operates on an already existing image resource.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource lifecycle transitions must maintain consistency between creation and destruct..."
      }
    ]
  },
  "CVE-2015-8874_before_exclude_100:db5432e6:spec": {
    "timestamp": "2026-01-20T10:13:02.867565",
    "cve_id": "CVE-2015-8874",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "db5432e6",
    "scores": [
      {
        "score": 3,
        "reasoning": "The code does not perform any explicit memory allocation. It operates on an existing image structure (gdImagePtr) and manipulates pixel data. Therefore, the specification about initializing memory allocations is not directly applicable.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has a simple error handling path (returning early if `border < 0`). However, the function's primary operation is to modify the image state by setting pixels. The early return occurs before any state modification, which is consistent. The relevance is weak because the function is not managing complex object states or transactions, but the basic principle of maintaining a consistent image state is present.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is an image processing function (flood fill), not a network protocol handler. This specification is not applicable.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 6,
        "reasoning": "While not a file format parser, the function validates the `border` parameter against being negative, which is a basic numeric range check. It does not validate the `x`, `y`, or `color` parameters against the image bounds or color table range, which could be a security issue (out-of-bounds access). The specification is moderately relevant as it highlights a missing validation that should be present.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 9,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 4,
        "reasoning": "The function uses a simple state variable (`lastBorder`) to manage the fill logic across a scanline. It validates the state transition based on pixel color. However, this is a simple algorithmic state, not a complex parser state machine. The relevance is weak.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 2,
        "reasoning": "The code does not allocate or deallocate any resources (memory, files, etc.). It only reads and writes pixels within an existing image structure. This specification is not applicable.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Resource deallocation must use matching release functions for allocated types"
      },
      {
        "score": 2,
        "reasoning": "Similar to spec_7, the function does not manage resource lifecycle (creation/destruction). It operates on a provided image resource. This specification is not applicable.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource lifecycle transitions must maintain consistency between creation and destruct..."
      }
    ]
  },
  "CVE-2022-25258_before_exclude_100:1fd9edb6:spec": {
    "timestamp": "2026-01-20T10:13:04.656772",
    "cve_id": "CVE-2022-25258",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1fd9edb6",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the w_length field from the USB control request against USB_COMP_EP0_BUFSIZ, which is a platform-specific buffer size limit. This directly addresses protocol message length validation. However, the validation is incomplete for the case where w_length > USB_COMP_EP0_BUFSIZ and data direction is IN - it truncates the length but doesn't return an error, which could be a security concern.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "No evaluation reason",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code shows consistent type handling by converting USB control request fields from little-endian to CPU endianness using le16_to_cpu(). It also uses appropriate type casting and size calculations with min() and min_t() functions. However, there's a concerning cast of const __le16* to non-const when modifying wLength.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 6,
        "reasoning": "The code initializes request structure fields (req->zero, req->context, req->complete, req->length) before use. However, the initialization happens after some conditional logic, and buffer initialization depends on called functions.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code has multiple error paths (goto done, break statements) but maintains some state consistency. However, error handling for the w_length truncation case could leave the system in an inconsistent state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant as this is a USB protocol handler that validates input parameters (w_length, w_index, w_value) before processing. It checks request types, validates interface bounds, and performs length validation against buffer sizes.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "The code validates w_length against USB_COMP_EP0_BUFSIZ, which is a system constraint. It also validates w_index for interface bounds against MAX_CONFIG_INTERFACES. However, the validation could be more comprehensive.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 7,
        "reasoning": "The code handles variable-length USB descriptors and validates lengths before copying data. It uses min() to ensure response lengths don't exceed requested lengths or buffer sizes. However, the structural integrity checking is somewhat basic.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2020-12674_before_exclude_100:d064254f:spec": {
    "timestamp": "2026-01-20T10:13:12.236499",
    "cve_id": "CVE-2020-12674",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d064254f",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code reads a length field from the input data and uses it for memory allocation and bounds checking. However, it does not validate that the length value itself is within platform-specific integer limits (e.g., against SIZE_MAX or INT_MAX) before using it in arithmetic operations like `p + len` or as an argument to `p_malloc`. This omission could lead to integer overflow vulnerabilities.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code allocates memory based on the user-controlled `len` value. While it checks `p + len > end` for buffer boundaries, it does not validate `len` against allocation limits (e.g., maximum allowed allocation size) or ensure the allocated size is suitable for subsequent usage (the `memcpy`). This could lead to excessive memory consumption or other allocation-related issues.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "Low relevance. The code handles a simple length-prefixed buffer read. There is no indication of complex type handling or type conversions across processing stages that would make this specification directly applicable.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code uses `memcpy` to copy data into the newly allocated buffer, which initializes it with the input data. It does not leave the allocated memory uninitialized before use, so this specification is not applicable.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The function has early error returns (return 0) when bounds checks fail. However, it does not appear to manage complex object states. The main concern is whether callers handle the 0 return correctly and whether any partial state changes occur before the error (here, only `*data` is advanced on success, not on error, which is good).",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. This is a network protocol handler function that reads a buffer from input data. It performs validation (bounds checks on `p` and `p + len`) before processing (allocation and copy). However, as noted in spec_1 and spec_2, the validation could be more comprehensive regarding integer limits and allocation size.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve regular expression parsing. It reads a length-prefixed binary buffer, not a regex pattern.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The code does not involve pattern compilation or processing of escape sequences. It is a simple buffer read operation.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-25258_after_exclude_100:e3514cc4:spec": {
    "timestamp": "2026-01-20T10:13:15.704879",
    "cve_id": "CVE-2022-25258",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "e3514cc4",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code validates the `w_length` field from the USB control request against `USB_COMP_EP0_BUFSIZ` at the beginning. This is a direct validation of a protocol message length field against a platform-specific limit, which aligns with HS-INPUT-001. However, the validation is not exhaustive for all possible length fields in the protocol (e.g., other descriptors), so it's not a perfect match.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform explicit memory allocation operations within the shown function. It uses pre-allocated buffers (`req->buf`). Therefore, HS-MEM-002, which focuses on validating size parameters for allocations, has very low direct relevance.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "The code handles various USB request types and descriptors, converting data from little-endian format (`le16_to_cpu`) and ensuring consistent handling through switch statements. There is an effort to maintain type consistency (e.g., using `min_t(int, ...)` for signed comparisons, casting). However, there are areas like the cast of `__le16 *temp` to modify a `const` field which could be seen as a type consistency issue, making the relevance moderate.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 6,
        "reasoning": "The code initializes the `req` structure fields (zero, context, complete, length) before use. In the OS descriptors handling block, it also uses `memset(buf, 0, w_length)`. This shows some adherence to initializing memory before use. However, not all code paths guarantee full initialization (e.g., some `break` statements may leave `req->buf` contents undefined), making relevance moderate.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 9,
        "reasoning": "This function is a USB gadget protocol handler. It extensively validates input parameters from the USB control request (`ctrl`): checking request type, length, recipient, and indices (e.g., `intf >= MAX_CONFIG_INTERFACES`). This is a core part of the function's logic, making HS-IO-003 highly relevant. The validation is not perfectly exhaustive but is comprehensive.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "Similar to spec_1, the code validates the user-provided `w_length` and `w_index` (which can be considered array indices for interfaces) against system constraints like `USB_COMP_EP0_BUFSIZ` and `MAX_CONFIG_INTERFACES`. This aligns well with HS-INPUT-001 (the second instance). The validation is present but may not cover all possible user-provided lengths/indices in all sub-functions.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      }
    ]
  },
  "CVE-2020-12674_after_exclude_100:80a6eba4:spec": {
    "timestamp": "2026-01-20T10:13:18.431051",
    "cve_id": "CVE-2020-12674",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "80a6eba4",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates a length field from a protocol message (len = *p++) against the buffer boundaries (p + len > end). This directly addresses HS-INPUT-001's requirement to validate protocol message length fields. However, it does not explicitly check against platform-specific integer limits (e.g., overflow when adding p + len, or len exceeding a maximum allocation size), which prevents a perfect score.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs a memory allocation based on a user-controlled length (p_malloc(pool, len)). While it validates that `len` is not zero and that `p + len` does not exceed the input buffer `end`, it does not validate `len` against any explicit allocation limit (e.g., a maximum allowed size for the pool). This is a direct application of HS-MEM-002, but the validation is incomplete for allocation limits.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The specification is about consistent type handling across processing stages. The code reads a single-byte length field (unsigned int len = *p++), which is a specific type choice, but the specification is broad and not directly focused on the core security activities in this function (boundary checking and allocation). Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "HS-MEM-001 requires memory to be initialized before use. This function uses memcpy to copy data into the newly allocated buffer, which initializes it with the source data. This is proper initialization, so the specification is not addressing a security issue in this code. It is applicable but not relevant for finding flaws here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has multiple error return paths (return 0). On error, it returns 0 but does not modify *buffer (which remains uninitialized from the caller's perspective) or *data. This could be considered consistent error state handling. However, the specification is broader, often concerning object state in more complex scenarios. Moderate relevance.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This function is a network protocol handler (reading a length-prefixed buffer). It performs essential input validation (checking p > end, p + len > end, len == 0) before processing (allocating and copying). This is a direct and strong application of HS-IO-003.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "HS-INPUT-001 (duplicate number, appears to be a copy-paste error in the list) is about regular expression parsers and NUL bytes. This code does not involve regular expressions. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "HS-PROTOCOL-002 concerns pattern compilers and escape sequences. This code is a simple buffer reader for a length-prefixed field and does not involve pattern compilation or escape sequence processing. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2022-28389_before_exclude_100:9026c71a:spec": {
    "timestamp": "2026-01-20T10:13:20.853567",
    "cve_id": "CVE-2022-28389",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "9026c71a",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes a CAN frame where the `dlc` (Data Length Code) field is directly assigned from `cf->len`. While the CAN protocol defines a valid DLC range (0-8, or 0-64 for CAN FD), the code does not explicitly validate `cf->len` against these platform-specific integer limits before using it in `memcpy` and potentially in the USB message. This is moderately relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The code does not contain explicit memory allocation operations (like kmalloc). It retrieves a pre-allocated context via `mcba_usb_get_free_ctx`. The relevance to validating size parameters for allocation is very low.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 8,
        "reasoning": "The code handles two types of CAN identifiers (standard and extended) and constructs a different message format (`sid`, `eid` fields) for each. It must ensure consistent type handling (e.g., bitmask operations, byte order) across both branches. This is strongly relevant to protocol implementation.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 6,
        "reasoning": "The `skb->data` is cast to a `can_frame` and its `len` field (`cf->len`) is used without validation against system constraints (like max CAN frame length) before being copied. This is a userspace-provided length (via socket), making it moderately relevant, though the primary check `can_dropped_invalid_skb` may perform some validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 7,
        "reasoning": "The code processes the variable-length data component of the CAN frame (`cf->data` of length `cf->len`). It should verify the structural integrity (e.g., that `cf->len` is valid for the declared frame type) before the `memcpy`. This is moderately relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 3,
        "reasoning": "The code does not perform buffer allocation based on input. The `usb_msg.data` buffer is likely fixed-size (8 bytes for classic CAN). The copy uses `usb_msg.dlc` which comes from `cf->len`. While buffer overflow is a risk if `dlc` is too large, this is more of an input validation issue (covered by spec 1/4/5). Direct relevance to allocation logic is very low.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The function retrieves a free context (`mcba_usb_get_free_ctx`) which likely manages a shared pool of contexts. The state transition (free -> used) for this shared resource should be protected atomically. The relevance is weak to moderate, as the atomicity depends on the implementation of `mcba_usb_get_free_ctx`.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 6,
        "reasoning": "The function uses a context (`ctx`) to track the transmitted message, links the SKB via `can_put_echo_skb`, and must ensure cleanup (`can_free_echo_skb`, `mcba_usb_free_ctx`) on failure. Consistency between the context state, the echo SKB, and the network device stats is important. This is moderately relevant.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2022-28389_after_exclude_100:124ed1c9:spec": {
    "timestamp": "2026-01-20T10:13:25.786442",
    "cve_id": "CVE-2022-28389",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "124ed1c9",
    "scores": [
      {
        "score": 7,
        "reasoning": "The code processes a CAN frame where `cf->len` (DLC) is used directly as `usb_msg.dlc`. While there is a check `can_dropped_invalid_skb` that may validate the skb, the specification about validating protocol message length fields against integer limits is moderately relevant. The DLC field is later used in `memcpy(usb_msg.data, cf->data, usb_msg.dlc)`, so ensuring it doesn't exceed the buffer size of `usb_msg.data` (typically 8 for CAN) is important. The relevance is not direct to \"platform-specific integer limits\" but to buffer bounds.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation; it retrieves a context via `mcba_usb_get_free_ctx`. However, this function likely manages a pool of contexts. The specification about validating size parameters for allocation is only loosely related because the primary concern here is managing a fixed pool of contexts, not dynamic allocation with size parameters.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles CAN frames with standard (11-bit) and extended (29-bit) identifiers, converting them into a specific USB message format. It must ensure consistent interpretation of the CAN ID bits, flags (EFF, RTR), and DLC across the conversion. The bit manipulation and masking must be correct to avoid misinterpretation. This is directly relevant to protocol type handling consistency.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 6,
        "reasoning": "The `skb->data` comes from userspace (via socket). The code casts it to `struct can_frame *` and uses `cf->len` and `cf->data`. While `can_dropped_invalid_skb` may perform some validation, the specification about validating userspace-provided array lengths against system constraints is moderately relevant. The `cf->len` is used as a copy length, so it must be validated against the actual data size and the maximum CAN data length (8).",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The code processes a variable-length component: the CAN data field length (`cf->len`). It must verify that the length is valid (0-8) and matches the actual data available in the skb before the `memcpy`. The `can_dropped_invalid_skb` likely does this, but explicit validation of structural integrity is relevant. The relevance is strong but not perfect because the check is delegated.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "The code uses a fixed-size buffer `usb_msg.data` (implied by CAN protocol, max 8 bytes). It does not dynamically allocate buffers based on input. The specification about buffer allocation for worst-case scenarios is only loosely related, as the buffer is statically sized within the struct. However, ensuring the input length does not overflow this fixed buffer is covered by length validation.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "The code accesses shared resources: the context pool via `mcba_usb_get_free_ctx` and the echo skb queue via `can_put_echo_skb`. However, the specification about atomic check-and-update for state transitions is weakly relevant. The function likely runs in a non-reentrant context (netdev xmit), but concurrent access to the context pool might need protection. The code does not show explicit atomic operations.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Shared resource state transitions must be protected by atomic check-and-update operat..."
      },
      {
        "score": 5,
        "reasoning": "The code manages resource allocation state: it obtains a free context (`ctx`) and associates it with an skb (echo skb). If transmission fails, it frees the echo skb and the context. Consistency between the context's state (ndx), the echo skb queue, and the network device stats is crucial. A leak or inconsistency could occur if error handling is flawed. This is highly relevant to maintaining consistency between tracking structures.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Resource allocation state must maintain strict consistency between different tracking ..."
      }
    ]
  },
  "CVE-2018-14881_before_exclude_100:ae622302:spec": {
    "timestamp": "2026-01-20T10:19:40.618023",
    "cve_id": "CVE-2018-14881",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ae622302",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the capability length field (hdr->length) before using it to calculate memory offsets and copy data (memcpy). This directly aligns with the specification's requirement to validate field lengths before accessing corresponding data.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 5,
        "reasoning": "The code performs validation for the MP capability type (CAPABILITY_CODE_MP), checking action values and converting AFI/SAFI. However, for unrecognized capabilities, it only logs a warning and continues, rather than enforcing strict validation or rejection as the specification implies.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains strict bounds checking throughout parsing: it validates pnt + 3 > end before reading the header, and validates pnt + hdr->length + 3 > end before processing the capability data, ensuring operations stay within packet boundaries.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 5,
        "reasoning": "While the code validates length fields against the remaining packet buffer, it doesn't explicitly enforce RFC-specified minimum/maximum length constraints for individual capability types beyond basic buffer bounds.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The code implements complete bounds checking for the TLV-like capability structure: validates the capability header fits, validates the capability data length fits, and only then accesses the capability data through memcpy.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "Directly relevant as the code validates hdr->length before using it in pointer arithmetic (pnt + hdr->length + 3) and before copying capability data with memcpy, preventing buffer overflows.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 5,
        "reasoning": "The code validates message boundaries by checking pnt < end for the loop and validating each capability's length against the remaining buffer. However, it doesn't verify that all bytes are consumed or that there's no trailing garbage.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains separation by validating data before use, but the memcpy directly copies unvalidated network data into a local structure (mpc). While length was checked, the content of mpc (like afi/safi) is only validated after the copy.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2016-7532_after_exclude_100:d22eea59:spec": {
    "timestamp": "2026-01-20T10:20:40.203499",
    "cve_id": "CVE-2016-7532",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d22eea59",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code is a CIN/DPX image format parser. It validates critical header fields such as the magic number (\"\\200\\052\\137\\327\"), checks that `cin.file.image_offset` is not too small (>= 712), and validates structural relationships (e.g., checking offset against file size). This directly aligns with HS-INPUT-001's requirement to validate all critical header fields before processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs some size validation before memory allocation, such as checking `cin.file.user_length > GetBlobSize(image)` before creating a StringInfo profile. However, it does not extensively pre-validate all size parameters (e.g., image->columns * image->rows) before internal buffer allocations like `GetQuantumPixels`. The principle applies but is not fully demonstrated.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 1,
        "reasoning": "Very low relevance. The specification specifically targets BMP parser bit count requirements. The target code is for CIN/DPX format, not BMP. The general concept of validating format-specific fields does not directly apply here.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. This is a direct extension of HS-INPUT-001. The code validates structural relationships: it checks `cin.file.image_offset` against file size, ensures `offset` matches the expected image offset, and verifies that `(image->columns * image->rows / 8)` does not exceed the blob size. These are critical structural validations.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses loops with fixed bounds (e.g., `for (i=0; i < 8; i++)` for channels) which are safe. However, it does not explicitly validate array indexes against allocated sizes for dynamically sized data. The principle of bounds checking is present but not a central focus in this code snippet.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code implements error handling with resource cleanup: it uses `ThrowReaderException` for errors, destroys images (`DestroyImageList`), frees quantum info (`DestroyQuantumInfo`), and closes blobs. However, not all error paths (e.g., early breaks in the pixel reading loop) may guarantee full cleanup, slightly reducing the score.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code initializes the `cin` struct with `memset(&cin,0,sizeof(cin));` before use. It also initializes `property` buffers via `CopyMagickString`. However, not all buffers (e.g., `pixels` from `GetQuantumPixels`) are necessarily fully initialized before use, though they are populated by `ReadBlobStream`.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code generally maintains consistent states: on error, it throws exceptions which likely unwind to cleanup. However, in the pixel reading loop, a break due to `count != length` does not explicitly set an error state or ensure the image object is in a consistent state for further operations. The principle is followed but not perfectly.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      }
    ]
  },
  "CVE-2020-21050_before_exclude_100:2895e83c:spec": {
    "timestamp": "2026-01-20T11:22:40.229393",
    "cve_id": "CVE-2020-21050",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2895e83c",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs PNG image decoding, not cryptographic operations on secret values. There is no cryptographic processing involved.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is for PNG image processing, not elliptic curve cryptography. No cryptographic curve models are involved.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs image decoding operations, not cryptographic processing that requires constant-time memory operations. No secret data is being processed.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does perform buffer allocation for image data and includes bounds checking for width/height dimensions, but it doesn't specifically address cryptographic padding requirements or safety margins for operational padding.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code performs PNG image decompression/decoding and includes multiple bounds checks: verifying width/height don't overflow int, checking dimensions aren't too large, and validating total size limits. This directly addresses buffer bounds security for image compression operations.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 1,
        "reasoning": "The code processes PNG image data, not cryptographic signatures or ASN.1 structures. No cryptographic verification is performed.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Cryptographic signature verification must validate all ASN.1 structure lengths against..."
      },
      {
        "score": 1,
        "reasoning": "The code is for PNG image decoding, not PKCS#1 v1.5 verification or any RSA padding validation. No cryptographic padding is involved.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: PKCS#1 v1.5 verification must enforce minimum padding requirements regardless of publ..."
      },
      {
        "score": 5,
        "reasoning": "The code processes PNG image format, not X.509 certificates or any certificate parsing. No structural metadata validation for certificates is performed.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: X.509 parsers must validate all structural metadata before processing certificate c..."
      }
    ]
  },
  "CVE-2020-21050_after_exclude_100:ada0b9d9:spec": {
    "timestamp": "2026-01-20T11:22:42.880182",
    "cve_id": "CVE-2020-21050",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ada0b9d9",
    "scores": [
      {
        "score": 1,
        "reasoning": "The code performs PNG image decoding, not cryptographic operations on secret values. There is no cryptographic processing involved.",
        "spec_index": 0,
        "spec_preview": "HS-TIMING-001: Cryptographic operations on secret values must execute in constant time"
      },
      {
        "score": 1,
        "reasoning": "The code is for PNG image processing, not elliptic curve cryptography. No cryptographic curves or side-channel resistance considerations are present.",
        "spec_index": 1,
        "spec_preview": "HS-CRYPTO-002: Elliptic curve implementations must provide side-channel resistance for all curve mod..."
      },
      {
        "score": 1,
        "reasoning": "The code performs image decoding operations, not cryptographic processing that requires constant-time memory operations. No secret data is being handled.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Secure memory operations must maintain constant-time properties during cryptographic pro..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code does perform buffer allocation for image data and includes bounds checking for width/height dimensions to prevent overflow, which aligns with the general principle of safe memory allocation. However, it doesn't deal with cryptographic padding requirements specifically.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code performs PNG image decompression with multiple bounds checks: verifying width/height don't overflow int, checking single dimension limits, and validating total size limits. This directly addresses buffer safety for image compression operations.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 1,
        "reasoning": "The code processes PNG images, not cryptographic signatures or ASN.1 structures. No signature verification is performed.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Cryptographic signature verification must validate all ASN.1 structure lengths against..."
      },
      {
        "score": 5,
        "reasoning": "The code is for PNG image decoding, not PKCS#1 v1.5 verification or RSA cryptography. No padding requirements are involved.",
        "spec_index": 6,
        "spec_preview": "HS-CRYPTO-002: PKCS#1 v1.5 verification must enforce minimum padding requirements regardless of publ..."
      },
      {
        "score": 5,
        "reasoning": "The code processes PNG image data, not X.509 certificates or protocol parsing. No certificate validation is performed.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: X.509 parsers must validate all structural metadata before processing certificate c..."
      }
    ]
  },
  "CVE-2014-0196_after_exclude_100:f346a2fc:spec": {
    "timestamp": "2026-01-20T11:23:00.987072",
    "cve_id": "CVE-2014-0196",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f346a2fc",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a kernel module close function handling internal cleanup, not processing userspace-provided array lengths. No input validation against system constraints is performed here.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The function handles device shutdown and resource cleanup, not protocol message processing. No variable-length protocol components are being parsed or validated.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "No cryptographic operations are present in this code. The function deals with network device cleanup, not cryptography.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 1,
        "reasoning": "No cryptographic operations or memory-safe interfaces for crypto data handling are involved in this network device cleanup routine.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While the code doesn't explicitly handle VMAP_STACK, kernel cleanup functions should be aware of stack usage patterns, but this is not a primary concern here.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code uses locking (disc_data_lock) to protect the tty->disc_data pointer during concurrent access, ensuring atomic updates when setting it to NULL.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. The function manages shared state transitions (tty->disc_data, ax->refcnt) with proper locking and reference counting, maintaining consistency invariants across access paths during cleanup.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2014-0196_before_exclude_100:d9ef4fdf:spec": {
    "timestamp": "2026-01-20T11:23:08.018367",
    "cve_id": "CVE-2014-0196",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d9ef4fdf",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is a kernel module close/cleanup function. It does not process userspace-provided array lengths. The function deals with internal resource cleanup after a TTY is closed, not with input validation during data processing.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The function is a cleanup routine, not a protocol message handler. It frees internal buffers (rbuff, xbuff) but does not parse or validate the structure of any incoming protocol messages.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code performs network device and buffer cleanup. It contains no cryptographic operations and does not use scatterlists or reference stack memory in a cryptographic context.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Cryptographic operations must never directly reference stack memory through scatterlists"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code has no cryptographic implementations. It uses standard kernel memory deallocation functions (kfree, free_netdev) which are memory-safe for their intended purpose, but not in a cryptographic context.",
        "spec_index": 4,
        "spec_preview": "HS-CRYPTO-002: Cryptographic implementations must use approved memory-safe interfaces for data handl..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The function uses kernel stack memory for local pointers (e.g., `struct mkiss *ax`). While it doesn't explicitly handle VMAP_STACK, proper cleanup of kernel data structures (like ensuring no dangling pointers in `tty->disc_data`) is a general principle that interacts with kernel memory layouts. The direct implications are minimal here.",
        "spec_index": 5,
        "spec_preview": "HS-CONF-003: Kernel components must properly handle VMAP_STACK configuration implications"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The function manages concurrent access to shared state (`tty->disc_data`) using a lock (`disc_data_lock`). It performs a critical check-and-set operation under this lock: reading `ax = tty->disc_data` and setting `tty->disc_data = NULL`. This atomic operation under lock prevents race conditions during close.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 5,
        "reasoning": "Highly relevant. This is a core function of the code. It manages the shared state transition of a `struct mkiss` object from \"in use\" to \"closed and freed.\" It uses a refcount (`ax->refcnt`) and a completion (`ax->dead`) to ensure all existing users finish before cleanup proceeds. It maintains consistency by nullifying `ax->tty` and `tty->disc_data`, stopping the network queue, and unregistering/freeing resources in a specific order.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2016-8670_before_exclude_100:3557e3bf:spec": {
    "timestamp": "2026-01-20T11:23:43.896489",
    "cve_id": "CVE-2016-8670",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3557e3bf",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory for `res->ContribRow` and for each `Weights` array but does not initialize the contents of these allocations before returning. This leaves uninitialized memory that could later be used, potentially leading to information disclosure or undefined behavior. Specification HS-MEM-001 directly addresses this risk.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The code has multiple error handling paths (e.g., allocation failures, overflow detection). In the nested allocation failure path, it correctly frees previously allocated `Weights` arrays and the main structure, maintaining a consistent state (no memory leaks). This is a strong example of the principle in HS-STATE-002.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code is a utility memory allocation function for image processing. It does not handle network protocols or process network input in any way. The specification is not relevant.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation and arithmetic checks. It does not parse or process regular expressions or handle input patterns containing NUL bytes. The specification is not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code does not compile patterns, process escape sequences, or deal with textual pattern input. It is a low-level memory allocator for a data structure. The specification is not relevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "The code does not process strings. It handles numeric parameters for allocation sizes. While the principle of bounds awareness is broadly important, the specific guidance on string operations has very low relevance to this code.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "The code validates size parameters for overflow but does not process protocol messages or their length fields. The parameters `line_length` and `windows_size` are function arguments, not from a network protocol. The specification is not relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant. The code explicitly uses `overflow2` to validate the multiplication of `line_length` and `sizeof(ContributionType)` before allocation, and also checks `windows_size * sizeof(double)` in the loop. This directly implements the specification's requirement to validate size parameters against allocation limits and subsequent usage (addressing integer overflow).",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2017-14151_after_exclude_100:8302d9cf:spec": {
    "timestamp": "2026-01-20T11:25:35.764289",
    "cve_id": "CVE-2017-14151",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "8302d9cf",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs multiple memory allocations (jas_malloc, jas_alloc2) and initializes the allocated structures (cp, cp->ccps) with values. However, there is a potential issue: the loop initializing ccp->sampgrdsubstepx is incorrectly duplicated (set twice), leaving ccp->sampgrdsubstepy uninitialized. This violates the \"fully initialized before use\" principle.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The function has extensive error handling using goto error. It consistently frees allocated resources (ilyrrates, tvp, cp) in the error path, maintaining consistent object states and preventing resource leaks. This is a strong example of proper error handling.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "The code does not handle network protocols. It processes an option string (optstr) for image encoding configuration, which is local input, not network input.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 3,
        "reasoning": "While the code performs buffer allocations (e.g., for cp->ccps), there's no evident consideration for operational padding or safety margins. The allocations are based directly on calculated sizes (numcmpts * sizeof(jpc_enc_ccp_t)). The relevance is weak.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 9,
        "reasoning": "The code is an image compression (JPEG2000 encoder) function. It performs multiple bounds checks: validating tile dimensions, tile grid offsets, precinct dimensions, code block sizes, number of layers, resolution levels, guard bits, and intermediate layer rates. This aligns directly with the specification.",
        "spec_index": 4,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      },
      {
        "score": 1,
        "reasoning": "The code does not process protocol message length fields. It parses an option string for encoder settings, not network packets.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code validates size parameters before use. For example, it checks cp->rawsize != 0 to prevent division by zero, validates tccp->maxrlvls against JPC_MAXRLVLS, and checks that allocations succeed. However, it doesn't explicitly validate against allocation limits (e.g., maximum heap size).",
        "spec_index": 6,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "The code does not implement a network protocol. It handles internal encoder configuration structures and image data. Type handling is consistent (using jas_image_* functions), but this is not related to protocol processing.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      }
    ]
  },
  "CVE-2018-1000879_before_exclude_100:3cbe0dc4:spec": {
    "timestamp": "2026-01-20T11:25:44.820354",
    "cve_id": "CVE-2018-1000879",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "3cbe0dc4",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is an image decoder (MNG format) that reads and processes chunks from a file. It does not perform filesystem operations that would involve inode state management across layers. The code works with blob data in memory, not with filesystem inodes.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Filesystem operations must maintain consistent inode state across all layers"
      },
      {
        "score": 1,
        "reasoning": "The code does not perform any POSIX rename operations or handle hardlinks. It is purely an image parsing and decoding routine that reads data from a blob (file stream) and creates image structures in memory.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: POSIX rename operations must properly handle all special cases including self-hardl..."
      },
      {
        "score": 1,
        "reasoning": "The code does not implement filesystem drivers or interact with VFS layer. It operates at the application level, reading image data through the ImageMagick blob abstraction.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem drivers must expose consistent inode identity to VFS layer"
      },
      {
        "score": 5,
        "reasoning": "While the code does perform some validation of chunk data (checking lengths, magic numbers), it does not deal with database constraints or generated columns. The validation is specific to image format parsing, not database integrity.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Integrity verification must validate all constraints including NOT NULL on generated c..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains some internal state consistency (MngInfo structure, image lists) but this is not database consistency checking. The invariants are related to image format parsing rather than database column types.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Database consistency checks must maintain invariant validation across all column types"
      },
      {
        "score": 5,
        "reasoning": "The code performs object copying operations during image magnification processing (copying pixel data between images) and maintains image list pointers. There is some relevance to maintaining pointer validity during reinitialization when creating new image structures and managing the image linked list.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Object copy operations must maintain atomic pointer validity during reinitialization"
      },
      {
        "score": 5,
        "reasoning": "The code uses file descriptor operations through ReadBlob, SeekBlob, and TellBlob functions, but doesn't appear to enforce strict state transition ordering. It does handle some error cases but not with the rigor specified for filesystem driver-level operations.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File descriptor operations must enforce strict state transition ordering"
      },
      {
        "score": 5,
        "reasoning": "During the magnification processing, the code copies pixel data between image buffers and creates intermediate image structures. There is some need to maintain consistent states during these operations, though not at the level of atomic guarantees specified.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-003: Object copying must guarantee consistent intermediate states"
      }
    ]
  },
  "CVE-2018-1000879_after_exclude_100:25ce6ac9:spec": {
    "timestamp": "2026-01-20T11:25:48.594536",
    "cve_id": "CVE-2018-1000879",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "25ce6ac9",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is an image decoder (MNG format reader) and does not perform filesystem operations or manage inode states. It reads image data from a blob/stream, processes chunks, and creates image structures in memory. No filesystem layer or inode consistency is involved.",
        "spec_index": 0,
        "spec_preview": "HS-STATE-001: Filesystem operations must maintain consistent inode state across all layers"
      },
      {
        "score": 1,
        "reasoning": "The code does not perform any POSIX rename operations, file moving, or handle hardlinks. It is purely an image parsing and decoding routine operating on a binary data stream.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: POSIX rename operations must properly handle all special cases including self-hardl..."
      },
      {
        "score": 1,
        "reasoning": "No filesystem driver or VFS layer interaction is present. The code works with an abstract blob interface (ReadBlob, SeekBlob) for reading image data, not with filesystem inodes.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Filesystem drivers must expose consistent inode identity to VFS layer"
      },
      {
        "score": 5,
        "reasoning": "While the code does perform some integrity checks (e.g., verifying chunk lengths, magic numbers), it does not involve database constraints, generated columns, or SQL-level validation. The checks are specific to image format parsing.",
        "spec_index": 3,
        "spec_preview": "HS-LOGIC-001: Integrity verification must validate all constraints including NOT NULL on generated c..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains internal state consistency for MNG decoding (e.g., object existence, framing mode) but does not involve database consistency checks, column types, or relational invariants.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Database consistency checks must maintain invariant validation across all column types"
      },
      {
        "score": 5,
        "reasoning": "The code performs object copying and reinitialization in several places (e.g., image magnification, layer insertion) and manages memory allocation/release. While not about atomic pointer validity in a concurrent sense, it does ensure pointer validity during reallocation and copying operations (e.g., using AcquireQuantumMemory, RelinquishMagickMemory).",
        "spec_index": 5,
        "spec_preview": "HS-MEM-001: Object copy operations must maintain atomic pointer validity during reinitialization"
      },
      {
        "score": 5,
        "reasoning": "The code uses file descriptor-like operations via the blob abstraction (ReadBlob, SeekBlob) and maintains some state transitions (e.g., skip_to_iend, loop handling). However, it does not enforce strict ordering or state transitions typical of OS-level file descriptor management.",
        "spec_index": 6,
        "spec_preview": "HS-IO-002: File descriptor operations must enforce strict state transition ordering"
      },
      {
        "score": 5,
        "reasoning": "The code copies and transforms image data (e.g., during magnification) and ensures intermediate states are consistent (e.g., allocating temporary buffers, synchronizing pixels). It guarantees consistency during object copying but not in a generic object-copying framework.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-003: Object copying must guarantee consistent intermediate states"
      }
    ]
  },
  "CVE-2016-7532_after_exclude_100:b4b2d7c6:spec": {
    "timestamp": "2026-01-20T11:26:34.411281",
    "cve_id": "CVE-2016-7532",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "b4b2d7c6",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses local arrays like `command[MagickPathExtent]` and `filename[MagickPathExtent]` which are initialized via `memset` or string functions. However, there is a loop that writes to `command` array character-by-character with potential overflow check `(size_t) (p-command) < (MagickPathExtent-1)`, but the check is incomplete as it doesn't prevent writing the null terminator beyond bounds if the buffer fills exactly. The initialization principle is relevant but implementation has subtle flaws.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function has multiple error handling paths (e.g., failed `AcquireUniqueSymbolicLink`, `delegate_info == NULL`, `image == NULL` after `ReadImage`). Most paths clean up resources (destroying images, freeing strings, relinquishing unique files), but there is a potential issue: if `ExternalDelegateCommand` fails, `options` and `density` strings are already destroyed before the command call, which is fine, but if `ReadImage` fails after successful delegate command, cleanup of `read_info->filename` and `input_filename` still occurs. Overall, error paths attempt consistent state cleanup, though some early returns could be scrutinized.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This code reads a PCL image file from local storage via `OpenBlob`, not network protocol handling. No network input validation is present. Specification is about network protocols, which does not apply here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code parses PCL file format, extracting CropBox and MediaBox via sscanf. It validates structural relationships indirectly by checking `count == 4` after parsing. However, it does not validate relationships between multiple boxes (e.g., CropBox within MediaBox) or other header fields thoroughly. Some relevance as a file format parser, but not comprehensive header relationship validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 8,
        "reasoning": "The loop writing to `command` array includes a bounds check `((size_t) (p-command) < (MagickPathExtent-1))` before continuing, but the check is only performed when `c` is not '/' or '\\n'. When `c` is '/' or '\\n', the character is written without that check, potentially allowing overflow if the buffer is already full. Also, `*p++=(char) c;` occurs before check, so indexing may exceed bounds. Array indexing operations are present and validation is attempted but flawed.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      },
      {
        "score": 5,
        "reasoning": "This is a file format processor (PCL image reader). It implements error handling with cleanup for many failure scenarios: blob open failure, unique link failure, delegate info failure, delegate command failure, image read failure. Resources like images, strings, and temporary files are cleaned up in error paths. However, there might be edge cases (e.g., early returns before all allocations). Strong relevance.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: File format processors must implement complete error handling with resource cleanup"
      },
      {
        "score": 5,
        "reasoning": "The code reads PCL headers to determine page geometry and CMYK colorspace. It validates critical fields like CropBox and MediaBox by parsing numeric values and checking count. However, it does not validate that width/height derived from bounds are reasonable (e.g., positive, not overflowing size_t). Some validation is present but not exhaustive for all critical header fields before further processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code does not perform explicit memory allocation via malloc/calloc in this snippet; it uses stack arrays and AcquireString for density/options. For stack arrays, size is fixed at compile time. The `AcquireString` allocates based on string length but not directly from user input. There is no pre-validation of size parameters for allocations here. Weak relevance because memory allocation is minimal and not obviously vulnerable.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2011-3603_before_exclude_100:905b4d53:spec": {
    "timestamp": "2026-01-20T11:27:07.619449",
    "cve_id": "CVE-2011-3603",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "905b4d53",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The code performs privilege separation (dropping privileges via setuid/setgid). Specification HS-SEC-001 mandates immediate termination on failure. The code partially follows this by exiting only when EXIT_ON_SETUID_FAILURE is defined and the error is EAGAIN. This is a strong but not perfect match to the specification's requirement.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. The code performs a security-critical state transition (changing effective UID/GID). Specification HS-STATE-002 requires atomic verification. The code verifies the success of setuid and setgid calls individually and updates the internal state (current_user.euid/egid) only after successful system calls. However, it's not fully atomic if setuid succeeds but setgid fails, leaving the process in an inconsistent state (UID dropped, GID not dropped).",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 2,
        "reasoning": "Very low relevance. The code is a function for dropping privileges, not a daemon startup routine. There is no validation of runtime configuration (like config files or environment variables) shown in this snippet. The specification targets a different phase of program execution.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not contain any regular expression parsing or processing. It deals with system calls for privilege management and error reporting.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not contain any pattern compilation or processing of escape sequences. It is focused on privilege management system calls.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not perform string processing on untrusted input. It uses sys_error for logging, but the format string is a literal, and the arguments are integers.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not handle network-derived data or length values. It operates on internal user credential structures and system call return values.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. The code does not parse any network protocol messages or variable-length fields. It is a local privilege management function.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2011-3603_after_exclude_100:eb7952c7:spec": {
    "timestamp": "2026-01-20T11:27:10.685817",
    "cve_id": "CVE-2011-3603",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "eb7952c7",
    "scores": [
      {
        "score": 9,
        "reasoning": "This specification is highly relevant. The code performs privilege separation (dropping privileges to a non-privileged user). The specification mandates immediate termination on failure. The code partially follows this by calling `exit(e)` only when `EXIT_ON_SETUID_FAILURE` is defined and the error is `EAGAIN`. This is a conditional and incomplete enforcement, making it strongly relevant but not a perfect match.",
        "spec_index": 0,
        "spec_preview": "HS-SEC-001: Privilege separation failures must enforce immediate process termination"
      },
      {
        "score": 7,
        "reasoning": "The code performs a security-critical state transition (changing UID/GID). The specification calls for atomic verification. The code does verify the success of the `setresuid`/`setuid` and `setresgid`/`setgid` calls and updates the internal state (`current_user.euid`, `current_user.egid`) only after the system calls succeed. This is a form of verification and state update, though not necessarily \"atomic\" in the strictest sense (e.g., checking all IDs at once). It has moderate to strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Security-critical state transitions require atomic verification"
      },
      {
        "score": 2,
        "reasoning": "The code is a utility function for dropping privileges, not a daemon initialization routine. There is no validation of runtime configuration (like config files or command-line arguments) happening in this snippet. The relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-CONF-003: Security-sensitive daemons must validate runtime configuration before operation"
      },
      {
        "score": 5,
        "reasoning": "The code deals with process privileges and user IDs. It contains no regular expression parsing or string pattern handling. The specification is about a completely different vulnerability class (regex, NUL bytes) and does not apply.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 1,
        "reasoning": "The code deals with process privileges and user IDs. It contains no pattern compilation, escape sequence processing, or string manipulation related to protocols. The specification is about a completely different vulnerability class and does not apply.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 1,
        "reasoning": "The code performs system calls and error logging. It does not process strings from untrusted input using functions like `strcpy`, `sprintf`, etc. The `sys_error` call uses a format string with integer arguments, which is safe. The specification about length-aware string operations is not relevant.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 1,
        "reasoning": "The code performs privilege management operations. It does not handle network input, parse network-derived data, or validate any length values from external sources. The specification is about network security and does not apply.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All network-derived length values must be validated for range and sign before use"
      },
      {
        "score": 1,
        "reasoning": "The code performs privilege management operations. It does not implement a network protocol, parse protocol messages, or handle variable-length fields. The specification is about protocol parsing and does not apply.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Protocol option parsers must validate all variable-length fields against remaining ..."
      }
    ]
  },
  "CVE-2019-1010065_before_exclude_100:ac6bfc52:spec": {
    "timestamp": "2026-01-20T11:27:57.942785",
    "cve_id": "CVE-2019-1010065",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "ac6bfc52",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs direct memory access via `kmap(page)` and pointer arithmetic on `__be32 *` pointers (e.g., `curr = pptr + ...`). While the kernel's `kmap` generally returns an aligned address, the pointer arithmetic and subsequent dereferencing (`val = *curr`) assume proper alignment for 32-bit accesses. The relevance is strong because the code manipulates raw memory pages and must respect alignment for correct and safe operation, though the kernel's page mapping mechanisms typically handle alignment.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory operations must respect platform alignment requirements"
      },
      {
        "score": 2,
        "reasoning": "This specification is about network protocol message validation. The target code is a filesystem bitmap allocation function with no network protocol handling. The relevance is very low.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol implementations must validate message structure before processing"
      },
      {
        "score": 7,
        "reasoning": "The code processes a bitmap from disk (via `read_mapping_page`), which could contain misaligned or corrupted data. It uses `be32_to_cpu()` on data read from the page, which assumes the data is in big-endian format. If the on-disk data is malformed, the bitwise operations (like `~val`, `n & mask`) could lead to unexpected behavior. The code has moderate relevance as it should safely handle misaligned or invalid bitmap data, though it lacks explicit validation checks.",
        "spec_index": 2,
        "spec_preview": "HS-INPUT-003: Input processing must handle misaligned data safely"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 1,
        "reasoning": "This specification is for network protocol handlers. The target code is a filesystem block allocator with no network interaction. The relevance is extremely low.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 6,
        "spec_preview": "HS-LOGIC-001: Arithmetic operations must validate against type boundaries before calculation"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-002: Filesystem parsers must validate all structural fields against physical constraints"
      }
    ]
  },
  "CVE-2016-1838_before_exclude_100:a999a87b:spec": {
    "timestamp": "2026-01-20T11:29:38.918166",
    "cve_id": "CVE-2016-1838",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "a999a87b",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code is an XML parser, not a regular expression parser. While it does parse input patterns (XML tags and content), it does not use regular expressions. The handling of NUL bytes is not directly addressed, but the parser uses length-aware scanning functions (like pj_scan_get_until_ch), which may offer some protection. Relevance is weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 4,
        "reasoning": "The code does not compile patterns or process escape sequences in the sense of a pattern compiler (like regex). It handles XML constructs like comments, CDATA, and quotes, but the specification's focus on \"escape sequences\" in pattern compilers is not directly applicable. Weak relevance.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The code extensively uses length-aware scanning operations (pj_scan_get_until_ch, pj_scan_get_until_chr) to process input, which is a core principle for safely handling untrusted input. These functions take a scanner object that tracks position and boundaries, reducing risks of buffer overflows.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 2,
        "reasoning": "The code does not process protocol message length fields. It parses XML tokens sequentially from a scanner without reading length fields from the input. Very low relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code calls alloc_node and alloc_attr, but their implementations are not shown. The specification about validating size parameters against allocation limits and usage requirements could apply if those allocators handle user-influenced sizes, but it's not visible in the provided code.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code enforces consistent type handling for XML nodes, attributes, and content (e.g., checking for '<', '>', '/', quotes). It validates syntax at various stages (like tag matching), which aligns with enforcing consistent processing. However, the specification is broad and includes type handling beyond syntax checks.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code processes character data (XML tags, attributes, content) and uses scanner functions that operate within buffer boundaries. It validates buffer state before accesses (e.g., checking scanner->curptr) and uses functions like pj_scan_get_until_ch to prevent overruns, directly applying the principle of validating boundaries before access.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Character encoding processing must validate buffer boundaries before access"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code is a parser that maintains buffer state through a scanner object, using functions like pj_scan_advance_n and pj_scan_get_char. It checks for EOF and syntax errors, which helps maintain consistent buffer state invariants during input operations.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Parser input operations must maintain consistent buffer state invariants"
      }
    ]
  },
  "CVE-2018-14461_before_exclude_100:0ec1dbb2:spec": {
    "timestamp": "2026-01-20T11:29:39.630159",
    "cve_id": "CVE-2018-14461",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0ec1dbb2",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code uses `cdf_grow_info` to allocate memory for property info. While the newly allocated memory block for `inp` is used, there is no explicit full initialization shown (e.g., via `memset`). However, the code does write to specific fields (`pi_id`, `pi_type`, `pi_str`, `pi_val`) in the loop. The `unknown` case uses `memset` to zero `pi_val`. The relevance is strong because memory allocation initialization is a key concern, though the code partially addresses it through field-by-field assignment.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "The error handling path labeled `out` ensures consistent state by freeing `*info`, setting it to NULL, and resetting `*count` and `*maxcount` to 0. This prevents dangling pointers and inconsistent counts on error. This is a direct and correct application of the specification.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code parses a file format (CDF/Compound Document Format), not a network protocol. While input validation is performed (e.g., checking offsets and lengths), the specification is specifically for network protocol handlers, making the connection weak.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code directly validates length fields against limits. It checks `offs > UINT32_MAX / 4` to prevent overflow, validates `sh.sh_len > CDF_SHLEN_LIMIT`, and uses `cdf_check_stream_offset` to ensure lengths and offsets are within bounds. This is a core part of the function's logic and highly relevant.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code calls `cdf_grow_info` (not shown in full) which likely handles allocation growth. The function validates `sh.sh_properties` against `CDF_PROP_LIMIT` before attempting to grow the info array. This is a validation against an allocation limit. Subsequent usage checks (e.g., `left < sizeof(uint32_t)`) also validate against usage requirements. Strong relevance.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code enforces consistent type handling through a switch statement on `pi_type & CDF_TYPEMASK`. It rejects invalid types (`CDF_ARRAY|CDF_BYREF|CDF_RESERVED`) and has specific handling for each data type (e.g., CDF_SIGNED16, CDF_LENGTH32_STRING). This is a direct implementation of consistent type handling across processing stages.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling embedded NUL bytes. This code does not parse regular expressions; it parses structured property information from a CDF stream. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. This code is a file format parser, not a pattern compiler. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2017-14151_before_exclude_100:5a14ec73:spec": {
    "timestamp": "2026-01-20T11:29:42.994774",
    "cve_id": "CVE-2017-14151",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "5a14ec73",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via `g_malloc` for `frame_data` and `delta_data` but does not explicitly initialize these buffers before they are used (e.g., in `memcpy` and `flx_decode_chunks`). While the decode function may write to them, uninitialized memory could lead to information leaks or instability if the decode logic has flaws. The specification about initializing memory before use is highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The code has error handling paths (e.g., `wrong_type` label, `need_more_data` label, and error returns). However, the `wrong_type` error path calls `gst_object_unref(flxdec)` which may violate object state consistency if `flxdec` is already being managed elsewhere. Also, after `GST_ELEMENT_ERROR` in the decode failure case, it returns `GST_FLOW_ERROR` without cleaning up adapter state. This shows moderate relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 6,
        "reasoning": "While this is not a network protocol handler, it processes a file/stream format (FLX/FLI/FLC). The code validates the header type magic numbers and checks chunk sizes before processing, which aligns with the principle of validating input before processing. However, the specification is framed for network protocols, so relevance is moderate.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 7,
        "reasoning": "The code reads size fields from the stream (`flxfh.size`, `flxh->width`, `flxh->height`) and uses them in calculations (`flxdec->size = width * height`) and memory operations. It checks `avail < flxfh.size` but does not validate integer overflow in `width * height` or against platform maximum allocation size. This is relevant to message length validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 9,
        "reasoning": "The code calculates `flxdec->size = width * height` and allocates `frame_data` and `delta_data` of that size, and later allocates a buffer of `flxdec->size * 4`. No validation checks for integer overflow in the multiplication or whether the size exceeds reasonable allocation limits. This is a direct memory allocation size validation issue, making the specification highly relevant.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code handles different FLX file types (FLI, FLC, FLX) and chunk types (`FLX_FRAME_TYPE` vs others). It applies endianness fixes and processes accordingly. However, there is no strict enforcement that type values are within expected ranges beyond the magic number check. The specification about consistent type handling across stages is strongly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code allocates buffers based on calculated size (`width * height` and `*4`) but does not appear to add any safety margin or account for padding. This could lead to buffer overflows if calculations are off-by-one or if decode writes exceed allocation. However, the specification emphasizes \"operational padding requirements,\" which is less directly applicable hereweak relevance.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for all operational padding requirements with safety marg..."
      },
      {
        "score": 5,
        "reasoning": "The code performs image decompression/decoding in `flx_decode_chunks`. It uses allocated buffers but does not show explicit bounds checking within the decoder to ensure writes stay within `frame_data` bounds. The specification about image compression operations enforcing bounds checking is somewhat relevant, but this is decompression, not compression, and the check is not visible in the provided code.",
        "spec_index": 7,
        "spec_preview": "HS-IO-004: Image compression operations must enforce strict bounds checking for all encoder buffers"
      }
    ]
  },
  "CVE-2017-12982_before_exclude_100:2226e343:spec": {
    "timestamp": "2026-01-20T11:30:15.370771",
    "cve_id": "CVE-2017-12982",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "2226e343",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via g_malloc(size) but does not explicitly initialize the allocated buffer before use. The memory is later written to in a loop, but there is no guarantee of full initialization if the loop conditions fail or if there are gaps. This relates directly to HS-MEM-001's requirement for full initialization before use.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function uses a RETURN macro that frees 'bits' and returns on error, which helps maintain consistency. However, the function modifies output parameters (*width, *height, *data, etc.) only on success, leaving them unchanged on failure. This is a consistent state practice, though not perfect (e.g., early returns before all parameters are set).",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code reads from a FILE stream (likely a file), not a network protocol. HS-IO-003 is specifically for network protocol handlers, so it has very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "While the code uses fgets with a fixed buffer MAX_SIZE and checks for overflow, and uses sscanf without specifying buffer limits for string reads, the main vulnerability is not about string formatting operations like printf/sprintf. The sscanf patterns use %s without width limits, which could overflow name_and_type if the line is malformed, but this is a parsing issue, not a formatting output issue. Weak relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "The sscanf uses %s without length specifier into a fixed buffer name_and_type, which does not strictly validate length against buffer capacity. This is a numeric/string format parsing issue, but the specification mentions \"numeric format templates\" and \"output buffer capacity\"  here it's string input, not numeric output. Moderate-weak relevance.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      },
      {
        "score": 5,
        "reasoning": "The code does not implement a formatting state machine with position tracking. It reads lines sequentially and parses them, but there's no complex state machine for formatting. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Formatting state machines must maintain consistent position tracking"
      },
      {
        "score": 5,
        "reasoning": "The function reads a bitmap file format (XBM-like). It validates critical header fields (width, height) before processing data: it checks `if (!ww || !hh) RETURN (FALSE);` after reading the bitmap data declaration. This aligns with HS-INPUT-001's requirement to validate header fields before processing.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Memory allocation `bits = g_malloc(size)` uses size calculated from ww and hh, which are read from the file. The code checks `if (!ww || !hh)` before allocation, but does not validate that size is reasonable (e.g., non-negative, not too large). This relates to guarding allocation with pre-validation of size parameters, though the validation is minimal.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2018-20750_after_exclude_100:142011d4:spec": {
    "timestamp": "2026-01-20T11:30:20.151886",
    "cve_id": "CVE-2018-20750",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "142011d4",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code allocates memory via `g_malloc(size)` but does not explicitly initialize the allocated buffer (`bits`) before reading data into it using pointer writes (`*ptr = value`). While the data is immediately overwritten in the subsequent loops, the specification about initializing memory before use is relevant. The score is not a 10 because the memory is not used uninitialized; it's populated in a controlled manner.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code uses a macro `RETURN(code)` that frees `bits` and returns. This ensures cleanup on error paths, maintaining a consistent state (no memory leak). However, other object states (like output parameters `width`, `height`, `data`) are not reset on error, which could leave callers with inconsistent/incomplete values. The principle applies moderately.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "No evaluation reason",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code uses `fgets(line, MAX_SIZE, fstream)` which bounds input to `MAX_SIZE`. It also checks if `strlen(line) == MAX_SIZE-1` to detect potential truncation/over-long lines. This relates to validating output buffer bounds for string input. However, the specification mentions \"string formatting operations\" (like `sprintf`), which are not present. The buffer validation principle has moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: String formatting operations must validate output buffer bounds before write operations"
      },
      {
        "score": 5,
        "reasoning": "The code uses `sscanf` with format strings like `\"#define %s %d\"`. The `%s` can overflow the `name_and_type` buffer (`char[MAX_SIZE]`) if the input token is longer than `MAX_SIZE-1`. There is no explicit length validation in the format template (e.g., `%<MAX_SIZE-1>s`). This is a potential issue, but the connection to \"Numeric format templates\" is weak (the spec seems focused on numeric formats). The broader input validation principle has some relevance.",
        "spec_index": 4,
        "spec_preview": "HS-INPUT-002: Numeric format templates require strict length validation against output buffer capaci..."
      },
      {
        "score": 5,
        "reasoning": "The specification is about \"Formatting state machines must maintain consistent position tracking\". The code does not implement a formatting state machine with position tracking; it sequentially reads lines and parses them. Relevance is very low.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: Formatting state machines must maintain consistent position tracking"
      },
      {
        "score": 5,
        "reasoning": "This is an image (bitmap) format parser. It validates critical header fields: it reads `width` and `height`, checks they are positive (`if (value <= 0)`), and ensures they are non-zero (`if (!ww || !hh)`) before processing data. It also validates size calculation for overflow. This directly aligns with the specification. Not a 10 because hotspot fields (`x_hot`, `y_hot`) are not validated (but they are optional).",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The code performs a size calculation (`bytes_per_line * hh`) and explicitly checks for integer overflow (`if (size / bytes_per_line != hh)`) before calling `g_malloc(size)`. This is a direct example of guarding memory allocation with pre-validation of size parameters. Highly relevant.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      }
    ]
  },
  "CVE-2017-16914_before_exclude_100:aeef0137:spec": {
    "timestamp": "2026-01-20T11:31:40.498554",
    "cve_id": "CVE-2017-16914",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "aeef0137",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a USB device disconnect handler, not a protocol message parser. It does not process any protocol messages with length fields, making this specification about integer limit validation for protocol messages irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The function performs cleanup (freeing URBs, unregistering hardware) but does not contain any memory allocation operations. It deallocates resources, so the specification about validating size parameters during allocation does not apply.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The function is a device lifecycle management routine, not a protocol implementation. It does not handle protocol data types or processing stages, making this specification irrelevant.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "This is a kernel disconnect callback, not a function processing userspace input. It does not receive or validate array lengths from userspace, so the specification does not apply.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 5,
        "reasoning": "The function handles USB device teardown, not protocol message parsing. It does not process variable-length protocol components, so this specification is irrelevant.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 5,
        "reasoning": "While the function deals with USB buffers (URBs), it is freeing them, not allocating them based on input. The specification focuses on allocation for worst-case input, which is not happening here.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 5,
        "reasoning": "This is highly relevant as the code is part of a USB device driver's disconnect path. While it doesn't explicitly validate endpoints here (that should occur during probe/initialization), proper USB driver design requires endpoint validation before use, and this cleanup function must handle resources allocated based on those endpoints. The specification's main principle directly applies to the driver context.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: USB device drivers must validate all required endpoints before operation"
      },
      {
        "score": 5,
        "reasoning": "Moderately relevant. The function is part of device driver lifecycle management. While configuration verification should happen during initialization (before this disconnect runs), improper configuration could lead to issues during cleanup. The specification's principle of verifying device state applies indirectly to ensuring safe teardown.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-002: Device configuration must be fully verified before driver initialization"
      }
    ]
  },
  "CVE-2017-16914_after_exclude_100:65256516:spec": {
    "timestamp": "2026-01-20T11:31:40.956094",
    "cve_id": "CVE-2017-16914",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "65256516",
    "scores": [
      {
        "score": 2,
        "reasoning": "The code is a USB device disconnect handler, not a protocol message parser. It does not process any protocol messages with length fields, making this specification largely irrelevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 3,
        "reasoning": "The function performs cleanup (freeing memory/URBs) but does not contain any memory allocation operations. It is deallocating resources, not allocating them based on size parameters.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 2,
        "reasoning": "The code handles device teardown, not protocol processing. There are no protocol stages or type handling operations present in this disconnect routine.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 2,
        "reasoning": "This is a kernel driver disconnect callback. It does not receive or process any userspace-provided array lengths or data from userspace.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 2,
        "reasoning": "The function is not a protocol message handler. It performs resource cleanup when a USB device is disconnected, with no variable-length component processing.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 3,
        "reasoning": "While buffer allocation might have occurred elsewhere in the driver, this specific disconnect function only deallocates resources and does not perform any buffer allocation based on input scenarios.",
        "spec_index": 5,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 8,
        "reasoning": "This is highly relevant as it's a USB device driver disconnect handler. While it doesn't validate endpoints (that should happen during probe/initialization), it properly cleans up USB-related resources (URBs, anchored URBs) and manages the USB device lifecycle, which is a core concern for USB driver security and stability.",
        "spec_index": 6,
        "spec_preview": "HS-IO-001: USB device drivers must validate all required endpoints before operation"
      },
      {
        "score": 7,
        "reasoning": "Moderately relevant. This disconnect function is part of the device lifecycle management. While configuration verification should occur during initialization (probe), proper cleanup in disconnect ensures the driver doesn't leave the system in an inconsistent state, which relates to overall device configuration management.",
        "spec_index": 7,
        "spec_preview": "HS-CONF-002: Device configuration must be fully verified before driver initialization"
      }
    ]
  },
  "CVE-2017-12982_before_exclude_100:67321b7f:spec": {
    "timestamp": "2026-01-20T11:32:10.893663",
    "cve_id": "CVE-2017-12982",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "67321b7f",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The code is a BMP image parser that extensively validates header fields (magic number, biSize, biWidth, biHeight, biPlanes, biBitCnt, biClrUsed, etc.) before proceeding with image processing. It performs multiple sanity checks on critical header values.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs pre-validation of size parameters before implicit memory allocations in ReadImage function. It checks for integer overflows in width*height calculations and validates rowbytes calculation, though direct memory allocation calls are not visible in this snippet.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 10,
        "reasoning": "Highly relevant. The code explicitly validates biBitCnt field against allowed values (1, 2, 4, 8, 16, 24, 32) and rejects invalid values. This directly enforces bit count requirements per BMP specification.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. While the code initializes some local variables, there's no visible dynamic memory allocation that needs initialization in this function. The at_bitmap_init function may handle initialization, but it's not shown here.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code uses goto cleanup pattern for error handling, which helps maintain consistent state. However, the image object initialization happens late and cleanup may not fully handle all intermediate states.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This is a file parser, not a network protocol handler. While input validation principles are similar, the specification specifically mentions network protocols.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates various length/field values against platform limits (e.g., checking biHeight != -2147483648, overflow checks). While not specifically for protocol messages, the principle of validating integer fields applies.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Strong relevance. The code performs comprehensive validation of size parameters including integer overflow checks for width*bitcnt and width*height calculations. It validates against both allocation limits and usage requirements before calling ReadImage.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2017-12982_after_exclude_100:d357ba72:spec": {
    "timestamp": "2026-01-20T11:32:22.069947",
    "cve_id": "CVE-2017-12982",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d357ba72",
    "scores": [
      {
        "score": 10,
        "reasoning": "Highly relevant. The code is a BMP image parser that extensively validates header fields (magic number, biSize, biWidth, biHeight, biPlanes, biBitCnt, biClrUsed) before processing the image data. It performs multiple sanity checks on these fields to prevent malformed input from causing issues.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The code performs some pre-validation of size parameters (checking for integer overflows in width*height calculations, validating rowbytes calculation) before memory allocation would occur in ReadImage function. However, the actual memory allocation is not shown in this code snippet, so we can't see the full implementation of this principle.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 9,
        "reasoning": "Strong relevance. The code validates biBitCnt against acceptable values (1, 2, 4, 8, 16, 24, 32) and rejects invalid values. It also has special handling for different bit depths throughout the parsing logic, enforcing BMP specification requirements.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. While the code initializes some local variables (like memset(masks, 0, sizeof(masks))), the specification about memory allocation initialization doesn't directly apply since the actual memory allocation for the image happens in ReadImage function which is not shown in this snippet.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code uses consistent error handling with goto cleanup pattern, maintains the image object state (initialized early with at_bitmap_init), and ensures proper cleanup (fclose) on all error paths. The exp exception object is also properly maintained throughout error conditions.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Very low relevance. This specification is for network protocol handlers, but the code is parsing a BMP file from local filesystem, not network data. While input validation principles are similar, the network-specific aspects don't apply.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code validates various header fields against integer limits (checking biWidth and biHeight against 0x7fffffff, checking for -2147483648 edge case, overflow checks for width*bitcnt). However, this is for file parsing not network protocol messages specifically.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Moderate relevance. The code performs validation of size parameters that would affect memory allocation (integer overflow checks for width*height, width*bitcnt, and rowbytes calculation). These validations help prevent excessive memory allocation. However, the actual allocation calls are not visible in this snippet.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2011-2896_before_exclude_100:6bcc844a:spec": {
    "timestamp": "2026-01-20T11:33:09.376739",
    "cve_id": "CVE-2011-2896",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "6bcc844a",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The GIF parser validates numeric fields like offset_x, offset_y, width, height against the overall image dimensions (boundary checking). It also validates colour_table_size derived from flags. However, it uses unsigned int which may not fully prevent integer overflow during calculations like offset_x + width before the check.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code processes image data in bounded loops (for y, while x) based on validated width and height. The LZW decoding uses burst_bytes limiting to remaining x. However, the loop depends on external LZW decoder state which should itself ensure bounded iteration.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The function validates intermediate states like checking for GIF_IMAGE_SEPARATOR, sufficient data before proceeding, and validating LZW decode results. However, state validation could be more comprehensive for all possible parser transitions.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. Memory for frame_data is obtained via callback (bitmap_get_buffer), and color_table entries are fully initialized. The memset calls initialize frame areas. However, the code assumes the callback returns properly initialized memory.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Error handling uses goto with cleanup that restores buffer_position. However, some error paths may not fully maintain consistent state (e.g., early returns before gif_decode_frame_exit label). The function generally maintains decoded_frame state.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. While this is a file format parser (GIF), not specifically a network protocol handler. The input validation principles are similar but the context is different.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code validates length fields like width/height against boundaries, but doesn't specifically check against platform integer limits (e.g., SIZE_MAX). The focus is more on logical bounds than platform limits.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. Memory allocation happens via callback functions, so size validation is indirect. The code does validate that width*height calculations don't exceed gif boundaries, but doesn't explicitly check allocation size limits.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2011-2896_after_exclude_100:efc03026:spec": {
    "timestamp": "2026-01-20T11:33:17.853189",
    "cve_id": "CVE-2011-2896",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "efc03026",
    "scores": [
      {
        "score": 9,
        "reasoning": "Highly relevant. The GIF parser validates numeric fields like width, height, offset_x, offset_y against boundaries (offset_x + width <= gif->width, offset_y + height <= gif->height). It also checks colour_table_size derived from flags. However, it uses unsigned ints without explicit signedness validation for values read from the data stream (e.g., gif_data[1] | (gif_data[2] << 8)), which assumes well-formed input. Direct relevance to file format parsing.",
        "spec_index": 0,
        "spec_preview": "HS-LOGIC-001: File format parsers must validate all numeric fields for correct signedness and range"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. The code processes image data with bounded loops (for y, while x) based on validated width/height. The LZW decoding uses burst reads with bounds checking (burst_bytes > x). However, the loop conditions depend on previously validated dimensions, ensuring iteration is bounded by the image size. This aligns with the principle of bounded iteration in image decoders.",
        "spec_index": 1,
        "spec_preview": "HS-INPUT-002: Image decoders must implement bounded iteration when processing input data"
      },
      {
        "score": 7,
        "reasoning": "Moderate relevance. The parser validates intermediate states: checks for GIF_IMAGE_SEPARATOR, GIF_TRAILER, and disposal method states before proceeding. It also ensures sufficient data remains at multiple points (gif_bytes checks). However, the state machine is implicit rather than explicit, and some transitions depend on external callbacks (bitmap_get_buffer). Still, validation of conditions before processing aligns with the specification.",
        "spec_index": 2,
        "spec_preview": "HS-STATE-003: Parser state machines must validate intermediate states before proceeding"
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code initializes local variables (e.g., index=0) and uses memset to clear frame_data. However, memory for colour_table (global or local) is assumed pre-allocated/initialized elsewhere. The frame_data from bitmap_get_buffer is not directly allocated here, so full initialization responsibility lies partly outside this function. Partial guidance applies.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 8,
        "reasoning": "Strong relevance. Error handling uses goto gif_decode_frame_exit to maintain consistent state (restoring buffer_position, updating frame opaque/virgin flags). The function ensures cleanup and state restoration on multiple error paths. However, some early returns (e.g., GIF_INSUFFICIENT_DATA) bypass the exit label, potentially skipping state updates. Overall, good error path consistency.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 4,
        "reasoning": "Weak relevance. The code is a GIF file parser, not a network protocol handler. While both involve input validation, the specification specifically targets network protocols. The validation principles (checking data boundaries, markers) are similar, but the context differs significantly.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "Weak relevance. The code validates length-like fields (width, height, colour_table_size) against boundaries but does not explicitly check against platform integer limits (e.g., SIZE_MAX, integer overflow). Calculations like offset_x + width use unsigned ints without overflow checks. Some relevance as GIF fields act as message length fields, but platform-specific limits are not addressed.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 6,
        "reasoning": "Moderate relevance. The code validates size parameters indirectly: checks gif_bytes before processing, ensures colour_table_size fits in buffer. However, memory allocations occur outside this function (via bitmap_get_buffer). Size validations for allocations (e.g., width * height * sizeof(int)) are not shown here, but the code does validate usage requirements (e.g., gif_bytes >= 12). Partial guidance applies.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      }
    ]
  },
  "CVE-2014-0196_before_exclude_100:492c4252:spec": {
    "timestamp": "2026-01-20T11:34:11.150080",
    "cve_id": "CVE-2014-0196",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "492c4252",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code does not process userspace-provided array lengths. It is a cleanup function for a network device, dealing with internal resource deallocation and state management, not input validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All userspace-provided array lengths must be validated against system constraints befo..."
      },
      {
        "score": 4,
        "reasoning": "The code does not handle protocol messages. It is a close/cleanup routine that unregisters a network device and frees internal buffers, not a packet handler.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Protocol message handlers must verify structural integrity of all variable-length c..."
      },
      {
        "score": 4,
        "reasoning": "The code frees buffers (`kfree`) but does not perform any buffer allocation. The specification is about allocation with size limits, which is not relevant to this deallocation path.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Buffer allocation must account for worst-case input scenarios with explicit size limits"
      },
      {
        "score": 1,
        "reasoning": "The code is for a TTY line discipline (sixpack) and network device, not USB request processing. The specification is completely unrelated to the code's context.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: USB request processing must validate buffer presence when length indicates data transf..."
      },
      {
        "score": 1,
        "reasoning": "The code is for a TTY line discipline (sixpack) and network device, not USB/IP protocol. The specification is completely unrelated to the code's context.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: USB/IP protocol implementation must validate packet structure before processing"
      },
      {
        "score": 1,
        "reasoning": "The code is for a TTY line discipline (sixpack) and network device, not USB request state management. The specification is completely unrelated to the code's context.",
        "spec_index": 5,
        "spec_preview": "HS-STATE-003: USB request state transitions must maintain consistent buffer-length relationships"
      },
      {
        "score": 8,
        "reasoning": "The code uses a lock (`write_lock_irq`) to protect the assignment of `tty->disc_data = NULL` and the reading of `sp = tty->disc_data`. This is an atomic check-and-set operation under lock for a shared resource (`disc_data`), which aligns with the principle of the specification, though it's for cleanup/concurrency control rather than initialization.",
        "spec_index": 6,
        "spec_preview": "HS-TIMING-001: Concurrent resource initialization must perform atomic check-and-set operations under..."
      },
      {
        "score": 9,
        "reasoning": "The code manages shared state transitions (setting `tty->disc_data` to NULL under lock, using refcounting (`refcount_dec_and_test`) and a completion (`wait_for_completion`) to ensure all users finish before cleanup, and stopping the network queue). These actions aim to maintain consistency invariants during the shutdown transition across potential concurrent access paths.",
        "spec_index": 7,
        "spec_preview": "HS-STATE-002: Shared state transitions must maintain consistency invariants across all access paths"
      }
    ]
  },
  "CVE-2016-7532_before_exclude_100:d34c5448:spec": {
    "timestamp": "2026-01-20T11:36:53.865809",
    "cve_id": "CVE-2016-7532",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d34c5448",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code reads pixel data into a buffer but does not perform memory allocation itself. It uses GetAuthenticPixels which presumably allocates/returns memory. The specification about initializing memory before use is only weakly relevant because the function processes already allocated pixel queues.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 7,
        "reasoning": "The function returns MagickFalse on pixel queue failure and uses exception handling. Error paths should maintain consistent state, which is moderately relevant as the function modifies pixel data and must ensure image integrity on error.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code is a PSD image parser reading pixel data from a buffer, not a network protocol handler. Very low relevance.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 8,
        "reasoning": "This is an image format parser (PSD). The function reads channel pixels and relies on validated header fields (like image->depth, image->columns, packet_size). Strong relevance as proper validation of header fields before reaching this pixel reading code is critical.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The function does not perform memory allocation directly; it works with pre-allocated pixel queues. Guarding allocation with size parameter validation is weakly relevant here.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "Specification is specifically for BMP parser. This is PSD parsing code. Very low relevance.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "As a file format parser, it must validate structural relationships (e.g., channels, depth, columns, packet_size consistency). The function uses these fields to read pixels, so validation before this point is highly relevant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The code indexes the pixel array via q++ and x in loops. It uses image->columns as the loop bound but does not explicitly validate that the input buffer 'pixels' has sufficient data for the entire row given packet_size. This is a direct array/buffer indexing operation requiring bounds validation against the allocated input buffer size. Strong relevance.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      }
    ]
  },
  "CVE-2016-7532_after_exclude_100:46c3d522:spec": {
    "timestamp": "2026-01-20T11:37:06.147754",
    "cve_id": "CVE-2016-7532",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "46c3d522",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses `GetAuthenticPixels` and `GetAuthenticIndexQueue` which likely perform memory allocation. However, the code does not directly show the allocation or initialization of the returned memory buffers. The pixel data is written via `SetPSDPixel` and `q++`, which initializes the allocated memory. The relevance is weak because the specification focuses on the allocator's responsibility, which is not visible in this function.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function returns `MagickFalse` if `GetAuthenticPixels` fails, and the return value of `SyncAuthenticPixels` is propagated. This shows some error handling. However, the code does not clearly show complex object state management or rollback operations. The relevance is moderate as error paths exist but their consistency with object states is not fully detailed here.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This function is a PSD image parser reading pixel data from a buffer. It is not a network protocol handler. The specification is about network input validation, which is not applicable here.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "This is a PSD image format parser function (`ReadPSDChannelPixels`). It processes pixel data based on parameters like `channels`, `type`, `packet_size`, and `image->depth`. The function assumes critical header fields (like image dimensions, depth) have been validated earlier. The specification directly applies to the overall parser context, though this specific function works on already-validated data.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Image format parsers must validate all critical header fields before processing"
      },
      {
        "score": 5,
        "reasoning": "The function uses `image->columns` in a loop but does not validate it against any allocation size within this function. Memory allocation for pixel rows is done by `GetAuthenticPixels`, which is external. The relevance is weak to moderate because the function uses the column count without explicit pre-validation, but the actual allocation guard might be in the called function.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation must be guarded by pre-validation of size parameters"
      },
      {
        "score": 5,
        "reasoning": "This specification is specifically for BMP parsers. The target code is for PSD (Photoshop) format parsing. Therefore, it is not applicable.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: BMP parser must enforce minimum bit count requirements per specification"
      },
      {
        "score": 5,
        "reasoning": "This is a file format parser function. It relies on structural relationships between fields (e.g., `packet_size`, `image->depth`, `channels`, `type`) to correctly interpret the pixel stream. While it doesn't validate them itself (likely done earlier), the specification's principle directly applies to the code's purpose. Strong relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: File format parsers must validate all structural relationships between header fields"
      },
      {
        "score": 5,
        "reasoning": "The loop `for (x=0; x < (ssize_t) image->columns; x++)` uses `x` as an index. The bounds are checked against `image->columns`, which defines the row width. However, there is no explicit validation that `image->columns` matches the allocated size of the pixel buffer (`q`). The index `x` is also manipulated within the bit-depth=1 else branch (`x++` and `x--`), which requires careful bounds handling. Moderate relevance as indexing is present but full bounds validation against allocation is not visible.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-002: Array indexing operations require explicit bounds validation against allocated size"
      }
    ]
  },
  "CVE-2011-1003_before_exclude_100:cead6673:spec": {
    "timestamp": "2026-01-20T11:38:33.895746",
    "cve_id": "CVE-2011-1003",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "cead6673",
    "scores": [
      {
        "score": 4,
        "reasoning": "The code uses strtok for string splitting, not regular expression parsing. While embedded NUL bytes could affect strtok behavior (as it expects null-terminated strings), the specification is specifically about regular expression parsers, making the connection weak.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 3,
        "reasoning": "The specification is about pattern compilers processing escape sequences, which is unrelated to this simple string splitting function that doesn't compile patterns or process escape sequences.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      },
      {
        "score": 8,
        "reasoning": "Highly relevant. The code uses strtok which is not length-aware and could be problematic with untrusted input containing embedded NULs. The function processes input strings without bounds checking, making it vulnerable to various string processing issues.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: String processing functions must use length-aware operations for potentially untrusted i..."
      },
      {
        "score": 6,
        "reasoning": "Moderately relevant. The code allocates memory via realloc but doesn't explicitly initialize all bytes. However, it immediately assigns string pointers to the allocated slots, so the risk is somewhat mitigated but not completely addressed.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The error handling paths carefully maintain consistent states by freeing all allocated memory before returning NULL. The code properly cleans up both the result array and individual strings in error conditions.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 3,
        "reasoning": "Very low relevance. This is a general string splitting utility function, not a network protocol handler. There's no network I/O or protocol-specific processing in this code.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 9,
        "reasoning": "Highly relevant. The error handling paths consistently free all allocated memory (copy, result array, and individual strings) across all execution branches, maintaining proper memory state management.",
        "spec_index": 6,
        "spec_preview": "HS-MEM-003: Error handling paths must maintain consistent memory state across all execution branches"
      },
      {
        "score": 7,
        "reasoning": "Moderately to strongly relevant. The function accepts input without validation and performs memory operations. While it doesn't establish clear boundaries before operations, the need for such validation is present since the function processes potentially untrusted input strings.",
        "spec_index": 7,
        "spec_preview": "HS-INPUT-004: Input validation must establish clear boundaries before memory operations"
      }
    ]
  },
  "CVE-2013-1978_after_exclude_100:1197ce4e:spec": {
    "timestamp": "2026-01-20T11:39:20.487221",
    "cve_id": "CVE-2013-1978",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "1197ce4e",
    "scores": [
      {
        "score": 8,
        "reasoning": "The code performs memory allocation via jas_alloc2 and uses the allocated memory (e.g., lutents) without explicit full initialization. While some fields may be initialized later in loops, the specification about initializing memory before use is highly relevant to prevent information leaks or undefined behavior.",
        "spec_index": 0,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The code uses extensive error handling with goto error paths. It must ensure consistent object states (like setting dec->image = 0 before returning image) to avoid double-free or use-after-free. The error paths clean up resources (box, dec), showing strong relevance.",
        "spec_index": 1,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The code decodes a JPEG2000 stream from an input stream (jas_stream_t *in). It validates box types, magic numbers, and field consistency (e.g., numcmpts, bpc). This is input validation for a file format protocol, which aligns with the principle of validating input before processing.",
        "spec_index": 2,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The code checks various numeric fields from the stream (e.g., numcmpts, bpcs indices, channo) against reasonable bounds (like comparing with jas_image_numcmpts). This involves validating length/limit fields, though not explicitly against platform integer limits like SIZE_MAX. Moderate relevance.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code uses jas_alloc2 for dynamic allocation (e.g., dec->chantocmptlut, lutents). It checks the result for NULL but does not explicitly validate size parameters against allocation limits or usage requirements (e.g., overflow checks). The specification is strongly relevant for safe memory allocation.",
        "spec_index": 4,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The code enforces consistency between different parts of the JPEG2000 format: IHDR vs. code stream components, BPCC vs. data type, CMAP vs. PCLR presence, CDEF channel numbers. This directly matches \"enforce consistent type handling across all processing stages\". Highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The code does not involve regular expression parsing. It deals with JPEG2000 box decoding and image processing. No regex patterns or NUL bytes handling in input patterns. Very low relevance.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The code does not involve pattern compilers or escape sequence processing. It parses JPEG2000 boxes and performs color management. Very low relevance.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2018-14881_before_exclude_100:0b19ef00:spec": {
    "timestamp": "2026-01-20T11:39:49.278798",
    "cve_id": "CVE-2018-14881",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "0b19ef00",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the capability length field (cap.length) before using it to calculate the next pointer position (pnt += cap.length + 3). This directly aligns with HS-INPUT-001's requirement to validate field lengths before accessing corresponding data. The check \"if (pnt + (cap.length + 3) > end)\" is a critical validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 8,
        "reasoning": "The code performs specific structure validation for the MP capability type (CAPABILITY_CODE_MP), checking the validity of afi and safi values. However, for other capability codes, it only logs a warning and ignores them, which may not constitute \"strict\" validation for all types as implied by the specification. The core principle of validating known capability structures is present.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 5,
        "reasoning": "The code maintains strict bounds checking throughout the parsing loop. It checks \"if (pnt + 3 > end)\" before reading the basic capability header and later checks \"if (pnt + (cap.length + 3) > end)\" before processing the capability payload and advancing the pointer. This ensures operations stay within the packet bounds.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 5,
        "reasoning": "The code validates the length field against the remaining packet buffer (\"end\"), which is a form of enforcing length constraints. However, the specification emphasizes \"RFC-specified\" constraints. The code does not appear to check if cap.length itself meets minimum/maximum values defined by RFCs (e.g., for MP capability), only that it doesn't overflow the received message buffer.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 5,
        "reasoning": "The capability structure is a Type-Length-Value (TLV) format. The code implements complete bounds checking before accessing the TLV's value portion. The check \"if (pnt + (cap.length + 3) > end)\" occurs before the code enters the logic that processes the capability value (e.g., interpreting cap.mpc.afi and cap.mpc.safi).",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 5,
        "reasoning": "This is a restatement of Specification 1 (HS-INPUT-001). The code validates the length field (cap.length) before using it to access data (by calculating the next TLV offset and before processing the MP capability's internal fields). The reasoning is identical to spec_1.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 5,
        "reasoning": "The code enforces strict message boundary validation. The pointer \"pnt\" is advanced by \"cap.length + 3\" only after confirming that this operation would not exceed \"end\". The loop condition \"while (pnt < end)\" and the length checks ensure the parser respects the overall message boundary and each capability's sub-boundary.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains a clear separation. The \"end\" pointer marks the validated boundary of the input buffer. Data is read into the local 'cap' structure via memcpy only after a basic length check. However, the memcpy occurs before the full capability length validation (\"cap.length + 3\"), which could be considered a minor deviation from strict separation if cap.length is malicious. The overall parsing logic, however, robustly uses the validated 'end' boundary.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2018-14881_after_exclude_100:f2bb1a2e:spec": {
    "timestamp": "2026-01-20T11:39:50.905899",
    "cve_id": "CVE-2018-14881",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "f2bb1a2e",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code validates the capability length field (hdr->length) before using it to calculate memory offsets and copy data (memcpy). This directly aligns with HS-INPUT-001's requirement to validate field lengths before accessing corresponding data. The check `if ((pnt + hdr->length + 3) > end)` is a critical bounds validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all field lengths before accessing corresponding data"
      },
      {
        "score": 7,
        "reasoning": "The code performs some validation for the MP capability type (checking afi/safi validity and ignoring based on a flag). However, for other capability codes (the `else` branch), it only logs a warning and ignores them. It does not enforce \"strict structure validation\" for each specific capability type as implied by the specification, missing detailed per-type parsing and validation.",
        "spec_index": 1,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict structure validation for each capabil..."
      },
      {
        "score": 9,
        "reasoning": "The code maintains strict bounds checking throughout the parsing loop. It validates the initial packet segment (`pnt + 3 > end`), validates the capability length against the remaining buffer (`pnt + hdr->length + 3 > end`), and uses `pnt < end` as the loop condition. This is a core practice of the specification.",
        "spec_index": 2,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict bounds checking throughout parsing operations"
      },
      {
        "score": 6,
        "reasoning": "The code validates length fields against the bounds of the received message buffer (`end`). However, the specification emphasizes \"RFC-specified length constraints.\" The code does not show checks for minimum/maximum values of `hdr->length` as might be defined in BGP RFCs (e.g., CAPABILITY_CODE_MP has a defined structure size), which is a more specific form of validation.",
        "spec_index": 3,
        "spec_preview": "HS-INPUT-001: Protocol message field validation must enforce RFC-specified length constraints"
      },
      {
        "score": 9,
        "reasoning": "The code implements TLV-like parsing (Type/Length/Value for capability code, length, and data). It performs complete bounds checking (`pnt + hdr->length + 3 > end`) before accessing the TLV's value portion via `memcpy`. This is a direct and correct application of the specification.",
        "spec_index": 4,
        "spec_preview": "HS-PROTOCOL-002: TLV processing must implement complete bounds checking before field access"
      },
      {
        "score": 9,
        "reasoning": "Identical to spec_1 and spec_5. The code validates the `hdr->length` field in the condition `if ((pnt + hdr->length + 3) > end)` before using it to copy data with `memcpy` and to advance the pointer `pnt`. This is a direct application of the principle.",
        "spec_index": 5,
        "spec_preview": "HS-INPUT-001: Protocol parsers must validate all length fields before data access"
      },
      {
        "score": 9,
        "reasoning": "The code enforces strict message boundary validation for the BGP capability message. The `end` pointer marks the boundary of the capability message data. All pointer arithmetic (`pnt + 3`, `pnt + hdr->length + 3`) is checked against `end` to ensure the parser does not read beyond the allocated message buffer.",
        "spec_index": 6,
        "spec_preview": "HS-PROTOCOL-002: BGP capability processing must enforce strict message boundary validation"
      },
      {
        "score": 5,
        "reasoning": "The code maintains a clear separation: the `pnt` to `end` region is the unvalidated input buffer. Data is only considered validated after passing length checks and is then copied into a local structure (`mpc`). However, the `memcpy` occurs immediately after the length check, which is safe, but the code does not maintain a persistent \"validated region\" data structure; it validates on-the-fly. The principle of separation is followed in practice.",
        "spec_index": 7,
        "spec_preview": "HS-MEM-003: Packet dissection must maintain strict separation between validated and unvalidated data..."
      }
    ]
  },
  "CVE-2018-14461_before_exclude_100:d064254f:spec": {
    "timestamp": "2026-01-20T11:41:27.491934",
    "cve_id": "CVE-2018-14461",
    "code_type": "before",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "d064254f",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code reads a length field from the input data (len = *p++) and uses it for memory allocation and copying. It validates that `p + len > end` to prevent reading beyond the buffer, which is a form of length validation. However, it does not explicitly validate `len` against platform-specific integer limits (e.g., maximum size_t, integer overflow when adding to pointer, or negative values when treated as signed). This is directly relevant to protocol message length field validation.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 5,
        "reasoning": "The code performs memory allocation with `p_malloc(pool, len)` using the unchecked `len` value. While it checks `p + len > end` for buffer boundaries, it does not validate `len` against allocation limits (e.g., maximum allocatable size) or ensure it meets subsequent usage requirements (e.g., non-zero, not causing integer overflow in allocation). This is highly relevant to memory allocation size validation.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 5,
        "reasoning": "The specification about consistent type handling across protocol stages is very low relevance. The code deals with raw bytes and length fields but does not show type conversions, serialization/deserialization of complex types, or multiple processing stages where type consistency could be an issue.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires memory allocations to be fully initialized before use. The code uses `memcpy` to copy data from the input buffer into the newly allocated memory, which initializes it with external data. This is not uninitialized memory use, so the specification is not relevant.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function returns 0 on error (when length validation fails) but does not specify what happens to output parameters (`*buffer`, `*data`) in error paths. The caller might be left with inconsistent states if `*buffer` or `*data` are partially modified. This relates to maintaining consistent object states in error handling.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "The function reads a length-prefixed buffer from network-like data (`*data` to `end`). It validates input (`p > end` and `p + len > end`) before processing (allocation and copy). This is a direct example of network protocol input validation, making it highly relevant.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification about regular expression parsers and NUL bytes is completely unrelated. The code does not involve regular expressions, pattern parsing, or string handling where NUL bytes would be significant.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification about pattern compilers and escape sequences is completely unrelated. The code reads a simple length-prefixed binary buffer, with no pattern compilation, escape sequence processing, or boundary issues related to escape sequences.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  },
  "CVE-2018-14461_after_exclude_100:80a6eba4:spec": {
    "timestamp": "2026-01-20T11:41:31.423707",
    "cve_id": "CVE-2018-14461",
    "code_type": "after",
    "data_source": "exclude_100",
    "knowledge_type": "spec",
    "specs_count": 8,
    "code_hash": "80a6eba4",
    "scores": [
      {
        "score": 9,
        "reasoning": "The code reads a length field from a protocol message (`len = *p++`). It validates that `p + len > end` to prevent reading beyond the buffer, which is a direct application of validating length fields against the available data boundaries. However, it does not explicitly check for platform-specific integer overflow/wraparound (e.g., if `len` is very large, `p + len` could overflow before the comparison). This is a core concern of HS-INPUT-001, making it highly relevant.",
        "spec_index": 0,
        "spec_preview": "HS-INPUT-001: All protocol message length fields must be validated against platform-specific integer..."
      },
      {
        "score": 8,
        "reasoning": "The code performs memory allocation (`p_malloc(pool, len)`) based on the user-controlled `len` value. It validates that `len != 0` before allocation, which is a basic check. However, it does not validate `len` against any maximum allocation limit (allocation limits) or ensure the size is suitable for subsequent operations (usage requirements, though `memcpy` uses the same `len`). The principle of validating size parameters before allocation is central to this function, making the specification strongly relevant.",
        "spec_index": 1,
        "spec_preview": "HS-MEM-002: Memory allocation operations must validate size parameters against both allocation limit..."
      },
      {
        "score": 3,
        "reasoning": "The specification deals with consistent type handling across processing stages. The target code is a low-level buffer reading function that treats data as bytes/unsigned chars. There is no evidence of type conversions, serialization/deserialization of complex types, or multiple processing stages where type consistency could be an issue. Relevance is very low.",
        "spec_index": 2,
        "spec_preview": "HS-PROTOCOL-003: Protocol implementations must enforce consistent type handling across all processin..."
      },
      {
        "score": 5,
        "reasoning": "The specification requires memory to be initialized before use. This function uses `memcpy` to copy data from the input buffer into the newly allocated memory. The allocated memory is therefore initialized with the input data, not left uninitialized. The specification about initializing memory to a known state (e.g., zeroing) before use does not apply here. Relevance is very low.",
        "spec_index": 3,
        "spec_preview": "HS-MEM-001: Memory allocations must be fully initialized before use"
      },
      {
        "score": 5,
        "reasoning": "The function has error handling paths (return 0). On error, it returns 0 but does not modify the output `*buffer` (which remains uninitialized from the caller's perspective). The caller must handle the 0 return value correctly. The function itself maintains a simple state (the `*data` pointer is only advanced on success). There is a moderate relevance because error paths must be considered, but the function's state is relatively simple.",
        "spec_index": 4,
        "spec_preview": "HS-STATE-002: Error handling paths must maintain consistent object states"
      },
      {
        "score": 5,
        "reasoning": "This function is a network protocol handler (reading a length-prefixed buffer from a data stream). It performs essential input validation: checking pointer boundaries (`p > end`, `p + len > end`) and validating the length (`len == 0`). This is a direct and critical application of HS-IO-003. The validation prevents buffer over-read.",
        "spec_index": 5,
        "spec_preview": "HS-IO-003: Network protocol handlers must validate input before processing"
      },
      {
        "score": 5,
        "reasoning": "The specification is about regular expression parsers handling NUL bytes. The target code does not involve regular expressions at all. It reads binary data where NUL bytes are valid content. The specification is completely unrelated.",
        "spec_index": 6,
        "spec_preview": "HS-INPUT-001: Regular expression parsers must properly handle embedded NUL bytes in input patterns"
      },
      {
        "score": 5,
        "reasoning": "The specification is about pattern compilers and escape sequences. The target code is a simple binary buffer reader with no pattern compilation, escape sequence processing, or lexical analysis. The specification is completely unrelated.",
        "spec_index": 7,
        "spec_preview": "HS-PROTOCOL-002: Pattern compilers must maintain strict boundaries when processing escape sequences"
      }
    ]
  }
}