[
    {
        "function_name": "extract_archive_thread",
        "vulnerability": "Path Traversal",
        "criticism": "The reasoning correctly identifies a potential path traversal vulnerability due to the lack of sanitization of the 'pathname' variable. However, the code uses '_g_path_get_relative_basename_safe', which suggests some level of path validation. The severity is high because path traversal can lead to arbitrary file writes, but the profitability is moderate as it requires crafting a specific archive.",
        "correctness": 7,
        "severity": 8,
        "profitability": 6,
        "reason": "The code constructs file paths using user-controlled input without proper sanitization or validation. This vulnerability can allow an attacker to craft archive entries with paths containing '../' sequences, potentially leading to arbitrary file write operations outside the intended extraction directory.",
        "code": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\tg_object_unref (info);\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\tparent = g_file_get_parent (file);\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\t\tfiletype = archive_entry_filetype (entry);\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "file_name": "445995.sol",
        "final_score": 7.0
    },
    {
        "function_name": "extract_archive_thread",
        "vulnerability": "Absolute Path Traversal",
        "criticism": "The reasoning correctly identifies the risk of absolute path traversal due to the construction of 'fullpath' from 'pathname'. However, the use of '_g_path_get_relative_basename_safe' suggests some mitigation. The severity is high due to the potential for critical file overwrites, and the profitability is moderate.",
        "correctness": 7,
        "severity": 8,
        "profitability": 6,
        "reason": "The code constructs the `fullpath` variable using the `pathname` that is directly derived from the archive entry without proper sanitization. This can lead to absolute path traversal if an attacker crafts the archive with files whose paths are absolute paths or contain path traversal sequences. This could allow an attacker to write files outside of the intended extraction directory, potentially overwriting critical system files.",
        "code": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\tg_object_unref (info);\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\tparent = g_file_get_parent (file);\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\t\tfiletype = archive_entry_filetype (entry);\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "file_name": "445995.sol",
        "final_score": 7.0
    },
    {
        "function_name": "extract_archive_thread",
        "vulnerability": "Hard Link Vulnerability",
        "criticism": "The reasoning is correct in identifying the risk of creating hard links based on untrusted input. This can indeed lead to security issues if an attacker can control the link target. The severity is moderate as it requires specific conditions to exploit, and the profitability is low due to the complexity of crafting such an attack.",
        "correctness": 8,
        "severity": 5,
        "profitability": 4,
        "reason": "Creating hard links based on potentially untrusted input can lead to security issues. An attacker could exploit this to create hard links that point to sensitive files on the filesystem, which might be manipulated or accessed through the archive extraction process.",
        "code": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\tg_object_unref (info);\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\tparent = g_file_get_parent (file);\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\t\tfiletype = archive_entry_filetype (entry);\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "file_name": "445995.sol",
        "final_score": 6.25
    },
    {
        "function_name": "extract_archive_thread",
        "vulnerability": "Unsafe Hard Link Creation",
        "criticism": "The reasoning is correct in identifying the risk of creating hard links without sufficient validation. This can lead to privilege escalation if an attacker can control the link targets. The severity is moderate, and the profitability is low due to the complexity of exploiting this vulnerability.",
        "correctness": 8,
        "severity": 5,
        "profitability": 4,
        "reason": "The code attempts to create a hard link using `link(oldname, newname)` without sufficient validation of `oldname` and `newname`. This can lead to vulnerabilities if an attacker can control the `oldname` or `newname` to point to sensitive files or directories. It could potentially allow an attacker to perform privilege escalation or data manipulation by linking to unauthorized files.",
        "code": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\tg_object_unref (info);\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\tparent = g_file_get_parent (file);\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\t\tfiletype = archive_entry_filetype (entry);\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "file_name": "445995.sol",
        "final_score": 6.25
    },
    {
        "function_name": "extract_archive_thread",
        "vulnerability": "Insecure File Overwrite",
        "criticism": "The reasoning is partially correct. The use of 'g_file_replace' does allow file overwriting, but the function checks for 'overwrite' and 'skip_older' flags, which mitigate the risk. The severity is moderate as it requires specific conditions, and the profitability is low due to the need for control over the archive content.",
        "correctness": 6,
        "severity": 5,
        "profitability": 3,
        "reason": "The function uses g_file_replace to overwrite files without sufficient checks or conditions. This could allow an attacker to overwrite important system files if they can control the archive content and paths, leading to potential denial of service or privilege escalation.",
        "code": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\tg_object_unref (info);\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\tparent = g_file_get_parent (file);\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\t\tfiletype = archive_entry_filetype (entry);\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "file_name": "445995.sol",
        "final_score": 5.0
    },
    {
        "function_name": "extract_archive_thread",
        "vulnerability": "Improper File Overwrite Handling",
        "criticism": "The reasoning is partially correct. While 'g_file_replace' does overwrite files, the function checks for 'overwrite' and 'skip_older' flags, which mitigate the risk. The severity is moderate, and the profitability is low due to the need for specific conditions to exploit.",
        "correctness": 6,
        "severity": 5,
        "profitability": 3,
        "reason": "The function uses `g_file_replace` to overwrite existing files without explicit checks for file permissions or ownership. This could be exploited by an attacker to overwrite critical files if the extraction directory is not properly restricted, leading to potential privilege escalation or denial of service by corrupting system or user files.",
        "code": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\tg_object_unref (info);\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\tparent = g_file_get_parent (file);\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\t\tfiletype = archive_entry_filetype (entry);\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "file_name": "445995.sol",
        "final_score": 5.0
    }
]