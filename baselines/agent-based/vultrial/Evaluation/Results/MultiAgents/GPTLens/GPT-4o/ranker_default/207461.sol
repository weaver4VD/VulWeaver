[
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning correctly identifies the risk of buffer overflow due to fixed-size buffer operations without size checks. The use of ReadOK with potentially large reads into a 64-byte buffer is a valid concern. The potential for arbitrary code execution is significant if an attacker can control the input size.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The buffer is defined with a fixed size of 64 bytes. Multiple operations read data into this buffer without checking the size of the data being read, particularly in the ReadOK function calls. If more than 64 bytes are read, it could lead to a buffer overflow, allowing an attacker to overwrite adjacent memory and potentially execute arbitrary code.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 8.25
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Integer Overflow",
        "criticism": "The reasoning correctly identifies the risk of integer overflow in the calculation of rowbytes and other size-related variables. The code does not adequately check for overflow in these calculations, which could lead to buffer overflows. The potential for arbitrary code execution is significant if an attacker can manipulate biWidth and biBitCnt.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The calculation of 'rowbytes' and other size-related variables do not adequately check for integer overflow. If 'biWidth' and 'biBitCnt' are large enough, their multiplication can overflow, leading to an incorrectly sized memory allocation. This can result in buffer overflows when the actual data is read, enabling potential exploitation for arbitrary code execution.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 8.25
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning correctly identifies a potential buffer overflow due to the use of biSize in reading operations without adequate bounds checking. However, the code does perform some checks on biSize, which reduces the likelihood of exploitation. The potential for arbitrary code execution exists, but the conditions required make it less likely.",
        "correctness": 7,
        "severity": 7,
        "profitability": 6,
        "reason": "The buffer is read with a size based directly on biSize from the file without adequate bounds checking. If biSize is larger than expected, this could lead to a buffer overflow, allowing an attacker to cause a crash or execute arbitrary code.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 6.75
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Integer Overflow",
        "criticism": "The reasoning correctly identifies a potential integer overflow issue with the calculation of bfSize and bfOffs using ToL. However, the code does include checks for large values of biWidth and biBitCnt, which mitigate some overflow risks. The vulnerability is plausible but not as severe as described because the code has some safeguards. The potential for arbitrary code execution is present but requires specific conditions to be met.",
        "correctness": 7,
        "severity": 6,
        "profitability": 5,
        "reason": "The code calculates the bfSize and bfOffs fields using ToL, which might result in integer overflow if the values read from the file are large. This can lead to improper memory allocation or buffer overflow in subsequent operations, allowing for potential arbitrary code execution.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 6.25
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Out-of-bounds Read",
        "criticism": "The reasoning is correct in identifying that bfOffs is used in fseek without sufficient validation, which could lead to out-of-bounds reads. However, the impact of this vulnerability is limited to reading unallocated memory, which is less severe than arbitrary code execution. The potential for information leakage exists, but the profitability is low unless sensitive data is located nearby.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The fseek operation uses bfOffs, which is directly derived from the file without sufficient validation. If bfOffs is manipulated, it can cause the fseek to position the file pointer outside the bounds of the actual file data. This could lead to reading unallocated memory or data, potentially leaking sensitive information or causing undefined behavior.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 6.0
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Improper File Handling",
        "criticism": "The reasoning about directory traversal vulnerabilities due to the use of fopen is valid. However, the severity is overstated as directory traversal requires specific conditions and is often mitigated by operating system-level protections. The profitability is low unless the application has elevated privileges or access to sensitive files.",
        "correctness": 8,
        "severity": 4,
        "profitability": 3,
        "reason": "The use of fopen without validating the input 'filename' can lead to directory traversal vulnerabilities. An attacker can provide a path that points to sensitive files on the system, potentially exposing or modifying them.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 5.75
    }
]