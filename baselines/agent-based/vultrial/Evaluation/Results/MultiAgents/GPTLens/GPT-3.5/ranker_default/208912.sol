[
    {
        "function_name": "file_upload",
        "vulnerability": "Lack of input validation",
        "criticism": "The reasoning provided for the vulnerability is valid as lack of input validation can lead to various attacks like SQL injection or file upload vulnerabilities. The correctness score is high as it is a common vulnerability in web applications. However, the severity and profitability scores are too low as the impact of this vulnerability can be significant depending on the context.",
        "correctness": 8,
        "severity": 5,
        "profitability": 4,
        "reason": " ",
        "code": "getcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t\n    int\t\tindent,\t\t\n    int\t\tclear_ccline)\t\n{\n    static int\tdepth = 0;\t    \n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t\n    int\t\tdo_abbr;\t\t\n    char_u\t*lookfor = NULL;\t\n    int\t\thiscnt;\t\t\t\n    int\t\thistype;\t\t\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t\n    int\t\twim_index = 0;\t\t\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t\n    int\t\tsome_key_typed = FALSE;\t\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n    ++depth;\n    if (ccline.cmdbuff != NULL)\n    {\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t\n    if (depth == 50)\n    {\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n    redir_off = TRUE;\t\t\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n    msg_scroll = FALSE;\n    State = MODE_CMDLINE;\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t\n#endif\n    settmode(TMODE_RAW);\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n    init_history();\n    hiscnt = get_hislen();\t\n    histype = hist_char2type(firstc);\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t\n#endif\n    if (did_emsg)\n\tredrawcmd();\n#ifdef FEAT_STL_OPT\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\tif (*p_tal != NUL)\n\t{\n\t    redraw_tabline = TRUE;\n\t    found_one = TRUE;\n\t}\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n    did_emsg = FALSE;\n    got_int = FALSE;\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\tredir_off = TRUE;\t\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t\n#endif\n\tquit_more = FALSE;\t\n\tdid_emsg = FALSE;\t\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\tdo\n\t{\n\t    cursorcmd();\t\t\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t&& (!break_ctrl_c || exmode_active)\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\tif (cmdline_pum_active())\n\t{\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n\tif (end_wildmenu)\n\t{\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n\t    wildmenu_cleanup(&ccline);\n\t}\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t\n\t    c = Ctrl_BSL;\t\t\n\t}\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\tgotesc = FALSE;\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1\n\t\t    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST))\n\t\t\t    || p_wmnu))\n\t\t{\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\tif (c == NUL || c == K_ZERO)\t    \n\t    c = NL;\n\tdo_abbr = TRUE;\t\t\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t\n\t    goto cmdline_changed;\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t\n#endif\n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_U:\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\tcase ESC:\t\n\tcase Ctrl_C:\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\t\tgotesc = TRUE;\t\t\n\t\tgoto returncmd;\t\t\n\tcase Ctrl_R:\t\t\t\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t\n\t\tredrawcmd();\n\t\tcontinue;\t\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\tcase K_IGNORE:\n\t\tgoto cmdline_not_changed;\n#ifdef FEAT_GUI_MSWIN\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    \n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   \n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\tcase K_SELECT:\t    \n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_B:\t    \n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_E:\t    \n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_A:\t    \n\t\tif (cmdline_pum_active())\n\t\t    cmdline_pum_cleanup(&ccline);\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\tcase Ctrl_N:\t    \n\tcase Ctrl_P:\t    \n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    \n\tcase Ctrl_T:\t    \n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\t\t    do_abbr = FALSE;\t    \n\t\t    extra_char = NUL;\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\t\tbreak;\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    \n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif \n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    \n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t\n\t\t    goto returncmd;\t\n\t\t}\n#endif\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\nreturncmd:\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n    if (ccline.cmdbuff != NULL)\n    {\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n    State = save_State;\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t\n#endif\n    sb_text_end_cmdline();\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}",
        "file_name": "208912.sol",
        "final_score": 6.25
    },
    {
        "function_name": "login",
        "vulnerability": "Weak password policy",
        "criticism": "The reasoning provided for the vulnerability is valid as a weak password policy can lead to easy brute force attacks. However, the severity and profitability scores are too high as the impact of weak password policy can vary depending on other security measures in place. The correctness score is also high as it is a common vulnerability in many systems.",
        "correctness": 7,
        "severity": 4,
        "profitability": 3,
        "reason": " ",
        "code": "getcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t\n    int\t\tindent,\t\t\n    int\t\tclear_ccline)\t\n{\n    static int\tdepth = 0;\t    \n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t\n    int\t\tdo_abbr;\t\t\n    char_u\t*lookfor = NULL;\t\n    int\t\thiscnt;\t\t\t\n    int\t\thistype;\t\t\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t\n    int\t\twim_index = 0;\t\t\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t\n    int\t\tsome_key_typed = FALSE;\t\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n    ++depth;\n    if (ccline.cmdbuff != NULL)\n    {\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t\n    if (depth == 50)\n    {\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n    redir_off = TRUE;\t\t\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n    msg_scroll = FALSE;\n    State = MODE_CMDLINE;\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t\n#endif\n    settmode(TMODE_RAW);\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n    init_history();\n    hiscnt = get_hislen();\t\n    histype = hist_char2type(firstc);\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t\n#endif\n    if (did_emsg)\n\tredrawcmd();\n#ifdef FEAT_STL_OPT\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\tif (*p_tal != NUL)\n\t{\n\t    redraw_tabline = TRUE;\n\t    found_one = TRUE;\n\t}\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n    did_emsg = FALSE;\n    got_int = FALSE;\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\tredir_off = TRUE;\t\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t\n#endif\n\tquit_more = FALSE;\t\n\tdid_emsg = FALSE;\t\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\tdo\n\t{\n\t    cursorcmd();\t\t\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t&& (!break_ctrl_c || exmode_active)\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\tif (cmdline_pum_active())\n\t{\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n\tif (end_wildmenu)\n\t{\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n\t    wildmenu_cleanup(&ccline);\n\t}\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t\n\t    c = Ctrl_BSL;\t\t\n\t}\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\tgotesc = FALSE;\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1\n\t\t    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST))\n\t\t\t    || p_wmnu))\n\t\t{\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\tif (c == NUL || c == K_ZERO)\t    \n\t    c = NL;\n\tdo_abbr = TRUE;\t\t\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t\n\t    goto cmdline_changed;\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t\n#endif\n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_U:\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\tcase ESC:\t\n\tcase Ctrl_C:\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\t\tgotesc = TRUE;\t\t\n\t\tgoto returncmd;\t\t\n\tcase Ctrl_R:\t\t\t\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t\n\t\tredrawcmd();\n\t\tcontinue;\t\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\tcase K_IGNORE:\n\t\tgoto cmdline_not_changed;\n#ifdef FEAT_GUI_MSWIN\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    \n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   \n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\tcase K_SELECT:\t    \n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_B:\t    \n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_E:\t    \n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\tcase Ctrl_A:\t    \n\t\tif (cmdline_pum_active())\n\t\t    cmdline_pum_cleanup(&ccline);\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\tcase Ctrl_N:\t    \n\tcase Ctrl_P:\t    \n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    \n\tcase Ctrl_T:\t    \n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\t\t    do_abbr = FALSE;\t    \n\t\t    extra_char = NUL;\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\t\tbreak;\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    \n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif \n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    \n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t\n\t\t    goto returncmd;\t\n\t\t}\n#endif\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\nreturncmd:\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n    if (ccline.cmdbuff != NULL)\n    {\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n    State = save_State;\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t\n#endif\n    sb_text_end_cmdline();\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}",
        "file_name": "208912.sol",
        "final_score": 5.25
    }
]