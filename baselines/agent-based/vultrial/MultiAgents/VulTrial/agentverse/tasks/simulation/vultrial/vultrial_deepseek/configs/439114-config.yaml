agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nstatic\
    \ Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n\
    {\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\
    \n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    start_position;\n\
    \n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n\
    \  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register\
    \ unsigned char\n    *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n    length;\n\
    \n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\
    \n  unsigned int\n    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n\
    \    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n\
    \  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug\
    \ != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\"\
    ,\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n\
    \  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n\
    \  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status\
    \ == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image\
    \ *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n\
    \  bmp_info.ba_offset=0;\n  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n\
    \  if (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n  do\n  {\n    LongPixelPacket\n      shift;\n\n    PixelPacket\n      quantum_bits;\n\
    \n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset ==\
    \ 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n   \
    \ while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n\
    \      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n\
    \      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n\
    \    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    \  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char\
    \ *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\"\
    ,2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n\
    \n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \         \"  File_size in header:  %u bytes\",bmp_info.file_size);\n\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n\
    \    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n\
    \      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n\
    \        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n\
    \          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"\
    BMP2\",MaxTextExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n\
    \        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n      \
    \  bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n\
    \        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n\
    \        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n      \
    \  bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n        \
    \  {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \
    \        \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n\
    \              bmp_info.height);\n          }\n      }\n    else\n      {\n  \
    \      /*\n          Microsoft Windows BMP image file.\n        */\n        if\
    \ (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\"\
    );\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t)\
    \ ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n\
    \        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n\
    \        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n\
    \        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n\
    \        bmp_info.colors_important=ReadBlobLSBLong(image);\n        if (image->debug\
    \ != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n\
    \              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n\
    \            switch (bmp_info.compression)\n            {\n              case\
    \ BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_RGB\");\n                break;\n     \
    \         }\n              case BI_RLE4:\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression:\
    \ BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n\
    \              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_RLE8\");\n                break;\n    \
    \          }\n              case BI_BITFIELDS:\n              {\n            \
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"\
    \  Compression: BI_BITFIELDS\");\n                break;\n              }\n  \
    \            case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_PNG\");\n                break;\n     \
    \         }\n              case BI_JPEG:\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression:\
    \ BI_JPEG\");\n                break;\n              }\n              default:\n\
    \              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n  \
    \            }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Number of colors: %u\",bmp_info.number_colors);\n         \
    \ }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n\
    \        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size\
    \ > 40)\n          {\n            double\n              gamma;\n\n           \
    \ /*\n              Read color management information.\n            */\n     \
    \       bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n\
    \            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n\
    \            */\n#           define BMP_DENOM ((double) 0x40000000)\n        \
    \    bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n     \
    \       bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n  \
    \          bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n         \
    \     bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n\
    \            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n\
    \            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n     \
    \       image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n        \
    \    gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n\
    \            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n\
    \            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n\
    \            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n\
    \            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n        \
    \      bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n\
    \            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n\
    \            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n   \
    \         image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n    \
    \        /*\n              Decode 16^16 fixed point formatted gamma_scales.\n\
    \            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n\
    \            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n\
    \              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n     \
    \     (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n\n     \
    \   if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\
    \n            /*\n              Read BMP Version 5 color management information.\n\
    \            */\n            intent=ReadBlobLSBLong(image);\n            switch\
    \ ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n       \
    \       {\n                image->rendering_intent=SaturationIntent;\n       \
    \         break;\n              }\n              case LCS_GM_GRAPHICS:\n     \
    \         {\n                image->rendering_intent=RelativeIntent;\n       \
    \         break;\n              }\n              case LCS_GM_IMAGES:\n       \
    \       {\n                image->rendering_intent=PerceptualIntent;\n       \
    \         break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n\
    \              {\n                image->rendering_intent=AbsoluteIntent;\n  \
    \              break;\n              }\n            }\n            (void) ReadBlobLSBLong(image);\
    \  /* Profile data */\n            (void) ReadBlobLSBLong(image);  /* Profile\
    \ size */\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n \
    \         }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n\
    \      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n\
    \        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n\
    \      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n       \
    \ (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"\
    LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width\
    \ <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\"\
    );\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"\
    NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"\
    StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) &&\
    \ (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) &&\
    \ (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24)\
    \ && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"\
    UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n      \
    \  bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"\
    UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel\
    \ != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\"\
    );\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n \
    \     ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n\
    \    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n    \
    \  ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n   \
    \ switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n\
    \        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n\
    \        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n\
    \        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n    \
    \  case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\"\
    );\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\"\
    );\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n\
    \    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel\
    \ <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->matte=((bmp_info.alpha_mask\
    \ != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;\n\
    \    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\
    \n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n\
    \        one=1;\n        if (image->colors == 0)\n          image->colors=one\
    \ << bmp_info.bits_per_pixel;\n      }\n    image->x_resolution=(double) bmp_info.x_pixels/100.0;\n\
    \    image->y_resolution=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n\
    \    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n\
    \      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n\
    \    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    if (image->storage_class\
    \ == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n\
    \        size_t\n          packet_size;\n\n        /*\n          Read BMP raster\
    \ colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap\
    \ of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors)\
    \ == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n   \
    \       image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned\
    \ char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n\
    \        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n\
    \        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char\
    \ *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n\
    \        if (count != (ssize_t) (packet_size*image->colors))\n          {\n  \
    \          bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\"\
    );\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors;\
    \ i++)\n        {\n          image->colormap[i].blue=ScaleCharToQuantum(*p++);\n\
    \          image->colormap[i].green=ScaleCharToQuantum(*p++);\n          image->colormap[i].red=ScaleCharToQuantum(*p++);\n\
    \          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned\
    \ char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image\
    \ data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n\
    \    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n\
    \    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t)\
    \ bytes_per_line*image->rows;\n    if (((MagickSizeType) length/8) > GetBlobSize(image))\n\
    \      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\"\
    );\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression\
    \ == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n\
    \          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info ==\
    \ (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     \
    \   if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n\
    \        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\"\
    );\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length\
    \ encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n\
    \          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info ==\
    \ (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     \
    \   status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n\
    \        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\"\
    );\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n\
    \    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n      \
    \    We should ignore the alpha value in BMP3 files but there have been\n    \
    \      reports about 32 bit files with alpha. We do a quick check to see if\n\
    \          the alpha channel contains a value that is not zero (default value).\n\
    \          If we find a non zero value we asume the program that wrote the file\n\
    \          wants to use the alpha channel.\n        */\n        if ((image->matte\
    \ == MagickFalse) && (bmp_info.size == 40) &&\n            (bmp_info.bits_per_pixel\
    \ == 32))\n          {\n            bytes_per_line=4*(image->columns);\n     \
    \       for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n        \
    \      p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x <\
    \ (ssize_t) image->columns; x++)\n              {\n                if (*(p+3)\
    \ != 0)\n                  {\n                    image->matte=MagickTrue;\n \
    \                   y=-1;\n                    break;\n                  }\n \
    \               p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->matte\
    \ != MagickFalse ? 0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n\
    \        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n\
    \        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n   \
    \           RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n\
    \            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n\
    \          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void)\
    \ memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel\
    \ == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register size_t\n\
    \          sample;\n\n        /*\n          Get shift and quantum bits info from\
    \ bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n         \
    \ while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n\
    \            shift.red++;\n            if (shift.red > 32U)\n              break;\n\
    \          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask\
    \ << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n\
    \            if (shift.green > 32U)\n              break;\n          }\n     \
    \   if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue)\
    \ & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if\
    \ (shift.blue > 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask\
    \ != 0)\n          while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL)\
    \ == 0)\n          {\n            shift.opacity++;\n            if (shift.opacity\
    \ > 32U)\n              break;\n          }\n        sample=shift.red;\n     \
    \   while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n \
    \         sample++;\n          if (sample > 32U)\n            break;\n       \
    \ }\n        quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n\
    \        sample=shift.green;\n        while (((bmp_info.green_mask << sample)\
    \ & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample\
    \ > 32U)\n            break;\n        }\n        quantum_bits.green=ClampToQuantum((MagickRealType)\
    \ sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask\
    \ << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n         \
    \ if (sample > 32U)\n            break;\n        }\n        quantum_bits.blue=ClampToQuantum((MagickRealType)\
    \ sample-shift.blue);\n        sample=shift.opacity;\n        while (((bmp_info.alpha_mask\
    \ << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n         \
    \ if (sample > 32U)\n            break;\n        }\n        quantum_bits.opacity=ClampToQuantum((MagickRealType)\
    \ sample-\n          shift.opacity);\n      }\n    switch (bmp_info.bits_per_pixel)\n\
    \    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n\
    \        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n\
    \          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n  \
    \          for (bit=0; bit < 8; bit++)\n            {\n              index=(IndexPacket)\
    \ (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n\
    \              q++;\n            }\n            p++;\n          }\n          if\
    \ ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit <\
    \ (image->columns % 8); bit++)\n              {\n                index=(IndexPacket)\
    \ (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n\
    \              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          if (image->previous == (Image\
    \ *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 4:\n      {\n        /*\n          Convert\
    \ PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y\
    \ >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n  \
    \          (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),\n \
    \             &index,exception);\n            SetPixelIndex(indexes+x,index);\n\
    \            (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,\n\
    \              exception);\n            SetPixelIndex(indexes+x+1,index);\n  \
    \          p++;\n          }\n          if ((image->columns % 2) != 0)\n     \
    \       {\n              (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4)\
    \ & 0xf),\n                &index,exception);\n              SetPixelIndex(indexes+(x++),index);\n\
    \              p++;\n            }\n          if (x < (ssize_t) image->columns)\n\
    \            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n\
    \            break;\n          if (image->previous == (Image *) NULL)\n      \
    \      {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 8:\n      {\n        /*\n          Convert\
    \ PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8)\
    \ ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n\
    \        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n      \
    \      (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);\n   \
    \         SetPixelIndex(indexes,index);\n            indexes++;\n            p++;\n\
    \            q++;\n          }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n          \
    \      (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 16:\n      {\n        unsigned int\n    \
    \      alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded\
    \ 16-bit PseudoColor scanline.\n        */\n        if (bmp_info.compression !=\
    \ BI_RGB &&\n            bmp_info.compression != BI_BITFIELDS)\n          {\n\
    \            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n\
    \              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns\
    \ % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1;\
    \ y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned\
    \ int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask)\
    \ << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n             \
    \ red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n      \
    \        red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask)\
    \ << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n         \
    \     green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n\
    \              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green\
    \ <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel\
    \ & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue\
    \ == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue\
    \ <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned\
    \ short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\
    \ green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n\
    \            SetPixelOpacity(q,OpaqueOpacity);\n            if (image->matte !=\
    \ MagickFalse)\n              {\n                alpha=((pixel & bmp_info.alpha_mask)\
    \ << shift.opacity) >> 16;\n                if (quantum_bits.opacity <= 8)\n \
    \                 alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned\
    \ short) alpha));\n              }\n            q++;\n          }\n          if\
    \ (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n\
    \          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous\
    \ == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n\
    \        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for\
    \ (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n\
    \            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n\
    \            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n\
    \          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        \
    \    break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n        \
    \  if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor\
    \ scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n   \
    \         (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\"\
    );\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t)\
    \ image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n           \
    \ alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned\
    \ int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned\
    \ int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n       \
    \     red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red\
    \ == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask)\
    \ << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n         \
    \     green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) <<\
    \ shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue\
    \ >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n\
    \            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n \
    \           SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n    \
    \        SetPixelAlpha(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n\
    \              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.opacity)\
    \ >> 16;\n                if (quantum_bits.opacity == 8)\n                  alpha|=(alpha\
    \ >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)\
    \ alpha));\n              }\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n          \
    \      (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  \
    \    }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y\
    \ > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n      \
    \  ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n \
    \         image->filename);\n        break;\n      }\n    if (bmp_info.height\
    \ < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n    \
    \      Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n\
    \        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n\
    \            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n\
    \          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes\
    \ != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n\
    \        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n\
    \        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if\
    \ ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n  \
    \        Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image);\n\
    \        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n     \
    \       status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n\
    \        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      \
    \    GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n\
    \      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n\
    \  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n\
    }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\nstatic Image *ReadBMPImage(const\
    \ ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\
    \n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n \
    \   status;\n\n  MagickOffsetType\n    offset,\n    start_position;\n\n  MemoryInfo\n\
    \    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n\
    \    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n \
    \   *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n    length;\n\n  ssize_t\n\
    \    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  unsigned\
    \ int\n    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n    Open image\
    \ file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature\
    \ == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void)\
    \ LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n\
    \  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature\
    \ == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n\
    \  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n\
    \  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n  if\
    \ (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n  do\n  {\n    LongPixelPacket\n      shift;\n\n    PixelPacket\n      quantum_bits;\n\
    \n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset ==\
    \ 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n   \
    \ while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n\
    \      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n\
    \      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n\
    \    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    \  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char\
    \ *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\"\
    ,2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n\
    \n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \         \"  File_size in header:  %u bytes\",bmp_info.file_size);\n\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n\
    \    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n\
    \      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n\
    \        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n\
    \          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"\
    BMP2\",MaxTextExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n\
    \        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n      \
    \  bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n\
    \        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n\
    \        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n      \
    \  bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n        \
    \  {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \
    \        \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n\
    \              bmp_info.height);\n          }\n      }\n    else\n      {\n  \
    \      /*\n          Microsoft Windows BMP image file.\n        */\n        if\
    \ (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\"\
    );\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t)\
    \ ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n\
    \        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n\
    \        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n\
    \        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n\
    \        bmp_info.colors_important=ReadBlobLSBLong(image);\n        if (image->debug\
    \ != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n\
    \              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n\
    \            switch (bmp_info.compression)\n            {\n              case\
    \ BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_RGB\");\n                break;\n     \
    \         }\n              case BI_RLE4:\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression:\
    \ BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n\
    \              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_RLE8\");\n                break;\n    \
    \          }\n              case BI_BITFIELDS:\n              {\n            \
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"\
    \  Compression: BI_BITFIELDS\");\n                break;\n              }\n  \
    \            case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_PNG\");\n                break;\n     \
    \         }\n              case BI_JPEG:\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression:\
    \ BI_JPEG\");\n                break;\n              }\n              default:\n\
    \              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n  \
    \            }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Number of colors: %u\",bmp_info.number_colors);\n         \
    \ }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n\
    \        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size\
    \ > 40)\n          {\n            double\n              gamma;\n\n           \
    \ /*\n              Read color management information.\n            */\n     \
    \       bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n\
    \            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n\
    \            */\n#           define BMP_DENOM ((double) 0x40000000)\n        \
    \    bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n     \
    \       bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n  \
    \          bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n         \
    \     bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n\
    \            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n\
    \            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n     \
    \       image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n        \
    \    gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n\
    \            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n\
    \            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n\
    \            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n\
    \            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n        \
    \      bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n\
    \            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n\
    \            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n   \
    \         image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n    \
    \        /*\n              Decode 16^16 fixed point formatted gamma_scales.\n\
    \            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n\
    \            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n\
    \              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n     \
    \     (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n\n     \
    \   if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\
    \n            /*\n              Read BMP Version 5 color management information.\n\
    \            */\n            intent=ReadBlobLSBLong(image);\n            switch\
    \ ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n       \
    \       {\n                image->rendering_intent=SaturationIntent;\n       \
    \         break;\n              }\n              case LCS_GM_GRAPHICS:\n     \
    \         {\n                image->rendering_intent=RelativeIntent;\n       \
    \         break;\n              }\n              case LCS_GM_IMAGES:\n       \
    \       {\n                image->rendering_intent=PerceptualIntent;\n       \
    \         break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n\
    \              {\n                image->rendering_intent=AbsoluteIntent;\n  \
    \              break;\n              }\n            }\n            (void) ReadBlobLSBLong(image);\
    \  /* Profile data */\n            (void) ReadBlobLSBLong(image);  /* Profile\
    \ size */\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n \
    \         }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n\
    \      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n\
    \        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n\
    \      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n       \
    \ (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"\
    LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width\
    \ <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\"\
    );\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"\
    NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"\
    StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) &&\
    \ (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) &&\
    \ (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24)\
    \ && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"\
    UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n      \
    \  bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"\
    UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel\
    \ != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\"\
    );\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n \
    \     ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n\
    \    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n    \
    \  ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n   \
    \ switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n\
    \        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n\
    \        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n\
    \        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n    \
    \  case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\"\
    );\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\"\
    );\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n\
    \    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel\
    \ <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->matte=((bmp_info.alpha_mask\
    \ != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;\n\
    \    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\
    \n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n\
    \        one=1;\n        if (image->colors == 0)\n          image->colors=one\
    \ << bmp_info.bits_per_pixel;\n      }\n    image->x_resolution=(double) bmp_info.x_pixels/100.0;\n\
    \    image->y_resolution=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n\
    \    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n\
    \      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n\
    \    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    if (image->storage_class\
    \ == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n\
    \        size_t\n          packet_size;\n\n        /*\n          Read BMP raster\
    \ colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap\
    \ of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors)\
    \ == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n   \
    \       image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned\
    \ char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n\
    \        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n\
    \        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char\
    \ *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n\
    \        if (count != (ssize_t) (packet_size*image->colors))\n          {\n  \
    \          bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\"\
    );\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors;\
    \ i++)\n        {\n          image->colormap[i].blue=ScaleCharToQuantum(*p++);\n\
    \          image->colormap[i].green=ScaleCharToQuantum(*p++);\n          image->colormap[i].red=ScaleCharToQuantum(*p++);\n\
    \          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned\
    \ char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image\
    \ data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n\
    \    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n\
    \    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t)\
    \ bytes_per_line*image->rows;\n    if (((MagickSizeType) length/8) > GetBlobSize(image))\n\
    \      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\"\
    );\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression\
    \ == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n\
    \          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info ==\
    \ (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     \
    \   if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n\
    \        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\"\
    );\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length\
    \ encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n\
    \          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info ==\
    \ (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     \
    \   status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n\
    \        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\"\
    );\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n\
    \    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n      \
    \    We should ignore the alpha value in BMP3 files but there have been\n    \
    \      reports about 32 bit files with alpha. We do a quick check to see if\n\
    \          the alpha channel contains a value that is not zero (default value).\n\
    \          If we find a non zero value we asume the program that wrote the file\n\
    \          wants to use the alpha channel.\n        */\n        if ((image->matte\
    \ == MagickFalse) && (bmp_info.size == 40) &&\n            (bmp_info.bits_per_pixel\
    \ == 32))\n          {\n            bytes_per_line=4*(image->columns);\n     \
    \       for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n        \
    \      p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x <\
    \ (ssize_t) image->columns; x++)\n              {\n                if (*(p+3)\
    \ != 0)\n                  {\n                    image->matte=MagickTrue;\n \
    \                   y=-1;\n                    break;\n                  }\n \
    \               p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->matte\
    \ != MagickFalse ? 0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n\
    \        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n\
    \        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n   \
    \           RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n\
    \            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n\
    \          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void)\
    \ memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel\
    \ == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register size_t\n\
    \          sample;\n\n        /*\n          Get shift and quantum bits info from\
    \ bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n         \
    \ while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n\
    \            shift.red++;\n            if (shift.red > 32U)\n              break;\n\
    \          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask\
    \ << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n\
    \            if (shift.green > 32U)\n              break;\n          }\n     \
    \   if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue)\
    \ & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if\
    \ (shift.blue > 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask\
    \ != 0)\n          while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL)\
    \ == 0)\n          {\n            shift.opacity++;\n            if (shift.opacity\
    \ > 32U)\n              break;\n          }\n        sample=shift.red;\n     \
    \   while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n \
    \         sample++;\n          if (sample > 32U)\n            break;\n       \
    \ }\n        quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n\
    \        sample=shift.green;\n        while (((bmp_info.green_mask << sample)\
    \ & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample\
    \ > 32U)\n            break;\n        }\n        quantum_bits.green=ClampToQuantum((MagickRealType)\
    \ sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask\
    \ << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n         \
    \ if (sample > 32U)\n            break;\n        }\n        quantum_bits.blue=ClampToQuantum((MagickRealType)\
    \ sample-shift.blue);\n        sample=shift.opacity;\n        while (((bmp_info.alpha_mask\
    \ << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n         \
    \ if (sample > 32U)\n            break;\n        }\n        quantum_bits.opacity=ClampToQuantum((MagickRealType)\
    \ sample-\n          shift.opacity);\n      }\n    switch (bmp_info.bits_per_pixel)\n\
    \    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n\
    \        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n\
    \          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n  \
    \          for (bit=0; bit < 8; bit++)\n            {\n              index=(IndexPacket)\
    \ (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n\
    \              q++;\n            }\n            p++;\n          }\n          if\
    \ ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit <\
    \ (image->columns % 8); bit++)\n              {\n                index=(IndexPacket)\
    \ (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n\
    \              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          if (image->previous == (Image\
    \ *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 4:\n      {\n        /*\n          Convert\
    \ PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y\
    \ >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n  \
    \          (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),\n \
    \             &index,exception);\n            SetPixelIndex(indexes+x,index);\n\
    \            (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,\n\
    \              exception);\n            SetPixelIndex(indexes+x+1,index);\n  \
    \          p++;\n          }\n          if ((image->columns % 2) != 0)\n     \
    \       {\n              (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4)\
    \ & 0xf),\n                &index,exception);\n              SetPixelIndex(indexes+(x++),index);\n\
    \              p++;\n            }\n          if (x < (ssize_t) image->columns)\n\
    \            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n\
    \            break;\n          if (image->previous == (Image *) NULL)\n      \
    \      {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 8:\n      {\n        /*\n          Convert\
    \ PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8)\
    \ ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n\
    \        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n      \
    \      (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);\n   \
    \         SetPixelIndex(indexes,index);\n            indexes++;\n            p++;\n\
    \            q++;\n          }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n          \
    \      (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 16:\n      {\n        unsigned int\n    \
    \      alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded\
    \ 16-bit PseudoColor scanline.\n        */\n        if (bmp_info.compression !=\
    \ BI_RGB &&\n            bmp_info.compression != BI_BITFIELDS)\n          {\n\
    \            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n\
    \              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns\
    \ % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1;\
    \ y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned\
    \ int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask)\
    \ << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n             \
    \ red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n      \
    \        red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask)\
    \ << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n         \
    \     green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n\
    \              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green\
    \ <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel\
    \ & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue\
    \ == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue\
    \ <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned\
    \ short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\
    \ green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n\
    \            SetPixelOpacity(q,OpaqueOpacity);\n            if (image->matte !=\
    \ MagickFalse)\n              {\n                alpha=((pixel & bmp_info.alpha_mask)\
    \ << shift.opacity) >> 16;\n                if (quantum_bits.opacity <= 8)\n \
    \                 alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned\
    \ short) alpha));\n              }\n            q++;\n          }\n          if\
    \ (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n\
    \          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous\
    \ == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n\
    \        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for\
    \ (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n\
    \            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n\
    \            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n\
    \          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        \
    \    break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n        \
    \  if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor\
    \ scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n   \
    \         (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\"\
    );\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t)\
    \ image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n           \
    \ alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned\
    \ int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned\
    \ int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n       \
    \     red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red\
    \ == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask)\
    \ << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n         \
    \     green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) <<\
    \ shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue\
    \ >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n\
    \            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n \
    \           SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n    \
    \        SetPixelAlpha(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n\
    \              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.opacity)\
    \ >> 16;\n                if (quantum_bits.opacity == 8)\n                  alpha|=(alpha\
    \ >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)\
    \ alpha));\n              }\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n          \
    \      (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  \
    \    }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y\
    \ > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n      \
    \  ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n \
    \         image->filename);\n        break;\n      }\n    if (bmp_info.height\
    \ < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n    \
    \      Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n\
    \        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n\
    \            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n\
    \          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes\
    \ != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n\
    \        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n\
    \        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if\
    \ ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n  \
    \        Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image);\n\
    \        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n     \
    \       status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n\
    \        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      \
    \    GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n\
    \      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n\
    \  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n\
    }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\nstatic Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo\
    \ *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  IndexPacket\n\
    \    index;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n\
    \    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n\
    \    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n\
    \    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n\
    \    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n\
    \    *pixels;\n\n  unsigned int\n    blue,\n    green,\n    offset_bits,\n   \
    \ red;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo\
    \ *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug\
    \ != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\"\
    ,\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n\
    \  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n\
    \  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status\
    \ == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image\
    \ *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n\
    \  bmp_info.ba_offset=0;\n  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n\
    \  if (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n  do\n  {\n    LongPixelPacket\n      shift;\n\n    PixelPacket\n      quantum_bits;\n\
    \n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset ==\
    \ 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n   \
    \ while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n\
    \      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n\
    \      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n\
    \    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    \  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char\
    \ *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\"\
    ,2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n\
    \n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \         \"  File_size in header:  %u bytes\",bmp_info.file_size);\n\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n\
    \    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n\
    \      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n\
    \        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n\
    \          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"\
    BMP2\",MaxTextExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n\
    \        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n      \
    \  bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n\
    \        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n\
    \        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n      \
    \  bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n        \
    \  {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \
    \        \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n\
    \              bmp_info.height);\n          }\n      }\n    else\n      {\n  \
    \      /*\n          Microsoft Windows BMP image file.\n        */\n        if\
    \ (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\"\
    );\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t)\
    \ ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n\
    \        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n\
    \        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n\
    \        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n\
    \        bmp_info.colors_important=ReadBlobLSBLong(image);\n        if (image->debug\
    \ != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n\
    \              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n\
    \            switch (bmp_info.compression)\n            {\n              case\
    \ BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_RGB\");\n                break;\n     \
    \         }\n              case BI_RLE4:\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression:\
    \ BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n\
    \              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_RLE8\");\n                break;\n    \
    \          }\n              case BI_BITFIELDS:\n              {\n            \
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"\
    \  Compression: BI_BITFIELDS\");\n                break;\n              }\n  \
    \            case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_PNG\");\n                break;\n     \
    \         }\n              case BI_JPEG:\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression:\
    \ BI_JPEG\");\n                break;\n              }\n              default:\n\
    \              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n  \
    \            }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Number of colors: %u\",bmp_info.number_colors);\n         \
    \ }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n\
    \        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size\
    \ > 40)\n          {\n            double\n              gamma;\n\n           \
    \ /*\n              Read color management information.\n            */\n     \
    \       bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n\
    \            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n\
    \            */\n#           define BMP_DENOM ((double) 0x40000000)\n        \
    \    bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n     \
    \       bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n  \
    \          bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n         \
    \     bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n\
    \            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n\
    \            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n     \
    \       image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n        \
    \    gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n\
    \            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n\
    \            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n\
    \            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n\
    \            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n        \
    \      bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n\
    \            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n\
    \            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n   \
    \         image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n    \
    \        /*\n              Decode 16^16 fixed point formatted gamma_scales.\n\
    \            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n\
    \            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n\
    \              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n     \
    \     (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n\n     \
    \   if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\
    \n            /*\n              Read BMP Version 5 color management information.\n\
    \            */\n            intent=ReadBlobLSBLong(image);\n            switch\
    \ ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n       \
    \       {\n                image->rendering_intent=SaturationIntent;\n       \
    \         break;\n              }\n              case LCS_GM_GRAPHICS:\n     \
    \         {\n                image->rendering_intent=RelativeIntent;\n       \
    \         break;\n              }\n              case LCS_GM_IMAGES:\n       \
    \       {\n                image->rendering_intent=PerceptualIntent;\n       \
    \         break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n\
    \              {\n                image->rendering_intent=AbsoluteIntent;\n  \
    \              break;\n              }\n            }\n            (void) ReadBlobLSBLong(image);\
    \  /* Profile data */\n            (void) ReadBlobLSBLong(image);  /* Profile\
    \ size */\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n \
    \         }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n\
    \      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n\
    \        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n\
    \      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n       \
    \ (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"\
    LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width\
    \ <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\"\
    );\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"\
    NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"\
    StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) &&\
    \ (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) &&\
    \ (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24)\
    \ && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"\
    UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n      \
    \  bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"\
    UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel\
    \ != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\"\
    );\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n \
    \     ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n\
    \    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n    \
    \  ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n   \
    \ switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n\
    \        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n\
    \        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n\
    \        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n    \
    \  case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\"\
    );\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\"\
    );\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n\
    \    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel\
    \ <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->matte=((bmp_info.alpha_mask\
    \ != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;\n\
    \    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\
    \n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n\
    \        one=1;\n        if (image->colors == 0)\n          image->colors=one\
    \ << bmp_info.bits_per_pixel;\n      }\n    image->x_resolution=(double) bmp_info.x_pixels/100.0;\n\
    \    image->y_resolution=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n\
    \    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n\
    \      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n\
    \    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    if (image->storage_class\
    \ == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n\
    \        size_t\n          packet_size;\n\n        /*\n          Read BMP raster\
    \ colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap\
    \ of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors)\
    \ == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n   \
    \       image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned\
    \ char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n\
    \        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n\
    \        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char\
    \ *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n\
    \        if (count != (ssize_t) (packet_size*image->colors))\n          {\n  \
    \          bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\"\
    );\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors;\
    \ i++)\n        {\n          image->colormap[i].blue=ScaleCharToQuantum(*p++);\n\
    \          image->colormap[i].green=ScaleCharToQuantum(*p++);\n          image->colormap[i].red=ScaleCharToQuantum(*p++);\n\
    \          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned\
    \ char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image\
    \ data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n\
    \    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n\
    \    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t)\
    \ bytes_per_line*image->rows;\n    if (((MagickSizeType) length/8) > GetBlobSize(image))\n\
    \      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\"\
    );\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression\
    \ == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n\
    \          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info ==\
    \ (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     \
    \   if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n\
    \        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\"\
    );\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length\
    \ encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n\
    \          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info ==\
    \ (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     \
    \   status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n\
    \        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\"\
    );\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n\
    \    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n      \
    \    We should ignore the alpha value in BMP3 files but there have been\n    \
    \      reports about 32 bit files with alpha. We do a quick check to see if\n\
    \          the alpha channel contains a value that is not zero (default value).\n\
    \          If we find a non zero value we asume the program that wrote the file\n\
    \          wants to use the alpha channel.\n        */\n        if ((image->matte\
    \ == MagickFalse) && (bmp_info.size == 40) &&\n            (bmp_info.bits_per_pixel\
    \ == 32))\n          {\n            bytes_per_line=4*(image->columns);\n     \
    \       for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n        \
    \      p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x <\
    \ (ssize_t) image->columns; x++)\n              {\n                if (*(p+3)\
    \ != 0)\n                  {\n                    image->matte=MagickTrue;\n \
    \                   y=-1;\n                    break;\n                  }\n \
    \               p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->matte\
    \ != MagickFalse ? 0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n\
    \        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n\
    \        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n   \
    \           RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n\
    \            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n\
    \          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void)\
    \ memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel\
    \ == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register size_t\n\
    \          sample;\n\n        /*\n          Get shift and quantum bits info from\
    \ bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n         \
    \ while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n\
    \            shift.red++;\n            if (shift.red > 32U)\n              break;\n\
    \          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask\
    \ << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n\
    \            if (shift.green > 32U)\n              break;\n          }\n     \
    \   if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue)\
    \ & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if\
    \ (shift.blue > 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask\
    \ != 0)\n          while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL)\
    \ == 0)\n          {\n            shift.opacity++;\n            if (shift.opacity\
    \ > 32U)\n              break;\n          }\n        sample=shift.red;\n     \
    \   while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n \
    \         sample++;\n          if (sample > 32U)\n            break;\n       \
    \ }\n        quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n\
    \        sample=shift.green;\n        while (((bmp_info.green_mask << sample)\
    \ & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample\
    \ > 32U)\n            break;\n        }\n        quantum_bits.green=ClampToQuantum((MagickRealType)\
    \ sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask\
    \ << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n         \
    \ if (sample > 32U)\n            break;\n        }\n        quantum_bits.blue=ClampToQuantum((MagickRealType)\
    \ sample-shift.blue);\n        sample=shift.opacity;\n        while (((bmp_info.alpha_mask\
    \ << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n         \
    \ if (sample > 32U)\n            break;\n        }\n        quantum_bits.opacity=ClampToQuantum((MagickRealType)\
    \ sample-\n          shift.opacity);\n      }\n    switch (bmp_info.bits_per_pixel)\n\
    \    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n\
    \        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n\
    \          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n  \
    \          for (bit=0; bit < 8; bit++)\n            {\n              index=(IndexPacket)\
    \ (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n\
    \              q++;\n            }\n            p++;\n          }\n          if\
    \ ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit <\
    \ (image->columns % 8); bit++)\n              {\n                index=(IndexPacket)\
    \ (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n\
    \              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          if (image->previous == (Image\
    \ *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 4:\n      {\n        /*\n          Convert\
    \ PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y\
    \ >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n  \
    \          (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),\n \
    \             &index,exception);\n            SetPixelIndex(indexes+x,index);\n\
    \            (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,\n\
    \              exception);\n            SetPixelIndex(indexes+x+1,index);\n  \
    \          p++;\n          }\n          if ((image->columns % 2) != 0)\n     \
    \       {\n              (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4)\
    \ & 0xf),\n                &index,exception);\n              SetPixelIndex(indexes+(x++),index);\n\
    \              p++;\n            }\n          if (x < (ssize_t) image->columns)\n\
    \            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n\
    \            break;\n          if (image->previous == (Image *) NULL)\n      \
    \      {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 8:\n      {\n        /*\n          Convert\
    \ PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8)\
    \ ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n\
    \        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n      \
    \      (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);\n   \
    \         SetPixelIndex(indexes,index);\n            indexes++;\n            p++;\n\
    \            q++;\n          }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n          \
    \      (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 16:\n      {\n        unsigned int\n    \
    \      alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded\
    \ 16-bit PseudoColor scanline.\n        */\n        if (bmp_info.compression !=\
    \ BI_RGB &&\n            bmp_info.compression != BI_BITFIELDS)\n          {\n\
    \            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n\
    \              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns\
    \ % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1;\
    \ y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned\
    \ int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask)\
    \ << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n             \
    \ red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n      \
    \        red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask)\
    \ << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n         \
    \     green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n\
    \              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green\
    \ <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel\
    \ & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue\
    \ == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue\
    \ <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned\
    \ short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\
    \ green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n\
    \            SetPixelOpacity(q,OpaqueOpacity);\n            if (image->matte !=\
    \ MagickFalse)\n              {\n                alpha=((pixel & bmp_info.alpha_mask)\
    \ << shift.opacity) >> 16;\n                if (quantum_bits.opacity <= 8)\n \
    \                 alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned\
    \ short) alpha));\n              }\n            q++;\n          }\n          if\
    \ (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n\
    \          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous\
    \ == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n\
    \        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for\
    \ (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n\
    \            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n\
    \            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n\
    \          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        \
    \    break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n        \
    \  if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor\
    \ scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n   \
    \         (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\"\
    );\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t)\
    \ image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n           \
    \ alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned\
    \ int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned\
    \ int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n       \
    \     red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red\
    \ == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask)\
    \ << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n         \
    \     green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) <<\
    \ shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue\
    \ >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n\
    \            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n \
    \           SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n    \
    \        SetPixelAlpha(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n\
    \              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.opacity)\
    \ >> 16;\n                if (quantum_bits.opacity == 8)\n                  alpha|=(alpha\
    \ >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)\
    \ alpha));\n              }\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n          \
    \      (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  \
    \    }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y\
    \ > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n      \
    \  ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n \
    \         image->filename);\n        break;\n      }\n    if (bmp_info.height\
    \ < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n    \
    \      Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n\
    \        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n\
    \            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n\
    \          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes\
    \ != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n\
    \        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n\
    \        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if\
    \ ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n  \
    \        Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image);\n\
    \        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n     \
    \       status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n\
    \        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      \
    \    GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n\
    \      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n\
    \  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n\
    }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\nstatic Image *ReadBMPImage(const ImageInfo\
    \ *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n\
    \    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\
    \n  MagickOffsetType\n    offset,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\
    \n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n\
    \  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n \
    \ size_t\n    bit,\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count,\n\
    \    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  unsigned int\n\
    \    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n    Open image file.\n\
    \  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature\
    \ == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void)\
    \ LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n\
    \  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature\
    \ == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n\
    \  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n\
    \  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n  if\
    \ (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n  do\n  {\n    LongPixelPacket\n      shift;\n\n    PixelPacket\n      quantum_bits;\n\
    \n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset ==\
    \ 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n   \
    \ while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n\
    \      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n\
    \      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n\
    \    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    \  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char\
    \ *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\"\
    ,2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n\
    \n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \         \"  File_size in header:  %u bytes\",bmp_info.file_size);\n\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n\
    \    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n\
    \      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n\
    \        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n\
    \          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"\
    BMP2\",MaxTextExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n\
    \        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n      \
    \  bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n\
    \        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n\
    \        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n      \
    \  bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n        \
    \  {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \
    \        \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n\
    \              bmp_info.height);\n          }\n      }\n    else\n      {\n  \
    \      /*\n          Microsoft Windows BMP image file.\n        */\n        if\
    \ (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\"\
    );\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t)\
    \ ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n\
    \        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n\
    \        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n\
    \        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n\
    \        bmp_info.colors_important=ReadBlobLSBLong(image);\n        if (image->debug\
    \ != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n\
    \              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n\
    \            switch (bmp_info.compression)\n            {\n              case\
    \ BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_RGB\");\n                break;\n     \
    \         }\n              case BI_RLE4:\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression:\
    \ BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n\
    \              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_RLE8\");\n                break;\n    \
    \          }\n              case BI_BITFIELDS:\n              {\n            \
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"\
    \  Compression: BI_BITFIELDS\");\n                break;\n              }\n  \
    \            case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: BI_PNG\");\n                break;\n     \
    \         }\n              case BI_JPEG:\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression:\
    \ BI_JPEG\");\n                break;\n              }\n              default:\n\
    \              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n  \
    \            }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \              \"  Number of colors: %u\",bmp_info.number_colors);\n         \
    \ }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n\
    \        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size\
    \ > 40)\n          {\n            double\n              gamma;\n\n           \
    \ /*\n              Read color management information.\n            */\n     \
    \       bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n\
    \            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n\
    \            */\n#           define BMP_DENOM ((double) 0x40000000)\n        \
    \    bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n     \
    \       bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n  \
    \          bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\
    \n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n         \
    \     bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n\
    \            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n\
    \            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n     \
    \       image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n        \
    \    gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n\
    \            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n\
    \            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n\
    \            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n\
    \            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n        \
    \      bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n\
    \            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n\
    \            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n   \
    \         image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n    \
    \        /*\n              Decode 16^16 fixed point formatted gamma_scales.\n\
    \            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n\
    \            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n\
    \            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n\
    \              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n     \
    \     (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n\n     \
    \   if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\
    \n            /*\n              Read BMP Version 5 color management information.\n\
    \            */\n            intent=ReadBlobLSBLong(image);\n            switch\
    \ ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n       \
    \       {\n                image->rendering_intent=SaturationIntent;\n       \
    \         break;\n              }\n              case LCS_GM_GRAPHICS:\n     \
    \         {\n                image->rendering_intent=RelativeIntent;\n       \
    \         break;\n              }\n              case LCS_GM_IMAGES:\n       \
    \       {\n                image->rendering_intent=PerceptualIntent;\n       \
    \         break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n\
    \              {\n                image->rendering_intent=AbsoluteIntent;\n  \
    \              break;\n              }\n            }\n            (void) ReadBlobLSBLong(image);\
    \  /* Profile data */\n            (void) ReadBlobLSBLong(image);  /* Profile\
    \ size */\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n \
    \         }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n\
    \      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n\
    \        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n\
    \      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n       \
    \ (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"\
    LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width\
    \ <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\"\
    );\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"\
    NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"\
    StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) &&\
    \ (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) &&\
    \ (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24)\
    \ && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"\
    UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n      \
    \  bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"\
    UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel\
    \ != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\"\
    );\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n \
    \     ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n\
    \    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n    \
    \  ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n   \
    \ switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n\
    \        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n\
    \        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n\
    \        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n    \
    \  case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\"\
    );\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\"\
    );\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n\
    \    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel\
    \ <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->matte=((bmp_info.alpha_mask\
    \ != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;\n\
    \    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\
    \n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n\
    \        one=1;\n        if (image->colors == 0)\n          image->colors=one\
    \ << bmp_info.bits_per_pixel;\n      }\n    image->x_resolution=(double) bmp_info.x_pixels/100.0;\n\
    \    image->y_resolution=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n\
    \    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n\
    \      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n\
    \    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    if (image->storage_class\
    \ == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n\
    \        size_t\n          packet_size;\n\n        /*\n          Read BMP raster\
    \ colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap\
    \ of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors)\
    \ == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n   \
    \       image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned\
    \ char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n\
    \        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n\
    \        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char\
    \ *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n\
    \        if (count != (ssize_t) (packet_size*image->colors))\n          {\n  \
    \          bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\"\
    );\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors;\
    \ i++)\n        {\n          image->colormap[i].blue=ScaleCharToQuantum(*p++);\n\
    \          image->colormap[i].green=ScaleCharToQuantum(*p++);\n          image->colormap[i].red=ScaleCharToQuantum(*p++);\n\
    \          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned\
    \ char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image\
    \ data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n\
    \    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n\
    \    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t)\
    \ bytes_per_line*image->rows;\n    if (((MagickSizeType) length/8) > GetBlobSize(image))\n\
    \      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\"\
    );\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression\
    \ == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n\
    \          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info ==\
    \ (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     \
    \   if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n\
    \        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\"\
    );\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length\
    \ encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n\
    \          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info ==\
    \ (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     \
    \   status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n\
    \        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\"\
    );\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n\
    \    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n      \
    \    We should ignore the alpha value in BMP3 files but there have been\n    \
    \      reports about 32 bit files with alpha. We do a quick check to see if\n\
    \          the alpha channel contains a value that is not zero (default value).\n\
    \          If we find a non zero value we asume the program that wrote the file\n\
    \          wants to use the alpha channel.\n        */\n        if ((image->matte\
    \ == MagickFalse) && (bmp_info.size == 40) &&\n            (bmp_info.bits_per_pixel\
    \ == 32))\n          {\n            bytes_per_line=4*(image->columns);\n     \
    \       for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n        \
    \      p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x <\
    \ (ssize_t) image->columns; x++)\n              {\n                if (*(p+3)\
    \ != 0)\n                  {\n                    image->matte=MagickTrue;\n \
    \                   y=-1;\n                    break;\n                  }\n \
    \               p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->matte\
    \ != MagickFalse ? 0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n\
    \        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n\
    \        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n   \
    \           RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n\
    \            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n\
    \          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void)\
    \ memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel\
    \ == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register size_t\n\
    \          sample;\n\n        /*\n          Get shift and quantum bits info from\
    \ bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n         \
    \ while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n\
    \            shift.red++;\n            if (shift.red > 32U)\n              break;\n\
    \          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask\
    \ << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n\
    \            if (shift.green > 32U)\n              break;\n          }\n     \
    \   if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue)\
    \ & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if\
    \ (shift.blue > 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask\
    \ != 0)\n          while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL)\
    \ == 0)\n          {\n            shift.opacity++;\n            if (shift.opacity\
    \ > 32U)\n              break;\n          }\n        sample=shift.red;\n     \
    \   while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n \
    \         sample++;\n          if (sample > 32U)\n            break;\n       \
    \ }\n        quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n\
    \        sample=shift.green;\n        while (((bmp_info.green_mask << sample)\
    \ & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample\
    \ > 32U)\n            break;\n        }\n        quantum_bits.green=ClampToQuantum((MagickRealType)\
    \ sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask\
    \ << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n         \
    \ if (sample > 32U)\n            break;\n        }\n        quantum_bits.blue=ClampToQuantum((MagickRealType)\
    \ sample-shift.blue);\n        sample=shift.opacity;\n        while (((bmp_info.alpha_mask\
    \ << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n         \
    \ if (sample > 32U)\n            break;\n        }\n        quantum_bits.opacity=ClampToQuantum((MagickRealType)\
    \ sample-\n          shift.opacity);\n      }\n    switch (bmp_info.bits_per_pixel)\n\
    \    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n\
    \        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n\
    \          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n  \
    \          for (bit=0; bit < 8; bit++)\n            {\n              index=(IndexPacket)\
    \ (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n\
    \              q++;\n            }\n            p++;\n          }\n          if\
    \ ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit <\
    \ (image->columns % 8); bit++)\n              {\n                index=(IndexPacket)\
    \ (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n\
    \              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          if (image->previous == (Image\
    \ *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 4:\n      {\n        /*\n          Convert\
    \ PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y\
    \ >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n  \
    \          (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),\n \
    \             &index,exception);\n            SetPixelIndex(indexes+x,index);\n\
    \            (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,\n\
    \              exception);\n            SetPixelIndex(indexes+x+1,index);\n  \
    \          p++;\n          }\n          if ((image->columns % 2) != 0)\n     \
    \       {\n              (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4)\
    \ & 0xf),\n                &index,exception);\n              SetPixelIndex(indexes+(x++),index);\n\
    \              p++;\n            }\n          if (x < (ssize_t) image->columns)\n\
    \            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n\
    \            break;\n          if (image->previous == (Image *) NULL)\n      \
    \      {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 8:\n      {\n        /*\n          Convert\
    \ PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8)\
    \ ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n\
    \        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n      \
    \      (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);\n   \
    \         SetPixelIndex(indexes,index);\n            indexes++;\n            p++;\n\
    \            q++;\n          }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n          \
    \      (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        (void) SyncImage(image);\n\
    \        break;\n      }\n      case 16:\n      {\n        unsigned int\n    \
    \      alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded\
    \ 16-bit PseudoColor scanline.\n        */\n        if (bmp_info.compression !=\
    \ BI_RGB &&\n            bmp_info.compression != BI_BITFIELDS)\n          {\n\
    \            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n\
    \              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns\
    \ % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1;\
    \ y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned\
    \ int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask)\
    \ << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n             \
    \ red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n      \
    \        red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask)\
    \ << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n         \
    \     green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n\
    \              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green\
    \ <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel\
    \ & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue\
    \ == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue\
    \ <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned\
    \ short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\
    \ green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n\
    \            SetPixelOpacity(q,OpaqueOpacity);\n            if (image->matte !=\
    \ MagickFalse)\n              {\n                alpha=((pixel & bmp_info.alpha_mask)\
    \ << shift.opacity) >> 16;\n                if (quantum_bits.opacity <= 8)\n \
    \                 alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned\
    \ short) alpha));\n              }\n            q++;\n          }\n          if\
    \ (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n\
    \          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous\
    \ == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n\
    \        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for\
    \ (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n\
    \            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n\
    \            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n\
    \          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        \
    \    break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n        \
    \  if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n\
    \                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor\
    \ scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n   \
    \         (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\"\
    );\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t)\
    \ image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n           \
    \ alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0;\
    \ x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned\
    \ int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned\
    \ int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n       \
    \     red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red\
    \ == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask)\
    \ << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n         \
    \     green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) <<\
    \ shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue\
    \ >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n\
    \            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n \
    \           SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n    \
    \        SetPixelAlpha(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n\
    \              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.opacity)\
    \ >> 16;\n                if (quantum_bits.opacity == 8)\n                  alpha|=(alpha\
    \ >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)\
    \ alpha));\n              }\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n          \
    \      (image->rows-y),image->rows);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        break;\n      }\n \
    \     default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  \
    \    }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y\
    \ > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n      \
    \  ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n \
    \         image->filename);\n        break;\n      }\n    if (bmp_info.height\
    \ < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n    \
    \      Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n\
    \        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n\
    \            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n\
    \          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes\
    \ != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n\
    \        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n\
    \        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if\
    \ ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n  \
    \        Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image);\n\
    \        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n     \
    \       status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n\
    \        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      \
    \    GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n\
    \      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n\
    \  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n\
    }"
  verbose: true
environment:
  env_type: judge
  id_save: 439114
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
