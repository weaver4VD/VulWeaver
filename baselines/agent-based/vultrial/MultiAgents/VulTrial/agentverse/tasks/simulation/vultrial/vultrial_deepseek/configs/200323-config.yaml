agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nsuggest_trie_walk(\n\
    \    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n\
    {\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\t\
    stack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\
    \t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and\
    \ split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when\
    \ coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound\
    \ flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\
    \tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n\
    \    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n\
    \    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n \
    \   fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    //\
    \ extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n\
    \    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n  \
    \  // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n\
    #endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\t\
    time_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold\
    \ tree, try changes at each node.\n    // \"tword[]\" contains the word collected\
    \ from nodes in the tree.\n    // \"fword[]\" the word we are trying to match\
    \ with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n\
    \    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t\
    // Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs\
    \ = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t//\
    \ When there are postponed prefixes we need to use these first.  At\n\t// the\
    \ end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\
    \tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\
    \tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth\
    \ = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix\
    \ first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n\
    \    // The loop may take an indefinite amount of time. Break out after some\n\
    \    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout,\
    \ &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round\
    \ we either:\n    // - For the current state try one operation, advance \"ts_curi\"\
    ,\n    //   increase \"depth\".\n    // - When a state is done go to the next,\
    \ set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n\
    \    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\
    \t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal\
    \ with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx =\
    \ sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\
    \t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current\
    \ byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip\
    \ over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx\
    \ + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL\
    \ bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end\
    \ of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\
    \tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\
    \t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t\
    \    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\
    \t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\t\
    n = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr\
    \ + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\
    \t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth],\
    \ \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\
    \t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t   \
    \ byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t   \
    \ // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word()\
    \ works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword\
    \ + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t \
    \   sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\
    \t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\
    \t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\
    \t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t\
    // eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words\
    \ with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t\
    \    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t \
    \      ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword\
    \ + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth\
    \ <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\
    \t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check\
    \ that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length\
    \ of the NULs in the prefix.  If there are\n\t\t// none this must be the first\
    \ try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen\
    \ = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\
    \t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t  \
    \     tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\
    \n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\
    \t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and\
    \ compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember\
    \ that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound\
    \ flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check\
    \ NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending\
    \ another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit &&\
    \ fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends =\
    \ FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok\
    \ = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\
    \t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t\
    \    // change in this word (it was correct) add the first word\n\t\t    // as\
    \ a suggestion.  If this word was corrected too, we\n\t\t    // need to check\
    \ if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\
    \t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\
    \t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx)\
    \ == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore =\
    \ score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\
    \t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score\
    \ isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su,\
    \ &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t   \
    \ newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t\
    \    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this\
    \ word.  If this\n\t\t    // word does not support compounding then give up\n\t\
    \t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\
    \t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\
    \t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte\
    \ chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\
    \t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\
    \t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen]\
    \ = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\
    \t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\
    \t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN\
    \  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\
    \t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if\
    \ (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) !=\
    \ NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang,\
    \ p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not\
    \ allowed.  But it may still be\n\t\t\t    // possible if we add another (short)\
    \ word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to\
    \ last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t\
    \    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper\
    \ case in preword.\n\t    // If there is a word from a previous split, append.\n\
    \t    // For the soundfold tree don't change the case, simply append.\n\t    if\
    \ (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\
    \t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case\
    \ tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword\
    \ + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the\
    \ badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the\
    \ badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\
    \t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\
    \t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word\
    \ after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p,\
    \ curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\
    \t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\
    \t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t\
    // word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su,\
    \ preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen\
    \ == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\
    \t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog\
    \ == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try\
    \ compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore\
    \ = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\
    \tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region)\
    \ == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t   \
    \ newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\
    \t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\
    \t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if\
    \ (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\
    \t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n\
    #ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\
    \t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought\
    \ us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j\
    \ < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\
    \t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t   \
    \ // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su,\
    \ preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\
    \t    // Give a penalty when changing non-word char to word\n\t\t    // char,\
    \ e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword,\
    \ p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\
    \t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p,\
    \ curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give\
    \ a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\
    \t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\
    \t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score\
    \ isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su,\
    \ &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score,\
    \ 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\
    \t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    //\
    \ upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t\
    \    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword\
    \ + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\
    \t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\
    \t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\
    \t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t  \
    \  }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >=\
    \ sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\
    \t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\
    \t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\
    \t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for\
    \ \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a\
    \ split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx\
    \ - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here\
    \ in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the\
    \ word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting\
    \ a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\
    \t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the\
    \ next word is valid.\n\t\t// 2. The badword does end, but it was due to a change\
    \ (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//\
    \    following word is valid.\n\t\t// 3. The badword and the word in the tree\
    \ end.  It may still\n\t\t//    be possible to compound another (short) word.\n\
    \t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\
    \t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\
    \t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\
    \t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword\
    \ + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax\
    \ < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t\
    \  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags,\
    \ ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen]\
    \ = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\
    \t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t\
    // valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound\
    \ = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\
    \t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to\
    \ avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\
    \t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\
    \t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same\
    \ NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t \
    \   sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t\
    {\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\
    \t\t// If we're going to split need to check that the\n\t\t\t// words so far are\
    \ valid for compounding.  If there\n\t\t\t// is only one word it must not have\
    \ the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\
    \t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\
    \t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\
    \t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\
    \t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\
    \t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\
    \n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang,\
    \ newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\
    \t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack,\
    \ depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\
    \t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen,\
    \ tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth],\
    \ \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\
    #endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags\
    \ = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\
    \n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword\
    \ when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword,\
    \ \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff\
    \ = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the\
    \ badword has a non-word character at this\n\t\t\t// position skip it.  That means\
    \ replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\
    \t// character when the word ends.  But only when the\n\t\t\t// good word can\
    \ end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t\
    \       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\
    \t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\
    \t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t  \
    \  if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\
    \t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx,\
    \ l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\
    \t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\
    \t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound\
    \ flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t\
    // may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\
    \t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\
    \t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx,\
    \ su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags\
    \ = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\
    \n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If\
    \ there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\
    \t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth\
    \ = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state\
    \ = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase\
    \ STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound\
    \ word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking\
    \ for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\
    \n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs\
    \ = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes\
    \ in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx]\
    \ == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use\
    \ STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\
    \tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\
    \t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes\
    \ at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\"\
    \ is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\
    \t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\
    \t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\t\
    else\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\t\
    arridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one\
    \ level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust\
    \ the score.  But don't even try\n\t\t// when the byte was already changed.  And\
    \ don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper\
    \ than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t||\
    \ (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\
    \t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    ||\
    \ (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\
    \t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth,\
    \ newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\
    \t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c\
    \ to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx],\
    \ c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\
    \t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n\
    #endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx]\
    \ != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t \
    \   sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\t\
    sp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte\
    \ characters are a bit complicated to\n\t\t\t// handle: They differ when any of\
    \ the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif\
    \ (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx\
    \ = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart\
    \ = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t\
    \       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\
    \t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad\
    \ word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\
    \t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff ==\
    \ DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\
    \t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\
    \t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\
    \t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST\
    \ to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\
    \t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t\
    \   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\
    \t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t\
    \  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score\
    \ from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\
    \t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\
    \    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\
    \t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t\
    \    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\
    \t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen\
    \ > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\
    \t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\
    \t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count\
    \ that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t\
    }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\
    \t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the\
    \ score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but\
    \ does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\
    \t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\
    \t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting\
    \ a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t\
    \    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the\
    \ score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's\
    \ slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\
    \t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\
    \t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t   \
    \ }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a\
    \ multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if\
    \ (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\
    \tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one\
    \ character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t \
    \   sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold\
    \ && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at\
    \ the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore\
    \ = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx]\
    \ != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\t\
    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character\
    \ we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags\
    \ |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance\
    \ over the character in fword[].  Give a bonus to the\n\t\t// score if the same\
    \ character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold\
    \ tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\
    \t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword\
    \ + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score\
    \ -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\
    \t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx\
    \ + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\t\
    break;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags\
    \ & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't\
    \ make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL\
    \ bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi\
    \ > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\
    \t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t   \
    \ break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found\
    \ a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state =\
    \ STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\
    \n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat\
    \ this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\
    \t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node,\
    \ go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\
    \t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    //\
    \ - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the\
    \ word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\
    \t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\
    \t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\
    \t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t \
    \   if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\
    \t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++]\
    \ = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl =\
    \ MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following\
    \ bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\
    \t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx\
    \ = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t \
    \   fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was\
    \ the same, thus doubling a\n\t\t    // character, give a bonus to the score.\
    \  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t\
    \    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen\
    \ - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\
    \t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"\
    12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards\
    \ at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t\
    \    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\t\
    PROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\
    \n\t    // Don't swap if the first character is not a word character.\n\t    //\
    \ SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p,\
    \ curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\
    \t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\
    \t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if\
    \ (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap\
    \ non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\
    \t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p\
    \ + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t \
    \   c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't\
    \ swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical,\
    \ swap won't do anything.\n\t    // Also get here if the second char is not a\
    \ word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su,\
    \ stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n\
    #ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\"\
    ,\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\
    \t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p,\
    \ p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t  \
    \  p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t  \
    \  }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t \
    \   break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\"\
    \ -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\
    \tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p\
    \ + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc\
    \ = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase\
    \ STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We\
    \ change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\
    \t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\
    \t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p\
    \ + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3\
    \ = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n\
    \ + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold\
    \ && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\
    \t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical:\
    \ \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP:\
    \ \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus\
    \ skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here\
    \ when the third character is not a word character.\n\t    // Second character\
    \ may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t\
    \    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack,\
    \ depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\
    \t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t \
    \   mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t\
    \    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] =\
    \ c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t \
    \   else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\
    \t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"\
    321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t   \
    \ {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p\
    \ + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\
    \tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2,\
    \ p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p\
    \ = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p,\
    \ curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate. \
    \ First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three\
    \ characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's\
    \ changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth,\
    \ SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\
    \t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate\
    \ left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0],\
    \ p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\
    \t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t  \
    \  n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p\
    \ + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n,\
    \ fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t\
    \    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\t\
    sp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\
    \t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t  \
    \  if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\
    \t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p +\
    \ tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc =\
    \ p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate\
    \ three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here,\
    \ it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack,\
    \ depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef\
    \ DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\
    \t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t   \
    \ c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p\
    \ + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t   \
    \ p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\
    \t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t  \
    \  if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\
    \t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p,\
    \ p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\t\
    c = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\
    \n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff\
    \ file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items\
    \ and we are not in the soundfold trie\n\t    // - the score is going to be too\
    \ high anyway\n\t    // - already applied a REP item or swapped here\n\t    if\
    \ ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP\
    \ >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\t\
    PROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\
    \n\t    // Use the first byte to quickly find the first entry that may\n\t   \
    \ // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi\
    \ = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi =\
    \ lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi <\
    \ 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\
    \t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\
    \t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items\
    \ from the .aff file.  For each match\n\t    // replace the characters and check\
    \ if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\
    \t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\
    \t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data\
    \ + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible\
    \ matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\
    \t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su,\
    \ stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n\
    #ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s\
    \ with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t \
    \   ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\
    \t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\
    \t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t   \
    \ fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t\
    \    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra\
    \ += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\
    \t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\
    \t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    //\
    \ Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\
    \t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\
    \t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\
    \t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if\
    \ (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\
    \t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\
    \t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all\
    \ possible states at this level, go up one level.\n\t    --depth;\n\n\t    if\
    \ (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t\
    // Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\
    \t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if\
    \ (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount\
    \ = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t\
    \  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t\
    \    }\n\t}\n    }\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\nsuggest_trie_walk(\n    suginfo_T\t\
    *su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\t\
    tword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n\
    \    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t \
    \     // concatenation of prefix compound\n\t\t\t\t      // words and split word.\
    \  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\
    \t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for\
    \ each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n \
    \   char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\
    \tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t\
    *gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n\
    \    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[]\
    \ from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n\
    \    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the\
    \ change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n \
    \   int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n\
    #endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree,\
    \ try changes at each node.\n    // \"tword[]\" contains the word collected from\
    \ nodes in the tree.\n    // \"fword[]\" the word we are trying to match with\
    \ (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n   \
    \ CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t//\
    \ Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs\
    \ = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t//\
    \ When there are postponed prefixes we need to use these first.  At\n\t// the\
    \ end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\
    \tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\
    \tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth\
    \ = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix\
    \ first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n\
    \    // The loop may take an indefinite amount of time. Break out after some\n\
    \    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout,\
    \ &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round\
    \ we either:\n    // - For the current state try one operation, advance \"ts_curi\"\
    ,\n    //   increase \"depth\".\n    // - When a state is done go to the next,\
    \ set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n\
    \    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\
    \t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal\
    \ with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx =\
    \ sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\
    \t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current\
    \ byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip\
    \ over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx\
    \ + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL\
    \ bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end\
    \ of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\
    \tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\
    \t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t\
    \    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\
    \t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\t\
    n = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr\
    \ + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\
    \t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth],\
    \ \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\
    \t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t   \
    \ byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t   \
    \ // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word()\
    \ works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword\
    \ + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t \
    \   sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\
    \t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\
    \t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\
    \t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t\
    // eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words\
    \ with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t\
    \    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t \
    \      ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword\
    \ + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth\
    \ <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\
    \t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check\
    \ that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length\
    \ of the NULs in the prefix.  If there are\n\t\t// none this must be the first\
    \ try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen\
    \ = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\
    \t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t  \
    \     tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\
    \n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\
    \t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and\
    \ compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember\
    \ that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound\
    \ flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check\
    \ NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending\
    \ another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit &&\
    \ fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends =\
    \ FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok\
    \ = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\
    \t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t\
    \    // change in this word (it was correct) add the first word\n\t\t    // as\
    \ a suggestion.  If this word was corrected too, we\n\t\t    // need to check\
    \ if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\
    \t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\
    \t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx)\
    \ == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore =\
    \ score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\
    \t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score\
    \ isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su,\
    \ &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t   \
    \ newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t\
    \    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this\
    \ word.  If this\n\t\t    // word does not support compounding then give up\n\t\
    \t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\
    \t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\
    \t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte\
    \ chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\
    \t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\
    \t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen]\
    \ = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\
    \t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\
    \t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN\
    \  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\
    \t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if\
    \ (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) !=\
    \ NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang,\
    \ p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not\
    \ allowed.  But it may still be\n\t\t\t    // possible if we add another (short)\
    \ word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to\
    \ last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t\
    \    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper\
    \ case in preword.\n\t    // If there is a word from a previous split, append.\n\
    \t    // For the soundfold tree don't change the case, simply append.\n\t    if\
    \ (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\
    \t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case\
    \ tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword\
    \ + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the\
    \ badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the\
    \ badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\
    \t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\
    \t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word\
    \ after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p,\
    \ curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\
    \t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\
    \t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t\
    // word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su,\
    \ preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen\
    \ == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\
    \t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog\
    \ == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try\
    \ compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore\
    \ = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\
    \tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region)\
    \ == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t   \
    \ newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\
    \t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\
    \t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if\
    \ (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\
    \t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n\
    #ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\
    \t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought\
    \ us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j\
    \ < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\
    \t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t   \
    \ // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su,\
    \ preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\
    \t    // Give a penalty when changing non-word char to word\n\t\t    // char,\
    \ e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword,\
    \ p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\
    \t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p,\
    \ curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give\
    \ a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\
    \t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\
    \t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score\
    \ isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su,\
    \ &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score,\
    \ 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\
    \t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    //\
    \ upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t\
    \    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword\
    \ + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\
    \t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\
    \t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\
    \t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t  \
    \  }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >=\
    \ sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\
    \t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\
    \t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\
    \t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for\
    \ \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a\
    \ split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx\
    \ - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here\
    \ in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the\
    \ word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting\
    \ a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\
    \t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the\
    \ next word is valid.\n\t\t// 2. The badword does end, but it was due to a change\
    \ (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//\
    \    following word is valid.\n\t\t// 3. The badword and the word in the tree\
    \ end.  It may still\n\t\t//    be possible to compound another (short) word.\n\
    \t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\
    \t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\
    \t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\
    \t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword\
    \ + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax\
    \ < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t\
    \  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags,\
    \ ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen]\
    \ = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\
    \t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t\
    // valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound\
    \ = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\
    \t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to\
    \ avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\
    \t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\
    \t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same\
    \ NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t \
    \   sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t\
    {\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\
    \t\t// If we're going to split need to check that the\n\t\t\t// words so far are\
    \ valid for compounding.  If there\n\t\t\t// is only one word it must not have\
    \ the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\
    \t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\
    \t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\
    \t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\
    \t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\
    \t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\
    \n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang,\
    \ newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\
    \t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack,\
    \ depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\
    \t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen,\
    \ tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth],\
    \ \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\
    #endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags\
    \ = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\
    \n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword\
    \ when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword,\
    \ \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff\
    \ = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the\
    \ badword has a non-word character at this\n\t\t\t// position skip it.  That means\
    \ replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\
    \t// character when the word ends.  But only when the\n\t\t\t// good word can\
    \ end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t\
    \       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\
    \t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\
    \t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t  \
    \  if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\
    \t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx,\
    \ l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\
    \t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\
    \t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound\
    \ flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t\
    // may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\
    \t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\
    \t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx,\
    \ su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags\
    \ = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\
    \n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If\
    \ there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\
    \t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth\
    \ = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state\
    \ = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase\
    \ STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound\
    \ word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking\
    \ for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\
    \n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs\
    \ = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes\
    \ in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx]\
    \ == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use\
    \ STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\
    \tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\
    \t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes\
    \ at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\"\
    \ is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\
    \t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\
    \t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\t\
    else\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\t\
    arridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one\
    \ level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust\
    \ the score.  But don't even try\n\t\t// when the byte was already changed.  And\
    \ don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper\
    \ than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t||\
    \ (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\
    \t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    ||\
    \ (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\
    \t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth,\
    \ newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\
    \t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c\
    \ to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx],\
    \ c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\
    \t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n\
    #endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx]\
    \ != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t \
    \   sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\t\
    sp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte\
    \ characters are a bit complicated to\n\t\t\t// handle: They differ when any of\
    \ the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif\
    \ (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx\
    \ = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart\
    \ = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t\
    \       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\
    \t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad\
    \ word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\
    \t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff ==\
    \ DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\
    \t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\
    \t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\
    \t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST\
    \ to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\
    \t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t\
    \   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\
    \t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t\
    \  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score\
    \ from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\
    \t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\
    \    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\
    \t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t\
    \    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\
    \t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen\
    \ > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\
    \t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\
    \t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count\
    \ that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t\
    }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\
    \t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the\
    \ score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but\
    \ does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\
    \t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\
    \t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting\
    \ a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t\
    \    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the\
    \ score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's\
    \ slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\
    \t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\
    \t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t   \
    \ }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a\
    \ multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if\
    \ (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\
    \tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one\
    \ character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t \
    \   sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold\
    \ && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at\
    \ the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore\
    \ = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx]\
    \ != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\t\
    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character\
    \ we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags\
    \ |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance\
    \ over the character in fword[].  Give a bonus to the\n\t\t// score if the same\
    \ character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold\
    \ tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\
    \t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword\
    \ + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score\
    \ -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\
    \t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx\
    \ + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\t\
    break;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags\
    \ & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't\
    \ make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL\
    \ bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi\
    \ > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\
    \t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t   \
    \ break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found\
    \ a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state =\
    \ STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\
    \n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat\
    \ this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\
    \t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node,\
    \ go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\
    \t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    //\
    \ - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the\
    \ word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\
    \t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\
    \t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\
    \t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t \
    \   if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\
    \t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++]\
    \ = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl =\
    \ MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following\
    \ bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\
    \t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx\
    \ = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t \
    \   fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was\
    \ the same, thus doubling a\n\t\t    // character, give a bonus to the score.\
    \  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t\
    \    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen\
    \ - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\
    \t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"\
    12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards\
    \ at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t\
    \    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\t\
    PROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\
    \n\t    // Don't swap if the first character is not a word character.\n\t    //\
    \ SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p,\
    \ curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\
    \t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\
    \t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if\
    \ (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap\
    \ non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\
    \t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p\
    \ + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t \
    \   c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't\
    \ swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical,\
    \ swap won't do anything.\n\t    // Also get here if the second char is not a\
    \ word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su,\
    \ stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n\
    #ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\"\
    ,\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\
    \t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p,\
    \ p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t  \
    \  p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t  \
    \  }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t \
    \   break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\"\
    \ -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\
    \tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p\
    \ + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc\
    \ = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase\
    \ STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We\
    \ change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\
    \t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\
    \t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p\
    \ + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3\
    \ = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n\
    \ + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold\
    \ && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\
    \t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical:\
    \ \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP:\
    \ \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus\
    \ skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here\
    \ when the third character is not a word character.\n\t    // Second character\
    \ may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t\
    \    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack,\
    \ depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\
    \t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t \
    \   mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t\
    \    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] =\
    \ c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t \
    \   else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\
    \t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"\
    321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t   \
    \ {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p\
    \ + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\
    \tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2,\
    \ p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p\
    \ = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p,\
    \ curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate. \
    \ First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three\
    \ characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's\
    \ changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth,\
    \ SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\
    \t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate\
    \ left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0],\
    \ p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\
    \t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t  \
    \  n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p\
    \ + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n,\
    \ fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t\
    \    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\t\
    sp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\
    \t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t  \
    \  if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\
    \t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p +\
    \ tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc =\
    \ p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate\
    \ three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here,\
    \ it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack,\
    \ depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef\
    \ DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\
    \t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t   \
    \ c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p\
    \ + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t   \
    \ p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\
    \t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t  \
    \  if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\
    \t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p,\
    \ p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\t\
    c = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\
    \n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff\
    \ file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items\
    \ and we are not in the soundfold trie\n\t    // - the score is going to be too\
    \ high anyway\n\t    // - already applied a REP item or swapped here\n\t    if\
    \ ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP\
    \ >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\t\
    PROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\
    \n\t    // Use the first byte to quickly find the first entry that may\n\t   \
    \ // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi\
    \ = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi =\
    \ lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi <\
    \ 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\
    \t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\
    \t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items\
    \ from the .aff file.  For each match\n\t    // replace the characters and check\
    \ if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\
    \t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\
    \t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data\
    \ + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible\
    \ matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\
    \t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su,\
    \ stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n\
    #ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s\
    \ with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t \
    \   ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\
    \t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\
    \t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t   \
    \ fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t\
    \    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra\
    \ += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\
    \t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\
    \t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    //\
    \ Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\
    \t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\
    \t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\
    \t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if\
    \ (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\
    \t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\
    \t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all\
    \ possible states at this level, go up one level.\n\t    --depth;\n\n\t    if\
    \ (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t\
    // Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\
    \t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if\
    \ (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount\
    \ = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t\
    \  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t\
    \    }\n\t}\n    }\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\nsuggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t\
    *fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word\
    \ collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN\
    \ * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix\
    \ compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t \
    \     // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\t\
    compflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n\
    \    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n\
    \    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n\
    \    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n\
    \    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n\
    \    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t\
    *slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef\
    \ DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n \
    \   char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n\
    #ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\
    \n    // Go through the whole case-fold tree, try changes at each node.\n    //\
    \ \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\"\
    \ the word we are trying to match with (initially the bad\n    // word).\n   \
    \ depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\
    \n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts =\
    \ fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\
    \tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n\
    \    }\n    else\n    {\n\t// When there are postponed prefixes we need to use\
    \ these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\
    \tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\
    \tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t\
    \    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state\
    \ = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts\
    \ = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t\
    \    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The\
    \ loop may take an indefinite amount of time. Break out after some\n    // time.\n\
    \    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout,\
    \ &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round\
    \ we either:\n    // - For the current state try one operation, advance \"ts_curi\"\
    ,\n    //   increase \"depth\".\n    // - When a state is done go to the next,\
    \ set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n\
    \    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\
    \t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal\
    \ with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx =\
    \ sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\
    \t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current\
    \ byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip\
    \ over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx\
    \ + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL\
    \ bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end\
    \ of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\
    \tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\
    \t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t\
    \    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\
    \t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\t\
    n = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr\
    \ + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\
    \t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth],\
    \ \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\
    \t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t   \
    \ byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t   \
    \ // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word()\
    \ works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword\
    \ + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t \
    \   sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\
    \t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\
    \t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\
    \t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t\
    // eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words\
    \ with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t\
    \    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t \
    \      ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword\
    \ + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth\
    \ <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\
    \t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check\
    \ that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length\
    \ of the NULs in the prefix.  If there are\n\t\t// none this must be the first\
    \ try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen\
    \ = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\
    \t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t  \
    \     tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\
    \n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\
    \t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and\
    \ compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember\
    \ that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound\
    \ flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check\
    \ NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending\
    \ another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit &&\
    \ fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends =\
    \ FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok\
    \ = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\
    \t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t\
    \    // change in this word (it was correct) add the first word\n\t\t    // as\
    \ a suggestion.  If this word was corrected too, we\n\t\t    // need to check\
    \ if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\
    \t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\
    \t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx)\
    \ == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore =\
    \ score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\
    \t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score\
    \ isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su,\
    \ &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t   \
    \ newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t\
    \    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this\
    \ word.  If this\n\t\t    // word does not support compounding then give up\n\t\
    \t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\
    \t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\
    \t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte\
    \ chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\
    \t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\
    \t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen]\
    \ = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\
    \t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\
    \t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN\
    \  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\
    \t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if\
    \ (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) !=\
    \ NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang,\
    \ p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not\
    \ allowed.  But it may still be\n\t\t\t    // possible if we add another (short)\
    \ word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to\
    \ last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t\
    \    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper\
    \ case in preword.\n\t    // If there is a word from a previous split, append.\n\
    \t    // For the soundfold tree don't change the case, simply append.\n\t    if\
    \ (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\
    \t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case\
    \ tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword\
    \ + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the\
    \ badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the\
    \ badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\
    \t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\
    \t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word\
    \ after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p,\
    \ curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\
    \t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\
    \t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t\
    // word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su,\
    \ preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen\
    \ == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\
    \t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog\
    \ == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try\
    \ compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore\
    \ = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\
    \tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region)\
    \ == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t   \
    \ newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\
    \t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\
    \t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if\
    \ (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\
    \t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n\
    #ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\
    \t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought\
    \ us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j\
    \ < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\
    \t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t   \
    \ // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su,\
    \ preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\
    \t    // Give a penalty when changing non-word char to word\n\t\t    // char,\
    \ e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword,\
    \ p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\
    \t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p,\
    \ curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give\
    \ a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\
    \t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\
    \t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score\
    \ isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su,\
    \ &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score,\
    \ 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\
    \t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    //\
    \ upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t\
    \    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword\
    \ + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\
    \t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\
    \t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\
    \t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t  \
    \  }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >=\
    \ sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\
    \t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\
    \t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\
    \t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for\
    \ \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a\
    \ split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx\
    \ - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here\
    \ in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the\
    \ word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting\
    \ a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\
    \t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the\
    \ next word is valid.\n\t\t// 2. The badword does end, but it was due to a change\
    \ (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//\
    \    following word is valid.\n\t\t// 3. The badword and the word in the tree\
    \ end.  It may still\n\t\t//    be possible to compound another (short) word.\n\
    \t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\
    \t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\
    \t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\
    \t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword\
    \ + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax\
    \ < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t\
    \  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags,\
    \ ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen]\
    \ = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\
    \t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t\
    // valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound\
    \ = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\
    \t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to\
    \ avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\
    \t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\
    \t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same\
    \ NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t \
    \   sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t\
    {\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\
    \t\t// If we're going to split need to check that the\n\t\t\t// words so far are\
    \ valid for compounding.  If there\n\t\t\t// is only one word it must not have\
    \ the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\
    \t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\
    \t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\
    \t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\
    \t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\
    \t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\
    \n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang,\
    \ newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\
    \t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack,\
    \ depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\
    \t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen,\
    \ tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth],\
    \ \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\
    #endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags\
    \ = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\
    \n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword\
    \ when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword,\
    \ \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff\
    \ = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the\
    \ badword has a non-word character at this\n\t\t\t// position skip it.  That means\
    \ replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\
    \t// character when the word ends.  But only when the\n\t\t\t// good word can\
    \ end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t\
    \       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\
    \t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\
    \t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t  \
    \  if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\
    \t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx,\
    \ l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\
    \t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\
    \t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound\
    \ flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t\
    // may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\
    \t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\
    \t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx,\
    \ su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags\
    \ = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\
    \n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If\
    \ there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\
    \t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth\
    \ = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state\
    \ = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase\
    \ STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound\
    \ word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking\
    \ for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\
    \n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs\
    \ = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes\
    \ in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx]\
    \ == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use\
    \ STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\
    \tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\
    \t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes\
    \ at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\"\
    \ is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\
    \t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\
    \t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\t\
    else\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\t\
    arridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one\
    \ level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust\
    \ the score.  But don't even try\n\t\t// when the byte was already changed.  And\
    \ don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper\
    \ than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t||\
    \ (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\
    \t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    ||\
    \ (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\
    \t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth,\
    \ newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\
    \t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c\
    \ to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx],\
    \ c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\
    \t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n\
    #endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx]\
    \ != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t \
    \   sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\t\
    sp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte\
    \ characters are a bit complicated to\n\t\t\t// handle: They differ when any of\
    \ the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif\
    \ (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx\
    \ = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart\
    \ = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t\
    \       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\
    \t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad\
    \ word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\
    \t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff ==\
    \ DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\
    \t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\
    \t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\
    \t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST\
    \ to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\
    \t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t\
    \   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\
    \t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t\
    \  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score\
    \ from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\
    \t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\
    \    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\
    \t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t\
    \    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\
    \t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen\
    \ > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\
    \t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\
    \t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count\
    \ that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t\
    }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\
    \t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the\
    \ score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but\
    \ does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\
    \t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\
    \t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting\
    \ a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t\
    \    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the\
    \ score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's\
    \ slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\
    \t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\
    \t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t   \
    \ }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a\
    \ multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if\
    \ (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\
    \tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one\
    \ character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t \
    \   sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold\
    \ && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at\
    \ the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore\
    \ = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx]\
    \ != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\t\
    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character\
    \ we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags\
    \ |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance\
    \ over the character in fword[].  Give a bonus to the\n\t\t// score if the same\
    \ character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold\
    \ tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\
    \t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword\
    \ + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score\
    \ -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\
    \t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx\
    \ + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\t\
    break;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags\
    \ & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't\
    \ make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL\
    \ bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi\
    \ > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\
    \t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t   \
    \ break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found\
    \ a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state =\
    \ STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\
    \n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat\
    \ this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\
    \t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node,\
    \ go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\
    \t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    //\
    \ - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the\
    \ word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\
    \t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\
    \t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\
    \t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t \
    \   if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\
    \t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++]\
    \ = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl =\
    \ MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following\
    \ bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\
    \t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx\
    \ = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t \
    \   fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was\
    \ the same, thus doubling a\n\t\t    // character, give a bonus to the score.\
    \  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t\
    \    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen\
    \ - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\
    \t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"\
    12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards\
    \ at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t\
    \    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\t\
    PROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\
    \n\t    // Don't swap if the first character is not a word character.\n\t    //\
    \ SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p,\
    \ curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\
    \t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\
    \t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if\
    \ (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap\
    \ non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\
    \t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p\
    \ + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t \
    \   c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't\
    \ swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical,\
    \ swap won't do anything.\n\t    // Also get here if the second char is not a\
    \ word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su,\
    \ stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n\
    #ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\"\
    ,\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\
    \t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p,\
    \ p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t  \
    \  p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t  \
    \  }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t \
    \   break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\"\
    \ -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\
    \tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p\
    \ + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc\
    \ = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase\
    \ STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We\
    \ change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\
    \t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\
    \t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p\
    \ + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3\
    \ = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n\
    \ + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold\
    \ && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\
    \t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical:\
    \ \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP:\
    \ \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus\
    \ skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here\
    \ when the third character is not a word character.\n\t    // Second character\
    \ may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t\
    \    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack,\
    \ depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\
    \t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t \
    \   mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t\
    \    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] =\
    \ c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t \
    \   else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\
    \t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"\
    321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t   \
    \ {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p\
    \ + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\
    \tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2,\
    \ p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p\
    \ = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p,\
    \ curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate. \
    \ First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three\
    \ characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's\
    \ changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth,\
    \ SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\
    \t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate\
    \ left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0],\
    \ p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\
    \t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t  \
    \  n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p\
    \ + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n,\
    \ fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t\
    \    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\t\
    sp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\
    \t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t  \
    \  if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\
    \t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p +\
    \ tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc =\
    \ p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate\
    \ three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here,\
    \ it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack,\
    \ depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef\
    \ DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\
    \t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t   \
    \ c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p\
    \ + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t   \
    \ p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\
    \t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t  \
    \  if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\
    \t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p,\
    \ p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\t\
    c = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\
    \n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff\
    \ file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items\
    \ and we are not in the soundfold trie\n\t    // - the score is going to be too\
    \ high anyway\n\t    // - already applied a REP item or swapped here\n\t    if\
    \ ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP\
    \ >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\t\
    PROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\
    \n\t    // Use the first byte to quickly find the first entry that may\n\t   \
    \ // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi\
    \ = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi =\
    \ lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi <\
    \ 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\
    \t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\
    \t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items\
    \ from the .aff file.  For each match\n\t    // replace the characters and check\
    \ if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\
    \t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\
    \t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data\
    \ + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible\
    \ matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\
    \t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su,\
    \ stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n\
    #ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s\
    \ with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t \
    \   ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\
    \t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\
    \t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t   \
    \ fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t\
    \    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra\
    \ += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\
    \t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\
    \t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    //\
    \ Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\
    \t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\
    \t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\
    \t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if\
    \ (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\
    \t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\
    \t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all\
    \ possible states at this level, go up one level.\n\t    --depth;\n\n\t    if\
    \ (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t\
    // Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\
    \t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if\
    \ (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount\
    \ = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t\
    \  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t\
    \    }\n\t}\n    }\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\nsuggest_trie_walk(\n    suginfo_T\t*su,\n\
    \    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\t\
    tword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n\
    \    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t \
    \     // concatenation of prefix compound\n\t\t\t\t      // words and split word.\
    \  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\
    \t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for\
    \ each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n \
    \   char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\
    \tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t\
    *gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n\
    \    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[]\
    \ from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n\
    \    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the\
    \ change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n \
    \   int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n\
    #endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree,\
    \ try changes at each node.\n    // \"tword[]\" contains the word collected from\
    \ nodes in the tree.\n    // \"fword[]\" the word we are trying to match with\
    \ (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n   \
    \ CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t//\
    \ Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs\
    \ = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t//\
    \ When there are postponed prefixes we need to use these first.  At\n\t// the\
    \ end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\
    \tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\
    \tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth\
    \ = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix\
    \ first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n\
    \    // The loop may take an indefinite amount of time. Break out after some\n\
    \    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout,\
    \ &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round\
    \ we either:\n    // - For the current state try one operation, advance \"ts_curi\"\
    ,\n    //   increase \"depth\".\n    // - When a state is done go to the next,\
    \ set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n\
    \    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\
    \t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal\
    \ with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx =\
    \ sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\
    \t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current\
    \ byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip\
    \ over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx\
    \ + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL\
    \ bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end\
    \ of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\
    \tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\
    \t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t\
    \    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\
    \t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\t\
    n = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr\
    \ + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\
    \t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth],\
    \ \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\
    \t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t   \
    \ byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t   \
    \ // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word()\
    \ works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword\
    \ + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t \
    \   sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\
    \t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\
    \t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\
    \t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t\
    // eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words\
    \ with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t\
    \    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t \
    \      ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword\
    \ + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth\
    \ <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\
    \t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check\
    \ that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length\
    \ of the NULs in the prefix.  If there are\n\t\t// none this must be the first\
    \ try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen\
    \ = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\
    \t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t  \
    \     tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\
    \n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\
    \t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and\
    \ compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember\
    \ that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound\
    \ flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check\
    \ NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending\
    \ another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit &&\
    \ fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends =\
    \ FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok\
    \ = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\
    \t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t\
    \    // change in this word (it was correct) add the first word\n\t\t    // as\
    \ a suggestion.  If this word was corrected too, we\n\t\t    // need to check\
    \ if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\
    \t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\
    \t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx)\
    \ == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore =\
    \ score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\
    \t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score\
    \ isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su,\
    \ &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t   \
    \ newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t\
    \    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this\
    \ word.  If this\n\t\t    // word does not support compounding then give up\n\t\
    \t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\
    \t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\
    \t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte\
    \ chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\
    \t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\
    \t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen]\
    \ = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\
    \t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\
    \t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN\
    \  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\
    \t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if\
    \ (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) !=\
    \ NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang,\
    \ p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not\
    \ allowed.  But it may still be\n\t\t\t    // possible if we add another (short)\
    \ word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to\
    \ last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t\
    \    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper\
    \ case in preword.\n\t    // If there is a word from a previous split, append.\n\
    \t    // For the soundfold tree don't change the case, simply append.\n\t    if\
    \ (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\
    \t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case\
    \ tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword\
    \ + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the\
    \ badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the\
    \ badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\
    \t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\
    \t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word\
    \ after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p,\
    \ curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\
    \t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\
    \t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t\
    // word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su,\
    \ preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen\
    \ == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\
    \t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog\
    \ == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try\
    \ compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore\
    \ = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\
    \tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region)\
    \ == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t   \
    \ newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\
    \t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\
    \t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if\
    \ (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\
    \t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n\
    #ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\
    \t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought\
    \ us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j\
    \ < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\
    \t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t   \
    \ // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su,\
    \ preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\
    \t    // Give a penalty when changing non-word char to word\n\t\t    // char,\
    \ e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword,\
    \ p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\
    \t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p,\
    \ curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give\
    \ a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\
    \t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\
    \t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score\
    \ isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su,\
    \ &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score,\
    \ 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\
    \t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    //\
    \ upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t\
    \    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword\
    \ + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\
    \t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\
    \t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\
    \t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t  \
    \  }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >=\
    \ sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\
    \t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\
    \t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\
    \t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for\
    \ \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a\
    \ split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx\
    \ - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here\
    \ in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the\
    \ word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting\
    \ a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\
    \t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the\
    \ next word is valid.\n\t\t// 2. The badword does end, but it was due to a change\
    \ (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//\
    \    following word is valid.\n\t\t// 3. The badword and the word in the tree\
    \ end.  It may still\n\t\t//    be possible to compound another (short) word.\n\
    \t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\
    \t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\
    \t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\
    \t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword\
    \ + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax\
    \ < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t\
    \  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags,\
    \ ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen]\
    \ = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\
    \t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t\
    // valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound\
    \ = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\
    \t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to\
    \ avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\
    \t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\
    \t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same\
    \ NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t \
    \   sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t\
    {\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\
    \t\t// If we're going to split need to check that the\n\t\t\t// words so far are\
    \ valid for compounding.  If there\n\t\t\t// is only one word it must not have\
    \ the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\
    \t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\
    \t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\
    \t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\
    \t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\
    \t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\
    \n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang,\
    \ newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\
    \t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack,\
    \ depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\
    \t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen,\
    \ tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth],\
    \ \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\
    #endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags\
    \ = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\
    \n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword\
    \ when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword,\
    \ \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff\
    \ = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the\
    \ badword has a non-word character at this\n\t\t\t// position skip it.  That means\
    \ replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\
    \t// character when the word ends.  But only when the\n\t\t\t// good word can\
    \ end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t\
    \       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\
    \t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\
    \t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t  \
    \  if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\
    \t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx,\
    \ l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\
    \t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\
    \t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound\
    \ flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t\
    // may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\
    \t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth\
    \ = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\
    \t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx,\
    \ su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags\
    \ = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\
    \n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If\
    \ there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\
    \t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth\
    \ = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state\
    \ = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase\
    \ STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound\
    \ word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking\
    \ for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\
    \n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs\
    \ = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes\
    \ in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx]\
    \ == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use\
    \ STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\
    \tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\
    \t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes\
    \ at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\"\
    \ is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\
    \t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\
    \t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\t\
    else\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\t\
    arridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one\
    \ level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust\
    \ the score.  But don't even try\n\t\t// when the byte was already changed.  And\
    \ don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper\
    \ than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t||\
    \ (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\
    \t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    ||\
    \ (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\
    \t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth,\
    \ newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\
    \t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c\
    \ to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx],\
    \ c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\
    \t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n\
    #endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx]\
    \ != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t \
    \   sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\t\
    sp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte\
    \ characters are a bit complicated to\n\t\t\t// handle: They differ when any of\
    \ the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif\
    \ (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx\
    \ = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart\
    \ = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t\
    \       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\
    \t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad\
    \ word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\
    \t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff ==\
    \ DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\
    \t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\
    \t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\
    \t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST\
    \ to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\
    \t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t\
    \   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\
    \t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t\
    \  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score\
    \ from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\
    \t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\
    \    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\
    \t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t\
    \    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\
    \t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen\
    \ > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\
    \t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\
    \t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count\
    \ that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t\
    }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\
    \t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the\
    \ score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but\
    \ does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\
    \t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\
    \t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting\
    \ a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t\
    \    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the\
    \ score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's\
    \ slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\
    \t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\
    \t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t   \
    \ }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a\
    \ multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if\
    \ (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\
    \tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one\
    \ character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t \
    \   sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold\
    \ && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at\
    \ the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore\
    \ = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx]\
    \ != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\t\
    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character\
    \ we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags\
    \ |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance\
    \ over the character in fword[].  Give a bonus to the\n\t\t// score if the same\
    \ character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold\
    \ tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\
    \t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword\
    \ + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score\
    \ -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\
    \t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx\
    \ + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\t\
    break;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags\
    \ & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't\
    \ make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL\
    \ bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi\
    \ > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\
    \t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t   \
    \ break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found\
    \ a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state =\
    \ STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\
    \n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat\
    \ this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\
    \t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node,\
    \ go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\
    \t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    //\
    \ - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the\
    \ word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\
    \t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\
    \t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\
    \t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t \
    \   if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\
    \t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++]\
    \ = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl =\
    \ MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following\
    \ bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\
    \t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx\
    \ = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t \
    \   fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was\
    \ the same, thus doubling a\n\t\t    // character, give a bonus to the score.\
    \  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t\
    \    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen\
    \ - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\
    \t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"\
    12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards\
    \ at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t\
    \    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\t\
    PROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\
    \n\t    // Don't swap if the first character is not a word character.\n\t    //\
    \ SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p,\
    \ curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\
    \t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\
    \t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if\
    \ (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap\
    \ non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\
    \t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p\
    \ + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t \
    \   c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't\
    \ swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical,\
    \ swap won't do anything.\n\t    // Also get here if the second char is not a\
    \ word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su,\
    \ stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n\
    #ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\"\
    ,\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\
    \t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p,\
    \ p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t  \
    \  p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t  \
    \  }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t \
    \   break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\"\
    \ -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\
    \tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p\
    \ + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc\
    \ = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase\
    \ STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We\
    \ change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\
    \t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\
    \t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p\
    \ + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3\
    \ = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n\
    \ + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold\
    \ && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\
    \t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical:\
    \ \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP:\
    \ \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus\
    \ skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here\
    \ when the third character is not a word character.\n\t    // Second character\
    \ may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\
    \t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t\
    \    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack,\
    \ depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\
    \t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t \
    \   mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t\
    \    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] =\
    \ c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t \
    \   else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\
    \t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"\
    321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t   \
    \ {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p\
    \ + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\
    \tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2,\
    \ p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p\
    \ = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p,\
    \ curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate. \
    \ First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three\
    \ characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's\
    \ changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth,\
    \ SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\
    \t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate\
    \ left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0],\
    \ p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\
    \t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t  \
    \  n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p\
    \ + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n,\
    \ fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t\
    \    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx\
    \ + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\t\
    sp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\
    \t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t  \
    \  if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\
    \t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p +\
    \ tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc =\
    \ p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate\
    \ three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here,\
    \ it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack,\
    \ depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef\
    \ DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth],\
    \ \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\
    \t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\
    \t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t   \
    \ c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p\
    \ + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t   \
    \ p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\
    \t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\
    \t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t  \
    \  if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\
    \t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p,\
    \ p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\t\
    c = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\
    \n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff\
    \ file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items\
    \ and we are not in the soundfold trie\n\t    // - the score is going to be too\
    \ high anyway\n\t    // - already applied a REP item or swapped here\n\t    if\
    \ ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP\
    \ >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\t\
    PROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\
    \n\t    // Use the first byte to quickly find the first entry that may\n\t   \
    \ // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi\
    \ = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi =\
    \ lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi <\
    \ 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\
    \t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\
    \t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items\
    \ from the .aff file.  For each match\n\t    // replace the characters and check\
    \ if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\
    \t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\
    \t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data\
    \ + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible\
    \ matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\
    \t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su,\
    \ stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n\
    #ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s\
    \ with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t \
    \   ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\
    \t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\
    \t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t   \
    \ fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t\
    \    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra\
    \ += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry\
    \ = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\
    \t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\
    \t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state\
    \ = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    //\
    \ Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\
    \t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\
    \t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\
    \t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if\
    \ (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\
    \t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\
    \t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all\
    \ possible states at this level, go up one level.\n\t    --depth;\n\n\t    if\
    \ (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t\
    // Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\
    \t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if\
    \ (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount\
    \ = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t\
    \  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t\
    \    }\n\t}\n    }\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 200323
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
