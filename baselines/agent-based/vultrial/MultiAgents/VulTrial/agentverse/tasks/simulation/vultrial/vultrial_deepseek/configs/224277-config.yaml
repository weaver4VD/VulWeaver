agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nsetup_seccomp\
    \ (FlatpakBwrap   *bwrap,\n               const char     *arch,\n            \
    \   gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n\
    \               GError        **error)\n{\n  gboolean multiarch = (run_flags &\
    \ FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL)\
    \ != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp\
    \ = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a\
    \ number of different Linux container\n   * implementations.  That will likely\
    \ continue for long into the\n   * future.  But we can still try to share code,\
    \ and it's important\n   * to do so because it affects what library and application\
    \ writers\n   * can do, and we should support code portability between different\n\
    \   * container tools.\n   *\n   * This syscall blocklist is copied from linux-user-chroot,\
    \ which was in turn\n   * clearly influenced by the Sandstorm.io blocklist.\n\
    \   *\n   * If you make any changes here, I suggest sending the changes along\n\
    \   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an\
    \ appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n\
    \   *\n   * A non-exhaustive list of links to container tooling that might\n \
    \  * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n\
    \   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n\
    \   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n\
    \   *    in src/setup-seccomp.c\n   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n\
    \   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n \
    \  *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int        \
    \          scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n\
    \  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n\
    \    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't\
    \ allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit\
    \ code is unnecessary in the sandbox, and modify_ldt is a\n       historic source\
    \ of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n\
    \    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\
    \n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key),\
    \ EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\
    \n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS\
    \ (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy),\
    \ EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace\
    \ setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n\
    \    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (umount), EPERM},\n    {SCMP_SYS\
    \ (umount2), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n    {SCMP_SYS (chroot),\
    \ EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n\
    \    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and\
    \ flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone),\
    \ EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n\
    \    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0\
    \ (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't\
    \ allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS\
    \ (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\
    \n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n\
    \     * the flags are OK, so we have no choice but to block clone3().\n     *\
    \ Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q;\
    \ see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3),\
    \ ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's\
    \ no\n     * legitimate reason to do these in the sandbox, so block all of them\n\
    \     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q)\
    \ */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n\
    \    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS\
    \ (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr),\
    \ ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int  \
    \                errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[]\
    \ = {\n    /* Profiling operations; we expect these to be done by tools from outside\n\
    \     * the sandbox.  In particular perf has been the source of many CVEs.\n \
    \    */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch\
    \ to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0\
    \ (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n\
    \  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int\
    \             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[]\
    \ = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL,\
    \ 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n  \
    \  { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH\
    \ },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf\
    \  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n\
    \    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize\
    \ seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id =\
    \ 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"\
    i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n    \
    \  else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n\
    \          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else\
    \ if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n\
    \        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\"\
    ) == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches\
    \ = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really\
    \ need to handle arches on multiarch systems.\n       * If only one arch is supported\
    \ the default is fine */\n      if (arch_id != 0)\n        {\n          /* This\
    \ *adds* the target arch, instead of replacing the\n             native one. This\
    \ is not ideal, because we'd like to only\n             allow the target arch,\
    \ but we can't really disallow the\n             native arch at this point, because\
    \ then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add\
    \ (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return\
    \ flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture\
    \ to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n\
    \            {\n              for (i = 0; extra_arches[i] != 0; i++)\n       \
    \         {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n\
    \                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error\
    \ (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture\
    \ to seccomp filter\"));\n                }\n            }\n        }\n    }\n\
    \n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We\
    \ do want them to be used by desktop apps, but they could also perhaps\n   * leak\
    \ system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS\
    \ (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n\
    \      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail\
    \ (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n\
    \        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n\
    \      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall,\
    \ 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return\
    \ flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall\
    \ %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS\
    \ (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n\
    \          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail\
    \ (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n\
    \            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1,\
    \ *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add\
    \ (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r ==\
    \ -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error,\
    \ FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n   \
    \     }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures\
    \ here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp\
    \ doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n\
    \  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist);\
    \ i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int\
    \ disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n   \
    \       (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n\
    \        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed\
    \ < family; disallowed++)\n        {\n          /* Blocklist the in-between valid\
    \ families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT),\
    \ SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n     \
    \ last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact\
    \ (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE,\
    \ last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR\
    \ | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf\
    \ (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\
    \ _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n\
    \  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"\
    --seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\nsetup_seccomp (FlatpakBwrap \
    \  *bwrap,\n               const char     *arch,\n               gulong      \
    \    allowed_personality,\n               FlatpakRunFlags run_flags,\n       \
    \        GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH)\
    \ != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup\
    \ (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON\
    \ CODE SHARING\n   *\n   * There are today a number of different Linux container\n\
    \   * implementations.  That will likely continue for long into the\n   * future.\
    \  But we can still try to share code, and it's important\n   * to do so because\
    \ it affects what library and application writers\n   * can do, and we should\
    \ support code portability between different\n   * container tools.\n   *\n  \
    \ * This syscall blocklist is copied from linux-user-chroot, which was in turn\n\
    \   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make\
    \ any changes here, I suggest sending the changes along\n   * to other sandbox\
    \ maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n\
    \   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive\
    \ list of links to container tooling that might\n   * want to share this blocklist:\n\
    \   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n\
    \   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n\
    \   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n\
    \   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n\
    \   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n \
    \  *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int        \
    \          scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n\
    \  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n\
    \    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't\
    \ allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit\
    \ code is unnecessary in the sandbox, and modify_ldt is a\n       historic source\
    \ of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n\
    \    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\
    \n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key),\
    \ EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\
    \n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS\
    \ (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy),\
    \ EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace\
    \ setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n\
    \    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (umount), EPERM},\n    {SCMP_SYS\
    \ (umount2), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n    {SCMP_SYS (chroot),\
    \ EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n\
    \    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and\
    \ flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone),\
    \ EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n\
    \    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0\
    \ (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't\
    \ allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS\
    \ (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\
    \n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n\
    \     * the flags are OK, so we have no choice but to block clone3().\n     *\
    \ Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q;\
    \ see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3),\
    \ ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's\
    \ no\n     * legitimate reason to do these in the sandbox, so block all of them\n\
    \     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q)\
    \ */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n\
    \    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS\
    \ (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr),\
    \ ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int  \
    \                errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[]\
    \ = {\n    /* Profiling operations; we expect these to be done by tools from outside\n\
    \     * the sandbox.  In particular perf has been the source of many CVEs.\n \
    \    */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch\
    \ to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0\
    \ (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n\
    \  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int\
    \             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[]\
    \ = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL,\
    \ 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n  \
    \  { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH\
    \ },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf\
    \  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n\
    \    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize\
    \ seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id =\
    \ 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"\
    i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n    \
    \  else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n\
    \          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else\
    \ if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n\
    \        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\"\
    ) == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches\
    \ = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really\
    \ need to handle arches on multiarch systems.\n       * If only one arch is supported\
    \ the default is fine */\n      if (arch_id != 0)\n        {\n          /* This\
    \ *adds* the target arch, instead of replacing the\n             native one. This\
    \ is not ideal, because we'd like to only\n             allow the target arch,\
    \ but we can't really disallow the\n             native arch at this point, because\
    \ then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add\
    \ (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return\
    \ flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture\
    \ to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n\
    \            {\n              for (i = 0; extra_arches[i] != 0; i++)\n       \
    \         {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n\
    \                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error\
    \ (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture\
    \ to seccomp filter\"));\n                }\n            }\n        }\n    }\n\
    \n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We\
    \ do want them to be used by desktop apps, but they could also perhaps\n   * leak\
    \ system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS\
    \ (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n\
    \      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail\
    \ (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n\
    \        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n\
    \      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall,\
    \ 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return\
    \ flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall\
    \ %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS\
    \ (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n\
    \          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail\
    \ (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n\
    \            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1,\
    \ *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add\
    \ (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r ==\
    \ -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error,\
    \ FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n   \
    \     }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures\
    \ here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp\
    \ doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n\
    \  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist);\
    \ i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int\
    \ disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n   \
    \       (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n\
    \        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed\
    \ < family; disallowed++)\n        {\n          /* Blocklist the in-between valid\
    \ families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT),\
    \ SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n     \
    \ last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact\
    \ (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE,\
    \ last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR\
    \ | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf\
    \ (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\
    \ _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n\
    \  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"\
    --seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\nsetup_seccomp (FlatpakBwrap   *bwrap,\n               const char  \
    \   *arch,\n               gulong          allowed_personality,\n            \
    \   FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean\
    \ multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel\
    \ = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp)))\
    \ scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n\
    \   * There are today a number of different Linux container\n   * implementations.\
    \  That will likely continue for long into the\n   * future.  But we can still\
    \ try to share code, and it's important\n   * to do so because it affects what\
    \ library and application writers\n   * can do, and we should support code portability\
    \ between different\n   * container tools.\n   *\n   * This syscall blocklist\
    \ is copied from linux-user-chroot, which was in turn\n   * clearly influenced\
    \ by the Sandstorm.io blocklist.\n   *\n   * If you make any changes here, I suggest\
    \ sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp\
    \ list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n\
    \   *\n   * A non-exhaustive list of links to container tooling that might\n \
    \  * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n\
    \   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n\
    \   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n\
    \   *    in src/setup-seccomp.c\n   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n\
    \   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n \
    \  *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int        \
    \          scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n\
    \  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n\
    \    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't\
    \ allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit\
    \ code is unnecessary in the sandbox, and modify_ldt is a\n       historic source\
    \ of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n\
    \    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\
    \n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key),\
    \ EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\
    \n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS\
    \ (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy),\
    \ EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace\
    \ setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n\
    \    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (umount), EPERM},\n    {SCMP_SYS\
    \ (umount2), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n    {SCMP_SYS (chroot),\
    \ EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n\
    \    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and\
    \ flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone),\
    \ EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n\
    \    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0\
    \ (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't\
    \ allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS\
    \ (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\
    \n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n\
    \     * the flags are OK, so we have no choice but to block clone3().\n     *\
    \ Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q;\
    \ see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3),\
    \ ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's\
    \ no\n     * legitimate reason to do these in the sandbox, so block all of them\n\
    \     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q)\
    \ */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n\
    \    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS\
    \ (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr),\
    \ ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int  \
    \                errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[]\
    \ = {\n    /* Profiling operations; we expect these to be done by tools from outside\n\
    \     * the sandbox.  In particular perf has been the source of many CVEs.\n \
    \    */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch\
    \ to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0\
    \ (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n\
    \  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int\
    \             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[]\
    \ = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL,\
    \ 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n  \
    \  { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH\
    \ },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf\
    \  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n\
    \    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize\
    \ seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id =\
    \ 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"\
    i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n    \
    \  else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n\
    \          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else\
    \ if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n\
    \        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\"\
    ) == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches\
    \ = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really\
    \ need to handle arches on multiarch systems.\n       * If only one arch is supported\
    \ the default is fine */\n      if (arch_id != 0)\n        {\n          /* This\
    \ *adds* the target arch, instead of replacing the\n             native one. This\
    \ is not ideal, because we'd like to only\n             allow the target arch,\
    \ but we can't really disallow the\n             native arch at this point, because\
    \ then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add\
    \ (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return\
    \ flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture\
    \ to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n\
    \            {\n              for (i = 0; extra_arches[i] != 0; i++)\n       \
    \         {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n\
    \                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error\
    \ (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture\
    \ to seccomp filter\"));\n                }\n            }\n        }\n    }\n\
    \n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We\
    \ do want them to be used by desktop apps, but they could also perhaps\n   * leak\
    \ system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS\
    \ (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n\
    \      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail\
    \ (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n\
    \        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n\
    \      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall,\
    \ 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return\
    \ flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall\
    \ %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS\
    \ (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n\
    \          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail\
    \ (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n\
    \            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1,\
    \ *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add\
    \ (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r ==\
    \ -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error,\
    \ FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n   \
    \     }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures\
    \ here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp\
    \ doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n\
    \  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist);\
    \ i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int\
    \ disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n   \
    \       (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n\
    \        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed\
    \ < family; disallowed++)\n        {\n          /* Blocklist the in-between valid\
    \ families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT),\
    \ SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n     \
    \ last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact\
    \ (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE,\
    \ last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR\
    \ | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf\
    \ (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\
    \ _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n\
    \  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"\
    --seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\nsetup_seccomp (FlatpakBwrap   *bwrap,\n \
    \              const char     *arch,\n               gulong          allowed_personality,\n\
    \               FlatpakRunFlags run_flags,\n               GError        **error)\n\
    {\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean\
    \ devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup\
    \ (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON\
    \ CODE SHARING\n   *\n   * There are today a number of different Linux container\n\
    \   * implementations.  That will likely continue for long into the\n   * future.\
    \  But we can still try to share code, and it's important\n   * to do so because\
    \ it affects what library and application writers\n   * can do, and we should\
    \ support code portability between different\n   * container tools.\n   *\n  \
    \ * This syscall blocklist is copied from linux-user-chroot, which was in turn\n\
    \   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make\
    \ any changes here, I suggest sending the changes along\n   * to other sandbox\
    \ maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n\
    \   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive\
    \ list of links to container tooling that might\n   * want to share this blocklist:\n\
    \   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n\
    \   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n\
    \   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n\
    \   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n\
    \   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n \
    \  *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int        \
    \          scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n\
    \  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n\
    \    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't\
    \ allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit\
    \ code is unnecessary in the sandbox, and modify_ldt is a\n       historic source\
    \ of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n\
    \    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\
    \n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key),\
    \ EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\
    \n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS\
    \ (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy),\
    \ EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace\
    \ setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n\
    \    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (umount), EPERM},\n    {SCMP_SYS\
    \ (umount2), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n    {SCMP_SYS (chroot),\
    \ EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n\
    \    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and\
    \ flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone),\
    \ EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n\
    \    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0\
    \ (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't\
    \ allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS\
    \ (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\
    \n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n\
    \     * the flags are OK, so we have no choice but to block clone3().\n     *\
    \ Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q;\
    \ see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3),\
    \ ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's\
    \ no\n     * legitimate reason to do these in the sandbox, so block all of them\n\
    \     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q)\
    \ */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n\
    \    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS\
    \ (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr),\
    \ ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int  \
    \                errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[]\
    \ = {\n    /* Profiling operations; we expect these to be done by tools from outside\n\
    \     * the sandbox.  In particular perf has been the source of many CVEs.\n \
    \    */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch\
    \ to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0\
    \ (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n\
    \  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int\
    \             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[]\
    \ = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL,\
    \ 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n  \
    \  { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH\
    \ },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf\
    \  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n\
    \    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize\
    \ seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id =\
    \ 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"\
    i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n    \
    \  else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n\
    \          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else\
    \ if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n\
    \        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\"\
    ) == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches\
    \ = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really\
    \ need to handle arches on multiarch systems.\n       * If only one arch is supported\
    \ the default is fine */\n      if (arch_id != 0)\n        {\n          /* This\
    \ *adds* the target arch, instead of replacing the\n             native one. This\
    \ is not ideal, because we'd like to only\n             allow the target arch,\
    \ but we can't really disallow the\n             native arch at this point, because\
    \ then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add\
    \ (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return\
    \ flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture\
    \ to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n\
    \            {\n              for (i = 0; extra_arches[i] != 0; i++)\n       \
    \         {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n\
    \                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error\
    \ (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture\
    \ to seccomp filter\"));\n                }\n            }\n        }\n    }\n\
    \n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We\
    \ do want them to be used by desktop apps, but they could also perhaps\n   * leak\
    \ system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS\
    \ (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n\
    \      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail\
    \ (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n\
    \        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n\
    \      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall,\
    \ 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return\
    \ flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall\
    \ %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS\
    \ (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n\
    \          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail\
    \ (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n\
    \            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1,\
    \ *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add\
    \ (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r ==\
    \ -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error,\
    \ FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n   \
    \     }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures\
    \ here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp\
    \ doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n\
    \  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist);\
    \ i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int\
    \ disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n   \
    \       (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n\
    \        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed\
    \ < family; disallowed++)\n        {\n          /* Blocklist the in-between valid\
    \ families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT),\
    \ SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n     \
    \ last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact\
    \ (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE,\
    \ last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR\
    \ | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf\
    \ (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\
    \ _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n\
    \  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"\
    --seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 224277
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
